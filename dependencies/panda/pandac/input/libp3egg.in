1478214022
3 2
8 libp3egg 4 hhEq 11 panda3d.egg 
981
1006 11 EggUserData 0 4 1987 24 EggUserData::EggUserData 0 2 1 2 22
/**
 *
 */

/**
 *
 */
96
inline EggUserData::EggUserData(void);
inline EggUserData::EggUserData(EggUserData const &copy);

1007 10 operator = 0 4 1987 23 EggUserData::operator = 0 1 3 10
/**
 *
 */
69
inline EggUserData &EggUserData::operator =(EggUserData const &copy);

1008 14 get_class_type 0 4 1987 27 EggUserData::get_class_type 0 1 4 0
52
static TypeHandle EggUserData::get_class_type(void);

1009 9 EggObject 0 4 1989 20 EggObject::EggObject 0 2 5 6 22
/**
 *
 */

/**
 *
 */
72
EggObject::EggObject(void);
EggObject::EggObject(EggObject const &copy);

1010 10 operator = 0 4 1989 21 EggObject::operator = 0 1 7 10
/**
 *
 */
56
EggObject &EggObject::operator =(EggObject const &copy);

1011 13 set_user_data 0 4 1989 24 EggObject::set_user_data 0 1 8 766
/**
 * Sets the user data associated with this object.  This may be any
 * EggUserData-derived object.  The egg library will do nothing with this
 * pointer, except to hold its reference count and return the pointer on
 * request.
 *
 * The EggObject maintains multiple different EggUserData pointers, one for
 * each unique type (as reported by get_type()).  If you know that only one
 * type of EggUserData object will be added in your application, you may use
 * the query functions that accept no parameters, but it is recommended that
 * in general you pass in the type of your particular user data, to allow
 * multiple applications to coexist in the same egg data.
 *
 * This pointer is also copied by the copy assignment operator and copy
 * constructor.
 */
54
void EggObject::set_user_data(EggUserData *user_data);

1012 13 get_user_data 0 4 1989 24 EggObject::get_user_data 0 2 9 10 228
/**
 * Returns the user data pointer most recently stored on this object, or NULL
 * if nothing was previously stored.
 */

/**
 * Returns the user data pointer of the indicated type, if it exists, or NULL
 * if it does not.
 */
112
EggUserData *EggObject::get_user_data(void) const;
EggUserData *EggObject::get_user_data(TypeHandle type) const;

1013 13 has_user_data 0 4 1989 24 EggObject::has_user_data 0 2 11 12 223
/**
 * Returns true if a generic user data pointer has recently been set and not
 * yet cleared, false otherwise.
 */

/**
 * Returns true if the user data pointer of the indicated type has been set,
 * false otherwise.
 */
96
bool EggObject::has_user_data(void) const;
bool EggObject::has_user_data(TypeHandle type) const;

1014 15 clear_user_data 0 4 1989 26 EggObject::clear_user_data 0 2 13 14 123
/**
 * Removes *all* user data pointers from the node.
 */

/**
 * Removes the user data pointer of the indicated type.
 */
88
void EggObject::clear_user_data(void);
void EggObject::clear_user_data(TypeHandle type);

1015 14 get_class_type 0 4 1989 25 EggObject::get_class_type 0 1 15 0
50
static TypeHandle EggObject::get_class_type(void);

1016 19 upcast_to_EggObject 0 12 1990 35 EggNamedObject::upcast_to_EggObject 0 1 21 39
upcast from EggNamedObject to EggObject
53
EggObject *EggNamedObject::upcast_to_EggObject(void);

1017 26 downcast_to_EggNamedObject 0 12 1989 37 EggObject::downcast_to_EggNamedObject 0 1 22 41
downcast from EggObject to EggNamedObject
60
EggNamedObject *EggObject::downcast_to_EggNamedObject(void);

1018 17 upcast_to_Namable 0 12 1990 33 EggNamedObject::upcast_to_Namable 0 1 23 37
upcast from EggNamedObject to Namable
49
Namable *EggNamedObject::upcast_to_Namable(void);

1019 26 downcast_to_EggNamedObject 0 12 1991 35 Namable::downcast_to_EggNamedObject 0 1 24 39
downcast from Namable to EggNamedObject
58
EggNamedObject *Namable::downcast_to_EggNamedObject(void);

1020 14 EggNamedObject 0 4 1990 30 EggNamedObject::EggNamedObject 0 2 16 17 22
/**
 *
 */

/**
 *
 */
135
inline EggNamedObject::EggNamedObject(std::string const &name = "");
inline EggNamedObject::EggNamedObject(EggNamedObject const &copy);

1021 10 operator = 0 4 1990 26 EggNamedObject::operator = 0 1 18 10
/**
 *
 */
78
inline EggNamedObject &EggNamedObject::operator =(EggNamedObject const &copy);

1022 6 output 0 4 1990 22 EggNamedObject::output 0 1 19 10
/**
 *
 */
48
void EggNamedObject::output(ostream &out) const;

1023 14 get_class_type 0 4 1990 30 EggNamedObject::get_class_type 0 1 20 0
55
static TypeHandle EggNamedObject::get_class_type(void);

1024 15 ~EggNamedObject 0 4 1990 31 EggNamedObject::~EggNamedObject 0 0 0
38
EggNamedObject::~EggNamedObject(void);

1025 10 operator = 0 4 1992 19 EggNode::operator = 0 1 25 10
/**
 *
 */
57
inline EggNode &EggNode::operator =(EggNode const &copy);

1026 10 get_parent 0 4 1992 19 EggNode::get_parent 0 1 26 10
/**
 *
 */
53
inline EggGroupNode *EggNode::get_parent(void) const;

1027 9 get_depth 0 4 1992 18 EggNode::get_depth 0 1 27 76
/**
 * Returns the number of nodes above this node in the egg hierarchy.
 */
42
inline int EggNode::get_depth(void) const;

1028 17 is_under_instance 0 4 1992 26 EggNode::is_under_instance 0 1 28 123
/**
 * Returns true if there is an <Instance> node somewhere in the egg tree at or
 * above this node, false otherwise.
 */
51
inline bool EggNode::is_under_instance(void) const;

1029 18 is_under_transform 0 4 1992 27 EggNode::is_under_transform 0 1 29 124
/**
 * Returns true if there is a <Transform> entry somewhere in the egg tree at
 * or above this node, false otherwise.
 */
52
inline bool EggNode::is_under_transform(void) const;

1030 14 is_local_coord 0 4 1992 23 EggNode::is_local_coord 0 1 30 189
/**
 * Returns true if this node's vertices are not in the global coordinate
 * space.  This will be the case if there was an <Instance> node under a
 * transform at or above this node.
 */
48
inline bool EggNode::is_local_coord(void) const;

1031 16 get_vertex_frame 0 4 1992 25 EggNode::get_vertex_frame 0 1 31 711
/**
 * Returns the coordinate frame of the vertices referenced by primitives at or
 * under this node.  This is not the same as get_node_frame().
 *
 * Generally, vertices in an egg file are stored in the global coordinate
 * space, regardless of the transforms defined at each node.  Thus,
 * get_vertex_frame() will usually return the identity transform (global
 * coordinate space).  However, primitives under an <Instance> entry reference
 * their vertices in the coordinate system under effect at the time of the
 * <Instance>.  Thus, nodes under an <Instance> entry may return this non-
 * identity matrix.
 *
 * Specifically, this may return a non-identity matrix only if
 * is_local_coord() is true.
 */
62
inline LMatrix4d const &EggNode::get_vertex_frame(void) const;

1032 14 get_node_frame 0 4 1992 23 EggNode::get_node_frame 0 1 32 133
/**
 * Returns the coordinate frame of the node itself.  This is simply the net
 * product of all transformations up to the root.
 */
60
inline LMatrix4d const &EggNode::get_node_frame(void) const;

1033 20 get_vertex_frame_inv 0 4 1992 29 EggNode::get_vertex_frame_inv 0 1 33 104
/**
 * Returns the inverse of the matrix returned by get_vertex_frame().  See
 * get_vertex_frame().
 */
66
inline LMatrix4d const &EggNode::get_vertex_frame_inv(void) const;

1034 18 get_node_frame_inv 0 4 1992 27 EggNode::get_node_frame_inv 0 1 34 100
/**
 * Returns the inverse of the matrix returned by get_node_frame().  See
 * get_node_frame().
 */
64
inline LMatrix4d const &EggNode::get_node_frame_inv(void) const;

1035 18 get_vertex_to_node 0 4 1992 27 EggNode::get_vertex_to_node 0 1 35 231
/**
 * Returns the transformation matrix suitable for converting the vertices as
 * read from the egg file into the coordinate space of the node.  This is the
 * same thing as:
 *
 * get_vertex_frame() * get_node_frame_inv()
 *
 */
64
inline LMatrix4d const &EggNode::get_vertex_to_node(void) const;

1036 18 get_node_to_vertex 0 4 1992 27 EggNode::get_node_to_vertex 0 1 36 263
/**
 * Returns the transformation matrix suitable for converting vertices in the
 * coordinate space of the node to the appropriate coordinate space for
 * storing in the egg file.  This is the same thing as:
 *
 * get_node_frame() * get_vertex_frame_inv()
 *
 */
64
inline LMatrix4d const &EggNode::get_node_to_vertex(void) const;

1037 20 get_vertex_frame_ptr 0 4 1992 29 EggNode::get_vertex_frame_ptr 0 1 37 120
/**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_vertex_frame() matrix.
 */
66
inline LMatrix4d const *EggNode::get_vertex_frame_ptr(void) const;

1038 18 get_node_frame_ptr 0 4 1992 27 EggNode::get_node_frame_ptr 0 1 38 118
/**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_node_frame() matrix.
 */
64
inline LMatrix4d const *EggNode::get_node_frame_ptr(void) const;

1039 24 get_vertex_frame_inv_ptr 0 4 1992 33 EggNode::get_vertex_frame_inv_ptr 0 1 39 124
/**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_vertex_frame_inv() matrix.
 */
70
inline LMatrix4d const *EggNode::get_vertex_frame_inv_ptr(void) const;

1040 22 get_node_frame_inv_ptr 0 4 1992 31 EggNode::get_node_frame_inv_ptr 0 1 40 122
/**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_node_frame_inv() matrix.
 */
68
inline LMatrix4d const *EggNode::get_node_frame_inv_ptr(void) const;

1041 22 get_vertex_to_node_ptr 0 4 1992 31 EggNode::get_vertex_to_node_ptr 0 1 41 122
/**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_vertex_to_node() matrix.
 */
68
inline LMatrix4d const *EggNode::get_vertex_to_node_ptr(void) const;

1042 22 get_node_to_vertex_ptr 0 4 1992 31 EggNode::get_node_to_vertex_ptr 0 1 42 122
/**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_node_to_vertex() matrix.
 */
68
inline LMatrix4d const *EggNode::get_node_to_vertex_ptr(void) const;

1043 9 transform 0 4 1992 18 EggNode::transform 0 1 43 90
/**
 * Applies the indicated transformation to the node and all of its
 * descendants.
 */
53
inline void EggNode::transform(LMatrix4d const &mat);

1044 23 transform_vertices_only 0 4 1992 32 EggNode::transform_vertices_only 0 1 44 213
/**
 * Applies the indicated transformation only to vertices that appear in global
 * space within vertex pools at this node and below.  Joints and other
 * transforms are not affected, nor are local vertices.
 */
67
inline void EggNode::transform_vertices_only(LMatrix4d const &mat);

1045 18 flatten_transforms 0 4 1992 27 EggNode::flatten_transforms 0 1 45 382
/**
 * Removes any transform and instance records from this node in the scene
 * graph and below.  If an instance node is encountered, removes the instance
 * and applies the transform to its vertices, duplicating vertices if
 * necessary.
 *
 * Since this function may result in duplicated vertices, it may be a good
 * idea to call remove_unused_vertices() after calling this.
 */
46
inline void EggNode::flatten_transforms(void);

1046 13 apply_texmats 0 4 1992 22 EggNode::apply_texmats 0 1 46 159
/**
 * Applies the texture matrices to the UV's of the vertices that reference
 * them, and then removes the texture matrices from the textures themselves.
 */
34
void EggNode::apply_texmats(void);

1047 11 rename_node 0 4 1992 20 EggNode::rename_node 0 1 47 45
/**
 * Rename by stripping out the prefix
 */
53
int EggNode::rename_node(vector_string strip_prefix);

1048 8 is_joint 0 6 1992 17 EggNode::is_joint 0 1 48 229
/**
 * Returns true if this particular node represents a <Joint> entry or not.
 * This is a handy thing to know since Joints are sorted to the end of their
 * sibling list when writing an egg file.  See EggGroupNode::write().
 */
43
virtual bool EggNode::is_joint(void) const;

1049 14 is_anim_matrix 0 6 1992 23 EggNode::is_anim_matrix 0 1 49 109
/**
 * Returns true if this node represents a table of animation transformation
 * data, false otherwise.
 */
49
virtual bool EggNode::is_anim_matrix(void) const;

1050 20 determine_alpha_mode 0 6 1992 29 EggNode::determine_alpha_mode 0 1 50 266
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has an alpha_mode
 * other than AM_unspecified.  Returns a valid EggRenderMode pointer if one is
 * found, or NULL otherwise.
 */
59
virtual EggRenderMode *EggNode::determine_alpha_mode(void);

1051 26 determine_depth_write_mode 0 6 1992 35 EggNode::determine_depth_write_mode 0 1 51 272
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * depth_write_mode other than DWM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
65
virtual EggRenderMode *EggNode::determine_depth_write_mode(void);

1052 25 determine_depth_test_mode 0 6 1992 34 EggNode::determine_depth_test_mode 0 1 52 271
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * depth_test_mode other than DTM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
64
virtual EggRenderMode *EggNode::determine_depth_test_mode(void);

1053 25 determine_visibility_mode 0 6 1992 34 EggNode::determine_visibility_mode 0 1 53 270
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * visibility_mode other than VM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
64
virtual EggRenderMode *EggNode::determine_visibility_mode(void);

1054 22 determine_depth_offset 0 6 1992 31 EggNode::determine_depth_offset 0 1 54 251
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a depth_offset
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */
61
virtual EggRenderMode *EggNode::determine_depth_offset(void);

1055 20 determine_draw_order 0 6 1992 29 EggNode::determine_draw_order 0 1 55 249
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a draw_order
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */
59
virtual EggRenderMode *EggNode::determine_draw_order(void);

1056 13 determine_bin 0 6 1992 22 EggNode::determine_bin 0 1 56 238
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a bin specified.
 * Returns a valid EggRenderMode pointer if one is found, or NULL otherwise.
 */
52
virtual EggRenderMode *EggNode::determine_bin(void);

1057 17 determine_indexed 0 6 1992 26 EggNode::determine_indexed 0 1 57 321
/**
 * Walks back up the hierarchy, looking for an EggGroup at this level or above
 * that has the "indexed" scalar set.  Returns the value of the indexed scalar
 * if it is found, or false if it is not.
 *
 * In other words, returns true if the "indexed" flag is in effect for the
 * indicated node, false otherwise.
 */
46
virtual bool EggNode::determine_indexed(void);

1058 15 determine_decal 0 6 1992 24 EggNode::determine_decal 0 1 58 311
/**
 * Walks back up the hierarchy, looking for an EggGroup at this level or above
 * that has the "decal" flag set.  Returns the value of the decal flag if it
 * is found, or false if it is not.
 *
 * In other words, returns true if the "decal" flag is in effect for the
 * indicated node, false otherwise.
 */
44
virtual bool EggNode::determine_decal(void);

1059 5 write 0 6 1992 14 EggNode::write 0 1 59 0
70
virtual void EggNode::write(ostream &out, int indent_level) const = 0;

1060 9 parse_egg 0 4 1992 18 EggNode::parse_egg 0 1 60 296
/**
 * Parses the egg syntax given in the indicate string as if it had been read
 * from the egg file within this object's definition.  Updates the object
 * accordingly.  Returns true if successful, false if there was some parse
 * error or if the object does not support this functionality.
 */
55
bool EggNode::parse_egg(std::string const &egg_syntax);

1061 20 test_under_integrity 0 4 1992 29 EggNode::test_under_integrity 0 1 61 0
47
void EggNode::test_under_integrity(void) const;

1062 14 get_class_type 0 4 1992 23 EggNode::get_class_type 0 1 62 0
48
static TypeHandle EggNode::get_class_type(void);

1063 8 ~EggNode 0 4 1992 17 EggNode::~EggNode 0 0 0
24
EggNode::~EggNode(void);

1064 10 operator = 0 4 1993 23 EggAnimData::operator = 0 1 63 10
/**
 *
 */
69
inline EggAnimData &EggAnimData::operator =(EggAnimData const &copy);

1065 7 set_fps 0 4 1993 20 EggAnimData::set_fps 0 1 64 10
/**
 *
 */
46
inline void EggAnimData::set_fps(double type);

1066 9 clear_fps 0 4 1993 22 EggAnimData::clear_fps 0 1 65 10
/**
 *
 */
41
inline void EggAnimData::clear_fps(void);

1067 7 has_fps 0 4 1993 20 EggAnimData::has_fps 0 1 66 10
/**
 *
 */
45
inline bool EggAnimData::has_fps(void) const;

1068 7 get_fps 0 4 1993 20 EggAnimData::get_fps 0 1 67 56
/**
 * This is only valid if has_fps() returns true.
 */
47
inline double EggAnimData::get_fps(void) const;

1069 10 clear_data 0 4 1993 23 EggAnimData::clear_data 0 1 68 50
/**
 * Removes all data and empties the table.
 */
42
inline void EggAnimData::clear_data(void);

1070 8 add_data 0 4 1993 21 EggAnimData::add_data 0 1 69 46
/**
 * Adds a single element to the table.
 */
48
inline void EggAnimData::add_data(double value);

1071 8 get_size 0 4 1993 21 EggAnimData::get_size 0 1 70 55
/**
 * Returns the number of elements in the table.
 */
45
inline int EggAnimData::get_size(void) const;

1072 8 quantize 0 4 1993 21 EggAnimData::quantize 0 1 71 79
/**
 * Rounds each element of the table to the nearest multiple of quantum.
 */
43
void EggAnimData::quantize(double quantum);

1073 14 get_class_type 0 4 1993 27 EggAnimData::get_class_type 0 1 72 0
52
static TypeHandle EggAnimData::get_class_type(void);

1074 12 ~EggAnimData 0 4 1993 25 EggAnimData::~EggAnimData 0 0 0
32
EggAnimData::~EggAnimData(void);

1075 14 EggAnimPreload 0 4 1994 30 EggAnimPreload::EggAnimPreload 0 2 73 74 22
/**
 *
 */

/**
 *
 */
135
inline EggAnimPreload::EggAnimPreload(std::string const &name = "");
inline EggAnimPreload::EggAnimPreload(EggAnimPreload const &copy);

1076 10 operator = 0 4 1994 26 EggAnimPreload::operator = 0 1 75 10
/**
 *
 */
78
inline EggAnimPreload &EggAnimPreload::operator =(EggAnimPreload const &copy);

1077 7 set_fps 0 4 1994 23 EggAnimPreload::set_fps 0 1 76 10
/**
 *
 */
48
inline void EggAnimPreload::set_fps(double fps);

1078 9 clear_fps 0 4 1994 25 EggAnimPreload::clear_fps 0 1 77 10
/**
 *
 */
44
inline void EggAnimPreload::clear_fps(void);

1079 7 has_fps 0 4 1994 23 EggAnimPreload::has_fps 0 1 78 10
/**
 *
 */
48
inline bool EggAnimPreload::has_fps(void) const;

1080 7 get_fps 0 4 1994 23 EggAnimPreload::get_fps 0 1 79 56
/**
 * This is only valid if has_fps() returns true.
 */
50
inline double EggAnimPreload::get_fps(void) const;

1081 14 set_num_frames 0 4 1994 30 EggAnimPreload::set_num_frames 0 1 80 10
/**
 *
 */
59
inline void EggAnimPreload::set_num_frames(int num_frames);

1082 16 clear_num_frames 0 4 1994 32 EggAnimPreload::clear_num_frames 0 1 81 10
/**
 *
 */
51
inline void EggAnimPreload::clear_num_frames(void);

1083 14 has_num_frames 0 4 1994 30 EggAnimPreload::has_num_frames 0 1 82 10
/**
 *
 */
55
inline bool EggAnimPreload::has_num_frames(void) const;

1084 14 get_num_frames 0 4 1994 30 EggAnimPreload::get_num_frames 0 1 83 63
/**
 * This is only valid if has_num_frames() returns true.
 */
54
inline int EggAnimPreload::get_num_frames(void) const;

1085 14 get_class_type 0 4 1994 30 EggAnimPreload::get_class_type 0 1 84 0
55
static TypeHandle EggAnimPreload::get_class_type(void);

1086 15 ~EggAnimPreload 0 4 1994 31 EggAnimPreload::~EggAnimPreload 0 0 0
38
EggAnimPreload::~EggAnimPreload(void);

1087 20 upcast_to_MemoryBase 0 12 1995 35 EggAttributes::upcast_to_MemoryBase 0 1 105 39
upcast from EggAttributes to MemoryBase
54
MemoryBase *EggAttributes::upcast_to_MemoryBase(void);

1088 25 downcast_to_EggAttributes 0 12 1996 37 MemoryBase::downcast_to_EggAttributes 0 1 106 41
downcast from MemoryBase to EggAttributes
59
EggAttributes *MemoryBase::downcast_to_EggAttributes(void);

1089 13 EggAttributes 0 4 1995 28 EggAttributes::EggAttributes 0 2 85 86 22
/**
 *
 */

/**
 *
 */
92
EggAttributes::EggAttributes(void);
EggAttributes::EggAttributes(EggAttributes const &copy);

1090 10 operator = 0 4 1995 25 EggAttributes::operator = 0 1 87 10
/**
 *
 */
68
EggAttributes &EggAttributes::operator =(EggAttributes const &copy);

1091 14 ~EggAttributes 0 6 1995 29 EggAttributes::~EggAttributes 0 0 10
/**
 *
 */
44
virtual EggAttributes::~EggAttributes(void);

1092 10 has_normal 0 4 1995 25 EggAttributes::has_normal 0 1 88 10
/**
 *
 */
50
inline bool EggAttributes::has_normal(void) const;

1093 10 get_normal 0 4 1995 25 EggAttributes::get_normal 0 1 89 10
/**
 *
 */
61
inline LNormald const &EggAttributes::get_normal(void) const;

1094 10 set_normal 0 4 1995 25 EggAttributes::set_normal 0 1 90 10
/**
 *
 */
62
inline void EggAttributes::set_normal(LNormald const &normal);

1095 12 clear_normal 0 4 1995 27 EggAttributes::clear_normal 0 1 91 10
/**
 *
 */
46
inline void EggAttributes::clear_normal(void);

1096 14 matches_normal 0 4 1995 29 EggAttributes::matches_normal 0 1 92 113
/**
 * Returns true if this normal matches that of the other EggAttributes object,
 * include the morph list.
 */
76
inline bool EggAttributes::matches_normal(EggAttributes const &other) const;

1097 11 copy_normal 0 4 1995 26 EggAttributes::copy_normal 0 1 93 130
/**
 * Sets this normal to be the same as the other's, include morphs.  If the
 * other has no normal, this clears the normal.
 */
67
inline void EggAttributes::copy_normal(EggAttributes const &other);

1098 9 has_color 0 4 1995 24 EggAttributes::has_color 0 1 94 10
/**
 *
 */
49
inline bool EggAttributes::has_color(void) const;

1099 9 get_color 0 4 1995 24 EggAttributes::get_color 0 1 95 107
/**
 * Returns the color set on this particular attribute.  If there is no color
 * set, returns white.
 */
51
inline LColor EggAttributes::get_color(void) const;

1100 9 set_color 0 4 1995 24 EggAttributes::set_color 0 1 96 10
/**
 *
 */
58
inline void EggAttributes::set_color(LColor const &Color);

1101 11 clear_color 0 4 1995 26 EggAttributes::clear_color 0 1 97 10
/**
 *
 */
45
inline void EggAttributes::clear_color(void);

1102 13 matches_color 0 4 1995 28 EggAttributes::matches_color 0 1 98 112
/**
 * Returns true if this color matches that of the other EggAttributes object,
 * include the morph list.
 */
75
inline bool EggAttributes::matches_color(EggAttributes const &other) const;

1103 10 copy_color 0 4 1995 25 EggAttributes::copy_color 0 1 99 127
/**
 * Sets this color to be the same as the other's, include morphs.  If the
 * other has no color, this clears the color.
 */
66
inline void EggAttributes::copy_color(EggAttributes const &other);

1104 5 write 0 4 1995 20 EggAttributes::write 0 1 100 78
/**
 * Writes the attributes to the indicated output stream in Egg format.
 */
64
void EggAttributes::write(ostream &out, int indent_level) const;

1105 15 sorts_less_than 0 4 1995 30 EggAttributes::sorts_less_than 0 1 101 149
/**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */
77
inline bool EggAttributes::sorts_less_than(EggAttributes const &other) const;

1106 10 compare_to 0 4 1995 25 EggAttributes::compare_to 0 1 102 149
/**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */
64
int EggAttributes::compare_to(EggAttributes const &other) const;

1107 9 transform 0 4 1995 24 EggAttributes::transform 0 1 103 73
/**
 * Applies the indicated transformation matrix to the attributes.
 */
52
void EggAttributes::transform(LMatrix4d const &mat);

1108 12 get_dnormals 0 20 1995 27 EggAttributes::get_dnormals 0 1 107 55
getter for EggMorphNormalList EggAttributes::_dnormals;
59
EggMorphNormalList EggAttributes::get_dnormals(void) const;

1109 10 get_drgbas 0 20 1995 25 EggAttributes::get_drgbas 0 1 108 52
getter for EggMorphColorList EggAttributes::_drgbas;
56
EggMorphColorList EggAttributes::get_drgbas(void) const;

1110 14 get_class_type 0 4 1995 29 EggAttributes::get_class_type 0 1 104 0
54
static TypeHandle EggAttributes::get_class_type(void);

1111 11 EggVertexUV 0 4 2001 24 EggVertexUV::EggVertexUV 0 3 109 110 111 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
198
EggVertexUV::EggVertexUV(std::string const &name, LTexCoordd const &uv);
EggVertexUV::EggVertexUV(std::string const &name, LTexCoord3d const &uvw);
EggVertexUV::EggVertexUV(EggVertexUV const &copy);

1112 10 operator = 0 4 2001 23 EggVertexUV::operator = 0 1 112 10
/**
 *
 */
62
EggVertexUV &EggVertexUV::operator =(EggVertexUV const &copy);

1113 11 filter_name 0 4 2001 24 EggVertexUV::filter_name 0 1 113 227
/**
 * Returns the actual name that should be set for a given name string.
 * Usually this is the same string that is input, but for historical reasons
 * the texture coordinate name "default" is mapped to the empty string.
 */
76
static inline std::string EggVertexUV::filter_name(std::string const &name);

1114 8 set_name 0 4 2001 21 EggVertexUV::set_name 0 1 114 10
/**
 *
 */
59
inline void EggVertexUV::set_name(std::string const &name);

1115 18 get_num_dimensions 0 4 2001 31 EggVertexUV::get_num_dimensions 0 1 115 150
/**
 * Returns the number of components of the texture coordinate set.  This is
 * either 2 (the normal case) or 3 (for a 3-d texture coordinate).
 */
55
inline int EggVertexUV::get_num_dimensions(void) const;

1116 5 has_w 0 4 2001 18 EggVertexUV::has_w 0 1 116 131
/**
 * Returns true if the texture coordinate has a third, w component, false if
 * it is just a normal 2-d texture coordinate.
 */
43
inline bool EggVertexUV::has_w(void) const;

1117 6 get_uv 0 4 2001 19 EggVertexUV::get_uv 0 1 117 77
/**
 * Returns the texture coordinate pair, if get_num_dimensions() is 2.
 */
50
inline LTexCoordd EggVertexUV::get_uv(void) const;

1118 7 get_uvw 0 4 2001 20 EggVertexUV::get_uvw 0 1 118 181
/**
 * Returns the texture coordinate triple, if get_num_dimensions() is 3.  This
 * is also legal to call if get_num_dimensions() is 2 (but the last dimension
 * will be zero).
 */
59
inline LTexCoord3d const &EggVertexUV::get_uvw(void) const;

1119 6 set_uv 0 4 2001 19 EggVertexUV::set_uv 0 1 119 133
/**
 * Sets the texture coordinate pair.  This makes the texture coordinate a 2-d
 * texture coordinate, which is the usual case.
 */
60
inline void EggVertexUV::set_uv(LTexCoordd const &texCoord);

1120 7 set_uvw 0 4 2001 20 EggVertexUV::set_uvw 0 1 120 110
/**
 * Sets the texture coordinate triple.  This makes the texture coordinate a
 * 3-d texture coordinate.
 */
62
inline void EggVertexUV::set_uvw(LTexCoord3d const &texCoord);

1121 11 has_tangent 0 4 2001 24 EggVertexUV::has_tangent 0 1 121 10
/**
 *
 */
49
inline bool EggVertexUV::has_tangent(void) const;

1122 11 get_tangent 0 4 2001 24 EggVertexUV::get_tangent 0 1 122 10
/**
 *
 */
60
inline LNormald const &EggVertexUV::get_tangent(void) const;

1123 11 set_tangent 0 4 2001 24 EggVertexUV::set_tangent 0 1 123 10
/**
 *
 */
62
inline void EggVertexUV::set_tangent(LNormald const &tangent);

1124 13 clear_tangent 0 4 2001 26 EggVertexUV::clear_tangent 0 1 124 10
/**
 *
 */
45
inline void EggVertexUV::clear_tangent(void);

1125 12 has_binormal 0 4 2001 25 EggVertexUV::has_binormal 0 1 125 10
/**
 *
 */
50
inline bool EggVertexUV::has_binormal(void) const;

1126 12 get_binormal 0 4 2001 25 EggVertexUV::get_binormal 0 1 126 10
/**
 *
 */
61
inline LNormald const &EggVertexUV::get_binormal(void) const;

1127 12 set_binormal 0 4 2001 25 EggVertexUV::set_binormal 0 1 127 10
/**
 *
 */
64
inline void EggVertexUV::set_binormal(LNormald const &binormal);

1128 14 clear_binormal 0 4 2001 27 EggVertexUV::clear_binormal 0 1 128 10
/**
 *
 */
46
inline void EggVertexUV::clear_binormal(void);

1129 12 make_average 0 4 2001 25 EggVertexUV::make_average 0 1 129 149
/**
 * Creates a new EggVertexUV that contains the averaged values of the two
 * given objects.  It is an error if they don't have the same name.
 */
111
static PointerTo< EggVertexUV > EggVertexUV::make_average(EggVertexUV const *first, EggVertexUV const *second);

1130 9 transform 0 4 2001 22 EggVertexUV::transform 0 1 130 149
/**
 * Applies the indicated transformation matrix to the UV's tangent and/or
 * binormal.  This does nothing if there is no tangent or binormal.
 */
50
void EggVertexUV::transform(LMatrix4d const &mat);

1131 5 write 0 4 2001 18 EggVertexUV::write 0 1 131 10
/**
 *
 */
62
void EggVertexUV::write(ostream &out, int indent_level) const;

1132 10 compare_to 0 4 2001 23 EggVertexUV::compare_to 0 1 132 149
/**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */
60
int EggVertexUV::compare_to(EggVertexUV const &other) const;

1133 8 get_duvs 0 20 2001 21 EggVertexUV::get_duvs 0 1 134 51
getter for EggMorphTexCoordList EggVertexUV::_duvs;
55
EggMorphTexCoordList EggVertexUV::get_duvs(void) const;

1134 14 get_class_type 0 4 2001 27 EggVertexUV::get_class_type 0 1 133 0
52
static TypeHandle EggVertexUV::get_class_type(void);

1135 12 EggVertexAux 0 4 2004 26 EggVertexAux::EggVertexAux 0 2 135 136 22
/**
 *
 */

/**
 *
 */
129
EggVertexAux::EggVertexAux(std::string const &name, LVecBase4d const &aux);
EggVertexAux::EggVertexAux(EggVertexAux const &copy);

1136 10 operator = 0 4 2004 24 EggVertexAux::operator = 0 1 137 10
/**
 *
 */
65
EggVertexAux &EggVertexAux::operator =(EggVertexAux const &copy);

1137 8 set_name 0 4 2004 22 EggVertexAux::set_name 0 1 138 10
/**
 *
 */
60
inline void EggVertexAux::set_name(std::string const &name);

1138 7 get_aux 0 4 2004 21 EggVertexAux::get_aux 0 1 139 48
/**
 * Returns the auxiliary data quadruple.
 */
59
inline LVecBase4d const &EggVertexAux::get_aux(void) const;

1139 7 set_aux 0 4 2004 21 EggVertexAux::set_aux 0 1 140 45
/**
 * Sets the auxiliary data quadruple.
 */
57
inline void EggVertexAux::set_aux(LVecBase4d const &aux);

1140 12 make_average 0 4 2004 26 EggVertexAux::make_average 0 1 141 150
/**
 * Creates a new EggVertexAux that contains the averaged values of the two
 * given objects.  It is an error if they don't have the same name.
 */
115
static PointerTo< EggVertexAux > EggVertexAux::make_average(EggVertexAux const *first, EggVertexAux const *second);

1141 5 write 0 4 2004 19 EggVertexAux::write 0 1 142 10
/**
 *
 */
63
void EggVertexAux::write(ostream &out, int indent_level) const;

1142 10 compare_to 0 4 2004 24 EggVertexAux::compare_to 0 1 143 149
/**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */
62
int EggVertexAux::compare_to(EggVertexAux const &other) const;

1143 14 get_class_type 0 4 2004 28 EggVertexAux::get_class_type 0 1 144 0
53
static TypeHandle EggVertexAux::get_class_type(void);

1144 19 upcast_to_EggObject 0 12 2005 30 EggVertex::upcast_to_EggObject 0 1 203 34
upcast from EggVertex to EggObject
48
EggObject *EggVertex::upcast_to_EggObject(void);

1145 21 downcast_to_EggVertex 0 12 1989 32 EggObject::downcast_to_EggVertex 0 1 204 36
downcast from EggObject to EggVertex
50
EggVertex *EggObject::downcast_to_EggVertex(void);

1146 23 upcast_to_EggAttributes 0 12 2005 34 EggVertex::upcast_to_EggAttributes 0 1 205 38
upcast from EggVertex to EggAttributes
56
EggAttributes *EggVertex::upcast_to_EggAttributes(void);

1147 21 downcast_to_EggVertex 0 12 1995 36 EggAttributes::downcast_to_EggVertex 0 1 206 40
downcast from EggAttributes to EggVertex
54
EggVertex *EggAttributes::downcast_to_EggVertex(void);

1148 9 EggVertex 0 4 2005 20 EggVertex::EggVertex 0 2 145 146 121
/**
 *
 */

/**
 * Copies all properties of the vertex except its vertex pool, index number,
 * and group membership.
 */
72
EggVertex::EggVertex(void);
EggVertex::EggVertex(EggVertex const &copy);

1149 10 operator = 0 4 2005 21 EggVertex::operator = 0 1 147 109
/**
 * Copies all properties of the vertex except its vertex pool, index number,
 * and group membership.
 */
56
EggVertex &EggVertex::operator =(EggVertex const &copy);

1150 10 ~EggVertex 0 6 2005 21 EggVertex::~EggVertex 0 0 10
/**
 *
 */
36
virtual EggVertex::~EggVertex(void);

1151 8 get_pool 0 4 2005 19 EggVertex::get_pool 0 1 148 123
/**
 * Returns the vertex pool this vertex belongs in.  This may be NULL if the
 * vertex has not been added to a pool.
 */
54
inline EggVertexPool *EggVertex::get_pool(void) const;

1152 20 is_forward_reference 0 4 2005 31 EggVertex::is_forward_reference 0 1 149 386
/**
 * Returns true if the vertex is a forward reference to some vertex that
 * hasn't been defined yet.  In this case, the vertex may not have any
 * properties filled in yet.
 *
 * This can only happen if you implicitly create a vertex via
 * EggVertexPool::get_forward_vertex(). Presumably, when the vertex pool is
 * later filled in, this vertex will be replaced with real data.
 */
56
inline bool EggVertex::is_forward_reference(void) const;

1153 7 set_pos 0 4 2005 18 EggVertex::set_pos 0 4 150 151 152 153 485
// The pos might have 1, 2, 3, or 4 dimensions.  That complicates things a
// bit.

/**
 * Sets the vertex position.  This variant sets the vertex to a one-
 * dimensional value.
 */

/**
 * Sets the vertex position.  This variant sets the vertex to a two-
 * dimensional value.
 */

/**
 * Sets the vertex position.  This variant sets the vertex to a three-
 * dimensional value.
 */

/**
 * Sets the vertex position.  This variant sets the vertex to a four-
 * dimensional value.
 */
202
inline void EggVertex::set_pos(double pos);
inline void EggVertex::set_pos(LPoint2d const &pos);
inline void EggVertex::set_pos(LPoint3d const &pos);
inline void EggVertex::set_pos(LPoint4d const &pos);

1154 8 set_pos4 0 4 2005 19 EggVertex::set_pos4 0 1 154 319
/**
 * This special flavor of set_pos() sets the vertex as a four-component value,
 * but does not change the set number of dimensions.  It's handy for
 * retrieving the vertex position via get_pos4, manipulating it, then storing
 * it back again, without worrying about the number of dimensions it actually
 * had.
 */
53
inline void EggVertex::set_pos4(LPoint4d const &pos);

1155 18 get_num_dimensions 0 4 2005 29 EggVertex::get_num_dimensions 0 1 155 487
// get_pos[123] return the pos as the corresponding type.  It is an error to
// call any of these without first verifying that get_num_dimensions()
// matches the desired type.  However, get_pos4() may always be called; it
// returns the pos as a four-component point in homogeneous space (with a
// 1.0 in the last position if the pos has fewer than four components).

/**
 * Returns the number of dimensions the vertex uses.  Usually this will be 3,
 * but it may be 1, 2, 3, or 4.
 */
53
inline int EggVertex::get_num_dimensions(void) const;

1156 8 get_pos1 0 4 2005 19 EggVertex::get_pos1 0 1 156 108
/**
 * Only valid if get_num_dimensions() returns 1. Returns the position as a
 * one-dimensional value.
 */
46
inline double EggVertex::get_pos1(void) const;

1157 8 get_pos2 0 4 2005 19 EggVertex::get_pos2 0 1 157 108
/**
 * Only valid if get_num_dimensions() returns 2. Returns the position as a
 * two-dimensional value.
 */
48
inline LPoint2d EggVertex::get_pos2(void) const;

1158 8 get_pos3 0 4 2005 19 EggVertex::get_pos3 0 1 158 110
/**
 * Valid if get_num_dimensions() returns 3 or 4. Returns the position as a
 * three-dimensional value.
 */
48
inline LVertexd EggVertex::get_pos3(void) const;

1159 8 get_pos4 0 4 2005 19 EggVertex::get_pos4 0 1 159 309
/**
 * This is always valid, regardless of the value of get_num_dimensions.  It
 * returns the position as a four-dimensional value.  If the pos has fewer
 * than four dimensions, this value represents the pos extended into four-
 * dimensional homogenous space, e.g.  by adding 1 as the fourth component.
 */
48
inline LPoint4d EggVertex::get_pos4(void) const;

1160 6 has_uv 0 4 2005 17 EggVertex::has_uv 0 2 160 161 406
/**
 * Returns true if the vertex has an unnamed UV coordinate pair, false
 * otherwise.
 *
 * This is the more restrictive interface, and is generally useful only in the
 * absence of multitexturing; see has_uv(name) for the interface that supports
 * multitexturing.
 */

/**
 * Returns true if the vertex has the named UV coordinate pair, and the named
 * UV coordinate pair is 2-d, false otherwise.
 */
97
inline bool EggVertex::has_uv(void) const;
bool EggVertex::has_uv(std::string const &name) const;

1161 6 get_uv 0 4 2005 17 EggVertex::get_uv 0 2 162 163 436
/**
 * Returns the unnamed UV coordinate pair on the vertex.  It is an error to
 * call this if has_uv() has returned false.
 *
 * This is the more restrictive interface, and is generally useful only in the
 * absence of multitexturing; see get_uv(name) for the interface that supports
 * multitexturing.
 */

/**
 * Returns the named UV coordinate pair on the vertex.  It is an error to call
 * this if has_uv(name) returned false.
 */
109
inline LTexCoordd EggVertex::get_uv(void) const;
LTexCoordd EggVertex::get_uv(std::string const &name) const;

1162 6 set_uv 0 4 2005 17 EggVertex::set_uv 0 2 164 165 453
/**
 * Replaces the unnamed UV coordinate pair on the vertex with the indicated
 * value.
 *
 * This is the more restrictive interface, and is generally useful only in the
 * absence of multitexturing; see set_uv(name, uv) for the interface that
 * supports multitexturing.
 */

/**
 * Sets the indicated UV coordinate pair on the vertex.  This replaces any UV
 * coordinate pair with the same name already on the vertex, but preserves UV
 * morphs.
 */
135
inline void EggVertex::set_uv(LTexCoordd const &texCoord);
void EggVertex::set_uv(std::string const &name, LTexCoordd const &texCoord);

1163 8 clear_uv 0 4 2005 19 EggVertex::clear_uv 0 2 166 167 154
/**
 * Removes all UV coordinate pairs from the vertex.
 */

/**
 * Removes the named UV coordinate pair from the vertex, along with any UV
 * morphs.
 */
89
inline void EggVertex::clear_uv(void);
void EggVertex::clear_uv(std::string const &name);

1164 7 has_uvw 0 4 2005 18 EggVertex::has_uvw 0 1 168 136
/**
 * Returns true if the vertex has the named UV coordinate triple, and the
 * named UV coordinate triple is 3-d, false otherwise.
 */
55
bool EggVertex::has_uvw(std::string const &name) const;

1165 7 get_uvw 0 4 2005 18 EggVertex::get_uvw 0 1 169 129
/**
 * Returns the named UV coordinate triple on the vertex.  It is an error to
 * call this if has_uvw(name) returned false.
 */
69
LTexCoord3d const &EggVertex::get_uvw(std::string const &name) const;

1166 7 set_uvw 0 4 2005 18 EggVertex::set_uvw 0 1 170 186
/**
 * Sets the indicated UV coordinate triple on the vertex.  This replaces any
 * UV coordinate pair or triple with the same name already on the vertex, but
 * preserves UV morphs.
 */
78
void EggVertex::set_uvw(std::string const &name, LTexCoord3d const &texCoord);

1167 10 get_uv_obj 0 4 2005 21 EggVertex::get_uv_obj 0 1 171 298
/**
 * Returns the named EggVertexUV object, which defines both the UV coordinate
 * pair for this name and the UV morphs.  This object might be shared between
 * multiple vertices.  You should not attempt to modify this object; instead,
 * call modify_uv_object to return a modifiable pointer.
 */
72
EggVertexUV const *EggVertex::get_uv_obj(std::string const &name) const;

1168 13 modify_uv_obj 0 4 2005 24 EggVertex::modify_uv_obj 0 1 172 204
/**
 * Returns a modifiable pointer to the named EggVertexUV object, which defines
 * both the UV coordinate pair for this name and the UV morphs.  Returns NULL
 * if there is no such named UV object.
 */
63
EggVertexUV *EggVertex::modify_uv_obj(std::string const &name);

1169 10 set_uv_obj 0 4 2005 21 EggVertex::set_uv_obj 0 1 173 163
/**
 * Sets the indicated EggVertexUV on the vertex.  This replaces any UV
 * coordinate pair with the same name already on the vertex, including UV
 * morphs.
 */
51
void EggVertex::set_uv_obj(EggVertexUV *vertex_uv);

1170 7 has_aux 0 4 2005 18 EggVertex::has_aux 0 2 174 175 157
/**
 * Returns true if the vertex has any auxiliary data, false otherwise.
 */

/**
 * Returns true if the vertex has the named auxiliary data quadruple.
 */
99
inline bool EggVertex::has_aux(void) const;
bool EggVertex::has_aux(std::string const &name) const;

1171 9 clear_aux 0 4 2005 20 EggVertex::clear_aux 0 2 176 177 116
/**
 * Removes all auxiliary data from the vertex.
 */

/**
 * Removes the named auxiliary data from the vertex.
 */
91
inline void EggVertex::clear_aux(void);
void EggVertex::clear_aux(std::string const &name);

1172 7 get_aux 0 4 2005 18 EggVertex::get_aux 0 1 178 133
/**
 * Returns the named auxiliary data quadruple on the vertex.  It is an error
 * to call this if has_aux(name) returned false.
 */
68
LVecBase4d const &EggVertex::get_aux(std::string const &name) const;

1173 7 set_aux 0 4 2005 18 EggVertex::set_aux 0 1 179 148
/**
 * Sets the indicated auxiliary data quadruple on the vertex.  This replaces
 * any auxiliary data with the same name already on the vertex.
 */
72
void EggVertex::set_aux(std::string const &name, LVecBase4d const &aux);

1174 11 get_aux_obj 0 4 2005 22 EggVertex::get_aux_obj 0 1 180 273
/**
 * Returns the named EggVertexAux object, which defines the auxiliary data for
 * this name.  This object might be shared between multiple vertices.  You
 * should not attempt to modify this object; instead, call modify_aux_object
 * to return a modifiable pointer.
 */
74
EggVertexAux const *EggVertex::get_aux_obj(std::string const &name) const;

1175 14 modify_aux_obj 0 4 2005 25 EggVertex::modify_aux_obj 0 1 181 178
/**
 * Returns a modifiable pointer to the named EggVertexAux object, which
 * defines the auxiliary data for this name.  Returns NULL if there is no such
 * named UV object.
 */
65
EggVertexAux *EggVertex::modify_aux_obj(std::string const &name);

1176 11 set_aux_obj 0 4 2005 22 EggVertex::set_aux_obj 0 1 182 136
/**
 * Sets the indicated EggVertexAux on the vertex.  This replaces any auxiliary
 * data with the same name already on the vertex.
 */
54
void EggVertex::set_aux_obj(EggVertexAux *vertex_aux);

1177 12 make_average 0 4 2005 23 EggVertex::make_average 0 1 183 284
/**
 * Creates a new vertex that lies in between the two given vertices.  The
 * attributes for the UV sets they have in common are averaged.
 *
 * Both vertices need to be either in no pool, or in the same pool.  In the
 * latter case, the new vertex will be placed in that pool.
 */
103
static PointerTo< EggVertex > EggVertex::make_average(EggVertex const *first, EggVertex const *second);

1178 9 get_index 0 4 2005 20 EggVertex::get_index 0 1 184 66
/**
 * Returns the index number of the vertex within its pool.
 */
44
inline int EggVertex::get_index(void) const;

1179 18 set_external_index 0 4 2005 29 EggVertex::set_external_index 0 1 185 486
/**
 * Sets a special index number that is associated with the EggVertex (but is
 * not written to the egg file). This number is not interpreted by any egg
 * code; it is simply maintained along with the vertex.  It *is* used to
 * differentiate otherwise identical vertices in
 * EggVertexPool::create_unique_vertex(), however.
 *
 * The intention of this number is as an aid for file converters, to associate
 * an EggVertex back to the index number of the original source vertex.
 */
62
inline void EggVertex::set_external_index(int external_index);

1180 18 get_external_index 0 4 2005 29 EggVertex::get_external_index 0 1 186 85
/**
 * Returns the number set by set_external_index().  See set_external_index().
 */
53
inline int EggVertex::get_external_index(void) const;

1181 19 set_external_index2 0 4 2005 30 EggVertex::set_external_index2 0 1 187 225
/**
 * Similar to set_external_index(), but this is a different number which may
 * be used for a different purpose by the calling code.  The egg library does
 * not assign any meaning to this number or use it in any way.
 */
64
inline void EggVertex::set_external_index2(int external_index2);

1182 19 get_external_index2 0 4 2005 30 EggVertex::get_external_index2 0 1 188 90
/**
 * Returns the number set by set_external_index2().  See
 * set_external_index2().
 */
54
inline int EggVertex::get_external_index2(void) const;

1183 5 write 0 4 2005 16 EggVertex::write 0 1 189 74
/**
 * Writes the vertex to the indicated output stream in Egg format.
 */
60
void EggVertex::write(ostream &out, int indent_level) const;

1184 15 sorts_less_than 0 4 2005 26 EggVertex::sorts_less_than 0 1 190 149
/**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */
69
inline bool EggVertex::sorts_less_than(EggVertex const &other) const;

1185 10 compare_to 0 4 2005 21 EggVertex::compare_to 0 1 191 746
/**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 *
 * Group membership is not considered in this comparison.  This is somewhat
 * problematic, but cannot easily be helped, because considering group
 * membership would make it difficult to add and remove groups from vertices.
 * It also makes it impossible to meaningfully compare with a concrete
 * EggVertex object (which cannot have group memberships).
 *
 * However, this is not altogether bad, because two vertices that are
 * identical in all other properties should generally also be identical in
 * group memberships, else the vertices will tend to fly apart when the joints
 * animate.
 */
56
int EggVertex::compare_to(EggVertex const &other) const;

1186 19 get_num_local_coord 0 4 2005 30 EggVertex::get_num_local_coord 0 1 192 134
/**
 * Returns the number of primitives that own this vertex whose vertices are
 * interpreted to be in a local coordinate system.
 */
47
int EggVertex::get_num_local_coord(void) const;

1187 20 get_num_global_coord 0 4 2005 31 EggVertex::get_num_global_coord 0 1 193 131
/**
 * Returns the number of primitives that own this vertex whose vertices are
 * interpreted in the global coordinate system.
 */
48
int EggVertex::get_num_global_coord(void) const;

1188 9 transform 0 4 2005 20 EggVertex::transform 0 1 194 69
/**
 * Applies the indicated transformation matrix to the vertex.
 */
48
void EggVertex::transform(LMatrix4d const &mat);

1189 8 has_gref 0 4 2005 19 EggVertex::has_gref 0 1 195 90
/**
 * Returns true if the indicated group references this vertex, false
 * otherwise.
 */
54
bool EggVertex::has_gref(EggGroup const *group) const;

1190 15 copy_grefs_from 0 4 2005 26 EggVertex::copy_grefs_from 0 1 196 406
/**
 * Copies all the group references from the other vertex onto this one.  This
 * assigns the current vertex to exactly the same groups, with exactly the
 * same memberships, as the given one.
 *
 * Warning: only an EggVertex allocated from the free store may have groups
 * assigned to it.  Do not attempt to call this on a temporary concrete
 * EggVertex object; a core dump will certainly result.
 */
56
void EggVertex::copy_grefs_from(EggVertex const &other);

1191 11 clear_grefs 0 4 2005 22 EggVertex::clear_grefs 0 1 197 100
/**
 * Removes all group references from the vertex, so that it is not assigned to
 * any group.
 */
34
void EggVertex::clear_grefs(void);

1192 8 has_pref 0 4 2005 19 EggVertex::has_pref 0 1 198 116
/**
 * Returns the number of times the vertex appears in the indicated primitive,
 * or 0 if it does not appear.
 */
56
int EggVertex::has_pref(EggPrimitive const *prim) const;

1193 19 test_gref_integrity 0 4 2005 30 EggVertex::test_gref_integrity 0 1 199 0
48
void EggVertex::test_gref_integrity(void) const;

1194 19 test_pref_integrity 0 4 2005 30 EggVertex::test_pref_integrity 0 1 200 0
48
void EggVertex::test_pref_integrity(void) const;

1195 6 output 0 4 2005 17 EggVertex::output 0 1 201 10
/**
 *
 */
43
void EggVertex::output(ostream &out) const;

1196 9 get_dxyzs 0 20 2005 20 EggVertex::get_dxyzs 0 1 207 48
getter for EggMorphVertexList EggVertex::_dxyzs;
52
EggMorphVertexList EggVertex::get_dxyzs(void) const;

1197 14 get_class_type 0 4 2005 25 EggVertex::get_class_type 0 1 202 0
50
static TypeHandle EggVertex::get_class_type(void);

1198 13 EggVertexPool 0 4 2008 28 EggVertexPool::EggVertexPool 0 2 208 209 210
/**
 *
 */

/**
 * Copying a vertex pool is of questionable value, since it will copy all of
 * the vertices and assign new pointers to them all.  There will be no
 * polygons referring to the new vertices.
 */
111
EggVertexPool::EggVertexPool(std::string const &name);
EggVertexPool::EggVertexPool(EggVertexPool const &copy);

1199 10 has_vertex 0 4 2008 25 EggVertexPool::has_vertex 0 1 210 147
/**
 * Returns true if the indicated vertex has been defined in the vertex pool,
 * false otherwise.  This does not include forward references.
 */
55
inline bool EggVertexPool::has_vertex(int index) const;

1200 20 has_forward_vertices 0 4 2008 35 EggVertexPool::has_forward_vertices 0 1 211 131
/**
 * Returns true if any vertices in the pool are undefined forward-reference
 * vertices, false if all vertices are defined.
 */
53
bool EggVertexPool::has_forward_vertices(void) const;

1201 20 has_defined_vertices 0 4 2008 35 EggVertexPool::has_defined_vertices 0 1 212 128
/**
 * Returns true if any vertices in the pool are fully defined vertices, false
 * if all vertices are forward references.
 */
53
bool EggVertexPool::has_defined_vertices(void) const;

1202 10 get_vertex 0 4 2008 25 EggVertexPool::get_vertex 0 1 213 169
// Returns NULL if there is no such vertex.

/**
 * Returns the vertex in the pool with the indicated index number, or NULL if
 * no vertices have that index number.
 */
54
EggVertex *EggVertexPool::get_vertex(int index) const;

1203 11 operator [] 0 4 2008 26 EggVertexPool::operator [] 0 1 214 124
/**
 * Returns the vertex in the pool with the indicated index number, or NULL if
 * no vertices have that index number.
 */
62
inline EggVertex *EggVertexPool::operator [](int index) const;

1204 18 get_forward_vertex 0 4 2008 33 EggVertexPool::get_forward_vertex 0 1 215 387
// Returns a forward reference if there is no such vertex.

/**
 * Returns the vertex in the pool with the indicated index number.  If there
 * is not a vertex in the pool with the indicated index number, creates a
 * special forward-reference EggVertex that has no data, on the assumption
 * that the vertex pool has not yet been fully read and more data will be
 * available later.
 */
56
EggVertex *EggVertexPool::get_forward_vertex(int index);

1205 17 get_highest_index 0 4 2008 32 EggVertexPool::get_highest_index 0 1 216 176
// Returns 0 if the pool is empty.

/**
 * Returns the highest index number used by any vertex in the pool (except
 * forward references).  Returns -1 if the pool is empty.
 */
49
int EggVertexPool::get_highest_index(void) const;

1206 17 set_highest_index 0 4 2008 32 EggVertexPool::set_highest_index 0 1 217 276
/**
 * Artificially changes the "highest index number", so that a newly created
 * vertex will begin at this number plus 1.  This can be used to default a
 * vertex pool to start counting at 1 (or any other index number), instead of
 * the default of 0.  Use with caution.
 */
57
void EggVertexPool::set_highest_index(int highest_index);

1207 18 get_num_dimensions 0 4 2008 33 EggVertexPool::get_num_dimensions 0 1 218 83
/**
 * Returns the maximum number of dimensions used by any vertex in the pool.
 */
50
int EggVertexPool::get_num_dimensions(void) const;

1208 11 has_normals 0 6 2008 26 EggVertexPool::has_normals 0 1 219 100
/**
 * Returns true if any vertex in the pool has a normal defined, false if none
 * of them do.
 */
52
virtual bool EggVertexPool::has_normals(void) const;

1209 10 has_colors 0 4 2008 25 EggVertexPool::has_colors 0 1 220 99
/**
 * Returns true if any vertex in the pool has a color defined, false if none
 * of them do.
 */
43
bool EggVertexPool::has_colors(void) const;

1210 19 has_nonwhite_colors 0 4 2008 34 EggVertexPool::has_nonwhite_colors 0 1 221 152
/**
 * Returns true if any vertex in the pool has a color defined other than
 * white, false if no vertices have colors, or if all colors are white.
 */
52
bool EggVertexPool::has_nonwhite_colors(void) const;

1211 19 check_overall_color 0 4 2008 34 EggVertexPool::check_overall_color 0 0 376
/**
 * Scans the vertex pool for different colors on different vertices.  If all
 * vertices are the same color, sets has_overall_color to true and fills the
 * color into overall_color.  If no vertices have any color, set
 * has_overall_color to true and fills white into overall_color.  If at least
 * two vertices have different colors, sets has_overall_color to false.
 */
94
void EggVertexPool::check_overall_color(bool &has_overall_color, LColor &overall_color) const;

1212 7 has_uvs 0 4 2008 22 EggVertexPool::has_uvs 0 1 222 96
/**
 * Returns true if any vertex in the pool has a uv defined, false if none of
 * them do.
 */
40
bool EggVertexPool::has_uvs(void) const;

1213 7 has_aux 0 4 2008 22 EggVertexPool::has_aux 0 1 223 106
/**
 * Returns true if any vertex in the pool has auxiliary data defined, false if
 * none of them do.
 */
40
bool EggVertexPool::has_aux(void) const;

1214 12 get_uv_names 0 4 2008 27 EggVertexPool::get_uv_names 0 1 224 351
/**
 * Returns the list of UV names that are defined by any vertices in the pool,
 * as well as the subset of UV names that actually define 3-d texture
 * coordinates ("uvw_names").  Also returns the subset of UV/UVW names that
 * define a tangent and binormal.  It is the user's responsibility to clear
 * both vectors before calling this method.
 */
116
void EggVertexPool::get_uv_names(vector_string &uv_names, vector_string &uvw_names, vector_string &tbn_names) const;

1215 13 get_aux_names 0 4 2008 28 EggVertexPool::get_aux_names 0 1 225 100
/**
 * Returns the list of auxiliary data names that are defined by any vertices
 * in the pool.
 */
66
void EggVertexPool::get_aux_names(vector_string &aux_names) const;

1216 4 size 0 4 2008 19 EggVertexPool::size 0 1 226 54
/**
 * Returns the number of vertices in the pool.
 */
57
EggVertexPool::size_type EggVertexPool::size(void) const;

1217 10 add_vertex 0 4 2008 25 EggVertexPool::add_vertex 0 1 227 908
// add_vertex() adds a freshly-allocated vertex.  It is up to the user to
// allocate the vertex.

/**
 * Adds the indicated vertex to the pool.  It is an error if the vertex is
 * already a member of this or any other pool.  The vertex must have been
 * allocated from the free store; its pointer will now be owned by the vertex
 * pool.  If the index number is supplied, tries to assign that index number;
 * it is an error if the index number is already in use.
 *
 * It is possible that a forward reference to this vertex was requested in the
 * past; if so, the data from the supplied vertex is copied onto the forward
 * reference, which becomes the actual vertex.  In this case, a different
 * pointer is saved (and returned) than the one actually passed in.  In the
 * usual case, however, the vertex pointer passed in is the one that is saved
 * in the vertex pool and returned from this method.
 */
72
EggVertex *EggVertexPool::add_vertex(EggVertex *vertex, int index = -1);

1218 15 make_new_vertex 0 4 2008 30 EggVertexPool::make_new_vertex 0 5 228 229 230 231 232 1272
// make_new_vertex() allocates and returns a new vertex from the pool.

/**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 */

/**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 *
 * This flavor of make_new_vertex() explicitly sets the vertex position as it
 * is allocated.  It does not attempt to share vertices.
 */

/**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 *
 * This flavor of make_new_vertex() explicitly sets the vertex position as it
 * is allocated.  It does not attempt to share vertices.
 */

/**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 *
 * This flavor of make_new_vertex() explicitly sets the vertex position as it
 * is allocated.  It does not attempt to share vertices.
 */

/**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 *
 * This flavor of make_new_vertex() explicitly sets the vertex position as it
 * is allocated.  It does not attempt to share vertices.
 */
330
inline EggVertex *EggVertexPool::make_new_vertex(void);
inline EggVertex *EggVertexPool::make_new_vertex(double pos);
inline EggVertex *EggVertexPool::make_new_vertex(LPoint2d const &pos);
inline EggVertex *EggVertexPool::make_new_vertex(LPoint3d const &pos);
inline EggVertex *EggVertexPool::make_new_vertex(LPoint4d const &pos);

1219 20 create_unique_vertex 0 4 2008 35 EggVertexPool::create_unique_vertex 0 1 233 350
// create_unique_vertex() creates a new vertex if there is not already one
// identical to the indicated vertex, or returns the existing one if there
// is.

/**
 * Creates a new vertex in the pool that is a copy of the indicated one and
 * returns it.  If there is already a vertex in the pool like the indicated
 * one, simply returns that one.
 */
70
EggVertex *EggVertexPool::create_unique_vertex(EggVertex const &copy);

1220 20 find_matching_vertex 0 4 2008 35 EggVertexPool::find_matching_vertex 0 1 234 212
/**
 * If the EggVertexPool already has a vertex matching the indicated vertex,
 * returns it; otherwise, returns NULL.  This is similar to
 * create_unique_vertex() except that a new vertex is never created.
 */
70
EggVertex *EggVertexPool::find_matching_vertex(EggVertex const &copy);

1221 13 remove_vertex 0 4 2008 28 EggVertexPool::remove_vertex 0 1 235 114
/**
 * Removes the vertex from the pool.  It is an error if the vertex is not
 * already a member of the pool.
 */
53
void EggVertexPool::remove_vertex(EggVertex *vertex);

1222 22 remove_unused_vertices 0 4 2008 37 EggVertexPool::remove_unused_vertices 0 1 236 292
/**
 * Removes all vertices from the pool that are not referenced by at least one
 * primitive.  Also collapses together equivalent vertices, and renumbers all
 * vertices after the operation so their indices are consecutive, beginning at
 * zero.  Returns the number of vertices removed.
 */
48
int EggVertexPool::remove_unused_vertices(void);

1223 27 add_unused_vertices_to_prim 0 4 2008 42 EggVertexPool::add_unused_vertices_to_prim 0 1 237 113
/**
 * Adds all of the unused vertices in this vertex pool to the indicated
 * primitive, in ascending order.
 */
68
void EggVertexPool::add_unused_vertices_to_prim(EggPrimitive *prim);

1224 9 transform 0 4 2008 24 EggVertexPool::transform 0 1 238 419
/**
 * Applies the indicated transformation matrix to all the vertices.  However,
 * vertices that are attached to primitives that believe their vertices are in
 * a local coordinate system are transformed only by the scale and rotation
 * component.  If a vertex happens to be attached both to a local and a global
 * primitive, and the transformation includes a translation component, the
 * vertex will be split.
 */
52
void EggVertexPool::transform(LMatrix4d const &mat);

1225 22 sort_by_external_index 0 4 2008 37 EggVertexPool::sort_by_external_index 0 1 239 186
/**
 * Re-orders (and re-numbers) the vertices in this vertex pool so that they
 * appear in increasing order by the optional external_index that has been
 * assigned to each vertex.
 */
49
void EggVertexPool::sort_by_external_index(void);

1226 14 get_class_type 0 4 2008 29 EggVertexPool::get_class_type 0 1 240 0
54
static TypeHandle EggVertexPool::get_class_type(void);

1227 12 EggGroupNode 0 4 2009 26 EggGroupNode::EggGroupNode 0 2 241 242 10
/**
 *
 */
111
EggGroupNode::EggGroupNode(std::string const &name = "");
EggGroupNode::EggGroupNode(EggGroupNode const &copy);

1228 10 operator = 0 4 2009 24 EggGroupNode::operator = 0 1 243 10
/**
 *
 */
65
EggGroupNode &EggGroupNode::operator =(EggGroupNode const &copy);

1229 5 empty 0 4 2009 19 EggGroupNode::empty 0 1 244 10
/**
 *
 */
37
bool EggGroupNode::empty(void) const;

1230 4 size 0 4 2009 18 EggGroupNode::size 0 1 245 10
/**
 *
 */
55
EggGroupNode::size_type EggGroupNode::size(void) const;

1231 5 clear 0 4 2009 19 EggGroupNode::clear 0 1 246 10
/**
 *
 */
31
void EggGroupNode::clear(void);

1232 15 get_first_child 0 4 2009 29 EggGroupNode::get_first_child 0 1 247 607
// This is an alternate way to traverse the list of children.  It is mainly
// provided for scripting code, which can't use the iterators defined above
// (they don't export through interrogate very well). These are, of course,
// non-thread-safe.

/**
 * Returns the first child in the group's list of children, or NULL if the
 * list of children is empty.  Can be used with get_next_child() to return the
 * complete list of children without using the iterator class; however, this
 * is non-thread-safe, and so is not recommended except for languages other
 * than C++ which cannot use the iterators.
 */
45
EggNode *EggGroupNode::get_first_child(void);

1233 14 get_next_child 0 4 2009 28 EggGroupNode::get_next_child 0 1 248 506
/**
 * Returns the next child in the group's list of children since the last call
 * to get_first_child() or get_next_child(), or NULL if the last child has
 * been returned.  Can be used with get_first_child() to return the complete
 * list of children without using the iterator class; however, this is non-
 * thread-safe, and so is not recommended except for languages other than C++
 * which cannot use the iterators.
 *
 * It is an error to call this without previously calling get_first_child().
 */
44
EggNode *EggGroupNode::get_next_child(void);

1234 12 get_children 0 4 2009 26 EggGroupNode::get_children 0 1 249 0
49
PyObject *EggGroupNode::get_children(void) const;

1235 9 add_child 0 4 2009 23 EggGroupNode::add_child 0 1 250 143
/**
 * Adds the indicated child to the group and returns it.  If the child node is
 * already a child of some other node, removes it first.
 */
48
EggNode *EggGroupNode::add_child(EggNode *node);

1236 12 remove_child 0 4 2009 26 EggGroupNode::remove_child 0 1 251 152
/**
 * Removes the indicated child node from the group and returns it.  If the
 * child was not already in the group, does nothing and returns NULL.
 */
63
PointerTo< EggNode > EggGroupNode::remove_child(EggNode *node);

1237 14 steal_children 0 4 2009 28 EggGroupNode::steal_children 0 1 252 171
/**
 * Moves all the children from the other node to this one.  This is especially
 * useful because the group node copy assignment operator does not copy
 * children.
 */
55
void EggGroupNode::steal_children(EggGroupNode &other);

1238 10 find_child 0 4 2009 24 EggGroupNode::find_child 0 1 253 169
/**
 * Returns the child of this node whose name is the indicated string, or NULL
 * if there is no child of this node by that name.  Does not search
 * recursively.
 */
65
EggNode *EggGroupNode::find_child(std::string const &name) const;

1239 22 has_absolute_pathnames 0 4 2009 36 EggGroupNode::has_absolute_pathnames 0 1 254 160
/**
 * Returns true if any nodes at this level and below include a reference to a
 * file via an absolute pathname, or false if all references are relative.
 */
54
bool EggGroupNode::has_absolute_pathnames(void) const;

1240 17 resolve_filenames 0 4 2009 31 EggGroupNode::resolve_filenames 0 1 255 207
/**
 * Walks the tree and attempts to resolve any filenames encountered.  This
 * looks up filenames along the specified search path; it does not
 * automatically search the model_path for missing files.
 */
68
void EggGroupNode::resolve_filenames(DSearchPath const &searchpath);

1241 15 force_filenames 0 4 2009 29 EggGroupNode::force_filenames 0 1 256 190
/**
 * Similar to resolve_filenames, but each non-absolute filename encountered is
 * arbitrarily taken to be in the indicated directory, whether or not the so-
 * named filename exists.
 */
62
void EggGroupNode::force_filenames(Filename const &directory);

1242 23 reverse_vertex_ordering 0 4 2009 37 EggGroupNode::reverse_vertex_ordering 0 1 257 136
/**
 * Reverses the vertex ordering of all polygons defined at this node and
 * below.  Does not change the surface normals, if any.
 */
49
void EggGroupNode::reverse_vertex_ordering(void);

1243 24 recompute_vertex_normals 0 4 2009 38 EggGroupNode::recompute_vertex_normals 0 1 258 711
/**
 * Recomputes all the vertex normals for polygon geometry at this group node
 * and below so that they accurately reflect the vertex positions.  A shared
 * edge between two polygons (even in different groups) is considered smooth
 * if the angle between the two edges is less than threshold degrees.
 *
 * This function also removes degenerate polygons that do not have enough
 * vertices to define a normal.  It does not affect normals for other kinds of
 * primitives like Nurbs or Points.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the correct normals.  Thus, it is a good idea
 * to call remove_unused_vertices() after calling this.
 */
98
void EggGroupNode::recompute_vertex_normals(double threshold, CoordinateSystem cs = ::CS_default);

1244 25 recompute_polygon_normals 0 4 2009 39 EggGroupNode::recompute_polygon_normals 0 1 259 672
/**
 * Recomputes all the polygon normals for polygon geometry at this group node
 * and below so that they accurately reflect the vertex positions.  Normals
 * are removed from the vertices and defined only on polygons, giving the
 * geometry a faceted appearance.
 *
 * This function also removes degenerate polygons that do not have enough
 * vertices to define a normal.  It does not affect normals for other kinds of
 * primitives like Nurbs or Points.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the normals removed.  Thus, it is a good idea
 * to call remove_unused_vertices() after calling this.
 */
81
void EggGroupNode::recompute_polygon_normals(CoordinateSystem cs = ::CS_default);

1245 13 strip_normals 0 4 2009 27 EggGroupNode::strip_normals 0 1 260 317
/**
 * Removes all normals from primitives, and the vertices they reference, at
 * this node and below.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the normal removed.  Thus, it is a good idea to
 * call remove_unused_vertices() after calling this.
 */
39
void EggGroupNode::strip_normals(void);

1246 26 recompute_tangent_binormal 0 4 2009 40 EggGroupNode::recompute_tangent_binormal 0 2 261 262 907
/**
 * This function recomputes the tangent and binormal for the named texture
 * coordinate set for all vertices at this level and below.  Use the empty
 * string for the default texture coordinate set.
 *
 * It is necessary for each vertex to already have a normal (or at least a
 * polygon normal), as well as a texture coordinate in the named texture
 * coordinate set, before calling this function.  You might precede this with
 * recompute_vertex_normals() to ensure that the normals exist.
 *
 * Like recompute_vertex_normals(), this function does not remove or adjust
 * vertices in the vertex pool; it only adds new vertices with the new
 * tangents and binormals computed.  Thus, it is a good idea to call
 * remove_unused_vertices() after calling this.
 */

/**
 * This function recomputes the tangent and binormal for the named texture
 * coordinate sets.  Returns true if anything was done.
 */
149
bool EggGroupNode::recompute_tangent_binormal(GlobPattern const &uv_name);
bool EggGroupNode::recompute_tangent_binormal(vector_string const &names);

1247 31 recompute_tangent_binormal_auto 0 4 2009 45 EggGroupNode::recompute_tangent_binormal_auto 0 1 263 160
/**
 * This function recomputes the tangent and binormal for any texture
 * coordinate set that affects a normal map.  Returns true if anything was
 * done.
 */
57
bool EggGroupNode::recompute_tangent_binormal_auto(void);

1248 20 triangulate_polygons 0 4 2009 34 EggGroupNode::triangulate_polygons 0 1 264 428
/**
 * Replace all higher-order polygons at this point in the scene graph and
 * below with triangles.  Returns the total number of new triangles produced,
 * less degenerate polygons removed.
 *
 * If flags contains T_polygon and T_convex, both concave and convex polygons
 * will be subdivided into triangles; with only T_polygon, only concave
 * polygons will be subdivided, and convex polygons will be largely unchanged.
 */
50
int EggGroupNode::triangulate_polygons(int flags);

1249 14 mesh_triangles 0 4 2009 28 EggGroupNode::mesh_triangles 0 1 265 84
/**
 * Combine triangles together into triangle strips, at this group and below.
 */
45
void EggGroupNode::mesh_triangles(int flags);

1250 21 make_point_primitives 0 4 2009 35 EggGroupNode::make_point_primitives 0 1 266 127
/**
 * Creates PointLight primitives to reference any otherwise unreferences
 * vertices discovered in this group or below.
 */
47
void EggGroupNode::make_point_primitives(void);

1251 12 rename_nodes 0 4 2009 26 EggGroupNode::rename_nodes 0 1 267 45
/**
 * Rename by stripping out the prefix
 */
73
int EggGroupNode::rename_nodes(vector_string strip_prefix, bool recurse);

1252 22 remove_unused_vertices 0 4 2009 36 EggGroupNode::remove_unused_vertices 0 1 268 692
/**
 * Removes all vertices from VertexPools within this group or below that are
 * not referenced by at least one primitive.  Also collapses together
 * equivalent vertices, and renumbers all vertices after the operation so
 * their indices are consecutive, beginning at zero.  Returns the total number
 * of vertices removed.
 *
 * Note that this operates on the VertexPools within this group level, without
 * respect to primitives that reference these vertices (unlike other functions
 * like strip_normals()).  It is therefore most useful to call this on the
 * EggData root, rather than on a subgroup within the hierarchy, since a
 * VertexPool may appear anywhere in the hierarchy.
 */
55
int EggGroupNode::remove_unused_vertices(bool recurse);

1253 25 remove_invalid_primitives 0 4 2009 39 EggGroupNode::remove_invalid_primitives 0 1 269 181
/**
 * Removes primitives at this level and below which appear to be degenerate;
 * e.g.  polygons with fewer than 3 vertices, etc.  Returns the number of
 * primitives removed.
 */
58
int EggGroupNode::remove_invalid_primitives(bool recurse);

1254 23 clear_connected_shading 0 4 2009 37 EggGroupNode::clear_connected_shading 0 1 270 319
/**
 * Resets the connected_shading information on all primitives at this node and
 * below, so that it may be accurately rederived by the next call to
 * get_connected_shading().
 *
 * It may be a good idea to call remove_unused_vertices() as well, to
 * establish the correct connectivity between common vertices.
 */
49
void EggGroupNode::clear_connected_shading(void);

1255 21 get_connected_shading 0 4 2009 35 EggGroupNode::get_connected_shading 0 1 271 194
/**
 * Queries the connected_shading information on all primitives at this node
 * and below, to ensure that it has been completely filled in before we start
 * mucking around with vertices.
 */
47
void EggGroupNode::get_connected_shading(void);

1256 16 unify_attributes 0 4 2009 30 EggGroupNode::unify_attributes 0 1 272 1065
/**
 * Applies per-vertex normal and color to all vertices, if they are in fact
 * per-vertex (and different for each vertex), or moves them to the primitive
 * if they are all the same.
 *
 * After this call, either the primitive will have normals or its vertices
 * will, but not both.  Ditto for colors.
 *
 * If use_connected_shading is true, each polygon is considered in conjunction
 * with all connected polygons; otherwise, each polygon is considered
 * individually.
 *
 * If allow_per_primitive is false, S_per_face or S_overall will treated like
 * S_per_vertex: normals and colors will always be assigned to the vertices.
 * In this case, there will never be per-primitive colors or normals after
 * this call returns.  On the other hand, if allow_per_primitive is true, then
 * S_per_face means that normals and colors should be assigned to the
 * primitives, and removed from the vertices, as described above.
 *
 * This may create redundant vertices in the vertex pool, so it may be a good
 * idea to follow this up with remove_unused_vertices().
 */
104
void EggGroupNode::unify_attributes(bool use_connected_shading, bool allow_per_primitive, bool recurse);

1257 20 apply_last_attribute 0 4 2009 34 EggGroupNode::apply_last_attribute 0 1 273 424
/**
 * Sets the last vertex of the triangle (or each component) to the primitive
 * normal and/or color, if the primitive is flat-shaded.  This reflects the
 * OpenGL convention of storing flat-shaded properties on the last vertex,
 * although it is not usually a convention in Egg.
 *
 * This may create redundant vertices in the vertex pool, so it may be a good
 * idea to follow this up with remove_unused_vertices().
 */
54
void EggGroupNode::apply_last_attribute(bool recurse);

1258 21 apply_first_attribute 0 4 2009 35 EggGroupNode::apply_first_attribute 0 1 274 427
/**
 * Sets the first vertex of the triangle (or each component) to the primitive
 * normal and/or color, if the primitive is flat-shaded.  This reflects the
 * DirectX convention of storing flat-shaded properties on the first vertex,
 * although it is not usually a convention in Egg.
 *
 * This may create redundant vertices in the vertex pool, so it may be a good
 * idea to follow this up with remove_unused_vertices().
 */
55
void EggGroupNode::apply_first_attribute(bool recurse);

1259 25 post_apply_flat_attribute 0 4 2009 39 EggGroupNode::post_apply_flat_attribute 0 1 275 217
/**
 * Intended as a followup to apply_last_attribute(), this also sets an
 * attribute on the first vertices of the primitive, if they don't already
 * have an attribute set, just so they end up with *something*.
 */
59
void EggGroupNode::post_apply_flat_attribute(bool recurse);

1260 14 has_primitives 0 6 2009 28 EggGroupNode::has_primitives 0 1 276 124
/**
 * Returns true if there are any primitives (e.g.  polygons) defined within
 * this group or below, false otherwise.
 */
54
virtual bool EggGroupNode::has_primitives(void) const;

1261 20 joint_has_primitives 0 6 2009 34 EggGroupNode::joint_has_primitives 0 1 277 154
/**
 * Returns true if there are any primitives (e.g.  polygons) defined within
 * this group or below, but the search does not include nested joints.
 */
60
virtual bool EggGroupNode::joint_has_primitives(void) const;

1262 11 has_normals 0 6 2009 25 EggGroupNode::has_normals 0 1 278 164
/**
 * Returns true if any of the primitives (e.g.  polygons) defined within this
 * group or below have either face or vertex normals defined, false otherwise.
 */
51
virtual bool EggGroupNode::has_normals(void) const;

1263 8 is_right 0 4 2009 22 EggGroupNode::is_right 0 1 279 60
/**
 * Returns true if the 2-d v1 is to the right of v2.
 */
84
static inline bool EggGroupNode::is_right(LVector2d const &v1, LVector2d const &v2);

1264 14 get_class_type 0 4 2009 28 EggGroupNode::get_class_type 0 1 280 0
53
static TypeHandle EggGroupNode::get_class_type(void);

1265 13 EggRenderMode 0 4 2011 28 EggRenderMode::EggRenderMode 0 2 281 282 22
/**
 *
 */

/**
 *
 */
99
EggRenderMode::EggRenderMode(void);
inline EggRenderMode::EggRenderMode(EggRenderMode const &copy);

1266 10 operator = 0 4 2011 25 EggRenderMode::operator = 0 1 283 10
/**
 *
 */
68
EggRenderMode &EggRenderMode::operator =(EggRenderMode const &copy);

1267 5 write 0 4 2011 20 EggRenderMode::write 0 1 284 78
/**
 * Writes the attributes to the indicated output stream in Egg format.
 */
64
void EggRenderMode::write(ostream &out, int indent_level) const;

1268 14 set_alpha_mode 0 4 2011 29 EggRenderMode::set_alpha_mode 0 1 285 500
/**
 * Specifies precisely how the transparency for this geometry should be
 * achieved, or if it should be used.  The default, AM_unspecified, is to use
 * transparency if the geometry has a color whose alpha value is non-1, or if
 * it has a four-channel texture applied; otherwise, AM_on forces transparency
 * on, and AM_off forces it off.  The other flavors of transparency are
 * specific ways to turn on transparency, which may or may not be supported by
 * a particular rendering backend.
 */
73
inline void EggRenderMode::set_alpha_mode(EggRenderMode::AlphaMode mode);

1269 14 get_alpha_mode 0 4 2011 29 EggRenderMode::get_alpha_mode 0 1 286 110
/**
 * Returns the alpha mode that was set, or AM_unspecified if nothing was set.
 * See set_alpha_mode().
 */
74
inline EggRenderMode::AlphaMode EggRenderMode::get_alpha_mode(void) const;

1270 20 set_depth_write_mode 0 4 2011 35 EggRenderMode::set_depth_write_mode 0 1 287 160
/**
 * Specifies whether writes should be made to the depth buffer (assuming the
 * rendering backend provides a depth buffer) when rendering this geometry.
 */
84
inline void EggRenderMode::set_depth_write_mode(EggRenderMode::DepthWriteMode mode);

1271 20 get_depth_write_mode 0 4 2011 35 EggRenderMode::get_depth_write_mode 0 1 288 124
/**
 * Returns the depth_write mode that was set, or DWM_unspecified if nothing
 * was set.  See set_depth_write_mode().
 */
85
inline EggRenderMode::DepthWriteMode EggRenderMode::get_depth_write_mode(void) const;

1272 19 set_depth_test_mode 0 4 2011 34 EggRenderMode::set_depth_test_mode 0 1 289 238
/**
 * Specifies whether this geometry should be tested against the depth buffer
 * when it is drawn (assuming the rendering backend provides a depth buffer).
 * Note that this is different, and independent from, the depth_write mode.
 */
82
inline void EggRenderMode::set_depth_test_mode(EggRenderMode::DepthTestMode mode);

1273 19 get_depth_test_mode 0 4 2011 34 EggRenderMode::get_depth_test_mode 0 1 290 122
/**
 * Returns the depth_test mode that was set, or DTM_unspecified if nothing was
 * set.  See set_depth_test_mode().
 */
83
inline EggRenderMode::DepthTestMode EggRenderMode::get_depth_test_mode(void) const;

1274 19 set_visibility_mode 0 4 2011 34 EggRenderMode::set_visibility_mode 0 1 291 252
/**
 * Specifies whether this geometry is to be considered normally visible, or
 * hidden.  If it is hidden, it is either not loaded into the scene graph at
 * all, or loaded as a "stashed" node, according to the setting of egg-
 * suppress-hidden.
 */
83
inline void EggRenderMode::set_visibility_mode(EggRenderMode::VisibilityMode mode);

1275 19 get_visibility_mode 0 4 2011 34 EggRenderMode::get_visibility_mode 0 1 292 121
/**
 * Returns the visibility mode that was set, or VM_unspecified if nothing was
 * set.  See set_visibility_mode().
 */
84
inline EggRenderMode::VisibilityMode EggRenderMode::get_visibility_mode(void) const;

1276 16 set_depth_offset 0 4 2011 31 EggRenderMode::set_depth_offset 0 1 293 198
/**
 * Sets the "depth-offset" flag associated with this object.  This adds or
 * subtracts an offset bias into the depth buffer.  See also DepthOffsetAttrib
 * and NodePath::set_depth_offset().
 */
54
inline void EggRenderMode::set_depth_offset(int bias);

1277 16 get_depth_offset 0 4 2011 31 EggRenderMode::get_depth_offset 0 1 294 105
/**
 * Returns the "depth-offset" flag as set for this particular object.  See
 * set_depth_offset().
 */
55
inline int EggRenderMode::get_depth_offset(void) const;

1278 16 has_depth_offset 0 4 2011 31 EggRenderMode::has_depth_offset 0 1 295 117
/**
 * Returns true if the depth-offset flag has been set for this particular
 * object.  See set_depth_offset().
 */
56
inline bool EggRenderMode::has_depth_offset(void) const;

1279 18 clear_depth_offset 0 4 2011 33 EggRenderMode::clear_depth_offset 0 1 296 97
/**
 * Removes the depth-offset flag from this particular object.  See
 * set_depth_offset().
 */
52
inline void EggRenderMode::clear_depth_offset(void);

1280 14 set_draw_order 0 4 2011 29 EggRenderMode::set_draw_order 0 1 297 260
/**
 * Sets the "draw-order" flag associated with this object.  This specifies a
 * particular order in which objects of this type should be drawn, within the
 * specified bin.  If a bin is not explicitly specified, "fixed" is used.  See
 * also set_bin().
 */
53
inline void EggRenderMode::set_draw_order(int order);

1281 14 get_draw_order 0 4 2011 29 EggRenderMode::get_draw_order 0 1 298 101
/**
 * Returns the "draw-order" flag as set for this particular object.  See
 * set_draw_order().
 */
53
inline int EggRenderMode::get_draw_order(void) const;

1282 14 has_draw_order 0 4 2011 29 EggRenderMode::has_draw_order 0 1 299 113
/**
 * Returns true if the draw-order flag has been set for this particular
 * object.  See set_draw_order().
 */
54
inline bool EggRenderMode::has_draw_order(void) const;

1283 16 clear_draw_order 0 4 2011 31 EggRenderMode::clear_draw_order 0 1 300 93
/**
 * Removes the draw-order flag from this particular object.  See
 * set_draw_order().
 */
50
inline void EggRenderMode::clear_draw_order(void);

1284 7 set_bin 0 4 2011 22 EggRenderMode::set_bin 0 1 301 378
/**
 * Sets the "bin" string for this particular object.  This names a particular
 * bin in which the object should be rendered.  The exact meaning of a bin is
 * implementation defined, but generally a GeomBin matching each bin name must
 * also be specifically added to the rendering engine (e.g.  the
 * CullTraverser) in use for this to work.  See also set_draw_order().
 */
59
inline void EggRenderMode::set_bin(std::string const &bin);

1285 7 get_bin 0 4 2011 22 EggRenderMode::get_bin 0 1 302 103
/**
 * Returns the bin name that has been set for this particular object, if any.
 * See set_bin().
 */
54
inline std::string EggRenderMode::get_bin(void) const;

1286 7 has_bin 0 4 2011 22 EggRenderMode::has_bin 0 1 303 97
/**
 * Returns true if a bin name has been set for this particular object.  See
 * set_bin().
 */
47
inline bool EggRenderMode::has_bin(void) const;

1287 9 clear_bin 0 4 2011 24 EggRenderMode::clear_bin 0 1 304 91
/**
 * Removes the bin name that was set for this particular object.  See
 * set_bin().
 */
43
inline void EggRenderMode::clear_bin(void);

1288 11 operator == 0 4 2011 26 EggRenderMode::operator == 0 1 305 34
// Comparison operators are handy.
66
bool EggRenderMode::operator ==(EggRenderMode const &other) const;

1289 11 operator != 0 4 2011 26 EggRenderMode::operator != 0 1 306 0
73
inline bool EggRenderMode::operator !=(EggRenderMode const &other) const;

1290 10 operator < 0 4 2011 25 EggRenderMode::operator < 0 1 307 0
65
bool EggRenderMode::operator <(EggRenderMode const &other) const;

1291 17 string_alpha_mode 0 4 2011 32 EggRenderMode::string_alpha_mode 0 1 308 167
/**
 * Returns the AlphaMode value associated with the given string
 * representation, or AM_unspecified if the string does not match any known
 * AlphaMode value.
 */
92
static EggRenderMode::AlphaMode EggRenderMode::string_alpha_mode(std::string const &string);

1292 23 string_depth_write_mode 0 4 2011 38 EggRenderMode::string_depth_write_mode 0 1 309 178
/**
 * Returns the DepthWriteMode value associated with the given string
 * representation, or DWM_unspecified if the string does not match any known
 * DepthWriteMode value.
 */
103
static EggRenderMode::DepthWriteMode EggRenderMode::string_depth_write_mode(std::string const &string);

1293 22 string_depth_test_mode 0 4 2011 37 EggRenderMode::string_depth_test_mode 0 1 310 176
/**
 * Returns the DepthTestMode value associated with the given string
 * representation, or DTM_unspecified if the string does not match any known
 * DepthTestMode value.
 */
101
static EggRenderMode::DepthTestMode EggRenderMode::string_depth_test_mode(std::string const &string);

1294 22 string_visibility_mode 0 4 2011 37 EggRenderMode::string_visibility_mode 0 1 311 169
/**
 * Returns the HiddenMode value associated with the given string
 * representation, or VM_unspecified if the string does not match any known
 * HiddenMode value.
 */
102
static EggRenderMode::VisibilityMode EggRenderMode::string_visibility_mode(std::string const &string);

1295 14 get_class_type 0 4 2011 29 EggRenderMode::get_class_type 0 1 312 0
54
static TypeHandle EggRenderMode::get_class_type(void);

1296 14 ~EggRenderMode 0 4 2011 29 EggRenderMode::~EggRenderMode 0 0 0
36
EggRenderMode::~EggRenderMode(void);

1297 12 EggTransform 0 4 2016 26 EggTransform::EggTransform 0 2 313 314 22
/**
 *
 */

/**
 *
 */
87
EggTransform::EggTransform(void);
EggTransform::EggTransform(EggTransform const &copy);

1298 10 operator = 0 4 2016 24 EggTransform::operator = 0 1 315 10
/**
 *
 */
65
EggTransform &EggTransform::operator =(EggTransform const &copy);

1299 13 ~EggTransform 0 6 2016 27 EggTransform::~EggTransform 0 0 10
/**
 *
 */
42
virtual EggTransform::~EggTransform(void);

1300 15 clear_transform 0 4 2016 29 EggTransform::clear_transform 0 1 316 51
/**
 * Resets the transform to empty, identity.
 */
48
inline void EggTransform::clear_transform(void);

1301 15 add_translate2d 0 4 2016 29 EggTransform::add_translate2d 0 1 317 72
/**
 * Appends a 2-d translation operation to the current transform.
 */
63
void EggTransform::add_translate2d(LVector2d const &translate);

1302 15 add_translate3d 0 4 2016 29 EggTransform::add_translate3d 0 1 318 72
/**
 * Appends a 3-d translation operation to the current transform.
 */
63
void EggTransform::add_translate3d(LVector3d const &translate);

1303 12 add_rotate2d 0 4 2016 26 EggTransform::add_rotate2d 0 1 319 141
/**
 * Appends a 2-d rotation to the current transform.  The rotation angle is
 * specified in degrees counterclockwise about the origin.
 */
46
void EggTransform::add_rotate2d(double angle);

1304 8 add_rotx 0 4 2016 22 EggTransform::add_rotx 0 1 320 152
/**
 * Appends a rotation about the X axis to the current transform.  The rotation
 * angle is specified in degrees counterclockwise about the axis.
 */
42
void EggTransform::add_rotx(double angle);

1305 8 add_roty 0 4 2016 22 EggTransform::add_roty 0 1 321 152
/**
 * Appends a rotation about the Y axis to the current transform.  The rotation
 * angle is specified in degrees counterclockwise about the axis.
 */
42
void EggTransform::add_roty(double angle);

1306 8 add_rotz 0 4 2016 22 EggTransform::add_rotz 0 1 322 152
/**
 * Appends a rotation about the Z axis to the current transform.  The rotation
 * angle is specified in degrees counterclockwise about the axis.
 */
42
void EggTransform::add_rotz(double angle);

1307 12 add_rotate3d 0 4 2016 26 EggTransform::add_rotate3d 0 2 323 324 324
/**
 * Appends a 3-d rotation about an arbitrary axis to the current transform.
 * The rotation angle is specified in degrees counterclockwise about the axis.
 */

/**
 * Appends an arbitrary 3-d rotation to the current transform, expressed as a
 * quaternion.  This is converted to axis-angle notation for the egg file.
 */
128
void EggTransform::add_rotate3d(double angle, LVector3d const &axis);
void EggTransform::add_rotate3d(LQuaterniond const &quat);

1308 11 add_scale2d 0 4 2016 25 EggTransform::add_scale2d 0 1 325 73
/**
 * Appends a possibly non-uniform scale to the current transform.
 */
56
void EggTransform::add_scale2d(LVecBase2d const &scale);

1309 11 add_scale3d 0 4 2016 25 EggTransform::add_scale3d 0 1 326 73
/**
 * Appends a possibly non-uniform scale to the current transform.
 */
56
void EggTransform::add_scale3d(LVecBase3d const &scale);

1310 17 add_uniform_scale 0 4 2016 31 EggTransform::add_uniform_scale 0 1 327 60
/**
 * Appends a uniform scale to the current transform.
 */
51
void EggTransform::add_uniform_scale(double scale);

1311 11 add_matrix3 0 4 2016 25 EggTransform::add_matrix3 0 1 328 68
/**
 * Appends an arbitrary 3x3 matrix to the current transform.
 */
60
inline void EggTransform::add_matrix3(LMatrix3d const &mat);

1312 11 add_matrix4 0 4 2016 25 EggTransform::add_matrix4 0 1 329 68
/**
 * Appends an arbitrary 4x4 matrix to the current transform.
 */
60
inline void EggTransform::add_matrix4(LMatrix4d const &mat);

1313 13 has_transform 0 4 2016 27 EggTransform::has_transform 0 1 330 174
/**
 * Returns true if the transform is nonempty, false if it is empty (no
 * transform components have been added).  This is true for either a 2-d or a
 * 3-d transform.
 */
52
inline bool EggTransform::has_transform(void) const;

1314 15 has_transform2d 0 4 2016 29 EggTransform::has_transform2d 0 1 331 328
/**
 * Returns true if the transform is specified as a 2-d transform, e.g.  with a
 * 3x3 matrix, or false if it is specified as a 3-d transform (with a 4x4
 * matrix), or not specified at all.
 *
 * Normally, EggTextures have a 2-d matrix (but occasionally they use a 3-d
 * matrix), and EggGroups always have a 3-d matrix.
 */
54
inline bool EggTransform::has_transform2d(void) const;

1315 15 set_transform2d 0 4 2016 29 EggTransform::set_transform2d 0 1 332 139
/**
 * Sets the overall transform as a 3x3 matrix.  This completely replaces
 * whatever componentwise transform may have been defined.
 */
64
inline void EggTransform::set_transform2d(LMatrix3d const &mat);

1316 15 has_transform3d 0 4 2016 29 EggTransform::has_transform3d 0 1 333 328
/**
 * Returns true if the transform is specified as a 3-d transform, e.g.  with a
 * 4x4 matrix, or false if it is specified as a 2-d transform (with a 2x2
 * matrix), or not specified at all.
 *
 * Normally, EggTextures have a 3-d matrix (but occasionally they use a 3-d
 * matrix), and EggGroups always have a 3-d matrix.
 */
54
inline bool EggTransform::has_transform3d(void) const;

1317 15 set_transform3d 0 4 2016 29 EggTransform::set_transform3d 0 1 334 139
/**
 * Sets the overall transform as a 4x4 matrix.  This completely replaces
 * whatever componentwise transform may have been defined.
 */
64
inline void EggTransform::set_transform3d(LMatrix4d const &mat);

1318 15 get_transform2d 0 4 2016 29 EggTransform::get_transform2d 0 1 335 119
/**
 * Returns the overall transform as a 3x3 matrix.  It is an error to call this
 * if has_transform3d() is true.
 */
59
inline LMatrix3d EggTransform::get_transform2d(void) const;

1319 15 get_transform3d 0 4 2016 29 EggTransform::get_transform3d 0 1 336 190
/**
 * Returns the overall transform as a 4x4 matrix.  It is valid to call this
 * even if has_transform2d() is true; in this case, the 3x3 transform will be
 * expanded to a 4x4 matrix.
 */
66
inline LMatrix4d const &EggTransform::get_transform3d(void) const;

1320 21 transform_is_identity 0 4 2016 35 EggTransform::transform_is_identity 0 1 337 80
/**
 * Returns true if the described transform is identity, false otherwise.
 */
60
inline bool EggTransform::transform_is_identity(void) const;

1321 18 get_num_components 0 4 2016 32 EggTransform::get_num_components 0 1 338 71
/**
 * Returns the number of components that make up the transform.
 */
56
inline int EggTransform::get_num_components(void) const;

1322 18 get_component_type 0 4 2016 32 EggTransform::get_component_type 0 1 339 49
/**
 * Returns the type of the nth component.
 */
81
inline EggTransform::ComponentType EggTransform::get_component_type(int n) const;

1323 20 get_component_number 0 4 2016 34 EggTransform::get_component_number 0 1 340 252
/**
 * Returns the solitary number associated with the nth component.  In the case
 * of a rotation, this is the angle in degrees to rotate; in the case of
 * uniform scale, this is the amount of the scale.  Other types do not use
 * this property.
 */
62
inline double EggTransform::get_component_number(int n) const;

1324 18 get_component_vec2 0 4 2016 32 EggTransform::get_component_vec2 0 1 341 239
/**
 * Returns the 2-component vector associated with the nth component.  This may
 * be the translate vector, rotate axis, or non-uniform scale.  It is an error
 * to call this if the component type does not use a 2-d vector property.
 */
71
inline LVecBase2d const &EggTransform::get_component_vec2(int n) const;

1325 18 get_component_vec3 0 4 2016 32 EggTransform::get_component_vec3 0 1 342 239
/**
 * Returns the 3-component vector associated with the nth component.  This may
 * be the translate vector, rotate axis, or non-uniform scale.  It is an error
 * to call this if the component type does not use a 3-d vector property.
 */
71
inline LVecBase3d const &EggTransform::get_component_vec3(int n) const;

1326 18 get_component_mat3 0 4 2016 32 EggTransform::get_component_mat3 0 1 343 141
/**
 * Returns the 3x3 matrix associated with the nth component.  It is an error
 * to call this if the component type is not CT_matrix3.
 */
70
inline LMatrix3d const &EggTransform::get_component_mat3(int n) const;

1327 18 get_component_mat4 0 4 2016 32 EggTransform::get_component_mat4 0 1 344 141
/**
 * Returns the 4x4 matrix associated with the nth component.  It is an error
 * to call this if the component type is not CT_matrix4.
 */
70
inline LMatrix4d const &EggTransform::get_component_mat4(int n) const;

1328 5 write 0 4 2016 19 EggTransform::write 0 1 345 70
/**
 * Writes the transform to the indicated stream in Egg format.
 */
89
void EggTransform::write(ostream &out, int indent_level, std::string const &label) const;

1329 9 make_copy 0 6 2018 29 EggSwitchCondition::make_copy 0 1 346 0
74
virtual EggSwitchCondition *EggSwitchCondition::make_copy(void) const = 0;

1330 5 write 0 6 2018 25 EggSwitchCondition::write 0 1 347 0
81
virtual void EggSwitchCondition::write(ostream &out, int indent_level) const = 0;

1331 9 transform 0 6 2018 29 EggSwitchCondition::transform 0 1 348 0
69
virtual void EggSwitchCondition::transform(LMatrix4d const &mat) = 0;

1332 14 get_class_type 0 4 2018 34 EggSwitchCondition::get_class_type 0 1 349 0
59
static TypeHandle EggSwitchCondition::get_class_type(void);

1333 19 ~EggSwitchCondition 0 4 2018 39 EggSwitchCondition::~EggSwitchCondition 0 0 0
46
EggSwitchCondition::~EggSwitchCondition(void);

1334 26 EggSwitchConditionDistance 0 4 2019 54 EggSwitchConditionDistance::EggSwitchConditionDistance 0 1 350 10
/**
 *
 */
135
EggSwitchConditionDistance::EggSwitchConditionDistance(double switch_in, double switch_out, LPoint3d const &center, double fade = 0.0);

1335 14 get_class_type 0 4 2019 42 EggSwitchConditionDistance::get_class_type 0 1 351 0
67
static TypeHandle EggSwitchConditionDistance::get_class_type(void);

1336 27 ~EggSwitchConditionDistance 0 4 2019 55 EggSwitchConditionDistance::~EggSwitchConditionDistance 0 0 0
62
EggSwitchConditionDistance::~EggSwitchConditionDistance(void);

1337 22 upcast_to_EggGroupNode 0 12 2020 32 EggGroup::upcast_to_EggGroupNode 0 1 490 36
upcast from EggGroup to EggGroupNode
53
EggGroupNode *EggGroup::upcast_to_EggGroupNode(void);

1338 20 downcast_to_EggGroup 0 12 2009 34 EggGroupNode::downcast_to_EggGroup 0 1 491 38
downcast from EggGroupNode to EggGroup
51
EggGroup *EggGroupNode::downcast_to_EggGroup(void);

1339 23 upcast_to_EggRenderMode 0 12 2020 33 EggGroup::upcast_to_EggRenderMode 0 1 492 37
upcast from EggGroup to EggRenderMode
55
EggRenderMode *EggGroup::upcast_to_EggRenderMode(void);

1340 20 downcast_to_EggGroup 0 12 2011 35 EggRenderMode::downcast_to_EggGroup 0 1 493 39
downcast from EggRenderMode to EggGroup
52
EggGroup *EggRenderMode::downcast_to_EggGroup(void);

1341 22 upcast_to_EggTransform 0 12 2020 32 EggGroup::upcast_to_EggTransform 0 1 494 36
upcast from EggGroup to EggTransform
53
EggTransform *EggGroup::upcast_to_EggTransform(void);

1342 20 downcast_to_EggGroup 0 12 2016 34 EggTransform::downcast_to_EggGroup 0 1 495 38
downcast from EggTransform to EggGroup
51
EggGroup *EggTransform::downcast_to_EggGroup(void);

1343 8 EggGroup 0 4 2020 18 EggGroup::EggGroup 0 2 352 353 22
/**
 *
 */

/**
 *
 */
91
EggGroup::EggGroup(std::string const &name = "");
EggGroup::EggGroup(EggGroup const &copy);

1344 10 operator = 0 4 2020 20 EggGroup::operator = 0 1 354 10
/**
 *
 */
53
EggGroup &EggGroup::operator =(EggGroup const &copy);

1345 9 ~EggGroup 0 6 2020 19 EggGroup::~EggGroup 0 0 10
/**
 *
 */
34
virtual EggGroup::~EggGroup(void);

1346 5 write 0 6 2020 15 EggGroup::write 0 1 355 100
/**
 * Writes the group and all of its children to the indicated output stream in
 * Egg format.
 */
67
virtual void EggGroup::write(ostream &out, int indent_level) const;

1347 21 write_billboard_flags 0 4 2020 31 EggGroup::write_billboard_flags 0 1 356 92
/**
 * Writes just the <Billboard> entry and related fields to the indicated
 * ostream.
 */
75
void EggGroup::write_billboard_flags(ostream &out, int indent_level) const;

1348 19 write_collide_flags 0 4 2020 29 EggGroup::write_collide_flags 0 1 357 90
/**
 * Writes just the <Collide> entry and related fields to the indicated
 * ostream.
 */
73
void EggGroup::write_collide_flags(ostream &out, int indent_level) const;

1349 17 write_model_flags 0 4 2020 27 EggGroup::write_model_flags 0 1 358 78
/**
 * Writes the <Model> flag and related flags to the indicated ostream.
 */
71
void EggGroup::write_model_flags(ostream &out, int indent_level) const;

1350 18 write_switch_flags 0 4 2020 28 EggGroup::write_switch_flags 0 1 359 79
/**
 * Writes the <Switch> flag and related flags to the indicated ostream.
 */
72
void EggGroup::write_switch_flags(ostream &out, int indent_level) const;

1351 18 write_object_types 0 4 2020 28 EggGroup::write_object_types 0 1 360 83
/**
 * Writes just the <ObjectTypes> entries, if any, to the indicated ostream.
 */
72
void EggGroup::write_object_types(ostream &out, int indent_level) const;

1352 17 write_decal_flags 0 4 2020 27 EggGroup::write_decal_flags 0 1 361 56
/**
 * Writes the flags related to decaling, if any.
 */
71
void EggGroup::write_decal_flags(ostream &out, int indent_level) const;

1353 10 write_tags 0 4 2020 20 EggGroup::write_tags 0 1 362 75
/**
 * Writes just the <Tag> entries, if any, to the indicated ostream.
 */
64
void EggGroup::write_tags(ostream &out, int indent_level) const;

1354 17 write_render_mode 0 4 2020 27 EggGroup::write_render_mode 0 1 363 114
/**
 * Writes the flags inherited from EggRenderMode and similar flags that
 * control obscure render effects.
 */
71
void EggGroup::write_render_mode(ostream &out, int indent_level) const;

1355 8 is_joint 0 6 2020 18 EggGroup::is_joint 0 1 364 229
/**
 * Returns true if this particular node represents a <Joint> entry or not.
 * This is a handy thing to know since Joints are sorted to the end of their
 * sibling list when writing an egg file.  See EggGroupNode::write().
 */
44
virtual bool EggGroup::is_joint(void) const;

1356 20 determine_alpha_mode 0 6 2020 30 EggGroup::determine_alpha_mode 0 1 365 267
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has an alpha_mode
 * other than AM_unspecified.  Returns a valid EggRenderMode pointer if one is
 * found, or NULL otherwise.
 */
60
virtual EggRenderMode *EggGroup::determine_alpha_mode(void);

1357 26 determine_depth_write_mode 0 6 2020 36 EggGroup::determine_depth_write_mode 0 1 366 273
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a
 * depth_write_mode other than DWM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
66
virtual EggRenderMode *EggGroup::determine_depth_write_mode(void);

1358 25 determine_depth_test_mode 0 6 2020 35 EggGroup::determine_depth_test_mode 0 1 367 272
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a
 * depth_test_mode other than DTM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
65
virtual EggRenderMode *EggGroup::determine_depth_test_mode(void);

1359 25 determine_visibility_mode 0 6 2020 35 EggGroup::determine_visibility_mode 0 1 368 271
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a
 * visibility_mode other than VM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
65
virtual EggRenderMode *EggGroup::determine_visibility_mode(void);

1360 22 determine_depth_offset 0 6 2020 32 EggGroup::determine_depth_offset 0 1 369 252
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a depth_offset
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */
62
virtual EggRenderMode *EggGroup::determine_depth_offset(void);

1361 20 determine_draw_order 0 6 2020 30 EggGroup::determine_draw_order 0 1 370 250
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a draw_order
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */
60
virtual EggRenderMode *EggGroup::determine_draw_order(void);

1362 13 determine_bin 0 6 2020 23 EggGroup::determine_bin 0 1 371 243
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a bin
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */
53
virtual EggRenderMode *EggGroup::determine_bin(void);

1363 17 determine_indexed 0 6 2020 27 EggGroup::determine_indexed 0 1 372 321
/**
 * Walks back up the hierarchy, looking for an EggGroup at this level or above
 * that has the "indexed" scalar set.  Returns the value of the indexed scalar
 * if it is found, or false if it is not.
 *
 * In other words, returns true if the "indexed" flag is in effect for the
 * indicated node, false otherwise.
 */
47
virtual bool EggGroup::determine_indexed(void);

1364 15 determine_decal 0 6 2020 25 EggGroup::determine_decal 0 1 373 311
/**
 * Walks back up the hierarchy, looking for an EggGroup at this level or above
 * that has the "decal" flag set.  Returns the value of the decal flag if it
 * is found, or false if it is not.
 *
 * In other words, returns true if the "decal" flag is in effect for the
 * indicated node, false otherwise.
 */
45
virtual bool EggGroup::determine_decal(void);

1365 14 set_group_type 0 4 2020 24 EggGroup::set_group_type 0 1 374 10
/**
 *
 */
56
void EggGroup::set_group_type(EggGroup::GroupType type);

1366 14 get_group_type 0 4 2020 24 EggGroup::get_group_type 0 1 375 10
/**
 *
 */
64
inline EggGroup::GroupType EggGroup::get_group_type(void) const;

1367 16 is_instance_type 0 4 2020 26 EggGroup::is_instance_type 0 1 376 368
/**
 * Returns true if this group is an instance type node; i.e.  it begins the
 * root of a local coordinate space.  This is not related to instancing
 * (multiple copies of a node in a scene graph).
 *
 * This also includes the case of the node including a billboard flag without
 * an explicit center, which implicitly makes the node behave like an
 * instance.
 */
51
inline bool EggGroup::is_instance_type(void) const;

1368 18 set_billboard_type 0 4 2020 28 EggGroup::set_billboard_type 0 1 377 10
/**
 *
 */
71
inline void EggGroup::set_billboard_type(EggGroup::BillboardType type);

1369 18 get_billboard_type 0 4 2020 28 EggGroup::get_billboard_type 0 1 378 10
/**
 *
 */
72
inline EggGroup::BillboardType EggGroup::get_billboard_type(void) const;

1370 20 set_billboard_center 0 4 2020 30 EggGroup::set_billboard_center 0 1 379 694
/**
 * Sets the point around which the billboard will rotate, if this node
 * contains a billboard specification.
 *
 * If a billboard type is given but no billboard_center is specified, then the
 * group node is treated as an <Instance>, and the billboard rotates around
 * the origin.  If, however, a billboard_center is specified, then the group
 * node is *not* treated as an <Instance>, and the billboard rotates around
 * the specified point.
 *
 * The point is in the same coordinate system as the vertices of this node:
 * usually global, but possibly local if there is an <Instance> somewhere
 * above.  Specifically, this is the coordinate system defined by
 * get_vertex_frame().
 */
77
inline void EggGroup::set_billboard_center(LPoint3d const &billboard_center);

1371 22 clear_billboard_center 0 4 2020 32 EggGroup::clear_billboard_center 0 1 380 10
/**
 *
 */
51
inline void EggGroup::clear_billboard_center(void);

1372 20 has_billboard_center 0 4 2020 30 EggGroup::has_billboard_center 0 1 381 10
/**
 *
 */
55
inline bool EggGroup::has_billboard_center(void) const;

1373 20 get_billboard_center 0 4 2020 30 EggGroup::get_billboard_center 0 1 382 10
/**
 *
 */
66
inline LPoint3d const &EggGroup::get_billboard_center(void) const;

1374 11 set_cs_type 0 4 2020 21 EggGroup::set_cs_type 0 1 383 10
/**
 *
 */
69
inline void EggGroup::set_cs_type(EggGroup::CollisionSolidType type);

1375 11 get_cs_type 0 4 2020 21 EggGroup::get_cs_type 0 1 384 10
/**
 *
 */
70
inline EggGroup::CollisionSolidType EggGroup::get_cs_type(void) const;

1376 17 set_collide_flags 0 4 2020 27 EggGroup::set_collide_flags 0 1 385 10
/**
 *
 */
51
inline void EggGroup::set_collide_flags(int flags);

1377 17 get_collide_flags 0 4 2020 27 EggGroup::get_collide_flags 0 1 386 10
/**
 *
 */
70
inline EggGroup::CollideFlags EggGroup::get_collide_flags(void) const;

1378 18 set_collision_name 0 4 2020 28 EggGroup::set_collision_name 0 1 387 10
/**
 *
 */
76
inline void EggGroup::set_collision_name(std::string const &collision_name);

1379 20 clear_collision_name 0 4 2020 30 EggGroup::clear_collision_name 0 1 388 10
/**
 *
 */
49
inline void EggGroup::clear_collision_name(void);

1380 18 has_collision_name 0 4 2020 28 EggGroup::has_collision_name 0 1 389 10
/**
 *
 */
53
inline bool EggGroup::has_collision_name(void) const;

1381 18 get_collision_name 0 4 2020 28 EggGroup::get_collision_name 0 1 390 10
/**
 *
 */
67
inline std::string const &EggGroup::get_collision_name(void) const;

1382 12 set_dcs_type 0 4 2020 22 EggGroup::set_dcs_type 0 1 391 10
/**
 *
 */
59
inline void EggGroup::set_dcs_type(EggGroup::DCSType type);

1383 12 get_dcs_type 0 4 2020 22 EggGroup::get_dcs_type 0 1 392 10
/**
 *
 */
60
inline EggGroup::DCSType EggGroup::get_dcs_type(void) const;

1384 12 has_dcs_type 0 4 2020 22 EggGroup::has_dcs_type 0 1 393 91
/**
 * Returns true if the specified DCS type is not DC_none and not
 * DC_unspecified.
 */
47
inline bool EggGroup::has_dcs_type(void) const;

1385 13 set_dart_type 0 4 2020 23 EggGroup::set_dart_type 0 1 394 10
/**
 *
 */
61
inline void EggGroup::set_dart_type(EggGroup::DartType type);

1386 13 get_dart_type 0 4 2020 23 EggGroup::get_dart_type 0 1 395 10
/**
 *
 */
62
inline EggGroup::DartType EggGroup::get_dart_type(void) const;

1387 15 set_switch_flag 0 4 2020 25 EggGroup::set_switch_flag 0 1 396 10
/**
 *
 */
49
inline void EggGroup::set_switch_flag(bool flag);

1388 15 get_switch_flag 0 4 2020 25 EggGroup::get_switch_flag 0 1 397 10
/**
 *
 */
50
inline bool EggGroup::get_switch_flag(void) const;

1389 14 set_switch_fps 0 4 2020 24 EggGroup::set_switch_fps 0 1 398 10
/**
 *
 */
49
inline void EggGroup::set_switch_fps(double fps);

1390 14 get_switch_fps 0 4 2020 24 EggGroup::get_switch_fps 0 1 399 10
/**
 *
 */
51
inline double EggGroup::get_switch_fps(void) const;

1391 15 add_object_type 0 4 2020 25 EggGroup::add_object_type 0 1 400 10
/**
 *
 */
70
inline void EggGroup::add_object_type(std::string const &object_type);

1392 18 clear_object_types 0 4 2020 28 EggGroup::clear_object_types 0 1 401 10
/**
 *
 */
47
inline void EggGroup::clear_object_types(void);

1393 20 get_num_object_types 0 4 2020 30 EggGroup::get_num_object_types 0 1 402 10
/**
 *
 */
54
inline int EggGroup::get_num_object_types(void) const;

1394 15 get_object_type 0 4 2020 25 EggGroup::get_object_type 0 1 403 10
/**
 *
 */
62
inline std::string EggGroup::get_object_type(int index) const;

1395 15 has_object_type 0 4 2020 25 EggGroup::has_object_type 0 1 404 104
/**
 * Returns true if the indicated object type has been added to the group, or
 * false otherwise.
 */
69
bool EggGroup::has_object_type(std::string const &object_type) const;

1396 18 remove_object_type 0 4 2020 28 EggGroup::remove_object_type 0 1 405 178
/**
 * Removes the first instance of the indicated object type from the group if
 * it is present.  Returns true if the object type was found and removed,
 * false otherwise.
 */
66
bool EggGroup::remove_object_type(std::string const &object_type);

1397 14 set_model_flag 0 4 2020 24 EggGroup::set_model_flag 0 1 406 10
/**
 *
 */
48
inline void EggGroup::set_model_flag(bool flag);

1398 14 get_model_flag 0 4 2020 24 EggGroup::get_model_flag 0 1 407 10
/**
 *
 */
49
inline bool EggGroup::get_model_flag(void) const;

1399 16 set_texlist_flag 0 4 2020 26 EggGroup::set_texlist_flag 0 1 408 10
/**
 *
 */
50
inline void EggGroup::set_texlist_flag(bool flag);

1400 16 get_texlist_flag 0 4 2020 26 EggGroup::get_texlist_flag 0 1 409 10
/**
 *
 */
51
inline bool EggGroup::get_texlist_flag(void) const;

1401 14 set_nofog_flag 0 4 2020 24 EggGroup::set_nofog_flag 0 1 410 10
/**
 *
 */
48
inline void EggGroup::set_nofog_flag(bool flag);

1402 14 get_nofog_flag 0 4 2020 24 EggGroup::get_nofog_flag 0 1 411 10
/**
 *
 */
49
inline bool EggGroup::get_nofog_flag(void) const;

1403 14 set_decal_flag 0 4 2020 24 EggGroup::set_decal_flag 0 1 412 10
/**
 *
 */
48
inline void EggGroup::set_decal_flag(bool flag);

1404 14 get_decal_flag 0 4 2020 24 EggGroup::get_decal_flag 0 1 413 10
/**
 *
 */
49
inline bool EggGroup::get_decal_flag(void) const;

1405 15 set_direct_flag 0 4 2020 25 EggGroup::set_direct_flag 0 1 414 10
/**
 *
 */
49
inline void EggGroup::set_direct_flag(bool flag);

1406 15 get_direct_flag 0 4 2020 25 EggGroup::get_direct_flag 0 1 415 10
/**
 *
 */
50
inline bool EggGroup::get_direct_flag(void) const;

1407 15 set_portal_flag 0 4 2020 25 EggGroup::set_portal_flag 0 1 416 10
/**
 *
 */
49
inline void EggGroup::set_portal_flag(bool flag);

1408 15 get_portal_flag 0 4 2020 25 EggGroup::get_portal_flag 0 1 417 10
/**
 *
 */
50
inline bool EggGroup::get_portal_flag(void) const;

1409 17 set_occluder_flag 0 4 2020 27 EggGroup::set_occluder_flag 0 1 418 10
/**
 *
 */
51
inline void EggGroup::set_occluder_flag(bool flag);

1410 17 get_occluder_flag 0 4 2020 27 EggGroup::get_occluder_flag 0 1 419 10
/**
 *
 */
52
inline bool EggGroup::get_occluder_flag(void) const;

1411 18 set_polylight_flag 0 4 2020 28 EggGroup::set_polylight_flag 0 1 420 10
/**
 *
 */
52
inline void EggGroup::set_polylight_flag(bool flag);

1412 18 get_polylight_flag 0 4 2020 28 EggGroup::get_polylight_flag 0 1 421 10
/**
 *
 */
53
inline bool EggGroup::get_polylight_flag(void) const;

1413 16 set_indexed_flag 0 4 2020 26 EggGroup::set_indexed_flag 0 1 422 106
/**
 * If this flag is true, geometry at this node and below will be generated as
 * indexed geometry.
 */
50
inline void EggGroup::set_indexed_flag(bool flag);

1414 18 clear_indexed_flag 0 4 2020 28 EggGroup::clear_indexed_flag 0 1 423 10
/**
 *
 */
47
inline void EggGroup::clear_indexed_flag(void);

1415 16 has_indexed_flag 0 4 2020 26 EggGroup::has_indexed_flag 0 1 424 10
/**
 *
 */
51
inline bool EggGroup::has_indexed_flag(void) const;

1416 16 get_indexed_flag 0 4 2020 26 EggGroup::get_indexed_flag 0 1 425 10
/**
 *
 */
51
inline bool EggGroup::get_indexed_flag(void) const;

1417 16 set_collide_mask 0 4 2020 26 EggGroup::set_collide_mask 0 1 426 10
/**
 *
 */
57
inline void EggGroup::set_collide_mask(CollideMask mask);

1418 18 clear_collide_mask 0 4 2020 28 EggGroup::clear_collide_mask 0 1 427 10
/**
 *
 */
47
inline void EggGroup::clear_collide_mask(void);

1419 16 has_collide_mask 0 4 2020 26 EggGroup::has_collide_mask 0 1 428 10
/**
 *
 */
51
inline bool EggGroup::has_collide_mask(void) const;

1420 16 get_collide_mask 0 4 2020 26 EggGroup::get_collide_mask 0 1 429 10
/**
 *
 */
58
inline CollideMask EggGroup::get_collide_mask(void) const;

1421 21 set_from_collide_mask 0 4 2020 31 EggGroup::set_from_collide_mask 0 1 430 10
/**
 *
 */
62
inline void EggGroup::set_from_collide_mask(CollideMask mask);

1422 23 clear_from_collide_mask 0 4 2020 33 EggGroup::clear_from_collide_mask 0 1 431 10
/**
 *
 */
52
inline void EggGroup::clear_from_collide_mask(void);

1423 21 has_from_collide_mask 0 4 2020 31 EggGroup::has_from_collide_mask 0 1 432 10
/**
 *
 */
56
inline bool EggGroup::has_from_collide_mask(void) const;

1424 21 get_from_collide_mask 0 4 2020 31 EggGroup::get_from_collide_mask 0 1 433 10
/**
 *
 */
63
inline CollideMask EggGroup::get_from_collide_mask(void) const;

1425 21 set_into_collide_mask 0 4 2020 31 EggGroup::set_into_collide_mask 0 1 434 10
/**
 *
 */
62
inline void EggGroup::set_into_collide_mask(CollideMask mask);

1426 23 clear_into_collide_mask 0 4 2020 33 EggGroup::clear_into_collide_mask 0 1 435 10
/**
 *
 */
52
inline void EggGroup::clear_into_collide_mask(void);

1427 21 has_into_collide_mask 0 4 2020 31 EggGroup::has_into_collide_mask 0 1 436 10
/**
 *
 */
56
inline bool EggGroup::has_into_collide_mask(void) const;

1428 21 get_into_collide_mask 0 4 2020 31 EggGroup::get_into_collide_mask 0 1 437 10
/**
 *
 */
63
inline CollideMask EggGroup::get_into_collide_mask(void) const;

1429 14 set_blend_mode 0 4 2020 24 EggGroup::set_blend_mode 0 1 438 10
/**
 *
 */
69
inline void EggGroup::set_blend_mode(EggGroup::BlendMode blend_mode);

1430 14 get_blend_mode 0 4 2020 24 EggGroup::get_blend_mode 0 1 439 10
/**
 *
 */
64
inline EggGroup::BlendMode EggGroup::get_blend_mode(void) const;

1431 19 set_blend_operand_a 0 4 2020 29 EggGroup::set_blend_operand_a 0 1 440 10
/**
 *
 */
82
inline void EggGroup::set_blend_operand_a(EggGroup::BlendOperand blend_operand_a);

1432 19 get_blend_operand_a 0 4 2020 29 EggGroup::get_blend_operand_a 0 1 441 10
/**
 *
 */
72
inline EggGroup::BlendOperand EggGroup::get_blend_operand_a(void) const;

1433 19 set_blend_operand_b 0 4 2020 29 EggGroup::set_blend_operand_b 0 1 442 10
/**
 *
 */
82
inline void EggGroup::set_blend_operand_b(EggGroup::BlendOperand blend_operand_b);

1434 19 get_blend_operand_b 0 4 2020 29 EggGroup::get_blend_operand_b 0 1 443 10
/**
 *
 */
72
inline EggGroup::BlendOperand EggGroup::get_blend_operand_b(void) const;

1435 15 set_blend_color 0 4 2020 25 EggGroup::set_blend_color 0 1 444 10
/**
 *
 */
65
inline void EggGroup::set_blend_color(LColor const &blend_color);

1436 17 clear_blend_color 0 4 2020 27 EggGroup::clear_blend_color 0 1 445 49
/**
 * Removes the blend color specification.
 */
46
inline void EggGroup::clear_blend_color(void);

1437 15 has_blend_color 0 4 2020 25 EggGroup::has_blend_color 0 1 446 79
/**
 * Returns true if the blend color has been specified, false otherwise.
 */
50
inline bool EggGroup::has_blend_color(void) const;

1438 15 get_blend_color 0 4 2020 25 EggGroup::get_blend_color 0 1 447 96
/**
 * Returns the blend color if one has been specified, or (0, 0, 0, 0) if one
 * has not.
 */
59
inline LColor const &EggGroup::get_blend_color(void) const;

1439 7 set_lod 0 4 2020 17 EggGroup::set_lod 0 1 448 10
/**
 *
 */
61
inline void EggGroup::set_lod(EggSwitchCondition const &lod);

1440 9 clear_lod 0 4 2020 19 EggGroup::clear_lod 0 1 449 10
/**
 *
 */
38
inline void EggGroup::clear_lod(void);

1441 7 has_lod 0 4 2020 17 EggGroup::has_lod 0 1 450 10
/**
 *
 */
42
inline bool EggGroup::has_lod(void) const;

1442 7 get_lod 0 4 2020 17 EggGroup::get_lod 0 1 451 10
/**
 *
 */
63
inline EggSwitchCondition const &EggGroup::get_lod(void) const;

1443 7 set_tag 0 4 2020 17 EggGroup::set_tag 0 1 452 524
/**
 * Associates a user-defined value with a user-defined key which is stored on
 * the node.  This value has no meaning to Panda; but it is stored
 * indefinitely on the node until it is requested again.  This value will be
 * copied to the PandaNode that is created for this particular EggGroup if the
 * egg file is loaded as a scene.
 *
 * Each unique key stores a different string value.  There is no effective
 * limit on the number of different keys that may be stored or on the length
 * of any one key's value.
 */
80
inline void EggGroup::set_tag(std::string const &key, std::string const &value);

1444 7 get_tag 0 4 2020 17 EggGroup::get_tag 0 1 453 182
/**
 * Retrieves the user-defined value that was previously set on this node for
 * the particular key, if any.  If no value has been previously set, returns
 * the empty string.
 */
67
inline std::string EggGroup::get_tag(std::string const &key) const;

1445 7 has_tag 0 4 2020 17 EggGroup::has_tag 0 1 454 170
/**
 * Returns true if a value has been defined on this node for the particular
 * key (even if that value is the empty string), or false if no value has been
 * set.
 */
60
inline bool EggGroup::has_tag(std::string const &key) const;

1446 9 clear_tag 0 4 2020 19 EggGroup::clear_tag 0 1 455 158
/**
 * Removes the value defined for this key on this particular node.  After a
 * call to clear_tag(), has_tag() will return false for the indicated key.
 */
56
inline void EggGroup::clear_tag(std::string const &key);

1447 16 get_default_pose 0 4 2020 26 EggGroup::get_default_pose 0 1 456 315
/**
 * Returns a read-only accessor to the initial pose transform.  This is the
 * <DefaultPose> entry for a Joint, and defines only the initial transform
 * pose for the unanimated joint; it has nothing to do with the group's
 * <Transform> entry, which defines the (eventual) space of the group's
 * vertices.
 */
66
inline EggTransform const &EggGroup::get_default_pose(void) const;

1448 19 modify_default_pose 0 4 2020 29 EggGroup::modify_default_pose 0 1 457 314
/**
 * Returns a writable accessor to the initial pose transform.  This is the
 * <DefaultPose> entry for a Joint, and defines only the initial transform
 * pose for the unanimated joint; it has nothing to do with the group's
 * <Transform> entry, which defines the (eventual) space of the group's
 * vertices.
 */
57
inline EggTransform &EggGroup::modify_default_pose(void);

1449 16 set_default_pose 0 4 2020 26 EggGroup::set_default_pose 0 1 458 289
/**
 * Replaces the initial pose transform.  This is the <DefaultPose> entry for a
 * Joint, and defines only the initial transform pose for the unanimated
 * joint; it has nothing to do with the group's <Transform> entry, which
 * defines the (eventual) space of the group's vertices.
 */
70
inline void EggGroup::set_default_pose(EggTransform const &transform);

1450 18 clear_default_pose 0 4 2020 28 EggGroup::clear_default_pose 0 1 459 71
/**
 * Removes the initial pose transform.  See set_default_pose().
 */
47
inline void EggGroup::clear_default_pose(void);

1451 12 set_scroll_u 0 4 2020 22 EggGroup::set_scroll_u 0 1 460 0
57
inline void EggGroup::set_scroll_u(double const u_speed);

1452 12 set_scroll_v 0 4 2020 22 EggGroup::set_scroll_v 0 1 461 0
57
inline void EggGroup::set_scroll_v(double const v_speed);

1453 12 set_scroll_w 0 4 2020 22 EggGroup::set_scroll_w 0 1 462 0
57
inline void EggGroup::set_scroll_w(double const w_speed);

1454 12 set_scroll_r 0 4 2020 22 EggGroup::set_scroll_r 0 1 463 0
57
inline void EggGroup::set_scroll_r(double const r_speed);

1455 12 get_scroll_u 0 4 2020 22 EggGroup::get_scroll_u 0 1 464 0
49
inline double EggGroup::get_scroll_u(void) const;

1456 12 get_scroll_v 0 4 2020 22 EggGroup::get_scroll_v 0 1 465 0
49
inline double EggGroup::get_scroll_v(void) const;

1457 12 get_scroll_w 0 4 2020 22 EggGroup::get_scroll_w 0 1 466 0
49
inline double EggGroup::get_scroll_w(void) const;

1458 12 get_scroll_r 0 4 2020 22 EggGroup::get_scroll_r 0 1 467 0
49
inline double EggGroup::get_scroll_r(void) const;

1459 17 has_scrolling_uvs 0 4 2020 27 EggGroup::has_scrolling_uvs 0 1 468 0
46
inline bool EggGroup::has_scrolling_uvs(void);

1460 10 ref_vertex 0 4 2020 20 EggGroup::ref_vertex 0 1 469 213
/**
 * Adds the vertex to the set of those referenced by the group, at the
 * indicated membership level.  If the vertex is already being referenced,
 * increases the membership amount by the indicated amount.
 */
68
void EggGroup::ref_vertex(EggVertex *vert, double membership = 1.0);

1461 12 unref_vertex 0 4 2020 22 EggGroup::unref_vertex 0 1 470 130
/**
 * Removes the vertex from the set of those referenced by the group.  Does
 * nothing if the vertex is not already reffed.
 */
45
void EggGroup::unref_vertex(EggVertex *vert);

1462 18 unref_all_vertices 0 4 2020 28 EggGroup::unref_all_vertices 0 1 471 56
/**
 * Removes all vertices from the reference list.
 */
40
void EggGroup::unref_all_vertices(void);

1463 21 get_vertex_membership 0 4 2020 31 EggGroup::get_vertex_membership 0 1 472 139
/**
 * Returns the amount of membership of the indicated vertex in this group.  If
 * the vertex is not reffed by the group, returns 0.
 */
68
double EggGroup::get_vertex_membership(EggVertex const *vert) const;

1464 21 set_vertex_membership 0 4 2020 31 EggGroup::set_vertex_membership 0 1 473 106
/**
 * Explicitly sets the net membership of the indicated vertex in this group to
 * the given value.
 */
73
void EggGroup::set_vertex_membership(EggVertex *vert, double membership);

1465 11 steal_vrefs 0 4 2020 21 EggGroup::steal_vrefs 0 1 474 195
/**
 * Moves all of the vertex references from the indicated other group into this
 * one.  If a given vertex was previously shared by both groups, the relative
 * memberships will be summed.
 */
44
void EggGroup::steal_vrefs(EggGroup *other);

1466 19 test_vref_integrity 0 4 2020 29 EggGroup::test_vref_integrity 0 1 475 0
47
void EggGroup::test_vref_integrity(void) const;

1467 13 add_group_ref 0 4 2020 23 EggGroup::add_group_ref 0 1 476 207
/**
 * Adds a new <Ref> entry to the group.  This declares an internal reference
 * to another node, and is used to implement scene-graph instancing; it is
 * only valid if the group_type is GT_instance.
 */
46
void EggGroup::add_group_ref(EggGroup *group);

1468 18 get_num_group_refs 0 4 2020 28 EggGroup::get_num_group_refs 0 1 477 90
/**
 * Returns the number of <Ref> entries within this group.  See
 * add_group_ref().
 */
45
int EggGroup::get_num_group_refs(void) const;

1469 13 get_group_ref 0 4 2020 23 EggGroup::get_group_ref 0 1 478 79
/**
 * Returns the nth <Ref> entry within this group.  See add_group_ref().
 */
47
EggGroup *EggGroup::get_group_ref(int n) const;

1470 16 remove_group_ref 0 4 2020 26 EggGroup::remove_group_ref 0 1 479 79
/**
 * Removes the nth <Ref> entry within this group.  See add_group_ref().
 */
39
void EggGroup::remove_group_ref(int n);

1471 16 clear_group_refs 0 4 2020 26 EggGroup::clear_group_refs 0 1 480 84
/**
 * Removes all of the <Ref> entries within this group.  See add_group_ref().
 */
38
void EggGroup::clear_group_refs(void);

1472 17 string_group_type 0 4 2020 27 EggGroup::string_group_type 0 1 481 163
/**
 * Returns the GroupType value associated with the given string
 * representation, or GT_invalid if the string does not match any known
 * GroupType value.
 */
82
static EggGroup::GroupType EggGroup::string_group_type(std::string const &strval);

1473 16 string_dart_type 0 4 2020 26 EggGroup::string_dart_type 0 1 482 155
/**
 * Returns the DartType value associated with the given string representation,
 * or DT_none if the string does not match any known DartType value.
 */
80
static EggGroup::DartType EggGroup::string_dart_type(std::string const &strval);

1474 15 string_dcs_type 0 4 2020 25 EggGroup::string_dcs_type 0 1 483 160
/**
 * Returns the DCSType value associated with the given string representation,
 * or DC_unspecified if the string does not match any known DCSType value.
 */
78
static EggGroup::DCSType EggGroup::string_dcs_type(std::string const &strval);

1475 21 string_billboard_type 0 4 2020 31 EggGroup::string_billboard_type 0 1 484 168
/**
 * Returns the BillboardType value associated with the given string
 * representation, or BT_none if the string does not match any known
 * BillboardType value.
 */
90
static EggGroup::BillboardType EggGroup::string_billboard_type(std::string const &strval);

1476 14 string_cs_type 0 4 2020 24 EggGroup::string_cs_type 0 1 485 179
/**
 * Returns the CollisionSolidType value associated with the given string
 * representation, or CST_none if the string does not match any known
 * CollisionSolidType value.
 */
88
static EggGroup::CollisionSolidType EggGroup::string_cs_type(std::string const &strval);

1477 20 string_collide_flags 0 4 2020 30 EggGroup::string_collide_flags 0 1 486 260
/**
 * Returns the CollideFlags value associated with the given string
 * representation, or CF_none if the string does not match any known
 * CollideFlags value.  This only recognizes a single keyword; it does not
 * attempt to parse a string of keywords.
 */
88
static EggGroup::CollideFlags EggGroup::string_collide_flags(std::string const &strval);

1478 17 string_blend_mode 0 4 2020 27 EggGroup::string_blend_mode 0 1 487 154
/**
 * Returns the BlendMode value associated with the given string
 * representation, or BM_none if the string does not match any known
 * BlendMode.
 */
82
static EggGroup::BlendMode EggGroup::string_blend_mode(std::string const &strval);

1479 20 string_blend_operand 0 4 2020 30 EggGroup::string_blend_operand 0 1 488 160
/**
 * Returns the BlendOperand value associated with the given string
 * representation, or BO_none if the string does not match any known
 * BlendOperand.
 */
88
static EggGroup::BlendOperand EggGroup::string_blend_operand(std::string const &strval);

1480 14 get_class_type 0 4 2020 24 EggGroup::get_class_type 0 1 489 0
49
static TypeHandle EggGroup::get_class_type(void);

1481 6 EggBin 0 4 2049 14 EggBin::EggBin 0 3 496 497 498 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
119
EggBin::EggBin(std::string const &name = "");
EggBin::EggBin(EggGroup const &copy);
EggBin::EggBin(EggBin const &copy);

1482 14 set_bin_number 0 4 2049 22 EggBin::set_bin_number 0 1 499 10
/**
 *
 */
44
void EggBin::set_bin_number(int bin_number);

1483 14 get_bin_number 0 4 2049 22 EggBin::get_bin_number 0 1 500 10
/**
 *
 */
39
int EggBin::get_bin_number(void) const;

1484 14 get_class_type 0 4 2049 22 EggBin::get_class_type 0 1 501 0
47
static TypeHandle EggBin::get_class_type(void);

1485 7 ~EggBin 0 4 2049 15 EggBin::~EggBin 0 0 0
22
EggBin::~EggBin(void);

1486 9 make_bins 0 4 2050 22 EggBinMaker::make_bins 0 1 502 208
/**
 * The main entry point to EggBinMaker.  Walks the egg scene graph beginning
 * at the indicated root node, and moves all binnable nodes into EggBin
 * objects.  Returns the number of EggBins created.
 */
53
int EggBinMaker::make_bins(EggGroupNode *root_group);

1487 12 prepare_node 0 6 2050 25 EggBinMaker::prepare_node 0 1 503 171
/**
 * May be overridden in derived classes to perform some setup work as each
 * node is encountered.  This will be called once for each node in the egg
 * hierarchy.
 */
54
virtual void EggBinMaker::prepare_node(EggNode *node);

1488 14 get_bin_number 0 6 2050 27 EggBinMaker::get_bin_number 0 1 504 0
65
virtual int EggBinMaker::get_bin_number(EggNode const *node) = 0;

1489 10 sorts_less 0 6 2050 23 EggBinMaker::sorts_less 0 1 505 361
/**
 * May be overridden in derived classes to create additional bins within a
 * particular bin number, based on some arbitrary property of nodes.  This
 * function establishes an arbitrary but fixed ordering between nodes; if two
 * nodes do not sort to the same position, different bins are created for each
 * one (with the same bin number on each bin).
 */
89
virtual bool EggBinMaker::sorts_less(int bin_number, EggNode const *a, EggNode const *b);

1490 14 collapse_group 0 6 2050 27 EggBinMaker::collapse_group 0 1 506 145
/**
 * May be overridden in derived classes to specify whether a particular group
 * node, apparently redundant, may be safely collapsed out.
 */
80
virtual bool EggBinMaker::collapse_group(EggGroup const *group, int bin_number);

1491 12 get_bin_name 0 6 2050 25 EggBinMaker::get_bin_name 0 1 507 130
/**
 * May be overridden in derived classes to define a name for each new bin,
 * based on its bin number, and a sample child.
 */
84
virtual std::string EggBinMaker::get_bin_name(int bin_number, EggNode const *child);

1492 8 make_bin 0 6 2050 21 EggBinMaker::make_bin 0 1 508 352
/**
 * May be overridden in derived classes to construct a new EggBin object (or
 * some derived class, if needed), and preload some initial data into as
 * required.
 *
 * child is an arbitrary child of the bin, and collapse_from is the group the
 * bin is being collapsed with, if any (implying collapse_group() returned
 * true), or NULL if not.
 */
113
virtual PointerTo< EggBin > EggBinMaker::make_bin(int bin_number, EggNode const *child, EggGroup *collapse_from);

1493 14 get_class_type 0 4 2050 27 EggBinMaker::get_class_type 0 1 509 0
52
static TypeHandle EggBinMaker::get_class_type(void);

1494 10 EggComment 0 4 2051 22 EggComment::EggComment 0 2 510 511 22
/**
 *
 */

/**
 *
 */
143
inline EggComment::EggComment(std::string const &node_name, std::string const &comment);
inline EggComment::EggComment(EggComment const &copy);

1495 10 operator = 0 4 2051 22 EggComment::operator = 0 2 512 513 22
/**
 *
 */

/**
 *
 */
137
inline EggComment &EggComment::operator =(std::string const &comment);
inline EggComment &EggComment::operator =(EggComment const &copy);

1496 17 operator typecast 0 132 2051 29 EggComment::operator typecast 0 1 517 0
68
inline std::string const &EggComment::operator typecast(void) const;

1497 11 set_comment 0 4 2051 23 EggComment::set_comment 0 1 514 10
/**
 *
 */
64
inline void EggComment::set_comment(std::string const &comment);

1498 11 get_comment 0 4 2051 23 EggComment::get_comment 0 1 515 10
/**
 *
 */
55
inline std::string EggComment::get_comment(void) const;

1499 14 get_class_type 0 4 2051 26 EggComment::get_class_type 0 1 516 0
51
static TypeHandle EggComment::get_class_type(void);

1500 11 ~EggComment 0 4 2051 23 EggComment::~EggComment 0 0 0
30
EggComment::~EggComment(void);

1501 10 operator = 0 4 2052 27 EggFilenameNode::operator = 0 1 518 10
/**
 *
 */
81
inline EggFilenameNode &EggFilenameNode::operator =(EggFilenameNode const &copy);

1502 21 get_default_extension 0 6 2052 38 EggFilenameNode::get_default_extension 0 1 519 64
/**
 * Returns the default extension for this filename type.
 */
71
virtual std::string EggFilenameNode::get_default_extension(void) const;

1503 12 get_filename 0 4 2052 29 EggFilenameNode::get_filename 0 1 520 61
/**
 * Returns a nonmodifiable reference to the filename.
 */
65
inline Filename const &EggFilenameNode::get_filename(void) const;

1504 12 set_filename 0 4 2052 29 EggFilenameNode::set_filename 0 1 521 10
/**
 *
 */
68
inline void EggFilenameNode::set_filename(Filename const &filename);

1505 12 get_fullpath 0 4 2052 29 EggFilenameNode::get_fullpath 0 1 522 472
/**
 * Returns the full pathname to the file, if it is known; otherwise, returns
 * the same thing as get_filename().
 *
 * This function simply returns whatever was set by the last call to
 * set_fullpath().  This string is not written to the egg file; its main
 * purpose is to record the full path to a filename (for instance, a texture
 * filename) if it is known, for egg structures that are generated in-memory
 * and then immediately converted to a scene graph.
 */
65
inline Filename const &EggFilenameNode::get_fullpath(void) const;

1506 12 set_fullpath 0 4 2052 29 EggFilenameNode::set_fullpath 0 1 523 84
/**
 * Records the full pathname to the file, for the benefit of get_fullpath().
 */
68
inline void EggFilenameNode::set_fullpath(Filename const &fullpath);

1507 14 get_class_type 0 4 2052 31 EggFilenameNode::get_class_type 0 1 524 0
56
static TypeHandle EggFilenameNode::get_class_type(void);

1508 16 ~EggFilenameNode 0 4 2052 33 EggFilenameNode::~EggFilenameNode 0 0 0
40
EggFilenameNode::~EggFilenameNode(void);

1509 25 upcast_to_EggFilenameNode 0 12 2053 37 EggTexture::upcast_to_EggFilenameNode 0 1 645 41
upcast from EggTexture to EggFilenameNode
61
EggFilenameNode *EggTexture::upcast_to_EggFilenameNode(void);

1510 22 downcast_to_EggTexture 0 12 2052 39 EggFilenameNode::downcast_to_EggTexture 0 1 646 43
downcast from EggFilenameNode to EggTexture
58
EggTexture *EggFilenameNode::downcast_to_EggTexture(void);

1511 23 upcast_to_EggRenderMode 0 12 2053 35 EggTexture::upcast_to_EggRenderMode 0 1 647 39
upcast from EggTexture to EggRenderMode
57
EggRenderMode *EggTexture::upcast_to_EggRenderMode(void);

1512 22 downcast_to_EggTexture 0 12 2011 37 EggRenderMode::downcast_to_EggTexture 0 1 648 41
downcast from EggRenderMode to EggTexture
56
EggTexture *EggRenderMode::downcast_to_EggTexture(void);

1513 22 upcast_to_EggTransform 0 12 2053 34 EggTexture::upcast_to_EggTransform 0 1 649 38
upcast from EggTexture to EggTransform
55
EggTransform *EggTexture::upcast_to_EggTransform(void);

1514 22 downcast_to_EggTexture 0 12 2016 36 EggTransform::downcast_to_EggTexture 0 1 650 40
downcast from EggTransform to EggTexture
55
EggTexture *EggTransform::downcast_to_EggTexture(void);

1515 10 EggTexture 0 4 2053 22 EggTexture::EggTexture 0 2 525 526 22
/**
 *
 */

/**
 *
 */
127
EggTexture::EggTexture(std::string const &tref_name, Filename const &filename);
EggTexture::EggTexture(EggTexture const &copy);

1516 10 operator = 0 4 2053 22 EggTexture::operator = 0 1 527 10
/**
 *
 */
59
EggTexture &EggTexture::operator =(EggTexture const &copy);

1517 11 ~EggTexture 0 6 2053 23 EggTexture::~EggTexture 0 0 10
/**
 *
 */
38
virtual EggTexture::~EggTexture(void);

1518 5 write 0 6 2053 17 EggTexture::write 0 1 528 86
/**
 * Writes the texture definition to the indicated output stream in Egg format.
 */
69
virtual void EggTexture::write(ostream &out, int indent_level) const;

1519 16 is_equivalent_to 0 4 2053 28 EggTexture::is_equivalent_to 0 1 529 899
/**
 * Returns true if the two textures are equivalent in all relevant properties
 * (according to eq), false otherwise.
 *
 * The Equivalence parameter, eq, should be set to the bitwise OR of the
 * following properties, according to what you consider relevant:
 *
 * EggTexture::E_basename: The basename part of the texture filename, without
 * the directory prefix *or* the filename extension.
 *
 * EggTexture::E_extension: The extension part of the texture filename.
 *
 * EggTexture::E_dirname: The directory prefix of the texture filename.
 *
 * EggTexture::E_complete_filename: The union of the above three; that is, the
 * complete filename, with directory, basename, and extension.
 *
 * EggTexture::E_transform: The texture matrix.
 *
 * EggTexture::E_attributes: All remaining texture attributes (mode, mipmap,
 * etc.) except TRef name.
 *
 * EggTexture::E_tref_name: The TRef name.
 */
73
bool EggTexture::is_equivalent_to(EggTexture const &other, int eq) const;

1520 15 sorts_less_than 0 4 2053 27 EggTexture::sorts_less_than 0 1 530 224
/**
 * An ordering operator to compare two textures for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique textures, according
 * to the indicated Equivalence factor.  See is_equivalent_to().
 */
72
bool EggTexture::sorts_less_than(EggTexture const &other, int eq) const;

1521 17 has_alpha_channel 0 4 2053 29 EggTexture::has_alpha_channel 0 1 531 260
/**
 * Given the number of color components (channels) in the image file as
 * actually read from the disk, return true if this texture seems to have an
 * alpha channel or not.  This depends on the EggTexture's format as well as
 * the number of channels.
 */
61
bool EggTexture::has_alpha_channel(int num_components) const;

1522 16 set_texture_type 0 4 2053 28 EggTexture::set_texture_type 0 1 532 10
/**
 *
 */
79
inline void EggTexture::set_texture_type(EggTexture::TextureType texture_type);

1523 16 get_texture_type 0 4 2053 28 EggTexture::get_texture_type 0 1 533 10
/**
 *
 */
72
inline EggTexture::TextureType EggTexture::get_texture_type(void) const;

1524 10 set_format 0 4 2053 22 EggTexture::set_format 0 1 534 10
/**
 *
 */
62
inline void EggTexture::set_format(EggTexture::Format format);

1525 10 get_format 0 4 2053 22 EggTexture::get_format 0 1 535 10
/**
 *
 */
61
inline EggTexture::Format EggTexture::get_format(void) const;

1526 20 set_compression_mode 0 4 2053 32 EggTexture::set_compression_mode 0 1 536 10
/**
 *
 */
79
inline void EggTexture::set_compression_mode(EggTexture::CompressionMode mode);

1527 20 get_compression_mode 0 4 2053 32 EggTexture::get_compression_mode 0 1 537 10
/**
 *
 */
80
inline EggTexture::CompressionMode EggTexture::get_compression_mode(void) const;

1528 13 set_wrap_mode 0 4 2053 25 EggTexture::set_wrap_mode 0 1 538 10
/**
 *
 */
65
inline void EggTexture::set_wrap_mode(EggTexture::WrapMode mode);

1529 13 get_wrap_mode 0 4 2053 25 EggTexture::get_wrap_mode 0 1 539 10
/**
 *
 */
66
inline EggTexture::WrapMode EggTexture::get_wrap_mode(void) const;

1530 10 set_wrap_u 0 4 2053 22 EggTexture::set_wrap_u 0 1 540 10
/**
 *
 */
62
inline void EggTexture::set_wrap_u(EggTexture::WrapMode mode);

1531 10 get_wrap_u 0 4 2053 22 EggTexture::get_wrap_u 0 1 541 120
/**
 * Returns the amount specified for U wrap.  This may be unspecified, even if
 * there is an overall wrap value.
 */
63
inline EggTexture::WrapMode EggTexture::get_wrap_u(void) const;

1532 16 determine_wrap_u 0 4 2053 28 EggTexture::determine_wrap_u 0 1 542 178
/**
 * Determines the appropriate wrap in the U direction.  This is different from
 * get_wrap_u() in that if the U wrap is unspecified, it returns the overall
 * wrap value.
 */
69
inline EggTexture::WrapMode EggTexture::determine_wrap_u(void) const;

1533 10 set_wrap_v 0 4 2053 22 EggTexture::set_wrap_v 0 1 543 10
/**
 *
 */
62
inline void EggTexture::set_wrap_v(EggTexture::WrapMode mode);

1534 10 get_wrap_v 0 4 2053 22 EggTexture::get_wrap_v 0 1 544 120
/**
 * Returns the amount specified for V wrap.  This may be unspecified, even if
 * there is an overall wrap value.
 */
63
inline EggTexture::WrapMode EggTexture::get_wrap_v(void) const;

1535 16 determine_wrap_v 0 4 2053 28 EggTexture::determine_wrap_v 0 1 545 178
/**
 * Determines the appropriate wrap in the V direction.  This is different from
 * get_wrap_v() in that if the V wrap is unspecified, it returns the overall
 * wrap value.
 */
69
inline EggTexture::WrapMode EggTexture::determine_wrap_v(void) const;

1536 10 set_wrap_w 0 4 2053 22 EggTexture::set_wrap_w 0 1 546 10
/**
 *
 */
62
inline void EggTexture::set_wrap_w(EggTexture::WrapMode mode);

1537 10 get_wrap_w 0 4 2053 22 EggTexture::get_wrap_w 0 1 547 120
/**
 * Returns the amount specified for W wrap.  This may be unspecified, even if
 * there is an overall wrap value.
 */
63
inline EggTexture::WrapMode EggTexture::get_wrap_w(void) const;

1538 16 determine_wrap_w 0 4 2053 28 EggTexture::determine_wrap_w 0 1 548 178
/**
 * Determines the appropriate wrap in the W direction.  This is different from
 * get_wrap_w() in that if the W wrap is unspecified, it returns the overall
 * wrap value.
 */
69
inline EggTexture::WrapMode EggTexture::determine_wrap_w(void) const;

1539 13 set_minfilter 0 4 2053 25 EggTexture::set_minfilter 0 1 549 10
/**
 *
 */
67
inline void EggTexture::set_minfilter(EggTexture::FilterType type);

1540 13 get_minfilter 0 4 2053 25 EggTexture::get_minfilter 0 1 550 10
/**
 *
 */
68
inline EggTexture::FilterType EggTexture::get_minfilter(void) const;

1541 13 set_magfilter 0 4 2053 25 EggTexture::set_magfilter 0 1 551 10
/**
 *
 */
67
inline void EggTexture::set_magfilter(EggTexture::FilterType type);

1542 13 get_magfilter 0 4 2053 25 EggTexture::get_magfilter 0 1 552 10
/**
 *
 */
68
inline EggTexture::FilterType EggTexture::get_magfilter(void) const;

1543 22 set_anisotropic_degree 0 4 2053 34 EggTexture::set_anisotropic_degree 0 1 553 127
/**
 * Sets the degree of anisotropic filtering for this texture.  1 is off;
 * higher levels indicate filtering in effect.
 */
71
inline void EggTexture::set_anisotropic_degree(int anisotropic_degree);

1544 24 clear_anisotropic_degree 0 4 2053 36 EggTexture::clear_anisotropic_degree 0 1 554 79
/**
 * Removes the specification of anisotropic filtering from the texture.
 */
55
inline void EggTexture::clear_anisotropic_degree(void);

1545 22 has_anisotropic_degree 0 4 2053 34 EggTexture::has_anisotropic_degree 0 1 555 128
/**
 * Returns true if a value for the anisotropic filtering degree has been
 * specified for this texture, false otherwise.
 */
59
inline bool EggTexture::has_anisotropic_degree(void) const;

1546 22 get_anisotropic_degree 0 4 2053 34 EggTexture::get_anisotropic_degree 0 1 556 132
/**
 * Returns the anisotropic filtering degree that has been specified for this
 * texture, or 0 if nothing has been specified.
 */
58
inline int EggTexture::get_anisotropic_degree(void) const;

1547 12 set_env_type 0 4 2053 24 EggTexture::set_env_type 0 1 557 10
/**
 *
 */
63
inline void EggTexture::set_env_type(EggTexture::EnvType type);

1548 12 get_env_type 0 4 2053 24 EggTexture::get_env_type 0 1 558 10
/**
 *
 */
64
inline EggTexture::EnvType EggTexture::get_env_type(void) const;

1549 21 affects_polygon_alpha 0 4 2053 33 EggTexture::affects_polygon_alpha 0 1 559 162
/**
 * Returns true if this texture's environment type or combine mode allows the
 * texture to have an effect on the polygon's alpha values, false otherwise.
 */
51
bool EggTexture::affects_polygon_alpha(void) const;

1550 16 set_combine_mode 0 4 2053 28 EggTexture::set_combine_mode 0 1 560 10
/**
 *
 */
105
inline void EggTexture::set_combine_mode(EggTexture::CombineChannel channel, EggTexture::CombineMode cm);

1551 16 get_combine_mode 0 4 2053 28 EggTexture::get_combine_mode 0 1 561 10
/**
 *
 */
102
inline EggTexture::CombineMode EggTexture::get_combine_mode(EggTexture::CombineChannel channel) const;

1552 18 set_combine_source 0 4 2053 30 EggTexture::set_combine_source 0 1 562 10
/**
 *
 */
116
inline void EggTexture::set_combine_source(EggTexture::CombineChannel channel, int n, EggTexture::CombineSource cs);

1553 18 get_combine_source 0 4 2053 30 EggTexture::get_combine_source 0 1 563 10
/**
 *
 */
113
inline EggTexture::CombineSource EggTexture::get_combine_source(EggTexture::CombineChannel channel, int n) const;

1554 19 set_combine_operand 0 4 2053 31 EggTexture::set_combine_operand 0 1 564 10
/**
 *
 */
118
inline void EggTexture::set_combine_operand(EggTexture::CombineChannel channel, int n, EggTexture::CombineOperand co);

1555 19 get_combine_operand 0 4 2053 31 EggTexture::get_combine_operand 0 1 565 10
/**
 *
 */
115
inline EggTexture::CombineOperand EggTexture::get_combine_operand(EggTexture::CombineChannel channel, int n) const;

1556 16 set_saved_result 0 4 2053 28 EggTexture::set_saved_result 0 1 566 614
/**
 * Sets the saved_result flag.  When this is true, the output of this stage is
 * not part of the normal pipeline--that is, it will not be supplied as the
 * "previous" source for the next texture stage--but it will instead be
 * supplied as the "last_saved_result" source for any future stages, until the
 * next TextureStage with a saved_result set true is encountered.
 *
 * This can be used to reuse the results of this texture stage as input to
 * more than one stage later in the pipeline.
 *
 * The last texture in the pipeline (the one with the highest sort value)
 * should not have this flag set.
 */
60
inline void EggTexture::set_saved_result(bool saved_result);

1557 16 get_saved_result 0 4 2053 28 EggTexture::get_saved_result 0 1 567 92
/**
 * Returns the current setting of the saved_result flag.  See
 * set_saved_result().
 */
53
inline bool EggTexture::get_saved_result(void) const;

1558 11 set_tex_gen 0 4 2053 23 EggTexture::set_tex_gen 0 1 568 10
/**
 *
 */
64
inline void EggTexture::set_tex_gen(EggTexture::TexGen tex_gen);

1559 11 get_tex_gen 0 4 2053 23 EggTexture::get_tex_gen 0 1 569 10
/**
 *
 */
62
inline EggTexture::TexGen EggTexture::get_tex_gen(void) const;

1560 17 set_quality_level 0 4 2053 29 EggTexture::set_quality_level 0 1 570 10
/**
 *
 */
82
inline void EggTexture::set_quality_level(EggTexture::QualityLevel quality_level);

1561 17 get_quality_level 0 4 2053 29 EggTexture::get_quality_level 0 1 571 10
/**
 *
 */
74
inline EggTexture::QualityLevel EggTexture::get_quality_level(void) const;

1562 14 set_stage_name 0 4 2053 26 EggTexture::set_stage_name 0 1 572 442
/**
 * Specifies the particular TextureStage this texture will be rendered on by
 * name.  If this is omitted, the texture will be rendered on the default
 * TextureStage, unless some other stage-specific property is specificied, in
 * which case the texture will be rendered on a TextureStage with the same
 * name as the tref.  This is in support of multitexturing.
 *
 * Each different TextureStage in the world must be uniquely named.
 */
70
inline void EggTexture::set_stage_name(std::string const &stage_name);

1563 16 clear_stage_name 0 4 2053 28 EggTexture::clear_stage_name 0 1 573 56
/**
 * Removes the named TextureStage specification.
 */
47
inline void EggTexture::clear_stage_name(void);

1564 14 has_stage_name 0 4 2053 26 EggTexture::has_stage_name 0 1 574 107
/**
 * Returns true if a stage name has been explicitly specified for this
 * texture, false otherwise.
 */
51
inline bool EggTexture::has_stage_name(void) const;

1565 14 get_stage_name 0 4 2053 26 EggTexture::get_stage_name 0 1 575 146
/**
 * Returns the stage name that has been specified for this texture, or the
 * tref name if no texture stage has explicitly been specified.
 */
65
inline std::string const &EggTexture::get_stage_name(void) const;

1566 12 set_priority 0 4 2053 24 EggTexture::set_priority 0 1 576 178
/**
 * Sets the importance of this texture with respect to other textures also
 * applied on the same geometry.  This is only meaningful in the presence of
 * multitexturing.
 */
51
inline void EggTexture::set_priority(int priority);

1567 14 clear_priority 0 4 2053 26 EggTexture::clear_priority 0 1 577 116
/**
 * Removes the specification of multitexture priority from the texture.  The
 * default priority value is 0.
 */
45
inline void EggTexture::clear_priority(void);

1568 12 has_priority 0 4 2053 24 EggTexture::has_priority 0 1 578 127
/**
 * Returns true if a priority value for multitexture importance has been
 * specified for the texture, false otherwise.
 */
49
inline bool EggTexture::has_priority(void) const;

1569 12 get_priority 0 4 2053 24 EggTexture::get_priority 0 1 579 142
/**
 * Returns the multitexture importance value that has been specified for the
 * texture, or 0 if no priority value has been specified.
 */
48
inline int EggTexture::get_priority(void) const;

1570 9 set_color 0 4 2053 21 EggTexture::set_color 0 1 580 10
/**
 *
 */
55
inline void EggTexture::set_color(LColor const &color);

1571 11 clear_color 0 4 2053 23 EggTexture::clear_color 0 1 581 10
/**
 *
 */
42
inline void EggTexture::clear_color(void);

1572 9 has_color 0 4 2053 21 EggTexture::has_color 0 1 582 76
/**
 * Returns true if a blend color has been specified for the texture.
 */
46
inline bool EggTexture::has_color(void) const;

1573 9 get_color 0 4 2053 21 EggTexture::get_color 0 1 583 91
/**
 * Returns the blend color if one has been specified, or (0, 0, 0, 1)
 * otherwise.
 */
55
inline LColor const &EggTexture::get_color(void) const;

1574 16 set_border_color 0 4 2053 28 EggTexture::set_border_color 0 1 584 10
/**
 *
 */
69
inline void EggTexture::set_border_color(LColor const &border_color);

1575 18 clear_border_color 0 4 2053 30 EggTexture::clear_border_color 0 1 585 10
/**
 *
 */
49
inline void EggTexture::clear_border_color(void);

1576 16 has_border_color 0 4 2053 28 EggTexture::has_border_color 0 1 586 77
/**
 * Returns true if a border color has been specified for the texture.
 */
53
inline bool EggTexture::has_border_color(void) const;

1577 16 get_border_color 0 4 2053 28 EggTexture::get_border_color 0 1 587 92
/**
 * Returns the border color if one has been specified, or (0, 0, 0, 1)
 * otherwise.
 */
62
inline LColor const &EggTexture::get_border_color(void) const;

1578 11 set_uv_name 0 4 2053 23 EggTexture::set_uv_name 0 1 588 309
/**
 * Specifies the named set of texture coordinates that this texture will use
 * when it is applied to geometry.  Geometry may have multiple sets of texture
 * coordinates defined, by name.
 *
 * If this is not specified for a particular texture, the default set of
 * texture coordinates will be used.
 */
64
inline void EggTexture::set_uv_name(std::string const &uv_name);

1579 13 clear_uv_name 0 4 2053 25 EggTexture::clear_uv_name 0 1 589 153
/**
 * Removes the restriction to a particular named set of texture coordinates
 * and restores the texture to using the default texture coordinates.
 */
44
inline void EggTexture::clear_uv_name(void);

1580 11 has_uv_name 0 4 2053 23 EggTexture::has_uv_name 0 1 590 110
/**
 * Returns true if a texcoord name has been explicitly specified for this
 * texture, false otherwise.
 */
48
inline bool EggTexture::has_uv_name(void) const;

1581 11 get_uv_name 0 4 2053 23 EggTexture::get_uv_name 0 1 591 152
/**
 * Returns the texcoord name that has been specified for this texture, or the
 * empty string if no texcoord name has explicitly been specified.
 */
62
inline std::string const &EggTexture::get_uv_name(void) const;

1582 13 set_rgb_scale 0 4 2053 25 EggTexture::set_rgb_scale 0 1 592 220
/**
 * Sets an additional factor that will scale all three r, g, b components
 * after the texture has been applied.  This is used only when a combine mode
 * is in effect.
 *
 * The only legal values are 1, 2, or 4.
 */
53
inline void EggTexture::set_rgb_scale(int rgb_scale);

1583 15 clear_rgb_scale 0 4 2053 27 EggTexture::clear_rgb_scale 0 1 593 95
/**
 * Removes the rgb_scale from the texture and restores it to the default value
 * of 1.
 */
46
inline void EggTexture::clear_rgb_scale(void);

1584 13 has_rgb_scale 0 4 2053 25 EggTexture::has_rgb_scale 0 1 594 95
/**
 * Returns true if an rgb_scale has been specified for the texture, false
 * otherwise.
 */
50
inline bool EggTexture::has_rgb_scale(void) const;

1585 13 get_rgb_scale 0 4 2053 25 EggTexture::get_rgb_scale 0 1 595 129
/**
 * Returns the rgb_scale value that has been specified for the texture, or 1
 * if no rgb_scale value has been specified.
 */
49
inline int EggTexture::get_rgb_scale(void) const;

1586 15 set_alpha_scale 0 4 2053 27 EggTexture::set_alpha_scale 0 1 596 211
/**
 * Sets an additional factor that will scale the alpha component after the
 * texture has been applied.  This is used only when a combine mode is in
 * effect.
 *
 * The only legal values are 1, 2, or 4.
 */
57
inline void EggTexture::set_alpha_scale(int alpha_scale);

1587 17 clear_alpha_scale 0 4 2053 29 EggTexture::clear_alpha_scale 0 1 597 97
/**
 * Removes the alpha_scale from the texture and restores it to the default
 * value of 1.
 */
48
inline void EggTexture::clear_alpha_scale(void);

1588 15 has_alpha_scale 0 4 2053 27 EggTexture::has_alpha_scale 0 1 598 97
/**
 * Returns true if an alpha_scale has been specified for the texture, false
 * otherwise.
 */
52
inline bool EggTexture::has_alpha_scale(void) const;

1589 15 get_alpha_scale 0 4 2053 27 EggTexture::get_alpha_scale 0 1 599 133
/**
 * Returns the alpha_scale value that has been specified for the texture, or 1
 * if no alpha_scale value has been specified.
 */
51
inline int EggTexture::get_alpha_scale(void) const;

1590 18 set_alpha_filename 0 4 2053 30 EggTexture::set_alpha_filename 0 1 600 235
/**
 * Specifies a separate file that will be loaded in with the 1- or 3-component
 * texture and applied as the alpha channel.  This is useful when loading
 * textures from file formats that do not support alpha, for instance jpg.
 */
69
inline void EggTexture::set_alpha_filename(Filename const &filename);

1591 20 clear_alpha_filename 0 4 2053 32 EggTexture::clear_alpha_filename 0 1 601 10
/**
 *
 */
51
inline void EggTexture::clear_alpha_filename(void);

1592 18 has_alpha_filename 0 4 2053 30 EggTexture::has_alpha_filename 0 1 602 131
/**
 * Returns true if a separate file for the alpha component has been applied,
 * false otherwise.  See set_alpha_filename().
 */
55
inline bool EggTexture::has_alpha_filename(void) const;

1593 18 get_alpha_filename 0 4 2053 30 EggTexture::get_alpha_filename 0 1 603 172
/**
 * Returns the separate file assigned for the alpha channel.  It is an error
 * to call this unless has_alpha_filename() returns true.  See
 * set_alpha_filename().
 */
66
inline Filename const &EggTexture::get_alpha_filename(void) const;

1594 18 set_alpha_fullpath 0 4 2053 30 EggTexture::set_alpha_fullpath 0 1 604 93
/**
 * Records the full pathname to the file, for the benefit of
 * get_alpha_fullpath().
 */
69
inline void EggTexture::set_alpha_fullpath(Filename const &fullpath);

1595 18 get_alpha_fullpath 0 4 2053 30 EggTexture::get_alpha_fullpath 0 1 605 463
/**
 * Returns the full pathname to the alpha file, if it is known; otherwise,
 * returns the same thing as get_alpha_filename().
 *
 * This function simply returns whatever was set by the last call to
 * set_alpha_fullpath().  This string is not written to the egg file; its main
 * purpose is to record the full path to the alpha filename if it is known,
 * for egg structures that are generated in-memory and then immediately
 * converted to a scene graph.
 */
66
inline Filename const &EggTexture::get_alpha_fullpath(void) const;

1596 22 set_alpha_file_channel 0 4 2053 34 EggTexture::set_alpha_file_channel 0 1 606 416
/**
 * If a separate alpha-file is specified, this indicates which channel number
 * should be extracted from this file to derive the alpha channel for the
 * final image.  The default is 0, which means the grayscale combination of r,
 * g, b.  Otherwise, this should be the 1-based channel number, for instance
 * 1, 2, or 3 for r, g, or b, respectively, or 4 for the alpha channel of a
 * four-component image.
 */
71
inline void EggTexture::set_alpha_file_channel(int alpha_file_channel);

1597 24 clear_alpha_file_channel 0 4 2053 36 EggTexture::clear_alpha_file_channel 0 1 607 98
/**
 * Removes the specification of a particular channel to use from the alpha-
 * file image.
 */
55
inline void EggTexture::clear_alpha_file_channel(void);

1598 22 has_alpha_file_channel 0 4 2053 34 EggTexture::has_alpha_file_channel 0 1 608 112
/**
 * Returns true if a particular channel has been specified for the alpha-file
 * image, false otherwise.
 */
59
inline bool EggTexture::has_alpha_file_channel(void) const;

1599 22 get_alpha_file_channel 0 4 2053 34 EggTexture::get_alpha_file_channel 0 1 609 167
/**
 * Returns the particular channel that has been specified for the alpha-file
 * image, or 0 if no channel has been specified.  See
 * set_alpha_file_channel().
 */
58
inline int EggTexture::get_alpha_file_channel(void) const;

1600 13 set_multiview 0 4 2053 25 EggTexture::set_multiview 0 1 610 380
/**
 * Sets the multiview flag.
 *
 * If multiview is true, the filename should contain a hash mark ('#'), which
 * will be filled in with the view number; and a multiview texture will be
 * defined with a series of images, one for each view.
 *
 * A multiview texture is most often used for stereo textures, but other uses
 * are also possible, such as for texture animation.
 */
54
inline void EggTexture::set_multiview(bool multiview);

1601 13 get_multiview 0 4 2053 25 EggTexture::get_multiview 0 1 611 83
/**
 * Returns the current setting of the multiview flag.  See set_multiview().
 */
50
inline bool EggTexture::get_multiview(void) const;

1602 13 set_num_views 0 4 2053 25 EggTexture::set_num_views 0 1 612 197
/**
 * When loading a 3-D multiview texture, this parameter is necessary to
 * specify how many views will be expected.  The z size is determined
 * implicitly from the number of images loaded.
 */
53
inline void EggTexture::set_num_views(int num_views);

1603 15 clear_num_views 0 4 2053 27 EggTexture::clear_num_views 0 1 613 91
/**
 * Removes the specification of the number of views for a 3-D multiview
 * texture.
 */
46
inline void EggTexture::clear_num_views(void);

1604 13 has_num_views 0 4 2053 25 EggTexture::has_num_views 0 1 614 116
/**
 * Returns true if the number of views has been specified for the 3-D
 * multiview texture, false otherwise.
 */
50
inline bool EggTexture::has_num_views(void) const;

1605 13 get_num_views 0 4 2053 25 EggTexture::get_num_views 0 1 615 114
/**
 * Returns the specified number of views specified for the 3-D multiview
 * texture.  See set_num_views().
 */
49
inline int EggTexture::get_num_views(void) const;

1606 16 set_read_mipmaps 0 4 2053 28 EggTexture::set_read_mipmaps 0 1 616 546
/**
 * Sets the read_mipmaps flag.
 *
 * If read_mipmaps is true, the filename should contain a hash mark ('#'),
 * which will be filled in with the mipmap level number; and the texture will
 * be defined with a series of images, one for each mipmap level.
 *
 * If the filename is of a type that already requires a hash mark, such as a
 * cube map or a 3-d texture, then the filename should now require two hash
 * marks, and the first one indicates the mipmap level number, while the
 * second indicates the face number or 3-d level number.
 */
60
inline void EggTexture::set_read_mipmaps(bool read_mipmaps);

1607 16 get_read_mipmaps 0 4 2053 28 EggTexture::get_read_mipmaps 0 1 617 92
/**
 * Returns the current setting of the read_mipmaps flag.  See
 * set_read_mipmaps().
 */
53
inline bool EggTexture::get_read_mipmaps(void) const;

1608 11 set_min_lod 0 4 2053 23 EggTexture::set_min_lod 0 1 618 61
/**
 * Sets the minimum mipmap level that may be sampled.
 */
52
inline void EggTexture::set_min_lod(double min_lod);

1609 13 clear_min_lod 0 4 2053 25 EggTexture::clear_min_lod 0 1 619 80
/**
 * Removes the specification of a minimum mipmap level from the texture.
 */
44
inline void EggTexture::clear_min_lod(void);

1610 11 has_min_lod 0 4 2053 23 EggTexture::has_min_lod 0 1 620 120
/**
 * Returns true if a value for the minimum mipmap level has been specified for
 * this texture, false otherwise.
 */
48
inline bool EggTexture::has_min_lod(void) const;

1611 11 get_min_lod 0 4 2053 23 EggTexture::get_min_lod 0 1 621 85
/**
 * Returns the minimum mipmap level that has been specified for this texture.
 */
50
inline double EggTexture::get_min_lod(void) const;

1612 11 set_max_lod 0 4 2053 23 EggTexture::set_max_lod 0 1 622 61
/**
 * Sets the maximum mipmap level that may be sampled.
 */
52
inline void EggTexture::set_max_lod(double max_lod);

1613 13 clear_max_lod 0 4 2053 25 EggTexture::clear_max_lod 0 1 623 80
/**
 * Removes the specification of a maximum mipmap level from the texture.
 */
44
inline void EggTexture::clear_max_lod(void);

1614 11 has_max_lod 0 4 2053 23 EggTexture::has_max_lod 0 1 624 120
/**
 * Returns true if a value for the maximum mipmap level has been specified for
 * this texture, false otherwise.
 */
48
inline bool EggTexture::has_max_lod(void) const;

1615 11 get_max_lod 0 4 2053 23 EggTexture::get_max_lod 0 1 625 85
/**
 * Returns the maximum mipmap level that has been specified for this texture.
 */
50
inline double EggTexture::get_max_lod(void) const;

1616 12 set_lod_bias 0 4 2053 24 EggTexture::set_lod_bias 0 1 626 86
/**
 * Sets the mipmap level bias that is added to the mipmap level to be sampled.
 */
54
inline void EggTexture::set_lod_bias(double lod_bias);

1617 14 clear_lod_bias 0 4 2053 26 EggTexture::clear_lod_bias 0 1 627 80
/**
 * Removes the specification of a maximum mipmap level from the texture.
 */
45
inline void EggTexture::clear_lod_bias(void);

1618 12 has_lod_bias 0 4 2053 24 EggTexture::has_lod_bias 0 1 628 120
/**
 * Returns true if a value for the maximum mipmap level has been specified for
 * this texture, false otherwise.
 */
49
inline bool EggTexture::has_lod_bias(void) const;

1619 12 get_lod_bias 0 4 2053 24 EggTexture::get_lod_bias 0 1 629 85
/**
 * Returns the maximum mipmap level that has been specified for this texture.
 */
51
inline double EggTexture::get_lod_bias(void) const;

1620 18 clear_multitexture 0 4 2053 30 EggTexture::clear_multitexture 0 1 630 173
/**
 * Resets the multitexture flags set by multitexture_over().  After this call,
 * get_multitexture() will return false, and get_multitexture_sort() will
 * return 0.
 */
42
void EggTexture::clear_multitexture(void);

1621 17 multitexture_over 0 4 2053 29 EggTexture::multitexture_over 0 1 631 434
/**
 * Indicates that this texture should be layered on top of the other texture.
 * This will guarantee that this->get_multitexture_sort() >
 * other->get_multitexture_sort(), at least until clear_multitexture() is
 * called on either one.
 *
 * The return value is true if successful, or false if there is a failure
 * because the other texture was already layered on top of this one (or there
 * is a three- or more-way cycle).
 */
54
bool EggTexture::multitexture_over(EggTexture *other);

1622 21 get_multitexture_sort 0 4 2053 33 EggTexture::get_multitexture_sort 0 1 632 333
/**
 * Returns an integer that represents the depth to which this texture is
 * layered on all other textures in the egg file.  In general, if texture A is
 * layered over texture B, then sort(A) > sort(B).  If texture A is never
 * layered over any other texture, then sort(A) == 0.  More than that is
 * difficult to guarantee.
 */
57
inline int EggTexture::get_multitexture_sort(void) const;

1623 19 string_texture_type 0 4 2053 31 EggTexture::string_texture_type 0 1 633 171
/**
 * Returns the Texture_ype value associated with the given string
 * representation, or TT_unspecified if the string does not match any known
 * TextureType value.
 */
90
static EggTexture::TextureType EggTexture::string_texture_type(std::string const &string);

1624 13 string_format 0 4 2053 25 EggTexture::string_format 0 1 634 157
/**
 * Returns the Format value associated with the given string representation,
 * or F_unspecified if the string does not match any known Format value.
 */
79
static EggTexture::Format EggTexture::string_format(std::string const &string);

1625 23 string_compression_mode 0 4 2053 35 EggTexture::string_compression_mode 0 1 635 175
/**
 * Returns the CompressionMode value associated with the given string
 * representation, or CM_default if the string does not match any known
 * CompressionMode value.
 */
98
static EggTexture::CompressionMode EggTexture::string_compression_mode(std::string const &string);

1626 16 string_wrap_mode 0 4 2053 28 EggTexture::string_wrap_mode 0 1 636 162
/**
 * Returns the WrapMode value associated with the given string representation,
 * or WM_unspecified if the string does not match any known WrapMode value.
 */
84
static EggTexture::WrapMode EggTexture::string_wrap_mode(std::string const &string);

1627 18 string_filter_type 0 4 2053 30 EggTexture::string_filter_type 0 1 637 169
/**
 * Returns the FilterType value associated with the given string
 * representation, or FT_unspecified if the string does not match any known
 * FilterType value.
 */
88
static EggTexture::FilterType EggTexture::string_filter_type(std::string const &string);

1628 15 string_env_type 0 4 2053 27 EggTexture::string_env_type 0 1 638 160
/**
 * Returns the EnvType value associated with the given string representation,
 * or ET_unspecified if the string does not match any known EnvType value.
 */
82
static EggTexture::EnvType EggTexture::string_env_type(std::string const &string);

1629 19 string_combine_mode 0 4 2053 31 EggTexture::string_combine_mode 0 1 639 171
/**
 * Returns the CombineMode value associated with the given string
 * representation, or CM_unspecified if the string does not match any known
 * CombineMode value.
 */
90
static EggTexture::CombineMode EggTexture::string_combine_mode(std::string const &string);

1630 21 string_combine_source 0 4 2053 33 EggTexture::string_combine_source 0 1 640 175
/**
 * Returns the CombineSource value associated with the given string
 * representation, or CS_unspecified if the string does not match any known
 * CombineSource value.
 */
94
static EggTexture::CombineSource EggTexture::string_combine_source(std::string const &string);

1631 22 string_combine_operand 0 4 2053 34 EggTexture::string_combine_operand 0 1 641 177
/**
 * Returns the CombineOperand value associated with the given string
 * representation, or CO_unspecified if the string does not match any known
 * CombineOperand value.
 */
96
static EggTexture::CombineOperand EggTexture::string_combine_operand(std::string const &string);

1632 14 string_tex_gen 0 4 2053 26 EggTexture::string_tex_gen 0 1 642 158
/**
 * Returns the TexGen value associated with the given string representation,
 * or ET_unspecified if the string does not match any known TexGen value.
 */
80
static EggTexture::TexGen EggTexture::string_tex_gen(std::string const &string);

1633 20 string_quality_level 0 4 2053 32 EggTexture::string_quality_level 0 1 643 158
/**
 * Returns the TexGen value associated with the given string representation,
 * or ET_unspecified if the string does not match any known TexGen value.
 */
92
static EggTexture::QualityLevel EggTexture::string_quality_level(std::string const &string);

1634 14 get_class_type 0 4 2053 26 EggTexture::get_class_type 0 1 644 0
51
static TypeHandle EggTexture::get_class_type(void);

1635 11 EggMaterial 0 4 2071 24 EggMaterial::EggMaterial 0 2 651 652 22
/**
 *
 */

/**
 *
 */
106
EggMaterial::EggMaterial(std::string const &mref_name);
EggMaterial::EggMaterial(EggMaterial const &copy);

1636 16 is_equivalent_to 0 4 2071 29 EggMaterial::is_equivalent_to 0 1 653 411
/**
 * Returns true if the two materials are equivalent in all relevant properties
 * (according to eq), false otherwise.
 *
 * The Equivalence parameter, eq, should be set to the bitwise OR of the
 * following properties, according to what you consider relevant:
 *
 * EggMaterial::E_attributes: All material attributes (diff, spec, etc.)
 * except MRef name.
 *
 * EggMaterial::E_mref_name: The MRef name.
 */
75
bool EggMaterial::is_equivalent_to(EggMaterial const &other, int eq) const;

1637 15 sorts_less_than 0 4 2071 28 EggMaterial::sorts_less_than 0 1 654 226
/**
 * An ordering operator to compare two materials for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique materials,
 * according to the indicated Equivalence factor.  See is_equivalent_to().
 */
74
bool EggMaterial::sorts_less_than(EggMaterial const &other, int eq) const;

1638 8 set_base 0 4 2071 21 EggMaterial::set_base 0 1 655 10
/**
 *
 */
54
inline void EggMaterial::set_base(LColor const &base);

1639 10 clear_base 0 4 2071 23 EggMaterial::clear_base 0 1 656 10
/**
 *
 */
42
inline void EggMaterial::clear_base(void);

1640 8 has_base 0 4 2071 21 EggMaterial::has_base 0 1 657 10
/**
 *
 */
46
inline bool EggMaterial::has_base(void) const;

1641 8 get_base 0 4 2071 21 EggMaterial::get_base 0 1 658 122
/**
 * It is legal to call this even if has_base() returns false.  If so, it
 * simply returns the default base color.
 */
48
inline LColor EggMaterial::get_base(void) const;

1642 8 set_diff 0 4 2071 21 EggMaterial::set_diff 0 1 659 10
/**
 *
 */
54
inline void EggMaterial::set_diff(LColor const &diff);

1643 10 clear_diff 0 4 2071 23 EggMaterial::clear_diff 0 1 660 10
/**
 *
 */
42
inline void EggMaterial::clear_diff(void);

1644 8 has_diff 0 4 2071 21 EggMaterial::has_diff 0 1 661 10
/**
 *
 */
46
inline bool EggMaterial::has_diff(void) const;

1645 8 get_diff 0 4 2071 21 EggMaterial::get_diff 0 1 662 122
/**
 * It is legal to call this even if has_diff() returns false.  If so, it
 * simply returns the default diff color.
 */
48
inline LColor EggMaterial::get_diff(void) const;

1646 7 set_amb 0 4 2071 20 EggMaterial::set_amb 0 1 663 10
/**
 *
 */
52
inline void EggMaterial::set_amb(LColor const &amb);

1647 9 clear_amb 0 4 2071 22 EggMaterial::clear_amb 0 1 664 10
/**
 *
 */
41
inline void EggMaterial::clear_amb(void);

1648 7 has_amb 0 4 2071 20 EggMaterial::has_amb 0 1 665 10
/**
 *
 */
45
inline bool EggMaterial::has_amb(void) const;

1649 7 get_amb 0 4 2071 20 EggMaterial::get_amb 0 1 666 120
/**
 * It is legal to call this even if has_amb() returns false.  If so, it simply
 * returns the default amb color.
 */
47
inline LColor EggMaterial::get_amb(void) const;

1650 8 set_emit 0 4 2071 21 EggMaterial::set_emit 0 1 667 10
/**
 *
 */
54
inline void EggMaterial::set_emit(LColor const &emit);

1651 10 clear_emit 0 4 2071 23 EggMaterial::clear_emit 0 1 668 10
/**
 *
 */
42
inline void EggMaterial::clear_emit(void);

1652 8 has_emit 0 4 2071 21 EggMaterial::has_emit 0 1 669 10
/**
 *
 */
46
inline bool EggMaterial::has_emit(void) const;

1653 8 get_emit 0 4 2071 21 EggMaterial::get_emit 0 1 670 122
/**
 * It is legal to call this even if has_emit() returns false.  If so, it
 * simply returns the default emit color.
 */
48
inline LColor EggMaterial::get_emit(void) const;

1654 8 set_spec 0 4 2071 21 EggMaterial::set_spec 0 1 671 10
/**
 *
 */
54
inline void EggMaterial::set_spec(LColor const &spec);

1655 10 clear_spec 0 4 2071 23 EggMaterial::clear_spec 0 1 672 10
/**
 *
 */
42
inline void EggMaterial::clear_spec(void);

1656 8 has_spec 0 4 2071 21 EggMaterial::has_spec 0 1 673 10
/**
 *
 */
46
inline bool EggMaterial::has_spec(void) const;

1657 8 get_spec 0 4 2071 21 EggMaterial::get_spec 0 1 674 122
/**
 * It is legal to call this even if has_spec() returns false.  If so, it
 * simply returns the default spec color.
 */
48
inline LColor EggMaterial::get_spec(void) const;

1658 13 set_shininess 0 4 2071 26 EggMaterial::set_shininess 0 1 675 10
/**
 *
 */
57
inline void EggMaterial::set_shininess(double shininess);

1659 15 clear_shininess 0 4 2071 28 EggMaterial::clear_shininess 0 1 676 10
/**
 *
 */
47
inline void EggMaterial::clear_shininess(void);

1660 13 has_shininess 0 4 2071 26 EggMaterial::has_shininess 0 1 677 10
/**
 *
 */
51
inline bool EggMaterial::has_shininess(void) const;

1661 13 get_shininess 0 4 2071 26 EggMaterial::get_shininess 0 1 678 10
/**
 *
 */
53
inline double EggMaterial::get_shininess(void) const;

1662 13 set_roughness 0 4 2071 26 EggMaterial::set_roughness 0 1 679 10
/**
 *
 */
57
inline void EggMaterial::set_roughness(double roughness);

1663 15 clear_roughness 0 4 2071 28 EggMaterial::clear_roughness 0 1 680 10
/**
 *
 */
47
inline void EggMaterial::clear_roughness(void);

1664 13 has_roughness 0 4 2071 26 EggMaterial::has_roughness 0 1 681 10
/**
 *
 */
51
inline bool EggMaterial::has_roughness(void) const;

1665 13 get_roughness 0 4 2071 26 EggMaterial::get_roughness 0 1 682 10
/**
 *
 */
53
inline double EggMaterial::get_roughness(void) const;

1666 12 set_metallic 0 4 2071 25 EggMaterial::set_metallic 0 1 683 10
/**
 *
 */
55
inline void EggMaterial::set_metallic(double metallic);

1667 14 clear_metallic 0 4 2071 27 EggMaterial::clear_metallic 0 1 684 10
/**
 *
 */
46
inline void EggMaterial::clear_metallic(void);

1668 12 has_metallic 0 4 2071 25 EggMaterial::has_metallic 0 1 685 10
/**
 *
 */
50
inline bool EggMaterial::has_metallic(void) const;

1669 12 get_metallic 0 4 2071 25 EggMaterial::get_metallic 0 1 686 10
/**
 *
 */
52
inline double EggMaterial::get_metallic(void) const;

1670 7 set_ior 0 4 2071 20 EggMaterial::set_ior 0 1 687 10
/**
 *
 */
45
inline void EggMaterial::set_ior(double ior);

1671 9 clear_ior 0 4 2071 22 EggMaterial::clear_ior 0 1 688 10
/**
 *
 */
41
inline void EggMaterial::clear_ior(void);

1672 7 has_ior 0 4 2071 20 EggMaterial::has_ior 0 1 689 10
/**
 *
 */
45
inline bool EggMaterial::has_ior(void) const;

1673 7 get_ior 0 4 2071 20 EggMaterial::get_ior 0 1 690 10
/**
 *
 */
47
inline double EggMaterial::get_ior(void) const;

1674 9 set_local 0 4 2071 22 EggMaterial::set_local 0 1 691 10
/**
 *
 */
47
inline void EggMaterial::set_local(bool local);

1675 11 clear_local 0 4 2071 24 EggMaterial::clear_local 0 1 692 10
/**
 *
 */
43
inline void EggMaterial::clear_local(void);

1676 9 has_local 0 4 2071 22 EggMaterial::has_local 0 1 693 10
/**
 *
 */
47
inline bool EggMaterial::has_local(void) const;

1677 9 get_local 0 4 2071 22 EggMaterial::get_local 0 1 694 10
/**
 *
 */
47
inline bool EggMaterial::get_local(void) const;

1678 14 get_class_type 0 4 2071 27 EggMaterial::get_class_type 0 1 695 0
52
static TypeHandle EggMaterial::get_class_type(void);

1679 12 ~EggMaterial 0 4 2071 25 EggMaterial::~EggMaterial 0 0 0
32
EggMaterial::~EggMaterial(void);

1680 17 upcast_to_EggNode 0 12 2073 31 EggPrimitive::upcast_to_EggNode 0 1 750 35
upcast from EggPrimitive to EggNode
47
EggNode *EggPrimitive::upcast_to_EggNode(void);

1681 24 downcast_to_EggPrimitive 0 12 1992 33 EggNode::downcast_to_EggPrimitive 0 1 751 37
downcast from EggNode to EggPrimitive
54
EggPrimitive *EggNode::downcast_to_EggPrimitive(void);

1682 23 upcast_to_EggAttributes 0 12 2073 37 EggPrimitive::upcast_to_EggAttributes 0 1 752 41
upcast from EggPrimitive to EggAttributes
59
EggAttributes *EggPrimitive::upcast_to_EggAttributes(void);

1683 24 downcast_to_EggPrimitive 0 12 1995 39 EggAttributes::downcast_to_EggPrimitive 0 1 753 43
downcast from EggAttributes to EggPrimitive
60
EggPrimitive *EggAttributes::downcast_to_EggPrimitive(void);

1684 23 upcast_to_EggRenderMode 0 12 2073 37 EggPrimitive::upcast_to_EggRenderMode 0 1 754 41
upcast from EggPrimitive to EggRenderMode
59
EggRenderMode *EggPrimitive::upcast_to_EggRenderMode(void);

1685 24 downcast_to_EggPrimitive 0 12 2011 39 EggRenderMode::downcast_to_EggPrimitive 0 1 755 43
downcast from EggRenderMode to EggPrimitive
60
EggPrimitive *EggRenderMode::downcast_to_EggPrimitive(void);

1686 10 operator = 0 4 2073 24 EggPrimitive::operator = 0 1 696 10
/**
 *
 */
72
inline EggPrimitive &EggPrimitive::operator =(EggPrimitive const &copy);

1687 13 ~EggPrimitive 0 6 2073 27 EggPrimitive::~EggPrimitive 0 0 10
/**
 *
 */
49
virtual inline EggPrimitive::~EggPrimitive(void);

1688 9 make_copy 0 6 2073 23 EggPrimitive::make_copy 0 1 697 0
62
virtual EggPrimitive *EggPrimitive::make_copy(void) const = 0;

1689 20 determine_alpha_mode 0 6 2073 34 EggPrimitive::determine_alpha_mode 0 1 698 271
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this primitive that has an
 * alpha_mode other than AM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
64
virtual EggRenderMode *EggPrimitive::determine_alpha_mode(void);

1690 26 determine_depth_write_mode 0 6 2073 40 EggPrimitive::determine_depth_write_mode 0 1 699 272
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * depth_write_mode other than DWM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
70
virtual EggRenderMode *EggPrimitive::determine_depth_write_mode(void);

1691 25 determine_depth_test_mode 0 6 2073 39 EggPrimitive::determine_depth_test_mode 0 1 700 271
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * depth_test_mode other than DTM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
69
virtual EggRenderMode *EggPrimitive::determine_depth_test_mode(void);

1692 25 determine_visibility_mode 0 6 2073 39 EggPrimitive::determine_visibility_mode 0 1 701 270
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * visibility_mode other than VM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
69
virtual EggRenderMode *EggPrimitive::determine_visibility_mode(void);

1693 22 determine_depth_offset 0 6 2073 36 EggPrimitive::determine_depth_offset 0 1 702 256
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this primitive that has a
 * depth_offset specified.  Returns a valid EggRenderMode pointer if one is
 * found, or NULL otherwise.
 */
66
virtual EggRenderMode *EggPrimitive::determine_depth_offset(void);

1694 20 determine_draw_order 0 6 2073 34 EggPrimitive::determine_draw_order 0 1 703 254
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this primitive that has a
 * draw_order specified.  Returns a valid EggRenderMode pointer if one is
 * found, or NULL otherwise.
 */
64
virtual EggRenderMode *EggPrimitive::determine_draw_order(void);

1695 13 determine_bin 0 6 2073 27 EggPrimitive::determine_bin 0 1 704 247
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this primitive that has a bin
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */
57
virtual EggRenderMode *EggPrimitive::determine_bin(void);

1696 13 get_sort_name 0 4 2073 27 EggPrimitive::get_sort_name 0 1 705 223
/**
 * Returns the name of the primitive for the purposes of sorting primitives
 * into different groups, if there is one.
 *
 * Presently, this is defined as the primitive name itself, unless it begins
 * with a digit.
 */
59
inline std::string EggPrimitive::get_sort_name(void) const;

1697 11 get_shading 0 6 2073 25 EggPrimitive::get_shading 0 1 706 696
/**
 * Returns the shading properties apparent on this particular primitive.  This
 * returns S_per_vertex if the vertices have colors or normals (and they are
 * not all the same values), or for a simple primitive, S_overall otherwise.
 * A composite primitive may also return S_per_face if the individual
 * component primitives have colors or normals that are not all the same
 * values.
 *
 * To get the most accurate results, you should call clear_shading() on all
 * connected primitives (or on all primitives in the egg file), followed by
 * get_shading() on each primitive.  You may find it easiest to call these
 * methods on the EggData root node (they are defined on EggGroupNode).
 */
68
virtual EggPrimitive::Shading EggPrimitive::get_shading(void) const;

1698 23 clear_connected_shading 0 4 2073 37 EggPrimitive::clear_connected_shading 0 1 707 128
/**
 * Resets the connected_shading member in this primitive, so that
 * get_connected_shading() will recompute a new value.
 */
56
inline void EggPrimitive::clear_connected_shading(void);

1699 21 get_connected_shading 0 4 2073 35 EggPrimitive::get_connected_shading 0 1 708 479
/**
 * Determines what sort of shading properties this primitive's connected
 * neighbors have.
 *
 * To get the most accurate results, you should first call
 * clear_connected_shading() on all connected primitives (or on all primitives
 * in the egg file). It might also be a good idea to call
 * remove_unused_vertices() to ensure proper connectivity.
 *
 * You may find it easiest to call these other methods on the EggData root
 * node (they are defined on EggGroupNode).
 */
77
inline EggPrimitive::Shading EggPrimitive::get_connected_shading(void) const;

1700 11 set_texture 0 4 2073 25 EggPrimitive::set_texture 0 1 709 217
/**
 * Replaces the current list of textures with the indicated texture.
 *
 * This method is deprecated and is used in support of single-texturing only.
 * Please use the multitexture variant add_texture instead.
 */
59
inline void EggPrimitive::set_texture(EggTexture *texture);

1701 11 has_texture 0 4 2073 25 EggPrimitive::has_texture 0 2 710 711 338
/**
 * Returns true if the primitive has any textures specified, false otherwise.
 *
 * This method is deprecated and is used in support of single-texturing only.
 * New code should be written to use the multitexture variants instead.
 */

/**
 * Returns true if the primitive has the particular indicated texture, false
 * otherwise.
 */
116
inline bool EggPrimitive::has_texture(void) const;
inline bool EggPrimitive::has_texture(EggTexture *texture) const;

1702 11 get_texture 0 4 2073 25 EggPrimitive::get_texture 0 2 712 713 345
/**
 * Returns the first texture on the primitive, if any, or NULL if there are no
 * textures on the primitive.
 *
 * This method is deprecated and is used in support of single-texturing only.
 * New code should be written to use the multitexture variants instead.
 */

/**
 * Returns the nth texture that has been applied to the primitive.
 */
116
inline EggTexture *EggPrimitive::get_texture(void) const;
inline EggTexture *EggPrimitive::get_texture(int n) const;

1703 11 add_texture 0 4 2073 25 EggPrimitive::add_texture 0 1 714 276
/**
 * Applies the indicated texture to the primitive.
 *
 * Note that, in the case of multiple textures being applied to a single
 * primitive, the order in which the textures are applied does not affect the
 * rendering order; use EggTexture::set_sort() to specify that.
 */
59
inline void EggPrimitive::add_texture(EggTexture *texture);

1704 13 clear_texture 0 4 2073 27 EggPrimitive::clear_texture 0 1 715 52
/**
 * Removes any texturing from the primitive.
 */
46
inline void EggPrimitive::clear_texture(void);

1705 16 get_num_textures 0 4 2073 30 EggPrimitive::get_num_textures 0 1 716 67
/**
 * Returns the number of textures applied to the primitive.
 */
54
inline int EggPrimitive::get_num_textures(void) const;

1706 12 set_material 0 4 2073 26 EggPrimitive::set_material 0 1 717 59
/**
 * Applies the indicated material to the primitive.
 */
62
inline void EggPrimitive::set_material(EggMaterial *material);

1707 14 clear_material 0 4 2073 28 EggPrimitive::clear_material 0 1 718 51
/**
 * Removes any material from the primitive.
 */
47
inline void EggPrimitive::clear_material(void);

1708 12 get_material 0 4 2073 26 EggPrimitive::get_material 0 1 719 97
/**
 * Returns a pointer to the applied material, or NULL if there is no material
 * applied.
 */
59
inline EggMaterial *EggPrimitive::get_material(void) const;

1709 12 has_material 0 4 2073 26 EggPrimitive::has_material 0 1 720 160
/**
 * Returns true if the primitive is materiald (and get_material() will return
 * a real pointer), false otherwise (and get_material() will return NULL).
 */
51
inline bool EggPrimitive::has_material(void) const;

1710 14 set_bface_flag 0 4 2073 28 EggPrimitive::set_bface_flag 0 1 721 204
/**
 * Sets the backfacing flag of the polygon.  If this is true, the polygon will
 * be rendered so that both faces are visible; if it is false, only the front
 * face of the polygon will be visible.
 */
52
inline void EggPrimitive::set_bface_flag(bool flag);

1711 14 get_bface_flag 0 4 2073 28 EggPrimitive::get_bface_flag 0 1 722 79
/**
 * Retrieves the backfacing flag of the polygon.  See set_bface_flag().
 */
53
inline bool EggPrimitive::get_bface_flag(void) const;

1712 15 copy_attributes 0 4 2073 29 EggPrimitive::copy_attributes 0 2 723 724 146
/**
 * Copies the rendering attributes from the indicated primitive.
 */

/**
 * Copies the rendering attributes from the indicated primitive.
 */
126
void EggPrimitive::copy_attributes(EggAttributes const &other);
void EggPrimitive::copy_attributes(EggPrimitive const &other);

1713 17 has_vertex_normal 0 4 2073 31 EggPrimitive::has_vertex_normal 0 1 725 295
/**
 * Returns true if any vertex on the primitive has a specific normal set,
 * false otherwise.
 *
 * If you call unify_attributes() first, this will also return false even if
 * all the vertices were set to the same value (since unify_attributes()
 * removes redundant vertex properties).
 */
49
bool EggPrimitive::has_vertex_normal(void) const;

1714 16 has_vertex_color 0 4 2073 30 EggPrimitive::has_vertex_color 0 1 726 294
/**
 * Returns true if any vertex on the primitive has a specific color set, false
 * otherwise.
 *
 * If you call unify_attributes() first, this will also return false even if
 * all the vertices were set to the same value (since unify_attributes()
 * removes redundant vertex properties).
 */
48
bool EggPrimitive::has_vertex_color(void) const;

1715 16 unify_attributes 0 6 2073 30 EggPrimitive::unify_attributes 0 1 727 766
/**
 * If the shading property is S_per_vertex, ensures that all vertices have a
 * normal and a color, and the overall primitive does not.
 *
 * If the shading property is S_per_face, and this is a composite primitive,
 * ensures that all components have a normal and a color, and the vertices and
 * overall primitive do not.  (If this is a simple primitive, S_per_face works
 * the same as S_overall, below).
 *
 * If the shading property is S_overall, ensures that no vertices or
 * components have a normal or a color, and the overall primitive does (if any
 * exists at all).
 *
 * After this call, either the primitive will have normals or its vertices
 * will, but not both.  Ditto for colors.
 *
 * This may create redundant vertices in the vertex pool.
 */
75
virtual void EggPrimitive::unify_attributes(EggPrimitive::Shading shading);

1716 20 apply_last_attribute 0 6 2073 34 EggPrimitive::apply_last_attribute 0 1 728 350
/**
 * Sets the last vertex of the triangle (or each component) to the primitive
 * normal and/or color, if the primitive is flat-shaded.  This reflects the
 * OpenGL convention of storing flat-shaded properties on the last vertex,
 * although it is not usually a convention in Egg.
 *
 * This may introduce redundant vertices to the vertex pool.
 */
54
virtual void EggPrimitive::apply_last_attribute(void);

1717 21 apply_first_attribute 0 6 2073 35 EggPrimitive::apply_first_attribute 0 1 729 353
/**
 * Sets the first vertex of the triangle (or each component) to the primitive
 * normal and/or color, if the primitive is flat-shaded.  This reflects the
 * DirectX convention of storing flat-shaded properties on the first vertex,
 * although it is not usually a convention in Egg.
 *
 * This may introduce redundant vertices to the vertex pool.
 */
55
virtual void EggPrimitive::apply_first_attribute(void);

1718 25 post_apply_flat_attribute 0 6 2073 39 EggPrimitive::post_apply_flat_attribute 0 1 730 217
/**
 * Intended as a followup to apply_last_attribute(), this also sets an
 * attribute on the first vertices of the primitive, if they don't already
 * have an attribute set, just so they end up with *something*.
 */
59
virtual void EggPrimitive::post_apply_flat_attribute(void);

1719 23 reverse_vertex_ordering 0 6 2073 37 EggPrimitive::reverse_vertex_ordering 0 1 731 201
/**
 * Reverses the ordering of the vertices in this primitive, if appropriate, in
 * order to change the direction the polygon appears to be facing.  Does not
 * adjust the surface normal, if any.
 */
57
virtual void EggPrimitive::reverse_vertex_ordering(void);

1720 7 cleanup 0 6 2073 21 EggPrimitive::cleanup 0 1 732 272
/**
 * Cleans up modeling errors in whatever context this makes sense.  For
 * instance, for a polygon, this calls remove_doubled_verts(true).  For a
 * point, it calls remove_nonunique_verts().  Returns true if the primitive is
 * valid, or false if it is degenerate.
 */
41
virtual bool EggPrimitive::cleanup(void);

1721 20 remove_doubled_verts 0 4 2073 34 EggPrimitive::remove_doubled_verts 0 1 733 559
/**
 * Certain kinds of primitives, particularly polygons, don't like to have the
 * same vertex repeated consecutively.  Unfortunately, some modeling programs
 * (like MultiGen) make this an easy mistake to make.
 *
 * It's handy to have a function to remove these redundant vertices.  If
 * closed is true, it also checks that the first and last vertices are not the
 * same.
 *
 * This function identifies repeated vertices by position only; it does not
 * consider any other properties, such as color or UV, significant in
 * differentiating vertices.
 */
53
void EggPrimitive::remove_doubled_verts(bool closed);

1722 22 remove_nonunique_verts 0 4 2073 36 EggPrimitive::remove_nonunique_verts 0 1 734 256
/**
 * Removes any multiple appearances of the same vertex from the primitive.
 * This primarily makes sense for a point primitive, which is really a
 * collection of points and which doesn't make sense to include the same point
 * twice, in any order.
 */
48
void EggPrimitive::remove_nonunique_verts(void);

1723 14 has_primitives 0 6 2073 28 EggPrimitive::has_primitives 0 1 735 124
/**
 * Returns true if there are any primitives (e.g.  polygons) defined within
 * this group or below, false otherwise.
 */
54
virtual bool EggPrimitive::has_primitives(void) const;

1724 20 joint_has_primitives 0 6 2073 34 EggPrimitive::joint_has_primitives 0 1 736 154
/**
 * Returns true if there are any primitives (e.g.  polygons) defined within
 * this group or below, but the search does not include nested joints.
 */
60
virtual bool EggPrimitive::joint_has_primitives(void) const;

1725 11 has_normals 0 6 2073 25 EggPrimitive::has_normals 0 1 737 164
/**
 * Returns true if any of the primitives (e.g.  polygons) defined within this
 * group or below have either face or vertex normals defined, false otherwise.
 */
51
virtual bool EggPrimitive::has_normals(void) const;

1726 5 clear 0 4 2073 19 EggPrimitive::clear 0 1 738 58
/**
 * Removes all of the vertices from the primitive.
 */
38
inline void EggPrimitive::clear(void);

1727 10 add_vertex 0 4 2073 24 EggPrimitive::add_vertex 0 1 739 103
/**
 * Adds the indicated vertex to the end of the primitive's list of vertices,
 * and returns it.
 */
55
EggVertex *EggPrimitive::add_vertex(EggVertex *vertex);

1728 13 remove_vertex 0 4 2073 27 EggPrimitive::remove_vertex 0 2 740 741 218
/**
 * Removes the indicated vertex from the primitive and returns it.  If the
 * vertex was not already in the primitive, does nothing and returns NULL.
 */

/**
 * Removes the indicated vertex from the primitive.
 */
111
EggVertex *EggPrimitive::remove_vertex(EggVertex *vertex);
void EggPrimitive::remove_vertex(std::size_t index);

1729 13 copy_vertices 0 4 2073 27 EggPrimitive::copy_vertices 0 1 742 123
/**
 * Replaces the current primitive's list of vertices with a copy of the list
 * of vertices on the other primitive.
 */
60
void EggPrimitive::copy_vertices(EggPrimitive const &other);

1730 16 get_num_vertices 0 4 2073 30 EggPrimitive::get_num_vertices 0 1 743 205
// These are shorthands if you don't want to use the iterators.

// These are shorthands if you don't want to use the iterators.

// These are shorthands if you don't want to use the iterators.

/**
 *
 */
62
inline std::size_t EggPrimitive::get_num_vertices(void) const;

1731 10 set_vertex 0 4 2073 24 EggPrimitive::set_vertex 0 1 744 187
/**
 * Replaces a particular vertex based on its index number in the list of
 * vertices.  This is just a convenience function for people who don't want to
 * mess with the iterators.
 */
75
inline void EggPrimitive::set_vertex(std::size_t index, EggVertex *vertex);

1732 10 get_vertex 0 4 2073 24 EggPrimitive::get_vertex 0 1 745 64
/**
 * Returns a particular index based on its index number.
 */
68
inline EggVertex *EggPrimitive::get_vertex(std::size_t index) const;

1733 8 get_pool 0 4 2073 22 EggPrimitive::get_pool 0 1 746 126
/**
 * Returns the vertex pool associated with the vertices of the primitive, or
 * NULL if the primitive has no vertices.
 */
57
inline EggVertexPool *EggPrimitive::get_pool(void) const;

1734 5 write 0 6 2073 19 EggPrimitive::write 0 1 747 0
75
virtual void EggPrimitive::write(ostream &out, int indent_level) const = 0;

1735 19 test_vref_integrity 0 4 2073 33 EggPrimitive::test_vref_integrity 0 1 748 0
51
void EggPrimitive::test_vref_integrity(void) const;

1736 14 get_class_type 0 4 2073 28 EggPrimitive::get_class_type 0 1 749 0
53
static TypeHandle EggPrimitive::get_class_type(void);

1737 10 operator = 0 4 2079 33 EggCompositePrimitive::operator = 0 1 756 10
/**
 *
 */
99
inline EggCompositePrimitive &EggCompositePrimitive::operator =(EggCompositePrimitive const &copy);

1738 18 get_num_components 0 4 2079 41 EggCompositePrimitive::get_num_components 0 1 757 148
/**
 * Returns the number of individual component triangles within the composite.
 * Each one of these might have a different set of attributes.
 */
65
inline int EggCompositePrimitive::get_num_components(void) const;

1739 13 get_component 0 4 2079 36 EggCompositePrimitive::get_component 0 2 758 759 132
/**
 * Returns the attributes for the nth component triangle.
 */

/**
 * Returns the attributes for the nth component triangle.
 */
145
inline EggAttributes const *EggCompositePrimitive::get_component(int i) const;
inline EggAttributes *EggCompositePrimitive::get_component(int i);

1740 13 set_component 0 4 2079 36 EggCompositePrimitive::set_component 0 1 760 65
/**
 * Changes the attributes for the nth component triangle.
 */
85
inline void EggCompositePrimitive::set_component(int i, EggAttributes const *attrib);

1741 16 triangulate_into 0 4 2079 39 EggCompositePrimitive::triangulate_into 0 1 761 361
/**
 * Subdivides the composite primitive into triangles and adds those triangles
 * to the indicated container.  Does not remove the primitive from its
 * existing parent or modify it in any way.
 *
 * Returns true if the triangulation is successful, or false if there was some
 * error (in which case the container may contain some partial triangulation).
 */
83
inline bool EggCompositePrimitive::triangulate_into(EggGroupNode *container) const;

1742 20 triangulate_in_place 0 4 2079 43 EggCompositePrimitive::triangulate_in_place 0 1 762 460
/**
 * Subdivides the composite primitive into triangles and adds those triangles
 * to the parent group node in place of the original primitive.  Returns a
 * pointer to the original primitive, which is likely about to be destructed.
 *
 * If convex_also is true, both concave and convex polygons will be subdivided
 * into triangles; otherwise, only concave polygons will be subdivided, and
 * convex polygons will be copied unchanged into the container.
 */
85
PointerTo< EggCompositePrimitive > EggCompositePrimitive::triangulate_in_place(void);

1743 14 get_class_type 0 4 2079 37 EggCompositePrimitive::get_class_type 0 1 763 0
62
static TypeHandle EggCompositePrimitive::get_class_type(void);

1744 7 EggData 0 4 2081 16 EggData::EggData 0 2 764 765 22
/**
 *
 */

/**
 *
 */
76
inline EggData::EggData(void);
inline EggData::EggData(EggData const &copy);

1745 10 operator = 0 4 2081 19 EggData::operator = 0 1 766 10
/**
 *
 */
57
inline EggData &EggData::operator =(EggData const &copy);

1746 20 resolve_egg_filename 0 4 2081 29 EggData::resolve_egg_filename 0 1 767 212
/**
 * Looks for the indicated filename, first along the indicated searchpath, and
 * then along the model_path.  If found, updates the filename to the full path
 * and returns true; otherwise, returns false.
 */
113
static bool EggData::resolve_egg_filename(Filename &egg_filename, DSearchPath const &searchpath = DSearchPath());

1747 4 read 0 4 2081 13 EggData::read 0 2 768 769 735
/**
 * Opens the indicated filename and reads the egg data contents from it.
 * Returns true if the file was successfully opened and read, false if there
 * were some errors, in which case the data may be partially read.
 *
 * error is the output stream to which to write error messages.
 */

/**
 * Parses the egg syntax contained in the indicated input stream.  Returns
 * true if the stream was a completely valid egg file, false if there were
 * some errors, in which case the data may be partially read.
 *
 * Before you call this routine, you should probably call set_egg_filename()
 * to set the name of the egg file we're processing, if at all possible.  If
 * there is no such filename, you may set it to the empty string.
 */
108
bool EggData::read(Filename filename, std::string display_name = string());
bool EggData::read(istream &in);

1748 5 merge 0 4 2081 14 EggData::merge 0 1 770 110
/**
 * Appends the other egg structure to the end of this one.  The other egg
 * structure is invalidated.
 */
36
void EggData::merge(EggData &other);

1749 14 load_externals 0 4 2081 23 EggData::load_externals 0 2 771 772 714
/**
 * Loads up all the egg files referenced by <File> entries within the egg
 * structure, and inserts their contents in place of the <File> entries.
 * Searches for files in the searchpath, if not found directly, and writes
 * error messages to the indicated output stream.  Returns true if all
 * externals were loaded successfully, false otherwise.
 */

/**
 * Loads up all the egg files referenced by <File> entries within the egg
 * structure, and inserts their contents in place of the <File> entries.
 * Searches for files in the searchpath, if not found directly, and writes
 * error messages to the indicated output stream.  Returns true if all
 * externals were loaded successfully, false otherwise.
 */
161
bool EggData::load_externals(DSearchPath const &searchpath = DSearchPath());
bool EggData::load_externals(DSearchPath const &searchpath, BamCacheRecord *record);

1750 28 collapse_equivalent_textures 0 4 2081 37 EggData::collapse_equivalent_textures 0 1 773 310
/**
 * Removes duplicate references to the same texture image with the same
 * properties.  Considers two texture references with identical properties,
 * but different tref names, to be equivalent, and collapses them, choosing
 * one tref name to keep arbitrarily.  Returns the number of textures removed.
 */
48
int EggData::collapse_equivalent_textures(void);

1751 29 collapse_equivalent_materials 0 4 2081 38 EggData::collapse_equivalent_materials 0 1 774 306
/**
 * Removes duplicate references to the same material with the same properties.
 * Considers two material references with identical properties, but different
 * mref names, to be equivalent, and collapses them, choosing one mref name to
 * keep arbitrarily.  Returns the number of materials removed.
 */
49
int EggData::collapse_equivalent_materials(void);

1752 9 write_egg 0 4 2081 18 EggData::write_egg 0 2 775 776 124
/**
 * The main interface for writing complete egg files.
 */

/**
 * The main interface for writing complete egg files.
 */
82
bool EggData::write_egg(Filename filename);
bool EggData::write_egg(ostream &out);

1753 26 set_auto_resolve_externals 0 4 2081 35 EggData::set_auto_resolve_externals 0 1 777 147
/**
 * Indicates whether the EggData object will automatically resolve any
 * external references when read() is called.  The default is false.
 */
62
inline void EggData::set_auto_resolve_externals(bool resolve);

1754 26 get_auto_resolve_externals 0 4 2081 35 EggData::get_auto_resolve_externals 0 1 778 147
/**
 * Indicates whether the EggData object will automatically resolve any
 * external references when read() is called.  The default is false.
 */
60
inline bool EggData::get_auto_resolve_externals(void) const;

1755 31 original_had_absolute_pathnames 0 4 2081 40 EggData::original_had_absolute_pathnames 0 1 779 411
/**
 * Returns true if the data processed in the last call to read() contained
 * absolute pathnames, or false if those pathnames were all relative.
 *
 * This method is necessary because if auto_resolve_externals() is in effect,
 * it may modify the pathnames to be absolute whether or not they were as
 * loaded from disk.  This method can be used to query the state of the
 * original egg file from disk.
 */
65
inline bool EggData::original_had_absolute_pathnames(void) const;

1756 21 set_coordinate_system 0 4 2081 30 EggData::set_coordinate_system 0 1 780 156
/**
 * Changes the coordinate system of the EggData.  If the coordinate system was
 * previously different, this may result in a conversion of the data.
 */
63
void EggData::set_coordinate_system(CoordinateSystem coordsys);

1757 21 get_coordinate_system 0 4 2081 30 EggData::get_coordinate_system 0 1 781 74
/**
 * Returns the coordinate system in which the egg file is defined.
 */
67
inline CoordinateSystem EggData::get_coordinate_system(void) const;

1758 16 set_egg_filename 0 4 2081 25 EggData::set_egg_filename 0 1 782 150
/**
 * Sets the filename--especially the directory part--in which the egg file is
 * considered to reside.  This is also implicitly set by read().
 */
68
inline void EggData::set_egg_filename(Filename const &egg_filename);

1759 16 get_egg_filename 0 4 2081 25 EggData::get_egg_filename 0 1 783 79
/**
 * Returns the directory in which the egg file is considered to reside.
 */
61
inline Filename const &EggData::get_egg_filename(void) const;

1760 17 set_egg_timestamp 0 4 2081 26 EggData::set_egg_timestamp 0 1 784 136
/**
 * Sets the timestamp of the egg file on disk, at the time it was opened for
 * reading.  This is also implicitly set by read().
 */
61
inline void EggData::set_egg_timestamp(time_t egg_timestamp);

1761 17 get_egg_timestamp 0 4 2081 26 EggData::get_egg_timestamp 0 1 785 142
/**
 * Returns the timestamp of the egg file on disk, at the time it was opened
 * for reading, or 0 if this information is not available.
 */
53
inline time_t EggData::get_egg_timestamp(void) const;

1762 24 recompute_vertex_normals 0 4 2081 33 EggData::recompute_vertex_normals 0 1 786 711
/**
 * Recomputes all the vertex normals for polygon geometry at this group node
 * and below so that they accurately reflect the vertex positions.  A shared
 * edge between two polygons (even in different groups) is considered smooth
 * if the angle between the two edges is less than threshold degrees.
 *
 * This function also removes degenerate polygons that do not have enough
 * vertices to define a normal.  It does not affect normals for other kinds of
 * primitives like Nurbs or Points.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the correct normals.  Thus, it is a good idea
 * to call remove_unused_vertices() after calling this.
 */
64
inline void EggData::recompute_vertex_normals(double threshold);

1763 25 recompute_polygon_normals 0 4 2081 34 EggData::recompute_polygon_normals 0 1 787 672
/**
 * Recomputes all the polygon normals for polygon geometry at this group node
 * and below so that they accurately reflect the vertex positions.  Normals
 * are removed from the vertices and defined only on polygons, giving the
 * geometry a faceted appearance.
 *
 * This function also removes degenerate polygons that do not have enough
 * vertices to define a normal.  It does not affect normals for other kinds of
 * primitives like Nurbs or Points.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the normals removed.  Thus, it is a good idea
 * to call remove_unused_vertices() after calling this.
 */
53
inline void EggData::recompute_polygon_normals(void);

1764 13 strip_normals 0 4 2081 22 EggData::strip_normals 0 1 788 317
/**
 * Removes all normals from primitives, and the vertices they reference, at
 * this node and below.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the normal removed.  Thus, it is a good idea to
 * call remove_unused_vertices() after calling this.
 */
41
inline void EggData::strip_normals(void);

1765 14 get_class_type 0 4 2081 23 EggData::get_class_type 0 1 789 0
48
static TypeHandle EggData::get_class_type(void);

1766 8 ~EggData 0 4 2081 17 EggData::~EggData 0 0 0
24
EggData::~EggData(void);

1767 19 EggCoordinateSystem 0 4 2082 40 EggCoordinateSystem::EggCoordinateSystem 0 2 790 791 22
/**
 *
 */

/**
 *
 */
169
inline EggCoordinateSystem::EggCoordinateSystem(CoordinateSystem value = ::CS_default);
inline EggCoordinateSystem::EggCoordinateSystem(EggCoordinateSystem const &copy);

1768 9 set_value 0 4 2082 30 EggCoordinateSystem::set_value 0 1 792 10
/**
 *
 */
67
inline void EggCoordinateSystem::set_value(CoordinateSystem value);

1769 9 get_value 0 4 2082 30 EggCoordinateSystem::get_value 0 1 793 10
/**
 *
 */
67
inline CoordinateSystem EggCoordinateSystem::get_value(void) const;

1770 14 get_class_type 0 4 2082 35 EggCoordinateSystem::get_class_type 0 1 794 0
60
static TypeHandle EggCoordinateSystem::get_class_type(void);

1771 20 ~EggCoordinateSystem 0 4 2082 41 EggCoordinateSystem::~EggCoordinateSystem 0 0 0
48
EggCoordinateSystem::~EggCoordinateSystem(void);

1772 10 operator = 0 4 2083 20 EggCurve::operator = 0 1 795 10
/**
 *
 */
60
inline EggCurve &EggCurve::operator =(EggCurve const &copy);

1773 10 set_subdiv 0 4 2083 20 EggCurve::set_subdiv 0 1 796 276
/**
 * Sets the number of subdivisions that will be requested across the curve.
 * (This doesn't necessary guarantee that this number of subdivisions will be
 * made; it's just a hint to any curve renderer or quick tesselator.)  Set the
 * number to 0 to disable the hint.
 */
45
inline void EggCurve::set_subdiv(int subdiv);

1774 10 get_subdiv 0 4 2083 20 EggCurve::get_subdiv 0 1 797 115
/**
 * Returns the requested number of subdivisions, or 0 if no particular
 * subdivisions have been requested.
 */
44
inline int EggCurve::get_subdiv(void) const;

1775 14 set_curve_type 0 4 2083 24 EggCurve::set_curve_type 0 1 798 126
/**
 * Sets the type of the curve.  This is primarily used as a hint to any code
 * that may need to deal with this curve.
 */
63
inline void EggCurve::set_curve_type(EggCurve::CurveType type);

1776 14 get_curve_type 0 4 2083 24 EggCurve::get_curve_type 0 1 799 51
/**
 * Returns the indicated type of the curve.
 */
64
inline EggCurve::CurveType EggCurve::get_curve_type(void) const;

1777 17 string_curve_type 0 4 2083 27 EggCurve::string_curve_type 0 1 800 163
/**
 * Returns the CurveType value associated with the given string
 * representation, or CT_invalid if the string does not match any known
 * CurveType value.
 */
82
static EggCurve::CurveType EggCurve::string_curve_type(std::string const &string);

1778 14 get_class_type 0 4 2083 24 EggCurve::get_class_type 0 1 801 0
49
static TypeHandle EggCurve::get_class_type(void);

1779 9 ~EggCurve 0 4 2083 19 EggCurve::~EggCurve 0 0 0
26
EggCurve::~EggCurve(void);

1780 20 EggExternalReference 0 4 2085 42 EggExternalReference::EggExternalReference 0 2 802 803 22
/**
 *
 */

/**
 *
 */
180
EggExternalReference::EggExternalReference(std::string const &node_name, std::string const &filename);
EggExternalReference::EggExternalReference(EggExternalReference const &copy);

1781 10 operator = 0 4 2085 32 EggExternalReference::operator = 0 1 804 10
/**
 *
 */
89
EggExternalReference &EggExternalReference::operator =(EggExternalReference const &copy);

1782 14 get_class_type 0 4 2085 36 EggExternalReference::get_class_type 0 1 805 0
61
static TypeHandle EggExternalReference::get_class_type(void);

1783 21 ~EggExternalReference 0 4 2085 43 EggExternalReference::~EggExternalReference 0 0 0
50
EggExternalReference::~EggExternalReference(void);

1784 5 clear 0 4 2086 24 EggNameUniquifier::clear 0 1 806 86
/**
 * Empties the table of used named and prepares the Uniquifier for a new tree.
 */
36
void EggNameUniquifier::clear(void);

1785 8 uniquify 0 4 2086 27 EggNameUniquifier::uniquify 0 1 807 56
/**
 * Begins the traversal from the indicated node.
 */
48
void EggNameUniquifier::uniquify(EggNode *node);

1786 8 get_node 0 4 2086 27 EggNameUniquifier::get_node 0 1 808 114
/**
 * Returns the node associated with the given category and name, or NULL if
 * the name has not been used.
 */
97
EggNode *EggNameUniquifier::get_node(std::string const &category, std::string const &name) const;

1787 8 has_name 0 4 2086 27 EggNameUniquifier::has_name 0 1 809 105
/**
 * Returns true if the name has been used for the indicated category already,
 * false otherwise.
 */
93
bool EggNameUniquifier::has_name(std::string const &category, std::string const &name) const;

1788 8 add_name 0 4 2086 27 EggNameUniquifier::add_name 0 1 810 219
/**
 * Adds the name to the indicated category.  This name will not be used for
 * any other egg node within this category.  Returns true if the name was
 * added, or false if it was already in use for the category.
 */
106
bool EggNameUniquifier::add_name(std::string const &category, std::string const &name, EggNode *node = 0);

1789 12 get_category 0 6 2086 31 EggNameUniquifier::get_category 0 1 811 0
71
virtual std::string EggNameUniquifier::get_category(EggNode *node) = 0;

1790 11 filter_name 0 6 2086 30 EggNameUniquifier::filter_name 0 1 812 216
/**
 * Returns the name of the given node, or at least the name it should be.
 * This provides a hook to adjust the name before attempting to uniquify it,
 * if desired, for instance to remove invalid characters.
 */
66
virtual std::string EggNameUniquifier::filter_name(EggNode *node);

1791 13 generate_name 0 6 2086 32 EggNameUniquifier::generate_name 0 1 813 365
/**
 * Generates a new name for the given node when its existing name clashes with
 * some other node.  This function will be called repeatedly, if necessary,
 * until it returns a name that actually is unique.
 *
 * The category is the string returned by get_category(), and index is a
 * uniquely-generated number that may be useful for synthesizing the name.
 */
108
virtual std::string EggNameUniquifier::generate_name(EggNode *node, std::string const &category, int index);

1792 14 get_class_type 0 4 2086 33 EggNameUniquifier::get_class_type 0 1 814 0
58
static TypeHandle EggNameUniquifier::get_class_type(void);

1793 18 EggGroupUniquifier 0 4 2087 38 EggGroupUniquifier::EggGroupUniquifier 0 1 815 254
/**
 * If filter_names is true, then the group names will be coerced into a fairly
 * safe, standard convention that uses no characters other than a-z, A-Z, 0-9,
 * and underscore.  If filter_names is false, the group names will be left
 * unchanged.
 */
65
EggGroupUniquifier::EggGroupUniquifier(bool filter_names = true);

1794 14 get_class_type 0 4 2087 34 EggGroupUniquifier::get_class_type 0 1 816 0
59
static TypeHandle EggGroupUniquifier::get_class_type(void);

1795 19 ~EggGroupUniquifier 0 4 2087 39 EggGroupUniquifier::~EggGroupUniquifier 0 0 0
46
EggGroupUniquifier::~EggGroupUniquifier(void);

1796 10 operator = 0 4 2088 19 EggLine::operator = 0 1 817 10
/**
 *
 */
57
inline EggLine &EggLine::operator =(EggLine const &copy);

1797 9 make_copy 0 6 2088 18 EggLine::make_copy 0 1 818 39
/**
 * Makes a copy of this object.
 */
51
virtual EggLine *EggLine::make_copy(void) override;

1798 9 has_thick 0 4 2088 18 EggLine::has_thick 0 1 819 10
/**
 *
 */
43
inline bool EggLine::has_thick(void) const;

1799 9 get_thick 0 4 2088 18 EggLine::get_thick 0 1 820 108
/**
 * Returns the thickness set on this particular line.  If there is no
 * thickness set, returns 1.0.
 */
45
inline double EggLine::get_thick(void) const;

1800 9 set_thick 0 4 2088 18 EggLine::set_thick 0 1 821 10
/**
 *
 */
45
inline void EggLine::set_thick(double thick);

1801 11 clear_thick 0 4 2088 20 EggLine::clear_thick 0 1 822 10
/**
 *
 */
39
inline void EggLine::clear_thick(void);

1802 14 get_class_type 0 4 2088 23 EggLine::get_class_type 0 1 823 0
48
static TypeHandle EggLine::get_class_type(void);

1803 21 EggMaterialCollection 0 4 2089 44 EggMaterialCollection::EggMaterialCollection 0 2 824 825 22
/**
 *
 */

/**
 *
 */
132
EggMaterialCollection::EggMaterialCollection(void);
EggMaterialCollection::EggMaterialCollection(EggMaterialCollection const &copy);

1804 10 operator = 0 4 2089 33 EggMaterialCollection::operator = 0 1 826 10
/**
 *
 */
92
EggMaterialCollection &EggMaterialCollection::operator =(EggMaterialCollection const &copy);

1805 22 ~EggMaterialCollection 0 4 2089 45 EggMaterialCollection::~EggMaterialCollection 0 0 10
/**
 *
 */
52
EggMaterialCollection::~EggMaterialCollection(void);

1806 5 clear 0 4 2089 28 EggMaterialCollection::clear 0 1 827 53
/**
 * Removes all materials from the collection.
 */
40
void EggMaterialCollection::clear(void);

1807 17 extract_materials 0 4 2089 40 EggMaterialCollection::extract_materials 0 1 828 211
/**
 * Walks the egg hierarchy beginning at the indicated node, and removes any
 * EggMaterials encountered in the hierarchy, adding them to the collection.
 * Returns the number of EggMaterials encountered.
 */
65
int EggMaterialCollection::extract_materials(EggGroupNode *node);

1808 19 find_used_materials 0 4 2089 42 EggMaterialCollection::find_used_materials 0 1 829 903
/**
 * Walks the egg hierarchy beginning at the indicated node, looking for
 * materials that are referenced by primitives but are not already members of
 * the collection, adding them to the collection.
 *
 * If this is called following extract_materials(), it can be used to pick up
 * any additional material references that appeared in the egg hierarchy (but
 * whose EggMaterial node was not actually part of the hierarchy).
 *
 * If this is called in lieu of extract_materials(), it will fill up the
 * collection with all of the referenced materials (and only the referenced
 * materials), without destructively removing the EggMaterials from the
 * hierarchy.
 *
 * This also has the side effect of incrementing the internal usage count for
 * a material in the collection each time a material reference is encountered.
 * This side effect is taken advantage of by remove_unused_materials().
 */
62
int EggMaterialCollection::find_used_materials(EggNode *node);

1809 23 remove_unused_materials 0 4 2089 46 EggMaterialCollection::remove_unused_materials 0 1 830 283
/**
 * Removes any materials from the collection that aren't referenced by any
 * primitives in the indicated egg hierarchy.  This also, incidentally, adds
 * materials to the collection that had been referenced by primitives but had
 * not previously appeared in the collection.
 */
67
void EggMaterialCollection::remove_unused_materials(EggNode *node);

1810 29 collapse_equivalent_materials 0 4 2089 52 EggMaterialCollection::collapse_equivalent_materials 0 2 831 832 1050
/**
 * Walks through the collection and collapses together any separate materials
 * that are equivalent according to the indicated equivalence factor, eq (see
 * EggMaterial::is_equivalent_to()).  The return value is the number of
 * materials removed.
 *
 * This flavor of collapse_equivalent_materials() automatically adjusts all
 * the primitives in the egg hierarchy to refer to the new material pointers.
 */

/**
 * Walks through the collection and collapses together any separate materials
 * that are equivalent according to the indicated equivalence factor, eq (see
 * EggMaterial::is_equivalent_to()).  The return value is the number of
 * materials removed.
 *
 * This flavor of collapse_equivalent_materials() does not adjust any
 * primitives in the egg hierarchy; instead, it fills up the 'removed' map
 * with an entry for each removed material, mapping it back to the equivalent
 * retained material.  It's up to the user to then call replace_materials()
 * with this map, if desired, to apply these changes to the egg hierarchy.
 */
204
int EggMaterialCollection::collapse_equivalent_materials(int eq, EggGroupNode *node);
int EggMaterialCollection::collapse_equivalent_materials(int eq, EggMaterialCollection::MaterialReplacement &removed);

1811 17 replace_materials 0 4 2089 40 EggMaterialCollection::replace_materials 0 1 833 300
/**
 * Walks the egg hierarchy, changing out any reference to a material appearing
 * on the left side of the map with its corresponding material on the right
 * side.  This is most often done following a call to
 * collapse_equivalent_materials().  It does not directly affect the
 * Collection.
 */
132
static void EggMaterialCollection::replace_materials(EggGroupNode *node, EggMaterialCollection::MaterialReplacement const &replace);

1812 14 uniquify_mrefs 0 4 2089 37 EggMaterialCollection::uniquify_mrefs 0 1 834 131
/**
 * Guarantees that each material in the collection has a unique MRef name.
 * This is essential before writing an egg file.
 */
49
void EggMaterialCollection::uniquify_mrefs(void);

1813 12 sort_by_mref 0 4 2089 35 EggMaterialCollection::sort_by_mref 0 1 835 154
/**
 * Sorts all the materials into alphabetical order by MRef name.  Subsequent
 * operations using begin()/end() will traverse in this sorted order.
 */
47
void EggMaterialCollection::sort_by_mref(void);

1814 12 add_material 0 4 2089 35 EggMaterialCollection::add_material 0 1 836 165
/**
 * Explicitly adds a new material to the collection.  Returns true if the
 * material was added, false if it was already there or if there was some
 * error.
 */
64
bool EggMaterialCollection::add_material(EggMaterial *material);

1815 15 remove_material 0 4 2089 38 EggMaterialCollection::remove_material 0 1 837 160
/**
 * Explicitly removes a material from the collection.  Returns true if the
 * material was removed, false if it wasn't there or if there was some error.
 */
67
bool EggMaterialCollection::remove_material(EggMaterial *material);

1816 22 create_unique_material 0 4 2089 45 EggMaterialCollection::create_unique_material 0 1 838 421
// create_unique_material() creates a new material if there is not already
// one equivalent (according to eq, see EggMaterial::is_equivalent_to()) to
// the indicated material, or returns the existing one if there is.

/**
 * Creates a new material if there is not already one equivalent (according to
 * eq, see EggMaterial::is_equivalent_to()) to the indicated material, or
 * returns the existing one if there is.
 */
92
EggMaterial *EggMaterialCollection::create_unique_material(EggMaterial const &copy, int eq);

1817 9 find_mref 0 4 2089 32 EggMaterialCollection::find_mref 0 1 839 145
// Find a material with a particular MRef name.

/**
 * Returns the material with the indicated MRef name, or NULL if no material
 * matches.
 */
82
EggMaterial *EggMaterialCollection::find_mref(std::string const &mref_name) const;

1818 10 operator = 0 4 2090 22 EggPolygon::operator = 0 1 840 10
/**
 *
 */
66
inline EggPolygon &EggPolygon::operator =(EggPolygon const &copy);

1819 9 make_copy 0 6 2090 21 EggPolygon::make_copy 0 1 841 39
/**
 * Makes a copy of this object.
 */
57
virtual EggPolygon *EggPolygon::make_copy(void) override;

1820 16 calculate_normal 0 4 2090 28 EggPolygon::calculate_normal 0 1 842 374
/**
 * Calculates the true polygon normal--the vector pointing out of the front of
 * the polygon--based on the vertices.  This does not return or change the
 * polygon's normal as set via set_normal().
 *
 * The return value is true if the normal is computed correctly, or false if
 * the polygon is degenerate and does not have at least three noncollinear
 * vertices.
 */
94
bool EggPolygon::calculate_normal(LNormald &result, CoordinateSystem cs = ::CS_default) const;

1821 9 is_planar 0 4 2090 21 EggPolygon::is_planar 0 1 843 103
/**
 * Returns true if all of the polygon's vertices lie within the same plane,
 * false otherwise.
 */
39
bool EggPolygon::is_planar(void) const;

1822 24 recompute_polygon_normal 0 4 2090 36 EggPolygon::recompute_polygon_normal 0 1 844 210
/**
 * Recalculates the normal according to the order of the vertices, and sets
 * it.  Returns true if the normal is computed correctly, or false if the
 * polygon is degenerate and does not have a normal.
 */
85
inline bool EggPolygon::recompute_polygon_normal(CoordinateSystem cs = ::CS_default);

1823 16 triangulate_into 0 4 2090 28 EggPolygon::triangulate_into 0 1 845 656
/**
 * Subdivides the polygon into triangles and adds each one to the indicated
 * container.  If the polygon is already a triangle, adds an exact copy of the
 * polygon to the container.  Does not remove the polygon from its existing
 * parent or modify it in any way.
 *
 * Returns true if the triangulation is successful, or false if there was some
 * error (in which case the container may contain some partial triangulation).
 *
 * If convex_also is true, both concave and convex polygons will be subdivided
 * into triangles; otherwise, only concave polygons will be subdivided, and
 * convex polygons will be copied unchanged into the container.
 */
90
inline bool EggPolygon::triangulate_into(EggGroupNode *container, bool convex_also) const;

1824 20 triangulate_in_place 0 4 2090 32 EggPolygon::triangulate_in_place 0 1 846 444
/**
 * Subdivides the polygon into triangles and adds those triangles to the
 * parent group node in place of the original polygon.  Returns a pointer to
 * the original polygon, which is likely about to be destructed.
 *
 * If convex_also is true, both concave and convex polygons will be subdivided
 * into triangles; otherwise, only concave polygons will be subdivided, and
 * convex polygons will be copied unchanged into the container.
 */
75
PointerTo< EggPolygon > EggPolygon::triangulate_in_place(bool convex_also);

1825 14 get_class_type 0 4 2090 26 EggPolygon::get_class_type 0 1 847 0
51
static TypeHandle EggPolygon::get_class_type(void);

1826 11 ~EggPolygon 0 4 2090 23 EggPolygon::~EggPolygon 0 0 0
30
EggPolygon::~EggPolygon(void);

1827 10 operator = 0 4 2091 25 EggNurbsCurve::operator = 0 1 848 10
/**
 *
 */
75
inline EggNurbsCurve &EggNurbsCurve::operator =(EggNurbsCurve const &copy);

1828 9 make_copy 0 6 2091 24 EggNurbsCurve::make_copy 0 1 849 39
/**
 * Makes a copy of this object.
 */
63
virtual EggNurbsCurve *EggNurbsCurve::make_copy(void) override;

1829 5 setup 0 4 2091 20 EggNurbsCurve::setup 0 1 850 306
/**
 * Prepares a new curve definition with the indicated order and number of
 * knots.  This also implies a particular number of vertices as well (the
 * number of knots minus the order), but it is up to the user to add the
 * correct number of vertices to the curve by repeatedly calling push_back().
 */
52
void EggNurbsCurve::setup(int order, int num_knots);

1830 9 set_order 0 4 2091 24 EggNurbsCurve::set_order 0 1 851 273
/**
 * Directly changes the order to the indicated value (which must be an integer
 * in the range 1 <= order <= 4).  If possible, it is preferable to use the
 * setup() method instead of this method, since changing the order directly
 * may result in an invalid curve.
 */
48
inline void EggNurbsCurve::set_order(int order);

1831 13 set_num_knots 0 4 2091 28 EggNurbsCurve::set_num_knots 0 1 852 361
/**
 * Directly changes the number of knots.  This will either add zero-valued
 * knots onto the end, or truncate knot values from the end, depending on
 * whether the list is being increased or decreased.  If possible, it is
 * preferable to use the setup() method instead of directly setting the number
 * of knots, as this may result in an invalid curve.
 */
43
void EggNurbsCurve::set_num_knots(int num);

1832 8 set_knot 0 4 2091 23 EggNurbsCurve::set_knot 0 1 853 199
/**
 * Resets the value of the indicated knot as indicated.  k must be in the
 * range 0 <= k < get_num_knots(), and the value must be in the range
 * get_knot(k - 1) <= value <= get_knot(k + 1).
 */
57
inline void EggNurbsCurve::set_knot(int k, double value);

1833 8 is_valid 0 4 2091 23 EggNurbsCurve::is_valid 0 1 854 204
/**
 * Returns true if the NURBS parameters are all internally consistent (e.g.
 * it has the right number of vertices to match its number of knots and order
 * in each dimension), or false otherwise.
 */
41
bool EggNurbsCurve::is_valid(void) const;

1834 9 get_order 0 4 2091 24 EggNurbsCurve::get_order 0 1 855 215
/**
 * Returns the order of the curve.  The order is the degree of the NURBS
 * equation plus 1; for a typical NURBS, the order is 4.  With this
 * implementation of NURBS, the order must be in the range [1, 4].
 */
48
inline int EggNurbsCurve::get_order(void) const;

1835 10 get_degree 0 4 2091 25 EggNurbsCurve::get_degree 0 1 856 82
/**
 * Returns the degree of the curve.  For a typical NURBS, the degree is 3.
 */
49
inline int EggNurbsCurve::get_degree(void) const;

1836 13 get_num_knots 0 4 2091 28 EggNurbsCurve::get_num_knots 0 1 857 39
/**
 * Returns the number of knots.
 */
52
inline int EggNurbsCurve::get_num_knots(void) const;

1837 11 get_num_cvs 0 4 2091 26 EggNurbsCurve::get_num_cvs 0 1 858 367
/**
 * Returns the total number of control vertices that *should* be defined for
 * the curve.  This is determined by the number of knots and the order, in
 * each direction; it does not necessarily reflect the number of vertices that
 * have actually been added to the curve.  (However, if the number of vertices
 * in the curve are wrong, the curve is invalid.)
 */
50
inline int EggNurbsCurve::get_num_cvs(void) const;

1838 9 is_closed 0 4 2091 24 EggNurbsCurve::is_closed 0 1 859 204
/**
 * Returns true if the curve appears to be closed.  Since the Egg syntax does
 * not provide a means for explicit indication of closure, this has to be
 * guessed at by examining the curve itself.
 */
42
bool EggNurbsCurve::is_closed(void) const;

1839 8 get_knot 0 4 2091 23 EggNurbsCurve::get_knot 0 1 860 46
/**
 * Returns the nth knot value defined.
 */
51
inline double EggNurbsCurve::get_knot(int k) const;

1840 14 get_class_type 0 4 2091 29 EggNurbsCurve::get_class_type 0 1 861 0
54
static TypeHandle EggNurbsCurve::get_class_type(void);

1841 14 ~EggNurbsCurve 0 4 2091 29 EggNurbsCurve::~EggNurbsCurve 0 0 0
36
EggNurbsCurve::~EggNurbsCurve(void);

1842 10 operator = 0 4 2092 22 EggSurface::operator = 0 1 862 10
/**
 *
 */
66
inline EggSurface &EggSurface::operator =(EggSurface const &copy);

1843 12 set_u_subdiv 0 4 2092 24 EggSurface::set_u_subdiv 0 1 863 300
/**
 * Sets the number of subdivisions in the U direction that will be requested
 * across the surface.  (This doesn't necessary guarantee that this number of
 * subdivisions will be made; it's just a hint to any surface renderer or
 * quick tesselator.)  Set the number to 0 to disable the hint.
 */
49
inline void EggSurface::set_u_subdiv(int subdiv);

1844 12 get_u_subdiv 0 4 2092 24 EggSurface::get_u_subdiv 0 1 864 134
/**
 * Returns the requested number of subdivisions in the U direction, or 0 if no
 * particular subdivisions have been requested.
 */
48
inline int EggSurface::get_u_subdiv(void) const;

1845 12 set_v_subdiv 0 4 2092 24 EggSurface::set_v_subdiv 0 1 865 300
/**
 * Sets the number of subdivisions in the U direction that will be requested
 * across the surface.  (This doesn't necessary guarantee that this number of
 * subdivisions will be made; it's just a hint to any surface renderer or
 * quick tesselator.)  Set the number to 0 to disable the hint.
 */
49
inline void EggSurface::set_v_subdiv(int subdiv);

1846 12 get_v_subdiv 0 4 2092 24 EggSurface::get_v_subdiv 0 1 866 134
/**
 * Returns the requested number of subdivisions in the U direction, or 0 if no
 * particular subdivisions have been requested.
 */
48
inline int EggSurface::get_v_subdiv(void) const;

1847 14 get_class_type 0 4 2092 26 EggSurface::get_class_type 0 1 867 0
51
static TypeHandle EggSurface::get_class_type(void);

1848 11 ~EggSurface 0 4 2092 23 EggSurface::~EggSurface 0 0 0
30
EggSurface::~EggSurface(void);

1849 10 operator = 0 4 2093 27 EggNurbsSurface::operator = 0 1 868 10
/**
 *
 */
81
inline EggNurbsSurface &EggNurbsSurface::operator =(EggNurbsSurface const &copy);

1850 9 make_copy 0 6 2093 26 EggNurbsSurface::make_copy 0 1 869 39
/**
 * Makes a copy of this object.
 */
67
virtual EggNurbsSurface *EggNurbsSurface::make_copy(void) override;

1851 5 setup 0 4 2093 22 EggNurbsSurface::setup 0 1 870 349
/**
 * Prepares a new surface definition with the indicated order and number of
 * knots in each dimension.  This also implies a particular number of vertices
 * in each dimension as well (the number of knots minus the order), but it is
 * up to the user to add the correct number of vertices to the surface by
 * repeatedly calling push_back().
 */
88
void EggNurbsSurface::setup(int u_order, int v_order, int num_u_knots, int num_v_knots);

1852 11 set_u_order 0 4 2093 28 EggNurbsSurface::set_u_order 0 1 871 296
/**
 * Directly changes the order in the U direction to the indicated value (which
 * must be an integer in the range 1 <= u_order <= 4).  If possible, it is
 * preferable to use the setup() method instead of this method, since changing
 * the order directly may result in an invalid surface.
 */
54
inline void EggNurbsSurface::set_u_order(int u_order);

1853 11 set_v_order 0 4 2093 28 EggNurbsSurface::set_v_order 0 1 872 296
/**
 * Directly changes the order in the V direction to the indicated value (which
 * must be an integer in the range 1 <= v_order <= 4).  If possible, it is
 * preferable to use the setup() method instead of this method, since changing
 * the order directly may result in an invalid surface.
 */
54
inline void EggNurbsSurface::set_v_order(int v_order);

1854 15 set_num_u_knots 0 4 2093 32 EggNurbsSurface::set_num_u_knots 0 1 873 382
/**
 * Directly changes the number of knots in the U direction.  This will either
 * add zero-valued knots onto the end, or truncate knot values from the end,
 * depending on whether the list is being increased or decreased.  If
 * possible, it is preferable to use the setup() method instead of directly
 * setting the number of knots, as this may result in an invalid surface.
 */
47
void EggNurbsSurface::set_num_u_knots(int num);

1855 15 set_num_v_knots 0 4 2093 32 EggNurbsSurface::set_num_v_knots 0 1 874 382
/**
 * Directly changes the number of knots in the V direction.  This will either
 * add zero-valued knots onto the end, or truncate knot values from the end,
 * depending on whether the list is being increased or decreased.  If
 * possible, it is preferable to use the setup() method instead of directly
 * setting the number of knots, as this may result in an invalid surface.
 */
47
void EggNurbsSurface::set_num_v_knots(int num);

1856 10 set_u_knot 0 4 2093 27 EggNurbsSurface::set_u_knot 0 1 875 205
/**
 * Resets the value of the indicated knot as indicated.  k must be in the
 * range 0 <= k < get_num_u_knots(), and the value must be in the range
 * get_u_knot(k - 1) <= value <= get_u_knot(k + 1).
 */
61
inline void EggNurbsSurface::set_u_knot(int k, double value);

1857 10 set_v_knot 0 4 2093 27 EggNurbsSurface::set_v_knot 0 1 876 205
/**
 * Resets the value of the indicated knot as indicated.  k must be in the
 * range 0 <= k < get_num_v_knots(), and the value must be in the range
 * get_v_knot(k - 1) <= value <= get_v_knot(k + 1).
 */
61
inline void EggNurbsSurface::set_v_knot(int k, double value);

1858 6 set_cv 0 4 2093 23 EggNurbsSurface::set_cv 0 1 877 202
/**
 * Redefines the control vertex associated with a particular u, v coordinate
 * pair.  This is just a shorthand to access the EggPrimitive's normal vertex
 * assignment for a 2-d control vertex.
 */
71
inline void EggNurbsSurface::set_cv(int ui, int vi, EggVertex *vertex);

1859 8 is_valid 0 4 2093 25 EggNurbsSurface::is_valid 0 1 878 204
/**
 * Returns true if the NURBS parameters are all internally consistent (e.g.
 * it has the right number of vertices to match its number of knots and order
 * in each dimension), or false otherwise.
 */
43
bool EggNurbsSurface::is_valid(void) const;

1860 11 get_u_order 0 4 2093 28 EggNurbsSurface::get_u_order 0 1 879 235
/**
 * Returns the order of the surface in the U direction.  The order is the
 * degree of the NURBS equation plus 1; for a typical NURBS, the order is 4.
 * With this implementation of NURBS, the order must be in the range [1, 4].
 */
52
inline int EggNurbsSurface::get_u_order(void) const;

1861 11 get_v_order 0 4 2093 28 EggNurbsSurface::get_v_order 0 1 880 235
/**
 * Returns the order of the surface in the V direction.  The order is the
 * degree of the NURBS equation plus 1; for a typical NURBS, the order is 4.
 * With this implementation of NURBS, the order must be in the range [1, 4].
 */
52
inline int EggNurbsSurface::get_v_order(void) const;

1862 12 get_u_degree 0 4 2093 29 EggNurbsSurface::get_u_degree 0 1 881 106
/**
 * Returns the degree of the surface in the U direction.  For a typical NURBS,
 * the degree is 3.
 */
53
inline int EggNurbsSurface::get_u_degree(void) const;

1863 12 get_v_degree 0 4 2093 29 EggNurbsSurface::get_v_degree 0 1 882 106
/**
 * Returns the degree of the surface in the V direction.  for a typical NURBS,
 * the degree is 3.
 */
53
inline int EggNurbsSurface::get_v_degree(void) const;

1864 15 get_num_u_knots 0 4 2093 32 EggNurbsSurface::get_num_u_knots 0 1 883 58
/**
 * Returns the number of knots in the U direction.
 */
56
inline int EggNurbsSurface::get_num_u_knots(void) const;

1865 15 get_num_v_knots 0 4 2093 32 EggNurbsSurface::get_num_v_knots 0 1 884 58
/**
 * Returns the number of knots in the V direction.
 */
56
inline int EggNurbsSurface::get_num_v_knots(void) const;

1866 13 get_num_u_cvs 0 4 2093 30 EggNurbsSurface::get_num_u_cvs 0 1 885 351
/**
 * Returns the number of control vertices that should be present in the U
 * direction.  This is determined by the number of knots and the order; it
 * does not necessarily reflect the number of vertices that have actually been
 * added to the surface.  (However, if the number of vertices in the surface
 * are wrong, the surface is invalid.)
 */
54
inline int EggNurbsSurface::get_num_u_cvs(void) const;

1867 13 get_num_v_cvs 0 4 2093 30 EggNurbsSurface::get_num_v_cvs 0 1 886 351
/**
 * Returns the number of control vertices that should be present in the V
 * direction.  This is determined by the number of knots and the order; it
 * does not necessarily reflect the number of vertices that have actually been
 * added to the surface.  (However, if the number of vertices in the surface
 * are wrong, the surface is invalid.)
 */
54
inline int EggNurbsSurface::get_num_v_cvs(void) const;

1868 11 get_num_cvs 0 4 2093 28 EggNurbsSurface::get_num_cvs 0 1 887 375
/**
 * Returns the total number of control vertices that *should* be defined for
 * the surface.  This is determined by the number of knots and the order, in
 * each direction; it does not necessarily reflect the number of vertices that
 * have actually been added to the surface.  (However, if the number of
 * vertices in the surface are wrong, the surface is invalid.)
 */
52
inline int EggNurbsSurface::get_num_cvs(void) const;

1869 11 get_u_index 0 4 2093 28 EggNurbsSurface::get_u_index 0 1 888 265
/**
 * Returns the U index number of the given vertex within the EggPrimitive's
 * linear list of vertices.  An EggNurbsSurface maps a linear list of vertices
 * to its 2-d mesh; this returns the U index number that corresponds to the
 * nth vertex in the list.
 */
64
inline int EggNurbsSurface::get_u_index(int vertex_index) const;

1870 11 get_v_index 0 4 2093 28 EggNurbsSurface::get_v_index 0 1 889 265
/**
 * Returns the V index number of the given vertex within the EggPrimitive's
 * linear list of vertices.  An EggNurbsSurface maps a linear list of vertices
 * to its 2-d mesh; this returns the V index number that corresponds to the
 * nth vertex in the list.
 */
64
inline int EggNurbsSurface::get_v_index(int vertex_index) const;

1871 16 get_vertex_index 0 4 2093 33 EggNurbsSurface::get_vertex_index 0 1 890 111
/**
 * Returns the index number within the EggPrimitive's list of the control
 * vertex at position ui, vi.
 */
67
inline int EggNurbsSurface::get_vertex_index(int ui, int vi) const;

1872 11 is_closed_u 0 4 2093 28 EggNurbsSurface::is_closed_u 0 1 891 227
/**
 * Returns true if the surface appears to be closed in the U direction.  Since
 * the Egg syntax does not provide a means for explicit indication of closure,
 * this has to be guessed at by examining the surface itself.
 */
46
bool EggNurbsSurface::is_closed_u(void) const;

1873 11 is_closed_v 0 4 2093 28 EggNurbsSurface::is_closed_v 0 1 892 227
/**
 * Returns true if the surface appears to be closed in the V direction.  Since
 * the Egg syntax does not provide a means for explicit indication of closure,
 * this has to be guessed at by examining the surface itself.
 */
46
bool EggNurbsSurface::is_closed_v(void) const;

1874 10 get_u_knot 0 4 2093 27 EggNurbsSurface::get_u_knot 0 1 893 65
/**
 * Returns the nth knot value defined in the U direction.
 */
55
inline double EggNurbsSurface::get_u_knot(int k) const;

1875 10 get_v_knot 0 4 2093 27 EggNurbsSurface::get_v_knot 0 1 894 65
/**
 * Returns the nth knot value defined in the V direction.
 */
55
inline double EggNurbsSurface::get_v_knot(int k) const;

1876 6 get_cv 0 4 2093 23 EggNurbsSurface::get_cv 0 1 895 68
/**
 * Returns the control vertex at the indicate U, V position.
 */
64
inline EggVertex *EggNurbsSurface::get_cv(int ui, int vi) const;

1877 14 get_class_type 0 4 2093 31 EggNurbsSurface::get_class_type 0 1 896 0
56
static TypeHandle EggNurbsSurface::get_class_type(void);

1878 16 ~EggNurbsSurface 0 4 2093 33 EggNurbsSurface::~EggNurbsSurface 0 0 0
40
EggNurbsSurface::~EggNurbsSurface(void);

1879 10 operator = 0 4 2102 20 EggPatch::operator = 0 1 897 10
/**
 *
 */
60
inline EggPatch &EggPatch::operator =(EggPatch const &copy);

1880 9 make_copy 0 6 2102 19 EggPatch::make_copy 0 1 898 39
/**
 * Makes a copy of this object.
 */
53
virtual EggPatch *EggPatch::make_copy(void) override;

1881 14 get_class_type 0 4 2102 24 EggPatch::get_class_type 0 1 899 0
49
static TypeHandle EggPatch::get_class_type(void);

1882 9 ~EggPatch 0 4 2102 19 EggPatch::~EggPatch 0 0 0
26
EggPatch::~EggPatch(void);

1883 10 operator = 0 4 2103 20 EggPoint::operator = 0 1 900 10
/**
 *
 */
60
inline EggPoint &EggPoint::operator =(EggPoint const &copy);

1884 9 make_copy 0 6 2103 19 EggPoint::make_copy 0 1 901 39
/**
 * Makes a copy of this object.
 */
53
virtual EggPoint *EggPoint::make_copy(void) override;

1885 9 has_thick 0 4 2103 19 EggPoint::has_thick 0 1 902 10
/**
 *
 */
44
inline bool EggPoint::has_thick(void) const;

1886 9 get_thick 0 4 2103 19 EggPoint::get_thick 0 1 903 109
/**
 * Returns the thickness set on this particular point.  If there is no
 * thickness set, returns 1.0.
 */
46
inline double EggPoint::get_thick(void) const;

1887 9 set_thick 0 4 2103 19 EggPoint::set_thick 0 1 904 10
/**
 *
 */
46
inline void EggPoint::set_thick(double thick);

1888 11 clear_thick 0 4 2103 21 EggPoint::clear_thick 0 1 905 10
/**
 *
 */
40
inline void EggPoint::clear_thick(void);

1889 15 has_perspective 0 4 2103 25 EggPoint::has_perspective 0 1 906 10
/**
 *
 */
50
inline bool EggPoint::has_perspective(void) const;

1890 15 get_perspective 0 4 2103 25 EggPoint::get_perspective 0 1 907 125
/**
 * Returns the perspective flag set on this particular point.  If there is no
 * perspective flag set, returns false.
 */
50
inline bool EggPoint::get_perspective(void) const;

1891 15 set_perspective 0 4 2103 25 EggPoint::set_perspective 0 1 908 10
/**
 *
 */
56
inline void EggPoint::set_perspective(bool perspective);

1892 17 clear_perspective 0 4 2103 27 EggPoint::clear_perspective 0 1 909 10
/**
 *
 */
46
inline void EggPoint::clear_perspective(void);

1893 14 get_class_type 0 4 2103 24 EggPoint::get_class_type 0 1 910 0
49
static TypeHandle EggPoint::get_class_type(void);

1894 9 ~EggPoint 0 4 2103 19 EggPoint::~EggPoint 0 0 0
26
EggPoint::~EggPoint(void);

1895 15 EggPolysetMaker 0 4 2104 32 EggPolysetMaker::EggPolysetMaker 0 1 911 10
/**
 *
 */
39
EggPolysetMaker::EggPolysetMaker(void);

1896 14 set_properties 0 4 2104 31 EggPolysetMaker::set_properties 0 1 912 316
/**
 * Sets the set of properties that determines which polygons are allowed to be
 * grouped together into a single polyset.  This is the bitwise 'or' of all
 * the properties that matter.  If this is 0, all polygons (within a given
 * group) will be lumped into a common polyset regardless of their properties.
 */
53
void EggPolysetMaker::set_properties(int properties);

1897 14 get_class_type 0 4 2104 31 EggPolysetMaker::get_class_type 0 1 913 0
56
static TypeHandle EggPolysetMaker::get_class_type(void);

1898 16 ~EggPolysetMaker 0 4 2104 33 EggPolysetMaker::~EggPolysetMaker 0 0 0
40
EggPolysetMaker::~EggPolysetMaker(void);

1899 17 EggPoolUniquifier 0 4 2107 36 EggPoolUniquifier::EggPoolUniquifier 0 1 914 10
/**
 *
 */
43
EggPoolUniquifier::EggPoolUniquifier(void);

1900 14 get_class_type 0 4 2107 33 EggPoolUniquifier::get_class_type 0 1 915 0
58
static TypeHandle EggPoolUniquifier::get_class_type(void);

1901 18 ~EggPoolUniquifier 0 4 2107 37 EggPoolUniquifier::~EggPoolUniquifier 0 0 0
44
EggPoolUniquifier::~EggPoolUniquifier(void);

1902 12 EggSAnimData 0 4 2108 26 EggSAnimData::EggSAnimData 0 2 916 917 22
/**
 *
 */

/**
 *
 */
125
inline EggSAnimData::EggSAnimData(std::string const &name = "");
inline EggSAnimData::EggSAnimData(EggSAnimData const &copy);

1903 10 operator = 0 4 2108 24 EggSAnimData::operator = 0 1 918 10
/**
 *
 */
72
inline EggSAnimData &EggSAnimData::operator =(EggSAnimData const &copy);

1904 12 get_num_rows 0 4 2108 26 EggSAnimData::get_num_rows 0 1 919 100
/**
 * Returns the number of rows in the table.  For an SAnim table, each row has
 * one column.
 */
50
inline int EggSAnimData::get_num_rows(void) const;

1905 9 get_value 0 4 2108 23 EggSAnimData::get_value 0 1 920 106
/**
 * Returns the value at the indicated row.  Row must be in the range 0 <= row
 * < get_num_rows().
 */
53
inline double EggSAnimData::get_value(int row) const;

1906 9 set_value 0 4 2108 23 EggSAnimData::set_value 0 1 921 106
/**
 * Changes the value at the indicated row.  Row must be in the range 0 <= row
 * < get_num_rows().
 */
59
inline void EggSAnimData::set_value(int row, double value);

1907 8 optimize 0 4 2108 22 EggSAnimData::optimize 0 1 922 100
/**
 * Optimizes the data by collapsing a long table of duplicate values into a
 * single value.
 */
34
void EggSAnimData::optimize(void);

1908 14 get_class_type 0 4 2108 28 EggSAnimData::get_class_type 0 1 923 0
53
static TypeHandle EggSAnimData::get_class_type(void);

1909 13 ~EggSAnimData 0 4 2108 27 EggSAnimData::~EggSAnimData 0 0 0
34
EggSAnimData::~EggSAnimData(void);

1910 8 EggTable 0 4 2109 18 EggTable::EggTable 0 2 924 925 22
/**
 *
 */

/**
 *
 */
105
inline EggTable::EggTable(std::string const &name = "");
inline EggTable::EggTable(EggTable const &copy);

1911 10 operator = 0 4 2109 20 EggTable::operator = 0 1 926 10
/**
 *
 */
60
inline EggTable &EggTable::operator =(EggTable const &copy);

1912 14 set_table_type 0 4 2109 24 EggTable::set_table_type 0 1 927 10
/**
 *
 */
63
inline void EggTable::set_table_type(EggTable::TableType type);

1913 14 get_table_type 0 4 2109 24 EggTable::get_table_type 0 1 928 10
/**
 *
 */
64
inline EggTable::TableType EggTable::get_table_type(void) const;

1914 13 has_transform 0 4 2109 23 EggTable::has_transform 0 1 929 90
/**
 * Returns true if the table contains a transform description, false
 * otherwise.
 */
41
bool EggTable::has_transform(void) const;

1915 17 string_table_type 0 4 2109 27 EggTable::string_table_type 0 1 930 163
/**
 * Returns the TableType value associated with the given string
 * representation, or TT_invalid if the string does not match any known
 * TableType value.
 */
82
static EggTable::TableType EggTable::string_table_type(std::string const &string);

1916 14 get_class_type 0 4 2109 24 EggTable::get_class_type 0 1 931 0
49
static TypeHandle EggTable::get_class_type(void);

1917 9 ~EggTable 0 4 2109 19 EggTable::~EggTable 0 0 0
26
EggTable::~EggTable(void);

1918 20 EggTextureCollection 0 4 2111 42 EggTextureCollection::EggTextureCollection 0 2 932 933 22
/**
 *
 */

/**
 *
 */
127
EggTextureCollection::EggTextureCollection(void);
EggTextureCollection::EggTextureCollection(EggTextureCollection const &copy);

1919 10 operator = 0 4 2111 32 EggTextureCollection::operator = 0 1 934 10
/**
 *
 */
89
EggTextureCollection &EggTextureCollection::operator =(EggTextureCollection const &copy);

1920 21 ~EggTextureCollection 0 4 2111 43 EggTextureCollection::~EggTextureCollection 0 0 10
/**
 *
 */
50
EggTextureCollection::~EggTextureCollection(void);

1921 5 clear 0 4 2111 27 EggTextureCollection::clear 0 1 935 52
/**
 * Removes all textures from the collection.
 */
39
void EggTextureCollection::clear(void);

1922 16 extract_textures 0 4 2111 38 EggTextureCollection::extract_textures 0 1 936 209
/**
 * Walks the egg hierarchy beginning at the indicated node, and removes any
 * EggTextures encountered in the hierarchy, adding them to the collection.
 * Returns the number of EggTextures encountered.
 */
63
int EggTextureCollection::extract_textures(EggGroupNode *node);

1923 8 is_empty 0 4 2111 30 EggTextureCollection::is_empty 0 1 937 86
/**
 * Returns true if there are no EggTexures in the collection, false otherwise.
 */
48
bool EggTextureCollection::is_empty(void) const;

1924 16 get_num_textures 0 4 2111 38 EggTextureCollection::get_num_textures 0 1 938 63
/**
 * Returns the number of EggTextures in the collection.
 */
55
int EggTextureCollection::get_num_textures(void) const;

1925 11 get_texture 0 4 2111 33 EggTextureCollection::get_texture 0 1 939 56
/**
 * Returns the nth EggTexture in the collection.
 */
63
EggTexture *EggTextureCollection::get_texture(int index) const;

1926 18 find_used_textures 0 4 2111 40 EggTextureCollection::find_used_textures 0 1 940 1178
/**
 * Walks the egg hierarchy beginning at the indicated node, looking for
 * textures that are referenced by primitives but are not already members of
 * the collection, adding them to the collection.
 *
 * If this is called following extract_textures(), it can be used to pick up
 * any additional texture references that appeared in the egg hierarchy (but
 * whose EggTexture node was not actually part of the hierarchy).
 *
 * If this is called in lieu of extract_textures(), it will fill up the
 * collection with all of the referenced textures (and only the referenced
 * textures), without destructively removing the EggTextures from the
 * hierarchy.
 *
 * This also has the side effect of incrementing the internal usage count for
 * a texture in the collection each time a texture reference is encountered.
 * This side effect is taken advantage of by remove_unused_textures().
 *
 * And one more side effect: this function identifies the presence of
 * multitexturing in the egg file, and calls multitexture_over() on each
 * texture appropriately so that, after this call, you may expect
 * get_multitexture_sort() to return a reasonable value for each texture.
 */
60
int EggTextureCollection::find_used_textures(EggNode *node);

1927 22 remove_unused_textures 0 4 2111 44 EggTextureCollection::remove_unused_textures 0 1 941 281
/**
 * Removes any textures from the collection that aren't referenced by any
 * primitives in the indicated egg hierarchy.  This also, incidentally, adds
 * textures to the collection that had been referenced by primitives but had
 * not previously appeared in the collection.
 */
65
void EggTextureCollection::remove_unused_textures(EggNode *node);

1928 28 collapse_equivalent_textures 0 4 2111 50 EggTextureCollection::collapse_equivalent_textures 0 2 942 943 1038
/**
 * Walks through the collection and collapses together any separate textures
 * that are equivalent according to the indicated equivalence factor, eq (see
 * EggTexture::is_equivalent_to()).  The return value is the number of
 * textures removed.
 *
 * This flavor of collapse_equivalent_textures() automatically adjusts all the
 * primitives in the egg hierarchy to refer to the new texture pointers.
 */

/**
 * Walks through the collection and collapses together any separate textures
 * that are equivalent according to the indicated equivalence factor, eq (see
 * EggTexture::is_equivalent_to()).  The return value is the number of
 * textures removed.
 *
 * This flavor of collapse_equivalent_textures() does not adjust any
 * primitives in the egg hierarchy; instead, it fills up the 'removed' map
 * with an entry for each removed texture, mapping it back to the equivalent
 * retained texture.  It's up to the user to then call replace_textures() with
 * this map, if desired, to apply these changes to the egg hierarchy.
 */
198
int EggTextureCollection::collapse_equivalent_textures(int eq, EggGroupNode *node);
int EggTextureCollection::collapse_equivalent_textures(int eq, EggTextureCollection::TextureReplacement &removed);

1929 16 replace_textures 0 4 2111 38 EggTextureCollection::replace_textures 0 1 944 297
/**
 * Walks the egg hierarchy, changing out any reference to a texture appearing
 * on the left side of the map with its corresponding texture on the right
 * side.  This is most often done following a call to
 * collapse_equivalent_textures().  It does not directly affect the
 * Collection.
 */
128
static void EggTextureCollection::replace_textures(EggGroupNode *node, EggTextureCollection::TextureReplacement const &replace);

1930 14 uniquify_trefs 0 4 2111 36 EggTextureCollection::uniquify_trefs 0 1 945 130
/**
 * Guarantees that each texture in the collection has a unique TRef name.
 * This is essential before writing an egg file.
 */
48
void EggTextureCollection::uniquify_trefs(void);

1931 12 sort_by_tref 0 4 2111 34 EggTextureCollection::sort_by_tref 0 1 946 153
/**
 * Sorts all the textures into alphabetical order by TRef name.  Subsequent
 * operations using begin()/end() will traverse in this sorted order.
 */
46
void EggTextureCollection::sort_by_tref(void);

1932 16 sort_by_basename 0 4 2111 38 EggTextureCollection::sort_by_basename 0 1 947 202
/**
 * Sorts all the textures into alphabetical order by the basename part
 * (including extension) of the filename.  Subsequent operations using
 * begin()/end() will traverse in this sorted order.
 */
50
void EggTextureCollection::sort_by_basename(void);

1933 11 operator [] 0 4 2111 33 EggTextureCollection::operator [] 0 1 948 56
/**
 * Returns the nth EggTexture in the collection.
 */
94
inline EggTexture *EggTextureCollection::operator [](EggTextureCollection::size_type n) const;

1934 4 size 0 4 2111 26 EggTextureCollection::size 0 1 949 63
/**
 * Returns the number of EggTextures in the collection.
 */
78
inline EggTextureCollection::size_type EggTextureCollection::size(void) const;

1935 11 add_texture 0 4 2111 33 EggTextureCollection::add_texture 0 1 950 163
/**
 * Explicitly adds a new texture to the collection.  Returns true if the
 * texture was added, false if it was already there or if there was some
 * error.
 */
60
bool EggTextureCollection::add_texture(EggTexture *texture);

1936 14 remove_texture 0 4 2111 36 EggTextureCollection::remove_texture 0 1 951 158
/**
 * Explicitly removes a texture from the collection.  Returns true if the
 * texture was removed, false if it wasn't there or if there was some error.
 */
63
bool EggTextureCollection::remove_texture(EggTexture *texture);

1937 21 create_unique_texture 0 4 2111 43 EggTextureCollection::create_unique_texture 0 1 952 414
// create_unique_texture() creates a new texture if there is not already one
// equivalent (according to eq, see EggTexture::is_equivalent_to()) to the
// indicated texture, or returns the existing one if there is.

/**
 * Creates a new texture if there is not already one equivalent (according to
 * eq, see EggTexture::is_equivalent_to()) to the indicated texture, or
 * returns the existing one if there is.
 */
88
EggTexture *EggTextureCollection::create_unique_texture(EggTexture const &copy, int eq);

1938 9 find_tref 0 4 2111 31 EggTextureCollection::find_tref 0 1 953 142
// Find a texture with a particular TRef name.

/**
 * Returns the texture with the indicated TRef name, or NULL if no texture
 * matches.
 */
80
EggTexture *EggTextureCollection::find_tref(std::string const &tref_name) const;

1939 13 find_filename 0 4 2111 35 EggTextureCollection::find_filename 0 1 954 140
// Find a texture with a particular filename.

/**
 * Returns the texture with the indicated filename, or NULL if no texture
 * matches.
 */
80
EggTexture *EggTextureCollection::find_filename(Filename const &filename) const;

1940 10 operator = 0 4 2112 26 EggTriangleFan::operator = 0 1 955 10
/**
 *
 */
78
inline EggTriangleFan &EggTriangleFan::operator =(EggTriangleFan const &copy);

1941 9 make_copy 0 6 2112 25 EggTriangleFan::make_copy 0 1 956 39
/**
 * Makes a copy of this object.
 */
65
virtual EggTriangleFan *EggTriangleFan::make_copy(void) override;

1942 14 get_class_type 0 4 2112 30 EggTriangleFan::get_class_type 0 1 957 0
55
static TypeHandle EggTriangleFan::get_class_type(void);

1943 10 operator = 0 4 2113 28 EggTriangleStrip::operator = 0 1 958 10
/**
 *
 */
84
inline EggTriangleStrip &EggTriangleStrip::operator =(EggTriangleStrip const &copy);

1944 9 make_copy 0 6 2113 27 EggTriangleStrip::make_copy 0 1 959 39
/**
 * Makes a copy of this object.
 */
69
virtual EggTriangleStrip *EggTriangleStrip::make_copy(void) override;

1945 14 get_class_type 0 4 2113 32 EggTriangleStrip::get_class_type 0 1 960 0
57
static TypeHandle EggTriangleStrip::get_class_type(void);

1946 11 EggXfmSAnim 0 4 2114 24 EggXfmSAnim::EggXfmSAnim 0 3 961 962 963 108
/**
 *
 */

/**
 *
 */

/**
 * Converts the older-style XfmAnim table to the newer-style XfmSAnim table.
 */
218
inline EggXfmSAnim::EggXfmSAnim(std::string const &name = "", CoordinateSystem cs = ::CS_default);
EggXfmSAnim::EggXfmSAnim(EggXfmAnimData const &convert_from);
inline EggXfmSAnim::EggXfmSAnim(EggXfmSAnim const &copy);

1947 10 operator = 0 4 2114 23 EggXfmSAnim::operator = 0 1 964 10
/**
 *
 */
69
inline EggXfmSAnim &EggXfmSAnim::operator =(EggXfmSAnim const &copy);

1948 7 set_fps 0 4 2114 20 EggXfmSAnim::set_fps 0 1 965 10
/**
 *
 */
45
inline void EggXfmSAnim::set_fps(double fps);

1949 9 clear_fps 0 4 2114 22 EggXfmSAnim::clear_fps 0 1 966 10
/**
 *
 */
41
inline void EggXfmSAnim::clear_fps(void);

1950 7 has_fps 0 4 2114 20 EggXfmSAnim::has_fps 0 1 967 10
/**
 *
 */
45
inline bool EggXfmSAnim::has_fps(void) const;

1951 7 get_fps 0 4 2114 20 EggXfmSAnim::get_fps 0 1 968 56
/**
 * This is only valid if has_fps() returns true.
 */
47
inline double EggXfmSAnim::get_fps(void) const;

1952 9 set_order 0 4 2114 22 EggXfmSAnim::set_order 0 1 969 10
/**
 *
 */
61
inline void EggXfmSAnim::set_order(std::string const &order);

1953 11 clear_order 0 4 2114 24 EggXfmSAnim::clear_order 0 1 970 10
/**
 *
 */
43
inline void EggXfmSAnim::clear_order(void);

1954 9 has_order 0 4 2114 22 EggXfmSAnim::has_order 0 1 971 10
/**
 *
 */
47
inline bool EggXfmSAnim::has_order(void) const;

1955 9 get_order 0 4 2114 22 EggXfmSAnim::get_order 0 1 972 10
/**
 *
 */
61
inline std::string const &EggXfmSAnim::get_order(void) const;

1956 18 get_standard_order 0 4 2114 31 EggXfmSAnim::get_standard_order 0 1 973 178
/**
 * Returns the standard order of matrix component composition.  This is what
 * the order string must be set to in order to use set_value() or add_data()
 * successfully.
 */
71
static inline std::string const &EggXfmSAnim::get_standard_order(void);

1957 21 get_coordinate_system 0 4 2114 34 EggXfmSAnim::get_coordinate_system 0 1 974 292
/**
 * Returns the coordinate system this table believes it is defined within.
 * This should always match the coordinate system of the EggData structure
 * that owns it.  It is necessary to store it here because the meaning of the
 * h, p, and r columns depends on the coordinate system.
 */
71
inline CoordinateSystem EggXfmSAnim::get_coordinate_system(void) const;

1958 8 optimize 0 4 2114 21 EggXfmSAnim::optimize 0 1 975 66
/**
 * Optimizes the table by collapsing redundant sub-tables.
 */
33
void EggXfmSAnim::optimize(void);

1959 26 optimize_to_standard_order 0 4 2114 39 EggXfmSAnim::optimize_to_standard_order 0 1 976 225
/**
 * Optimizes the table by collapsing redundant sub-tables, and simultaneously
 * ensures that the order string is the standard order (which is the same as
 * that supported by compose_matrix() and decompose_matrix()).
 */
51
void EggXfmSAnim::optimize_to_standard_order(void);

1960 9 normalize 0 4 2114 22 EggXfmSAnim::normalize 0 1 977 241
/**
 * The inverse operation of optimize(), this ensures that all the sub-tables
 * have the same length by duplicating rows as necessary.  This is needed
 * before doing operations like add_data() or set_value() on an existing
 * table.
 */
34
void EggXfmSAnim::normalize(void);

1961 12 get_num_rows 0 4 2114 25 EggXfmSAnim::get_num_rows 0 1 978 259
/**
 * Returns the effective number of rows in the table.  This is actually the
 * number of rows of the smallest subtable larger than one row.  This is a
 * convenience function that treats the table of tables as if it were a single
 * table of matrices.
 */
42
int EggXfmSAnim::get_num_rows(void) const;

1962 9 get_value 0 4 2114 22 EggXfmSAnim::get_value 0 1 979 342
/**
 * Returns the value of the aggregate row of the table as a matrix.  This is a
 * convenience function that treats the table of tables as if it were a single
 * table of matrices.  It is an error to call this if any SAnimData children
 * of this node have an improper name (e.g.  not a single letter, or not one
 * of "ijkabchprxyz").
 */
59
void EggXfmSAnim::get_value(int row, LMatrix4d &mat) const;

1963 9 set_value 0 4 2114 22 EggXfmSAnim::set_value 0 1 980 387
/**
 * Replaces the indicated row of the table with the given matrix.
 *
 * This function can only be called if all the constraints of add_data(),
 * below, are met.  Call normalize() first if you are not sure.
 *
 * The return value is true if the matrix can be decomposed and stored as
 * scale, shear, rotate, and translate, or false otherwise.  The data is set
 * in either case.
 */
59
bool EggXfmSAnim::set_value(int row, LMatrix4d const &mat);

1964 10 clear_data 0 4 2114 23 EggXfmSAnim::clear_data 0 1 981 93
/**
 * Removes all data from the table.  It does this by removing all of its
 * children.
 */
42
inline void EggXfmSAnim::clear_data(void);

1965 8 add_data 0 4 2114 21 EggXfmSAnim::add_data 0 1 982 1136
/**
 * Adds a new matrix to the table, by adding a new row to each of the
 * subtables.
 *
 * This is a convenience function that treats the table of tables as if it
 * were a single table of matrices.  It is an error to call this if any
 * SAnimData children of this node have an improper name (e.g.  not a single
 * letter, or not one of "ijkabchprxyz").
 *
 * This function has the further requirement that all nine of the subtables
 * must exist and be of the same length.  Furthermore, the order string must
 * be the standard order string, which matches the system compose_matrix() and
 * decompose_matrix() functions.
 *
 * Thus, you probably cannot take an existing EggXfmSAnim object and start
 * adding matrices to the end; you must clear out the original data first.
 * (As a special exception, if no tables exist, they will be created.)  The
 * method normalize() will do this for you on an existing EggXfmSAnim.
 *
 * This function may fail silently if the matrix cannot be decomposed into
 * scale, shear, rotate, and translate.  In this case, the closest
 * approximation is added to the table, and false is returned.
 */
49
bool EggXfmSAnim::add_data(LMatrix4d const &mat);

1966 18 add_component_data 0 4 2114 31 EggXfmSAnim::add_component_data 0 2 983 984 174
/**
 * Adds a new row to the named component (one of matrix_component_letters) of
 * the table.
 */

/**
 * Adds a new row to the indicated component (0-12) of the table.
 */
153
void EggXfmSAnim::add_component_data(std::string const &component_name, double value);
void EggXfmSAnim::add_component_data(int component, double value);

1967 18 compose_with_order 0 4 2114 31 EggXfmSAnim::compose_with_order 0 1 985 172
/**
 * Composes a matrix out of the nine individual components, respecting the
 * order string.  The components will be applied in the order indicated by the
 * string.
 */
205
static void EggXfmSAnim::compose_with_order(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, LVecBase3d const &trans, std::string const &order, CoordinateSystem cs);

1968 14 get_class_type 0 4 2114 27 EggXfmSAnim::get_class_type 0 1 986 0
52
static TypeHandle EggXfmSAnim::get_class_type(void);

1969 12 ~EggXfmSAnim 0 4 2114 25 EggXfmSAnim::~EggXfmSAnim 0 0 0
32
EggXfmSAnim::~EggXfmSAnim(void);

1970 14 EggXfmAnimData 0 4 2115 30 EggXfmAnimData::EggXfmAnimData 0 3 987 988 989 108
/**
 *
 */

/**
 *
 */

/**
 * Converts the newer-style XfmSAnim table to the older-style XfmAnim table.
 */
236
inline EggXfmAnimData::EggXfmAnimData(std::string const &name = "", CoordinateSystem cs = ::CS_default);
EggXfmAnimData::EggXfmAnimData(EggXfmSAnim const &convert_from);
inline EggXfmAnimData::EggXfmAnimData(EggXfmAnimData const &copy);

1971 10 operator = 0 4 2115 26 EggXfmAnimData::operator = 0 1 990 10
/**
 *
 */
78
inline EggXfmAnimData &EggXfmAnimData::operator =(EggXfmAnimData const &copy);

1972 9 set_order 0 4 2115 25 EggXfmAnimData::set_order 0 1 991 10
/**
 *
 */
64
inline void EggXfmAnimData::set_order(std::string const &order);

1973 11 clear_order 0 4 2115 27 EggXfmAnimData::clear_order 0 1 992 10
/**
 *
 */
46
inline void EggXfmAnimData::clear_order(void);

1974 9 has_order 0 4 2115 25 EggXfmAnimData::has_order 0 1 993 10
/**
 *
 */
50
inline bool EggXfmAnimData::has_order(void) const;

1975 9 get_order 0 4 2115 25 EggXfmAnimData::get_order 0 1 994 10
/**
 *
 */
64
inline std::string const &EggXfmAnimData::get_order(void) const;

1976 18 get_standard_order 0 4 2115 34 EggXfmAnimData::get_standard_order 0 1 995 178
/**
 * Returns the standard order of matrix component composition.  This is what
 * the order string must be set to in order to use set_value() or add_data()
 * successfully.
 */
74
static inline std::string const &EggXfmAnimData::get_standard_order(void);

1977 12 set_contents 0 4 2115 28 EggXfmAnimData::set_contents 0 1 996 10
/**
 *
 */
70
inline void EggXfmAnimData::set_contents(std::string const &contents);

1978 14 clear_contents 0 4 2115 30 EggXfmAnimData::clear_contents 0 1 997 10
/**
 *
 */
49
inline void EggXfmAnimData::clear_contents(void);

1979 12 has_contents 0 4 2115 28 EggXfmAnimData::has_contents 0 1 998 10
/**
 *
 */
53
inline bool EggXfmAnimData::has_contents(void) const;

1980 12 get_contents 0 4 2115 28 EggXfmAnimData::get_contents 0 1 999 10
/**
 *
 */
67
inline std::string const &EggXfmAnimData::get_contents(void) const;

1981 21 get_coordinate_system 0 4 2115 37 EggXfmAnimData::get_coordinate_system 0 1 1000 292
/**
 * Returns the coordinate system this table believes it is defined within.
 * This should always match the coordinate system of the EggData structure
 * that owns it.  It is necessary to store it here because the meaning of the
 * h, p, and r columns depends on the coordinate system.
 */
74
inline CoordinateSystem EggXfmAnimData::get_coordinate_system(void) const;

1982 12 get_num_rows 0 4 2115 28 EggXfmAnimData::get_num_rows 0 1 1001 51
/**
 * Returns the number of rows in the table.
 */
52
inline int EggXfmAnimData::get_num_rows(void) const;

1983 12 get_num_cols 0 4 2115 28 EggXfmAnimData::get_num_cols 0 1 1002 148
/**
 * Returns the number of columns in the table.  This is set according to the
 * "contents" string, which defines the meaning of each column.
 */
52
inline int EggXfmAnimData::get_num_cols(void) const;

1984 9 get_value 0 4 2115 25 EggXfmAnimData::get_value 0 2 1003 1004 341
/**
 * Returns the value at the indicated row.  Row must be in the range 0 <= row
 * < get_num_rows(); col must be in the range 0 <= col < get_num_cols().
 */

/**
 * Returns the value of the aggregate row of the table as a matrix.  This is a
 * convenience function that treats the 2-d table as if it were a single table
 * of matrices.
 */
127
inline double EggXfmAnimData::get_value(int row, int col) const;
void EggXfmAnimData::get_value(int row, LMatrix4d &mat) const;

1985 14 get_class_type 0 4 2115 30 EggXfmAnimData::get_class_type 0 1 1005 0
55
static TypeHandle EggXfmAnimData::get_class_type(void);

1986 15 ~EggXfmAnimData 0 4 2115 31 EggXfmAnimData::~EggXfmAnimData 0 0 0
38
EggXfmAnimData::~EggXfmAnimData(void);

1005
1 0 0 7 3 2116 0 0 10 /**
 *
 */ 0 
2 0 0 7 3 2116 0 0 10 /**
 *
 */ 1 4 copy 1 2117  
3 0 0 7 4 2116 0 0 10 /**
 *
 */ 2 4 this 3 2116  4 copy 1 2117  
4 0 0 7 5 2120 0 0 0 0 
5 0 0 7 7 2121 0 0 10 /**
 *
 */ 0 
6 0 0 7 7 2121 0 0 10 /**
 *
 */ 1 4 copy 1 2122  
7 0 0 7 8 2121 0 0 10 /**
 *
 */ 2 4 this 3 2121  4 copy 1 2122  
8 0 0 4 9 2124 0 0 766 /**
 * Sets the user data associated with this object.  This may be any
 * EggUserData-derived object.  The egg library will do nothing with this
 * pointer, except to hold its reference count and return the pointer on
 * request.
 *
 * The EggObject maintains multiple different EggUserData pointers, one for
 * each unique type (as reported by get_type()).  If you know that only one
 * type of EggUserData object will be added in your application, you may use
 * the query functions that accept no parameters, but it is recommended that
 * in general you pass in the type of your particular user data, to allow
 * multiple applications to coexist in the same egg data.
 *
 * This pointer is also copied by the copy assignment operator and copy
 * constructor.
 */ 2 4 this 3 2121  9 user_data 1 2116  
9 0 0 7 10 2116 0 0 122 /**
 * Returns the user data pointer most recently stored on this object, or NULL
 * if nothing was previously stored.
 */ 1 4 this 3 2122  
10 0 0 7 10 2116 0 0 104 /**
 * Returns the user data pointer of the indicated type, if it exists, or NULL
 * if it does not.
 */ 2 4 this 3 2122  4 type 1 2120  
11 0 0 6 11 2038 0 0 117 /**
 * Returns true if a generic user data pointer has recently been set and not
 * yet cleared, false otherwise.
 */ 1 4 this 3 2122  
12 0 0 6 11 2038 0 0 104 /**
 * Returns true if the user data pointer of the indicated type has been set,
 * false otherwise.
 */ 2 4 this 3 2122  4 type 1 2120  
13 0 0 4 12 2124 0 0 58 /**
 * Removes *all* user data pointers from the node.
 */ 1 4 this 3 2121  
14 0 0 4 12 2124 0 0 63 /**
 * Removes the user data pointer of the indicated type.
 */ 2 4 this 3 2121  4 type 1 2120  
15 0 0 7 13 2120 0 0 0 0 
16 0 0 7 20 2127 1024 0 10 /**
 *
 */ 1 4 copy 1 2125  
17 0 0 7 20 2127 1024 0 10 /**
 *
 */ 1 4 name 1 2128  
18 0 0 7 21 2127 1024 0 10 /**
 *
 */ 2 4 this 3 2127  4 copy 1 2125  
19 0 0 4 22 2124 0 0 10 /**
 *
 */ 2 4 this 3 2125  3 out 1 2129  
20 0 0 7 23 2120 0 0 0 0 
21 0 0 7 15 2121 0 0 0 1 4 this 3 2127  
22 0 0 7 16 2127 1024 0 0 1 4 this 3 2121  
23 0 0 6 18 2131 0 0 0 1 4 this 3 2127  
24 0 0 7 19 2127 1024 0 0 1 4 this 3 2131  
25 0 0 7 26 2132 1063 0 10 /**
 *
 */ 2 4 this 3 2132  4 copy 1 2133  
26 0 0 7 27 2135 1063 0 10 /**
 *
 */ 1 4 this 3 2133  
27 0 0 6 28 2068 0 0 76 /**
 * Returns the number of nodes above this node in the egg hierarchy.
 */ 1 4 this 3 2133  
28 0 0 6 29 2038 0 0 123 /**
 * Returns true if there is an <Instance> node somewhere in the egg tree at or
 * above this node, false otherwise.
 */ 1 4 this 3 2133  
29 0 0 6 30 2038 0 0 124 /**
 * Returns true if there is a <Transform> entry somewhere in the egg tree at
 * or above this node, false otherwise.
 */ 1 4 this 3 2133  
30 0 0 6 31 2038 0 0 189 /**
 * Returns true if this node's vertices are not in the global coordinate
 * space.  This will be the case if there was an <Instance> node under a
 * transform at or above this node.
 */ 1 4 this 3 2133  
31 0 0 6 32 2136 0 0 711 /**
 * Returns the coordinate frame of the vertices referenced by primitives at or
 * under this node.  This is not the same as get_node_frame().
 *
 * Generally, vertices in an egg file are stored in the global coordinate
 * space, regardless of the transforms defined at each node.  Thus,
 * get_vertex_frame() will usually return the identity transform (global
 * coordinate space).  However, primitives under an <Instance> entry reference
 * their vertices in the coordinate system under effect at the time of the
 * <Instance>.  Thus, nodes under an <Instance> entry may return this non-
 * identity matrix.
 *
 * Specifically, this may return a non-identity matrix only if
 * is_local_coord() is true.
 */ 1 4 this 3 2133  
32 0 0 6 33 2136 0 0 133 /**
 * Returns the coordinate frame of the node itself.  This is simply the net
 * product of all transformations up to the root.
 */ 1 4 this 3 2133  
33 0 0 6 34 2136 0 0 104 /**
 * Returns the inverse of the matrix returned by get_vertex_frame().  See
 * get_vertex_frame().
 */ 1 4 this 3 2133  
34 0 0 6 35 2136 0 0 100 /**
 * Returns the inverse of the matrix returned by get_node_frame().  See
 * get_node_frame().
 */ 1 4 this 3 2133  
35 0 0 6 36 2136 0 0 231 /**
 * Returns the transformation matrix suitable for converting the vertices as
 * read from the egg file into the coordinate space of the node.  This is the
 * same thing as:
 *
 * get_vertex_frame() * get_node_frame_inv()
 *
 */ 1 4 this 3 2133  
36 0 0 6 37 2136 0 0 263 /**
 * Returns the transformation matrix suitable for converting vertices in the
 * coordinate space of the node to the appropriate coordinate space for
 * storing in the egg file.  This is the same thing as:
 *
 * get_node_frame() * get_vertex_frame_inv()
 *
 */ 1 4 this 3 2133  
37 0 0 6 38 2136 0 0 120 /**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_vertex_frame() matrix.
 */ 1 4 this 3 2133  
38 0 0 6 39 2136 0 0 118 /**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_node_frame() matrix.
 */ 1 4 this 3 2133  
39 0 0 6 40 2136 0 0 124 /**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_vertex_frame_inv() matrix.
 */ 1 4 this 3 2133  
40 0 0 6 41 2136 0 0 122 /**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_node_frame_inv() matrix.
 */ 1 4 this 3 2133  
41 0 0 6 42 2136 0 0 122 /**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_vertex_to_node() matrix.
 */ 1 4 this 3 2133  
42 0 0 6 43 2136 0 0 122 /**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_node_to_vertex() matrix.
 */ 1 4 this 3 2133  
43 0 0 4 44 2124 0 0 90 /**
 * Applies the indicated transformation to the node and all of its
 * descendants.
 */ 2 4 this 3 2132  3 mat 1 2136  
44 0 0 4 45 2124 0 0 213 /**
 * Applies the indicated transformation only to vertices that appear in global
 * space within vertex pools at this node and below.  Joints and other
 * transforms are not affected, nor are local vertices.
 */ 2 4 this 3 2132  3 mat 1 2136  
45 0 0 4 46 2124 0 0 382 /**
 * Removes any transform and instance records from this node in the scene
 * graph and below.  If an instance node is encountered, removes the instance
 * and applies the transform to its vertices, duplicating vertices if
 * necessary.
 *
 * Since this function may result in duplicated vertices, it may be a good
 * idea to call remove_unused_vertices() after calling this.
 */ 1 4 this 3 2132  
46 0 0 4 47 2124 0 0 159 /**
 * Applies the texture matrices to the UV's of the vertices that reference
 * them, and then removes the texture matrices from the textures themselves.
 */ 1 4 this 3 2132  
47 0 0 6 48 2068 0 0 45 /**
 * Rename by stripping out the prefix
 */ 2 4 this 3 2132  12 strip_prefix 1 2139  
48 0 0 6 49 2038 0 0 229 /**
 * Returns true if this particular node represents a <Joint> entry or not.
 * This is a handy thing to know since Joints are sorted to the end of their
 * sibling list when writing an egg file.  See EggGroupNode::write().
 */ 1 4 this 3 2133  
49 0 0 6 50 2038 0 0 109 /**
 * Returns true if this node represents a table of animation transformation
 * data, false otherwise.
 */ 1 4 this 3 2133  
50 0 0 6 51 2142 0 0 266 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has an alpha_mode
 * other than AM_unspecified.  Returns a valid EggRenderMode pointer if one is
 * found, or NULL otherwise.
 */ 1 4 this 3 2132  
51 0 0 6 52 2142 0 0 272 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * depth_write_mode other than DWM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2132  
52 0 0 6 53 2142 0 0 271 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * depth_test_mode other than DTM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2132  
53 0 0 6 54 2142 0 0 270 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * visibility_mode other than VM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2132  
54 0 0 6 55 2142 0 0 251 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a depth_offset
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */ 1 4 this 3 2132  
55 0 0 6 56 2142 0 0 249 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a draw_order
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */ 1 4 this 3 2132  
56 0 0 6 57 2142 0 0 238 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a bin specified.
 * Returns a valid EggRenderMode pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2132  
57 0 0 6 58 2038 0 0 321 /**
 * Walks back up the hierarchy, looking for an EggGroup at this level or above
 * that has the "indexed" scalar set.  Returns the value of the indexed scalar
 * if it is found, or false if it is not.
 *
 * In other words, returns true if the "indexed" flag is in effect for the
 * indicated node, false otherwise.
 */ 1 4 this 3 2132  
58 0 0 6 59 2038 0 0 311 /**
 * Walks back up the hierarchy, looking for an EggGroup at this level or above
 * that has the "decal" flag set.  Returns the value of the decal flag if it
 * is found, or false if it is not.
 *
 * In other words, returns true if the "decal" flag is in effect for the
 * indicated node, false otherwise.
 */ 1 4 this 3 2132  
59 0 0 4 60 2124 0 0 0 3 4 this 3 2133  3 out 1 2129  12 indent_level 1 2068  
60 0 0 6 61 2038 0 0 296 /**
 * Parses the egg syntax given in the indicate string as if it had been read
 * from the egg file within this object's definition.  Updates the object
 * accordingly.  Returns true if successful, false if there was some parse
 * error or if the object does not support this functionality.
 */ 2 4 this 3 2132  10 egg_syntax 1 2128  
61 0 0 4 62 2124 0 0 0 1 4 this 3 2133  
62 0 0 7 63 2120 0 0 0 0 
63 0 0 7 66 2143 1074 0 10 /**
 *
 */ 2 4 this 3 2143  4 copy 1 2144  
64 0 0 4 67 2124 0 0 10 /**
 *
 */ 2 4 this 3 2143  4 type 1 2039  
65 0 0 4 68 2124 0 0 10 /**
 *
 */ 1 4 this 3 2143  
66 0 0 6 69 2038 0 0 10 /**
 *
 */ 1 4 this 3 2144  
67 0 0 6 70 2039 0 0 56 /**
 * This is only valid if has_fps() returns true.
 */ 1 4 this 3 2144  
68 0 0 4 71 2124 0 0 50 /**
 * Removes all data and empties the table.
 */ 1 4 this 3 2143  
69 0 0 4 72 2124 0 0 46 /**
 * Adds a single element to the table.
 */ 2 4 this 3 2143  5 value 1 2039  
70 0 0 6 73 2068 0 0 55 /**
 * Returns the number of elements in the table.
 */ 1 4 this 3 2144  
71 0 0 4 74 2124 0 0 79 /**
 * Rounds each element of the table to the nearest multiple of quantum.
 */ 2 4 this 3 2143  7 quantum 1 2039  
72 0 0 7 75 2120 0 0 0 0 
73 0 0 7 78 2148 1086 0 10 /**
 *
 */ 1 4 copy 1 2146  
74 0 0 7 78 2148 1086 0 10 /**
 *
 */ 1 4 name 1 2128  
75 0 0 7 79 2148 1086 0 10 /**
 *
 */ 2 4 this 3 2148  4 copy 1 2146  
76 0 0 4 80 2124 0 0 10 /**
 *
 */ 2 4 this 3 2148  3 fps 1 2039  
77 0 0 4 81 2124 0 0 10 /**
 *
 */ 1 4 this 3 2148  
78 0 0 6 82 2038 0 0 10 /**
 *
 */ 1 4 this 3 2146  
79 0 0 6 83 2039 0 0 56 /**
 * This is only valid if has_fps() returns true.
 */ 1 4 this 3 2146  
80 0 0 4 84 2124 0 0 10 /**
 *
 */ 2 4 this 3 2148  10 num_frames 1 2068  
81 0 0 4 85 2124 0 0 10 /**
 *
 */ 1 4 this 3 2148  
82 0 0 6 86 2038 0 0 10 /**
 *
 */ 1 4 this 3 2146  
83 0 0 6 87 2068 0 0 63 /**
 * This is only valid if has_num_frames() returns true.
 */ 1 4 this 3 2146  
84 0 0 7 88 2120 0 0 0 0 
85 0 0 7 94 2080 1091 0 10 /**
 *
 */ 0 
86 0 0 7 94 2080 1091 0 10 /**
 *
 */ 1 4 copy 1 2149  
87 0 0 6 95 2080 0 0 10 /**
 *
 */ 2 4 this 3 2080  4 copy 1 2149  
88 0 0 6 97 2038 0 0 10 /**
 *
 */ 1 4 this 3 2149  
89 0 0 6 98 2151 0 0 10 /**
 *
 */ 1 4 this 3 2149  
90 0 0 4 99 2124 0 0 10 /**
 *
 */ 2 4 this 3 2080  6 normal 1 2151  
91 0 0 4 100 2124 0 0 10 /**
 *
 */ 1 4 this 3 2080  
92 0 0 6 101 2038 0 0 113 /**
 * Returns true if this normal matches that of the other EggAttributes object,
 * include the morph list.
 */ 2 4 this 3 2149  5 other 1 2149  
93 0 0 4 102 2124 0 0 130 /**
 * Sets this normal to be the same as the other's, include morphs.  If the
 * other has no normal, this clears the normal.
 */ 2 4 this 3 2080  5 other 1 2149  
94 0 0 6 103 2038 0 0 10 /**
 *
 */ 1 4 this 3 2149  
95 0 0 7 104 2155 0 0 107 /**
 * Returns the color set on this particular attribute.  If there is no color
 * set, returns white.
 */ 1 4 this 3 2149  
96 0 0 4 105 2124 0 0 10 /**
 *
 */ 2 4 this 3 2080  5 Color 1 2156  
97 0 0 4 106 2124 0 0 10 /**
 *
 */ 1 4 this 3 2080  
98 0 0 6 107 2038 0 0 112 /**
 * Returns true if this color matches that of the other EggAttributes object,
 * include the morph list.
 */ 2 4 this 3 2149  5 other 1 2149  
99 0 0 4 108 2124 0 0 127 /**
 * Sets this color to be the same as the other's, include morphs.  If the
 * other has no color, this clears the color.
 */ 2 4 this 3 2080  5 other 1 2149  
100 0 0 4 109 2124 0 0 78 /**
 * Writes the attributes to the indicated output stream in Egg format.
 */ 3 4 this 3 2149  3 out 1 2129  12 indent_level 1 2068  
101 0 0 6 110 2038 0 0 149 /**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */ 2 4 this 3 2149  5 other 1 2149  
102 0 0 6 111 2068 0 0 149 /**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */ 2 4 this 3 2149  5 other 1 2149  
103 0 0 4 112 2124 0 0 73 /**
 * Applies the indicated transformation matrix to the attributes.
 */ 2 4 this 3 2080  3 mat 1 2136  
104 0 0 7 121 2120 0 0 0 0 
105 0 0 6 92 2157 0 0 0 1 4 this 3 2080  
106 0 0 6 93 2080 0 0 0 1 4 this 3 2157  
107 0 0 7 115 2158 0 0 0 1 4 this 3 2149  
108 0 0 7 119 2159 0 0 0 1 4 this 3 2149  
109 0 0 7 123 2162 1024 0 10 /**
 *
 */ 1 4 copy 1 2160  
110 0 0 7 123 2162 1024 0 10 /**
 *
 */ 2 4 name 1 2128  3 uvw 1 2163  
111 0 0 7 123 2162 1024 0 10 /**
 *
 */ 2 4 name 1 2128  2 uv 1 2166  
112 0 0 7 124 2162 1024 0 10 /**
 *
 */ 2 4 this 3 2162  4 copy 1 2160  
113 0 0 6 125 2128 0 0 227 /**
 * Returns the actual name that should be set for a given name string.
 * Usually this is the same string that is input, but for historical reasons
 * the texture coordinate name "default" is mapped to the empty string.
 */ 1 4 name 1 2128  
114 0 0 4 126 2124 0 0 10 /**
 *
 */ 2 4 this 3 2162  4 name 1 2128  
115 0 0 6 127 2068 0 0 150 /**
 * Returns the number of components of the texture coordinate set.  This is
 * either 2 (the normal case) or 3 (for a 3-d texture coordinate).
 */ 1 4 this 3 2160  
116 0 0 6 128 2038 0 0 131 /**
 * Returns true if the texture coordinate has a third, w component, false if
 * it is just a normal 2-d texture coordinate.
 */ 1 4 this 3 2160  
117 0 0 7 129 2170 0 0 77 /**
 * Returns the texture coordinate pair, if get_num_dimensions() is 2.
 */ 1 4 this 3 2160  
118 0 0 6 130 2163 0 0 181 /**
 * Returns the texture coordinate triple, if get_num_dimensions() is 3.  This
 * is also legal to call if get_num_dimensions() is 2 (but the last dimension
 * will be zero).
 */ 1 4 this 3 2160  
119 0 0 4 131 2124 0 0 133 /**
 * Sets the texture coordinate pair.  This makes the texture coordinate a 2-d
 * texture coordinate, which is the usual case.
 */ 2 4 this 3 2162  8 texCoord 1 2166  
120 0 0 4 132 2124 0 0 110 /**
 * Sets the texture coordinate triple.  This makes the texture coordinate a
 * 3-d texture coordinate.
 */ 2 4 this 3 2162  8 texCoord 1 2163  
121 0 0 6 133 2038 0 0 10 /**
 *
 */ 1 4 this 3 2160  
122 0 0 6 134 2151 0 0 10 /**
 *
 */ 1 4 this 3 2160  
123 0 0 4 135 2124 0 0 10 /**
 *
 */ 2 4 this 3 2162  7 tangent 1 2151  
124 0 0 4 136 2124 0 0 10 /**
 *
 */ 1 4 this 3 2162  
125 0 0 6 137 2038 0 0 10 /**
 *
 */ 1 4 this 3 2160  
126 0 0 6 138 2151 0 0 10 /**
 *
 */ 1 4 this 3 2160  
127 0 0 4 139 2124 0 0 10 /**
 *
 */ 2 4 this 3 2162  8 binormal 1 2151  
128 0 0 4 140 2124 0 0 10 /**
 *
 */ 1 4 this 3 2162  
129 0 0 7 141 2162 1024 0 149 /**
 * Creates a new EggVertexUV that contains the averaged values of the two
 * given objects.  It is an error if they don't have the same name.
 */ 2 5 first 1 2160  6 second 1 2160  
130 0 0 4 142 2124 0 0 149 /**
 * Applies the indicated transformation matrix to the UV's tangent and/or
 * binormal.  This does nothing if there is no tangent or binormal.
 */ 2 4 this 3 2162  3 mat 1 2136  
131 0 0 4 143 2124 0 0 10 /**
 *
 */ 3 4 this 3 2160  3 out 1 2129  12 indent_level 1 2068  
132 0 0 6 144 2068 0 0 149 /**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */ 2 4 this 3 2160  5 other 1 2160  
133 0 0 7 149 2120 0 0 0 0 
134 0 0 7 147 2171 0 0 0 1 4 this 3 2160  
135 0 0 7 151 2174 1024 0 10 /**
 *
 */ 1 4 copy 1 2172  
136 0 0 7 151 2174 1024 0 10 /**
 *
 */ 2 4 name 1 2128  3 aux 1 2175  
137 0 0 7 152 2174 1024 0 10 /**
 *
 */ 2 4 this 3 2174  4 copy 1 2172  
138 0 0 4 153 2124 0 0 10 /**
 *
 */ 2 4 this 3 2174  4 name 1 2128  
139 0 0 6 154 2175 0 0 48 /**
 * Returns the auxiliary data quadruple.
 */ 1 4 this 3 2172  
140 0 0 4 155 2124 0 0 45 /**
 * Sets the auxiliary data quadruple.
 */ 2 4 this 3 2174  3 aux 1 2175  
141 0 0 7 156 2174 1024 0 150 /**
 * Creates a new EggVertexAux that contains the averaged values of the two
 * given objects.  It is an error if they don't have the same name.
 */ 2 5 first 1 2172  6 second 1 2172  
142 0 0 4 157 2124 0 0 10 /**
 *
 */ 3 4 this 3 2172  3 out 1 2129  12 indent_level 1 2068  
143 0 0 6 158 2068 0 0 149 /**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */ 2 4 this 3 2172  5 other 1 2172  
144 0 0 7 159 2120 0 0 0 0 
145 0 0 7 165 2077 1150 0 10 /**
 *
 */ 0 
146 0 0 7 165 2077 1150 0 109 /**
 * Copies all properties of the vertex except its vertex pool, index number,
 * and group membership.
 */ 1 4 copy 1 2178  
147 0 0 7 166 2077 1150 0 109 /**
 * Copies all properties of the vertex except its vertex pool, index number,
 * and group membership.
 */ 2 4 this 3 2077  4 copy 1 2178  
148 0 0 7 168 2078 1063 0 123 /**
 * Returns the vertex pool this vertex belongs in.  This may be NULL if the
 * vertex has not been added to a pool.
 */ 1 4 this 3 2178  
149 0 0 6 169 2038 0 0 386 /**
 * Returns true if the vertex is a forward reference to some vertex that
 * hasn't been defined yet.  In this case, the vertex may not have any
 * properties filled in yet.
 *
 * This can only happen if you implicitly create a vertex via
 * EggVertexPool::get_forward_vertex(). Presumably, when the vertex pool is
 * later filled in, this vertex will be replaced with real data.
 */ 1 4 this 3 2178  
150 0 0 4 170 2124 0 0 98 /**
 * Sets the vertex position.  This variant sets the vertex to a two-
 * dimensional value.
 */ 2 4 this 3 2077  3 pos 1 2180  
151 0 0 4 170 2124 0 0 100 /**
 * Sets the vertex position.  This variant sets the vertex to a three-
 * dimensional value.
 */ 2 4 this 3 2077  3 pos 1 2182  
152 0 0 4 170 2124 0 0 99 /**
 * Sets the vertex position.  This variant sets the vertex to a four-
 * dimensional value.
 */ 2 4 this 3 2077  3 pos 1 2183  
153 0 0 4 170 2124 0 0 98 /**
 * Sets the vertex position.  This variant sets the vertex to a one-
 * dimensional value.
 */ 2 4 this 3 2077  3 pos 1 2039  
154 0 0 4 171 2124 0 0 319 /**
 * This special flavor of set_pos() sets the vertex as a four-component value,
 * but does not change the set number of dimensions.  It's handy for
 * retrieving the vertex position via get_pos4, manipulating it, then storing
 * it back again, without worrying about the number of dimensions it actually
 * had.
 */ 2 4 this 3 2077  3 pos 1 2183  
155 0 0 6 172 2068 0 0 368 // get_pos[123] return the pos as the corresponding type.  It is an error to
// call any of these without first verifying that get_num_dimensions()
// matches the desired type.  However, get_pos4() may always be called; it
// returns the pos as a four-component point in homogeneous space (with a
// 1.0 in the last position if the pos has fewer than four components). 1 4 this 3 2178  
156 0 0 6 173 2039 0 0 108 /**
 * Only valid if get_num_dimensions() returns 1. Returns the position as a
 * one-dimensional value.
 */ 1 4 this 3 2178  
157 0 0 7 174 2186 0 0 108 /**
 * Only valid if get_num_dimensions() returns 2. Returns the position as a
 * two-dimensional value.
 */ 1 4 this 3 2178  
158 0 0 7 175 2188 0 0 110 /**
 * Valid if get_num_dimensions() returns 3 or 4. Returns the position as a
 * three-dimensional value.
 */ 1 4 this 3 2178  
159 0 0 7 176 2189 0 0 309 /**
 * This is always valid, regardless of the value of get_num_dimensions.  It
 * returns the position as a four-dimensional value.  If the pos has fewer
 * than four dimensions, this value represents the pos extended into four-
 * dimensional homogenous space, e.g.  by adding 1 as the fourth component.
 */ 1 4 this 3 2178  
160 0 0 6 177 2038 0 0 272 /**
 * Returns true if the vertex has an unnamed UV coordinate pair, false
 * otherwise.
 *
 * This is the more restrictive interface, and is generally useful only in the
 * absence of multitexturing; see has_uv(name) for the interface that supports
 * multitexturing.
 */ 1 4 this 3 2178  
161 0 0 6 177 2038 0 0 132 /**
 * Returns true if the vertex has the named UV coordinate pair, and the named
 * UV coordinate pair is 2-d, false otherwise.
 */ 2 4 this 3 2178  4 name 1 2128  
162 0 0 7 178 2170 0 0 308 /**
 * Returns the unnamed UV coordinate pair on the vertex.  It is an error to
 * call this if has_uv() has returned false.
 *
 * This is the more restrictive interface, and is generally useful only in the
 * absence of multitexturing; see get_uv(name) for the interface that supports
 * multitexturing.
 */ 1 4 this 3 2178  
163 0 0 7 178 2170 0 0 126 /**
 * Returns the named UV coordinate pair on the vertex.  It is an error to call
 * this if has_uv(name) returned false.
 */ 2 4 this 3 2178  4 name 1 2128  
164 0 0 4 179 2124 0 0 277 /**
 * Replaces the unnamed UV coordinate pair on the vertex with the indicated
 * value.
 *
 * This is the more restrictive interface, and is generally useful only in the
 * absence of multitexturing; see set_uv(name, uv) for the interface that
 * supports multitexturing.
 */ 2 4 this 3 2077  8 texCoord 1 2166  
165 0 0 4 179 2124 0 0 174 /**
 * Sets the indicated UV coordinate pair on the vertex.  This replaces any UV
 * coordinate pair with the same name already on the vertex, but preserves UV
 * morphs.
 */ 3 4 this 3 2077  4 name 1 2128  8 texCoord 1 2166  
166 0 0 4 180 2124 0 0 59 /**
 * Removes all UV coordinate pairs from the vertex.
 */ 1 4 this 3 2077  
167 0 0 4 180 2124 0 0 93 /**
 * Removes the named UV coordinate pair from the vertex, along with any UV
 * morphs.
 */ 2 4 this 3 2077  4 name 1 2128  
168 0 0 6 181 2038 0 0 136 /**
 * Returns true if the vertex has the named UV coordinate triple, and the
 * named UV coordinate triple is 3-d, false otherwise.
 */ 2 4 this 3 2178  4 name 1 2128  
169 0 0 6 182 2163 0 0 129 /**
 * Returns the named UV coordinate triple on the vertex.  It is an error to
 * call this if has_uvw(name) returned false.
 */ 2 4 this 3 2178  4 name 1 2128  
170 0 0 4 183 2124 0 0 186 /**
 * Sets the indicated UV coordinate triple on the vertex.  This replaces any
 * UV coordinate pair or triple with the same name already on the vertex, but
 * preserves UV morphs.
 */ 3 4 this 3 2077  4 name 1 2128  8 texCoord 1 2163  
171 0 0 7 184 2160 0 0 298 /**
 * Returns the named EggVertexUV object, which defines both the UV coordinate
 * pair for this name and the UV morphs.  This object might be shared between
 * multiple vertices.  You should not attempt to modify this object; instead,
 * call modify_uv_object to return a modifiable pointer.
 */ 2 4 this 3 2178  4 name 1 2128  
172 0 0 7 185 2162 1024 0 204 /**
 * Returns a modifiable pointer to the named EggVertexUV object, which defines
 * both the UV coordinate pair for this name and the UV morphs.  Returns NULL
 * if there is no such named UV object.
 */ 2 4 this 3 2077  4 name 1 2128  
173 0 0 4 186 2124 0 0 163 /**
 * Sets the indicated EggVertexUV on the vertex.  This replaces any UV
 * coordinate pair with the same name already on the vertex, including UV
 * morphs.
 */ 2 4 this 3 2077  9 vertex_uv 1 2162  
174 0 0 6 187 2038 0 0 78 /**
 * Returns true if the vertex has any auxiliary data, false otherwise.
 */ 1 4 this 3 2178  
175 0 0 6 187 2038 0 0 77 /**
 * Returns true if the vertex has the named auxiliary data quadruple.
 */ 2 4 this 3 2178  4 name 1 2128  
176 0 0 4 188 2124 0 0 54 /**
 * Removes all auxiliary data from the vertex.
 */ 1 4 this 3 2077  
177 0 0 4 188 2124 0 0 60 /**
 * Removes the named auxiliary data from the vertex.
 */ 2 4 this 3 2077  4 name 1 2128  
178 0 0 6 189 2175 0 0 133 /**
 * Returns the named auxiliary data quadruple on the vertex.  It is an error
 * to call this if has_aux(name) returned false.
 */ 2 4 this 3 2178  4 name 1 2128  
179 0 0 4 190 2124 0 0 148 /**
 * Sets the indicated auxiliary data quadruple on the vertex.  This replaces
 * any auxiliary data with the same name already on the vertex.
 */ 3 4 this 3 2077  4 name 1 2128  3 aux 1 2175  
180 0 0 7 191 2172 0 0 273 /**
 * Returns the named EggVertexAux object, which defines the auxiliary data for
 * this name.  This object might be shared between multiple vertices.  You
 * should not attempt to modify this object; instead, call modify_aux_object
 * to return a modifiable pointer.
 */ 2 4 this 3 2178  4 name 1 2128  
181 0 0 7 192 2174 1024 0 178 /**
 * Returns a modifiable pointer to the named EggVertexAux object, which
 * defines the auxiliary data for this name.  Returns NULL if there is no such
 * named UV object.
 */ 2 4 this 3 2077  4 name 1 2128  
182 0 0 4 193 2124 0 0 136 /**
 * Sets the indicated EggVertexAux on the vertex.  This replaces any auxiliary
 * data with the same name already on the vertex.
 */ 2 4 this 3 2077  10 vertex_aux 1 2174  
183 0 0 7 194 2077 1150 0 284 /**
 * Creates a new vertex that lies in between the two given vertices.  The
 * attributes for the UV sets they have in common are averaged.
 *
 * Both vertices need to be either in no pool, or in the same pool.  In the
 * latter case, the new vertex will be placed in that pool.
 */ 2 5 first 1 2178  6 second 1 2178  
184 0 0 6 195 2068 0 0 66 /**
 * Returns the index number of the vertex within its pool.
 */ 1 4 this 3 2178  
185 0 0 4 196 2124 0 0 486 /**
 * Sets a special index number that is associated with the EggVertex (but is
 * not written to the egg file). This number is not interpreted by any egg
 * code; it is simply maintained along with the vertex.  It *is* used to
 * differentiate otherwise identical vertices in
 * EggVertexPool::create_unique_vertex(), however.
 *
 * The intention of this number is as an aid for file converters, to associate
 * an EggVertex back to the index number of the original source vertex.
 */ 2 4 this 3 2077  14 external_index 1 2068  
186 0 0 6 197 2068 0 0 85 /**
 * Returns the number set by set_external_index().  See set_external_index().
 */ 1 4 this 3 2178  
187 0 0 4 198 2124 0 0 225 /**
 * Similar to set_external_index(), but this is a different number which may
 * be used for a different purpose by the calling code.  The egg library does
 * not assign any meaning to this number or use it in any way.
 */ 2 4 this 3 2077  15 external_index2 1 2068  
188 0 0 6 199 2068 0 0 90 /**
 * Returns the number set by set_external_index2().  See
 * set_external_index2().
 */ 1 4 this 3 2178  
189 0 0 4 200 2124 0 0 74 /**
 * Writes the vertex to the indicated output stream in Egg format.
 */ 3 4 this 3 2178  3 out 1 2129  12 indent_level 1 2068  
190 0 0 6 201 2038 0 0 149 /**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */ 2 4 this 3 2178  5 other 1 2178  
191 0 0 6 202 2068 0 0 746 /**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 *
 * Group membership is not considered in this comparison.  This is somewhat
 * problematic, but cannot easily be helped, because considering group
 * membership would make it difficult to add and remove groups from vertices.
 * It also makes it impossible to meaningfully compare with a concrete
 * EggVertex object (which cannot have group memberships).
 *
 * However, this is not altogether bad, because two vertices that are
 * identical in all other properties should generally also be identical in
 * group memberships, else the vertices will tend to fly apart when the joints
 * animate.
 */ 2 4 this 3 2178  5 other 1 2178  
192 0 0 6 203 2068 0 0 134 /**
 * Returns the number of primitives that own this vertex whose vertices are
 * interpreted to be in a local coordinate system.
 */ 1 4 this 3 2178  
193 0 0 6 204 2068 0 0 131 /**
 * Returns the number of primitives that own this vertex whose vertices are
 * interpreted in the global coordinate system.
 */ 1 4 this 3 2178  
194 0 0 4 205 2124 0 0 69 /**
 * Applies the indicated transformation matrix to the vertex.
 */ 2 4 this 3 2077  3 mat 1 2136  
195 0 0 6 206 2038 0 0 90 /**
 * Returns true if the indicated group references this vertex, false
 * otherwise.
 */ 2 4 this 3 2178  5 group 1 2190  
196 0 0 4 207 2124 0 0 406 /**
 * Copies all the group references from the other vertex onto this one.  This
 * assigns the current vertex to exactly the same groups, with exactly the
 * same memberships, as the given one.
 *
 * Warning: only an EggVertex allocated from the free store may have groups
 * assigned to it.  Do not attempt to call this on a temporary concrete
 * EggVertex object; a core dump will certainly result.
 */ 2 4 this 3 2077  5 other 1 2178  
197 0 0 4 208 2124 0 0 100 /**
 * Removes all group references from the vertex, so that it is not assigned to
 * any group.
 */ 1 4 this 3 2077  
198 0 0 6 209 2068 0 0 116 /**
 * Returns the number of times the vertex appears in the indicated primitive,
 * or 0 if it does not appear.
 */ 2 4 this 3 2178  4 prim 1 2192  
199 0 0 4 210 2124 0 0 0 1 4 this 3 2178  
200 0 0 4 211 2124 0 0 0 1 4 this 3 2178  
201 0 0 4 212 2124 0 0 10 /**
 *
 */ 2 4 this 3 2178  3 out 1 2129  
202 0 0 7 217 2120 0 0 0 0 
203 0 0 7 161 2121 0 0 0 1 4 this 3 2077  
204 0 0 7 162 2077 1150 0 0 1 4 this 3 2121  
205 0 0 6 163 2080 0 0 0 1 4 this 3 2077  
206 0 0 7 164 2077 1150 0 0 1 4 this 3 2080  
207 0 0 7 215 2194 0 0 0 1 4 this 3 2178  
208 0 0 7 219 2078 1063 0 198 /**
 * Copying a vertex pool is of questionable value, since it will copy all of
 * the vertices and assign new pointers to them all.  There will be no
 * polygons referring to the new vertices.
 */ 1 4 copy 1 2195  
209 0 0 7 219 2078 1063 0 10 /**
 *
 */ 1 4 name 1 2128  
210 0 0 6 220 2038 0 0 147 /**
 * Returns true if the indicated vertex has been defined in the vertex pool,
 * false otherwise.  This does not include forward references.
 */ 2 4 this 3 2195  5 index 1 2068  
211 0 0 6 221 2038 0 0 131 /**
 * Returns true if any vertices in the pool are undefined forward-reference
 * vertices, false if all vertices are defined.
 */ 1 4 this 3 2195  
212 0 0 6 222 2038 0 0 128 /**
 * Returns true if any vertices in the pool are fully defined vertices, false
 * if all vertices are forward references.
 */ 1 4 this 3 2195  
213 0 0 7 223 2077 1150 0 124 /**
 * Returns the vertex in the pool with the indicated index number, or NULL if
 * no vertices have that index number.
 */ 2 4 this 3 2195  5 index 1 2068  
214 0 0 7 224 2077 1150 0 124 /**
 * Returns the vertex in the pool with the indicated index number, or NULL if
 * no vertices have that index number.
 */ 2 4 this 3 2195  5 index 1 2068  
215 0 0 7 225 2077 1150 0 327 /**
 * Returns the vertex in the pool with the indicated index number.  If there
 * is not a vertex in the pool with the indicated index number, creates a
 * special forward-reference EggVertex that has no data, on the assumption
 * that the vertex pool has not yet been fully read and more data will be
 * available later.
 */ 2 4 this 3 2078  5 index 1 2068  
216 0 0 6 226 2068 0 0 140 /**
 * Returns the highest index number used by any vertex in the pool (except
 * forward references).  Returns -1 if the pool is empty.
 */ 1 4 this 3 2195  
217 0 0 4 227 2124 0 0 276 /**
 * Artificially changes the "highest index number", so that a newly created
 * vertex will begin at this number plus 1.  This can be used to default a
 * vertex pool to start counting at 1 (or any other index number), instead of
 * the default of 0.  Use with caution.
 */ 2 4 this 3 2078  13 highest_index 1 2068  
218 0 0 6 228 2068 0 0 83 /**
 * Returns the maximum number of dimensions used by any vertex in the pool.
 */ 1 4 this 3 2195  
219 0 0 6 229 2038 0 0 100 /**
 * Returns true if any vertex in the pool has a normal defined, false if none
 * of them do.
 */ 1 4 this 3 2195  
220 0 0 6 230 2038 0 0 99 /**
 * Returns true if any vertex in the pool has a color defined, false if none
 * of them do.
 */ 1 4 this 3 2195  
221 0 0 6 231 2038 0 0 152 /**
 * Returns true if any vertex in the pool has a color defined other than
 * white, false if no vertices have colors, or if all colors are white.
 */ 1 4 this 3 2195  
222 0 0 6 233 2038 0 0 96 /**
 * Returns true if any vertex in the pool has a uv defined, false if none of
 * them do.
 */ 1 4 this 3 2195  
223 0 0 6 234 2038 0 0 106 /**
 * Returns true if any vertex in the pool has auxiliary data defined, false if
 * none of them do.
 */ 1 4 this 3 2195  
224 0 0 4 235 2124 0 0 351 /**
 * Returns the list of UV names that are defined by any vertices in the pool,
 * as well as the subset of UV names that actually define 3-d texture
 * coordinates ("uvw_names").  Also returns the subset of UV/UVW names that
 * define a tangent and binormal.  It is the user's responsibility to clear
 * both vectors before calling this method.
 */ 4 4 this 3 2195  8 uv_names 1 2139  9 uvw_names 1 2139  9 tbn_names 1 2139  
225 0 0 4 236 2124 0 0 100 /**
 * Returns the list of auxiliary data names that are defined by any vertices
 * in the pool.
 */ 2 4 this 3 2195  9 aux_names 1 2139  
226 0 0 6 237 2197 0 0 54 /**
 * Returns the number of vertices in the pool.
 */ 1 4 this 3 2195  
227 0 0 7 238 2077 1150 0 809 /**
 * Adds the indicated vertex to the pool.  It is an error if the vertex is
 * already a member of this or any other pool.  The vertex must have been
 * allocated from the free store; its pointer will now be owned by the vertex
 * pool.  If the index number is supplied, tries to assign that index number;
 * it is an error if the index number is already in use.
 *
 * It is possible that a forward reference to this vertex was requested in the
 * past; if so, the data from the supplied vertex is copied onto the forward
 * reference, which becomes the actual vertex.  In this case, a different
 * pointer is saved (and returned) than the one actually passed in.  In the
 * usual case, however, the vertex pointer passed in is the one that is saved
 * in the vertex pool and returned from this method.
 */ 3 4 this 3 2078  6 vertex 1 2077  5 index 1 2068  
228 0 0 7 239 2077 1150 0 128 /**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 */ 1 4 this 3 2078  
229 0 0 7 239 2077 1150 0 266 /**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 *
 * This flavor of make_new_vertex() explicitly sets the vertex position as it
 * is allocated.  It does not attempt to share vertices.
 */ 2 4 this 3 2078  3 pos 1 2180  
230 0 0 7 239 2077 1150 0 266 /**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 *
 * This flavor of make_new_vertex() explicitly sets the vertex position as it
 * is allocated.  It does not attempt to share vertices.
 */ 2 4 this 3 2078  3 pos 1 2182  
231 0 0 7 239 2077 1150 0 266 /**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 *
 * This flavor of make_new_vertex() explicitly sets the vertex position as it
 * is allocated.  It does not attempt to share vertices.
 */ 2 4 this 3 2078  3 pos 1 2183  
232 0 0 7 239 2077 1150 0 266 /**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 *
 * This flavor of make_new_vertex() explicitly sets the vertex position as it
 * is allocated.  It does not attempt to share vertices.
 */ 2 4 this 3 2078  3 pos 1 2039  
233 0 0 7 240 2077 1150 0 192 /**
 * Creates a new vertex in the pool that is a copy of the indicated one and
 * returns it.  If there is already a vertex in the pool like the indicated
 * one, simply returns that one.
 */ 2 4 this 3 2078  4 copy 1 2178  
234 0 0 7 241 2077 1150 0 212 /**
 * If the EggVertexPool already has a vertex matching the indicated vertex,
 * returns it; otherwise, returns NULL.  This is similar to
 * create_unique_vertex() except that a new vertex is never created.
 */ 2 4 this 3 2078  4 copy 1 2178  
235 0 0 4 242 2124 0 0 114 /**
 * Removes the vertex from the pool.  It is an error if the vertex is not
 * already a member of the pool.
 */ 2 4 this 3 2078  6 vertex 1 2077  
236 0 0 6 243 2068 0 0 292 /**
 * Removes all vertices from the pool that are not referenced by at least one
 * primitive.  Also collapses together equivalent vertices, and renumbers all
 * vertices after the operation so their indices are consecutive, beginning at
 * zero.  Returns the number of vertices removed.
 */ 1 4 this 3 2078  
237 0 0 4 244 2124 0 0 113 /**
 * Adds all of the unused vertices in this vertex pool to the indicated
 * primitive, in ascending order.
 */ 2 4 this 3 2078  4 prim 1 2199  
238 0 0 4 245 2124 0 0 419 /**
 * Applies the indicated transformation matrix to all the vertices.  However,
 * vertices that are attached to primitives that believe their vertices are in
 * a local coordinate system are transformed only by the scale and rotation
 * component.  If a vertex happens to be attached both to a local and a global
 * primitive, and the transformation includes a translation component, the
 * vertex will be split.
 */ 2 4 this 3 2078  3 mat 1 2136  
239 0 0 4 246 2124 0 0 186 /**
 * Re-orders (and re-numbers) the vertices in this vertex pool so that they
 * appear in increasing order by the optional external_index that has been
 * assigned to each vertex.
 */ 1 4 this 3 2078  
240 0 0 7 247 2120 0 0 0 0 
241 0 0 7 249 2135 1063 0 10 /**
 *
 */ 1 4 copy 1 2200  
242 0 0 7 249 2135 1063 0 0 1 4 name 1 2128  
243 0 0 7 250 2135 1063 0 10 /**
 *
 */ 2 4 this 3 2135  4 copy 1 2200  
244 0 0 6 251 2038 0 0 10 /**
 *
 */ 1 4 this 3 2200  
245 0 0 6 252 2202 0 0 10 /**
 *
 */ 1 4 this 3 2200  
246 0 0 4 253 2124 0 0 10 /**
 *
 */ 1 4 this 3 2135  
247 0 0 7 254 2132 1063 0 358 /**
 * Returns the first child in the group's list of children, or NULL if the
 * list of children is empty.  Can be used with get_next_child() to return the
 * complete list of children without using the iterator class; however, this
 * is non-thread-safe, and so is not recommended except for languages other
 * than C++ which cannot use the iterators.
 */ 1 4 this 3 2135  
248 0 0 7 255 2132 1063 0 506 /**
 * Returns the next child in the group's list of children since the last call
 * to get_first_child() or get_next_child(), or NULL if the last child has
 * been returned.  Can be used with get_first_child() to return the complete
 * list of children without using the iterator class; however, this is non-
 * thread-safe, and so is not recommended except for languages other than C++
 * which cannot use the iterators.
 *
 * It is an error to call this without previously calling get_first_child().
 */ 1 4 this 3 2135  
249 0 0 6 256 2203 0 0 0 1 4 this 3 2200  
250 0 0 7 257 2132 1063 0 143 /**
 * Adds the indicated child to the group and returns it.  If the child node is
 * already a child of some other node, removes it first.
 */ 2 4 this 3 2135  4 node 1 2132  
251 0 0 7 258 2132 1063 0 152 /**
 * Removes the indicated child node from the group and returns it.  If the
 * child was not already in the group, does nothing and returns NULL.
 */ 2 4 this 3 2135  4 node 1 2132  
252 0 0 4 259 2124 0 0 171 /**
 * Moves all the children from the other node to this one.  This is especially
 * useful because the group node copy assignment operator does not copy
 * children.
 */ 2 4 this 3 2135  5 other 1 2135  
253 0 0 7 260 2132 1063 0 169 /**
 * Returns the child of this node whose name is the indicated string, or NULL
 * if there is no child of this node by that name.  Does not search
 * recursively.
 */ 2 4 this 3 2200  4 name 1 2128  
254 0 0 6 261 2038 0 0 160 /**
 * Returns true if any nodes at this level and below include a reference to a
 * file via an absolute pathname, or false if all references are relative.
 */ 1 4 this 3 2200  
255 0 0 4 262 2124 0 0 207 /**
 * Walks the tree and attempts to resolve any filenames encountered.  This
 * looks up filenames along the specified search path; it does not
 * automatically search the model_path for missing files.
 */ 2 4 this 3 2135  10 searchpath 1 2206  
256 0 0 4 263 2124 0 0 190 /**
 * Similar to resolve_filenames, but each non-absolute filename encountered is
 * arbitrarily taken to be in the indicated directory, whether or not the so-
 * named filename exists.
 */ 2 4 this 3 2135  9 directory 1 2209  
257 0 0 4 264 2124 0 0 136 /**
 * Reverses the vertex ordering of all polygons defined at this node and
 * below.  Does not change the surface normals, if any.
 */ 1 4 this 3 2135  
258 0 0 4 265 2124 0 0 711 /**
 * Recomputes all the vertex normals for polygon geometry at this group node
 * and below so that they accurately reflect the vertex positions.  A shared
 * edge between two polygons (even in different groups) is considered smooth
 * if the angle between the two edges is less than threshold degrees.
 *
 * This function also removes degenerate polygons that do not have enough
 * vertices to define a normal.  It does not affect normals for other kinds of
 * primitives like Nurbs or Points.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the correct normals.  Thus, it is a good idea
 * to call remove_unused_vertices() after calling this.
 */ 3 4 this 3 2135  9 threshold 1 2039  2 cs 1 2210  
259 0 0 4 266 2124 0 0 672 /**
 * Recomputes all the polygon normals for polygon geometry at this group node
 * and below so that they accurately reflect the vertex positions.  Normals
 * are removed from the vertices and defined only on polygons, giving the
 * geometry a faceted appearance.
 *
 * This function also removes degenerate polygons that do not have enough
 * vertices to define a normal.  It does not affect normals for other kinds of
 * primitives like Nurbs or Points.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the normals removed.  Thus, it is a good idea
 * to call remove_unused_vertices() after calling this.
 */ 2 4 this 3 2135  2 cs 1 2210  
260 0 0 4 267 2124 0 0 317 /**
 * Removes all normals from primitives, and the vertices they reference, at
 * this node and below.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the normal removed.  Thus, it is a good idea to
 * call remove_unused_vertices() after calling this.
 */ 1 4 this 3 2135  
261 0 0 6 268 2038 0 0 767 /**
 * This function recomputes the tangent and binormal for the named texture
 * coordinate set for all vertices at this level and below.  Use the empty
 * string for the default texture coordinate set.
 *
 * It is necessary for each vertex to already have a normal (or at least a
 * polygon normal), as well as a texture coordinate in the named texture
 * coordinate set, before calling this function.  You might precede this with
 * recompute_vertex_normals() to ensure that the normals exist.
 *
 * Like recompute_vertex_normals(), this function does not remove or adjust
 * vertices in the vertex pool; it only adds new vertices with the new
 * tangents and binormals computed.  Thus, it is a good idea to call
 * remove_unused_vertices() after calling this.
 */ 2 4 this 3 2135  7 uv_name 1 2211  
262 0 0 6 268 2038 0 0 138 /**
 * This function recomputes the tangent and binormal for the named texture
 * coordinate sets.  Returns true if anything was done.
 */ 2 4 this 3 2135  5 names 1 2214  
263 0 0 6 269 2038 0 0 160 /**
 * This function recomputes the tangent and binormal for any texture
 * coordinate set that affects a normal map.  Returns true if anything was
 * done.
 */ 1 4 this 3 2135  
264 0 0 6 271 2068 0 0 428 /**
 * Replace all higher-order polygons at this point in the scene graph and
 * below with triangles.  Returns the total number of new triangles produced,
 * less degenerate polygons removed.
 *
 * If flags contains T_polygon and T_convex, both concave and convex polygons
 * will be subdivided into triangles; with only T_polygon, only concave
 * polygons will be subdivided, and convex polygons will be largely unchanged.
 */ 2 4 this 3 2135  5 flags 1 2068  
265 0 0 4 272 2124 0 0 84 /**
 * Combine triangles together into triangle strips, at this group and below.
 */ 2 4 this 3 2135  5 flags 1 2068  
266 0 0 4 273 2124 0 0 127 /**
 * Creates PointLight primitives to reference any otherwise unreferences
 * vertices discovered in this group or below.
 */ 1 4 this 3 2135  
267 0 0 6 274 2068 0 0 45 /**
 * Rename by stripping out the prefix
 */ 3 4 this 3 2135  12 strip_prefix 1 2139  7 recurse 1 2038  
268 0 0 6 275 2068 0 0 692 /**
 * Removes all vertices from VertexPools within this group or below that are
 * not referenced by at least one primitive.  Also collapses together
 * equivalent vertices, and renumbers all vertices after the operation so
 * their indices are consecutive, beginning at zero.  Returns the total number
 * of vertices removed.
 *
 * Note that this operates on the VertexPools within this group level, without
 * respect to primitives that reference these vertices (unlike other functions
 * like strip_normals()).  It is therefore most useful to call this on the
 * EggData root, rather than on a subgroup within the hierarchy, since a
 * VertexPool may appear anywhere in the hierarchy.
 */ 2 4 this 3 2135  7 recurse 1 2038  
269 0 0 6 276 2068 0 0 181 /**
 * Removes primitives at this level and below which appear to be degenerate;
 * e.g.  polygons with fewer than 3 vertices, etc.  Returns the number of
 * primitives removed.
 */ 2 4 this 3 2135  7 recurse 1 2038  
270 0 0 4 277 2124 0 0 319 /**
 * Resets the connected_shading information on all primitives at this node and
 * below, so that it may be accurately rederived by the next call to
 * get_connected_shading().
 *
 * It may be a good idea to call remove_unused_vertices() as well, to
 * establish the correct connectivity between common vertices.
 */ 1 4 this 3 2135  
271 0 0 4 278 2124 0 0 194 /**
 * Queries the connected_shading information on all primitives at this node
 * and below, to ensure that it has been completely filled in before we start
 * mucking around with vertices.
 */ 1 4 this 3 2135  
272 0 0 4 279 2124 0 0 1065 /**
 * Applies per-vertex normal and color to all vertices, if they are in fact
 * per-vertex (and different for each vertex), or moves them to the primitive
 * if they are all the same.
 *
 * After this call, either the primitive will have normals or its vertices
 * will, but not both.  Ditto for colors.
 *
 * If use_connected_shading is true, each polygon is considered in conjunction
 * with all connected polygons; otherwise, each polygon is considered
 * individually.
 *
 * If allow_per_primitive is false, S_per_face or S_overall will treated like
 * S_per_vertex: normals and colors will always be assigned to the vertices.
 * In this case, there will never be per-primitive colors or normals after
 * this call returns.  On the other hand, if allow_per_primitive is true, then
 * S_per_face means that normals and colors should be assigned to the
 * primitives, and removed from the vertices, as described above.
 *
 * This may create redundant vertices in the vertex pool, so it may be a good
 * idea to follow this up with remove_unused_vertices().
 */ 4 4 this 3 2135  21 use_connected_shading 1 2038  19 allow_per_primitive 1 2038  7 recurse 1 2038  
273 0 0 4 280 2124 0 0 424 /**
 * Sets the last vertex of the triangle (or each component) to the primitive
 * normal and/or color, if the primitive is flat-shaded.  This reflects the
 * OpenGL convention of storing flat-shaded properties on the last vertex,
 * although it is not usually a convention in Egg.
 *
 * This may create redundant vertices in the vertex pool, so it may be a good
 * idea to follow this up with remove_unused_vertices().
 */ 2 4 this 3 2135  7 recurse 1 2038  
274 0 0 4 281 2124 0 0 427 /**
 * Sets the first vertex of the triangle (or each component) to the primitive
 * normal and/or color, if the primitive is flat-shaded.  This reflects the
 * DirectX convention of storing flat-shaded properties on the first vertex,
 * although it is not usually a convention in Egg.
 *
 * This may create redundant vertices in the vertex pool, so it may be a good
 * idea to follow this up with remove_unused_vertices().
 */ 2 4 this 3 2135  7 recurse 1 2038  
275 0 0 4 282 2124 0 0 217 /**
 * Intended as a followup to apply_last_attribute(), this also sets an
 * attribute on the first vertices of the primitive, if they don't already
 * have an attribute set, just so they end up with *something*.
 */ 2 4 this 3 2135  7 recurse 1 2038  
276 0 0 6 283 2038 0 0 124 /**
 * Returns true if there are any primitives (e.g.  polygons) defined within
 * this group or below, false otherwise.
 */ 1 4 this 3 2200  
277 0 0 6 284 2038 0 0 154 /**
 * Returns true if there are any primitives (e.g.  polygons) defined within
 * this group or below, but the search does not include nested joints.
 */ 1 4 this 3 2200  
278 0 0 6 285 2038 0 0 164 /**
 * Returns true if any of the primitives (e.g.  polygons) defined within this
 * group or below have either face or vertex normals defined, false otherwise.
 */ 1 4 this 3 2200  
279 0 0 6 286 2038 0 0 60 /**
 * Returns true if the 2-d v1 is to the right of v2.
 */ 2 2 v1 1 2216  2 v2 1 2216  
280 0 0 7 287 2120 0 0 0 0 
281 0 0 7 289 2142 1296 0 10 /**
 *
 */ 0 
282 0 0 7 289 2142 1296 0 10 /**
 *
 */ 1 4 copy 1 2219  
283 0 0 6 290 2142 0 0 10 /**
 *
 */ 2 4 this 3 2142  4 copy 1 2219  
284 0 0 4 291 2124 0 0 78 /**
 * Writes the attributes to the indicated output stream in Egg format.
 */ 3 4 this 3 2219  3 out 1 2129  12 indent_level 1 2068  
285 0 0 4 296 2124 0 0 500 /**
 * Specifies precisely how the transparency for this geometry should be
 * achieved, or if it should be used.  The default, AM_unspecified, is to use
 * transparency if the geometry has a color whose alpha value is non-1, or if
 * it has a four-channel texture applied; otherwise, AM_on forces transparency
 * on, and AM_off forces it off.  The other flavors of transparency are
 * specific ways to turn on transparency, which may or may not be supported by
 * a particular rendering backend.
 */ 2 4 this 3 2142  4 mode 1 2012  
286 0 0 6 297 2012 0 0 110 /**
 * Returns the alpha mode that was set, or AM_unspecified if nothing was set.
 * See set_alpha_mode().
 */ 1 4 this 3 2219  
287 0 0 4 298 2124 0 0 160 /**
 * Specifies whether writes should be made to the depth buffer (assuming the
 * rendering backend provides a depth buffer) when rendering this geometry.
 */ 2 4 this 3 2142  4 mode 1 2013  
288 0 0 6 299 2013 0 0 124 /**
 * Returns the depth_write mode that was set, or DWM_unspecified if nothing
 * was set.  See set_depth_write_mode().
 */ 1 4 this 3 2219  
289 0 0 4 300 2124 0 0 238 /**
 * Specifies whether this geometry should be tested against the depth buffer
 * when it is drawn (assuming the rendering backend provides a depth buffer).
 * Note that this is different, and independent from, the depth_write mode.
 */ 2 4 this 3 2142  4 mode 1 2014  
290 0 0 6 301 2014 0 0 122 /**
 * Returns the depth_test mode that was set, or DTM_unspecified if nothing was
 * set.  See set_depth_test_mode().
 */ 1 4 this 3 2219  
291 0 0 4 302 2124 0 0 252 /**
 * Specifies whether this geometry is to be considered normally visible, or
 * hidden.  If it is hidden, it is either not loaded into the scene graph at
 * all, or loaded as a "stashed" node, according to the setting of egg-
 * suppress-hidden.
 */ 2 4 this 3 2142  4 mode 1 2015  
292 0 0 6 303 2015 0 0 121 /**
 * Returns the visibility mode that was set, or VM_unspecified if nothing was
 * set.  See set_visibility_mode().
 */ 1 4 this 3 2219  
293 0 0 4 304 2124 0 0 198 /**
 * Sets the "depth-offset" flag associated with this object.  This adds or
 * subtracts an offset bias into the depth buffer.  See also DepthOffsetAttrib
 * and NodePath::set_depth_offset().
 */ 2 4 this 3 2142  4 bias 1 2068  
294 0 0 6 305 2068 0 0 105 /**
 * Returns the "depth-offset" flag as set for this particular object.  See
 * set_depth_offset().
 */ 1 4 this 3 2219  
295 0 0 6 306 2038 0 0 117 /**
 * Returns true if the depth-offset flag has been set for this particular
 * object.  See set_depth_offset().
 */ 1 4 this 3 2219  
296 0 0 4 307 2124 0 0 97 /**
 * Removes the depth-offset flag from this particular object.  See
 * set_depth_offset().
 */ 1 4 this 3 2142  
297 0 0 4 308 2124 0 0 260 /**
 * Sets the "draw-order" flag associated with this object.  This specifies a
 * particular order in which objects of this type should be drawn, within the
 * specified bin.  If a bin is not explicitly specified, "fixed" is used.  See
 * also set_bin().
 */ 2 4 this 3 2142  5 order 1 2068  
298 0 0 6 309 2068 0 0 101 /**
 * Returns the "draw-order" flag as set for this particular object.  See
 * set_draw_order().
 */ 1 4 this 3 2219  
299 0 0 6 310 2038 0 0 113 /**
 * Returns true if the draw-order flag has been set for this particular
 * object.  See set_draw_order().
 */ 1 4 this 3 2219  
300 0 0 4 311 2124 0 0 93 /**
 * Removes the draw-order flag from this particular object.  See
 * set_draw_order().
 */ 1 4 this 3 2142  
301 0 0 4 312 2124 0 0 378 /**
 * Sets the "bin" string for this particular object.  This names a particular
 * bin in which the object should be rendered.  The exact meaning of a bin is
 * implementation defined, but generally a GeomBin matching each bin name must
 * also be specifically added to the rendering engine (e.g.  the
 * CullTraverser) in use for this to work.  See also set_draw_order().
 */ 2 4 this 3 2142  3 bin 1 2128  
302 0 0 6 313 2128 0 0 103 /**
 * Returns the bin name that has been set for this particular object, if any.
 * See set_bin().
 */ 1 4 this 3 2219  
303 0 0 6 314 2038 0 0 97 /**
 * Returns true if a bin name has been set for this particular object.  See
 * set_bin().
 */ 1 4 this 3 2219  
304 0 0 4 315 2124 0 0 91 /**
 * Removes the bin name that was set for this particular object.  See
 * set_bin().
 */ 1 4 this 3 2142  
305 0 0 6 316 2038 0 0 34 // Comparison operators are handy. 2 4 this 3 2219  5 other 1 2219  
306 0 0 6 317 2038 0 0 0 2 4 this 3 2219  5 other 1 2219  
307 0 0 6 318 2038 0 0 0 2 4 this 3 2219  5 other 1 2219  
308 0 0 6 319 2012 0 0 167 /**
 * Returns the AlphaMode value associated with the given string
 * representation, or AM_unspecified if the string does not match any known
 * AlphaMode value.
 */ 1 6 string 1 2128  
309 0 0 6 320 2013 0 0 178 /**
 * Returns the DepthWriteMode value associated with the given string
 * representation, or DWM_unspecified if the string does not match any known
 * DepthWriteMode value.
 */ 1 6 string 1 2128  
310 0 0 6 321 2014 0 0 176 /**
 * Returns the DepthTestMode value associated with the given string
 * representation, or DTM_unspecified if the string does not match any known
 * DepthTestMode value.
 */ 1 6 string 1 2128  
311 0 0 6 322 2015 0 0 169 /**
 * Returns the HiddenMode value associated with the given string
 * representation, or VM_unspecified if the string does not match any known
 * HiddenMode value.
 */ 1 6 string 1 2128  
312 0 0 7 323 2120 0 0 0 0 
313 0 0 7 326 2221 1299 0 10 /**
 *
 */ 0 
314 0 0 7 326 2221 1299 0 10 /**
 *
 */ 1 4 copy 1 2222  
315 0 0 6 327 2221 0 0 10 /**
 *
 */ 2 4 this 3 2221  4 copy 1 2222  
316 0 0 4 329 2124 0 0 51 /**
 * Resets the transform to empty, identity.
 */ 1 4 this 3 2221  
317 0 0 4 330 2124 0 0 72 /**
 * Appends a 2-d translation operation to the current transform.
 */ 2 4 this 3 2221  9 translate 1 2216  
318 0 0 4 331 2124 0 0 72 /**
 * Appends a 3-d translation operation to the current transform.
 */ 2 4 this 3 2221  9 translate 1 2223  
319 0 0 4 332 2124 0 0 141 /**
 * Appends a 2-d rotation to the current transform.  The rotation angle is
 * specified in degrees counterclockwise about the origin.
 */ 2 4 this 3 2221  5 angle 1 2039  
320 0 0 4 333 2124 0 0 152 /**
 * Appends a rotation about the X axis to the current transform.  The rotation
 * angle is specified in degrees counterclockwise about the axis.
 */ 2 4 this 3 2221  5 angle 1 2039  
321 0 0 4 334 2124 0 0 152 /**
 * Appends a rotation about the Y axis to the current transform.  The rotation
 * angle is specified in degrees counterclockwise about the axis.
 */ 2 4 this 3 2221  5 angle 1 2039  
322 0 0 4 335 2124 0 0 152 /**
 * Appends a rotation about the Z axis to the current transform.  The rotation
 * angle is specified in degrees counterclockwise about the axis.
 */ 2 4 this 3 2221  5 angle 1 2039  
323 0 0 4 336 2124 0 0 160 /**
 * Appends an arbitrary 3-d rotation to the current transform, expressed as a
 * quaternion.  This is converted to axis-angle notation for the egg file.
 */ 2 4 this 3 2221  4 quat 1 2225  
324 0 0 4 336 2124 0 0 162 /**
 * Appends a 3-d rotation about an arbitrary axis to the current transform.
 * The rotation angle is specified in degrees counterclockwise about the axis.
 */ 3 4 this 3 2221  5 angle 1 2039  4 axis 1 2223  
325 0 0 4 337 2124 0 0 73 /**
 * Appends a possibly non-uniform scale to the current transform.
 */ 2 4 this 3 2221  5 scale 1 2228  
326 0 0 4 338 2124 0 0 73 /**
 * Appends a possibly non-uniform scale to the current transform.
 */ 2 4 this 3 2221  5 scale 1 2231  
327 0 0 4 339 2124 0 0 60 /**
 * Appends a uniform scale to the current transform.
 */ 2 4 this 3 2221  5 scale 1 2039  
328 0 0 4 340 2124 0 0 68 /**
 * Appends an arbitrary 3x3 matrix to the current transform.
 */ 2 4 this 3 2221  3 mat 1 2234  
329 0 0 4 341 2124 0 0 68 /**
 * Appends an arbitrary 4x4 matrix to the current transform.
 */ 2 4 this 3 2221  3 mat 1 2136  
330 0 0 6 342 2038 0 0 174 /**
 * Returns true if the transform is nonempty, false if it is empty (no
 * transform components have been added).  This is true for either a 2-d or a
 * 3-d transform.
 */ 1 4 this 3 2222  
331 0 0 6 343 2038 0 0 328 /**
 * Returns true if the transform is specified as a 2-d transform, e.g.  with a
 * 3x3 matrix, or false if it is specified as a 3-d transform (with a 4x4
 * matrix), or not specified at all.
 *
 * Normally, EggTextures have a 2-d matrix (but occasionally they use a 3-d
 * matrix), and EggGroups always have a 3-d matrix.
 */ 1 4 this 3 2222  
332 0 0 4 344 2124 0 0 139 /**
 * Sets the overall transform as a 3x3 matrix.  This completely replaces
 * whatever componentwise transform may have been defined.
 */ 2 4 this 3 2221  3 mat 1 2234  
333 0 0 6 345 2038 0 0 328 /**
 * Returns true if the transform is specified as a 3-d transform, e.g.  with a
 * 4x4 matrix, or false if it is specified as a 2-d transform (with a 2x2
 * matrix), or not specified at all.
 *
 * Normally, EggTextures have a 3-d matrix (but occasionally they use a 3-d
 * matrix), and EggGroups always have a 3-d matrix.
 */ 1 4 this 3 2222  
334 0 0 4 346 2124 0 0 139 /**
 * Sets the overall transform as a 4x4 matrix.  This completely replaces
 * whatever componentwise transform may have been defined.
 */ 2 4 this 3 2221  3 mat 1 2136  
335 0 0 7 347 2237 0 0 119 /**
 * Returns the overall transform as a 3x3 matrix.  It is an error to call this
 * if has_transform3d() is true.
 */ 1 4 this 3 2222  
336 0 0 6 348 2136 0 0 190 /**
 * Returns the overall transform as a 4x4 matrix.  It is valid to call this
 * even if has_transform2d() is true; in this case, the 3x3 transform will be
 * expanded to a 4x4 matrix.
 */ 1 4 this 3 2222  
337 0 0 6 349 2038 0 0 80 /**
 * Returns true if the described transform is identity, false otherwise.
 */ 1 4 this 3 2222  
338 0 0 6 351 2068 0 0 71 /**
 * Returns the number of components that make up the transform.
 */ 1 4 this 3 2222  
339 0 0 6 352 2017 0 0 49 /**
 * Returns the type of the nth component.
 */ 2 4 this 3 2222  1 n 1 2068  
340 0 0 6 353 2039 0 0 252 /**
 * Returns the solitary number associated with the nth component.  In the case
 * of a rotation, this is the angle in degrees to rotate; in the case of
 * uniform scale, this is the amount of the scale.  Other types do not use
 * this property.
 */ 2 4 this 3 2222  1 n 1 2068  
341 0 0 6 354 2228 0 0 239 /**
 * Returns the 2-component vector associated with the nth component.  This may
 * be the translate vector, rotate axis, or non-uniform scale.  It is an error
 * to call this if the component type does not use a 2-d vector property.
 */ 2 4 this 3 2222  1 n 1 2068  
342 0 0 6 355 2231 0 0 239 /**
 * Returns the 3-component vector associated with the nth component.  This may
 * be the translate vector, rotate axis, or non-uniform scale.  It is an error
 * to call this if the component type does not use a 3-d vector property.
 */ 2 4 this 3 2222  1 n 1 2068  
343 0 0 6 356 2234 0 0 141 /**
 * Returns the 3x3 matrix associated with the nth component.  It is an error
 * to call this if the component type is not CT_matrix3.
 */ 2 4 this 3 2222  1 n 1 2068  
344 0 0 6 357 2136 0 0 141 /**
 * Returns the 4x4 matrix associated with the nth component.  It is an error
 * to call this if the component type is not CT_matrix4.
 */ 2 4 this 3 2222  1 n 1 2068  
345 0 0 4 358 2124 0 0 70 /**
 * Writes the transform to the indicated stream in Egg format.
 */ 4 4 this 3 2222  3 out 1 2129  12 indent_level 1 2068  5 label 1 2128  
346 0 0 7 360 2239 1333 0 0 1 4 this 3 2238  
347 0 0 4 361 2124 0 0 0 3 4 this 3 2238  3 out 1 2129  12 indent_level 1 2068  
348 0 0 4 362 2124 0 0 0 2 4 this 3 2239  3 mat 1 2136  
349 0 0 7 363 2120 0 0 0 0 
350 0 0 7 366 2240 1336 0 10 /**
 *
 */ 4 9 switch_in 1 2039  10 switch_out 1 2039  6 center 1 2182  4 fade 1 2039  
351 0 0 7 367 2120 0 0 0 0 
352 0 0 7 388 2241 1345 0 10 /**
 *
 */ 1 4 copy 1 2190  
353 0 0 7 388 2241 1345 0 10 /**
 *
 */ 1 4 name 1 2128  
354 0 0 7 389 2241 1345 0 10 /**
 *
 */ 2 4 this 3 2241  4 copy 1 2190  
355 0 0 4 391 2124 0 0 100 /**
 * Writes the group and all of its children to the indicated output stream in
 * Egg format.
 */ 3 4 this 3 2190  3 out 1 2129  12 indent_level 1 2068  
356 0 0 4 392 2124 0 0 92 /**
 * Writes just the <Billboard> entry and related fields to the indicated
 * ostream.
 */ 3 4 this 3 2190  3 out 1 2129  12 indent_level 1 2068  
357 0 0 4 393 2124 0 0 90 /**
 * Writes just the <Collide> entry and related fields to the indicated
 * ostream.
 */ 3 4 this 3 2190  3 out 1 2129  12 indent_level 1 2068  
358 0 0 4 394 2124 0 0 78 /**
 * Writes the <Model> flag and related flags to the indicated ostream.
 */ 3 4 this 3 2190  3 out 1 2129  12 indent_level 1 2068  
359 0 0 4 395 2124 0 0 79 /**
 * Writes the <Switch> flag and related flags to the indicated ostream.
 */ 3 4 this 3 2190  3 out 1 2129  12 indent_level 1 2068  
360 0 0 4 396 2124 0 0 83 /**
 * Writes just the <ObjectTypes> entries, if any, to the indicated ostream.
 */ 3 4 this 3 2190  3 out 1 2129  12 indent_level 1 2068  
361 0 0 4 397 2124 0 0 56 /**
 * Writes the flags related to decaling, if any.
 */ 3 4 this 3 2190  3 out 1 2129  12 indent_level 1 2068  
362 0 0 4 398 2124 0 0 75 /**
 * Writes just the <Tag> entries, if any, to the indicated ostream.
 */ 3 4 this 3 2190  3 out 1 2129  12 indent_level 1 2068  
363 0 0 4 399 2124 0 0 114 /**
 * Writes the flags inherited from EggRenderMode and similar flags that
 * control obscure render effects.
 */ 3 4 this 3 2190  3 out 1 2129  12 indent_level 1 2068  
364 0 0 6 400 2038 0 0 229 /**
 * Returns true if this particular node represents a <Joint> entry or not.
 * This is a handy thing to know since Joints are sorted to the end of their
 * sibling list when writing an egg file.  See EggGroupNode::write().
 */ 1 4 this 3 2190  
365 0 0 6 401 2142 0 0 267 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has an alpha_mode
 * other than AM_unspecified.  Returns a valid EggRenderMode pointer if one is
 * found, or NULL otherwise.
 */ 1 4 this 3 2241  
366 0 0 6 402 2142 0 0 273 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a
 * depth_write_mode other than DWM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2241  
367 0 0 6 403 2142 0 0 272 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a
 * depth_test_mode other than DTM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2241  
368 0 0 6 404 2142 0 0 271 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a
 * visibility_mode other than VM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2241  
369 0 0 6 405 2142 0 0 252 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a depth_offset
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */ 1 4 this 3 2241  
370 0 0 6 406 2142 0 0 250 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a draw_order
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */ 1 4 this 3 2241  
371 0 0 6 407 2142 0 0 243 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a bin
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */ 1 4 this 3 2241  
372 0 0 6 408 2038 0 0 321 /**
 * Walks back up the hierarchy, looking for an EggGroup at this level or above
 * that has the "indexed" scalar set.  Returns the value of the indexed scalar
 * if it is found, or false if it is not.
 *
 * In other words, returns true if the "indexed" flag is in effect for the
 * indicated node, false otherwise.
 */ 1 4 this 3 2241  
373 0 0 6 409 2038 0 0 311 /**
 * Walks back up the hierarchy, looking for an EggGroup at this level or above
 * that has the "decal" flag set.  Returns the value of the decal flag if it
 * is found, or false if it is not.
 *
 * In other words, returns true if the "decal" flag is in effect for the
 * indicated node, false otherwise.
 */ 1 4 this 3 2241  
374 0 0 4 410 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  4 type 1 2025  
375 0 0 6 411 2025 0 0 10 /**
 *
 */ 1 4 this 3 2190  
376 0 0 6 412 2038 0 0 368 /**
 * Returns true if this group is an instance type node; i.e.  it begins the
 * root of a local coordinate space.  This is not related to instancing
 * (multiple copies of a node in a scene graph).
 *
 * This also includes the case of the node including a billboard flag without
 * an explicit center, which implicitly makes the node behave like an
 * instance.
 */ 1 4 this 3 2190  
377 0 0 4 413 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  4 type 1 2027  
378 0 0 6 414 2027 0 0 10 /**
 *
 */ 1 4 this 3 2190  
379 0 0 4 415 2124 0 0 694 /**
 * Sets the point around which the billboard will rotate, if this node
 * contains a billboard specification.
 *
 * If a billboard type is given but no billboard_center is specified, then the
 * group node is treated as an <Instance>, and the billboard rotates around
 * the origin.  If, however, a billboard_center is specified, then the group
 * node is *not* treated as an <Instance>, and the billboard rotates around
 * the specified point.
 *
 * The point is in the same coordinate system as the vertices of this node:
 * usually global, but possibly local if there is an <Instance> somewhere
 * above.  Specifically, this is the coordinate system defined by
 * get_vertex_frame().
 */ 2 4 this 3 2241  16 billboard_center 1 2182  
380 0 0 4 416 2124 0 0 10 /**
 *
 */ 1 4 this 3 2241  
381 0 0 6 417 2038 0 0 10 /**
 *
 */ 1 4 this 3 2190  
382 0 0 6 418 2182 0 0 10 /**
 *
 */ 1 4 this 3 2190  
383 0 0 4 419 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  4 type 1 2028  
384 0 0 6 420 2028 0 0 10 /**
 *
 */ 1 4 this 3 2190  
385 0 0 4 421 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  5 flags 1 2068  
386 0 0 6 422 2029 0 0 10 /**
 *
 */ 1 4 this 3 2190  
387 0 0 4 423 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  14 collision_name 1 2128  
388 0 0 4 424 2124 0 0 10 /**
 *
 */ 1 4 this 3 2241  
389 0 0 6 425 2038 0 0 10 /**
 *
 */ 1 4 this 3 2190  
390 0 0 6 426 2128 0 0 10 /**
 *
 */ 1 4 this 3 2190  
391 0 0 4 427 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  4 type 1 2026  
392 0 0 6 428 2026 0 0 10 /**
 *
 */ 1 4 this 3 2190  
393 0 0 6 429 2038 0 0 91 /**
 * Returns true if the specified DCS type is not DC_none and not
 * DC_unspecified.
 */ 1 4 this 3 2190  
394 0 0 4 430 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  4 type 1 2030  
395 0 0 6 431 2030 0 0 10 /**
 *
 */ 1 4 this 3 2190  
396 0 0 4 432 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  4 flag 1 2038  
397 0 0 6 433 2038 0 0 10 /**
 *
 */ 1 4 this 3 2190  
398 0 0 4 434 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  3 fps 1 2039  
399 0 0 6 435 2039 0 0 10 /**
 *
 */ 1 4 this 3 2190  
400 0 0 4 436 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  11 object_type 1 2128  
401 0 0 4 437 2124 0 0 10 /**
 *
 */ 1 4 this 3 2241  
402 0 0 6 438 2068 0 0 10 /**
 *
 */ 1 4 this 3 2190  
403 0 0 6 439 2128 0 0 10 /**
 *
 */ 2 4 this 3 2190  5 index 1 2068  
404 0 0 6 441 2038 0 0 104 /**
 * Returns true if the indicated object type has been added to the group, or
 * false otherwise.
 */ 2 4 this 3 2190  11 object_type 1 2128  
405 0 0 6 442 2038 0 0 178 /**
 * Removes the first instance of the indicated object type from the group if
 * it is present.  Returns true if the object type was found and removed,
 * false otherwise.
 */ 2 4 this 3 2241  11 object_type 1 2128  
406 0 0 4 443 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  4 flag 1 2038  
407 0 0 6 444 2038 0 0 10 /**
 *
 */ 1 4 this 3 2190  
408 0 0 4 445 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  4 flag 1 2038  
409 0 0 6 446 2038 0 0 10 /**
 *
 */ 1 4 this 3 2190  
410 0 0 4 447 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  4 flag 1 2038  
411 0 0 6 448 2038 0 0 10 /**
 *
 */ 1 4 this 3 2190  
412 0 0 4 449 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  4 flag 1 2038  
413 0 0 6 450 2038 0 0 10 /**
 *
 */ 1 4 this 3 2190  
414 0 0 4 451 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  4 flag 1 2038  
415 0 0 6 452 2038 0 0 10 /**
 *
 */ 1 4 this 3 2190  
416 0 0 4 453 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  4 flag 1 2038  
417 0 0 6 454 2038 0 0 10 /**
 *
 */ 1 4 this 3 2190  
418 0 0 4 455 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  4 flag 1 2038  
419 0 0 6 456 2038 0 0 10 /**
 *
 */ 1 4 this 3 2190  
420 0 0 4 457 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  4 flag 1 2038  
421 0 0 6 458 2038 0 0 10 /**
 *
 */ 1 4 this 3 2190  
422 0 0 4 459 2124 0 0 106 /**
 * If this flag is true, geometry at this node and below will be generated as
 * indexed geometry.
 */ 2 4 this 3 2241  4 flag 1 2038  
423 0 0 4 460 2124 0 0 10 /**
 *
 */ 1 4 this 3 2241  
424 0 0 6 461 2038 0 0 10 /**
 *
 */ 1 4 this 3 2190  
425 0 0 6 462 2038 0 0 10 /**
 *
 */ 1 4 this 3 2190  
426 0 0 4 463 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  4 mask 1 2242  
427 0 0 4 464 2124 0 0 10 /**
 *
 */ 1 4 this 3 2241  
428 0 0 6 465 2038 0 0 10 /**
 *
 */ 1 4 this 3 2190  
429 0 0 7 466 2242 0 0 10 /**
 *
 */ 1 4 this 3 2190  
430 0 0 4 467 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  4 mask 1 2242  
431 0 0 4 468 2124 0 0 10 /**
 *
 */ 1 4 this 3 2241  
432 0 0 6 469 2038 0 0 10 /**
 *
 */ 1 4 this 3 2190  
433 0 0 7 470 2242 0 0 10 /**
 *
 */ 1 4 this 3 2190  
434 0 0 4 471 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  4 mask 1 2242  
435 0 0 4 472 2124 0 0 10 /**
 *
 */ 1 4 this 3 2241  
436 0 0 6 473 2038 0 0 10 /**
 *
 */ 1 4 this 3 2190  
437 0 0 7 474 2242 0 0 10 /**
 *
 */ 1 4 this 3 2190  
438 0 0 4 475 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  10 blend_mode 1 2031  
439 0 0 6 476 2031 0 0 10 /**
 *
 */ 1 4 this 3 2190  
440 0 0 4 477 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  15 blend_operand_a 1 2032  
441 0 0 6 478 2032 0 0 10 /**
 *
 */ 1 4 this 3 2190  
442 0 0 4 479 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  15 blend_operand_b 1 2032  
443 0 0 6 480 2032 0 0 10 /**
 *
 */ 1 4 this 3 2190  
444 0 0 4 481 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  11 blend_color 1 2156  
445 0 0 4 482 2124 0 0 49 /**
 * Removes the blend color specification.
 */ 1 4 this 3 2241  
446 0 0 6 483 2038 0 0 79 /**
 * Returns true if the blend color has been specified, false otherwise.
 */ 1 4 this 3 2190  
447 0 0 6 484 2156 0 0 96 /**
 * Returns the blend color if one has been specified, or (0, 0, 0, 0) if one
 * has not.
 */ 1 4 this 3 2190  
448 0 0 4 485 2124 0 0 10 /**
 *
 */ 2 4 this 3 2241  3 lod 1 2238  
449 0 0 4 486 2124 0 0 10 /**
 *
 */ 1 4 this 3 2241  
450 0 0 6 487 2038 0 0 10 /**
 *
 */ 1 4 this 3 2190  
451 0 0 7 488 2238 0 0 10 /**
 *
 */ 1 4 this 3 2190  
452 0 0 4 489 2124 0 0 524 /**
 * Associates a user-defined value with a user-defined key which is stored on
 * the node.  This value has no meaning to Panda; but it is stored
 * indefinitely on the node until it is requested again.  This value will be
 * copied to the PandaNode that is created for this particular EggGroup if the
 * egg file is loaded as a scene.
 *
 * Each unique key stores a different string value.  There is no effective
 * limit on the number of different keys that may be stored or on the length
 * of any one key's value.
 */ 3 4 this 3 2241  3 key 1 2128  5 value 1 2128  
453 0 0 6 490 2128 0 0 182 /**
 * Retrieves the user-defined value that was previously set on this node for
 * the particular key, if any.  If no value has been previously set, returns
 * the empty string.
 */ 2 4 this 3 2190  3 key 1 2128  
454 0 0 6 491 2038 0 0 170 /**
 * Returns true if a value has been defined on this node for the particular
 * key (even if that value is the empty string), or false if no value has been
 * set.
 */ 2 4 this 3 2190  3 key 1 2128  
455 0 0 4 492 2124 0 0 158 /**
 * Removes the value defined for this key on this particular node.  After a
 * call to clear_tag(), has_tag() will return false for the indicated key.
 */ 2 4 this 3 2241  3 key 1 2128  
456 0 0 6 493 2222 0 0 315 /**
 * Returns a read-only accessor to the initial pose transform.  This is the
 * <DefaultPose> entry for a Joint, and defines only the initial transform
 * pose for the unanimated joint; it has nothing to do with the group's
 * <Transform> entry, which defines the (eventual) space of the group's
 * vertices.
 */ 1 4 this 3 2190  
457 0 0 6 494 2221 0 0 314 /**
 * Returns a writable accessor to the initial pose transform.  This is the
 * <DefaultPose> entry for a Joint, and defines only the initial transform
 * pose for the unanimated joint; it has nothing to do with the group's
 * <Transform> entry, which defines the (eventual) space of the group's
 * vertices.
 */ 1 4 this 3 2241  
458 0 0 4 495 2124 0 0 289 /**
 * Replaces the initial pose transform.  This is the <DefaultPose> entry for a
 * Joint, and defines only the initial transform pose for the unanimated
 * joint; it has nothing to do with the group's <Transform> entry, which
 * defines the (eventual) space of the group's vertices.
 */ 2 4 this 3 2241  9 transform 1 2222  
459 0 0 4 496 2124 0 0 71 /**
 * Removes the initial pose transform.  See set_default_pose().
 */ 1 4 this 3 2241  
460 0 0 4 497 2124 0 0 0 2 4 this 3 2241  7 u_speed 1 2243  
461 0 0 4 498 2124 0 0 0 2 4 this 3 2241  7 v_speed 1 2243  
462 0 0 4 499 2124 0 0 0 2 4 this 3 2241  7 w_speed 1 2243  
463 0 0 4 500 2124 0 0 0 2 4 this 3 2241  7 r_speed 1 2243  
464 0 0 6 501 2039 0 0 0 1 4 this 3 2190  
465 0 0 6 502 2039 0 0 0 1 4 this 3 2190  
466 0 0 6 503 2039 0 0 0 1 4 this 3 2190  
467 0 0 6 504 2039 0 0 0 1 4 this 3 2190  
468 0 0 6 505 2038 0 0 0 1 4 this 3 2241  
469 0 0 4 554 2124 0 0 213 /**
 * Adds the vertex to the set of those referenced by the group, at the
 * indicated membership level.  If the vertex is already being referenced,
 * increases the membership amount by the indicated amount.
 */ 3 4 this 3 2241  4 vert 1 2077  10 membership 1 2039  
470 0 0 4 555 2124 0 0 130 /**
 * Removes the vertex from the set of those referenced by the group.  Does
 * nothing if the vertex is not already reffed.
 */ 2 4 this 3 2241  4 vert 1 2077  
471 0 0 4 556 2124 0 0 56 /**
 * Removes all vertices from the reference list.
 */ 1 4 this 3 2241  
472 0 0 6 557 2039 0 0 139 /**
 * Returns the amount of membership of the indicated vertex in this group.  If
 * the vertex is not reffed by the group, returns 0.
 */ 2 4 this 3 2190  4 vert 1 2178  
473 0 0 4 558 2124 0 0 106 /**
 * Explicitly sets the net membership of the indicated vertex in this group to
 * the given value.
 */ 3 4 this 3 2241  4 vert 1 2077  10 membership 1 2039  
474 0 0 4 559 2124 0 0 195 /**
 * Moves all of the vertex references from the indicated other group into this
 * one.  If a given vertex was previously shared by both groups, the relative
 * memberships will be summed.
 */ 2 4 this 3 2241  5 other 1 2241  
475 0 0 4 560 2124 0 0 0 1 4 this 3 2190  
476 0 0 4 561 2124 0 0 207 /**
 * Adds a new <Ref> entry to the group.  This declares an internal reference
 * to another node, and is used to implement scene-graph instancing; it is
 * only valid if the group_type is GT_instance.
 */ 2 4 this 3 2241  5 group 1 2241  
477 0 0 6 562 2068 0 0 90 /**
 * Returns the number of <Ref> entries within this group.  See
 * add_group_ref().
 */ 1 4 this 3 2190  
478 0 0 7 563 2241 1345 0 79 /**
 * Returns the nth <Ref> entry within this group.  See add_group_ref().
 */ 2 4 this 3 2190  1 n 1 2068  
479 0 0 4 565 2124 0 0 79 /**
 * Removes the nth <Ref> entry within this group.  See add_group_ref().
 */ 2 4 this 3 2241  1 n 1 2068  
480 0 0 4 566 2124 0 0 84 /**
 * Removes all of the <Ref> entries within this group.  See add_group_ref().
 */ 1 4 this 3 2241  
481 0 0 6 567 2025 0 0 163 /**
 * Returns the GroupType value associated with the given string
 * representation, or GT_invalid if the string does not match any known
 * GroupType value.
 */ 1 6 strval 1 2128  
482 0 0 6 568 2030 0 0 155 /**
 * Returns the DartType value associated with the given string representation,
 * or DT_none if the string does not match any known DartType value.
 */ 1 6 strval 1 2128  
483 0 0 6 569 2026 0 0 160 /**
 * Returns the DCSType value associated with the given string representation,
 * or DC_unspecified if the string does not match any known DCSType value.
 */ 1 6 strval 1 2128  
484 0 0 6 570 2027 0 0 168 /**
 * Returns the BillboardType value associated with the given string
 * representation, or BT_none if the string does not match any known
 * BillboardType value.
 */ 1 6 strval 1 2128  
485 0 0 6 571 2028 0 0 179 /**
 * Returns the CollisionSolidType value associated with the given string
 * representation, or CST_none if the string does not match any known
 * CollisionSolidType value.
 */ 1 6 strval 1 2128  
486 0 0 6 572 2029 0 0 260 /**
 * Returns the CollideFlags value associated with the given string
 * representation, or CF_none if the string does not match any known
 * CollideFlags value.  This only recognizes a single keyword; it does not
 * attempt to parse a string of keywords.
 */ 1 6 strval 1 2128  
487 0 0 6 573 2031 0 0 154 /**
 * Returns the BlendMode value associated with the given string
 * representation, or BM_none if the string does not match any known
 * BlendMode.
 */ 1 6 strval 1 2128  
488 0 0 6 574 2032 0 0 160 /**
 * Returns the BlendOperand value associated with the given string
 * representation, or BO_none if the string does not match any known
 * BlendOperand.
 */ 1 6 strval 1 2128  
489 0 0 7 575 2120 0 0 0 0 
490 0 0 7 370 2135 1063 0 0 1 4 this 3 2241  
491 0 0 7 371 2241 1345 0 0 1 4 this 3 2135  
492 0 0 6 372 2142 0 0 0 1 4 this 3 2241  
493 0 0 7 373 2241 1345 0 0 1 4 this 3 2142  
494 0 0 6 374 2221 0 0 0 1 4 this 3 2241  
495 0 0 7 375 2241 1345 0 0 1 4 this 3 2221  
496 0 0 7 577 2246 1485 0 10 /**
 *
 */ 1 4 copy 1 2244  
497 0 0 7 577 2246 1485 0 10 /**
 *
 */ 1 4 copy 1 2190  
498 0 0 7 577 2246 1485 0 10 /**
 *
 */ 1 4 name 1 2128  
499 0 0 4 578 2124 0 0 10 /**
 *
 */ 2 4 this 3 2246  10 bin_number 1 2068  
500 0 0 6 579 2068 0 0 10 /**
 *
 */ 1 4 this 3 2244  
501 0 0 7 580 2120 0 0 0 0 
502 0 0 6 583 2068 0 0 208 /**
 * The main entry point to EggBinMaker.  Walks the egg scene graph beginning
 * at the indicated root node, and moves all binnable nodes into EggBin
 * objects.  Returns the number of EggBins created.
 */ 2 4 this 3 2247  10 root_group 1 2135  
503 0 0 4 584 2124 0 0 171 /**
 * May be overridden in derived classes to perform some setup work as each
 * node is encountered.  This will be called once for each node in the egg
 * hierarchy.
 */ 2 4 this 3 2247  4 node 1 2132  
504 0 0 6 585 2068 0 0 0 2 4 this 3 2247  4 node 1 2133  
505 0 0 6 586 2038 0 0 361 /**
 * May be overridden in derived classes to create additional bins within a
 * particular bin number, based on some arbitrary property of nodes.  This
 * function establishes an arbitrary but fixed ordering between nodes; if two
 * nodes do not sort to the same position, different bins are created for each
 * one (with the same bin number on each bin).
 */ 4 4 this 3 2247  10 bin_number 1 2068  1 a 1 2133  1 b 1 2133  
506 0 0 6 587 2038 0 0 145 /**
 * May be overridden in derived classes to specify whether a particular group
 * node, apparently redundant, may be safely collapsed out.
 */ 3 4 this 3 2247  5 group 1 2190  10 bin_number 1 2068  
507 0 0 6 588 2128 0 0 130 /**
 * May be overridden in derived classes to define a name for each new bin,
 * based on its bin number, and a sample child.
 */ 3 4 this 3 2247  10 bin_number 1 2068  5 child 1 2133  
508 0 0 7 589 2246 1485 0 352 /**
 * May be overridden in derived classes to construct a new EggBin object (or
 * some derived class, if needed), and preload some initial data into as
 * required.
 *
 * child is an arbitrary child of the bin, and collapse_from is the group the
 * bin is being collapsed with, if any (implying collapse_group() returned
 * true), or NULL if not.
 */ 4 4 this 3 2247  10 bin_number 1 2068  5 child 1 2133  13 collapse_from 1 2241  
509 0 0 7 590 2120 0 0 0 0 
510 0 0 7 592 2250 1500 0 10 /**
 *
 */ 1 4 copy 1 2248  
511 0 0 7 592 2250 1500 0 10 /**
 *
 */ 2 9 node_name 1 2128  7 comment 1 2128  
512 0 0 7 593 2250 1500 0 10 /**
 *
 */ 2 4 this 3 2250  4 copy 1 2248  
513 0 0 7 593 2250 1500 0 10 /**
 *
 */ 2 4 this 3 2250  7 comment 1 2128  
514 0 0 4 595 2124 0 0 10 /**
 *
 */ 2 4 this 3 2250  7 comment 1 2128  
515 0 0 6 596 2128 0 0 10 /**
 *
 */ 1 4 this 3 2248  
516 0 0 7 597 2120 0 0 0 0 
517 0 0 6 594 2128 0 0 0 1 4 this 3 2248  
518 0 0 7 600 2251 1508 0 10 /**
 *
 */ 2 4 this 3 2251  4 copy 1 2252  
519 0 0 6 601 2128 0 0 64 /**
 * Returns the default extension for this filename type.
 */ 1 4 this 3 2252  
520 0 0 6 602 2209 0 0 61 /**
 * Returns a nonmodifiable reference to the filename.
 */ 1 4 this 3 2252  
521 0 0 4 603 2124 0 0 10 /**
 *
 */ 2 4 this 3 2251  8 filename 1 2209  
522 0 0 6 604 2209 0 0 472 /**
 * Returns the full pathname to the file, if it is known; otherwise, returns
 * the same thing as get_filename().
 *
 * This function simply returns whatever was set by the last call to
 * set_fullpath().  This string is not written to the egg file; its main
 * purpose is to record the full path to a filename (for instance, a texture
 * filename) if it is known, for egg structures that are generated in-memory
 * and then immediately converted to a scene graph.
 */ 1 4 this 3 2252  
523 0 0 4 605 2124 0 0 84 /**
 * Records the full pathname to the file, for the benefit of get_fullpath().
 */ 2 4 this 3 2251  8 fullpath 1 2209  
524 0 0 7 606 2120 0 0 0 0 
525 0 0 7 615 2075 1517 0 10 /**
 *
 */ 1 4 copy 1 2254  
526 0 0 7 615 2075 1517 0 10 /**
 *
 */ 2 9 tref_name 1 2128  8 filename 1 2209  
527 0 0 7 616 2075 1517 0 10 /**
 *
 */ 2 4 this 3 2075  4 copy 1 2254  
528 0 0 4 618 2124 0 0 86 /**
 * Writes the texture definition to the indicated output stream in Egg format.
 */ 3 4 this 3 2254  3 out 1 2129  12 indent_level 1 2068  
529 0 0 6 620 2038 0 0 899 /**
 * Returns true if the two textures are equivalent in all relevant properties
 * (according to eq), false otherwise.
 *
 * The Equivalence parameter, eq, should be set to the bitwise OR of the
 * following properties, according to what you consider relevant:
 *
 * EggTexture::E_basename: The basename part of the texture filename, without
 * the directory prefix *or* the filename extension.
 *
 * EggTexture::E_extension: The extension part of the texture filename.
 *
 * EggTexture::E_dirname: The directory prefix of the texture filename.
 *
 * EggTexture::E_complete_filename: The union of the above three; that is, the
 * complete filename, with directory, basename, and extension.
 *
 * EggTexture::E_transform: The texture matrix.
 *
 * EggTexture::E_attributes: All remaining texture attributes (mode, mipmap,
 * etc.) except TRef name.
 *
 * EggTexture::E_tref_name: The TRef name.
 */ 3 4 this 3 2254  5 other 1 2254  2 eq 1 2068  
530 0 0 6 621 2038 0 0 224 /**
 * An ordering operator to compare two textures for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique textures, according
 * to the indicated Equivalence factor.  See is_equivalent_to().
 */ 3 4 this 3 2254  5 other 1 2254  2 eq 1 2068  
531 0 0 6 622 2038 0 0 260 /**
 * Given the number of color components (channels) in the image file as
 * actually read from the disk, return true if this texture seems to have an
 * alpha channel or not.  This depends on the EggTexture's format as well as
 * the number of channels.
 */ 2 4 this 3 2254  14 num_components 1 2068  
532 0 0 4 636 2124 0 0 10 /**
 *
 */ 2 4 this 3 2075  12 texture_type 1 2055  
533 0 0 6 637 2055 0 0 10 /**
 *
 */ 1 4 this 3 2254  
534 0 0 4 638 2124 0 0 10 /**
 *
 */ 2 4 this 3 2075  6 format 1 2056  
535 0 0 6 639 2056 0 0 10 /**
 *
 */ 1 4 this 3 2254  
536 0 0 4 640 2124 0 0 10 /**
 *
 */ 2 4 this 3 2075  4 mode 1 2057  
537 0 0 6 641 2057 0 0 10 /**
 *
 */ 1 4 this 3 2254  
538 0 0 4 642 2124 0 0 10 /**
 *
 */ 2 4 this 3 2075  4 mode 1 2058  
539 0 0 6 643 2058 0 0 10 /**
 *
 */ 1 4 this 3 2254  
540 0 0 4 644 2124 0 0 10 /**
 *
 */ 2 4 this 3 2075  4 mode 1 2058  
541 0 0 6 645 2058 0 0 120 /**
 * Returns the amount specified for U wrap.  This may be unspecified, even if
 * there is an overall wrap value.
 */ 1 4 this 3 2254  
542 0 0 6 646 2058 0 0 178 /**
 * Determines the appropriate wrap in the U direction.  This is different from
 * get_wrap_u() in that if the U wrap is unspecified, it returns the overall
 * wrap value.
 */ 1 4 this 3 2254  
543 0 0 4 647 2124 0 0 10 /**
 *
 */ 2 4 this 3 2075  4 mode 1 2058  
544 0 0 6 648 2058 0 0 120 /**
 * Returns the amount specified for V wrap.  This may be unspecified, even if
 * there is an overall wrap value.
 */ 1 4 this 3 2254  
545 0 0 6 649 2058 0 0 178 /**
 * Determines the appropriate wrap in the V direction.  This is different from
 * get_wrap_v() in that if the V wrap is unspecified, it returns the overall
 * wrap value.
 */ 1 4 this 3 2254  
546 0 0 4 650 2124 0 0 10 /**
 *
 */ 2 4 this 3 2075  4 mode 1 2058  
547 0 0 6 651 2058 0 0 120 /**
 * Returns the amount specified for W wrap.  This may be unspecified, even if
 * there is an overall wrap value.
 */ 1 4 this 3 2254  
548 0 0 6 652 2058 0 0 178 /**
 * Determines the appropriate wrap in the W direction.  This is different from
 * get_wrap_w() in that if the W wrap is unspecified, it returns the overall
 * wrap value.
 */ 1 4 this 3 2254  
549 0 0 4 653 2124 0 0 10 /**
 *
 */ 2 4 this 3 2075  4 type 1 2059  
550 0 0 6 654 2059 0 0 10 /**
 *
 */ 1 4 this 3 2254  
551 0 0 4 655 2124 0 0 10 /**
 *
 */ 2 4 this 3 2075  4 type 1 2059  
552 0 0 6 656 2059 0 0 10 /**
 *
 */ 1 4 this 3 2254  
553 0 0 4 657 2124 0 0 127 /**
 * Sets the degree of anisotropic filtering for this texture.  1 is off;
 * higher levels indicate filtering in effect.
 */ 2 4 this 3 2075  18 anisotropic_degree 1 2068  
554 0 0 4 658 2124 0 0 79 /**
 * Removes the specification of anisotropic filtering from the texture.
 */ 1 4 this 3 2075  
555 0 0 6 659 2038 0 0 128 /**
 * Returns true if a value for the anisotropic filtering degree has been
 * specified for this texture, false otherwise.
 */ 1 4 this 3 2254  
556 0 0 6 660 2068 0 0 132 /**
 * Returns the anisotropic filtering degree that has been specified for this
 * texture, or 0 if nothing has been specified.
 */ 1 4 this 3 2254  
557 0 0 4 661 2124 0 0 10 /**
 *
 */ 2 4 this 3 2075  4 type 1 2060  
558 0 0 6 662 2060 0 0 10 /**
 *
 */ 1 4 this 3 2254  
559 0 0 6 663 2038 0 0 162 /**
 * Returns true if this texture's environment type or combine mode allows the
 * texture to have an effect on the polygon's alpha values, false otherwise.
 */ 1 4 this 3 2254  
560 0 0 4 664 2124 0 0 10 /**
 *
 */ 3 4 this 3 2075  7 channel 1 2062  2 cm 1 2061  
561 0 0 6 665 2061 0 0 10 /**
 *
 */ 2 4 this 3 2254  7 channel 1 2062  
562 0 0 4 666 2124 0 0 10 /**
 *
 */ 4 4 this 3 2075  7 channel 1 2062  1 n 1 2068  2 cs 1 2064  
563 0 0 6 667 2064 0 0 10 /**
 *
 */ 3 4 this 3 2254  7 channel 1 2062  1 n 1 2068  
564 0 0 4 668 2124 0 0 10 /**
 *
 */ 4 4 this 3 2075  7 channel 1 2062  1 n 1 2068  2 co 1 2065  
565 0 0 6 669 2065 0 0 10 /**
 *
 */ 3 4 this 3 2254  7 channel 1 2062  1 n 1 2068  
566 0 0 4 670 2124 0 0 614 /**
 * Sets the saved_result flag.  When this is true, the output of this stage is
 * not part of the normal pipeline--that is, it will not be supplied as the
 * "previous" source for the next texture stage--but it will instead be
 * supplied as the "last_saved_result" source for any future stages, until the
 * next TextureStage with a saved_result set true is encountered.
 *
 * This can be used to reuse the results of this texture stage as input to
 * more than one stage later in the pipeline.
 *
 * The last texture in the pipeline (the one with the highest sort value)
 * should not have this flag set.
 */ 2 4 this 3 2075  12 saved_result 1 2038  
567 0 0 6 671 2038 0 0 92 /**
 * Returns the current setting of the saved_result flag.  See
 * set_saved_result().
 */ 1 4 this 3 2254  
568 0 0 4 672 2124 0 0 10 /**
 *
 */ 2 4 this 3 2075  7 tex_gen 1 2066  
569 0 0 6 673 2066 0 0 10 /**
 *
 */ 1 4 this 3 2254  
570 0 0 4 674 2124 0 0 10 /**
 *
 */ 2 4 this 3 2075  13 quality_level 1 2067  
571 0 0 6 675 2067 0 0 10 /**
 *
 */ 1 4 this 3 2254  
572 0 0 4 676 2124 0 0 442 /**
 * Specifies the particular TextureStage this texture will be rendered on by
 * name.  If this is omitted, the texture will be rendered on the default
 * TextureStage, unless some other stage-specific property is specificied, in
 * which case the texture will be rendered on a TextureStage with the same
 * name as the tref.  This is in support of multitexturing.
 *
 * Each different TextureStage in the world must be uniquely named.
 */ 2 4 this 3 2075  10 stage_name 1 2128  
573 0 0 4 677 2124 0 0 56 /**
 * Removes the named TextureStage specification.
 */ 1 4 this 3 2075  
574 0 0 6 678 2038 0 0 107 /**
 * Returns true if a stage name has been explicitly specified for this
 * texture, false otherwise.
 */ 1 4 this 3 2254  
575 0 0 6 679 2128 0 0 146 /**
 * Returns the stage name that has been specified for this texture, or the
 * tref name if no texture stage has explicitly been specified.
 */ 1 4 this 3 2254  
576 0 0 4 680 2124 0 0 178 /**
 * Sets the importance of this texture with respect to other textures also
 * applied on the same geometry.  This is only meaningful in the presence of
 * multitexturing.
 */ 2 4 this 3 2075  8 priority 1 2068  
577 0 0 4 681 2124 0 0 116 /**
 * Removes the specification of multitexture priority from the texture.  The
 * default priority value is 0.
 */ 1 4 this 3 2075  
578 0 0 6 682 2038 0 0 127 /**
 * Returns true if a priority value for multitexture importance has been
 * specified for the texture, false otherwise.
 */ 1 4 this 3 2254  
579 0 0 6 683 2068 0 0 142 /**
 * Returns the multitexture importance value that has been specified for the
 * texture, or 0 if no priority value has been specified.
 */ 1 4 this 3 2254  
580 0 0 4 684 2124 0 0 10 /**
 *
 */ 2 4 this 3 2075  5 color 1 2156  
581 0 0 4 685 2124 0 0 10 /**
 *
 */ 1 4 this 3 2075  
582 0 0 6 686 2038 0 0 76 /**
 * Returns true if a blend color has been specified for the texture.
 */ 1 4 this 3 2254  
583 0 0 6 687 2156 0 0 91 /**
 * Returns the blend color if one has been specified, or (0, 0, 0, 1)
 * otherwise.
 */ 1 4 this 3 2254  
584 0 0 4 688 2124 0 0 10 /**
 *
 */ 2 4 this 3 2075  12 border_color 1 2156  
585 0 0 4 689 2124 0 0 10 /**
 *
 */ 1 4 this 3 2075  
586 0 0 6 690 2038 0 0 77 /**
 * Returns true if a border color has been specified for the texture.
 */ 1 4 this 3 2254  
587 0 0 6 691 2156 0 0 92 /**
 * Returns the border color if one has been specified, or (0, 0, 0, 1)
 * otherwise.
 */ 1 4 this 3 2254  
588 0 0 4 692 2124 0 0 309 /**
 * Specifies the named set of texture coordinates that this texture will use
 * when it is applied to geometry.  Geometry may have multiple sets of texture
 * coordinates defined, by name.
 *
 * If this is not specified for a particular texture, the default set of
 * texture coordinates will be used.
 */ 2 4 this 3 2075  7 uv_name 1 2128  
589 0 0 4 693 2124 0 0 153 /**
 * Removes the restriction to a particular named set of texture coordinates
 * and restores the texture to using the default texture coordinates.
 */ 1 4 this 3 2075  
590 0 0 6 694 2038 0 0 110 /**
 * Returns true if a texcoord name has been explicitly specified for this
 * texture, false otherwise.
 */ 1 4 this 3 2254  
591 0 0 6 695 2128 0 0 152 /**
 * Returns the texcoord name that has been specified for this texture, or the
 * empty string if no texcoord name has explicitly been specified.
 */ 1 4 this 3 2254  
592 0 0 4 696 2124 0 0 220 /**
 * Sets an additional factor that will scale all three r, g, b components
 * after the texture has been applied.  This is used only when a combine mode
 * is in effect.
 *
 * The only legal values are 1, 2, or 4.
 */ 2 4 this 3 2075  9 rgb_scale 1 2068  
593 0 0 4 697 2124 0 0 95 /**
 * Removes the rgb_scale from the texture and restores it to the default value
 * of 1.
 */ 1 4 this 3 2075  
594 0 0 6 698 2038 0 0 95 /**
 * Returns true if an rgb_scale has been specified for the texture, false
 * otherwise.
 */ 1 4 this 3 2254  
595 0 0 6 699 2068 0 0 129 /**
 * Returns the rgb_scale value that has been specified for the texture, or 1
 * if no rgb_scale value has been specified.
 */ 1 4 this 3 2254  
596 0 0 4 700 2124 0 0 211 /**
 * Sets an additional factor that will scale the alpha component after the
 * texture has been applied.  This is used only when a combine mode is in
 * effect.
 *
 * The only legal values are 1, 2, or 4.
 */ 2 4 this 3 2075  11 alpha_scale 1 2068  
597 0 0 4 701 2124 0 0 97 /**
 * Removes the alpha_scale from the texture and restores it to the default
 * value of 1.
 */ 1 4 this 3 2075  
598 0 0 6 702 2038 0 0 97 /**
 * Returns true if an alpha_scale has been specified for the texture, false
 * otherwise.
 */ 1 4 this 3 2254  
599 0 0 6 703 2068 0 0 133 /**
 * Returns the alpha_scale value that has been specified for the texture, or 1
 * if no alpha_scale value has been specified.
 */ 1 4 this 3 2254  
600 0 0 4 704 2124 0 0 235 /**
 * Specifies a separate file that will be loaded in with the 1- or 3-component
 * texture and applied as the alpha channel.  This is useful when loading
 * textures from file formats that do not support alpha, for instance jpg.
 */ 2 4 this 3 2075  8 filename 1 2209  
601 0 0 4 705 2124 0 0 10 /**
 *
 */ 1 4 this 3 2075  
602 0 0 6 706 2038 0 0 131 /**
 * Returns true if a separate file for the alpha component has been applied,
 * false otherwise.  See set_alpha_filename().
 */ 1 4 this 3 2254  
603 0 0 6 707 2209 0 0 172 /**
 * Returns the separate file assigned for the alpha channel.  It is an error
 * to call this unless has_alpha_filename() returns true.  See
 * set_alpha_filename().
 */ 1 4 this 3 2254  
604 0 0 4 708 2124 0 0 93 /**
 * Records the full pathname to the file, for the benefit of
 * get_alpha_fullpath().
 */ 2 4 this 3 2075  8 fullpath 1 2209  
605 0 0 6 709 2209 0 0 463 /**
 * Returns the full pathname to the alpha file, if it is known; otherwise,
 * returns the same thing as get_alpha_filename().
 *
 * This function simply returns whatever was set by the last call to
 * set_alpha_fullpath().  This string is not written to the egg file; its main
 * purpose is to record the full path to the alpha filename if it is known,
 * for egg structures that are generated in-memory and then immediately
 * converted to a scene graph.
 */ 1 4 this 3 2254  
606 0 0 4 710 2124 0 0 416 /**
 * If a separate alpha-file is specified, this indicates which channel number
 * should be extracted from this file to derive the alpha channel for the
 * final image.  The default is 0, which means the grayscale combination of r,
 * g, b.  Otherwise, this should be the 1-based channel number, for instance
 * 1, 2, or 3 for r, g, or b, respectively, or 4 for the alpha channel of a
 * four-component image.
 */ 2 4 this 3 2075  18 alpha_file_channel 1 2068  
607 0 0 4 711 2124 0 0 98 /**
 * Removes the specification of a particular channel to use from the alpha-
 * file image.
 */ 1 4 this 3 2075  
608 0 0 6 712 2038 0 0 112 /**
 * Returns true if a particular channel has been specified for the alpha-file
 * image, false otherwise.
 */ 1 4 this 3 2254  
609 0 0 6 713 2068 0 0 167 /**
 * Returns the particular channel that has been specified for the alpha-file
 * image, or 0 if no channel has been specified.  See
 * set_alpha_file_channel().
 */ 1 4 this 3 2254  
610 0 0 4 714 2124 0 0 380 /**
 * Sets the multiview flag.
 *
 * If multiview is true, the filename should contain a hash mark ('#'), which
 * will be filled in with the view number; and a multiview texture will be
 * defined with a series of images, one for each view.
 *
 * A multiview texture is most often used for stereo textures, but other uses
 * are also possible, such as for texture animation.
 */ 2 4 this 3 2075  9 multiview 1 2038  
611 0 0 6 715 2038 0 0 83 /**
 * Returns the current setting of the multiview flag.  See set_multiview().
 */ 1 4 this 3 2254  
612 0 0 4 716 2124 0 0 197 /**
 * When loading a 3-D multiview texture, this parameter is necessary to
 * specify how many views will be expected.  The z size is determined
 * implicitly from the number of images loaded.
 */ 2 4 this 3 2075  9 num_views 1 2068  
613 0 0 4 717 2124 0 0 91 /**
 * Removes the specification of the number of views for a 3-D multiview
 * texture.
 */ 1 4 this 3 2075  
614 0 0 6 718 2038 0 0 116 /**
 * Returns true if the number of views has been specified for the 3-D
 * multiview texture, false otherwise.
 */ 1 4 this 3 2254  
615 0 0 6 719 2068 0 0 114 /**
 * Returns the specified number of views specified for the 3-D multiview
 * texture.  See set_num_views().
 */ 1 4 this 3 2254  
616 0 0 4 720 2124 0 0 546 /**
 * Sets the read_mipmaps flag.
 *
 * If read_mipmaps is true, the filename should contain a hash mark ('#'),
 * which will be filled in with the mipmap level number; and the texture will
 * be defined with a series of images, one for each mipmap level.
 *
 * If the filename is of a type that already requires a hash mark, such as a
 * cube map or a 3-d texture, then the filename should now require two hash
 * marks, and the first one indicates the mipmap level number, while the
 * second indicates the face number or 3-d level number.
 */ 2 4 this 3 2075  12 read_mipmaps 1 2038  
617 0 0 6 721 2038 0 0 92 /**
 * Returns the current setting of the read_mipmaps flag.  See
 * set_read_mipmaps().
 */ 1 4 this 3 2254  
618 0 0 4 722 2124 0 0 61 /**
 * Sets the minimum mipmap level that may be sampled.
 */ 2 4 this 3 2075  7 min_lod 1 2039  
619 0 0 4 723 2124 0 0 80 /**
 * Removes the specification of a minimum mipmap level from the texture.
 */ 1 4 this 3 2075  
620 0 0 6 724 2038 0 0 120 /**
 * Returns true if a value for the minimum mipmap level has been specified for
 * this texture, false otherwise.
 */ 1 4 this 3 2254  
621 0 0 6 725 2039 0 0 85 /**
 * Returns the minimum mipmap level that has been specified for this texture.
 */ 1 4 this 3 2254  
622 0 0 4 726 2124 0 0 61 /**
 * Sets the maximum mipmap level that may be sampled.
 */ 2 4 this 3 2075  7 max_lod 1 2039  
623 0 0 4 727 2124 0 0 80 /**
 * Removes the specification of a maximum mipmap level from the texture.
 */ 1 4 this 3 2075  
624 0 0 6 728 2038 0 0 120 /**
 * Returns true if a value for the maximum mipmap level has been specified for
 * this texture, false otherwise.
 */ 1 4 this 3 2254  
625 0 0 6 729 2039 0 0 85 /**
 * Returns the maximum mipmap level that has been specified for this texture.
 */ 1 4 this 3 2254  
626 0 0 4 730 2124 0 0 86 /**
 * Sets the mipmap level bias that is added to the mipmap level to be sampled.
 */ 2 4 this 3 2075  8 lod_bias 1 2039  
627 0 0 4 731 2124 0 0 80 /**
 * Removes the specification of a maximum mipmap level from the texture.
 */ 1 4 this 3 2075  
628 0 0 6 732 2038 0 0 120 /**
 * Returns true if a value for the maximum mipmap level has been specified for
 * this texture, false otherwise.
 */ 1 4 this 3 2254  
629 0 0 6 733 2039 0 0 85 /**
 * Returns the maximum mipmap level that has been specified for this texture.
 */ 1 4 this 3 2254  
630 0 0 4 734 2124 0 0 173 /**
 * Resets the multitexture flags set by multitexture_over().  After this call,
 * get_multitexture() will return false, and get_multitexture_sort() will
 * return 0.
 */ 1 4 this 3 2075  
631 0 0 6 735 2038 0 0 434 /**
 * Indicates that this texture should be layered on top of the other texture.
 * This will guarantee that this->get_multitexture_sort() >
 * other->get_multitexture_sort(), at least until clear_multitexture() is
 * called on either one.
 *
 * The return value is true if successful, or false if there is a failure
 * because the other texture was already layered on top of this one (or there
 * is a three- or more-way cycle).
 */ 2 4 this 3 2075  5 other 1 2075  
632 0 0 6 736 2068 0 0 333 /**
 * Returns an integer that represents the depth to which this texture is
 * layered on all other textures in the egg file.  In general, if texture A is
 * layered over texture B, then sort(A) > sort(B).  If texture A is never
 * layered over any other texture, then sort(A) == 0.  More than that is
 * difficult to guarantee.
 */ 1 4 this 3 2254  
633 0 0 6 737 2055 0 0 171 /**
 * Returns the Texture_ype value associated with the given string
 * representation, or TT_unspecified if the string does not match any known
 * TextureType value.
 */ 1 6 string 1 2128  
634 0 0 6 738 2056 0 0 157 /**
 * Returns the Format value associated with the given string representation,
 * or F_unspecified if the string does not match any known Format value.
 */ 1 6 string 1 2128  
635 0 0 6 739 2057 0 0 175 /**
 * Returns the CompressionMode value associated with the given string
 * representation, or CM_default if the string does not match any known
 * CompressionMode value.
 */ 1 6 string 1 2128  
636 0 0 6 740 2058 0 0 162 /**
 * Returns the WrapMode value associated with the given string representation,
 * or WM_unspecified if the string does not match any known WrapMode value.
 */ 1 6 string 1 2128  
637 0 0 6 741 2059 0 0 169 /**
 * Returns the FilterType value associated with the given string
 * representation, or FT_unspecified if the string does not match any known
 * FilterType value.
 */ 1 6 string 1 2128  
638 0 0 6 742 2060 0 0 160 /**
 * Returns the EnvType value associated with the given string representation,
 * or ET_unspecified if the string does not match any known EnvType value.
 */ 1 6 string 1 2128  
639 0 0 6 743 2061 0 0 171 /**
 * Returns the CombineMode value associated with the given string
 * representation, or CM_unspecified if the string does not match any known
 * CombineMode value.
 */ 1 6 string 1 2128  
640 0 0 6 744 2064 0 0 175 /**
 * Returns the CombineSource value associated with the given string
 * representation, or CS_unspecified if the string does not match any known
 * CombineSource value.
 */ 1 6 string 1 2128  
641 0 0 6 745 2065 0 0 177 /**
 * Returns the CombineOperand value associated with the given string
 * representation, or CO_unspecified if the string does not match any known
 * CombineOperand value.
 */ 1 6 string 1 2128  
642 0 0 6 746 2066 0 0 158 /**
 * Returns the TexGen value associated with the given string representation,
 * or ET_unspecified if the string does not match any known TexGen value.
 */ 1 6 string 1 2128  
643 0 0 6 747 2067 0 0 158 /**
 * Returns the TexGen value associated with the given string representation,
 * or ET_unspecified if the string does not match any known TexGen value.
 */ 1 6 string 1 2128  
644 0 0 7 782 2120 0 0 0 0 
645 0 0 7 609 2251 1508 0 0 1 4 this 3 2075  
646 0 0 7 610 2075 1517 0 0 1 4 this 3 2251  
647 0 0 6 611 2142 0 0 0 1 4 this 3 2075  
648 0 0 7 612 2075 1517 0 0 1 4 this 3 2142  
649 0 0 6 613 2221 0 0 0 1 4 this 3 2075  
650 0 0 7 614 2075 1517 0 0 1 4 this 3 2221  
651 0 0 7 784 2076 1679 0 10 /**
 *
 */ 1 4 copy 1 2256  
652 0 0 7 784 2076 1679 0 10 /**
 *
 */ 1 9 mref_name 1 2128  
653 0 0 6 786 2038 0 0 411 /**
 * Returns true if the two materials are equivalent in all relevant properties
 * (according to eq), false otherwise.
 *
 * The Equivalence parameter, eq, should be set to the bitwise OR of the
 * following properties, according to what you consider relevant:
 *
 * EggMaterial::E_attributes: All material attributes (diff, spec, etc.)
 * except MRef name.
 *
 * EggMaterial::E_mref_name: The MRef name.
 */ 3 4 this 3 2256  5 other 1 2256  2 eq 1 2068  
654 0 0 6 787 2038 0 0 226 /**
 * An ordering operator to compare two materials for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique materials,
 * according to the indicated Equivalence factor.  See is_equivalent_to().
 */ 3 4 this 3 2256  5 other 1 2256  2 eq 1 2068  
655 0 0 4 788 2124 0 0 10 /**
 *
 */ 2 4 this 3 2076  4 base 1 2156  
656 0 0 4 789 2124 0 0 10 /**
 *
 */ 1 4 this 3 2076  
657 0 0 6 790 2038 0 0 10 /**
 *
 */ 1 4 this 3 2256  
658 0 0 7 791 2155 0 0 122 /**
 * It is legal to call this even if has_base() returns false.  If so, it
 * simply returns the default base color.
 */ 1 4 this 3 2256  
659 0 0 4 792 2124 0 0 10 /**
 *
 */ 2 4 this 3 2076  4 diff 1 2156  
660 0 0 4 793 2124 0 0 10 /**
 *
 */ 1 4 this 3 2076  
661 0 0 6 794 2038 0 0 10 /**
 *
 */ 1 4 this 3 2256  
662 0 0 7 795 2155 0 0 122 /**
 * It is legal to call this even if has_diff() returns false.  If so, it
 * simply returns the default diff color.
 */ 1 4 this 3 2256  
663 0 0 4 796 2124 0 0 10 /**
 *
 */ 2 4 this 3 2076  3 amb 1 2156  
664 0 0 4 797 2124 0 0 10 /**
 *
 */ 1 4 this 3 2076  
665 0 0 6 798 2038 0 0 10 /**
 *
 */ 1 4 this 3 2256  
666 0 0 7 799 2155 0 0 120 /**
 * It is legal to call this even if has_amb() returns false.  If so, it simply
 * returns the default amb color.
 */ 1 4 this 3 2256  
667 0 0 4 800 2124 0 0 10 /**
 *
 */ 2 4 this 3 2076  4 emit 1 2156  
668 0 0 4 801 2124 0 0 10 /**
 *
 */ 1 4 this 3 2076  
669 0 0 6 802 2038 0 0 10 /**
 *
 */ 1 4 this 3 2256  
670 0 0 7 803 2155 0 0 122 /**
 * It is legal to call this even if has_emit() returns false.  If so, it
 * simply returns the default emit color.
 */ 1 4 this 3 2256  
671 0 0 4 804 2124 0 0 10 /**
 *
 */ 2 4 this 3 2076  4 spec 1 2156  
672 0 0 4 805 2124 0 0 10 /**
 *
 */ 1 4 this 3 2076  
673 0 0 6 806 2038 0 0 10 /**
 *
 */ 1 4 this 3 2256  
674 0 0 7 807 2155 0 0 122 /**
 * It is legal to call this even if has_spec() returns false.  If so, it
 * simply returns the default spec color.
 */ 1 4 this 3 2256  
675 0 0 4 808 2124 0 0 10 /**
 *
 */ 2 4 this 3 2076  9 shininess 1 2039  
676 0 0 4 809 2124 0 0 10 /**
 *
 */ 1 4 this 3 2076  
677 0 0 6 810 2038 0 0 10 /**
 *
 */ 1 4 this 3 2256  
678 0 0 6 811 2039 0 0 10 /**
 *
 */ 1 4 this 3 2256  
679 0 0 4 812 2124 0 0 10 /**
 *
 */ 2 4 this 3 2076  9 roughness 1 2039  
680 0 0 4 813 2124 0 0 10 /**
 *
 */ 1 4 this 3 2076  
681 0 0 6 814 2038 0 0 10 /**
 *
 */ 1 4 this 3 2256  
682 0 0 6 815 2039 0 0 10 /**
 *
 */ 1 4 this 3 2256  
683 0 0 4 816 2124 0 0 10 /**
 *
 */ 2 4 this 3 2076  8 metallic 1 2039  
684 0 0 4 817 2124 0 0 10 /**
 *
 */ 1 4 this 3 2076  
685 0 0 6 818 2038 0 0 10 /**
 *
 */ 1 4 this 3 2256  
686 0 0 6 819 2039 0 0 10 /**
 *
 */ 1 4 this 3 2256  
687 0 0 4 820 2124 0 0 10 /**
 *
 */ 2 4 this 3 2076  3 ior 1 2039  
688 0 0 4 821 2124 0 0 10 /**
 *
 */ 1 4 this 3 2076  
689 0 0 6 822 2038 0 0 10 /**
 *
 */ 1 4 this 3 2256  
690 0 0 6 823 2039 0 0 10 /**
 *
 */ 1 4 this 3 2256  
691 0 0 4 824 2124 0 0 10 /**
 *
 */ 2 4 this 3 2076  5 local 1 2038  
692 0 0 4 825 2124 0 0 10 /**
 *
 */ 1 4 this 3 2076  
693 0 0 6 826 2038 0 0 10 /**
 *
 */ 1 4 this 3 2256  
694 0 0 6 827 2038 0 0 10 /**
 *
 */ 1 4 this 3 2256  
695 0 0 7 838 2120 0 0 0 0 
696 0 0 7 848 2199 1687 0 10 /**
 *
 */ 2 4 this 3 2199  4 copy 1 2192  
697 0 0 7 850 2199 1687 0 0 1 4 this 3 2192  
698 0 0 6 851 2142 0 0 271 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this primitive that has an
 * alpha_mode other than AM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2199  
699 0 0 6 852 2142 0 0 272 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * depth_write_mode other than DWM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2199  
700 0 0 6 853 2142 0 0 271 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * depth_test_mode other than DTM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2199  
701 0 0 6 854 2142 0 0 270 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * visibility_mode other than VM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2199  
702 0 0 6 855 2142 0 0 256 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this primitive that has a
 * depth_offset specified.  Returns a valid EggRenderMode pointer if one is
 * found, or NULL otherwise.
 */ 1 4 this 3 2199  
703 0 0 6 856 2142 0 0 254 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this primitive that has a
 * draw_order specified.  Returns a valid EggRenderMode pointer if one is
 * found, or NULL otherwise.
 */ 1 4 this 3 2199  
704 0 0 6 857 2142 0 0 247 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this primitive that has a bin
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */ 1 4 this 3 2199  
705 0 0 6 858 2128 0 0 223 /**
 * Returns the name of the primitive for the purposes of sorting primitives
 * into different groups, if there is one.
 *
 * Presently, this is defined as the primitive name itself, unless it begins
 * with a digit.
 */ 1 4 this 3 2192  
706 0 0 6 859 2074 0 0 696 /**
 * Returns the shading properties apparent on this particular primitive.  This
 * returns S_per_vertex if the vertices have colors or normals (and they are
 * not all the same values), or for a simple primitive, S_overall otherwise.
 * A composite primitive may also return S_per_face if the individual
 * component primitives have colors or normals that are not all the same
 * values.
 *
 * To get the most accurate results, you should call clear_shading() on all
 * connected primitives (or on all primitives in the egg file), followed by
 * get_shading() on each primitive.  You may find it easiest to call these
 * methods on the EggData root node (they are defined on EggGroupNode).
 */ 1 4 this 3 2192  
707 0 0 4 860 2124 0 0 128 /**
 * Resets the connected_shading member in this primitive, so that
 * get_connected_shading() will recompute a new value.
 */ 1 4 this 3 2199  
708 0 0 6 861 2074 0 0 479 /**
 * Determines what sort of shading properties this primitive's connected
 * neighbors have.
 *
 * To get the most accurate results, you should first call
 * clear_connected_shading() on all connected primitives (or on all primitives
 * in the egg file). It might also be a good idea to call
 * remove_unused_vertices() to ensure proper connectivity.
 *
 * You may find it easiest to call these other methods on the EggData root
 * node (they are defined on EggGroupNode).
 */ 1 4 this 3 2192  
709 0 0 4 862 2124 0 0 217 /**
 * Replaces the current list of textures with the indicated texture.
 *
 * This method is deprecated and is used in support of single-texturing only.
 * Please use the multitexture variant add_texture instead.
 */ 2 4 this 3 2199  7 texture 1 2075  
710 0 0 6 863 2038 0 0 238 /**
 * Returns true if the primitive has any textures specified, false otherwise.
 *
 * This method is deprecated and is used in support of single-texturing only.
 * New code should be written to use the multitexture variants instead.
 */ 1 4 this 3 2192  
711 0 0 6 863 2038 0 0 98 /**
 * Returns true if the primitive has the particular indicated texture, false
 * otherwise.
 */ 2 4 this 3 2192  7 texture 1 2075  
712 0 0 7 864 2075 1517 0 269 /**
 * Returns the first texture on the primitive, if any, or NULL if there are no
 * textures on the primitive.
 *
 * This method is deprecated and is used in support of single-texturing only.
 * New code should be written to use the multitexture variants instead.
 */ 1 4 this 3 2192  
713 0 0 7 864 2075 1517 0 74 /**
 * Returns the nth texture that has been applied to the primitive.
 */ 2 4 this 3 2192  1 n 1 2068  
714 0 0 4 865 2124 0 0 276 /**
 * Applies the indicated texture to the primitive.
 *
 * Note that, in the case of multiple textures being applied to a single
 * primitive, the order in which the textures are applied does not affect the
 * rendering order; use EggTexture::set_sort() to specify that.
 */ 2 4 this 3 2199  7 texture 1 2075  
715 0 0 4 866 2124 0 0 52 /**
 * Removes any texturing from the primitive.
 */ 1 4 this 3 2199  
716 0 0 6 867 2068 0 0 67 /**
 * Returns the number of textures applied to the primitive.
 */ 1 4 this 3 2192  
717 0 0 4 869 2124 0 0 59 /**
 * Applies the indicated material to the primitive.
 */ 2 4 this 3 2199  8 material 1 2076  
718 0 0 4 870 2124 0 0 51 /**
 * Removes any material from the primitive.
 */ 1 4 this 3 2199  
719 0 0 7 871 2076 1679 0 97 /**
 * Returns a pointer to the applied material, or NULL if there is no material
 * applied.
 */ 1 4 this 3 2192  
720 0 0 6 872 2038 0 0 160 /**
 * Returns true if the primitive is materiald (and get_material() will return
 * a real pointer), false otherwise (and get_material() will return NULL).
 */ 1 4 this 3 2192  
721 0 0 4 873 2124 0 0 204 /**
 * Sets the backfacing flag of the polygon.  If this is true, the polygon will
 * be rendered so that both faces are visible; if it is false, only the front
 * face of the polygon will be visible.
 */ 2 4 this 3 2199  4 flag 1 2038  
722 0 0 6 874 2038 0 0 79 /**
 * Retrieves the backfacing flag of the polygon.  See set_bface_flag().
 */ 1 4 this 3 2192  
723 0 0 4 883 2124 0 0 72 /**
 * Copies the rendering attributes from the indicated primitive.
 */ 2 4 this 3 2199  5 other 1 2149  
724 0 0 4 883 2124 0 0 72 /**
 * Copies the rendering attributes from the indicated primitive.
 */ 2 4 this 3 2199  5 other 1 2192  
725 0 0 6 884 2038 0 0 295 /**
 * Returns true if any vertex on the primitive has a specific normal set,
 * false otherwise.
 *
 * If you call unify_attributes() first, this will also return false even if
 * all the vertices were set to the same value (since unify_attributes()
 * removes redundant vertex properties).
 */ 1 4 this 3 2192  
726 0 0 6 885 2038 0 0 294 /**
 * Returns true if any vertex on the primitive has a specific color set, false
 * otherwise.
 *
 * If you call unify_attributes() first, this will also return false even if
 * all the vertices were set to the same value (since unify_attributes()
 * removes redundant vertex properties).
 */ 1 4 this 3 2192  
727 0 0 4 886 2124 0 0 766 /**
 * If the shading property is S_per_vertex, ensures that all vertices have a
 * normal and a color, and the overall primitive does not.
 *
 * If the shading property is S_per_face, and this is a composite primitive,
 * ensures that all components have a normal and a color, and the vertices and
 * overall primitive do not.  (If this is a simple primitive, S_per_face works
 * the same as S_overall, below).
 *
 * If the shading property is S_overall, ensures that no vertices or
 * components have a normal or a color, and the overall primitive does (if any
 * exists at all).
 *
 * After this call, either the primitive will have normals or its vertices
 * will, but not both.  Ditto for colors.
 *
 * This may create redundant vertices in the vertex pool.
 */ 2 4 this 3 2199  7 shading 1 2074  
728 0 0 4 887 2124 0 0 350 /**
 * Sets the last vertex of the triangle (or each component) to the primitive
 * normal and/or color, if the primitive is flat-shaded.  This reflects the
 * OpenGL convention of storing flat-shaded properties on the last vertex,
 * although it is not usually a convention in Egg.
 *
 * This may introduce redundant vertices to the vertex pool.
 */ 1 4 this 3 2199  
729 0 0 4 888 2124 0 0 353 /**
 * Sets the first vertex of the triangle (or each component) to the primitive
 * normal and/or color, if the primitive is flat-shaded.  This reflects the
 * DirectX convention of storing flat-shaded properties on the first vertex,
 * although it is not usually a convention in Egg.
 *
 * This may introduce redundant vertices to the vertex pool.
 */ 1 4 this 3 2199  
730 0 0 4 889 2124 0 0 217 /**
 * Intended as a followup to apply_last_attribute(), this also sets an
 * attribute on the first vertices of the primitive, if they don't already
 * have an attribute set, just so they end up with *something*.
 */ 1 4 this 3 2199  
731 0 0 4 890 2124 0 0 201 /**
 * Reverses the ordering of the vertices in this primitive, if appropriate, in
 * order to change the direction the polygon appears to be facing.  Does not
 * adjust the surface normal, if any.
 */ 1 4 this 3 2199  
732 0 0 6 891 2038 0 0 272 /**
 * Cleans up modeling errors in whatever context this makes sense.  For
 * instance, for a polygon, this calls remove_doubled_verts(true).  For a
 * point, it calls remove_nonunique_verts().  Returns true if the primitive is
 * valid, or false if it is degenerate.
 */ 1 4 this 3 2199  
733 0 0 4 892 2124 0 0 559 /**
 * Certain kinds of primitives, particularly polygons, don't like to have the
 * same vertex repeated consecutively.  Unfortunately, some modeling programs
 * (like MultiGen) make this an easy mistake to make.
 *
 * It's handy to have a function to remove these redundant vertices.  If
 * closed is true, it also checks that the first and last vertices are not the
 * same.
 *
 * This function identifies repeated vertices by position only; it does not
 * consider any other properties, such as color or UV, significant in
 * differentiating vertices.
 */ 2 4 this 3 2199  6 closed 1 2038  
734 0 0 4 893 2124 0 0 256 /**
 * Removes any multiple appearances of the same vertex from the primitive.
 * This primarily makes sense for a point primitive, which is really a
 * collection of points and which doesn't make sense to include the same point
 * twice, in any order.
 */ 1 4 this 3 2199  
735 0 0 6 894 2038 0 0 124 /**
 * Returns true if there are any primitives (e.g.  polygons) defined within
 * this group or below, false otherwise.
 */ 1 4 this 3 2192  
736 0 0 6 895 2038 0 0 154 /**
 * Returns true if there are any primitives (e.g.  polygons) defined within
 * this group or below, but the search does not include nested joints.
 */ 1 4 this 3 2192  
737 0 0 6 896 2038 0 0 164 /**
 * Returns true if any of the primitives (e.g.  polygons) defined within this
 * group or below have either face or vertex normals defined, false otherwise.
 */ 1 4 this 3 2192  
738 0 0 4 897 2124 0 0 58 /**
 * Removes all of the vertices from the primitive.
 */ 1 4 this 3 2199  
739 0 0 7 898 2077 1150 0 103 /**
 * Adds the indicated vertex to the end of the primitive's list of vertices,
 * and returns it.
 */ 2 4 this 3 2199  6 vertex 1 2077  
740 0 0 7 899 2077 1150 0 157 /**
 * Removes the indicated vertex from the primitive and returns it.  If the
 * vertex was not already in the primitive, does nothing and returns NULL.
 */ 2 4 this 3 2199  6 vertex 1 2077  
741 0 0 4 899 2124 0 0 59 /**
 * Removes the indicated vertex from the primitive.
 */ 2 4 this 3 2199  5 index 1 2258  
742 0 0 4 900 2124 0 0 123 /**
 * Replaces the current primitive's list of vertices with a copy of the list
 * of vertices on the other primitive.
 */ 2 4 this 3 2199  5 other 1 2192  
743 0 0 6 901 2258 0 0 63 // These are shorthands if you don't want to use the iterators. 1 4 this 3 2192  
744 0 0 4 902 2124 0 0 187 /**
 * Replaces a particular vertex based on its index number in the list of
 * vertices.  This is just a convenience function for people who don't want to
 * mess with the iterators.
 */ 3 4 this 3 2199  5 index 1 2258  6 vertex 1 2077  
745 0 0 7 903 2077 1150 0 64 /**
 * Returns a particular index based on its index number.
 */ 2 4 this 3 2192  5 index 1 2258  
746 0 0 7 905 2078 1063 0 126 /**
 * Returns the vertex pool associated with the vertices of the primitive, or
 * NULL if the primitive has no vertices.
 */ 1 4 this 3 2192  
747 0 0 4 910 2124 0 0 0 3 4 this 3 2192  3 out 1 2129  12 indent_level 1 2068  
748 0 0 4 911 2124 0 0 0 1 4 this 3 2192  
749 0 0 7 912 2120 0 0 0 0 
750 0 0 7 841 2132 1063 0 0 1 4 this 3 2199  
751 0 0 7 842 2199 1687 0 0 1 4 this 3 2132  
752 0 0 6 843 2080 0 0 0 1 4 this 3 2199  
753 0 0 7 844 2199 1687 0 0 1 4 this 3 2080  
754 0 0 6 845 2142 0 0 0 1 4 this 3 2199  
755 0 0 7 846 2199 1687 0 0 1 4 this 3 2142  
756 0 0 7 914 2259 1687 0 10 /**
 *
 */ 2 4 this 3 2259  4 copy 1 2260  
757 0 0 6 915 2068 0 0 148 /**
 * Returns the number of individual component triangles within the composite.
 * Each one of these might have a different set of attributes.
 */ 1 4 this 3 2260  
758 0 0 6 916 2080 0 0 65 /**
 * Returns the attributes for the nth component triangle.
 */ 2 4 this 3 2259  1 i 1 2068  
759 0 0 6 916 2149 0 0 65 /**
 * Returns the attributes for the nth component triangle.
 */ 2 4 this 3 2260  1 i 1 2068  
760 0 0 4 918 2124 0 0 65 /**
 * Changes the attributes for the nth component triangle.
 */ 3 4 this 3 2259  1 i 1 2068  6 attrib 1 2149  
761 0 0 6 921 2038 0 0 361 /**
 * Subdivides the composite primitive into triangles and adds those triangles
 * to the indicated container.  Does not remove the primitive from its
 * existing parent or modify it in any way.
 *
 * Returns true if the triangulation is successful, or false if there was some
 * error (in which case the container may contain some partial triangulation).
 */ 2 4 this 3 2260  9 container 1 2135  
762 0 0 7 922 2259 1687 0 460 /**
 * Subdivides the composite primitive into triangles and adds those triangles
 * to the parent group node in place of the original primitive.  Returns a
 * pointer to the original primitive, which is likely about to be destructed.
 *
 * If convex_also is true, both concave and convex polygons will be subdivided
 * into triangles; otherwise, only concave polygons will be subdivided, and
 * convex polygons will be copied unchanged into the container.
 */ 1 4 this 3 2259  
763 0 0 7 923 2120 0 0 0 0 
764 0 0 7 925 2262 1766 0 10 /**
 *
 */ 0 
765 0 0 7 925 2262 1766 0 10 /**
 *
 */ 1 4 copy 1 2263  
766 0 0 7 926 2262 1766 0 10 /**
 *
 */ 2 4 this 3 2262  4 copy 1 2263  
767 0 0 6 927 2038 0 0 212 /**
 * Looks for the indicated filename, first along the indicated searchpath, and
 * then along the model_path.  If found, updates the filename to the full path
 * and returns true; otherwise, returns false.
 */ 2 12 egg_filename 1 2265  10 searchpath 1 2206  
768 0 0 6 928 2038 0 0 291 /**
 * Opens the indicated filename and reads the egg data contents from it.
 * Returns true if the file was successfully opened and read, false if there
 * were some errors, in which case the data may be partially read.
 *
 * error is the output stream to which to write error messages.
 */ 3 4 this 3 2262  8 filename 1 2265  12 display_name 1 2128  
769 0 0 6 928 2038 0 0 442 /**
 * Parses the egg syntax contained in the indicated input stream.  Returns
 * true if the stream was a completely valid egg file, false if there were
 * some errors, in which case the data may be partially read.
 *
 * Before you call this routine, you should probably call set_egg_filename()
 * to set the name of the egg file we're processing, if at all possible.  If
 * there is no such filename, you may set it to the empty string.
 */ 2 4 this 3 2262  2 in 1 2266  
770 0 0 4 929 2124 0 0 110 /**
 * Appends the other egg structure to the end of this one.  The other egg
 * structure is invalidated.
 */ 2 4 this 3 2262  5 other 1 2262  
771 0 0 6 930 2038 0 0 356 /**
 * Loads up all the egg files referenced by <File> entries within the egg
 * structure, and inserts their contents in place of the <File> entries.
 * Searches for files in the searchpath, if not found directly, and writes
 * error messages to the indicated output stream.  Returns true if all
 * externals were loaded successfully, false otherwise.
 */ 2 4 this 3 2262  10 searchpath 1 2206  
772 0 0 6 930 2038 0 0 356 /**
 * Loads up all the egg files referenced by <File> entries within the egg
 * structure, and inserts their contents in place of the <File> entries.
 * Searches for files in the searchpath, if not found directly, and writes
 * error messages to the indicated output stream.  Returns true if all
 * externals were loaded successfully, false otherwise.
 */ 3 4 this 3 2262  10 searchpath 1 2206  6 record 1 2268  
773 0 0 6 931 2068 0 0 310 /**
 * Removes duplicate references to the same texture image with the same
 * properties.  Considers two texture references with identical properties,
 * but different tref names, to be equivalent, and collapses them, choosing
 * one tref name to keep arbitrarily.  Returns the number of textures removed.
 */ 1 4 this 3 2262  
774 0 0 6 932 2068 0 0 306 /**
 * Removes duplicate references to the same material with the same properties.
 * Considers two material references with identical properties, but different
 * mref names, to be equivalent, and collapses them, choosing one mref name to
 * keep arbitrarily.  Returns the number of materials removed.
 */ 1 4 this 3 2262  
775 0 0 6 933 2038 0 0 61 /**
 * The main interface for writing complete egg files.
 */ 2 4 this 3 2262  8 filename 1 2265  
776 0 0 6 933 2038 0 0 61 /**
 * The main interface for writing complete egg files.
 */ 2 4 this 3 2262  3 out 1 2129  
777 0 0 4 934 2124 0 0 147 /**
 * Indicates whether the EggData object will automatically resolve any
 * external references when read() is called.  The default is false.
 */ 2 4 this 3 2262  7 resolve 1 2038  
778 0 0 6 935 2038 0 0 147 /**
 * Indicates whether the EggData object will automatically resolve any
 * external references when read() is called.  The default is false.
 */ 1 4 this 3 2263  
779 0 0 6 936 2038 0 0 411 /**
 * Returns true if the data processed in the last call to read() contained
 * absolute pathnames, or false if those pathnames were all relative.
 *
 * This method is necessary because if auto_resolve_externals() is in effect,
 * it may modify the pathnames to be absolute whether or not they were as
 * loaded from disk.  This method can be used to query the state of the
 * original egg file from disk.
 */ 1 4 this 3 2263  
780 0 0 4 937 2124 0 0 156 /**
 * Changes the coordinate system of the EggData.  If the coordinate system was
 * previously different, this may result in a conversion of the data.
 */ 2 4 this 3 2262  8 coordsys 1 2210  
781 0 0 6 938 2210 0 0 74 /**
 * Returns the coordinate system in which the egg file is defined.
 */ 1 4 this 3 2263  
782 0 0 4 939 2124 0 0 150 /**
 * Sets the filename--especially the directory part--in which the egg file is
 * considered to reside.  This is also implicitly set by read().
 */ 2 4 this 3 2262  12 egg_filename 1 2209  
783 0 0 6 940 2209 0 0 79 /**
 * Returns the directory in which the egg file is considered to reside.
 */ 1 4 this 3 2263  
784 0 0 4 941 2124 0 0 136 /**
 * Sets the timestamp of the egg file on disk, at the time it was opened for
 * reading.  This is also implicitly set by read().
 */ 2 4 this 3 2262  13 egg_timestamp 1 2270  
785 0 0 6 942 2270 0 0 142 /**
 * Returns the timestamp of the egg file on disk, at the time it was opened
 * for reading, or 0 if this information is not available.
 */ 1 4 this 3 2263  
786 0 0 4 943 2124 0 0 711 /**
 * Recomputes all the vertex normals for polygon geometry at this group node
 * and below so that they accurately reflect the vertex positions.  A shared
 * edge between two polygons (even in different groups) is considered smooth
 * if the angle between the two edges is less than threshold degrees.
 *
 * This function also removes degenerate polygons that do not have enough
 * vertices to define a normal.  It does not affect normals for other kinds of
 * primitives like Nurbs or Points.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the correct normals.  Thus, it is a good idea
 * to call remove_unused_vertices() after calling this.
 */ 2 4 this 3 2262  9 threshold 1 2039  
787 0 0 4 944 2124 0 0 672 /**
 * Recomputes all the polygon normals for polygon geometry at this group node
 * and below so that they accurately reflect the vertex positions.  Normals
 * are removed from the vertices and defined only on polygons, giving the
 * geometry a faceted appearance.
 *
 * This function also removes degenerate polygons that do not have enough
 * vertices to define a normal.  It does not affect normals for other kinds of
 * primitives like Nurbs or Points.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the normals removed.  Thus, it is a good idea
 * to call remove_unused_vertices() after calling this.
 */ 1 4 this 3 2262  
788 0 0 4 945 2124 0 0 317 /**
 * Removes all normals from primitives, and the vertices they reference, at
 * this node and below.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the normal removed.  Thus, it is a good idea to
 * call remove_unused_vertices() after calling this.
 */ 1 4 this 3 2262  
789 0 0 7 946 2120 0 0 0 0 
790 0 0 7 949 2272 1771 0 10 /**
 *
 */ 1 5 value 1 2210  
791 0 0 7 949 2272 1771 0 10 /**
 *
 */ 1 4 copy 1 2273  
792 0 0 4 950 2124 0 0 10 /**
 *
 */ 2 4 this 3 2272  5 value 1 2210  
793 0 0 6 951 2210 0 0 10 /**
 *
 */ 1 4 this 3 2273  
794 0 0 7 952 2120 0 0 0 0 
795 0 0 7 955 2275 1779 0 10 /**
 *
 */ 2 4 this 3 2275  4 copy 1 2276  
796 0 0 4 957 2124 0 0 276 /**
 * Sets the number of subdivisions that will be requested across the curve.
 * (This doesn't necessary guarantee that this number of subdivisions will be
 * made; it's just a hint to any curve renderer or quick tesselator.)  Set the
 * number to 0 to disable the hint.
 */ 2 4 this 3 2275  6 subdiv 1 2068  
797 0 0 6 958 2068 0 0 115 /**
 * Returns the requested number of subdivisions, or 0 if no particular
 * subdivisions have been requested.
 */ 1 4 this 3 2276  
798 0 0 4 959 2124 0 0 126 /**
 * Sets the type of the curve.  This is primarily used as a hint to any code
 * that may need to deal with this curve.
 */ 2 4 this 3 2275  4 type 1 2084  
799 0 0 6 960 2084 0 0 51 /**
 * Returns the indicated type of the curve.
 */ 1 4 this 3 2276  
800 0 0 6 961 2084 0 0 163 /**
 * Returns the CurveType value associated with the given string
 * representation, or CT_invalid if the string does not match any known
 * CurveType value.
 */ 1 6 string 1 2128  
801 0 0 7 962 2120 0 0 0 0 
802 0 0 7 965 2280 1783 0 10 /**
 *
 */ 1 4 copy 1 2278  
803 0 0 7 965 2280 1783 0 10 /**
 *
 */ 2 9 node_name 1 2128  8 filename 1 2128  
804 0 0 7 966 2280 1783 0 10 /**
 *
 */ 2 4 this 3 2280  4 copy 1 2278  
805 0 0 7 967 2120 0 0 0 0 
806 0 0 4 970 2124 0 0 86 /**
 * Empties the table of used named and prepares the Uniquifier for a new tree.
 */ 1 4 this 3 2281  
807 0 0 4 971 2124 0 0 56 /**
 * Begins the traversal from the indicated node.
 */ 2 4 this 3 2281  4 node 1 2132  
808 0 0 7 972 2132 1063 0 114 /**
 * Returns the node associated with the given category and name, or NULL if
 * the name has not been used.
 */ 3 4 this 3 2282  8 category 1 2128  4 name 1 2128  
809 0 0 6 973 2038 0 0 105 /**
 * Returns true if the name has been used for the indicated category already,
 * false otherwise.
 */ 3 4 this 3 2282  8 category 1 2128  4 name 1 2128  
810 0 0 6 974 2038 0 0 219 /**
 * Adds the name to the indicated category.  This name will not be used for
 * any other egg node within this category.  Returns true if the name was
 * added, or false if it was already in use for the category.
 */ 4 4 this 3 2281  8 category 1 2128  4 name 1 2128  4 node 1 2132  
811 0 0 6 975 2128 0 0 0 2 4 this 3 2281  4 node 1 2132  
812 0 0 6 976 2128 0 0 216 /**
 * Returns the name of the given node, or at least the name it should be.
 * This provides a hook to adjust the name before attempting to uniquify it,
 * if desired, for instance to remove invalid characters.
 */ 2 4 this 3 2281  4 node 1 2132  
813 0 0 6 977 2128 0 0 365 /**
 * Generates a new name for the given node when its existing name clashes with
 * some other node.  This function will be called repeatedly, if necessary,
 * until it returns a name that actually is unique.
 *
 * The category is the string returned by get_category(), and index is a
 * uniquely-generated number that may be useful for synthesizing the name.
 */ 4 4 this 3 2281  4 node 1 2132  8 category 1 2128  5 index 1 2068  
814 0 0 7 978 2120 0 0 0 0 
815 0 0 7 980 2284 1795 0 254 /**
 * If filter_names is true, then the group names will be coerced into a fairly
 * safe, standard convention that uses no characters other than a-z, A-Z, 0-9,
 * and underscore.  If filter_names is false, the group names will be left
 * unchanged.
 */ 1 12 filter_names 1 2038  
816 0 0 7 981 2120 0 0 0 0 
817 0 0 7 984 2285 1687 0 10 /**
 *
 */ 2 4 this 3 2285  4 copy 1 2286  
818 0 0 7 985 2285 1687 0 0 1 4 this 3 2285  
819 0 0 6 986 2038 0 0 10 /**
 *
 */ 1 4 this 3 2286  
820 0 0 6 987 2039 0 0 108 /**
 * Returns the thickness set on this particular line.  If there is no
 * thickness set, returns 1.0.
 */ 1 4 this 3 2286  
821 0 0 4 988 2124 0 0 10 /**
 *
 */ 2 4 this 3 2285  5 thick 1 2039  
822 0 0 4 989 2124 0 0 10 /**
 *
 */ 1 4 this 3 2285  
823 0 0 7 990 2120 0 0 0 0 
824 0 0 7 992 2288 1805 0 10 /**
 *
 */ 0 
825 0 0 7 992 2288 1805 0 10 /**
 *
 */ 1 4 copy 1 2289  
826 0 0 6 993 2288 0 0 10 /**
 *
 */ 2 4 this 3 2288  4 copy 1 2289  
827 0 0 4 995 2124 0 0 53 /**
 * Removes all materials from the collection.
 */ 1 4 this 3 2288  
828 0 0 6 996 2068 0 0 211 /**
 * Walks the egg hierarchy beginning at the indicated node, and removes any
 * EggMaterials encountered in the hierarchy, adding them to the collection.
 * Returns the number of EggMaterials encountered.
 */ 2 4 this 3 2288  4 node 1 2135  
829 0 0 6 997 2068 0 0 903 /**
 * Walks the egg hierarchy beginning at the indicated node, looking for
 * materials that are referenced by primitives but are not already members of
 * the collection, adding them to the collection.
 *
 * If this is called following extract_materials(), it can be used to pick up
 * any additional material references that appeared in the egg hierarchy (but
 * whose EggMaterial node was not actually part of the hierarchy).
 *
 * If this is called in lieu of extract_materials(), it will fill up the
 * collection with all of the referenced materials (and only the referenced
 * materials), without destructively removing the EggMaterials from the
 * hierarchy.
 *
 * This also has the side effect of incrementing the internal usage count for
 * a material in the collection each time a material reference is encountered.
 * This side effect is taken advantage of by remove_unused_materials().
 */ 2 4 this 3 2288  4 node 1 2132  
830 0 0 4 998 2124 0 0 283 /**
 * Removes any materials from the collection that aren't referenced by any
 * primitives in the indicated egg hierarchy.  This also, incidentally, adds
 * materials to the collection that had been referenced by primitives but had
 * not previously appeared in the collection.
 */ 2 4 this 3 2288  4 node 1 2132  
831 0 0 6 999 2068 0 0 414 /**
 * Walks through the collection and collapses together any separate materials
 * that are equivalent according to the indicated equivalence factor, eq (see
 * EggMaterial::is_equivalent_to()).  The return value is the number of
 * materials removed.
 *
 * This flavor of collapse_equivalent_materials() automatically adjusts all
 * the primitives in the egg hierarchy to refer to the new material pointers.
 */ 3 4 this 3 2288  2 eq 1 2068  4 node 1 2135  
832 0 0 6 999 2068 0 0 634 /**
 * Walks through the collection and collapses together any separate materials
 * that are equivalent according to the indicated equivalence factor, eq (see
 * EggMaterial::is_equivalent_to()).  The return value is the number of
 * materials removed.
 *
 * This flavor of collapse_equivalent_materials() does not adjust any
 * primitives in the egg hierarchy; instead, it fills up the 'removed' map
 * with an entry for each removed material, mapping it back to the equivalent
 * retained material.  It's up to the user to then call replace_materials()
 * with this map, if desired, to apply these changes to the egg hierarchy.
 */ 3 4 this 3 2288  2 eq 1 2068  7 removed 1 2291  
833 0 0 4 1000 2124 0 0 300 /**
 * Walks the egg hierarchy, changing out any reference to a material appearing
 * on the left side of the map with its corresponding material on the right
 * side.  This is most often done following a call to
 * collapse_equivalent_materials().  It does not directly affect the
 * Collection.
 */ 2 4 node 1 2135  7 replace 1 2294  
834 0 0 4 1001 2124 0 0 131 /**
 * Guarantees that each material in the collection has a unique MRef name.
 * This is essential before writing an egg file.
 */ 1 4 this 3 2288  
835 0 0 4 1002 2124 0 0 154 /**
 * Sorts all the materials into alphabetical order by MRef name.  Subsequent
 * operations using begin()/end() will traverse in this sorted order.
 */ 1 4 this 3 2288  
836 0 0 6 1003 2038 0 0 165 /**
 * Explicitly adds a new material to the collection.  Returns true if the
 * material was added, false if it was already there or if there was some
 * error.
 */ 2 4 this 3 2288  8 material 1 2076  
837 0 0 6 1004 2038 0 0 160 /**
 * Explicitly removes a material from the collection.  Returns true if the
 * material was removed, false if it wasn't there or if there was some error.
 */ 2 4 this 3 2288  8 material 1 2076  
838 0 0 7 1005 2076 1679 0 218 // create_unique_material() creates a new material if there is not already
// one equivalent (according to eq, see EggMaterial::is_equivalent_to()) to
// the indicated material, or returns the existing one if there is. 3 4 this 3 2288  4 copy 1 2256  2 eq 1 2068  
839 0 0 7 1006 2076 1679 0 96 /**
 * Returns the material with the indicated MRef name, or NULL if no material
 * matches.
 */ 2 4 this 3 2289  9 mref_name 1 2128  
840 0 0 7 1008 2296 1826 0 10 /**
 *
 */ 2 4 this 3 2296  4 copy 1 2297  
841 0 0 7 1009 2296 1826 0 0 1 4 this 3 2296  
842 0 0 6 1010 2038 0 0 374 /**
 * Calculates the true polygon normal--the vector pointing out of the front of
 * the polygon--based on the vertices.  This does not return or change the
 * polygon's normal as set via set_normal().
 *
 * The return value is true if the normal is computed correctly, or false if
 * the polygon is degenerate and does not have at least three noncollinear
 * vertices.
 */ 3 4 this 3 2297  6 result 1 2299  2 cs 1 2210  
843 0 0 6 1011 2038 0 0 103 /**
 * Returns true if all of the polygon's vertices lie within the same plane,
 * false otherwise.
 */ 1 4 this 3 2297  
844 0 0 6 1012 2038 0 0 210 /**
 * Recalculates the normal according to the order of the vertices, and sets
 * it.  Returns true if the normal is computed correctly, or false if the
 * polygon is degenerate and does not have a normal.
 */ 2 4 this 3 2296  2 cs 1 2210  
845 0 0 6 1013 2038 0 0 656 /**
 * Subdivides the polygon into triangles and adds each one to the indicated
 * container.  If the polygon is already a triangle, adds an exact copy of the
 * polygon to the container.  Does not remove the polygon from its existing
 * parent or modify it in any way.
 *
 * Returns true if the triangulation is successful, or false if there was some
 * error (in which case the container may contain some partial triangulation).
 *
 * If convex_also is true, both concave and convex polygons will be subdivided
 * into triangles; otherwise, only concave polygons will be subdivided, and
 * convex polygons will be copied unchanged into the container.
 */ 3 4 this 3 2297  9 container 1 2135  11 convex_also 1 2038  
846 0 0 7 1014 2296 1826 0 444 /**
 * Subdivides the polygon into triangles and adds those triangles to the
 * parent group node in place of the original polygon.  Returns a pointer to
 * the original polygon, which is likely about to be destructed.
 *
 * If convex_also is true, both concave and convex polygons will be subdivided
 * into triangles; otherwise, only concave polygons will be subdivided, and
 * convex polygons will be copied unchanged into the container.
 */ 2 4 this 3 2296  11 convex_also 1 2038  
847 0 0 7 1015 2120 0 0 0 0 
848 0 0 7 1018 2300 1841 0 10 /**
 *
 */ 2 4 this 3 2300  4 copy 1 2301  
849 0 0 7 1019 2300 1841 0 0 1 4 this 3 2300  
850 0 0 4 1020 2124 0 0 306 /**
 * Prepares a new curve definition with the indicated order and number of
 * knots.  This also implies a particular number of vertices as well (the
 * number of knots minus the order), but it is up to the user to add the
 * correct number of vertices to the curve by repeatedly calling push_back().
 */ 3 4 this 3 2300  5 order 1 2068  9 num_knots 1 2068  
851 0 0 4 1021 2124 0 0 273 /**
 * Directly changes the order to the indicated value (which must be an integer
 * in the range 1 <= order <= 4).  If possible, it is preferable to use the
 * setup() method instead of this method, since changing the order directly
 * may result in an invalid curve.
 */ 2 4 this 3 2300  5 order 1 2068  
852 0 0 4 1022 2124 0 0 361 /**
 * Directly changes the number of knots.  This will either add zero-valued
 * knots onto the end, or truncate knot values from the end, depending on
 * whether the list is being increased or decreased.  If possible, it is
 * preferable to use the setup() method instead of directly setting the number
 * of knots, as this may result in an invalid curve.
 */ 2 4 this 3 2300  3 num 1 2068  
853 0 0 4 1023 2124 0 0 199 /**
 * Resets the value of the indicated knot as indicated.  k must be in the
 * range 0 <= k < get_num_knots(), and the value must be in the range
 * get_knot(k - 1) <= value <= get_knot(k + 1).
 */ 3 4 this 3 2300  1 k 1 2068  5 value 1 2039  
854 0 0 6 1024 2038 0 0 204 /**
 * Returns true if the NURBS parameters are all internally consistent (e.g.
 * it has the right number of vertices to match its number of knots and order
 * in each dimension), or false otherwise.
 */ 1 4 this 3 2301  
855 0 0 6 1025 2068 0 0 215 /**
 * Returns the order of the curve.  The order is the degree of the NURBS
 * equation plus 1; for a typical NURBS, the order is 4.  With this
 * implementation of NURBS, the order must be in the range [1, 4].
 */ 1 4 this 3 2301  
856 0 0 6 1026 2068 0 0 82 /**
 * Returns the degree of the curve.  For a typical NURBS, the degree is 3.
 */ 1 4 this 3 2301  
857 0 0 6 1027 2068 0 0 39 /**
 * Returns the number of knots.
 */ 1 4 this 3 2301  
858 0 0 6 1028 2068 0 0 367 /**
 * Returns the total number of control vertices that *should* be defined for
 * the curve.  This is determined by the number of knots and the order, in
 * each direction; it does not necessarily reflect the number of vertices that
 * have actually been added to the curve.  (However, if the number of vertices
 * in the curve are wrong, the curve is invalid.)
 */ 1 4 this 3 2301  
859 0 0 6 1029 2038 0 0 204 /**
 * Returns true if the curve appears to be closed.  Since the Egg syntax does
 * not provide a means for explicit indication of closure, this has to be
 * guessed at by examining the curve itself.
 */ 1 4 this 3 2301  
860 0 0 6 1030 2039 0 0 46 /**
 * Returns the nth knot value defined.
 */ 2 4 this 3 2301  1 k 1 2068  
861 0 0 7 1036 2120 0 0 0 0 
862 0 0 7 1039 2303 1848 0 10 /**
 *
 */ 2 4 this 3 2303  4 copy 1 2304  
863 0 0 4 1040 2124 0 0 300 /**
 * Sets the number of subdivisions in the U direction that will be requested
 * across the surface.  (This doesn't necessary guarantee that this number of
 * subdivisions will be made; it's just a hint to any surface renderer or
 * quick tesselator.)  Set the number to 0 to disable the hint.
 */ 2 4 this 3 2303  6 subdiv 1 2068  
864 0 0 6 1041 2068 0 0 134 /**
 * Returns the requested number of subdivisions in the U direction, or 0 if no
 * particular subdivisions have been requested.
 */ 1 4 this 3 2304  
865 0 0 4 1042 2124 0 0 300 /**
 * Sets the number of subdivisions in the U direction that will be requested
 * across the surface.  (This doesn't necessary guarantee that this number of
 * subdivisions will be made; it's just a hint to any surface renderer or
 * quick tesselator.)  Set the number to 0 to disable the hint.
 */ 2 4 this 3 2303  6 subdiv 1 2068  
866 0 0 6 1043 2068 0 0 134 /**
 * Returns the requested number of subdivisions in the U direction, or 0 if no
 * particular subdivisions have been requested.
 */ 1 4 this 3 2304  
867 0 0 7 1044 2120 0 0 0 0 
868 0 0 7 1055 2306 1878 0 10 /**
 *
 */ 2 4 this 3 2306  4 copy 1 2307  
869 0 0 7 1056 2306 1878 0 0 1 4 this 3 2306  
870 0 0 4 1057 2124 0 0 349 /**
 * Prepares a new surface definition with the indicated order and number of
 * knots in each dimension.  This also implies a particular number of vertices
 * in each dimension as well (the number of knots minus the order), but it is
 * up to the user to add the correct number of vertices to the surface by
 * repeatedly calling push_back().
 */ 5 4 this 3 2306  7 u_order 1 2068  7 v_order 1 2068  11 num_u_knots 1 2068  11 num_v_knots 1 2068  
871 0 0 4 1058 2124 0 0 296 /**
 * Directly changes the order in the U direction to the indicated value (which
 * must be an integer in the range 1 <= u_order <= 4).  If possible, it is
 * preferable to use the setup() method instead of this method, since changing
 * the order directly may result in an invalid surface.
 */ 2 4 this 3 2306  7 u_order 1 2068  
872 0 0 4 1059 2124 0 0 296 /**
 * Directly changes the order in the V direction to the indicated value (which
 * must be an integer in the range 1 <= v_order <= 4).  If possible, it is
 * preferable to use the setup() method instead of this method, since changing
 * the order directly may result in an invalid surface.
 */ 2 4 this 3 2306  7 v_order 1 2068  
873 0 0 4 1060 2124 0 0 382 /**
 * Directly changes the number of knots in the U direction.  This will either
 * add zero-valued knots onto the end, or truncate knot values from the end,
 * depending on whether the list is being increased or decreased.  If
 * possible, it is preferable to use the setup() method instead of directly
 * setting the number of knots, as this may result in an invalid surface.
 */ 2 4 this 3 2306  3 num 1 2068  
874 0 0 4 1061 2124 0 0 382 /**
 * Directly changes the number of knots in the V direction.  This will either
 * add zero-valued knots onto the end, or truncate knot values from the end,
 * depending on whether the list is being increased or decreased.  If
 * possible, it is preferable to use the setup() method instead of directly
 * setting the number of knots, as this may result in an invalid surface.
 */ 2 4 this 3 2306  3 num 1 2068  
875 0 0 4 1062 2124 0 0 205 /**
 * Resets the value of the indicated knot as indicated.  k must be in the
 * range 0 <= k < get_num_u_knots(), and the value must be in the range
 * get_u_knot(k - 1) <= value <= get_u_knot(k + 1).
 */ 3 4 this 3 2306  1 k 1 2068  5 value 1 2039  
876 0 0 4 1063 2124 0 0 205 /**
 * Resets the value of the indicated knot as indicated.  k must be in the
 * range 0 <= k < get_num_v_knots(), and the value must be in the range
 * get_v_knot(k - 1) <= value <= get_v_knot(k + 1).
 */ 3 4 this 3 2306  1 k 1 2068  5 value 1 2039  
877 0 0 4 1064 2124 0 0 202 /**
 * Redefines the control vertex associated with a particular u, v coordinate
 * pair.  This is just a shorthand to access the EggPrimitive's normal vertex
 * assignment for a 2-d control vertex.
 */ 4 4 this 3 2306  2 ui 1 2068  2 vi 1 2068  6 vertex 1 2077  
878 0 0 6 1065 2038 0 0 204 /**
 * Returns true if the NURBS parameters are all internally consistent (e.g.
 * it has the right number of vertices to match its number of knots and order
 * in each dimension), or false otherwise.
 */ 1 4 this 3 2307  
879 0 0 6 1066 2068 0 0 235 /**
 * Returns the order of the surface in the U direction.  The order is the
 * degree of the NURBS equation plus 1; for a typical NURBS, the order is 4.
 * With this implementation of NURBS, the order must be in the range [1, 4].
 */ 1 4 this 3 2307  
880 0 0 6 1067 2068 0 0 235 /**
 * Returns the order of the surface in the V direction.  The order is the
 * degree of the NURBS equation plus 1; for a typical NURBS, the order is 4.
 * With this implementation of NURBS, the order must be in the range [1, 4].
 */ 1 4 this 3 2307  
881 0 0 6 1068 2068 0 0 106 /**
 * Returns the degree of the surface in the U direction.  For a typical NURBS,
 * the degree is 3.
 */ 1 4 this 3 2307  
882 0 0 6 1069 2068 0 0 106 /**
 * Returns the degree of the surface in the V direction.  for a typical NURBS,
 * the degree is 3.
 */ 1 4 this 3 2307  
883 0 0 6 1070 2068 0 0 58 /**
 * Returns the number of knots in the U direction.
 */ 1 4 this 3 2307  
884 0 0 6 1071 2068 0 0 58 /**
 * Returns the number of knots in the V direction.
 */ 1 4 this 3 2307  
885 0 0 6 1072 2068 0 0 351 /**
 * Returns the number of control vertices that should be present in the U
 * direction.  This is determined by the number of knots and the order; it
 * does not necessarily reflect the number of vertices that have actually been
 * added to the surface.  (However, if the number of vertices in the surface
 * are wrong, the surface is invalid.)
 */ 1 4 this 3 2307  
886 0 0 6 1073 2068 0 0 351 /**
 * Returns the number of control vertices that should be present in the V
 * direction.  This is determined by the number of knots and the order; it
 * does not necessarily reflect the number of vertices that have actually been
 * added to the surface.  (However, if the number of vertices in the surface
 * are wrong, the surface is invalid.)
 */ 1 4 this 3 2307  
887 0 0 6 1074 2068 0 0 375 /**
 * Returns the total number of control vertices that *should* be defined for
 * the surface.  This is determined by the number of knots and the order, in
 * each direction; it does not necessarily reflect the number of vertices that
 * have actually been added to the surface.  (However, if the number of
 * vertices in the surface are wrong, the surface is invalid.)
 */ 1 4 this 3 2307  
888 0 0 6 1075 2068 0 0 265 /**
 * Returns the U index number of the given vertex within the EggPrimitive's
 * linear list of vertices.  An EggNurbsSurface maps a linear list of vertices
 * to its 2-d mesh; this returns the U index number that corresponds to the
 * nth vertex in the list.
 */ 2 4 this 3 2307  12 vertex_index 1 2068  
889 0 0 6 1076 2068 0 0 265 /**
 * Returns the V index number of the given vertex within the EggPrimitive's
 * linear list of vertices.  An EggNurbsSurface maps a linear list of vertices
 * to its 2-d mesh; this returns the V index number that corresponds to the
 * nth vertex in the list.
 */ 2 4 this 3 2307  12 vertex_index 1 2068  
890 0 0 6 1077 2068 0 0 111 /**
 * Returns the index number within the EggPrimitive's list of the control
 * vertex at position ui, vi.
 */ 3 4 this 3 2307  2 ui 1 2068  2 vi 1 2068  
891 0 0 6 1078 2038 0 0 227 /**
 * Returns true if the surface appears to be closed in the U direction.  Since
 * the Egg syntax does not provide a means for explicit indication of closure,
 * this has to be guessed at by examining the surface itself.
 */ 1 4 this 3 2307  
892 0 0 6 1079 2038 0 0 227 /**
 * Returns true if the surface appears to be closed in the V direction.  Since
 * the Egg syntax does not provide a means for explicit indication of closure,
 * this has to be guessed at by examining the surface itself.
 */ 1 4 this 3 2307  
893 0 0 6 1080 2039 0 0 65 /**
 * Returns the nth knot value defined in the U direction.
 */ 2 4 this 3 2307  1 k 1 2068  
894 0 0 6 1082 2039 0 0 65 /**
 * Returns the nth knot value defined in the V direction.
 */ 2 4 this 3 2307  1 k 1 2068  
895 0 0 7 1084 2077 1150 0 68 /**
 * Returns the control vertex at the indicate U, V position.
 */ 3 4 this 3 2307  2 ui 1 2068  2 vi 1 2068  
896 0 0 7 1085 2120 0 0 0 0 
897 0 0 7 1088 2309 1882 0 10 /**
 *
 */ 2 4 this 3 2309  4 copy 1 2310  
898 0 0 7 1089 2309 1882 0 0 1 4 this 3 2309  
899 0 0 7 1090 2120 0 0 0 0 
900 0 0 7 1093 2312 1894 0 10 /**
 *
 */ 2 4 this 3 2312  4 copy 1 2313  
901 0 0 7 1094 2312 1894 0 0 1 4 this 3 2312  
902 0 0 6 1095 2038 0 0 10 /**
 *
 */ 1 4 this 3 2313  
903 0 0 6 1096 2039 0 0 109 /**
 * Returns the thickness set on this particular point.  If there is no
 * thickness set, returns 1.0.
 */ 1 4 this 3 2313  
904 0 0 4 1097 2124 0 0 10 /**
 *
 */ 2 4 this 3 2312  5 thick 1 2039  
905 0 0 4 1098 2124 0 0 10 /**
 *
 */ 1 4 this 3 2312  
906 0 0 6 1099 2038 0 0 10 /**
 *
 */ 1 4 this 3 2313  
907 0 0 6 1100 2038 0 0 125 /**
 * Returns the perspective flag set on this particular point.  If there is no
 * perspective flag set, returns false.
 */ 1 4 this 3 2313  
908 0 0 4 1101 2124 0 0 10 /**
 *
 */ 2 4 this 3 2312  11 perspective 1 2038  
909 0 0 4 1102 2124 0 0 10 /**
 *
 */ 1 4 this 3 2312  
910 0 0 7 1103 2120 0 0 0 0 
911 0 0 7 1108 2315 1898 0 10 /**
 *
 */ 0 
912 0 0 4 1109 2124 0 0 316 /**
 * Sets the set of properties that determines which polygons are allowed to be
 * grouped together into a single polyset.  This is the bitwise 'or' of all
 * the properties that matter.  If this is 0, all polygons (within a given
 * group) will be lumped into a common polyset regardless of their properties.
 */ 2 4 this 3 2315  10 properties 1 2068  
913 0 0 7 1110 2120 0 0 0 0 
914 0 0 7 1113 2316 1901 0 10 /**
 *
 */ 0 
915 0 0 7 1114 2120 0 0 0 0 
916 0 0 7 1117 2319 1909 0 10 /**
 *
 */ 1 4 copy 1 2317  
917 0 0 7 1117 2319 1909 0 10 /**
 *
 */ 1 4 name 1 2128  
918 0 0 7 1118 2319 1909 0 10 /**
 *
 */ 2 4 this 3 2319  4 copy 1 2317  
919 0 0 6 1119 2068 0 0 100 /**
 * Returns the number of rows in the table.  For an SAnim table, each row has
 * one column.
 */ 1 4 this 3 2317  
920 0 0 6 1120 2039 0 0 106 /**
 * Returns the value at the indicated row.  Row must be in the range 0 <= row
 * < get_num_rows().
 */ 2 4 this 3 2317  3 row 1 2068  
921 0 0 4 1121 2124 0 0 106 /**
 * Changes the value at the indicated row.  Row must be in the range 0 <= row
 * < get_num_rows().
 */ 3 4 this 3 2319  3 row 1 2068  5 value 1 2039  
922 0 0 4 1122 2124 0 0 100 /**
 * Optimizes the data by collapsing a long table of duplicate values into a
 * single value.
 */ 1 4 this 3 2319  
923 0 0 7 1123 2120 0 0 0 0 
924 0 0 7 1127 2322 1917 0 10 /**
 *
 */ 1 4 copy 1 2320  
925 0 0 7 1127 2322 1917 0 10 /**
 *
 */ 1 4 name 1 2128  
926 0 0 7 1128 2322 1917 0 10 /**
 *
 */ 2 4 this 3 2322  4 copy 1 2320  
927 0 0 4 1129 2124 0 0 10 /**
 *
 */ 2 4 this 3 2322  4 type 1 2110  
928 0 0 6 1130 2110 0 0 10 /**
 *
 */ 1 4 this 3 2320  
929 0 0 6 1131 2038 0 0 90 /**
 * Returns true if the table contains a transform description, false
 * otherwise.
 */ 1 4 this 3 2320  
930 0 0 6 1132 2110 0 0 163 /**
 * Returns the TableType value associated with the given string
 * representation, or TT_invalid if the string does not match any known
 * TableType value.
 */ 1 6 string 1 2128  
931 0 0 7 1133 2120 0 0 0 0 
932 0 0 7 1136 2323 1920 0 10 /**
 *
 */ 0 
933 0 0 7 1136 2323 1920 0 10 /**
 *
 */ 1 4 copy 1 2324  
934 0 0 6 1137 2323 0 0 10 /**
 *
 */ 2 4 this 3 2323  4 copy 1 2324  
935 0 0 4 1139 2124 0 0 52 /**
 * Removes all textures from the collection.
 */ 1 4 this 3 2323  
936 0 0 6 1140 2068 0 0 209 /**
 * Walks the egg hierarchy beginning at the indicated node, and removes any
 * EggTextures encountered in the hierarchy, adding them to the collection.
 * Returns the number of EggTextures encountered.
 */ 2 4 this 3 2323  4 node 1 2135  
937 0 0 6 1141 2038 0 0 86 /**
 * Returns true if there are no EggTexures in the collection, false otherwise.
 */ 1 4 this 3 2324  
938 0 0 6 1142 2068 0 0 63 /**
 * Returns the number of EggTextures in the collection.
 */ 1 4 this 3 2324  
939 0 0 7 1143 2075 1517 0 56 /**
 * Returns the nth EggTexture in the collection.
 */ 2 4 this 3 2324  5 index 1 2068  
940 0 0 6 1145 2068 0 0 1178 /**
 * Walks the egg hierarchy beginning at the indicated node, looking for
 * textures that are referenced by primitives but are not already members of
 * the collection, adding them to the collection.
 *
 * If this is called following extract_textures(), it can be used to pick up
 * any additional texture references that appeared in the egg hierarchy (but
 * whose EggTexture node was not actually part of the hierarchy).
 *
 * If this is called in lieu of extract_textures(), it will fill up the
 * collection with all of the referenced textures (and only the referenced
 * textures), without destructively removing the EggTextures from the
 * hierarchy.
 *
 * This also has the side effect of incrementing the internal usage count for
 * a texture in the collection each time a texture reference is encountered.
 * This side effect is taken advantage of by remove_unused_textures().
 *
 * And one more side effect: this function identifies the presence of
 * multitexturing in the egg file, and calls multitexture_over() on each
 * texture appropriately so that, after this call, you may expect
 * get_multitexture_sort() to return a reasonable value for each texture.
 */ 2 4 this 3 2323  4 node 1 2132  
941 0 0 4 1146 2124 0 0 281 /**
 * Removes any textures from the collection that aren't referenced by any
 * primitives in the indicated egg hierarchy.  This also, incidentally, adds
 * textures to the collection that had been referenced by primitives but had
 * not previously appeared in the collection.
 */ 2 4 this 3 2323  4 node 1 2132  
942 0 0 6 1147 2068 0 0 409 /**
 * Walks through the collection and collapses together any separate textures
 * that are equivalent according to the indicated equivalence factor, eq (see
 * EggTexture::is_equivalent_to()).  The return value is the number of
 * textures removed.
 *
 * This flavor of collapse_equivalent_textures() automatically adjusts all the
 * primitives in the egg hierarchy to refer to the new texture pointers.
 */ 3 4 this 3 2323  2 eq 1 2068  4 node 1 2135  
943 0 0 6 1147 2068 0 0 627 /**
 * Walks through the collection and collapses together any separate textures
 * that are equivalent according to the indicated equivalence factor, eq (see
 * EggTexture::is_equivalent_to()).  The return value is the number of
 * textures removed.
 *
 * This flavor of collapse_equivalent_textures() does not adjust any
 * primitives in the egg hierarchy; instead, it fills up the 'removed' map
 * with an entry for each removed texture, mapping it back to the equivalent
 * retained texture.  It's up to the user to then call replace_textures() with
 * this map, if desired, to apply these changes to the egg hierarchy.
 */ 3 4 this 3 2323  2 eq 1 2068  7 removed 1 2326  
944 0 0 4 1148 2124 0 0 297 /**
 * Walks the egg hierarchy, changing out any reference to a texture appearing
 * on the left side of the map with its corresponding texture on the right
 * side.  This is most often done following a call to
 * collapse_equivalent_textures().  It does not directly affect the
 * Collection.
 */ 2 4 node 1 2135  7 replace 1 2329  
945 0 0 4 1149 2124 0 0 130 /**
 * Guarantees that each texture in the collection has a unique TRef name.
 * This is essential before writing an egg file.
 */ 1 4 this 3 2323  
946 0 0 4 1150 2124 0 0 153 /**
 * Sorts all the textures into alphabetical order by TRef name.  Subsequent
 * operations using begin()/end() will traverse in this sorted order.
 */ 1 4 this 3 2323  
947 0 0 4 1151 2124 0 0 202 /**
 * Sorts all the textures into alphabetical order by the basename part
 * (including extension) of the filename.  Subsequent operations using
 * begin()/end() will traverse in this sorted order.
 */ 1 4 this 3 2323  
948 0 0 7 1152 2075 1517 0 56 /**
 * Returns the nth EggTexture in the collection.
 */ 2 4 this 3 2324  1 n 1 2331  
949 0 0 6 1153 2331 0 0 63 /**
 * Returns the number of EggTextures in the collection.
 */ 1 4 this 3 2324  
950 0 0 6 1154 2038 0 0 163 /**
 * Explicitly adds a new texture to the collection.  Returns true if the
 * texture was added, false if it was already there or if there was some
 * error.
 */ 2 4 this 3 2323  7 texture 1 2075  
951 0 0 6 1155 2038 0 0 158 /**
 * Explicitly removes a texture from the collection.  Returns true if the
 * texture was removed, false if it wasn't there or if there was some error.
 */ 2 4 this 3 2323  7 texture 1 2075  
952 0 0 7 1156 2075 1517 0 214 // create_unique_texture() creates a new texture if there is not already one
// equivalent (according to eq, see EggTexture::is_equivalent_to()) to the
// indicated texture, or returns the existing one if there is. 3 4 this 3 2323  4 copy 1 2254  2 eq 1 2068  
953 0 0 7 1157 2075 1517 0 94 /**
 * Returns the texture with the indicated TRef name, or NULL if no texture
 * matches.
 */ 2 4 this 3 2324  9 tref_name 1 2128  
954 0 0 7 1158 2075 1517 0 93 /**
 * Returns the texture with the indicated filename, or NULL if no texture
 * matches.
 */ 2 4 this 3 2324  8 filename 1 2209  
955 0 0 7 1160 2332 1687 0 10 /**
 *
 */ 2 4 this 3 2332  4 copy 1 2333  
956 0 0 7 1161 2332 1687 0 0 1 4 this 3 2332  
957 0 0 7 1162 2120 0 0 0 0 
958 0 0 7 1164 2335 1687 0 10 /**
 *
 */ 2 4 this 3 2335  4 copy 1 2336  
959 0 0 7 1165 2335 1687 0 0 1 4 this 3 2335  
960 0 0 7 1166 2120 0 0 0 0 
961 0 0 7 1168 2340 1969 0 84 /**
 * Converts the older-style XfmAnim table to the newer-style XfmSAnim table.
 */ 1 12 convert_from 1 2338  
962 0 0 7 1168 2340 1969 0 10 /**
 *
 */ 1 4 copy 1 2341  
963 0 0 7 1168 2340 1969 0 10 /**
 *
 */ 2 4 name 1 2128  2 cs 1 2210  
964 0 0 7 1169 2340 1969 0 10 /**
 *
 */ 2 4 this 3 2340  4 copy 1 2341  
965 0 0 4 1170 2124 0 0 10 /**
 *
 */ 2 4 this 3 2340  3 fps 1 2039  
966 0 0 4 1171 2124 0 0 10 /**
 *
 */ 1 4 this 3 2340  
967 0 0 6 1172 2038 0 0 10 /**
 *
 */ 1 4 this 3 2341  
968 0 0 6 1173 2039 0 0 56 /**
 * This is only valid if has_fps() returns true.
 */ 1 4 this 3 2341  
969 0 0 4 1174 2124 0 0 10 /**
 *
 */ 2 4 this 3 2340  5 order 1 2128  
970 0 0 4 1175 2124 0 0 10 /**
 *
 */ 1 4 this 3 2340  
971 0 0 6 1176 2038 0 0 10 /**
 *
 */ 1 4 this 3 2341  
972 0 0 6 1177 2128 0 0 10 /**
 *
 */ 1 4 this 3 2341  
973 0 0 6 1178 2128 0 0 178 /**
 * Returns the standard order of matrix component composition.  This is what
 * the order string must be set to in order to use set_value() or add_data()
 * successfully.
 */ 0 
974 0 0 6 1179 2210 0 0 292 /**
 * Returns the coordinate system this table believes it is defined within.
 * This should always match the coordinate system of the EggData structure
 * that owns it.  It is necessary to store it here because the meaning of the
 * h, p, and r columns depends on the coordinate system.
 */ 1 4 this 3 2341  
975 0 0 4 1180 2124 0 0 66 /**
 * Optimizes the table by collapsing redundant sub-tables.
 */ 1 4 this 3 2340  
976 0 0 4 1181 2124 0 0 225 /**
 * Optimizes the table by collapsing redundant sub-tables, and simultaneously
 * ensures that the order string is the standard order (which is the same as
 * that supported by compose_matrix() and decompose_matrix()).
 */ 1 4 this 3 2340  
977 0 0 4 1182 2124 0 0 241 /**
 * The inverse operation of optimize(), this ensures that all the sub-tables
 * have the same length by duplicating rows as necessary.  This is needed
 * before doing operations like add_data() or set_value() on an existing
 * table.
 */ 1 4 this 3 2340  
978 0 0 6 1183 2068 0 0 259 /**
 * Returns the effective number of rows in the table.  This is actually the
 * number of rows of the smallest subtable larger than one row.  This is a
 * convenience function that treats the table of tables as if it were a single
 * table of matrices.
 */ 1 4 this 3 2341  
979 0 0 4 1184 2124 0 0 342 /**
 * Returns the value of the aggregate row of the table as a matrix.  This is a
 * convenience function that treats the table of tables as if it were a single
 * table of matrices.  It is an error to call this if any SAnimData children
 * of this node have an improper name (e.g.  not a single letter, or not one
 * of "ijkabchprxyz").
 */ 3 4 this 3 2341  3 row 1 2068  3 mat 1 2343  
980 0 0 6 1185 2038 0 0 387 /**
 * Replaces the indicated row of the table with the given matrix.
 *
 * This function can only be called if all the constraints of add_data(),
 * below, are met.  Call normalize() first if you are not sure.
 *
 * The return value is true if the matrix can be decomposed and stored as
 * scale, shear, rotate, and translate, or false otherwise.  The data is set
 * in either case.
 */ 3 4 this 3 2340  3 row 1 2068  3 mat 1 2136  
981 0 0 4 1186 2124 0 0 93 /**
 * Removes all data from the table.  It does this by removing all of its
 * children.
 */ 1 4 this 3 2340  
982 0 0 6 1187 2038 0 0 1136 /**
 * Adds a new matrix to the table, by adding a new row to each of the
 * subtables.
 *
 * This is a convenience function that treats the table of tables as if it
 * were a single table of matrices.  It is an error to call this if any
 * SAnimData children of this node have an improper name (e.g.  not a single
 * letter, or not one of "ijkabchprxyz").
 *
 * This function has the further requirement that all nine of the subtables
 * must exist and be of the same length.  Furthermore, the order string must
 * be the standard order string, which matches the system compose_matrix() and
 * decompose_matrix() functions.
 *
 * Thus, you probably cannot take an existing EggXfmSAnim object and start
 * adding matrices to the end; you must clear out the original data first.
 * (As a special exception, if no tables exist, they will be created.)  The
 * method normalize() will do this for you on an existing EggXfmSAnim.
 *
 * This function may fail silently if the matrix cannot be decomposed into
 * scale, shear, rotate, and translate.  In this case, the closest
 * approximation is added to the table, and false is returned.
 */ 2 4 this 3 2340  3 mat 1 2136  
983 0 0 4 1188 2124 0 0 73 /**
 * Adds a new row to the indicated component (0-12) of the table.
 */ 3 4 this 3 2340  9 component 1 2068  5 value 1 2039  
984 0 0 4 1188 2124 0 0 99 /**
 * Adds a new row to the named component (one of matrix_component_letters) of
 * the table.
 */ 3 4 this 3 2340  14 component_name 1 2128  5 value 1 2039  
985 0 0 4 1189 2124 0 0 172 /**
 * Composes a matrix out of the nine individual components, respecting the
 * order string.  The components will be applied in the order indicated by the
 * string.
 */ 7 3 mat 1 2343  5 scale 1 2231  5 shear 1 2231  3 hpr 1 2231  5 trans 1 2231  5 order 1 2128  2 cs 1 2210  
986 0 0 7 1190 2120 0 0 0 0 
987 0 0 7 1193 2344 1986 0 10 /**
 *
 */ 1 4 copy 1 2338  
988 0 0 7 1193 2344 1986 0 84 /**
 * Converts the newer-style XfmSAnim table to the older-style XfmAnim table.
 */ 1 12 convert_from 1 2341  
989 0 0 7 1193 2344 1986 0 10 /**
 *
 */ 2 4 name 1 2128  2 cs 1 2210  
990 0 0 7 1194 2344 1986 0 10 /**
 *
 */ 2 4 this 3 2344  4 copy 1 2338  
991 0 0 4 1195 2124 0 0 10 /**
 *
 */ 2 4 this 3 2344  5 order 1 2128  
992 0 0 4 1196 2124 0 0 10 /**
 *
 */ 1 4 this 3 2344  
993 0 0 6 1197 2038 0 0 10 /**
 *
 */ 1 4 this 3 2338  
994 0 0 6 1198 2128 0 0 10 /**
 *
 */ 1 4 this 3 2338  
995 0 0 6 1199 2128 0 0 178 /**
 * Returns the standard order of matrix component composition.  This is what
 * the order string must be set to in order to use set_value() or add_data()
 * successfully.
 */ 0 
996 0 0 4 1200 2124 0 0 10 /**
 *
 */ 2 4 this 3 2344  8 contents 1 2128  
997 0 0 4 1201 2124 0 0 10 /**
 *
 */ 1 4 this 3 2344  
998 0 0 6 1202 2038 0 0 10 /**
 *
 */ 1 4 this 3 2338  
999 0 0 6 1203 2128 0 0 10 /**
 *
 */ 1 4 this 3 2338  
1000 0 0 6 1204 2210 0 0 292 /**
 * Returns the coordinate system this table believes it is defined within.
 * This should always match the coordinate system of the EggData structure
 * that owns it.  It is necessary to store it here because the meaning of the
 * h, p, and r columns depends on the coordinate system.
 */ 1 4 this 3 2338  
1001 0 0 6 1205 2068 0 0 51 /**
 * Returns the number of rows in the table.
 */ 1 4 this 3 2338  
1002 0 0 6 1206 2068 0 0 148 /**
 * Returns the number of columns in the table.  This is set according to the
 * "contents" string, which defines the meaning of each column.
 */ 1 4 this 3 2338  
1003 0 0 4 1207 2124 0 0 181 /**
 * Returns the value of the aggregate row of the table as a matrix.  This is a
 * convenience function that treats the 2-d table as if it were a single table
 * of matrices.
 */ 3 4 this 3 2338  3 row 1 2068  3 mat 1 2343  
1004 0 0 6 1207 2039 0 0 158 /**
 * Returns the value at the indicated row.  Row must be in the range 0 <= row
 * < get_num_rows(); col must be in the range 0 <= col < get_num_cols().
 */ 3 4 this 3 2338  3 row 1 2068  3 col 1 2068  
1005 0 0 7 1208 2120 0 0 0 0 
358
1987 11 EggUserData 0 75777 11 EggUserData 11 EggUserData 0 0 0 1 1006 0 0 2 1007 1008 0 0 1 0 1988 0 0 0 0 352
/**
 * This is a base class for a user-defined data type to extend egg structures
 * in processing code.  The user of the egg library may derive from
 * EggUserData to associate any arbitrary data with various egg objects.
 *
 * However, this data will not be written out to the disk when the egg file is
 * written; it is an in-memory object only.
 */

1988 19 TypedReferenceCount 0 2049 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

1989 9 EggObject 0 75777 9 EggObject 9 EggObject 0 0 0 1 1009 0 0 6 1010 1011 1012 1013 1014 1015 0 0 1 0 1988 0 0 0 0 108
/**
 * The highest-level base class in the egg directory.  (Almost) all things egg
 * inherit from this.
 */

1990 14 EggNamedObject 0 141313 14 EggNamedObject 14 EggNamedObject 0 0 0 1 1020 1024 0 3 1021 1022 1023 0 0 2 3 1989 1016 1017 3 1991 1018 1019 0 0 81
/**
 * This is a fairly low-level base class--any egg object that has a name.
 */

1991 7 Namable 0 2049 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * A base class for all things which can have a name.  The name is either
 * empty or nonempty, but it is never NULL.
 */

1992 7 EggNode 0 141313 7 EggNode 7 EggNode 0 0 0 0 1063 0 38 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 0 0 1 0 1990 0 0 0 0 194
/**
 * A base class for things that may be directly added into the egg hierarchy.
 * This includes groups, joints, polygons, vertex pools, etc., but does not
 * include things like vertices.
 */

1993 11 EggAnimData 0 141313 11 EggAnimData 11 EggAnimData 0 0 0 0 1074 0 10 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 0 0 1 0 1992 0 0 0 0 106
/**
 * A base class for EggSAnimData and EggXfmAnimData, which contain rows and
 * columns of numbers.
 */

1994 14 EggAnimPreload 0 141313 14 EggAnimPreload 14 EggAnimPreload 0 0 0 1 1075 1086 0 10 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 0 0 1 0 1992 0 0 0 0 54
/**
 * This corresponds to an <AnimPreload> entry.
 */

1995 13 EggAttributes 0 26625 13 EggAttributes 13 EggAttributes 0 0 0 1 1089 1091 2 2345 2346 18 1090 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1110 0 0 1 3 1996 1087 1088 0 0 340
/**
 * The set of attributes that may be applied to vertices as well as polygons,
 * such as surface normal and color.
 *
 * This class cannot inherit from EggObject, because it causes problems at the
 * EggPolygon level with multiple appearances of the EggObject base class.
 * And making EggObject a virtual base class is just no fun.
 */

1996 10 MemoryBase 0 2049 10 MemoryBase 10 MemoryBase 0 0 0 0 0 0 0 0 0 0 0 0 428
/**
 * This class is intended to be the base class of all objects in Panda that
 * might be allocated and deleted via the new and delete operators.  It
 * redefines these operators to provide some memory tracking support.
 *
 * We used to try to override the global operator new and delete methods, but
 * that seems to cause problems when including header files for C++-based
 * system libraries (such as are found on OSX).
 */

1997 18 EggMorphNormalList 0 2105344 18 EggMorphNormalList 18 EggMorphNormalList 0 0 1998 0 0 0 0 0 0 0 0 0 0

1998 30 EggMorphList< EggMorphNormal > 0 1050624 30 EggMorphList< EggMorphNormal > 30 EggMorphList< EggMorphNormal > 0 0 0 0 0 0 0 0 0 0 0 0 0

1999 17 EggMorphColorList 0 2105344 17 EggMorphColorList 17 EggMorphColorList 0 0 2000 0 0 0 0 0 0 0 0 0 0

2000 29 EggMorphList< EggMorphColor > 0 1050624 29 EggMorphList< EggMorphColor > 29 EggMorphList< EggMorphColor > 0 0 0 0 0 0 0 0 0 0 0 0 0

2001 11 EggVertexUV 0 75777 11 EggVertexUV 11 EggVertexUV 0 0 0 1 1111 1024 1 2347 22 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1134 0 0 1 0 1990 0 0 0 0 188
/**
 * The set of UV's that may or may not be assigned to a vertex.  To support
 * multitexturing, there may be multiple sets of UV's on a particular vertex,
 * each with its own name.
 */

2002 20 EggMorphTexCoordList 0 2105344 20 EggMorphTexCoordList 20 EggMorphTexCoordList 0 0 2003 0 0 0 0 0 0 0 0 0 0

2003 32 EggMorphList< EggMorphTexCoord > 0 1050624 32 EggMorphList< EggMorphTexCoord > 32 EggMorphList< EggMorphTexCoord > 0 0 0 0 0 0 0 0 0 0 0 0 0

2004 12 EggVertexAux 0 75777 12 EggVertexAux 12 EggVertexAux 0 0 0 1 1135 1024 0 8 1136 1137 1138 1139 1140 1141 1142 1143 0 0 1 0 1990 0 0 0 0 267
/**
 * The set of named auxiliary data that may or may not be assigned to a
 * vertex.  Panda will import this data and create a custom column for it in
 * the vertex data, but will not otherwise interpret it.  Presumably, a shader
 * will process the data later.
 */

2005 9 EggVertex 0 26625 9 EggVertex 9 EggVertex 0 0 0 1 1148 1150 1 2348 47 1149 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1197 0 0 2 3 1989 1144 1145 3 1995 1146 1147 0 0 106
/**
 * Any one-, two-, three-, or four-component vertex, possibly with attributes
 * such as a normal.
 */

2006 18 EggMorphVertexList 0 2105344 18 EggMorphVertexList 18 EggMorphVertexList 0 0 2007 0 0 0 0 0 0 0 0 0 0

2007 30 EggMorphList< EggMorphVertex > 0 1050624 30 EggMorphList< EggMorphVertex > 30 EggMorphList< EggMorphVertex > 0 0 0 0 0 0 0 0 0 0 0 0 0

2008 13 EggVertexPool 0 75777 13 EggVertexPool 13 EggVertexPool 0 0 0 1 1198 1063 0 28 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 0 0 1 0 1992 0 0 0 0 553
/**
 * A collection of vertices.  There may be any number of vertex pools in a
 * single egg structure.  The vertices in a single pool need not necessarily
 * have any connection to each other, but it is necessary that any one
 * primitive (e.g.  a polygon) must pull all its vertices from the same pool.
 *
 * An EggVertexPool is an STL-style container of pointers to EggVertex's.
 * Functions add_vertex() and remove_vertex() are provided to manipulate the
 * list.  The list may also be operated on (read-only) via iterators and
 * begin()/end().
 */

2009 12 EggGroupNode 0 75777 12 EggGroupNode 12 EggGroupNode 0 0 0 1 1227 1063 0 37 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 0 0 1 0 1992 0 0 0 1 2010 417
/**
 * A base class for nodes in the hierarchy that are not leaf nodes.  (See also
 * EggGroup, which is specifically the "<Group>" node in egg.)
 *
 * An EggGroupNode is an STL-style container of pointers to EggNodes, like a
 * vector.  Functions push_back()/pop_back() and insert()/erase() are provided
 * to manipulate the list.  The list may also be operated on (read-only) via
 * iterators and begin()/end().
 */

2010 16 TriangulateFlags 0 794624 30 EggGroupNode::TriangulateFlags 30 EggGroupNode::TriangulateFlags 2009 0 0 0 0 0 0 0 0 0 5 9 T_polygon 23 EggGroupNode::T_polygon 0
1 8 T_convex 22 EggGroupNode::T_convex 0
2 11 T_composite 25 EggGroupNode::T_composite 0
4 9 T_recurse 23 EggGroupNode::T_recurse 0
8 13 T_flat_shaded 27 EggGroupNode::T_flat_shaded 0
16 0 0

2011 13 EggRenderMode 0 141313 13 EggRenderMode 13 EggRenderMode 0 0 0 1 1265 1296 0 30 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 0 0 0 0 4 2012 2013 2014 2015 516
/**
 * This class stores miscellaneous rendering properties that is associated
 * with geometry, and which may be set on the geometry primitive level, on the
 * group above it, or indirectly via a texture.  It's intended to be a base
 * class for egg objects that can have these properties set.
 *
 * This class cannot inherit from EggObject, because it causes problems at the
 * EggPolygon level with multiple appearances of the EggObject base class.
 * And making EggObject a virtual base class is just no fun.
 */

2012 9 AlphaMode 0 794624 24 EggRenderMode::AlphaMode 24 EggRenderMode::AlphaMode 2011 0 0 0 0 0 0 0 0 0 10 14 AM_unspecified 29 EggRenderMode::AM_unspecified 0
0 6 AM_off 21 EggRenderMode::AM_off 19
// No transparency.
1 5 AM_on 20 EggRenderMode::AM_on 37
// Use whatever the default model is.
2 8 AM_blend 23 EggRenderMode::AM_blend 59
// Normal alpha blending, e.g. TransparencyAttrib::M_alpha.
3 19 AM_blend_no_occlude 34 EggRenderMode::AM_blend_no_occlude 34
// Alpha blending w/o depth write.
4 5 AM_ms 20 EggRenderMode::AM_ms 36
// TransparencyAttrib::M_multisample
5 10 AM_ms_mask 25 EggRenderMode::AM_ms_mask 41
// TransparencyAttrib::M_multisample_mask
6 9 AM_binary 24 EggRenderMode::AM_binary 31
// TransparencyAttrib::M_binary
7 7 AM_dual 22 EggRenderMode::AM_dual 29
// TransparencyAttrib::M_dual
8 16 AM_premultiplied 31 EggRenderMode::AM_premultiplied 44
// TransparencyAttrib::M_premultiplied_alpha
9 0 44
// Specifies implementation of transparency.

2013 14 DepthWriteMode 0 794624 29 EggRenderMode::DepthWriteMode 29 EggRenderMode::DepthWriteMode 2011 0 0 0 0 0 0 0 0 0 3 15 DWM_unspecified 30 EggRenderMode::DWM_unspecified 0
0 7 DWM_off 22 EggRenderMode::DWM_off 0
1 6 DWM_on 21 EggRenderMode::DWM_on 0
2 0 0

2014 13 DepthTestMode 0 794624 28 EggRenderMode::DepthTestMode 28 EggRenderMode::DepthTestMode 2011 0 0 0 0 0 0 0 0 0 3 15 DTM_unspecified 30 EggRenderMode::DTM_unspecified 0
0 7 DTM_off 22 EggRenderMode::DTM_off 0
1 6 DTM_on 21 EggRenderMode::DTM_on 0
2 0 0

2015 14 VisibilityMode 0 794624 29 EggRenderMode::VisibilityMode 29 EggRenderMode::VisibilityMode 2011 0 0 0 0 0 0 0 0 0 3 14 VM_unspecified 29 EggRenderMode::VM_unspecified 0
0 9 VM_hidden 24 EggRenderMode::VM_hidden 0
1 9 VM_normal 24 EggRenderMode::VM_normal 0
2 0 0

2016 12 EggTransform 0 26625 12 EggTransform 12 EggTransform 0 0 0 1 1297 1299 0 30 1298 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 0 0 0 0 1 2017 313
/**
 * This represents the <Transform> entry of a group or texture node: a list of
 * component transform operations, applied in order, that describe a net
 * transform matrix.
 *
 * This may be either a 3-d transform, and therefore described by a 4x4
 * matrix, or a 2-d transform, described by a 3x3 matrix.
 */

2017 13 ComponentType 0 794624 27 EggTransform::ComponentType 27 EggTransform::ComponentType 2016 0 0 0 0 0 0 0 0 0 13 10 CT_invalid 24 EggTransform::CT_invalid 0
0 14 CT_translate2d 28 EggTransform::CT_translate2d 0
1 14 CT_translate3d 28 EggTransform::CT_translate3d 0
2 11 CT_rotate2d 25 EggTransform::CT_rotate2d 0
3 7 CT_rotx 21 EggTransform::CT_rotx 0
4 7 CT_roty 21 EggTransform::CT_roty 0
5 7 CT_rotz 21 EggTransform::CT_rotz 0
6 11 CT_rotate3d 25 EggTransform::CT_rotate3d 0
7 10 CT_scale2d 24 EggTransform::CT_scale2d 0
8 10 CT_scale3d 24 EggTransform::CT_scale3d 0
9 16 CT_uniform_scale 30 EggTransform::CT_uniform_scale 0
10 10 CT_matrix3 24 EggTransform::CT_matrix3 0
11 10 CT_matrix4 24 EggTransform::CT_matrix4 0
12 0 0

2018 18 EggSwitchCondition 0 141313 18 EggSwitchCondition 18 EggSwitchCondition 0 0 0 0 1333 0 4 1329 1330 1331 1332 0 0 1 0 1989 0 0 0 0 340
/**
 * This corresponds to a <SwitchCondition> entry within a group.  It indicates
 * the condition at which a level-of-detail is switched in or out.  This is
 * actually an abstract base class for potentially any number of specific
 * different kinds of switching conditions; presently, only a <Distance> type
 * is actually supported.
 */

2019 26 EggSwitchConditionDistance 0 141313 26 EggSwitchConditionDistance 26 EggSwitchConditionDistance 0 0 0 1 1334 1336 0 1 1335 0 0 1 0 2018 0 0 0 0 112
/**
 * A SwitchCondition that switches the levels-of-detail based on distance from
 * the camera's eyepoint.
 */

2020 8 EggGroup 0 26625 8 EggGroup 8 EggGroup 0 0 0 1 1343 1345 32 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 136 1344 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 2 2435 2436 0 3 3 2009 1337 1338 3 2011 1339 1340 3 2016 1341 1342 0 10 2021 2023 2025 2026 2027 2028 2029 2030 2031 2032 118
/**
 * The main glue of the egg hierarchy, this corresponds to the <Group>,
 * <Instance>, and <Joint> type nodes.
 */

2021 9 VertexRef 0 2367488 19 EggGroup::VertexRef 19 EggGroup::VertexRef 2020 0 2022 0 0 0 0 0 0 0 0 0 0

2022 27 map< PT_EggVertex, double > 0 2048 27 map< PT_EggVertex, double > 27 map< PT_EggVertex, double > 0 0 0 0 0 0 0 0 0 0 0 0 0

2023 7 TagData 0 2367488 17 EggGroup::TagData 17 EggGroup::TagData 2020 0 2024 0 0 0 0 0 0 0 0 0 0

2024 21 map< string, string > 0 2048 31 map< std::string, std::string > 31 map< std::string, std::string > 0 0 0 0 0 0 0 0 0 0 0 0 0

2025 9 GroupType 0 794624 19 EggGroup::GroupType 19 EggGroup::GroupType 2020 0 0 0 0 0 0 0 0 0 4 10 GT_invalid 20 EggGroup::GT_invalid 58
// The bits here must correspond to those in Flags, below.
-1 8 GT_group 18 EggGroup::GT_group 0
0 11 GT_instance 21 EggGroup::GT_instance 0
1 8 GT_joint 18 EggGroup::GT_joint 0
2 0 49
// These bits are all stored somewhere in _flags.

2026 7 DCSType 0 794624 17 EggGroup::DCSType 17 EggGroup::DCSType 2020 0 0 0 0 0 0 0 0 0 6 14 DC_unspecified 24 EggGroup::DC_unspecified 59
// The bits here must correspond to those in Flags2, below.
0 7 DC_none 17 EggGroup::DC_none 0
16 8 DC_local 18 EggGroup::DC_local 0
32 6 DC_net 16 EggGroup::DC_net 0
48 11 DC_no_touch 21 EggGroup::DC_no_touch 0
64 10 DC_default 20 EggGroup::DC_default 0
80 0 0

2027 13 BillboardType 0 794624 23 EggGroup::BillboardType 23 EggGroup::BillboardType 2020 0 0 0 0 0 0 0 0 0 4 7 BT_none 17 EggGroup::BT_none 58
// The bits here must correspond to those in Flags, below.
0 7 BT_axis 17 EggGroup::BT_axis 0
32 24 BT_point_camera_relative 34 EggGroup::BT_point_camera_relative 0
64 23 BT_point_world_relative 33 EggGroup::BT_point_world_relative 0
128 0 0

2028 18 CollisionSolidType 0 794624 28 EggGroup::CollisionSolidType 28 EggGroup::CollisionSolidType 2020 0 0 0 0 0 0 0 0 0 9 8 CST_none 18 EggGroup::CST_none 97
// The bits here must correspond to those in Flags, below, and they must
// fit within F_cs_type.
0 9 CST_plane 19 EggGroup::CST_plane 0
65536 11 CST_polygon 21 EggGroup::CST_polygon 0
131072 11 CST_polyset 21 EggGroup::CST_polyset 0
196608 10 CST_sphere 20 EggGroup::CST_sphere 0
262144 8 CST_tube 18 EggGroup::CST_tube 0
327680 14 CST_inv_sphere 24 EggGroup::CST_inv_sphere 0
393216 7 CST_box 17 EggGroup::CST_box 0
458752 14 CST_floor_mesh 24 EggGroup::CST_floor_mesh 0
524288 0 0

2029 12 CollideFlags 0 794624 22 EggGroup::CollideFlags 22 EggGroup::CollideFlags 2020 0 0 0 0 0 0 0 0 0 9 7 CF_none 17 EggGroup::CF_none 103
// The bits here must correspond to those in Flags, below, and they must
// fit within F_collide_flags.
0 10 CF_descend 20 EggGroup::CF_descend 0
1048576 8 CF_event 18 EggGroup::CF_event 0
2097152 7 CF_keep 17 EggGroup::CF_keep 0
4194304 8 CF_solid 18 EggGroup::CF_solid 0
8388608 9 CF_center 19 EggGroup::CF_center 0
16777216 12 CF_turnstile 22 EggGroup::CF_turnstile 0
33554432 8 CF_level 18 EggGroup::CF_level 0
67108864 13 CF_intangible 23 EggGroup::CF_intangible 0
134217728 0 0

2030 8 DartType 0 794624 18 EggGroup::DartType 18 EggGroup::DartType 2020 0 0 0 0 0 0 0 0 0 5 7 DT_none 17 EggGroup::DT_none 58
// The bits here must correspond to those in Flags, below.
0 13 DT_structured 23 EggGroup::DT_structured 0
268435456 7 DT_sync 17 EggGroup::DT_sync 0
536870912 9 DT_nosync 19 EggGroup::DT_nosync 0
805306368 10 DT_default 20 EggGroup::DT_default 0
1073741824 0 0

2031 9 BlendMode 0 794624 19 EggGroup::BlendMode 19 EggGroup::BlendMode 2020 0 0 0 0 0 0 0 0 0 7 14 BM_unspecified 24 EggGroup::BM_unspecified 0
0 7 BM_none 17 EggGroup::BM_none 0
1 6 BM_add 16 EggGroup::BM_add 0
2 11 BM_subtract 21 EggGroup::BM_subtract 0
3 15 BM_inv_subtract 25 EggGroup::BM_inv_subtract 0
4 6 BM_min 16 EggGroup::BM_min 0
5 6 BM_max 16 EggGroup::BM_max 0
6 0 68
// These correspond to ColorBlendAttrib::Mode (but not numerically).

2032 12 BlendOperand 0 794624 22 EggGroup::BlendOperand 22 EggGroup::BlendOperand 2020 0 0 0 0 0 0 0 0 0 20 14 BO_unspecified 24 EggGroup::BO_unspecified 0
0 7 BO_zero 17 EggGroup::BO_zero 0
1 6 BO_one 16 EggGroup::BO_one 0
2 17 BO_incoming_color 27 EggGroup::BO_incoming_color 0
3 27 BO_one_minus_incoming_color 37 EggGroup::BO_one_minus_incoming_color 0
4 16 BO_fbuffer_color 26 EggGroup::BO_fbuffer_color 0
5 26 BO_one_minus_fbuffer_color 36 EggGroup::BO_one_minus_fbuffer_color 0
6 17 BO_incoming_alpha 27 EggGroup::BO_incoming_alpha 0
7 27 BO_one_minus_incoming_alpha 37 EggGroup::BO_one_minus_incoming_alpha 0
8 16 BO_fbuffer_alpha 26 EggGroup::BO_fbuffer_alpha 0
9 26 BO_one_minus_fbuffer_alpha 36 EggGroup::BO_one_minus_fbuffer_alpha 0
10 17 BO_constant_color 27 EggGroup::BO_constant_color 0
11 27 BO_one_minus_constant_color 37 EggGroup::BO_one_minus_constant_color 0
12 17 BO_constant_alpha 27 EggGroup::BO_constant_alpha 0
13 27 BO_one_minus_constant_alpha 37 EggGroup::BO_one_minus_constant_alpha 0
14 26 BO_incoming_color_saturate 36 EggGroup::BO_incoming_color_saturate 0
15 14 BO_color_scale 24 EggGroup::BO_color_scale 0
16 24 BO_one_minus_color_scale 34 EggGroup::BO_one_minus_color_scale 0
17 14 BO_alpha_scale 24 EggGroup::BO_alpha_scale 0
18 24 BO_one_minus_alpha_scale 34 EggGroup::BO_one_minus_alpha_scale 0
19 0 71
// These correspond to ColorBlendAttrib::Operand (but not numerically).

2033 14 LPoint3d const 0 8832 14 LPoint3d const 14 LPoint3d const 0 0 2034 0 0 0 0 0 0 0 0 0 0

2034 8 LPoint3d 0 2048 8 LPoint3d 8 LPoint3d 0 0 0 0 0 0 0 0 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

2035 12 string const 0 8832 17 std::string const 17 std::string const 0 0 2036 0 0 0 0 0 0 0 0 0 0

2036 6 string 0 2105344 11 std::string 11 std::string 0 0 2037 0 0 0 0 0 0 0 0 0 0

2037 20 basic_string< char > 0 2048 25 std::basic_string< char > 25 std::basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

2038 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

2039 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

2040 11 CollideMask 0 2105344 11 CollideMask 11 CollideMask 0 0 2041 0 0 0 0 0 0 0 0 0 0

2041 9 BitMask32 0 2105344 9 BitMask32 9 BitMask32 0 0 2042 0 0 0 0 0 0 0 0 0 0

2042 23 BitMask< uint32_t, 32 > 0 2048 23 BitMask< uint32_t, 32 > 23 BitMask< uint32_t, 32 > 0 0 0 0 0 0 0 0 0 0 0 0 0

2043 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 2044 0 0 0 0 0 0 0 0 0 0

2044 6 LColor 0 2105344 6 LColor 6 LColor 0 0 2045 0 0 0 0 0 0 0 0 0 0

2045 7 LColorf 0 2105344 7 LColorf 7 LColorf 0 0 2046 0 0 0 0 0 0 0 0 0 0

2046 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

2047 24 EggSwitchCondition const 0 8832 24 EggSwitchCondition const 24 EggSwitchCondition const 0 0 2018 0 0 0 0 0 0 0 0 0 0

2048 18 EggTransform const 0 8832 18 EggTransform const 18 EggTransform const 0 0 2016 0 0 0 0 0 0 0 0 0 0

2049 6 EggBin 0 141313 6 EggBin 6 EggBin 0 0 0 1 1481 1485 0 3 1482 1483 1484 0 0 1 0 2020 0 0 0 0 233
/**
 * A type of group node that holds related subnodes.  This is a special kind
 * of node that will never be read in from an egg file, but can only exist in
 * the egg scene graph if it is created via the use of an EggBinMaker.
 */

2050 11 EggBinMaker 0 75777 11 EggBinMaker 11 EggBinMaker 0 0 0 0 0 0 8 1486 1487 1488 1489 1490 1491 1492 1493 0 0 1 0 1989 0 0 0 0 183
/**
 * This is a handy class for collecting related nodes together.  It is an
 * abstract class; to use it you must subclass off of it.  See the somewhat
 * lengthy comment above.
 */

2051 10 EggComment 0 141313 10 EggComment 10 EggComment 0 0 0 1 1494 1500 0 4 1495 1497 1498 1499 0 1 1496 1 0 1992 0 0 0 0 74
/**
 * A comment that appears in an egg file within a <Comment> entry.
 */

2052 15 EggFilenameNode 0 141313 15 EggFilenameNode 15 EggFilenameNode 0 0 0 0 1508 0 7 1501 1502 1503 1504 1505 1506 1507 0 0 1 0 1992 0 0 0 0 208
/**
 * This is an egg node that contains a filename.  It references a physical
 * file relative to the directory the egg file was loaded in.  It is a base
 * class for EggTexture and EggExternalReference.
 */

2053 10 EggTexture 0 26625 10 EggTexture 10 EggTexture 0 0 0 1 1515 1517 31 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 118 1516 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 0 0 3 3 2052 1509 1510 3 2011 1511 1512 3 2016 1513 1514 0 14 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 65
/**
 * Defines a texture map that may be applied to geometry.
 */

2054 11 Equivalence 0 794624 23 EggTexture::Equivalence 23 EggTexture::Equivalence 2053 0 0 0 0 0 0 0 0 0 7 10 E_basename 22 EggTexture::E_basename 0
1 11 E_extension 23 EggTexture::E_extension 0
2 9 E_dirname 21 EggTexture::E_dirname 0
4 19 E_complete_filename 31 EggTexture::E_complete_filename 0
7 11 E_transform 23 EggTexture::E_transform 0
8 12 E_attributes 24 EggTexture::E_attributes 0
16 11 E_tref_name 23 EggTexture::E_tref_name 0
32 0 0

2055 11 TextureType 0 794624 23 EggTexture::TextureType 23 EggTexture::TextureType 2053 0 0 0 0 0 0 0 0 0 5 14 TT_unspecified 26 EggTexture::TT_unspecified 0
0 13 TT_1d_texture 25 EggTexture::TT_1d_texture 0
1 13 TT_2d_texture 25 EggTexture::TT_2d_texture 0
2 13 TT_3d_texture 25 EggTexture::TT_3d_texture 0
3 11 TT_cube_map 23 EggTexture::TT_cube_map 0
4 0 0

2056 6 Format 0 794624 18 EggTexture::Format 18 EggTexture::Format 2053 0 0 0 0 0 0 0 0 0 19 13 F_unspecified 25 EggTexture::F_unspecified 0
0 6 F_rgba 18 EggTexture::F_rgba 0
1 6 F_rgbm 18 EggTexture::F_rgbm 0
2 8 F_rgba12 20 EggTexture::F_rgba12 0
3 7 F_rgba8 19 EggTexture::F_rgba8 0
4 7 F_rgba4 19 EggTexture::F_rgba4 0
5 7 F_rgba5 19 EggTexture::F_rgba5 0
6 5 F_rgb 17 EggTexture::F_rgb 0
7 7 F_rgb12 19 EggTexture::F_rgb12 0
8 6 F_rgb8 18 EggTexture::F_rgb8 0
9 6 F_rgb5 18 EggTexture::F_rgb5 0
10 8 F_rgb332 20 EggTexture::F_rgb332 0
11 5 F_red 17 EggTexture::F_red 0
12 7 F_green 19 EggTexture::F_green 0
13 6 F_blue 18 EggTexture::F_blue 0
14 7 F_alpha 19 EggTexture::F_alpha 0
15 11 F_luminance 23 EggTexture::F_luminance 0
16 17 F_luminance_alpha 29 EggTexture::F_luminance_alpha 0
17 21 F_luminance_alphamask 33 EggTexture::F_luminance_alphamask 0
18 0 0

2057 15 CompressionMode 0 794624 27 EggTexture::CompressionMode 27 EggTexture::CompressionMode 2053 0 0 0 0 0 0 0 0 0 9 10 CM_default 22 EggTexture::CM_default 0
0 6 CM_off 18 EggTexture::CM_off 0
1 5 CM_on 17 EggTexture::CM_on 0
2 7 CM_fxt1 19 EggTexture::CM_fxt1 0
3 7 CM_dxt1 19 EggTexture::CM_dxt1 0
4 7 CM_dxt2 19 EggTexture::CM_dxt2 0
5 7 CM_dxt3 19 EggTexture::CM_dxt3 0
6 7 CM_dxt4 19 EggTexture::CM_dxt4 0
7 7 CM_dxt5 19 EggTexture::CM_dxt5 0
8 0 0

2058 8 WrapMode 0 794624 20 EggTexture::WrapMode 20 EggTexture::WrapMode 2053 0 0 0 0 0 0 0 0 0 6 14 WM_unspecified 26 EggTexture::WM_unspecified 0
0 8 WM_clamp 20 EggTexture::WM_clamp 0
1 9 WM_repeat 21 EggTexture::WM_repeat 0
2 9 WM_mirror 21 EggTexture::WM_mirror 0
3 14 WM_mirror_once 26 EggTexture::WM_mirror_once 0
4 15 WM_border_color 27 EggTexture::WM_border_color 0
5 0 0

2059 10 FilterType 0 794624 22 EggTexture::FilterType 22 EggTexture::FilterType 2053 0 0 0 0 0 0 0 0 0 7 14 FT_unspecified 26 EggTexture::FT_unspecified 225
// Note that these type values match up, name-for-name, with a similar
// enumerated type in Panda's Texture object.  However, they do *not*
// match up numerically.  You must convert between them using a switch
// statement.
0 10 FT_nearest 22 EggTexture::FT_nearest 28
// Mag Filter and Min Filter
1 9 FT_linear 21 EggTexture::FT_linear 0
2 25 FT_nearest_mipmap_nearest 37 EggTexture::FT_nearest_mipmap_nearest 17
// "mipmap point"
3 24 FT_linear_mipmap_nearest 36 EggTexture::FT_linear_mipmap_nearest 18
// "mipmap linear"
4 24 FT_nearest_mipmap_linear 36 EggTexture::FT_nearest_mipmap_linear 20
// "mipmap bilinear"
5 23 FT_linear_mipmap_linear 35 EggTexture::FT_linear_mipmap_linear 21
// "mipmap trilinear"
6 0 0

2060 7 EnvType 0 794624 19 EggTexture::EnvType 19 EggTexture::EnvType 2053 0 0 0 0 0 0 0 0 0 16 14 ET_unspecified 26 EggTexture::ET_unspecified 0
0 11 ET_modulate 23 EggTexture::ET_modulate 0
1 8 ET_decal 20 EggTexture::ET_decal 0
2 8 ET_blend 20 EggTexture::ET_blend 0
3 10 ET_replace 22 EggTexture::ET_replace 0
4 6 ET_add 18 EggTexture::ET_add 0
5 20 ET_blend_color_scale 32 EggTexture::ET_blend_color_scale 0
6 16 ET_modulate_glow 28 EggTexture::ET_modulate_glow 0
7 17 ET_modulate_gloss 29 EggTexture::ET_modulate_gloss 0
8 9 ET_normal 21 EggTexture::ET_normal 0
9 16 ET_normal_height 28 EggTexture::ET_normal_height 0
10 7 ET_glow 19 EggTexture::ET_glow 0
11 8 ET_gloss 20 EggTexture::ET_gloss 0
12 9 ET_height 21 EggTexture::ET_height 0
13 11 ET_selector 23 EggTexture::ET_selector 0
14 15 ET_normal_gloss 27 EggTexture::ET_normal_gloss 0
15 0 0

2061 11 CombineMode 0 794624 23 EggTexture::CombineMode 23 EggTexture::CombineMode 2053 0 0 0 0 0 0 0 0 0 9 14 CM_unspecified 26 EggTexture::CM_unspecified 0
0 10 CM_replace 22 EggTexture::CM_replace 0
1 11 CM_modulate 23 EggTexture::CM_modulate 0
2 6 CM_add 18 EggTexture::CM_add 0
3 13 CM_add_signed 25 EggTexture::CM_add_signed 0
4 14 CM_interpolate 26 EggTexture::CM_interpolate 0
5 11 CM_subtract 23 EggTexture::CM_subtract 0
6 11 CM_dot3_rgb 23 EggTexture::CM_dot3_rgb 0
7 12 CM_dot3_rgba 24 EggTexture::CM_dot3_rgba 0
8 0 0

2062 14 CombineChannel 0 794624 26 EggTexture::CombineChannel 26 EggTexture::CombineChannel 2053 0 0 0 0 0 0 0 0 0 3 6 CC_rgb 18 EggTexture::CC_rgb 0
0 8 CC_alpha 20 EggTexture::CC_alpha 0
1 15 CC_num_channels 27 EggTexture::CC_num_channels 0
2 0 0

2063 12 CombineIndex 0 794624 24 EggTexture::CombineIndex 24 EggTexture::CombineIndex 2053 0 0 0 0 0 0 0 0 0 1 14 CI_num_indices 26 EggTexture::CI_num_indices 0
3 0 0

2064 13 CombineSource 0 794624 25 EggTexture::CombineSource 25 EggTexture::CombineSource 2053 0 0 0 0 0 0 0 0 0 7 14 CS_unspecified 26 EggTexture::CS_unspecified 0
0 10 CS_texture 22 EggTexture::CS_texture 0
1 11 CS_constant 23 EggTexture::CS_constant 0
2 16 CS_primary_color 28 EggTexture::CS_primary_color 0
3 11 CS_previous 23 EggTexture::CS_previous 0
4 23 CS_constant_color_scale 35 EggTexture::CS_constant_color_scale 0
5 20 CS_last_saved_result 32 EggTexture::CS_last_saved_result 0
6 0 0

2065 14 CombineOperand 0 794624 26 EggTexture::CombineOperand 26 EggTexture::CombineOperand 2053 0 0 0 0 0 0 0 0 0 5 14 CO_unspecified 26 EggTexture::CO_unspecified 0
0 12 CO_src_color 24 EggTexture::CO_src_color 0
1 22 CO_one_minus_src_color 34 EggTexture::CO_one_minus_src_color 0
2 12 CO_src_alpha 24 EggTexture::CO_src_alpha 0
3 22 CO_one_minus_src_alpha 34 EggTexture::CO_one_minus_src_alpha 0
4 0 0

2066 6 TexGen 0 794624 18 EggTexture::TexGen 18 EggTexture::TexGen 2053 0 0 0 0 0 0 0 0 0 9 14 TG_unspecified 26 EggTexture::TG_unspecified 0
0 17 TG_eye_sphere_map 29 EggTexture::TG_eye_sphere_map 0
1 17 TG_world_cube_map 29 EggTexture::TG_world_cube_map 0
2 15 TG_eye_cube_map 27 EggTexture::TG_eye_cube_map 0
3 15 TG_world_normal 27 EggTexture::TG_world_normal 0
4 13 TG_eye_normal 25 EggTexture::TG_eye_normal 0
5 17 TG_world_position 29 EggTexture::TG_world_position 0
6 15 TG_eye_position 27 EggTexture::TG_eye_position 0
7 15 TG_point_sprite 27 EggTexture::TG_point_sprite 0
8 0 0

2067 12 QualityLevel 0 794624 24 EggTexture::QualityLevel 24 EggTexture::QualityLevel 2053 0 0 0 0 0 0 0 0 0 5 14 QL_unspecified 26 EggTexture::QL_unspecified 0
0 10 QL_default 22 EggTexture::QL_default 0
1 10 QL_fastest 22 EggTexture::QL_fastest 0
2 9 QL_normal 21 EggTexture::QL_normal 0
3 7 QL_best 19 EggTexture::QL_best 0
4 0 0

2068 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

2069 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 2070 0 0 0 0 0 0 0 0 0 0

2070 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550
/**
 * The name of a file, such as a texture file or an Egg file.  Stores the full
 * pathname, and includes functions for extracting out the directory prefix
 * part and the file extension and stuff.
 *
 * A Filename is also aware of the mapping between the Unix-like filename
 * convention we use internally, and the local OS's specific filename
 * convention, and it knows how to perform basic OS-specific I/O, like testing
 * for file existence and searching a searchpath, as well as the best way to
 * open an fstream for reading or writing.
 */

2071 11 EggMaterial 0 141313 11 EggMaterial 11 EggMaterial 0 0 0 1 1635 1679 10 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 43 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 0 0 1 0 1992 0 0 0 1 2072 10
/**
 *
 */

2072 11 Equivalence 0 794624 24 EggMaterial::Equivalence 24 EggMaterial::Equivalence 2071 0 0 0 0 0 0 0 0 0 2 12 E_attributes 25 EggMaterial::E_attributes 0
1 11 E_mref_name 24 EggMaterial::E_mref_name 0
2 0 0

2073 12 EggPrimitive 0 26625 12 EggPrimitive 12 EggPrimitive 0 0 0 0 1687 8 2422 2423 2424 2425 2426 2427 2428 2429 50 1686 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 2 2437 2438 0 3 3 1992 1680 1681 3 1995 1682 1683 3 2011 1684 1685 0 1 2074 463
/**
 * A base class for any of a number of kinds of geometry primitives: polygons,
 * point lights, nurbs patches, parametrics curves, etc.  Things with a set of
 * vertices and some rendering properties like color.
 *
 * An EggPrimitive is an STL-style container of pointers to EggVertex's.  In
 * fact, it IS a vector, and can be manipulated in all the ways that vectors
 * can.  However, it is necessary that all vertices belong to the same vertex
 * pool.
 */

2074 7 Shading 0 794624 21 EggPrimitive::Shading 21 EggPrimitive::Shading 2073 0 0 0 0 0 0 0 0 0 4 9 S_unknown 23 EggPrimitive::S_unknown 94
// The order here is important.  The later choices are more specific than
// the earlier ones.
0 9 S_overall 23 EggPrimitive::S_overall 0
1 10 S_per_face 24 EggPrimitive::S_per_face 0
2 12 S_per_vertex 26 EggPrimitive::S_per_vertex 0
3 0 0

2075 12 EggTexture * 0 8576 12 EggTexture * 12 EggTexture * 0 0 2053 0 0 0 0 0 0 0 0 0 0

2076 13 EggMaterial * 0 8576 13 EggMaterial * 13 EggMaterial * 0 0 2071 0 0 0 0 0 0 0 0 0 0

2077 11 EggVertex * 0 8576 11 EggVertex * 11 EggVertex * 0 0 2005 0 0 0 0 0 0 0 0 0 0

2078 15 EggVertexPool * 0 8576 15 EggVertexPool * 15 EggVertexPool * 0 0 2008 0 0 0 0 0 0 0 0 0 0

2079 21 EggCompositePrimitive 0 75777 21 EggCompositePrimitive 21 EggCompositePrimitive 0 0 0 0 1687 1 2430 7 1737 1738 1739 1740 1741 1742 1743 1 2439 0 1 0 2073 0 0 0 0 186
/**
 * The base class for primitives such as triangle strips and triangle fans,
 * which include several component triangles, each of which might have its own
 * color and/or normal.
 */

2080 15 EggAttributes * 0 8576 15 EggAttributes * 15 EggAttributes * 0 0 1995 0 0 0 0 0 0 0 0 0 0

2081 7 EggData 0 141313 7 EggData 7 EggData 0 0 0 1 1744 1766 0 21 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 0 0 1 0 2009 0 0 0 0 441
/**
 * This is the primary interface into all the egg data, and the root of the
 * egg file structure.  An EggData structure corresponds exactly with an egg
 * file on the disk.
 *
 * The EggData class inherits from EggGroupNode its collection of children,
 * which are accessed by using the EggData itself as an STL container with
 * begin() and end() calls.  The children of the EggData class are the
 * toplevel nodes in the egg file.
 */

2082 19 EggCoordinateSystem 0 141313 19 EggCoordinateSystem 19 EggCoordinateSystem 0 0 0 1 1767 1771 0 3 1768 1769 1770 0 0 1 0 1992 0 0 0 0 177
/**
 * The <CoordinateSystem> entry at the top of an egg file.  Don't confuse this
 * with the enum EggData::CoordinateSystem, which is the value contained by
 * this entry.
 */

2083 8 EggCurve 0 141313 8 EggCurve 8 EggCurve 0 0 0 0 1779 0 7 1772 1773 1774 1775 1776 1777 1778 0 0 1 0 2073 0 0 0 1 2084 63
/**
 * A parametric curve of some kind.  See EggNurbsCurve.
 */

2084 9 CurveType 0 794624 19 EggCurve::CurveType 19 EggCurve::CurveType 2083 0 0 0 0 0 0 0 0 0 4 7 CT_none 17 EggCurve::CT_none 0
0 6 CT_xyz 16 EggCurve::CT_xyz 0
1 6 CT_hpr 16 EggCurve::CT_hpr 0
2 4 CT_t 14 EggCurve::CT_t 0
3 0 0

2085 20 EggExternalReference 0 141313 20 EggExternalReference 20 EggExternalReference 0 0 0 1 1780 1783 0 2 1781 1782 0 0 1 0 2052 0 0 0 0 93
/**
 * Defines a reference to another egg file which should be inserted at this
 * point.
 */

2086 17 EggNameUniquifier 0 75777 17 EggNameUniquifier 17 EggNameUniquifier 0 0 0 0 0 0 9 1784 1785 1786 1787 1788 1789 1790 1791 1792 0 0 1 0 1989 0 0 0 0 182
/**
 * This is a handy class for guaranteeing unique node names in an egg
 * hierarchy.  It is an abstract class; to use it you must subclass off of it.
 * See the comment above.
 */

2087 18 EggGroupUniquifier 0 141313 18 EggGroupUniquifier 18 EggGroupUniquifier 0 0 0 1 1793 1795 0 1 1794 0 0 1 0 2086 0 0 0 0 183
/**
 * This is a specialization of EggNameUniquifier to generate unique names for
 * EggGroup nodes.  It's not called automatically; you must invoke it yourself
 * if you want it.
 */

2088 7 EggLine 0 75777 7 EggLine 7 EggLine 0 0 0 0 1687 0 7 1796 1797 1798 1799 1800 1801 1802 0 0 1 0 2079 0 0 0 0 96
/**
 * A line segment, or a series of connected line segments, defined by a <Line>
 * entry.
 */

2089 21 EggMaterialCollection 0 26625 21 EggMaterialCollection 21 EggMaterialCollection 0 0 0 1 1803 1805 0 13 1804 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 0 0 0 0 0 232
/**
 * This is a collection of materials by MRef name.  It can extract the
 * materials from an egg file and sort them all together; it can also manage
 * the creation of unique materials and the assignment of unique MRef names.
 */

2090 10 EggPolygon 0 141313 10 EggPolygon 10 EggPolygon 0 0 0 0 1826 0 8 1818 1819 1820 1821 1822 1823 1824 1825 0 0 1 0 2073 0 0 0 0 28
/**
 * A single polygon.
 */

2091 13 EggNurbsCurve 0 141313 13 EggNurbsCurve 13 EggNurbsCurve 0 0 0 0 1841 4 2431 2432 2433 2434 14 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1 2440 0 1 0 2083 0 0 0 0 36
/**
 * A parametric NURBS curve.
 */

2092 10 EggSurface 0 141313 10 EggSurface 10 EggSurface 0 0 0 0 1848 0 6 1842 1843 1844 1845 1846 1847 0 0 1 0 2073 0 0 0 0 67
/**
 * A parametric surface of some kind.  See EggNurbsSurface.
 */

2093 15 EggNurbsSurface 0 141313 15 EggNurbsSurface 15 EggNurbsSurface 0 0 0 0 1878 0 29 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 2 2441 2442 0 1 0 2092 0 0 0 5 2094 2096 2097 2099 2100 38
/**
 * A parametric NURBS surface.
 */

2094 6 Curves 0 2367488 23 EggNurbsSurface::Curves 23 EggNurbsSurface::Curves 2093 0 2095 0 0 0 0 0 0 0 0 0 0

2095 34 list< PointerTo< EggNurbsCurve > > 0 2048 39 std::list< PointerTo< EggNurbsCurve > > 39 std::list< PointerTo< EggNurbsCurve > > 0 0 0 0 0 0 0 0 0 0 0 0 0

2096 4 Loop 0 2367488 21 EggNurbsSurface::Loop 21 EggNurbsSurface::Loop 2093 0 2094 0 0 0 0 0 0 0 0 0 0

2097 5 Loops 0 2367488 22 EggNurbsSurface::Loops 22 EggNurbsSurface::Loops 2093 0 2098 0 0 0 0 0 0 0 0 0 0

2098 12 list< Loop > 0 2048 17 std::list< Loop > 34 std::list< EggNurbsSurface::Loop > 0 0 0 0 0 0 0 0 0 0 0 0 0

2099 4 Trim 0 2367488 21 EggNurbsSurface::Trim 21 EggNurbsSurface::Trim 2093 0 2097 0 0 0 0 0 0 0 0 0 0

2100 5 Trims 0 2367488 22 EggNurbsSurface::Trims 22 EggNurbsSurface::Trims 2093 0 2101 0 0 0 0 0 0 0 0 0 0

2101 12 list< Trim > 0 2048 17 std::list< Trim > 34 std::list< EggNurbsSurface::Trim > 0 0 0 0 0 0 0 0 0 0 0 0 0

2102 8 EggPatch 0 141313 8 EggPatch 8 EggPatch 0 0 0 0 1882 0 3 1879 1880 1881 0 0 1 0 2073 0 0 0 0 99
/**
 * A single "patch", a special primitive to be rendered only with a
 * tessellation shader.
 */

2103 8 EggPoint 0 141313 8 EggPoint 8 EggPoint 0 0 0 0 1894 0 11 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 0 0 1 0 2073 0 0 0 0 98
/**
 * A single point, or a collection of points as defined by a single
 * <PointLight> entry.
 */

2104 15 EggPolysetMaker 0 141313 15 EggPolysetMaker 15 EggPolysetMaker 0 0 0 1 1895 1898 0 2 1896 1897 0 0 1 0 2050 0 0 0 2 2105 2106 400
/**
 * A specialization on EggBinMaker for making polysets that share the same
 * basic rendering characteristic.  This really just defines the example
 * functions described in the leading comment to EggBinMaker.
 *
 * It makes some common assumptions about how polysets should be grouped; if
 * these are not sufficient, you can always rederive your own further
 * specialization of this class.
 */

2105 9 BinNumber 0 794624 26 EggPolysetMaker::BinNumber 26 EggPolysetMaker::BinNumber 2104 0 0 0 0 0 0 0 0 0 2 7 BN_none 24 EggPolysetMaker::BN_none 0
0 10 BN_polyset 27 EggPolysetMaker::BN_polyset 0
1 0 72
// The BinNumber serves to identify why a particular EggBin was created.

2106 10 Properties 0 794624 27 EggPolysetMaker::Properties 27 EggPolysetMaker::Properties 2104 0 0 0 0 0 0 0 0 0 10 13 P_has_texture 30 EggPolysetMaker::P_has_texture 0
1 9 P_texture 26 EggPolysetMaker::P_texture 0
2 14 P_has_material 31 EggPolysetMaker::P_has_material 0
4 10 P_material 27 EggPolysetMaker::P_material 0
8 16 P_has_poly_color 33 EggPolysetMaker::P_has_poly_color 0
16 12 P_poly_color 29 EggPolysetMaker::P_poly_color 0
32 17 P_has_poly_normal 34 EggPolysetMaker::P_has_poly_normal 0
64 19 P_has_vertex_normal 36 EggPolysetMaker::P_has_vertex_normal 0
128 18 P_has_vertex_color 35 EggPolysetMaker::P_has_vertex_color 0
256 7 P_bface 24 EggPolysetMaker::P_bface 0
512 0 0

2107 17 EggPoolUniquifier 0 141313 17 EggPoolUniquifier 17 EggPoolUniquifier 0 0 0 1 1899 1901 0 1 1900 0 0 1 0 2086 0 0 0 0 234
/**
 * This is a specialization of EggNameUniquifier to generate unique names for
 * textures, materials, and vertex pools prior to writing out an egg file.
 * It's automatically called by EggData prior to writing out an egg file.
 */

2108 12 EggSAnimData 0 141313 12 EggSAnimData 12 EggSAnimData 0 0 0 1 1902 1909 0 6 1903 1904 1905 1906 1907 1908 0 0 1 0 1993 0 0 0 0 158
/**
 * Corresponding to an <S$Anim> entry, this stores a single column of numbers,
 * for instance for a morph target, or as one column in an EggXfmSAnim.
 */

2109 8 EggTable 0 141313 8 EggTable 8 EggTable 0 0 0 1 1910 1917 0 6 1911 1912 1913 1914 1915 1916 0 0 1 0 2009 0 0 0 1 2110 295
/**
 * This corresponds to a <Table> or a <Bundle> entry.  As such, it doesn't
 * actually contain a table of numbers, but it may be a parent to an
 * EggSAnimData or an EggXfmAnimData, which do.  It may also be a parent to
 * another <Table> or <Bundle>, establishing a hierarchy of tables.
 */

2110 9 TableType 0 794624 19 EggTable::TableType 19 EggTable::TableType 2109 0 0 0 0 0 0 0 0 0 3 10 TT_invalid 20 EggTable::TT_invalid 0
0 8 TT_table 18 EggTable::TT_table 0
1 9 TT_bundle 19 EggTable::TT_bundle 0
2 0 0

2111 20 EggTextureCollection 0 26625 20 EggTextureCollection 20 EggTextureCollection 0 0 0 1 1918 1920 0 20 1919 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1 2443 0 0 0 0 229
/**
 * This is a collection of textures by TRef name.  It can extract the textures
 * from an egg file and sort them all together; it can also manage the
 * creation of unique textures and the assignment of unique TRef names.
 */

2112 14 EggTriangleFan 0 75777 14 EggTriangleFan 14 EggTriangleFan 0 0 0 0 1687 0 3 1940 1941 1942 0 0 1 0 2079 0 0 0 0 140
/**
 * A connected fan of triangles.  This does not normally appear in an egg
 * file; it is typically generated as a result of meshing.
 */

2113 16 EggTriangleStrip 0 75777 16 EggTriangleStrip 16 EggTriangleStrip 0 0 0 0 1687 0 3 1943 1944 1945 0 0 1 0 2079 0 0 0 0 142
/**
 * A connected strip of triangles.  This does not normally appear in an egg
 * file; it is typically generated as a result of meshing.
 */

2114 11 EggXfmSAnim 0 141313 11 EggXfmSAnim 11 EggXfmSAnim 0 0 0 1 1946 1969 0 22 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 0 0 1 0 2009 0 0 0 0 252
/**
 * This corresponds to an <Xfm$Anim_S$> entry, which is a collection of up to
 * nine <S$Anim> entries that specify the nine components of a transformation.
 * It's implemented as a group that can contain any number of EggSAnimData
 * children.
 */

2115 14 EggXfmAnimData 0 141313 14 EggXfmAnimData 14 EggXfmAnimData 0 0 0 1 1970 1986 0 15 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 0 0 1 0 1993 0 0 0 0 262
/**
 * Corresponding to an <Xfm$Anim> entry, this stores a two-dimensional table
 * with up to nine columns, one for each component of a transformation.  This
 * is an older syntax of egg anim table, not often used currently--it's
 * replaced by EggXfmSAnim.
 */

2116 13 EggUserData * 0 8576 13 EggUserData * 13 EggUserData * 0 0 1987 0 0 0 0 0 0 0 0 0 0

2117 19 EggUserData const * 0 8576 19 EggUserData const * 19 EggUserData const * 0 0 2118 0 0 0 0 0 0 0 0 0 0

2118 17 EggUserData const 0 8832 17 EggUserData const 17 EggUserData const 0 0 1987 0 0 0 0 0 0 0 0 0 0

2119 10 TypeHandle 0 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

2120 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 2119 0 0 0 0 0 0 0 0 0 0

2121 11 EggObject * 0 8576 11 EggObject * 11 EggObject * 0 0 1989 0 0 0 0 0 0 0 0 0 0

2122 17 EggObject const * 0 8576 17 EggObject const * 17 EggObject const * 0 0 2123 0 0 0 0 0 0 0 0 0 0

2123 15 EggObject const 0 8832 15 EggObject const 15 EggObject const 0 0 1989 0 0 0 0 0 0 0 0 0 0

2124 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

2125 22 EggNamedObject const * 0 8576 22 EggNamedObject const * 22 EggNamedObject const * 0 0 2126 0 0 0 0 0 0 0 0 0 0

2126 20 EggNamedObject const 0 8832 20 EggNamedObject const 20 EggNamedObject const 0 0 1990 0 0 0 0 0 0 0 0 0 0

2127 16 EggNamedObject * 0 8576 16 EggNamedObject * 16 EggNamedObject * 0 0 1990 0 0 0 0 0 0 0 0 0 0

2128 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

2129 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 2130 0 0 0 0 0 0 0 0 0 0

2130 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

2131 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 1991 0 0 0 0 0 0 0 0 0 0

2132 9 EggNode * 0 8576 9 EggNode * 9 EggNode * 0 0 1992 0 0 0 0 0 0 0 0 0 0

2133 15 EggNode const * 0 8576 15 EggNode const * 15 EggNode const * 0 0 2134 0 0 0 0 0 0 0 0 0 0

2134 13 EggNode const 0 8832 13 EggNode const 13 EggNode const 0 0 1992 0 0 0 0 0 0 0 0 0 0

2135 14 EggGroupNode * 0 8576 14 EggGroupNode * 14 EggGroupNode * 0 0 2009 0 0 0 0 0 0 0 0 0 0

2136 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 2137 0 0 0 0 0 0 0 0 0 0

2137 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 2138 0 0 0 0 0 0 0 0 0 0

2138 9 LMatrix4d 0 2048 9 LMatrix4d 9 LMatrix4d 0 0 0 0 0 0 0 0 0 0 0 0 45
/**
 * This is a 4-by-4 transform matrix.
 */

2139 15 vector_string * 0 8576 15 vector_string * 15 vector_string * 0 0 2140 0 0 0 0 0 0 0 0 0 0

2140 13 vector_string 0 2105344 13 vector_string 13 vector_string 0 0 2141 0 0 0 0 0 0 0 0 0 0

2141 17 pvector< string > 0 2048 22 pvector< std::string > 22 pvector< std::string > 0 0 0 0 0 0 0 0 0 0 0 0 0

2142 15 EggRenderMode * 0 8576 15 EggRenderMode * 15 EggRenderMode * 0 0 2011 0 0 0 0 0 0 0 0 0 0

2143 13 EggAnimData * 0 8576 13 EggAnimData * 13 EggAnimData * 0 0 1993 0 0 0 0 0 0 0 0 0 0

2144 19 EggAnimData const * 0 8576 19 EggAnimData const * 19 EggAnimData const * 0 0 2145 0 0 0 0 0 0 0 0 0 0

2145 17 EggAnimData const 0 8832 17 EggAnimData const 17 EggAnimData const 0 0 1993 0 0 0 0 0 0 0 0 0 0

2146 22 EggAnimPreload const * 0 8576 22 EggAnimPreload const * 22 EggAnimPreload const * 0 0 2147 0 0 0 0 0 0 0 0 0 0

2147 20 EggAnimPreload const 0 8832 20 EggAnimPreload const 20 EggAnimPreload const 0 0 1994 0 0 0 0 0 0 0 0 0 0

2148 16 EggAnimPreload * 0 8576 16 EggAnimPreload * 16 EggAnimPreload * 0 0 1994 0 0 0 0 0 0 0 0 0 0

2149 21 EggAttributes const * 0 8576 21 EggAttributes const * 21 EggAttributes const * 0 0 2150 0 0 0 0 0 0 0 0 0 0

2150 19 EggAttributes const 0 8832 19 EggAttributes const 19 EggAttributes const 0 0 1995 0 0 0 0 0 0 0 0 0 0

2151 16 LNormald const * 0 8576 16 LNormald const * 16 LNormald const * 0 0 2152 0 0 0 0 0 0 0 0 0 0

2152 14 LNormald const 0 8832 14 LNormald const 14 LNormald const 0 0 2153 0 0 0 0 0 0 0 0 0 0

2153 8 LNormald 0 2105344 8 LNormald 8 LNormald 0 0 2154 0 0 0 0 0 0 0 0 0 0

2154 9 LVector3d 0 2048 9 LVector3d 9 LVector3d 0 0 0 0 0 0 0 0 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

2155 8 LColor * 0 8576 8 LColor * 8 LColor * 0 0 2044 0 0 0 0 0 0 0 0 0 0

2156 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 2043 0 0 0 0 0 0 0 0 0 0

2157 12 MemoryBase * 0 8576 12 MemoryBase * 12 MemoryBase * 0 0 1996 0 0 0 0 0 0 0 0 0 0

2158 20 EggMorphNormalList * 0 8576 20 EggMorphNormalList * 20 EggMorphNormalList * 0 0 1997 0 0 0 0 0 0 0 0 0 0

2159 19 EggMorphColorList * 0 8576 19 EggMorphColorList * 19 EggMorphColorList * 0 0 1999 0 0 0 0 0 0 0 0 0 0

2160 19 EggVertexUV const * 0 8576 19 EggVertexUV const * 19 EggVertexUV const * 0 0 2161 0 0 0 0 0 0 0 0 0 0

2161 17 EggVertexUV const 0 8832 17 EggVertexUV const 17 EggVertexUV const 0 0 2001 0 0 0 0 0 0 0 0 0 0

2162 13 EggVertexUV * 0 8576 13 EggVertexUV * 13 EggVertexUV * 0 0 2001 0 0 0 0 0 0 0 0 0 0

2163 19 LTexCoord3d const * 0 8576 19 LTexCoord3d const * 19 LTexCoord3d const * 0 0 2164 0 0 0 0 0 0 0 0 0 0

2164 17 LTexCoord3d const 0 8832 17 LTexCoord3d const 17 LTexCoord3d const 0 0 2165 0 0 0 0 0 0 0 0 0 0

2165 11 LTexCoord3d 0 2105344 11 LTexCoord3d 11 LTexCoord3d 0 0 2034 0 0 0 0 0 0 0 0 0 0

2166 18 LTexCoordd const * 0 8576 18 LTexCoordd const * 18 LTexCoordd const * 0 0 2167 0 0 0 0 0 0 0 0 0 0

2167 16 LTexCoordd const 0 8832 16 LTexCoordd const 16 LTexCoordd const 0 0 2168 0 0 0 0 0 0 0 0 0 0

2168 10 LTexCoordd 0 2105344 10 LTexCoordd 10 LTexCoordd 0 0 2169 0 0 0 0 0 0 0 0 0 0

2169 8 LPoint2d 0 2048 8 LPoint2d 8 LPoint2d 0 0 0 0 0 0 0 0 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

2170 12 LTexCoordd * 0 8576 12 LTexCoordd * 12 LTexCoordd * 0 0 2168 0 0 0 0 0 0 0 0 0 0

2171 22 EggMorphTexCoordList * 0 8576 22 EggMorphTexCoordList * 22 EggMorphTexCoordList * 0 0 2002 0 0 0 0 0 0 0 0 0 0

2172 20 EggVertexAux const * 0 8576 20 EggVertexAux const * 20 EggVertexAux const * 0 0 2173 0 0 0 0 0 0 0 0 0 0

2173 18 EggVertexAux const 0 8832 18 EggVertexAux const 18 EggVertexAux const 0 0 2004 0 0 0 0 0 0 0 0 0 0

2174 14 EggVertexAux * 0 8576 14 EggVertexAux * 14 EggVertexAux * 0 0 2004 0 0 0 0 0 0 0 0 0 0

2175 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 2176 0 0 0 0 0 0 0 0 0 0

2176 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 2177 0 0 0 0 0 0 0 0 0 0

2177 10 LVecBase4d 0 2048 10 LVecBase4d 10 LVecBase4d 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

2178 17 EggVertex const * 0 8576 17 EggVertex const * 17 EggVertex const * 0 0 2179 0 0 0 0 0 0 0 0 0 0

2179 15 EggVertex const 0 8832 15 EggVertex const 15 EggVertex const 0 0 2005 0 0 0 0 0 0 0 0 0 0

2180 16 LPoint2d const * 0 8576 16 LPoint2d const * 16 LPoint2d const * 0 0 2181 0 0 0 0 0 0 0 0 0 0

2181 14 LPoint2d const 0 8832 14 LPoint2d const 14 LPoint2d const 0 0 2169 0 0 0 0 0 0 0 0 0 0

2182 16 LPoint3d const * 0 8576 16 LPoint3d const * 16 LPoint3d const * 0 0 2033 0 0 0 0 0 0 0 0 0 0

2183 16 LPoint4d const * 0 8576 16 LPoint4d const * 16 LPoint4d const * 0 0 2184 0 0 0 0 0 0 0 0 0 0

2184 14 LPoint4d const 0 8832 14 LPoint4d const 14 LPoint4d const 0 0 2185 0 0 0 0 0 0 0 0 0 0

2185 8 LPoint4d 0 2048 8 LPoint4d 8 LPoint4d 0 0 0 0 0 0 0 0 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

2186 10 LPoint2d * 0 8576 10 LPoint2d * 10 LPoint2d * 0 0 2169 0 0 0 0 0 0 0 0 0 0

2187 8 LVertexd 0 2105344 8 LVertexd 8 LVertexd 0 0 2034 0 0 0 0 0 0 0 0 0 0

2188 10 LVertexd * 0 8576 10 LVertexd * 10 LVertexd * 0 0 2187 0 0 0 0 0 0 0 0 0 0

2189 10 LPoint4d * 0 8576 10 LPoint4d * 10 LPoint4d * 0 0 2185 0 0 0 0 0 0 0 0 0 0

2190 16 EggGroup const * 0 8576 16 EggGroup const * 16 EggGroup const * 0 0 2191 0 0 0 0 0 0 0 0 0 0

2191 14 EggGroup const 0 8832 14 EggGroup const 14 EggGroup const 0 0 2020 0 0 0 0 0 0 0 0 0 0

2192 20 EggPrimitive const * 0 8576 20 EggPrimitive const * 20 EggPrimitive const * 0 0 2193 0 0 0 0 0 0 0 0 0 0

2193 18 EggPrimitive const 0 8832 18 EggPrimitive const 18 EggPrimitive const 0 0 2073 0 0 0 0 0 0 0 0 0 0

2194 20 EggMorphVertexList * 0 8576 20 EggMorphVertexList * 20 EggMorphVertexList * 0 0 2006 0 0 0 0 0 0 0 0 0 0

2195 21 EggVertexPool const * 0 8576 21 EggVertexPool const * 21 EggVertexPool const * 0 0 2196 0 0 0 0 0 0 0 0 0 0

2196 19 EggVertexPool const 0 8832 19 EggVertexPool const 19 EggVertexPool const 0 0 2008 0 0 0 0 0 0 0 0 0 0

2197 9 size_type 0 2367488 24 EggVertexPool::size_type 24 EggVertexPool::size_type 2008 0 2198 0 0 0 0 0 0 0 0 0 0

2198 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0

2199 14 EggPrimitive * 0 8576 14 EggPrimitive * 14 EggPrimitive * 0 0 2073 0 0 0 0 0 0 0 0 0 0

2200 20 EggGroupNode const * 0 8576 20 EggGroupNode const * 20 EggGroupNode const * 0 0 2201 0 0 0 0 0 0 0 0 0 0

2201 18 EggGroupNode const 0 8832 18 EggGroupNode const 18 EggGroupNode const 0 0 2009 0 0 0 0 0 0 0 0 0 0

2202 9 size_type 0 2367488 23 EggGroupNode::size_type 23 EggGroupNode::size_type 2009 0 2198 0 0 0 0 0 0 0 0 0 0

2203 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 2204 0 0 0 0 0 0 0 0 0 0

2204 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 2205 0 0 0 0 0 0 0 0 0 0

2205 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

2206 19 DSearchPath const * 0 8576 19 DSearchPath const * 19 DSearchPath const * 0 0 2207 0 0 0 0 0 0 0 0 0 0

2207 17 DSearchPath const 0 8832 17 DSearchPath const 17 DSearchPath const 0 0 2208 0 0 0 0 0 0 0 0 0 0

2208 11 DSearchPath 0 2048 11 DSearchPath 11 DSearchPath 0 0 0 0 0 0 0 0 0 0 0 0 304
/**
 * This class stores a list of directories that can be searched, in order, to
 * locate a particular file.  It is normally constructed by passing it a
 * traditional searchpath-style string, e.g.  a list of directory names
 * delimited by spaces or colons, but it can also be built up explicitly.
 */

2209 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 2069 0 0 0 0 0 0 0 0 0 0

2210 16 CoordinateSystem 0 532480 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210
// The CS_default entry does not refer to a particular coordinate system,
// but rather to the value stored in default_coordinate_system, which in
// turn is loaded from the config variable "coordinate-system".
0 12 CS_zup_right 12 CS_zup_right 0
1 12 CS_yup_right 12 CS_yup_right 0
2 11 CS_zup_left 11 CS_zup_left 0
3 11 CS_yup_left 11 CS_yup_left 0
4 10 CS_invalid 10 CS_invalid 156
// CS_invalid is not a coordinate system at all.  It can be used in user-
// input processing code to indicate a contradictory coordinate system
// request.
5 0 0

2211 19 GlobPattern const * 0 8576 19 GlobPattern const * 19 GlobPattern const * 0 0 2212 0 0 0 0 0 0 0 0 0 0

2212 17 GlobPattern const 0 8832 17 GlobPattern const 17 GlobPattern const 0 0 2213 0 0 0 0 0 0 0 0 0 0

2213 11 GlobPattern 0 2048 11 GlobPattern 11 GlobPattern 0 0 0 0 0 0 0 0 0 0 0 0 538
/**
 * This class can be used to test for string matches against standard Unix-
 * shell filename globbing conventions.  It serves as a portable standin for
 * the Posix fnmatch() call.
 *
 * A GlobPattern is given a pattern string, which can contain operators like
 * *, ?, and [].  Then it can be tested against any number of candidate
 * strings; for each candidate, it will indicate whether the string matches
 * the pattern or not.  It can be used, for example, to scan a directory for
 * all files matching a particular pattern.
 */

2214 21 vector_string const * 0 8576 21 vector_string const * 21 vector_string const * 0 0 2215 0 0 0 0 0 0 0 0 0 0

2215 19 vector_string const 0 8832 19 vector_string const 19 vector_string const 0 0 2140 0 0 0 0 0 0 0 0 0 0

2216 17 LVector2d const * 0 8576 17 LVector2d const * 17 LVector2d const * 0 0 2217 0 0 0 0 0 0 0 0 0 0

2217 15 LVector2d const 0 8832 15 LVector2d const 15 LVector2d const 0 0 2218 0 0 0 0 0 0 0 0 0 0

2218 9 LVector2d 0 2048 9 LVector2d 9 LVector2d 0 0 0 0 0 0 0 0 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

2219 21 EggRenderMode const * 0 8576 21 EggRenderMode const * 21 EggRenderMode const * 0 0 2220 0 0 0 0 0 0 0 0 0 0

2220 19 EggRenderMode const 0 8832 19 EggRenderMode const 19 EggRenderMode const 0 0 2011 0 0 0 0 0 0 0 0 0 0

2221 14 EggTransform * 0 8576 14 EggTransform * 14 EggTransform * 0 0 2016 0 0 0 0 0 0 0 0 0 0

2222 20 EggTransform const * 0 8576 20 EggTransform const * 20 EggTransform const * 0 0 2048 0 0 0 0 0 0 0 0 0 0

2223 17 LVector3d const * 0 8576 17 LVector3d const * 17 LVector3d const * 0 0 2224 0 0 0 0 0 0 0 0 0 0

2224 15 LVector3d const 0 8832 15 LVector3d const 15 LVector3d const 0 0 2154 0 0 0 0 0 0 0 0 0 0

2225 20 LQuaterniond const * 0 8576 20 LQuaterniond const * 20 LQuaterniond const * 0 0 2226 0 0 0 0 0 0 0 0 0 0

2226 18 LQuaterniond const 0 8832 18 LQuaterniond const 18 LQuaterniond const 0 0 2227 0 0 0 0 0 0 0 0 0 0

2227 12 LQuaterniond 0 2048 12 LQuaterniond 12 LQuaterniond 0 0 0 0 0 0 0 0 0 0 0 0 44
/**
 * This is the base quaternion class
 */

2228 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 2229 0 0 0 0 0 0 0 0 0 0

2229 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 2230 0 0 0 0 0 0 0 0 0 0

2230 10 LVecBase2d 0 2048 10 LVecBase2d 10 LVecBase2d 0 0 0 0 0 0 0 0 0 0 0 0 75
/**
 * This is the base class for all two-component vectors and points.
 */

2231 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 2232 0 0 0 0 0 0 0 0 0 0

2232 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 2233 0 0 0 0 0 0 0 0 0 0

2233 10 LVecBase3d 0 2048 10 LVecBase3d 10 LVecBase3d 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

2234 17 LMatrix3d const * 0 8576 17 LMatrix3d const * 17 LMatrix3d const * 0 0 2235 0 0 0 0 0 0 0 0 0 0

2235 15 LMatrix3d const 0 8832 15 LMatrix3d const 15 LMatrix3d const 0 0 2236 0 0 0 0 0 0 0 0 0 0

2236 9 LMatrix3d 0 2048 9 LMatrix3d 9 LMatrix3d 0 0 0 0 0 0 0 0 0 0 0 0 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

2237 11 LMatrix3d * 0 8576 11 LMatrix3d * 11 LMatrix3d * 0 0 2236 0 0 0 0 0 0 0 0 0 0

2238 26 EggSwitchCondition const * 0 8576 26 EggSwitchCondition const * 26 EggSwitchCondition const * 0 0 2047 0 0 0 0 0 0 0 0 0 0

2239 20 EggSwitchCondition * 0 8576 20 EggSwitchCondition * 20 EggSwitchCondition * 0 0 2018 0 0 0 0 0 0 0 0 0 0

2240 28 EggSwitchConditionDistance * 0 8576 28 EggSwitchConditionDistance * 28 EggSwitchConditionDistance * 0 0 2019 0 0 0 0 0 0 0 0 0 0

2241 10 EggGroup * 0 8576 10 EggGroup * 10 EggGroup * 0 0 2020 0 0 0 0 0 0 0 0 0 0

2242 13 CollideMask * 0 8576 13 CollideMask * 13 CollideMask * 0 0 2040 0 0 0 0 0 0 0 0 0 0

2243 12 double const 0 8832 12 double const 12 double const 0 0 2039 0 0 0 0 0 0 0 0 0 0

2244 14 EggBin const * 0 8576 14 EggBin const * 14 EggBin const * 0 0 2245 0 0 0 0 0 0 0 0 0 0

2245 12 EggBin const 0 8832 12 EggBin const 12 EggBin const 0 0 2049 0 0 0 0 0 0 0 0 0 0

2246 8 EggBin * 0 8576 8 EggBin * 8 EggBin * 0 0 2049 0 0 0 0 0 0 0 0 0 0

2247 13 EggBinMaker * 0 8576 13 EggBinMaker * 13 EggBinMaker * 0 0 2050 0 0 0 0 0 0 0 0 0 0

2248 18 EggComment const * 0 8576 18 EggComment const * 18 EggComment const * 0 0 2249 0 0 0 0 0 0 0 0 0 0

2249 16 EggComment const 0 8832 16 EggComment const 16 EggComment const 0 0 2051 0 0 0 0 0 0 0 0 0 0

2250 12 EggComment * 0 8576 12 EggComment * 12 EggComment * 0 0 2051 0 0 0 0 0 0 0 0 0 0

2251 17 EggFilenameNode * 0 8576 17 EggFilenameNode * 17 EggFilenameNode * 0 0 2052 0 0 0 0 0 0 0 0 0 0

2252 23 EggFilenameNode const * 0 8576 23 EggFilenameNode const * 23 EggFilenameNode const * 0 0 2253 0 0 0 0 0 0 0 0 0 0

2253 21 EggFilenameNode const 0 8832 21 EggFilenameNode const 21 EggFilenameNode const 0 0 2052 0 0 0 0 0 0 0 0 0 0

2254 18 EggTexture const * 0 8576 18 EggTexture const * 18 EggTexture const * 0 0 2255 0 0 0 0 0 0 0 0 0 0

2255 16 EggTexture const 0 8832 16 EggTexture const 16 EggTexture const 0 0 2053 0 0 0 0 0 0 0 0 0 0

2256 19 EggMaterial const * 0 8576 19 EggMaterial const * 19 EggMaterial const * 0 0 2257 0 0 0 0 0 0 0 0 0 0

2257 17 EggMaterial const 0 8832 17 EggMaterial const 17 EggMaterial const 0 0 2071 0 0 0 0 0 0 0 0 0 0

2258 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 2198 0 0 0 0 0 0 0 0 0 0

2259 23 EggCompositePrimitive * 0 8576 23 EggCompositePrimitive * 23 EggCompositePrimitive * 0 0 2079 0 0 0 0 0 0 0 0 0 0

2260 29 EggCompositePrimitive const * 0 8576 29 EggCompositePrimitive const * 29 EggCompositePrimitive const * 0 0 2261 0 0 0 0 0 0 0 0 0 0

2261 27 EggCompositePrimitive const 0 8832 27 EggCompositePrimitive const 27 EggCompositePrimitive const 0 0 2079 0 0 0 0 0 0 0 0 0 0

2262 9 EggData * 0 8576 9 EggData * 9 EggData * 0 0 2081 0 0 0 0 0 0 0 0 0 0

2263 15 EggData const * 0 8576 15 EggData const * 15 EggData const * 0 0 2264 0 0 0 0 0 0 0 0 0 0

2264 13 EggData const 0 8832 13 EggData const 13 EggData const 0 0 2081 0 0 0 0 0 0 0 0 0 0

2265 10 Filename * 0 8576 10 Filename * 10 Filename * 0 0 2070 0 0 0 0 0 0 0 0 0 0

2266 9 istream * 0 8576 9 istream * 9 istream * 0 0 2267 0 0 0 0 0 0 0 0 0 0

2267 7 istream 0 2048 7 istream 7 istream 0 0 0 0 0 0 0 0 0 0 0 0 0

2268 16 BamCacheRecord * 0 8576 16 BamCacheRecord * 16 BamCacheRecord * 0 0 2269 0 0 0 0 0 0 0 0 0 0

2269 14 BamCacheRecord 0 2048 14 BamCacheRecord 14 BamCacheRecord 0 0 0 0 0 0 0 0 0 0 0 0 231
/**
 * An instance of this class is written to the front of a Bam or Txo file to
 * make the file a cached instance of some other loadable resource.  This
 * record contains information needed to test the validity of the cache.
 */

2270 6 time_t 0 2105344 6 time_t 6 time_t 0 0 2271 0 0 0 0 0 0 0 0 0 0

2271 8 long int 0 8210 8 long int 8 long int 0 1 0 0 0 0 0 0 0 0 0 0 0

2272 21 EggCoordinateSystem * 0 8576 21 EggCoordinateSystem * 21 EggCoordinateSystem * 0 0 2082 0 0 0 0 0 0 0 0 0 0

2273 27 EggCoordinateSystem const * 0 8576 27 EggCoordinateSystem const * 27 EggCoordinateSystem const * 0 0 2274 0 0 0 0 0 0 0 0 0 0

2274 25 EggCoordinateSystem const 0 8832 25 EggCoordinateSystem const 25 EggCoordinateSystem const 0 0 2082 0 0 0 0 0 0 0 0 0 0

2275 10 EggCurve * 0 8576 10 EggCurve * 10 EggCurve * 0 0 2083 0 0 0 0 0 0 0 0 0 0

2276 16 EggCurve const * 0 8576 16 EggCurve const * 16 EggCurve const * 0 0 2277 0 0 0 0 0 0 0 0 0 0

2277 14 EggCurve const 0 8832 14 EggCurve const 14 EggCurve const 0 0 2083 0 0 0 0 0 0 0 0 0 0

2278 28 EggExternalReference const * 0 8576 28 EggExternalReference const * 28 EggExternalReference const * 0 0 2279 0 0 0 0 0 0 0 0 0 0

2279 26 EggExternalReference const 0 8832 26 EggExternalReference const 26 EggExternalReference const 0 0 2085 0 0 0 0 0 0 0 0 0 0

2280 22 EggExternalReference * 0 8576 22 EggExternalReference * 22 EggExternalReference * 0 0 2085 0 0 0 0 0 0 0 0 0 0

2281 19 EggNameUniquifier * 0 8576 19 EggNameUniquifier * 19 EggNameUniquifier * 0 0 2086 0 0 0 0 0 0 0 0 0 0

2282 25 EggNameUniquifier const * 0 8576 25 EggNameUniquifier const * 25 EggNameUniquifier const * 0 0 2283 0 0 0 0 0 0 0 0 0 0

2283 23 EggNameUniquifier const 0 8832 23 EggNameUniquifier const 23 EggNameUniquifier const 0 0 2086 0 0 0 0 0 0 0 0 0 0

2284 20 EggGroupUniquifier * 0 8576 20 EggGroupUniquifier * 20 EggGroupUniquifier * 0 0 2087 0 0 0 0 0 0 0 0 0 0

2285 9 EggLine * 0 8576 9 EggLine * 9 EggLine * 0 0 2088 0 0 0 0 0 0 0 0 0 0

2286 15 EggLine const * 0 8576 15 EggLine const * 15 EggLine const * 0 0 2287 0 0 0 0 0 0 0 0 0 0

2287 13 EggLine const 0 8832 13 EggLine const 13 EggLine const 0 0 2088 0 0 0 0 0 0 0 0 0 0

2288 23 EggMaterialCollection * 0 8576 23 EggMaterialCollection * 23 EggMaterialCollection * 0 0 2089 0 0 0 0 0 0 0 0 0 0

2289 29 EggMaterialCollection const * 0 8576 29 EggMaterialCollection const * 29 EggMaterialCollection const * 0 0 2290 0 0 0 0 0 0 0 0 0 0

2290 27 EggMaterialCollection const 0 8832 27 EggMaterialCollection const 27 EggMaterialCollection const 0 0 2089 0 0 0 0 0 0 0 0 0 0

2291 21 MaterialReplacement * 0 8576 44 EggMaterialCollection::MaterialReplacement * 44 EggMaterialCollection::MaterialReplacement * 0 0 2292 0 0 0 0 0 0 0 0 0 0

2292 19 MaterialReplacement 0 2367488 42 EggMaterialCollection::MaterialReplacement 42 EggMaterialCollection::MaterialReplacement 2089 0 2293 0 0 0 0 0 0 0 0 0 0

2293 37 map< PT_EggMaterial, PT_EggMaterial > 0 2048 37 map< PT_EggMaterial, PT_EggMaterial > 37 map< PT_EggMaterial, PT_EggMaterial > 0 0 0 0 0 0 0 0 0 0 0 0 0

2294 27 MaterialReplacement const * 0 8576 50 EggMaterialCollection::MaterialReplacement const * 50 EggMaterialCollection::MaterialReplacement const * 0 0 2295 0 0 0 0 0 0 0 0 0 0

2295 25 MaterialReplacement const 0 8832 48 EggMaterialCollection::MaterialReplacement const 48 EggMaterialCollection::MaterialReplacement const 0 0 2292 0 0 0 0 0 0 0 0 0 0

2296 12 EggPolygon * 0 8576 12 EggPolygon * 12 EggPolygon * 0 0 2090 0 0 0 0 0 0 0 0 0 0

2297 18 EggPolygon const * 0 8576 18 EggPolygon const * 18 EggPolygon const * 0 0 2298 0 0 0 0 0 0 0 0 0 0

2298 16 EggPolygon const 0 8832 16 EggPolygon const 16 EggPolygon const 0 0 2090 0 0 0 0 0 0 0 0 0 0

2299 10 LNormald * 0 8576 10 LNormald * 10 LNormald * 0 0 2153 0 0 0 0 0 0 0 0 0 0

2300 15 EggNurbsCurve * 0 8576 15 EggNurbsCurve * 15 EggNurbsCurve * 0 0 2091 0 0 0 0 0 0 0 0 0 0

2301 21 EggNurbsCurve const * 0 8576 21 EggNurbsCurve const * 21 EggNurbsCurve const * 0 0 2302 0 0 0 0 0 0 0 0 0 0

2302 19 EggNurbsCurve const 0 8832 19 EggNurbsCurve const 19 EggNurbsCurve const 0 0 2091 0 0 0 0 0 0 0 0 0 0

2303 12 EggSurface * 0 8576 12 EggSurface * 12 EggSurface * 0 0 2092 0 0 0 0 0 0 0 0 0 0

2304 18 EggSurface const * 0 8576 18 EggSurface const * 18 EggSurface const * 0 0 2305 0 0 0 0 0 0 0 0 0 0

2305 16 EggSurface const 0 8832 16 EggSurface const 16 EggSurface const 0 0 2092 0 0 0 0 0 0 0 0 0 0

2306 17 EggNurbsSurface * 0 8576 17 EggNurbsSurface * 17 EggNurbsSurface * 0 0 2093 0 0 0 0 0 0 0 0 0 0

2307 23 EggNurbsSurface const * 0 8576 23 EggNurbsSurface const * 23 EggNurbsSurface const * 0 0 2308 0 0 0 0 0 0 0 0 0 0

2308 21 EggNurbsSurface const 0 8832 21 EggNurbsSurface const 21 EggNurbsSurface const 0 0 2093 0 0 0 0 0 0 0 0 0 0

2309 10 EggPatch * 0 8576 10 EggPatch * 10 EggPatch * 0 0 2102 0 0 0 0 0 0 0 0 0 0

2310 16 EggPatch const * 0 8576 16 EggPatch const * 16 EggPatch const * 0 0 2311 0 0 0 0 0 0 0 0 0 0

2311 14 EggPatch const 0 8832 14 EggPatch const 14 EggPatch const 0 0 2102 0 0 0 0 0 0 0 0 0 0

2312 10 EggPoint * 0 8576 10 EggPoint * 10 EggPoint * 0 0 2103 0 0 0 0 0 0 0 0 0 0

2313 16 EggPoint const * 0 8576 16 EggPoint const * 16 EggPoint const * 0 0 2314 0 0 0 0 0 0 0 0 0 0

2314 14 EggPoint const 0 8832 14 EggPoint const 14 EggPoint const 0 0 2103 0 0 0 0 0 0 0 0 0 0

2315 17 EggPolysetMaker * 0 8576 17 EggPolysetMaker * 17 EggPolysetMaker * 0 0 2104 0 0 0 0 0 0 0 0 0 0

2316 19 EggPoolUniquifier * 0 8576 19 EggPoolUniquifier * 19 EggPoolUniquifier * 0 0 2107 0 0 0 0 0 0 0 0 0 0

2317 20 EggSAnimData const * 0 8576 20 EggSAnimData const * 20 EggSAnimData const * 0 0 2318 0 0 0 0 0 0 0 0 0 0

2318 18 EggSAnimData const 0 8832 18 EggSAnimData const 18 EggSAnimData const 0 0 2108 0 0 0 0 0 0 0 0 0 0

2319 14 EggSAnimData * 0 8576 14 EggSAnimData * 14 EggSAnimData * 0 0 2108 0 0 0 0 0 0 0 0 0 0

2320 16 EggTable const * 0 8576 16 EggTable const * 16 EggTable const * 0 0 2321 0 0 0 0 0 0 0 0 0 0

2321 14 EggTable const 0 8832 14 EggTable const 14 EggTable const 0 0 2109 0 0 0 0 0 0 0 0 0 0

2322 10 EggTable * 0 8576 10 EggTable * 10 EggTable * 0 0 2109 0 0 0 0 0 0 0 0 0 0

2323 22 EggTextureCollection * 0 8576 22 EggTextureCollection * 22 EggTextureCollection * 0 0 2111 0 0 0 0 0 0 0 0 0 0

2324 28 EggTextureCollection const * 0 8576 28 EggTextureCollection const * 28 EggTextureCollection const * 0 0 2325 0 0 0 0 0 0 0 0 0 0

2325 26 EggTextureCollection const 0 8832 26 EggTextureCollection const 26 EggTextureCollection const 0 0 2111 0 0 0 0 0 0 0 0 0 0

2326 20 TextureReplacement * 0 8576 42 EggTextureCollection::TextureReplacement * 42 EggTextureCollection::TextureReplacement * 0 0 2327 0 0 0 0 0 0 0 0 0 0

2327 18 TextureReplacement 0 2367488 40 EggTextureCollection::TextureReplacement 40 EggTextureCollection::TextureReplacement 2111 0 2328 0 0 0 0 0 0 0 0 0 0

2328 35 map< PT_EggTexture, PT_EggTexture > 0 2048 35 map< PT_EggTexture, PT_EggTexture > 35 map< PT_EggTexture, PT_EggTexture > 0 0 0 0 0 0 0 0 0 0 0 0 0

2329 26 TextureReplacement const * 0 8576 48 EggTextureCollection::TextureReplacement const * 48 EggTextureCollection::TextureReplacement const * 0 0 2330 0 0 0 0 0 0 0 0 0 0

2330 24 TextureReplacement const 0 8832 46 EggTextureCollection::TextureReplacement const 46 EggTextureCollection::TextureReplacement const 0 0 2327 0 0 0 0 0 0 0 0 0 0

2331 9 size_type 0 2367488 31 EggTextureCollection::size_type 31 EggTextureCollection::size_type 2111 0 2198 0 0 0 0 0 0 0 0 0 0

2332 16 EggTriangleFan * 0 8576 16 EggTriangleFan * 16 EggTriangleFan * 0 0 2112 0 0 0 0 0 0 0 0 0 0

2333 22 EggTriangleFan const * 0 8576 22 EggTriangleFan const * 22 EggTriangleFan const * 0 0 2334 0 0 0 0 0 0 0 0 0 0

2334 20 EggTriangleFan const 0 8832 20 EggTriangleFan const 20 EggTriangleFan const 0 0 2112 0 0 0 0 0 0 0 0 0 0

2335 18 EggTriangleStrip * 0 8576 18 EggTriangleStrip * 18 EggTriangleStrip * 0 0 2113 0 0 0 0 0 0 0 0 0 0

2336 24 EggTriangleStrip const * 0 8576 24 EggTriangleStrip const * 24 EggTriangleStrip const * 0 0 2337 0 0 0 0 0 0 0 0 0 0

2337 22 EggTriangleStrip const 0 8832 22 EggTriangleStrip const 22 EggTriangleStrip const 0 0 2113 0 0 0 0 0 0 0 0 0 0

2338 22 EggXfmAnimData const * 0 8576 22 EggXfmAnimData const * 22 EggXfmAnimData const * 0 0 2339 0 0 0 0 0 0 0 0 0 0

2339 20 EggXfmAnimData const 0 8832 20 EggXfmAnimData const 20 EggXfmAnimData const 0 0 2115 0 0 0 0 0 0 0 0 0 0

2340 13 EggXfmSAnim * 0 8576 13 EggXfmSAnim * 13 EggXfmSAnim * 0 0 2114 0 0 0 0 0 0 0 0 0 0

2341 19 EggXfmSAnim const * 0 8576 19 EggXfmSAnim const * 19 EggXfmSAnim const * 0 0 2342 0 0 0 0 0 0 0 0 0 0

2342 17 EggXfmSAnim const 0 8832 17 EggXfmSAnim const 17 EggXfmSAnim const 0 0 2114 0 0 0 0 0 0 0 0 0 0

2343 11 LMatrix4d * 0 8576 11 LMatrix4d * 11 LMatrix4d * 0 0 2138 0 0 0 0 0 0 0 0 0 0

2344 16 EggXfmAnimData * 0 8576 16 EggXfmAnimData * 16 EggXfmAnimData * 0 0 2115 0 0 0 0 0 0 0 0 0 0

0
90
2345 9 _dnormals 0 2 1997 1108 0 0 0 0 0 24 EggAttributes::_dnormals 0

2346 7 _drgbas 0 2 1999 1109 0 0 0 0 0 22 EggAttributes::_drgbas 0

2347 5 _duvs 0 2 2002 1133 0 0 0 0 0 18 EggVertexUV::_duvs 0

2348 6 _dxyzs 0 2 2006 1196 0 0 0 0 0 17 EggVertex::_dxyzs 0

2349 10 group_type 0 6 2025 1366 1365 0 0 0 0 20 EggGroup::group_type 0

2350 14 billboard_type 0 6 2027 1369 1368 0 0 0 0 24 EggGroup::billboard_type 0

2351 16 billboard_center 0 30 2033 1373 1370 1372 1371 0 0 26 EggGroup::billboard_center 0

2352 7 cs_type 0 6 2028 1375 1374 0 0 0 0 17 EggGroup::cs_type 0

2353 13 collide_flags 0 6 2029 1377 1376 0 0 0 0 23 EggGroup::collide_flags 0

2354 14 collision_name 0 6 2035 1381 1378 0 0 0 0 24 EggGroup::collision_name 0

2355 8 dcs_type 0 6 2026 1383 1382 0 0 0 0 18 EggGroup::dcs_type 0

2356 9 dart_type 0 6 2030 1386 1385 0 0 0 0 19 EggGroup::dart_type 0

2357 11 switch_flag 0 6 2038 1388 1387 0 0 0 0 21 EggGroup::switch_flag 0

2358 10 switch_fps 0 6 2039 1390 1389 0 0 0 0 20 EggGroup::switch_fps 0

2359 12 object_types 0 66 2036 1394 0 0 0 0 1393 22 EggGroup::object_types 0

2360 10 model_flag 0 6 2038 1398 1397 0 0 0 0 20 EggGroup::model_flag 0

2361 12 texlist_flag 0 6 2038 1400 1399 0 0 0 0 22 EggGroup::texlist_flag 0

2362 10 nofog_flag 0 6 2038 1402 1401 0 0 0 0 20 EggGroup::nofog_flag 0

2363 10 decal_flag 0 6 2038 1404 1403 0 0 0 0 20 EggGroup::decal_flag 0

2364 11 direct_flag 0 6 2038 1406 1405 0 0 0 0 21 EggGroup::direct_flag 0

2365 11 portal_flag 0 6 2038 1408 1407 0 0 0 0 21 EggGroup::portal_flag 0

2366 13 occluder_flag 0 6 2038 1410 1409 0 0 0 0 23 EggGroup::occluder_flag 0

2367 12 indexed_flag 0 30 2038 1416 1413 1415 1414 0 0 22 EggGroup::indexed_flag 0

2368 12 collide_mask 0 30 2040 1420 1417 1419 1418 0 0 22 EggGroup::collide_mask 0

2369 17 from_collide_mask 0 30 2040 1424 1421 1423 1422 0 0 27 EggGroup::from_collide_mask 0

2370 17 into_collide_mask 0 30 2040 1428 1425 1427 1426 0 0 27 EggGroup::into_collide_mask 0

2371 10 blend_mode 0 6 2031 1430 1429 0 0 0 0 20 EggGroup::blend_mode 0

2372 15 blend_operand_a 0 6 2032 1432 1431 0 0 0 0 25 EggGroup::blend_operand_a 0

2373 15 blend_operand_b 0 6 2032 1434 1433 0 0 0 0 25 EggGroup::blend_operand_b 0

2374 11 blend_color 0 30 2043 1438 1435 1437 1436 0 0 21 EggGroup::blend_color 0

2375 3 lod 0 30 2047 1442 1439 1441 1440 0 0 13 EggGroup::lod 0

2376 12 default_pose 0 6 2048 1447 1449 0 0 0 0 22 EggGroup::default_pose 0

2377 8 scroll_u 0 6 2039 1455 1451 0 0 0 0 18 EggGroup::scroll_u 0

2378 8 scroll_v 0 6 2039 1456 1452 0 0 0 0 18 EggGroup::scroll_v 0

2379 8 scroll_w 0 6 2039 1457 1453 0 0 0 0 18 EggGroup::scroll_w 0

2380 8 scroll_r 0 6 2039 1458 1454 0 0 0 0 18 EggGroup::scroll_r 0

2381 12 texture_type 0 6 2055 1523 1522 0 0 0 0 24 EggTexture::texture_type 0

2382 6 format 0 6 2056 1525 1524 0 0 0 0 18 EggTexture::format 0

2383 16 compression_mode 0 6 2057 1527 1526 0 0 0 0 28 EggTexture::compression_mode 0

2384 9 wrap_mode 0 6 2058 1529 1528 0 0 0 0 21 EggTexture::wrap_mode 0

2385 6 wrap_u 0 6 2058 1531 1530 0 0 0 0 18 EggTexture::wrap_u 0

2386 6 wrap_v 0 6 2058 1534 1533 0 0 0 0 18 EggTexture::wrap_v 0

2387 6 wrap_w 0 6 2058 1537 1536 0 0 0 0 18 EggTexture::wrap_w 0

2388 9 minfilter 0 6 2059 1540 1539 0 0 0 0 21 EggTexture::minfilter 0

2389 9 magfilter 0 6 2059 1542 1541 0 0 0 0 21 EggTexture::magfilter 0

2390 18 anisotropic_degree 0 30 2068 1546 1543 1545 1544 0 0 30 EggTexture::anisotropic_degree 0

2391 8 env_type 0 6 2060 1548 1547 0 0 0 0 20 EggTexture::env_type 0

2392 12 saved_result 0 6 2038 1557 1556 0 0 0 0 24 EggTexture::saved_result 0

2393 7 tex_gen 0 6 2066 1559 1558 0 0 0 0 19 EggTexture::tex_gen 0

2394 13 quality_level 0 6 2067 1561 1560 0 0 0 0 25 EggTexture::quality_level 0

2395 10 stage_name 0 30 2035 1565 1562 1564 1563 0 0 22 EggTexture::stage_name 0

2396 8 priority 0 30 2068 1569 1566 1568 1567 0 0 20 EggTexture::priority 0

2397 5 color 0 30 2043 1573 1570 1572 1571 0 0 17 EggTexture::color 0

2398 12 border_color 0 30 2043 1577 1574 1576 1575 0 0 24 EggTexture::border_color 0

2399 7 uv_name 0 30 2035 1581 1578 1580 1579 0 0 19 EggTexture::uv_name 0

2400 9 rgb_scale 0 30 2068 1585 1582 1584 1583 0 0 21 EggTexture::rgb_scale 0

2401 11 alpha_scale 0 30 2068 1589 1586 1588 1587 0 0 23 EggTexture::alpha_scale 0

2402 14 alpha_filename 0 30 2069 1593 1590 1592 1591 0 0 26 EggTexture::alpha_filename 0

2403 14 alpha_fullpath 0 6 2069 1595 1594 0 0 0 0 26 EggTexture::alpha_fullpath 0

2404 18 alpha_file_channel 0 30 2068 1599 1596 1598 1597 0 0 30 EggTexture::alpha_file_channel 0

2405 9 multiview 0 6 2038 1601 1600 0 0 0 0 21 EggTexture::multiview 0

2406 9 num_views 0 30 2068 1605 1602 1604 1603 0 0 21 EggTexture::num_views 0

2407 12 read_mipmaps 0 6 2038 1607 1606 0 0 0 0 24 EggTexture::read_mipmaps 0

2408 7 min_lod 0 30 2039 1611 1608 1610 1609 0 0 19 EggTexture::min_lod 0

2409 7 max_lod 0 30 2039 1615 1612 1614 1613 0 0 19 EggTexture::max_lod 0

2410 8 lod_bias 0 30 2039 1619 1616 1618 1617 0 0 20 EggTexture::lod_bias 0

2411 17 multitexture_sort 0 2 2068 1622 0 0 0 0 0 29 EggTexture::multitexture_sort 0

2412 4 base 0 30 2044 1641 1638 1640 1639 0 0 17 EggMaterial::base 0

2413 4 diff 0 30 2044 1645 1642 1644 1643 0 0 17 EggMaterial::diff 0

2414 3 amb 0 30 2044 1649 1646 1648 1647 0 0 16 EggMaterial::amb 0

2415 4 emit 0 30 2044 1653 1650 1652 1651 0 0 17 EggMaterial::emit 0

2416 4 spec 0 30 2044 1657 1654 1656 1655 0 0 17 EggMaterial::spec 0

2417 9 shininess 0 30 2039 1661 1658 1660 1659 0 0 22 EggMaterial::shininess 0

2418 9 roughness 0 30 2039 1665 1662 1664 1663 0 0 22 EggMaterial::roughness 0

2419 8 metallic 0 30 2039 1669 1666 1668 1667 0 0 21 EggMaterial::metallic 0

2420 3 ior 0 30 2039 1673 1670 1672 1671 0 0 16 EggMaterial::ior 0

2421 5 local 0 30 2038 1677 1674 1676 1675 0 0 18 EggMaterial::local 0

2422 9 sort_name 0 2 2036 1696 0 0 0 0 0 23 EggPrimitive::sort_name 0

2423 7 shading 0 2 2074 1697 0 0 0 0 0 21 EggPrimitive::shading 0

2424 17 connected_shading 0 2 2074 1699 0 0 0 0 0 31 EggPrimitive::connected_shading 0

2425 8 textures 0 66 2075 1702 0 0 0 0 1705 22 EggPrimitive::textures 0

2426 8 material 0 30 2076 1708 1706 1709 1707 0 0 22 EggPrimitive::material 0

2427 10 bface_flag 0 6 2038 1711 1710 0 0 0 0 24 EggPrimitive::bface_flag 0

2428 8 vertices 0 102 2077 1732 1731 0 0 1728 1730 22 EggPrimitive::vertices 0

2429 4 pool 0 2 2078 1733 0 0 0 0 0 18 EggPrimitive::pool 0

2430 10 components 0 70 2080 1739 1740 0 0 0 1738 33 EggCompositePrimitive::components 0

2431 5 order 0 6 2068 1834 1830 0 0 0 0 20 EggNurbsCurve::order 0

2432 6 degree 0 2 2068 1835 0 0 0 0 0 21 EggNurbsCurve::degree 0

2433 6 closed 0 2 2038 1838 0 0 0 0 0 21 EggNurbsCurve::closed 0

2434 5 knots 0 70 2039 1839 1832 0 0 0 1836 20 EggNurbsCurve::knots 0

9
2435 16 get_object_types 0 1393 1394 26 EggGroup::get_object_types 0

2436 14 get_group_refs 0 1468 1469 24 EggGroup::get_group_refs 0

2437 12 get_textures 0 1705 1702 26 EggPrimitive::get_textures 0

2438 12 get_vertices 0 1730 1732 26 EggPrimitive::get_vertices 0

2439 14 get_components 0 1738 1739 37 EggCompositePrimitive::get_components 0

2440 9 get_knots 0 1836 1839 24 EggNurbsCurve::get_knots 0

2441 11 get_u_knots 0 1864 1874 28 EggNurbsSurface::get_u_knots 0

2442 11 get_v_knots 0 1865 1875 28 EggNurbsSurface::get_v_knots 0

2443 12 get_textures 0 1924 1925 34 EggTextureCollection::get_textures 0

