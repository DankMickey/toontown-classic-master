1478210430
3 2
14 libp3nativenet 4 5qEC 12 panda3d.core 
93
104 14 Socket_Address 0 4 197 30 Socket_Address::Socket_Address 0 2 1 2 112
/**
 * Constructor that lets us set a port value
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
136
inline Socket_Address::Socket_Address(unsigned short int port = 0);
inline Socket_Address::Socket_Address(Socket_Address const &inaddr);

105 15 ~Socket_Address 0 6 197 31 Socket_Address::~Socket_Address 0 0 28
/**
 * Normal Destructor
 */
53
virtual inline Socket_Address::~Socket_Address(void);

106 10 set_any_IP 0 4 197 26 Socket_Address::set_any_IP 0 1 3 50
/**
 * Set to any address and a specified port
 */
64
inline bool Socket_Address::set_any_IP(unsigned short int port);

107 12 set_any_IPv6 0 4 197 28 Socket_Address::set_any_IPv6 0 1 4 56
/**
 * Set to any IPv6 address and a specified port.
 */
66
inline bool Socket_Address::set_any_IPv6(unsigned short int port);

108 8 set_port 0 4 197 24 Socket_Address::set_port 0 1 5 34
/**
 * Set to a specified port
 */
62
inline bool Socket_Address::set_port(unsigned short int port);

109 13 set_broadcast 0 4 197 29 Socket_Address::set_broadcast 0 1 6 60
/**
 * Set to the broadcast address and a specified port
 */
67
inline bool Socket_Address::set_broadcast(unsigned short int port);

110 8 set_host 0 4 197 24 Socket_Address::set_host 0 3 7 8 9 387
/**
 *
 */

/**
 * This function will take a port and string-based TCP address and initialize
 * the address with this information.  Returns true on success; on failure, it
 * returns false and the address may be undefined.
 */

/**
 * Initializes the address from a string specifying both the address and port,
 * separated by a colon.  An IPv6 address must be enclosed in brackets.
 */
225
bool Socket_Address::set_host(std::string const &hostname, unsigned short int port);
bool Socket_Address::set_host(std::string const &hostname);
inline bool Socket_Address::set_host(uint32_t ip4addr, unsigned short int port);

111 5 clear 0 4 197 21 Socket_Address::clear 0 1 10 60
/**
 * Set the internal values to a suitable known value
 */
40
inline void Socket_Address::clear(void);

112 10 get_family 0 4 197 26 Socket_Address::get_family 0 1 11 97
/**
 * Returns AF_INET if this is an IPv4 address, or AF_INET6 if this is an IPv6
 * address.
 */
58
inline sa_family_t Socket_Address::get_family(void) const;

113 8 get_port 0 4 197 24 Socket_Address::get_port 0 1 12 45
/**
 * Get the port portion as an integer
 */
63
inline unsigned short int Socket_Address::get_port(void) const;

114 6 get_ip 0 4 197 22 Socket_Address::get_ip 0 1 13 64
/**
 * Return the IP address portion in dot notation string.
 */
47
std::string Socket_Address::get_ip(void) const;

115 11 get_ip_port 0 4 197 27 Socket_Address::get_ip_port 0 1 14 133
/**
 * Return the ip address/port in dot notation string.  If this is an IPv6
 * address, it will be enclosed in square brackets.
 */
52
std::string Socket_Address::get_ip_port(void) const;

116 15 GetIPAddressRaw 0 4 197 31 Socket_Address::GetIPAddressRaw 0 1 15 130
/**
 * Returns a raw 32-bit unsigned integer representing the IPv4 address.
 * @deprecated  Does not work with IPv6 addresses.
 */
62
unsigned long int Socket_Address::GetIPAddressRaw(void) const;

117 11 operator == 0 4 197 27 Socket_Address::operator == 0 1 16 0
72
inline bool Socket_Address::operator ==(Socket_Address const &in) const;

118 11 operator != 0 4 197 27 Socket_Address::operator != 0 1 17 0
72
inline bool Socket_Address::operator !=(Socket_Address const &in) const;

119 10 operator < 0 4 197 26 Socket_Address::operator < 0 1 18 0
71
inline bool Socket_Address::operator <(Socket_Address const &in) const;

120 6 is_any 0 4 197 22 Socket_Address::is_any 0 1 19 39
/**
 * True if the address is zero.
 */
47
inline bool Socket_Address::is_any(void) const;

121 14 is_mcast_range 0 4 197 30 Socket_Address::is_mcast_range 0 1 20 57
/**
 * True if the address is in the multicast range.
 */
55
inline bool Socket_Address::is_mcast_range(void) const;

122 9 Socket_IP 0 4 198 20 Socket_IP::Socket_IP 0 3 21 22 23 79
/**
 * Def Constructor
 */

/**
 * Assigns an existing socket to this class
 */
132
inline Socket_IP::Socket_IP(void);
inline Socket_IP::Socket_IP(SOCKET in);
inline Socket_IP::Socket_IP(Socket_IP const &) = default;

123 5 Close 0 4 198 16 Socket_IP::Close 0 1 24 53
/**
 * Closes a socket if it is open (allocated).
 */
35
inline void Socket_IP::Close(void);

124 12 GetLastError 0 4 198 23 Socket_IP::GetLastError 0 1 25 57
/**
 * Gets the last errcode from a socket operation.
 */
48
static inline int Socket_IP::GetLastError(void);

125 14 SetNonBlocking 0 4 198 25 Socket_IP::SetNonBlocking 0 1 26 67
/**
 * this function will throw a socket into non-blocking mode
 */
43
inline int Socket_IP::SetNonBlocking(void);

126 11 SetBlocking 0 4 198 22 Socket_IP::SetBlocking 0 1 27 102
/**
 * Set the socket to block on subsequent calls to socket functions that
 * address this socket
 */
40
inline int Socket_IP::SetBlocking(void);

127 15 SetReuseAddress 0 4 198 26 Socket_IP::SetReuseAddress 0 1 28 57
/**
 * Informs a socket to reuse IP address as needed
 */
57
inline bool Socket_IP::SetReuseAddress(bool flag = true);

128 9 SetV6Only 0 4 198 20 Socket_IP::SetV6Only 0 1 29 103
/**
 * Sets a flag indicating whether this IPv6 socket should operate in
 * dual-stack mode or not.
 */
44
inline bool Socket_IP::SetV6Only(bool flag);

129 6 Active 0 4 198 17 Socket_IP::Active 0 1 30 48
/**
 * Ask if the socket is open (allocated)
 */
36
inline bool Socket_IP::Active(void);

130 17 SetRecvBufferSize 0 4 198 28 Socket_IP::SetRecvBufferSize 0 1 31 63
/**
 * Ok it sets the recv buffer size for both tcp and UDP
 */
50
inline int Socket_IP::SetRecvBufferSize(int size);

131 9 SetSocket 0 4 198 20 Socket_IP::SetSocket 0 1 32 51
/**
 * Assigns an existing socket to this class
 */
45
inline void Socket_IP::SetSocket(SOCKET ins);

132 9 GetSocket 0 4 198 20 Socket_IP::GetSocket 0 2 33 34 82
/**
 * Gets the base socket type
 */

/**
 * Get The RAW file id of the socket
 */
89
inline SOCKET Socket_IP::GetSocket(void);
inline SOCKET Socket_IP::GetSocket(void) const;

133 11 GetPeerName 0 4 198 22 Socket_IP::GetPeerName 0 1 35 43
/**
 * Wrapper on berkly getpeername...
 */
57
inline Socket_Address Socket_IP::GetPeerName(void) const;

134 17 InitNetworkDriver 0 4 198 28 Socket_IP::InitNetworkDriver 0 1 36 0
53
static inline int Socket_IP::InitNetworkDriver(void);

135 14 get_class_type 0 4 198 25 Socket_IP::get_class_type 0 1 37 0
50
static TypeHandle Socket_IP::get_class_type(void);

136 10 Socket_TCP 0 4 200 22 Socket_TCP::Socket_TCP 0 3 38 39 40 10
/**
 *
 */
137
inline Socket_TCP::Socket_TCP(SOCKET );
inline Socket_TCP::Socket_TCP(void);
inline Socket_TCP::Socket_TCP(Socket_TCP const &) = default;

137 10 SetNoDelay 0 4 200 22 Socket_TCP::SetNoDelay 0 1 41 73
/**
 * Disable Nagle algorithm.  Don't delay send to coalesce packets
 */
52
inline int Socket_TCP::SetNoDelay(bool flag = true);

138 9 SetLinger 0 4 200 21 Socket_TCP::SetLinger 0 1 42 66
/**
 * will control the behavior of SO_LINGER for a TCP socket
 */
59
inline int Socket_TCP::SetLinger(int interval_seconds = 0);

139 10 DontLinger 0 4 200 22 Socket_TCP::DontLinger 0 1 43 217
/**
 * Turn off the linger flag.  The socket will quickly release buffered items
 * and free up OS resources.  You may lose a stream if you use this flag and
 * do not negotiate the close at the application layer.
 */
40
inline int Socket_TCP::DontLinger(void);

140 17 SetSendBufferSize 0 4 200 29 Socket_TCP::SetSendBufferSize 0 1 44 143
/**
 * Just like it sounds.  Sets a buffered socket recv buffer size.  This
 * function does not refuse ranges outside hard-coded OS limits
 */
53
inline int Socket_TCP::SetSendBufferSize(int insize);

141 10 ActiveOpen 0 4 200 22 Socket_TCP::ActiveOpen 0 1 45 200
// inline bool ActiveOpen(const Socket_Address &theaddress);

/**
 * This function will try and set the socket up for active open to a specified
 * address and port provided by the input parameter
 */
84
inline bool Socket_TCP::ActiveOpen(Socket_Address const &theaddress, bool setdelay);

142 21 ActiveOpenNonBlocking 0 4 200 33 Socket_TCP::ActiveOpenNonBlocking 0 1 46 161
/**
 * This function will try and set the socket up for active open to a specified
 * address and port provided by the input parameter (non-blocking version)
 */
80
inline bool Socket_TCP::ActiveOpenNonBlocking(Socket_Address const &theaddress);

143 21 ErrorIs_WouldBlocking 0 4 200 33 Socket_TCP::ErrorIs_WouldBlocking 0 1 47 0
55
inline bool Socket_TCP::ErrorIs_WouldBlocking(int err);

144 12 ShutdownSend 0 4 200 24 Socket_TCP::ShutdownSend 0 1 48 0
43
inline bool Socket_TCP::ShutdownSend(void);

145 8 SendData 0 4 200 20 Socket_TCP::SendData 0 1 49 137
/**
 * Ok Lets Send the Data - if error 0 if socket closed for write or lengh is 0
 * + bytes writen ( May be smaller than requested)
 */
56
inline int Socket_TCP::SendData(std::string const &str);

146 8 RecvData 0 4 200 20 Socket_TCP::RecvData 0 1 50 295
/**
 * Read the data from the connection - if error 0 if socket closed for read or
 * length is 0 + bytes read ( May be smaller than requested)
 */

/**
 * Read the data from the connection - if error 0 if socket closed for read or
 * length is 0 + bytes read (May be smaller than requested)
 */
46
std::string Socket_TCP::RecvData(int max_len);

147 14 get_class_type 0 4 200 26 Socket_TCP::get_class_type 0 1 51 0
51
static TypeHandle Socket_TCP::get_class_type(void);

148 11 ~Socket_TCP 0 4 200 23 Socket_TCP::~Socket_TCP 0 0 0
30
Socket_TCP::~Socket_TCP(void);

149 17 Socket_TCP_Listen 0 4 201 36 Socket_TCP_Listen::Socket_TCP_Listen 0 2 52 53 0
125
Socket_TCP_Listen::Socket_TCP_Listen(void);
inline Socket_TCP_Listen::Socket_TCP_Listen(Socket_TCP_Listen const &) = default;

150 13 OpenForListen 0 4 201 32 Socket_TCP_Listen::OpenForListen 0 2 54 55 120
/**
 * This function will initialize a listening Socket
 */

/**
 * This function will initialize a listening Socket
 */
197
inline bool Socket_TCP_Listen::OpenForListen(unsigned short int port, int backlog_size = 1024);
inline bool Socket_TCP_Listen::OpenForListen(Socket_Address const &address, int backlog_size = 1024);

151 21 GetIncomingConnection 0 4 201 40 Socket_TCP_Listen::GetIncomingConnection 0 1 56 58
/**
 * This function is used to accept new connections
 */
102
inline bool Socket_TCP_Listen::GetIncomingConnection(Socket_TCP &newsession, Socket_Address &address);

152 14 get_class_type 0 4 201 33 Socket_TCP_Listen::get_class_type 0 1 57 0
58
static TypeHandle Socket_TCP_Listen::get_class_type(void);

153 19 Socket_UDP_Incoming 0 4 202 40 Socket_UDP_Incoming::Socket_UDP_Incoming 0 2 58 59 0
142
inline Socket_UDP_Incoming::Socket_UDP_Incoming(void);
inline Socket_UDP_Incoming::Socket_UDP_Incoming(Socket_UDP_Incoming const &) = default;

154 12 OpenForInput 0 4 202 33 Socket_UDP_Incoming::OpenForInput 0 2 60 61 102
/**
 * Starts a UDP socket listening on a port
 */

/**
 * Starts a UDP socket listening on a port
 */
149
inline bool Socket_UDP_Incoming::OpenForInput(unsigned short int port);
inline bool Socket_UDP_Incoming::OpenForInput(Socket_Address const &address);

155 17 OpenForInputMCast 0 4 202 38 Socket_UDP_Incoming::OpenForInputMCast 0 1 62 50
/**
 * Starts a UDP socket listening on a port
 */
82
inline bool Socket_UDP_Incoming::OpenForInputMCast(Socket_Address const &address);

156 9 GetPacket 0 4 202 30 Socket_UDP_Incoming::GetPacket 0 0 105
/**
 * Grabs a dataset off the listening UDP socket and fills in the source
 * address information
 *
 */
94
inline bool Socket_UDP_Incoming::GetPacket(char *data, int *max_len, Socket_Address &address);

157 6 SendTo 0 4 202 27 Socket_UDP_Incoming::SendTo 0 1 63 41
/**
 * Send data to specified address
 */
98
inline bool Socket_UDP_Incoming::SendTo(char const *data, int len, Socket_Address const &address);

158 13 InitNoAddress 0 4 202 34 Socket_UDP_Incoming::InitNoAddress 0 1 64 68
/**
 * Set this socket to work without a bound external address.
 */
53
inline bool Socket_UDP_Incoming::InitNoAddress(void);

159 14 SetToBroadCast 0 4 202 35 Socket_UDP_Incoming::SetToBroadCast 0 1 65 85
/**
 * Flips the OS bits that allow for brodcast packets to come in on this port.
 */
54
inline bool Socket_UDP_Incoming::SetToBroadCast(void);

160 14 get_class_type 0 4 202 35 Socket_UDP_Incoming::get_class_type 0 1 66 0
60
static TypeHandle Socket_UDP_Incoming::get_class_type(void);

161 20 ~Socket_UDP_Incoming 0 4 202 41 Socket_UDP_Incoming::~Socket_UDP_Incoming 0 0 0
48
Socket_UDP_Incoming::~Socket_UDP_Incoming(void);

162 19 Socket_UDP_Outgoing 0 4 203 40 Socket_UDP_Outgoing::Socket_UDP_Outgoing 0 2 67 68 0
142
inline Socket_UDP_Outgoing::Socket_UDP_Outgoing(void);
inline Socket_UDP_Outgoing::Socket_UDP_Outgoing(Socket_UDP_Outgoing const &) = default;

163 13 InitToAddress 0 4 203 34 Socket_UDP_Outgoing::InitToAddress 0 1 69 106
// use this interface for a tagreted UDP connection

/**
 * Connects the Socket to a specified address
 */
78
inline bool Socket_UDP_Outgoing::InitToAddress(Socket_Address const &address);

164 4 Send 0 4 203 25 Socket_UDP_Outgoing::Send 0 1 70 84
/**
 * Send data to connected address
 */

/**
 * Send data to connected address
 */
63
inline bool Socket_UDP_Outgoing::Send(std::string const &data);

165 13 InitNoAddress 0 4 203 34 Socket_UDP_Outgoing::InitNoAddress 0 1 71 111
// use this interface for a none tagreted UDP connection

/**
 * This will set a udp up for targeted sends.
 */
53
inline bool Socket_UDP_Outgoing::InitNoAddress(void);

166 6 SendTo 0 4 203 27 Socket_UDP_Outgoing::SendTo 0 1 72 84
/**
 * Send data to specified address
 */

/**
 * Send data to specified address
 */
96
inline bool Socket_UDP_Outgoing::SendTo(std::string const &data, Socket_Address const &address);

167 14 SetToBroadCast 0 4 203 35 Socket_UDP_Outgoing::SetToBroadCast 0 1 73 71
/**
 * Ask the OS to let us receive broadcast packets on this port.
 */
54
inline bool Socket_UDP_Outgoing::SetToBroadCast(void);

168 14 get_class_type 0 4 203 35 Socket_UDP_Outgoing::get_class_type 0 1 74 0
60
static TypeHandle Socket_UDP_Outgoing::get_class_type(void);

169 20 ~Socket_UDP_Outgoing 0 4 203 41 Socket_UDP_Outgoing::~Socket_UDP_Outgoing 0 0 0
48
Socket_UDP_Outgoing::~Socket_UDP_Outgoing(void);

170 12 Socket_fdset 0 4 204 26 Socket_fdset::Socket_fdset 0 2 75 76 26
/**
 * The constructor
 */
107
inline Socket_fdset::Socket_fdset(void);
inline Socket_fdset::Socket_fdset(Socket_fdset const &) = default;

171 12 setForSocket 0 4 204 26 Socket_fdset::setForSocket 0 1 77 10
/**
 *
 */
63
inline void Socket_fdset::setForSocket(Socket_IP const &incon);

172 8 IsSetFor 0 4 204 22 Socket_fdset::IsSetFor 0 1 78 70
/**
 * check to see if a socket object has been marked for reading
 */
65
inline bool Socket_fdset::IsSetFor(Socket_IP const &incon) const;

173 11 WaitForRead 0 4 204 25 Socket_fdset::WaitForRead 0 2 79 80 22
/**
 *
 */

/**
 *
 */
163
inline int Socket_fdset::WaitForRead(bool zeroFds, uint32_t sleep_time = 2147483647);
inline int Socket_fdset::WaitForRead(bool zeroFds, Time_Span const &timeout);

174 12 WaitForWrite 0 4 204 26 Socket_fdset::WaitForWrite 0 1 81 94
/**
 * This is the function that will wait till one of the sockets is ready for
 * writing
 */
86
inline int Socket_fdset::WaitForWrite(bool zeroFds, uint32_t sleep_time = 2147483647);

175 12 WaitForError 0 4 204 26 Socket_fdset::WaitForError 0 1 82 91
/**
 * This is the function that will wait till one of the sockets is in error
 * state
 */
86
inline int Socket_fdset::WaitForError(bool zeroFds, uint32_t sleep_time = 2147483647);

176 5 clear 0 4 204 19 Socket_fdset::clear 0 1 83 37
/**
 * Marks the content as empty
 */
38
inline void Socket_fdset::clear(void);

177 13 ~Socket_fdset 0 4 204 27 Socket_fdset::~Socket_fdset 0 0 0
34
Socket_fdset::~Socket_fdset(void);

178 10 GetMessage 0 4 205 39 Buffered_DatagramConnection::GetMessage 0 1 86 54
/**
 * Reads a message.  Returns false on failure.
 */
67
inline bool Buffered_DatagramConnection::GetMessage(Datagram &val);

179 9 DoConnect 0 4 205 38 Buffered_DatagramConnection::DoConnect 0 1 87 38
// all the real state magic is in here
57
inline bool Buffered_DatagramConnection::DoConnect(void);

180 11 IsConnected 0 4 205 40 Buffered_DatagramConnection::IsConnected 0 1 88 38
// all the real state magic is in here
59
inline bool Buffered_DatagramConnection::IsConnected(void);

181 27 Buffered_DatagramConnection 0 4 205 56 Buffered_DatagramConnection::Buffered_DatagramConnection 0 2 84 85 10
/**
 *
 */
227
inline Buffered_DatagramConnection::Buffered_DatagramConnection(int rbufsize, int wbufsize, int write_flush_point);
inline Buffered_DatagramConnection::Buffered_DatagramConnection(Buffered_DatagramConnection const &) = default;

182 11 SendMessage 0 4 205 40 Buffered_DatagramConnection::SendMessage 0 1 89 58
// the reason thsi all exists

/**
 * send the message
 */
67
bool Buffered_DatagramConnection::SendMessage(Datagram const &msg);

183 5 Flush 0 4 205 34 Buffered_DatagramConnection::Flush 0 1 90 28
/**
 * Flush all writes.
 */
53
inline bool Buffered_DatagramConnection::Flush(void);

184 5 Reset 0 4 205 34 Buffered_DatagramConnection::Reset 0 1 91 16
/**
 * Reset
 */
53
inline void Buffered_DatagramConnection::Reset(void);

185 23 WaitForNetworkReadEvent 0 4 205 52 Buffered_DatagramConnection::WaitForNetworkReadEvent 0 1 92 0
86
inline void Buffered_DatagramConnection::WaitForNetworkReadEvent(PN_stdfloat MaxTime);

186 16 AddressQueueSize 0 4 205 45 Buffered_DatagramConnection::AddressQueueSize 0 1 93 22
// address queue stuff
71
inline std::size_t Buffered_DatagramConnection::AddressQueueSize(void);

187 10 AddAddress 0 4 205 39 Buffered_DatagramConnection::AddAddress 0 1 94 52
/**
 * must be called to set value to the server
 */
75
inline void Buffered_DatagramConnection::AddAddress(Socket_Address &inadr);

188 14 ClearAddresses 0 4 205 43 Buffered_DatagramConnection::ClearAddresses 0 1 95 0
62
inline void Buffered_DatagramConnection::ClearAddresses(void);

189 14 get_class_type 0 4 205 43 Buffered_DatagramConnection::get_class_type 0 1 96 0
68
static TypeHandle Buffered_DatagramConnection::get_class_type(void);

190 10 Socket_UDP 0 4 206 22 Socket_UDP::Socket_UDP 0 2 97 98 0
97
inline Socket_UDP::Socket_UDP(void);
inline Socket_UDP::Socket_UDP(Socket_UDP const &) = default;

191 13 InitToAddress 0 4 206 25 Socket_UDP::InitToAddress 0 1 99 106
// use this interface for a tagreted UDP connection

/**
 * Connects the socket to a Specified address
 */
69
inline bool Socket_UDP::InitToAddress(Socket_Address const &address);

192 4 Send 0 4 206 16 Socket_UDP::Send 0 1 100 84
/**
 * Send data to connected address
 */

/**
 * Send data to connected address
 */
54
inline bool Socket_UDP::Send(std::string const &data);

193 6 SendTo 0 4 206 18 Socket_UDP::SendTo 0 1 101 84
/**
 * Send data to specified address
 */

/**
 * Send data to specified address
 */
87
inline bool Socket_UDP::SendTo(std::string const &data, Socket_Address const &address);

194 14 SetToBroadCast 0 4 206 26 Socket_UDP::SetToBroadCast 0 1 102 71
/**
 * Ask the OS to let us receive broadcast packets on this port.
 */
45
inline bool Socket_UDP::SetToBroadCast(void);

195 14 get_class_type 0 4 206 26 Socket_UDP::get_class_type 0 1 103 0
51
static TypeHandle Socket_UDP::get_class_type(void);

196 11 ~Socket_UDP 0 4 206 23 Socket_UDP::~Socket_UDP 0 0 0
30
Socket_UDP::~Socket_UDP(void);

103
1 0 0 7 2 209 105 0 10 /**
 *
 */ 1 6 inaddr 1 207  
2 0 0 7 2 209 105 0 52 /**
 * Constructor that lets us set a port value
 */ 1 4 port 1 210  
3 0 0 6 4 211 0 0 50 /**
 * Set to any address and a specified port
 */ 2 4 this 3 209  4 port 1 210  
4 0 0 6 5 211 0 0 56 /**
 * Set to any IPv6 address and a specified port.
 */ 2 4 this 3 209  4 port 1 210  
5 0 0 6 6 211 0 0 34 /**
 * Set to a specified port
 */ 2 4 this 3 209  4 port 1 210  
6 0 0 6 7 211 0 0 60 /**
 * Set to the broadcast address and a specified port
 */ 2 4 this 3 209  4 port 1 210  
7 0 0 6 8 211 0 0 158 /**
 * Initializes the address from a string specifying both the address and port,
 * separated by a colon.  An IPv6 address must be enclosed in brackets.
 */ 2 4 this 3 209  8 hostname 1 212  
8 0 0 6 8 211 0 0 215 /**
 * This function will take a port and string-based TCP address and initialize
 * the address with this information.  Returns true on success; on failure, it
 * returns false and the address may be undefined.
 */ 3 4 this 3 209  8 hostname 1 212  4 port 1 210  
9 0 0 6 8 211 0 0 10 /**
 *
 */ 3 4 this 3 209  7 ip4addr 1 213  4 port 1 210  
10 0 0 4 9 215 0 0 60 /**
 * Set the internal values to a suitable known value
 */ 1 4 this 3 209  
11 0 0 6 10 216 0 0 97 /**
 * Returns AF_INET if this is an IPv4 address, or AF_INET6 if this is an IPv6
 * address.
 */ 1 4 this 3 207  
12 0 0 6 11 210 0 0 45 /**
 * Get the port portion as an integer
 */ 1 4 this 3 207  
13 0 0 6 12 212 0 0 64 /**
 * Return the IP address portion in dot notation string.
 */ 1 4 this 3 207  
14 0 0 6 13 212 0 0 133 /**
 * Return the ip address/port in dot notation string.  If this is an IPv6
 * address, it will be enclosed in square brackets.
 */ 1 4 this 3 207  
15 0 0 6 14 217 0 0 130 /**
 * Returns a raw 32-bit unsigned integer representing the IPv4 address.
 * @deprecated  Does not work with IPv6 addresses.
 */ 1 4 this 3 207  
16 0 0 6 15 211 0 0 0 2 4 this 3 207  2 in 1 207  
17 0 0 6 16 211 0 0 0 2 4 this 3 207  2 in 1 207  
18 0 0 6 17 211 0 0 0 2 4 this 3 207  2 in 1 207  
19 0 0 6 18 211 0 0 39 /**
 * True if the address is zero.
 */ 1 4 this 3 207  
20 0 0 6 19 211 0 0 57 /**
 * True if the address is in the multicast range.
 */ 1 4 this 3 207  
21 0 0 7 22 218 0 0 26 /**
 * Def Constructor
 */ 0 
22 0 0 7 22 218 0 0 51 /**
 * Assigns an existing socket to this class
 */ 1 2 in 1 219  
23 0 0 7 22 218 0 0 0 1 6 param0 0 220  
24 0 0 4 23 215 0 0 53 /**
 * Closes a socket if it is open (allocated).
 */ 1 4 this 3 218  
25 0 0 6 24 222 0 0 57 /**
 * Gets the last errcode from a socket operation.
 */ 0 
26 0 0 6 25 222 0 0 67 /**
 * this function will throw a socket into non-blocking mode
 */ 1 4 this 3 218  
27 0 0 6 26 222 0 0 102 /**
 * Set the socket to block on subsequent calls to socket functions that
 * address this socket
 */ 1 4 this 3 218  
28 0 0 6 27 211 0 0 57 /**
 * Informs a socket to reuse IP address as needed
 */ 2 4 this 3 218  4 flag 1 211  
29 0 0 6 28 211 0 0 103 /**
 * Sets a flag indicating whether this IPv6 socket should operate in
 * dual-stack mode or not.
 */ 2 4 this 3 218  4 flag 1 211  
30 0 0 6 29 211 0 0 48 /**
 * Ask if the socket is open (allocated)
 */ 1 4 this 3 218  
31 0 0 6 30 222 0 0 63 /**
 * Ok it sets the recv buffer size for both tcp and UDP
 */ 2 4 this 3 218  4 size 1 222  
32 0 0 4 31 215 0 0 51 /**
 * Assigns an existing socket to this class
 */ 2 4 this 3 218  3 ins 1 219  
33 0 0 6 32 219 0 0 36 /**
 * Gets the base socket type
 */ 1 4 this 3 218  
34 0 0 6 32 219 0 0 44 /**
 * Get The RAW file id of the socket
 */ 1 4 this 3 220  
35 0 0 7 33 209 105 0 43 /**
 * Wrapper on berkly getpeername...
 */ 1 4 this 3 220  
36 0 0 6 34 222 0 0 0 0 
37 0 0 7 35 224 0 0 0 0 
38 0 0 7 37 225 148 0 0 0 
39 0 0 7 37 225 148 0 10 /**
 *
 */ 1 6 param0 0 219  
40 0 0 7 37 225 148 0 0 1 6 param0 0 226  
41 0 0 6 38 222 0 0 73 /**
 * Disable Nagle algorithm.  Don't delay send to coalesce packets
 */ 2 4 this 3 225  4 flag 1 211  
42 0 0 6 39 222 0 0 66 /**
 * will control the behavior of SO_LINGER for a TCP socket
 */ 2 4 this 3 225  16 interval_seconds 1 222  
43 0 0 6 40 222 0 0 217 /**
 * Turn off the linger flag.  The socket will quickly release buffered items
 * and free up OS resources.  You may lose a stream if you use this flag and
 * do not negotiate the close at the application layer.
 */ 1 4 this 3 225  
44 0 0 6 41 222 0 0 143 /**
 * Just like it sounds.  Sets a buffered socket recv buffer size.  This
 * function does not refuse ranges outside hard-coded OS limits
 */ 2 4 this 3 225  6 insize 1 222  
45 0 0 6 42 211 0 0 138 /**
 * This function will try and set the socket up for active open to a specified
 * address and port provided by the input parameter
 */ 3 4 this 3 225  10 theaddress 1 207  8 setdelay 1 211  
46 0 0 6 43 211 0 0 161 /**
 * This function will try and set the socket up for active open to a specified
 * address and port provided by the input parameter (non-blocking version)
 */ 2 4 this 3 225  10 theaddress 1 207  
47 0 0 6 44 211 0 0 0 2 4 this 3 225  3 err 1 222  
48 0 0 6 45 211 0 0 0 1 4 this 3 225  
49 0 0 6 46 222 0 0 0 2 4 this 3 225  3 str 1 212  
50 0 0 6 47 212 0 0 146 /**
 * Read the data from the connection - if error 0 if socket closed for read or
 * length is 0 + bytes read (May be smaller than requested)
 */ 2 4 this 3 225  7 max_len 1 222  
51 0 0 7 48 224 0 0 0 0 
52 0 0 7 51 228 0 0 0 0 
53 0 0 7 51 228 0 0 0 1 6 param0 0 229  
54 0 0 6 52 211 0 0 59 /**
 * This function will initialize a listening Socket
 */ 3 4 this 3 228  7 address 1 207  12 backlog_size 1 222  
55 0 0 6 52 211 0 0 59 /**
 * This function will initialize a listening Socket
 */ 3 4 this 3 228  4 port 1 210  12 backlog_size 1 222  
56 0 0 6 53 211 0 0 0 3 4 this 3 228  10 newsession 1 225  7 address 1 209  
57 0 0 7 54 224 0 0 0 0 
58 0 0 7 56 231 161 0 0 0 
59 0 0 7 56 231 161 0 0 1 6 param0 0 232  
60 0 0 6 57 211 0 0 50 /**
 * Starts a UDP socket listening on a port
 */ 2 4 this 3 231  7 address 1 207  
61 0 0 6 57 211 0 0 50 /**
 * Starts a UDP socket listening on a port
 */ 2 4 this 3 231  4 port 1 210  
62 0 0 6 58 211 0 0 50 /**
 * Starts a UDP socket listening on a port
 */ 2 4 this 3 231  7 address 1 207  
63 0 0 6 60 211 0 0 41 /**
 * Send data to specified address
 */ 4 4 this 3 231  4 data 1 212  3 len 1 222  7 address 1 207  
64 0 0 6 61 211 0 0 68 /**
 * Set this socket to work without a bound external address.
 */ 1 4 this 3 231  
65 0 0 6 62 211 0 0 85 /**
 * Flips the OS bits that allow for brodcast packets to come in on this port.
 */ 1 4 this 3 231  
66 0 0 7 63 224 0 0 0 0 
67 0 0 7 66 234 169 0 0 0 
68 0 0 7 66 234 169 0 0 1 6 param0 0 235  
69 0 0 6 67 211 0 0 53 /**
 * Connects the Socket to a specified address
 */ 2 4 this 3 234  7 address 1 207  
70 0 0 6 68 211 0 0 41 /**
 * Send data to connected address
 */ 2 4 this 3 234  4 data 1 212  
71 0 0 6 69 211 0 0 56 // use this interface for a none tagreted UDP connection 1 4 this 3 234  
72 0 0 6 70 211 0 0 41 /**
 * Send data to specified address
 */ 3 4 this 3 234  4 data 1 212  7 address 1 207  
73 0 0 6 71 211 0 0 71 /**
 * Ask the OS to let us receive broadcast packets on this port.
 */ 1 4 this 3 234  
74 0 0 7 72 224 0 0 0 0 
75 0 0 7 75 237 177 0 26 /**
 * The constructor
 */ 0 
76 0 0 7 75 237 177 0 0 1 6 param0 0 238  
77 0 0 4 76 215 0 0 10 /**
 *
 */ 2 4 this 3 237  5 incon 1 220  
78 0 0 6 77 211 0 0 70 /**
 * check to see if a socket object has been marked for reading
 */ 2 4 this 3 238  5 incon 1 220  
79 0 0 6 78 222 0 0 10 /**
 *
 */ 3 4 this 3 237  7 zeroFds 1 211  7 timeout 1 240  
80 0 0 6 78 222 0 0 10 /**
 *
 */ 3 4 this 3 237  7 zeroFds 1 211  10 sleep_time 1 213  
81 0 0 6 79 222 0 0 94 /**
 * This is the function that will wait till one of the sockets is ready for
 * writing
 */ 3 4 this 3 237  7 zeroFds 1 211  10 sleep_time 1 213  
82 0 0 6 80 222 0 0 91 /**
 * This is the function that will wait till one of the sockets is in error
 * state
 */ 3 4 this 3 237  7 zeroFds 1 211  10 sleep_time 1 213  
83 0 0 4 81 215 0 0 37 /**
 * Marks the content as empty
 */ 1 4 this 3 237  
84 0 0 7 87 245 148 0 0 1 6 param0 0 243  
85 0 0 7 87 245 148 0 10 /**
 *
 */ 3 8 rbufsize 1 222  8 wbufsize 1 222  17 write_flush_point 1 222  
86 0 0 6 84 211 0 0 54 /**
 * Reads a message.  Returns false on failure.
 */ 2 4 this 3 245  3 val 1 246  
87 0 0 6 85 211 0 0 38 // all the real state magic is in here 1 4 this 3 245  
88 0 0 6 86 211 0 0 38 // all the real state magic is in here 1 4 this 3 245  
89 0 0 6 88 211 0 0 29 // the reason thsi all exists 2 4 this 3 245  3 msg 1 248  
90 0 0 6 89 211 0 0 28 /**
 * Flush all writes.
 */ 1 4 this 3 245  
91 0 0 4 90 215 0 0 16 /**
 * Reset
 */ 1 4 this 3 245  
92 0 0 4 91 215 0 0 0 2 4 this 3 245  7 MaxTime 1 250  
93 0 0 6 92 252 0 0 22 // address queue stuff 1 4 this 3 245  
94 0 0 4 93 215 0 0 52 /**
 * must be called to set value to the server
 */ 2 4 this 3 245  5 inadr 1 209  
95 0 0 4 94 215 0 0 0 1 4 this 3 245  
96 0 0 7 95 224 0 0 0 0 
97 0 0 7 97 253 196 0 0 0 
98 0 0 7 97 253 196 0 0 1 6 param0 0 254  
99 0 0 6 98 211 0 0 53 /**
 * Connects the socket to a Specified address
 */ 2 4 this 3 253  7 address 1 207  
100 0 0 6 99 211 0 0 41 /**
 * Send data to connected address
 */ 2 4 this 3 253  4 data 1 212  
101 0 0 6 100 211 0 0 41 /**
 * Send data to specified address
 */ 3 4 this 3 253  4 data 1 212  7 address 1 207  
102 0 0 6 101 211 0 0 71 /**
 * Ask the OS to let us receive broadcast packets on this port.
 */ 1 4 this 3 253  
103 0 0 7 102 224 0 0 0 0 
59
197 14 Socket_Address 0 26625 14 Socket_Address 14 Socket_Address 0 0 0 1 104 105 0 16 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 0 0 0 0 0 97
/**
 * A simple place to store and manipulate tcp and port address for
 * communication layer
 */

198 9 Socket_IP 0 75777 9 Socket_IP 9 Socket_IP 0 0 0 1 122 0 0 13 123 124 125 126 127 128 129 130 131 132 133 134 135 0 0 1 0 199 0 0 0 0 354
/**
 * Base functionality for a INET domain Socket This call should be the
 * starting point for all other unix domain sockets.
 *
 * SocketIP |
 * ------------------------------------------------------------------- |
 * |                       |                           | SocketTCP
 * SocketTCP_Listen    SocketUDP_Incoming   SocketUDP_OutBound
 *
 */

199 11 TypedObject 0 2049 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 2348
/**
 * This is an abstract class that all classes which use TypeHandle, and also
 * provide virtual functions to support polymorphism, should inherit from.
 * Each derived class should define get_type(), which should return the
 * specific type of the derived class.  Inheriting from this automatically
 * provides support for is_of_type() and is_exact_type().
 *
 * All classes that inherit directly or indirectly from TypedObject should
 * redefine get_type() and force_init_type(), as shown below.  Some classes
 * that do not inherit from TypedObject may still declare TypeHandles for
 * themselves by defining methods called get_class_type() and init_type().
 * Classes such as these may serve as base classes, but the dynamic type
 * identification system will be limited.  Classes that do not inherit from
 * TypedObject need not define the virtual functions get_type() and
 * force_init_type() (or any other virtual functions).
 *
 * There is a specific layout for defining the overrides from this class.
 * Keeping the definitions formatted just like these examples will allow
 * someone in the future to use a sed (or similar) script to make global
 * changes, if necessary.  Avoid rearranging the braces or the order of the
 * functions unless you're ready to change them in every file all at once.
 *
 * What follows are some examples that can be used in new classes that you
 * create.
 *
 * @par In the class definition (.h file): @code public: static TypeHandle
 * get_class_type() { return _type_handle; } static void init_type() {
 * <<<BaseClassOne>>>::init_type(); <<<BaseClassTwo>>>::init_type();
 * <<<BaseClassN>>>::init_type(); register_type(_type_handle,
 * "<<<ThisClassStringName>>>", <<<BaseClassOne>>>::get_class_type(),
 * <<<BaseClassTwo>>>::get_class_type(), <<<BaseClassN>>>::get_class_type());
 * } virtual TypeHandle get_type() const { return get_class_type(); } virtual
 * TypeHandle force_init_type() {init_type(); return get_class_type();}
 *
 * private: static TypeHandle _type_handle; @endcode
 *
 * @par In the class .cxx file: @code TypeHandle
 * <<<ThisClassStringName>>>::_type_handle; @endcode
 *
 * @par In the class config_<<<PackageName>>>.cxx file: @code
 * ConfigureFn(config_<<<PackageName>>>) { <<<ClassOne>>>::init_type();
 * <<<ClassTwo>>>::init_type(); <<<ClassN>>>::init_type(); } @endcode
 */

200 10 Socket_TCP 0 141313 10 Socket_TCP 10 Socket_TCP 0 0 0 1 136 148 0 11 137 138 139 140 141 142 143 144 145 146 147 0 0 1 0 198 0 0 0 0 175
/**
 * Base functionality for a TCP connected socket This class is pretty useless
 * by itself but it does hide some of the platform differences from machine to
 * machine
 */

201 17 Socket_TCP_Listen 0 75777 17 Socket_TCP_Listen 17 Socket_TCP_Listen 0 0 0 1 149 0 0 3 150 151 152 0 0 1 0 198 0 0 0 0 57
/**
 * Base functionality for a TCP rendezvous socket
 */

202 19 Socket_UDP_Incoming 0 141313 19 Socket_UDP_Incoming 19 Socket_UDP_Incoming 0 0 0 1 153 161 0 7 154 155 156 157 158 159 160 0 0 1 0 198 0 0 0 0 46
/**
 * Base functionality for a UDP Reader
 */

203 19 Socket_UDP_Outgoing 0 141313 19 Socket_UDP_Outgoing 19 Socket_UDP_Outgoing 0 0 0 1 162 169 0 6 163 164 165 166 167 168 0 0 1 0 198 0 0 0 0 54
/**
 * Base functionality for a UDP sending socket
 */

204 12 Socket_fdset 0 141313 12 Socket_fdset 12 Socket_fdset 0 0 0 1 170 177 0 6 171 172 173 174 175 176 0 0 0 0 0 0

205 27 Buffered_DatagramConnection 0 75777 27 Buffered_DatagramConnection 27 Buffered_DatagramConnection 0 0 0 1 181 148 0 11 178 179 180 182 183 184 185 186 187 188 189 0 0 1 0 200 0 0 0 0 176
// there are 3 states 1. Socket not even assigned,,,, 2. Socket Assigned and
// trying to get a active connect open 3. Socket is open and  writable.. (
// Fully powered up )...

206 10 Socket_UDP 0 141313 10 Socket_UDP 10 Socket_UDP 0 0 0 1 190 196 0 5 191 192 193 194 195 0 0 1 0 202 0 0 0 0 171
/**
 * Base functionality for a combination UDP Reader and Writer.  This
 * duplicates code from Socket_UDP_Outgoing, to avoid the problems of multiple
 * inheritance.
 */

207 22 Socket_Address const * 0 8576 22 Socket_Address const * 22 Socket_Address const * 0 0 208 0 0 0 0 0 0 0 0 0 0

208 20 Socket_Address const 0 8832 20 Socket_Address const 20 Socket_Address const 0 0 197 0 0 0 0 0 0 0 0 0 0

209 16 Socket_Address * 0 8576 16 Socket_Address * 16 Socket_Address * 0 0 197 0 0 0 0 0 0 0 0 0 0

210 18 unsigned short int 0 8262 18 unsigned short int 18 unsigned short int 0 1 0 0 0 0 0 0 0 0 0 0 0

211 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

212 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

213 8 uint32_t 0 2105344 8 uint32_t 8 uint32_t 0 0 214 0 0 0 0 0 0 0 0 0 0

214 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0

215 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

216 11 sa_family_t 0 2105344 11 sa_family_t 11 sa_family_t 0 0 210 0 0 0 0 0 0 0 0 0 0

217 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0

218 11 Socket_IP * 0 8576 11 Socket_IP * 11 Socket_IP * 0 0 198 0 0 0 0 0 0 0 0 0 0

219 6 SOCKET 0 2105344 6 SOCKET 6 SOCKET 0 0 217 0 0 0 0 0 0 0 0 0 0

220 17 Socket_IP const * 0 8576 17 Socket_IP const * 17 Socket_IP const * 0 0 221 0 0 0 0 0 0 0 0 0 0

221 15 Socket_IP const 0 8832 15 Socket_IP const 15 Socket_IP const 0 0 198 0 0 0 0 0 0 0 0 0 0

222 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

223 10 TypeHandle 0 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

224 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 223 0 0 0 0 0 0 0 0 0 0

225 12 Socket_TCP * 0 8576 12 Socket_TCP * 12 Socket_TCP * 0 0 200 0 0 0 0 0 0 0 0 0 0

226 18 Socket_TCP const * 0 8576 18 Socket_TCP const * 18 Socket_TCP const * 0 0 227 0 0 0 0 0 0 0 0 0 0

227 16 Socket_TCP const 0 8832 16 Socket_TCP const 16 Socket_TCP const 0 0 200 0 0 0 0 0 0 0 0 0 0

228 19 Socket_TCP_Listen * 0 8576 19 Socket_TCP_Listen * 19 Socket_TCP_Listen * 0 0 201 0 0 0 0 0 0 0 0 0 0

229 25 Socket_TCP_Listen const * 0 8576 25 Socket_TCP_Listen const * 25 Socket_TCP_Listen const * 0 0 230 0 0 0 0 0 0 0 0 0 0

230 23 Socket_TCP_Listen const 0 8832 23 Socket_TCP_Listen const 23 Socket_TCP_Listen const 0 0 201 0 0 0 0 0 0 0 0 0 0

231 21 Socket_UDP_Incoming * 0 8576 21 Socket_UDP_Incoming * 21 Socket_UDP_Incoming * 0 0 202 0 0 0 0 0 0 0 0 0 0

232 27 Socket_UDP_Incoming const * 0 8576 27 Socket_UDP_Incoming const * 27 Socket_UDP_Incoming const * 0 0 233 0 0 0 0 0 0 0 0 0 0

233 25 Socket_UDP_Incoming const 0 8832 25 Socket_UDP_Incoming const 25 Socket_UDP_Incoming const 0 0 202 0 0 0 0 0 0 0 0 0 0

234 21 Socket_UDP_Outgoing * 0 8576 21 Socket_UDP_Outgoing * 21 Socket_UDP_Outgoing * 0 0 203 0 0 0 0 0 0 0 0 0 0

235 27 Socket_UDP_Outgoing const * 0 8576 27 Socket_UDP_Outgoing const * 27 Socket_UDP_Outgoing const * 0 0 236 0 0 0 0 0 0 0 0 0 0

236 25 Socket_UDP_Outgoing const 0 8832 25 Socket_UDP_Outgoing const 25 Socket_UDP_Outgoing const 0 0 203 0 0 0 0 0 0 0 0 0 0

237 14 Socket_fdset * 0 8576 14 Socket_fdset * 14 Socket_fdset * 0 0 204 0 0 0 0 0 0 0 0 0 0

238 20 Socket_fdset const * 0 8576 20 Socket_fdset const * 20 Socket_fdset const * 0 0 239 0 0 0 0 0 0 0 0 0 0

239 18 Socket_fdset const 0 8832 18 Socket_fdset const 18 Socket_fdset const 0 0 204 0 0 0 0 0 0 0 0 0 0

240 17 Time_Span const * 0 8576 17 Time_Span const * 17 Time_Span const * 0 0 241 0 0 0 0 0 0 0 0 0 0

241 15 Time_Span const 0 8832 15 Time_Span const 15 Time_Span const 0 0 242 0 0 0 0 0 0 0 0 0 0

242 9 Time_Span 0 1050624 9 Time_Span 9 Time_Span 0 0 0 0 0 0 0 0 0 0 0 0 10
/**
 *
 */

243 35 Buffered_DatagramConnection const * 0 8576 35 Buffered_DatagramConnection const * 35 Buffered_DatagramConnection const * 0 0 244 0 0 0 0 0 0 0 0 0 0

244 33 Buffered_DatagramConnection const 0 8832 33 Buffered_DatagramConnection const 33 Buffered_DatagramConnection const 0 0 205 0 0 0 0 0 0 0 0 0 0

245 29 Buffered_DatagramConnection * 0 8576 29 Buffered_DatagramConnection * 29 Buffered_DatagramConnection * 0 0 205 0 0 0 0 0 0 0 0 0 0

246 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 247 0 0 0 0 0 0 0 0 0 0

247 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565
/**
 * An ordered list of data elements, formatted in memory for transmission over
 * a socket or writing to a data file.
 *
 * Data elements should be added one at a time, in order, to the Datagram.
 * The nature and contents of the data elements are totally up to the user.
 * When a Datagram has been transmitted and received, its data elements may be
 * extracted using a DatagramIterator; it is up to the caller to know the
 * correct type of each data element in order.
 *
 * A Datagram is itself headerless; it is simply a collection of data
 * elements.
 */

248 16 Datagram const * 0 8576 16 Datagram const * 16 Datagram const * 0 0 249 0 0 0 0 0 0 0 0 0 0

249 14 Datagram const 0 8832 14 Datagram const 14 Datagram const 0 0 247 0 0 0 0 0 0 0 0 0 0

250 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 251 0 0 0 0 0 0 0 0 0 0

251 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

252 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 217 0 0 0 0 0 0 0 0 0 0

253 12 Socket_UDP * 0 8576 12 Socket_UDP * 12 Socket_UDP * 0 0 206 0 0 0 0 0 0 0 0 0 0

254 18 Socket_UDP const * 0 8576 18 Socket_UDP const * 18 Socket_UDP const * 0 0 255 0 0 0 0 0 0 0 0 0 0

255 16 Socket_UDP const 0 8832 16 Socket_UDP const 16 Socket_UDP const 0 0 206 0 0 0 0 0 0 0 0 0 0

0
0
0
