1478211511
3 2
16 libp3pgraphnodes 4 Bgt0 12 panda3d.core 
187
177 15 upcast_to_Light 0 12 364 26 LightNode::upcast_to_Light 0 1 4 30
upcast from LightNode to Light
40
Light *LightNode::upcast_to_Light(void);

178 21 downcast_to_LightNode 0 12 365 28 Light::downcast_to_LightNode 0 1 5 32
downcast from Light to LightNode
46
LightNode *Light::downcast_to_LightNode(void);

179 19 upcast_to_PandaNode 0 12 364 30 LightNode::upcast_to_PandaNode 0 1 6 34
upcast from LightNode to PandaNode
48
PandaNode *LightNode::upcast_to_PandaNode(void);

180 21 downcast_to_LightNode 0 12 366 32 PandaNode::downcast_to_LightNode 0 1 7 36
downcast from PandaNode to LightNode
50
LightNode *PandaNode::downcast_to_LightNode(void);

181 6 output 0 6 364 17 LightNode::output 0 1 1 100
// We have to explicitly publish these because they resolve the multiple
// inheritance.

/**
 *
 */
51
virtual void LightNode::output(ostream &out) const;

182 5 write 0 6 364 16 LightNode::write 0 1 2 10
/**
 *
 */
72
virtual void LightNode::write(ostream &out, int indent_level = 0) const;

183 14 get_class_type 0 4 364 25 LightNode::get_class_type 0 1 3 0
50
static TypeHandle LightNode::get_class_type(void);

184 10 ~LightNode 0 4 364 21 LightNode::~LightNode 0 0 0
28
LightNode::~LightNode(void);

185 12 AmbientLight 0 4 367 26 AmbientLight::AmbientLight 0 1 8 138
/**
 *
 */

/**
 * Do not call the copy constructor directly; instead, use make_copy() or
 * copy_subgraph() to make a copy of a node.
 */
52
AmbientLight::AmbientLight(std::string const &name);

186 14 get_class_type 0 4 367 28 AmbientLight::get_class_type 0 1 9 0
53
static TypeHandle AmbientLight::get_class_type(void);

187 13 ~AmbientLight 0 4 367 27 AmbientLight::~AmbientLight 0 0 0
34
AmbientLight::~AmbientLight(void);

188 12 CallbackNode 0 4 368 26 CallbackNode::CallbackNode 0 1 10 22
/**
 *
 */

/**
 *
 */
52
CallbackNode::CallbackNode(std::string const &name);

189 17 set_cull_callback 0 4 368 31 CallbackNode::set_cull_callback 0 1 11 1131
/**
 * Sets the CallbackObject that will be notified when this node is visited
 * during the cull traversal.  This callback will be made during the cull
 * thread.
 *
 * The cull traversal is responsible for determining which nodes are visible
 * and within the view frustum, and for accumulating state and transform, and
 * generally building up the list of CullableObjects that are to be eventually
 * passed to the draw traversal for rendering.
 *
 * At the time the cull traversal callback is made, the node has been
 * determined to be visible and it has passed the bounding-volume test, so it
 * lies within the view frustum.
 *
 * The callback is passed an instance of a NodeCullCallbackData, which
 * contains pointers to the CullTraverser and CullTraverserData--enough data
 * to examine the current node and its place within the scene graph.  The
 * callback *replaces* the normal cull behavior, so if your callback does
 * nothing, the cull traversal will not continue below this node.  If you wish
 * the cull traversal to continue to visit this node and below, you must call
 * cbdata->upcall() from your callback.
 */
68
inline void CallbackNode::set_cull_callback(CallbackObject *object);

190 19 clear_cull_callback 0 4 368 33 CallbackNode::clear_cull_callback 0 1 12 78
/**
 * Removes the callback set by an earlier call to set_cull_callback().
 */
52
inline void CallbackNode::clear_cull_callback(void);

191 17 get_cull_callback 0 4 368 31 CallbackNode::get_cull_callback 0 1 13 65
/**
 * Returns the CallbackObject set by set_cull_callback().
 */
67
inline CallbackObject *CallbackNode::get_cull_callback(void) const;

192 17 set_draw_callback 0 4 368 31 CallbackNode::set_draw_callback 0 1 14 973
/**
 * Sets the CallbackObject that will be notified when this node is visited
 * during the draw traversal.  This callback will be made during the draw
 * thread.
 *
 * The draw traversal is responsible for actually issuing the commands to the
 * graphics engine to draw primitives.  Its job is to walk through the list of
 * CullableObjects build up by the cull traversal, as quickly as possible,
 * issuing the appropriate commands to draw each one.
 *
 * At the time the draw traversal callback is made, the graphics state has
 * been loaded with the correct modelview transform and render state, and the
 * primitives (if any) in this node are ready to be drawn.
 *
 * The callback is passed an instance of a GeomDrawCallbackData, which
 * contains pointers to the current state and transform, as well as the
 * current GSG.  There is a Geom pointer as well, but it will always be NULL
 * to this callback, since the CallbackNode does not itself contain any Geoms.
 */
68
inline void CallbackNode::set_draw_callback(CallbackObject *object);

193 19 clear_draw_callback 0 4 368 33 CallbackNode::clear_draw_callback 0 1 15 78
/**
 * Removes the callback set by an earlier call to set_draw_callback().
 */
52
inline void CallbackNode::clear_draw_callback(void);

194 17 get_draw_callback 0 4 368 31 CallbackNode::get_draw_callback 0 1 16 65
/**
 * Returns the CallbackObject set by set_draw_callback().
 */
67
inline CallbackObject *CallbackNode::get_draw_callback(void) const;

195 14 get_class_type 0 4 368 28 CallbackNode::get_class_type 0 1 17 0
53
static TypeHandle CallbackNode::get_class_type(void);

196 13 ~CallbackNode 0 4 368 27 CallbackNode::~CallbackNode 0 0 0
34
CallbackNode::~CallbackNode(void);

197 11 ComputeNode 0 4 371 24 ComputeNode::ComputeNode 0 1 18 134
/**
 * Creates a ComputeNode with the given name.  Use add_dispatch and  also
 * assign a shader using a ShaderAttrib.
 */

/**
 *
 */
50
ComputeNode::ComputeNode(std::string const &name);

198 12 add_dispatch 0 4 371 25 ComputeNode::add_dispatch 0 2 19 20 388
/**
 * Adds a dispatch command with the given number of work groups in the X, Y,
 * and Z dimensions.  Any of these values may be set to 1 if the respective
 * dimension should not be used.
 */

/**
 * Adds a dispatch command with the given number of work groups in the X, Y,
 * and Z dimensions.  Any of these values may be set to 1 if the respective
 * dimension should not be used.
 */
161
inline void ComputeNode::add_dispatch(LVecBase3i const &num_groups);
inline void ComputeNode::add_dispatch(int num_groups_x, int num_groups_y, int num_groups_z);

199 18 get_num_dispatches 0 4 371 31 ComputeNode::get_num_dispatches 0 1 21 83
/**
 * Returns the number of times add_dispatch has been called on this object.
 */
63
inline std::size_t ComputeNode::get_num_dispatches(void) const;

200 12 get_dispatch 0 4 371 25 ComputeNode::get_dispatch 0 1 22 84
/**
 * Returns the group counts of the nth dispatch associated with this object.
 */
72
inline LVecBase3i const &ComputeNode::get_dispatch(std::size_t i) const;

201 12 set_dispatch 0 4 371 25 ComputeNode::set_dispatch 0 1 23 81
/**
 * Sets the group counts of the nth dispatch associated with this object.
 */
83
inline void ComputeNode::set_dispatch(std::size_t i, LVecBase3i const &num_groups);

202 15 remove_dispatch 0 4 371 28 ComputeNode::remove_dispatch 0 1 24 57
/**
 * Erases the given dispatch index from the list.
 */
56
inline void ComputeNode::remove_dispatch(std::size_t i);

203 16 clear_dispatches 0 4 371 29 ComputeNode::clear_dispatches 0 1 25 41
/**
 * Removes all dispatch commands.
 */
48
inline void ComputeNode::clear_dispatches(void);

204 14 get_class_type 0 4 371 27 ComputeNode::get_class_type 0 1 26 0
52
static TypeHandle ComputeNode::get_class_type(void);

205 12 ~ComputeNode 0 4 371 25 ComputeNode::~ComputeNode 0 0 0
32
ComputeNode::~ComputeNode(void);

206 15 upcast_to_Light 0 12 375 30 LightLensNode::upcast_to_Light 0 1 36 34
upcast from LightLensNode to Light
44
Light *LightLensNode::upcast_to_Light(void);

207 25 downcast_to_LightLensNode 0 12 365 32 Light::downcast_to_LightLensNode 0 1 37 36
downcast from Light to LightLensNode
54
LightLensNode *Light::downcast_to_LightLensNode(void);

208 16 upcast_to_Camera 0 12 375 31 LightLensNode::upcast_to_Camera 0 1 38 35
upcast from LightLensNode to Camera
46
Camera *LightLensNode::upcast_to_Camera(void);

209 25 downcast_to_LightLensNode 0 12 376 33 Camera::downcast_to_LightLensNode 0 1 39 37
downcast from Camera to LightLensNode
55
LightLensNode *Camera::downcast_to_LightLensNode(void);

210 14 ~LightLensNode 0 6 375 29 LightLensNode::~LightLensNode 0 0 10
/**
 *
 */
44
virtual LightLensNode::~LightLensNode(void);

211 16 is_shadow_caster 0 4 375 31 LightLensNode::is_shadow_caster 0 1 27 75
/**
 * Returns whether this light is configured to cast shadows or not.
 */
50
inline bool LightLensNode::is_shadow_caster(void);

212 17 set_shadow_caster 0 4 375 32 LightLensNode::set_shadow_caster 0 2 28 29 609
/**
 * Sets the flag indicating whether this light should cast shadows or not.
 * This is the variant without buffer size, meaning that the current buffer
 * size will be kept (512x512 is the default). Note that enabling shadows will
 * require the shader generator to be enabled on the scene.
 */

/**
 * Sets the flag indicating whether this light should cast shadows or not.
 * The xsize and ysize parameters specify the size of the shadow buffer that
 * will be set up, the sort parameter specifies the sort.  Note that enabling
 * shadows will require the shader generator to be enabled on the scene.
 */
169
inline void LightLensNode::set_shadow_caster(bool caster);
inline void LightLensNode::set_shadow_caster(bool caster, int buffer_xsize, int buffer_ysize, int sort = -10);

213 22 get_shadow_buffer_size 0 4 375 37 LightLensNode::get_shadow_buffer_size 0 1 30 85
/**
 * Returns the size of the shadow buffer to be created for this light source.
 */
68
inline LVecBase2i LightLensNode::get_shadow_buffer_size(void) const;

214 22 set_shadow_buffer_size 0 4 375 37 LightLensNode::set_shadow_buffer_size 0 1 31 82
/**
 * Sets the size of the shadow buffer to be created for this light source.
 */
74
inline void LightLensNode::set_shadow_buffer_size(LVecBase2i const &size);

215 17 get_shadow_buffer 0 4 375 32 LightLensNode::get_shadow_buffer 0 1 32 214
/**
 * Returns the buffer that has been constructed for a given GSG, or NULL if no
 * such buffer has (yet) been constructed.  This should be used for debugging
 * only, you will not need to call this normally.
 */
92
inline GraphicsOutputBase *LightLensNode::get_shadow_buffer(GraphicsStateGuardianBase *gsg);

216 6 output 0 6 375 21 LightLensNode::output 0 1 33 100
// We have to explicitly publish these because they resolve the multiple
// inheritance.

/**
 *
 */
55
virtual void LightLensNode::output(ostream &out) const;

217 5 write 0 6 375 20 LightLensNode::write 0 1 34 10
/**
 *
 */
76
virtual void LightLensNode::write(ostream &out, int indent_level = 0) const;

218 14 get_class_type 0 4 375 29 LightLensNode::get_class_type 0 1 35 0
54
static TypeHandle LightLensNode::get_class_type(void);

219 16 DirectionalLight 0 4 379 34 DirectionalLight::DirectionalLight 0 1 40 138
/**
 *
 */

/**
 * Do not call the copy constructor directly; instead, use make_copy() or
 * copy_subgraph() to make a copy of a node.
 */
60
DirectionalLight::DirectionalLight(std::string const &name);

220 18 get_specular_color 0 4 379 36 DirectionalLight::get_specular_color 0 1 41 120
/**
 * Returns the color of specular highlights generated by the light.  This is
 * usually the same as get_color().
 */
70
inline LColor const &DirectionalLight::get_specular_color(void) final;

221 18 set_specular_color 0 4 379 36 DirectionalLight::set_specular_color 0 1 42 72
/**
 * Sets the color of specular highlights generated by the light.
 */
70
inline void DirectionalLight::set_specular_color(LColor const &color);

222 20 clear_specular_color 0 4 379 38 DirectionalLight::clear_specular_color 0 1 43 115
/**
 * Clears a custom specular color setting, meaning that the specular color
 * will now come from the color.
 */
57
inline void DirectionalLight::clear_specular_color(void);

223 9 get_point 0 4 379 27 DirectionalLight::get_point 0 1 44 349
/**
 * Returns the point in space at which the light is located.  This is local to
 * the coordinate space in which the light is assigned.
 *
 * This actually has no bearing on the visual effect of the light, since the
 * light is rendered as if it were infinitely far away.  This is only used to
 * create a visible representation of the light.
 */
62
inline LPoint3 const &DirectionalLight::get_point(void) const;

224 9 set_point 0 4 379 27 DirectionalLight::set_point 0 1 45 65
/**
 * Sets the point in space at which the light is located.
 */
62
inline void DirectionalLight::set_point(LPoint3 const &point);

225 13 get_direction 0 4 379 31 DirectionalLight::get_direction 0 1 46 135
/**
 * Returns the direction in which the light is aimed.  This is local to the
 * coordinate space in which the light is assigned.
 */
67
inline LVector3 const &DirectionalLight::get_direction(void) const;

226 13 set_direction 0 4 379 31 DirectionalLight::set_direction 0 1 47 58
/**
 * Sets the direction in which the light is aimed.
 */
71
inline void DirectionalLight::set_direction(LVector3 const &direction);

227 14 get_class_type 0 4 379 32 DirectionalLight::get_class_type 0 1 48 0
57
static TypeHandle DirectionalLight::get_class_type(void);

228 17 ~DirectionalLight 0 4 379 35 DirectionalLight::~DirectionalLight 0 0 0
42
DirectionalLight::~DirectionalLight(void);

229 7 LODNode 0 4 390 16 LODNode::LODNode 0 1 49 22
/**
 *
 */

/**
 *
 */
49
inline LODNode::LODNode(std::string const &name);

230 16 make_default_lod 0 4 390 25 LODNode::make_default_lod 0 1 50 98
/**
 * Creates a new LODNode of the type specified by the default-lod-type config
 * variable.
 */
79
static PointerTo< LODNode > LODNode::make_default_lod(std::string const &name);

231 10 add_switch 0 4 390 19 LODNode::add_switch 0 1 51 355
/**
 * Adds a switch range to the LODNode.  This implies that the corresponding
 * child node has been parented to the node.
 *
 * The sense of in vs.  out distances is as if the object were coming towards
 * you from far away: it switches "in" at the far distance, and switches "out"
 * at the close distance.  Thus, "in" should be larger than "out".
 */
65
inline void LODNode::add_switch(PN_stdfloat in, PN_stdfloat out);

232 10 set_switch 0 4 390 19 LODNode::set_switch 0 1 52 98
/**
 * Changes the switching range of a particular child of the LODNode.  See
 * add_switch().
 */
76
inline bool LODNode::set_switch(int index, PN_stdfloat in, PN_stdfloat out);

233 14 clear_switches 0 4 390 23 LODNode::clear_switches 0 1 53 146
/**
 * Removes the set of switching ranges for the LODNode, presumably in
 * conjunction with removing all of its children.  See add_switch().
 */
42
inline void LODNode::clear_switches(void);

234 16 get_num_switches 0 4 390 25 LODNode::get_num_switches 0 1 54 184
/**
 * Returns the number of switch ranges added to the LODNode.  This should
 * correspond to the number of children of the node in order for the LODNode
 * to function correctly.
 */
49
inline int LODNode::get_num_switches(void) const;

235 6 get_in 0 4 390 15 LODNode::get_in 0 1 55 136
/**
 * Returns the "in" distance of the indicated switch range.  This should be
 * larger than the "out" distance of the same range.
 */
52
inline PN_stdfloat LODNode::get_in(int index) const;

236 7 get_out 0 4 390 16 LODNode::get_out 0 1 56 137
/**
 * Returns the "out" distance of the indicated switch range.  This should be
 * smaller than the "in" distance of the same range.
 */
53
inline PN_stdfloat LODNode::get_out(int index) const;

237 17 get_lowest_switch 0 4 390 26 LODNode::get_lowest_switch 0 1 57 220
/**
 * Returns the index number of the child with the lowest level of detail; that
 * is, the one that is designed to be seen from the farthest away.  This is
 * usually the first child, but it is not necessarily so.
 */
50
inline int LODNode::get_lowest_switch(void) const;

238 18 get_highest_switch 0 4 390 27 LODNode::get_highest_switch 0 1 58 228
/**
 * Returns the index number of the child with the highest level of detail;
 * that is, the one that is designed to be seen from the closest to the
 * camera.  This is usually the last child, but it is not necessarily so.
 */
51
inline int LODNode::get_highest_switch(void) const;

239 12 force_switch 0 4 390 21 LODNode::force_switch 0 1 59 149
/**
 * Forces the LODNode to show the indicated level instead of the level that
 * would normally be shown based on the distance from the camera.
 */
45
inline void LODNode::force_switch(int index);

240 18 clear_force_switch 0 4 390 27 LODNode::clear_force_switch 0 1 60 133
/**
 * Undoes the effect of a previous call to force_switch() and releases the
 * LODNode to once again display the normal level.
 */
46
inline void LODNode::clear_force_switch(void);

241 13 set_lod_scale 0 4 390 22 LODNode::set_lod_scale 0 1 61 331
// for performance tuning, increasing this value should improve performance
// at the cost of model quality

// for performance tuning, increasing this value should improve performance
// at the cost of model quality

/**
 * Sets the multiplier for lod distances.  A higher value means you'll see
 * farther switchs than normal
 */
54
inline void LODNode::set_lod_scale(PN_stdfloat value);

242 13 get_lod_scale 0 4 390 22 LODNode::get_lod_scale 0 1 62 51
/**
 * Returns the multiplier for lod distances
 */
54
inline PN_stdfloat LODNode::get_lod_scale(void) const;

243 10 set_center 0 4 390 19 LODNode::set_center 0 1 63 172
/**
 * Specifies the center of the LOD.  This is the point that is compared to the
 * camera (in camera space) to determine the particular LOD that should be
 * chosen.
 */
55
inline void LODNode::set_center(LPoint3 const &center);

244 10 get_center 0 4 390 19 LODNode::get_center 0 1 64 170
/**
 * Returns the center of the LOD.  This is the point that is compared to the
 * camera (in camera space) to determine the particular LOD that should be
 * chosen.
 */
54
inline LPoint3 const &LODNode::get_center(void) const;

245 11 show_switch 0 4 390 20 LODNode::show_switch 0 2 65 66 1102
/**
 * This is provided as a debugging aid.  show_switch() will put the LODNode
 * into a special mode where rather than computing and drawing the appropriate
 * level of the LOD, a ring is drawn around the LODNode center indicating the
 * switch distances from the camera for the indicated level, and the geometry
 * of the indicated level is drawn in wireframe.
 *
 * Multiple different levels can be visualized this way at once.  Call
 * hide_switch() or hide_all_switches() to undo this mode and restore the
 * LODNode to its normal behavior.
 */

/**
 * This is provided as a debugging aid.  show_switch() will put the LODNode
 * into a special mode where rather than computing and drawing the appropriate
 * level of the LOD, a ring is drawn around the LODNode center indicating the
 * switch distances from the camera for the indicated level, and the geometry
 * of the indicated level is drawn in wireframe.
 *
 * Multiple different levels can be visualized this way at once.  Call
 * hide_switch() or hide_all_switches() to undo this mode and restore the
 * LODNode to its normal behavior.
 */
96
void LODNode::show_switch(int index);
void LODNode::show_switch(int index, LColor const &color);

246 11 hide_switch 0 4 390 20 LODNode::hide_switch 0 1 67 53
/**
 * Disables a previous call to show_switch().
 */
37
void LODNode::hide_switch(int index);

247 17 show_all_switches 0 4 390 26 LODNode::show_all_switches 0 1 68 52
/**
 * Shows all levels in their default colors.
 */
38
void LODNode::show_all_switches(void);

248 17 hide_all_switches 0 4 390 26 LODNode::hide_all_switches 0 1 69 71
/**
 * Hides all levels, restoring the LODNode to normal operation.
 */
38
void LODNode::hide_all_switches(void);

249 12 is_any_shown 0 4 390 21 LODNode::is_any_shown 0 1 70 159
/**
 * Returns true if any switch has been shown with show_switch(), indicating
 * the LODNode is in debug show mode; or false if it is in the normal mode.
 */
46
inline bool LODNode::is_any_shown(void) const;

250 19 verify_child_bounds 0 4 390 28 LODNode::verify_child_bounds 0 1 71 274
/**
 * Returns true if the bounding volumes for the geometry of each fhild node
 * entirely fits within the switch_in radius for that child, or false
 * otherwise.  It is almost always a mistake for the geometry of an LOD level
 * to be larger than its switch_in radius.
 */
46
bool LODNode::verify_child_bounds(void) const;

251 14 get_class_type 0 4 390 23 LODNode::get_class_type 0 1 72 0
48
static TypeHandle LODNode::get_class_type(void);

252 8 ~LODNode 0 4 390 17 LODNode::~LODNode 0 0 0
24
LODNode::~LODNode(void);

253 11 FadeLODNode 0 4 394 24 FadeLODNode::FadeLODNode 0 1 73 22
/**
 *
 */

/**
 *
 */
50
FadeLODNode::FadeLODNode(std::string const &name);

254 13 set_fade_time 0 4 394 26 FadeLODNode::set_fade_time 0 1 74 55
/**
 * set the time taken to complete an LOD switch
 */
54
inline void FadeLODNode::set_fade_time(PN_stdfloat t);

255 13 get_fade_time 0 4 394 26 FadeLODNode::get_fade_time 0 1 75 55
/**
 * get the time taken to complete an LOD switch
 */
58
inline PN_stdfloat FadeLODNode::get_fade_time(void) const;

256 12 set_fade_bin 0 4 394 25 FadeLODNode::set_fade_bin 0 1 76 124
/**
 * Specifies the cull bin and draw order that is assigned to the fading part
 * of the geometry during a transition.
 */
72
void FadeLODNode::set_fade_bin(std::string const &name, int draw_order);

257 17 get_fade_bin_name 0 4 394 30 FadeLODNode::get_fade_bin_name 0 1 77 107
/**
 * Returns the cull bin that is assigned to the fading part of the geometry
 * during a transition.
 */
69
inline std::string const &FadeLODNode::get_fade_bin_name(void) const;

258 23 get_fade_bin_draw_order 0 4 394 36 FadeLODNode::get_fade_bin_draw_order 0 1 78 135
/**
 * Returns the draw order that is assigned (along with the bin name) to the
 * fading part of the geometry during a transition.
 */
60
inline int FadeLODNode::get_fade_bin_draw_order(void) const;

259 23 set_fade_state_override 0 4 394 36 FadeLODNode::set_fade_state_override 0 1 79 191
/**
 * Specifies the override value that is applied to the state changes necessary
 * to apply the fade effect.  This should be larger than any attrib overrides
 * on the fading geometry.
 */
56
void FadeLODNode::set_fade_state_override(int override);

260 23 get_fade_state_override 0 4 394 36 FadeLODNode::get_fade_state_override 0 1 80 189
/**
 * Returns the override value that is applied to the state changes necessary
 * to apply the fade effect.  This should be larger than any attrib overrides
 * on the fading geometry.
 */
60
inline int FadeLODNode::get_fade_state_override(void) const;

261 14 get_class_type 0 4 394 27 FadeLODNode::get_class_type 0 1 81 0
52
static TypeHandle FadeLODNode::get_class_type(void);

262 12 ~FadeLODNode 0 4 394 25 FadeLODNode::~FadeLODNode 0 0 0
32
FadeLODNode::~FadeLODNode(void);

263 8 get_trav 0 4 398 30 NodeCullCallbackData::get_trav 0 1 83 193
/**
 * Returns the CullTraverser in use at the time of the callback.  This object
 * contains data that does not change during the traversal, such as the
 * DisplayRegion and Camera in use.
 */
65
inline CullTraverser *NodeCullCallbackData::get_trav(void) const;

264 8 get_data 0 4 398 30 NodeCullCallbackData::get_data 0 1 84 222
/**
 * Returns the CullTraverserData in use at the time of the callback.  This
 * object contains data that changes at each node of the traversal, such as
 * the current node and the current net transform to that node.
 */
69
inline CullTraverserData &NodeCullCallbackData::get_data(void) const;

265 14 get_class_type 0 4 398 36 NodeCullCallbackData::get_class_type 0 1 85 0
61
static TypeHandle NodeCullCallbackData::get_class_type(void);

266 20 NodeCullCallbackData 0 4 398 42 NodeCullCallbackData::NodeCullCallbackData 0 1 82 10
/**
 *
 */
90
inline NodeCullCallbackData::NodeCullCallbackData(NodeCullCallbackData const &) = default;

267 21 ~NodeCullCallbackData 0 4 398 43 NodeCullCallbackData::~NodeCullCallbackData 0 0 0
50
NodeCullCallbackData::~NodeCullCallbackData(void);

268 10 PointLight 0 4 400 22 PointLight::PointLight 0 1 86 138
/**
 *
 */

/**
 * Do not call the copy constructor directly; instead, use make_copy() or
 * copy_subgraph() to make a copy of a node.
 */
48
PointLight::PointLight(std::string const &name);

269 18 get_specular_color 0 4 400 30 PointLight::get_specular_color 0 1 87 120
/**
 * Returns the color of specular highlights generated by the light.  This is
 * usually the same as get_color().
 */
64
inline LColor const &PointLight::get_specular_color(void) final;

270 18 set_specular_color 0 4 400 30 PointLight::set_specular_color 0 1 88 72
/**
 * Sets the color of specular highlights generated by the light.
 */
64
inline void PointLight::set_specular_color(LColor const &color);

271 20 clear_specular_color 0 4 400 32 PointLight::clear_specular_color 0 1 89 115
/**
 * Clears a custom specular color setting, meaning that the specular color
 * will now come from the color.
 */
51
inline void PointLight::clear_specular_color(void);

272 15 get_attenuation 0 4 400 27 PointLight::get_attenuation 0 1 90 193
/**
 * Returns the terms of the attenuation equation for the light.  These are, in
 * order, the constant, linear, and quadratic terms based on the distance from
 * the point to the vertex.
 */
64
inline LVecBase3 const &PointLight::get_attenuation(void) final;

273 15 set_attenuation 0 4 400 27 PointLight::set_attenuation 0 1 91 190
/**
 * Sets the terms of the attenuation equation for the light.  These are, in
 * order, the constant, linear, and quadratic terms based on the distance from
 * the point to the vertex.
 */
70
inline void PointLight::set_attenuation(LVecBase3 const &attenuation);

274 16 get_max_distance 0 4 400 28 PointLight::get_max_distance 0 1 92 122
/**
 * Returns the maximum distance at which the light has any effect, as previously
 * specified by set_max_distance.
 */
60
inline PN_stdfloat PointLight::get_max_distance(void) const;

275 16 set_max_distance 0 4 400 28 PointLight::set_max_distance 0 1 93 161
/**
 * Sets the radius of the light's sphere of influence.  Beyond this distance, the
 * light may be attenuated to zero, if this is supported by the shader.
 */
67
inline void PointLight::set_max_distance(PN_stdfloat max_distance);

276 9 get_point 0 4 400 21 PointLight::get_point 0 1 94 160
/**
 * Returns the point in space at which the light is located.  This is local to
 * the coordinate space in which the light is assigned, and is usually 0.
 */
56
inline LPoint3 const &PointLight::get_point(void) const;

277 9 set_point 0 4 400 21 PointLight::set_point 0 1 95 77
/**
 * Sets the point in space at which the light is located.  Usually 0.
 */
56
inline void PointLight::set_point(LPoint3 const &point);

278 14 get_class_type 0 4 400 26 PointLight::get_class_type 0 1 96 0
51
static TypeHandle PointLight::get_class_type(void);

279 11 ~PointLight 0 4 400 23 PointLight::~PointLight 0 0 0
30
PointLight::~PointLight(void);

280 18 SelectiveChildNode 0 4 404 38 SelectiveChildNode::SelectiveChildNode 0 1 97 22
/**
 *
 */

/**
 *
 */
71
inline SelectiveChildNode::SelectiveChildNode(std::string const &name);

281 14 get_class_type 0 4 404 34 SelectiveChildNode::get_class_type 0 1 98 0
59
static TypeHandle SelectiveChildNode::get_class_type(void);

282 19 ~SelectiveChildNode 0 4 404 39 SelectiveChildNode::~SelectiveChildNode 0 0 0
46
SelectiveChildNode::~SelectiveChildNode(void);

283 28 upcast_to_SelectiveChildNode 0 12 405 42 SequenceNode::upcast_to_SelectiveChildNode 0 1 103 46
upcast from SequenceNode to SelectiveChildNode
69
SelectiveChildNode *SequenceNode::upcast_to_SelectiveChildNode(void);

284 24 downcast_to_SequenceNode 0 12 404 44 SelectiveChildNode::downcast_to_SequenceNode 0 1 104 48
downcast from SelectiveChildNode to SequenceNode
65
SequenceNode *SelectiveChildNode::downcast_to_SequenceNode(void);

285 23 upcast_to_AnimInterface 0 12 405 37 SequenceNode::upcast_to_AnimInterface 0 1 105 41
upcast from SequenceNode to AnimInterface
59
AnimInterface *SequenceNode::upcast_to_AnimInterface(void);

286 24 downcast_to_SequenceNode 0 12 406 39 AnimInterface::downcast_to_SequenceNode 0 1 106 43
downcast from AnimInterface to SequenceNode
60
SequenceNode *AnimInterface::downcast_to_SequenceNode(void);

287 12 SequenceNode 0 4 405 26 SequenceNode::SequenceNode 0 1 99 22
/**
 *
 */

/**
 *
 */
59
inline SequenceNode::SequenceNode(std::string const &name);

288 14 get_num_frames 0 6 405 28 SequenceNode::get_num_frames 0 1 100 278
/**
 * Returns the number of frames in the animation.  This is a property of the
 * animation and may not be directly adjusted by the user (although it may
 * change without warning with certain kinds of animations, since this is a
 * virtual method that may be overridden).
 */
53
virtual int SequenceNode::get_num_frames(void) const;

289 14 set_frame_rate 0 4 405 28 SequenceNode::set_frame_rate 0 1 101 173
/**
 * Changes the advertised frame rate of the SequenceNode.  This can be used in
 * conjunction with get_play_rate() to change the effective frame rate of the
 * node.
 */
60
inline void SequenceNode::set_frame_rate(double frame_rate);

290 14 get_class_type 0 4 405 28 SequenceNode::get_class_type 0 1 102 0
53
static TypeHandle SequenceNode::get_class_type(void);

291 13 ~SequenceNode 0 4 405 27 SequenceNode::~SequenceNode 0 0 0
34
SequenceNode::~SequenceNode(void);

292 15 ShaderGenerator 0 4 407 32 ShaderGenerator::ShaderGenerator 0 2 107 108 189
/**
 * Create a ShaderGenerator.  This has no state, except possibly to cache
 * certain results.  The parameter that must be passed is the GSG to which the
 * shader generator belongs.
 */
167
ShaderGenerator::ShaderGenerator(GraphicsStateGuardianBase *gsg, GraphicsOutputBase *host);
inline ShaderGenerator::ShaderGenerator(ShaderGenerator const &) = default;

293 17 synthesize_shader 0 6 407 34 ShaderGenerator::synthesize_shader 0 1 109 825
/**
 * This is the routine that implements the next-gen fixed function pipeline by
 * synthesizing a shader.  It also takes care of setting up any buffers needed
 * to produce the requested effects.
 *
 * Currently supports: - flat colors - vertex colors - lighting - normal maps,
 * but not multiple - gloss maps, but not multiple - glow maps, but not
 * multiple - materials, but not updates to materials - 2D textures - all
 * texture stage modes, including combine modes - color scale attrib - light
 * ramps (for cartoon shading) - shadow mapping - most texgen modes -
 * texmatrix - 1D/2D/3D textures, cube textures, 2D tex arrays -
 * linear/exp/exp2 fog - animation
 *
 * Not yet supported: - dot3_rgb and dot3_rgba combine modes
 *
 * Potential optimizations - omit attenuation calculations if attenuation off
 *
 */
134
virtual ConstPointerTo< ShaderAttrib > ShaderGenerator::synthesize_shader(RenderState const *rs, GeomVertexAnimationSpec const &anim);

294 14 get_class_type 0 4 407 31 ShaderGenerator::get_class_type 0 1 110 0
56
static TypeHandle ShaderGenerator::get_class_type(void);

295 11 SphereLight 0 4 409 24 SphereLight::SphereLight 0 1 111 138
/**
 *
 */

/**
 * Do not call the copy constructor directly; instead, use make_copy() or
 * copy_subgraph() to make a copy of a node.
 */
50
SphereLight::SphereLight(std::string const &name);

296 10 get_radius 0 4 409 23 SphereLight::get_radius 0 1 112 44
/**
 * Returns the radius of the sphere.
 */
55
inline PN_stdfloat SphereLight::get_radius(void) const;

297 10 set_radius 0 4 409 23 SphereLight::set_radius 0 1 113 41
/**
 * Sets the radius of the sphere.
 */
56
inline void SphereLight::set_radius(PN_stdfloat radius);

298 14 get_class_type 0 4 409 27 SphereLight::get_class_type 0 1 114 0
52
static TypeHandle SphereLight::get_class_type(void);

299 12 ~SphereLight 0 4 409 25 SphereLight::~SphereLight 0 0 0
32
SphereLight::~SphereLight(void);

300 9 Spotlight 0 4 410 20 Spotlight::Spotlight 0 1 115 138
/**
 *
 */

/**
 * Do not call the copy constructor directly; instead, use make_copy() or
 * copy_subgraph() to make a copy of a node.
 */
46
Spotlight::Spotlight(std::string const &name);

301 12 get_exponent 0 4 410 23 Spotlight::get_exponent 0 1 116 131
/**
 * Returns the exponent that controls the amount of light falloff from the
 * center of the spotlight.  See set_exponent().
 */
55
inline PN_stdfloat Spotlight::get_exponent(void) final;

302 12 set_exponent 0 4 410 23 Spotlight::set_exponent 0 1 117 398
/**
 * Sets the exponent that controls the amount of light falloff from the center
 * of the spotlight.  The light is attenuated by the cosine of the angle
 * between the direction of the light and the direction of the point being
 * lighted, raised to the power of this exponent.  Thus, higher exponents
 * result in a more focused light source, regardless of the field-of-view of
 * the lens.
 */
58
inline void Spotlight::set_exponent(PN_stdfloat exponent);

303 18 get_specular_color 0 4 410 29 Spotlight::get_specular_color 0 1 118 120
/**
 * Returns the color of specular highlights generated by the light.  This is
 * usually the same as get_color().
 */
63
inline LColor const &Spotlight::get_specular_color(void) final;

304 18 set_specular_color 0 4 410 29 Spotlight::set_specular_color 0 1 119 72
/**
 * Sets the color of specular highlights generated by the light.
 */
63
inline void Spotlight::set_specular_color(LColor const &color);

305 20 clear_specular_color 0 4 410 31 Spotlight::clear_specular_color 0 1 120 115
/**
 * Clears a custom specular color setting, meaning that the specular color
 * will now come from the color.
 */
50
inline void Spotlight::clear_specular_color(void);

306 15 get_attenuation 0 4 410 26 Spotlight::get_attenuation 0 1 121 193
/**
 * Returns the terms of the attenuation equation for the light.  These are, in
 * order, the constant, linear, and quadratic terms based on the distance from
 * the point to the vertex.
 */
63
inline LVecBase3 const &Spotlight::get_attenuation(void) final;

307 15 set_attenuation 0 4 410 26 Spotlight::set_attenuation 0 1 122 190
/**
 * Sets the terms of the attenuation equation for the light.  These are, in
 * order, the constant, linear, and quadratic terms based on the distance from
 * the point to the vertex.
 */
69
inline void Spotlight::set_attenuation(LVecBase3 const &attenuation);

308 16 get_max_distance 0 4 410 27 Spotlight::get_max_distance 0 1 123 122
/**
 * Returns the maximum distance at which the light has any effect, as previously
 * specified by set_max_distance.
 */
59
inline PN_stdfloat Spotlight::get_max_distance(void) const;

309 16 set_max_distance 0 4 410 27 Spotlight::set_max_distance 0 1 124 161
/**
 * Sets the radius of the light's sphere of influence.  Beyond this distance, the
 * light may be attenuated to zero, if this is supported by the shader.
 */
66
inline void Spotlight::set_max_distance(PN_stdfloat max_distance);

310 9 make_spot 0 4 410 20 Spotlight::make_spot 0 1 125 619
/**
 * Returns a newly-generated Texture that renders a circular spot image as
 * might be cast from the spotlight.  This may be projected onto target
 * geometry (for instance, via NodePath::project_texture()) instead of
 * actually enabling the light itself, as a cheesy way to make a high-
 * resolution spot appear on the geometry.
 *
 * pixel_width specifies the height and width of the new texture in pixels,
 * full_radius is a value in the range 0..1 that indicates the relative size
 * of the fully bright center spot, and fg and bg are the colors of the
 * interior and exterior of the spot, respectively.
 */
115
static PointerTo< Texture > Spotlight::make_spot(int pixel_width, PN_stdfloat full_radius, LColor &fg, LColor &bg);

311 14 get_class_type 0 4 410 25 Spotlight::get_class_type 0 1 126 0
50
static TypeHandle Spotlight::get_class_type(void);

312 10 ~Spotlight 0 4 410 21 Spotlight::~Spotlight 0 0 0
28
Spotlight::~Spotlight(void);

313 10 SwitchNode 0 4 411 22 SwitchNode::SwitchNode 0 1 127 22
/**
 *
 */

/**
 *
 */
55
inline SwitchNode::SwitchNode(std::string const &name);

314 17 set_visible_child 0 4 411 29 SwitchNode::set_visible_child 0 1 128 90
/**
 * Specifies the particular child of this node, by index, that will be
 * visible.
 */
53
inline void SwitchNode::set_visible_child(int index);

315 17 get_visible_child 0 6 411 29 SwitchNode::get_visible_child 0 1 129 65
/**
 * Returns the index of the child that should be visible.
 */
54
virtual int SwitchNode::get_visible_child(void) const;

316 14 get_class_type 0 4 411 26 SwitchNode::get_class_type 0 1 130 0
51
static TypeHandle SwitchNode::get_class_type(void);

317 11 ~SwitchNode 0 4 411 23 SwitchNode::~SwitchNode 0 0 0
30
SwitchNode::~SwitchNode(void);

318 12 UvScrollNode 0 4 412 26 UvScrollNode::UvScrollNode 0 2 131 132 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
203
inline UvScrollNode::UvScrollNode(std::string const &name, PN_stdfloat u_speed, PN_stdfloat v_speed, PN_stdfloat w_speed, PN_stdfloat r_speed);
inline UvScrollNode::UvScrollNode(std::string const &name);

319 11 set_u_speed 0 4 412 25 UvScrollNode::set_u_speed 0 1 133 10
/**
 *
 */
59
inline void UvScrollNode::set_u_speed(PN_stdfloat u_speed);

320 11 set_v_speed 0 4 412 25 UvScrollNode::set_v_speed 0 1 134 10
/**
 *
 */
59
inline void UvScrollNode::set_v_speed(PN_stdfloat v_speed);

321 11 set_w_speed 0 4 412 25 UvScrollNode::set_w_speed 0 1 135 10
/**
 *
 */
59
inline void UvScrollNode::set_w_speed(PN_stdfloat w_speed);

322 11 set_r_speed 0 4 412 25 UvScrollNode::set_r_speed 0 1 136 10
/**
 *
 */
59
inline void UvScrollNode::set_r_speed(PN_stdfloat r_speed);

323 11 get_u_speed 0 4 412 25 UvScrollNode::get_u_speed 0 1 137 10
/**
 *
 */
57
inline PN_stdfloat UvScrollNode::get_u_speed(void) const;

324 11 get_v_speed 0 4 412 25 UvScrollNode::get_v_speed 0 1 138 10
/**
 *
 */
57
inline PN_stdfloat UvScrollNode::get_v_speed(void) const;

325 11 get_w_speed 0 4 412 25 UvScrollNode::get_w_speed 0 1 139 10
/**
 *
 */
57
inline PN_stdfloat UvScrollNode::get_w_speed(void) const;

326 11 get_r_speed 0 4 412 25 UvScrollNode::get_r_speed 0 1 140 10
/**
 *
 */
57
inline PN_stdfloat UvScrollNode::get_r_speed(void) const;

327 14 get_class_type 0 4 412 28 UvScrollNode::get_class_type 0 1 141 0
53
static TypeHandle UvScrollNode::get_class_type(void);

328 13 ~UvScrollNode 0 4 412 27 UvScrollNode::~UvScrollNode 0 0 0
34
UvScrollNode::~UvScrollNode(void);

329 18 SceneGraphAnalyzer 0 4 413 38 SceneGraphAnalyzer::SceneGraphAnalyzer 0 2 142 143 10
/**
 *
 */
130
SceneGraphAnalyzer::SceneGraphAnalyzer(void);
inline SceneGraphAnalyzer::SceneGraphAnalyzer(SceneGraphAnalyzer const &) = default;

330 19 ~SceneGraphAnalyzer 0 4 413 39 SceneGraphAnalyzer::~SceneGraphAnalyzer 0 0 10
/**
 *
 */
46
SceneGraphAnalyzer::~SceneGraphAnalyzer(void);

331 12 set_lod_mode 0 4 413 32 SceneGraphAnalyzer::set_lod_mode 0 1 144 61
/**
 * Specifies the mode in which LODNodes are analyzed.
 */
83
inline void SceneGraphAnalyzer::set_lod_mode(SceneGraphAnalyzer::LodMode lod_mode);

332 12 get_lod_mode 0 4 413 32 SceneGraphAnalyzer::get_lod_mode 0 1 145 59
/**
 * Returns the mode in which LODNodes are analyzed.
 */
112
inline SceneGraphAnalyzer::LodMode SceneGraphAnalyzer::get_lod_mode(SceneGraphAnalyzer::LodMode lod_mode) const;

333 5 clear 0 4 413 25 SceneGraphAnalyzer::clear 0 1 146 79
/**
 * Resets all of the data in the analyzer in preparation for a new run.
 */
37
void SceneGraphAnalyzer::clear(void);

334 8 add_node 0 4 413 28 SceneGraphAnalyzer::add_node 0 1 147 244
/**
 * Adds a new node to the set of data for analysis.  Normally, this would only
 * be called once, and passed the top of the scene graph, but it's possible to
 * repeatedly pass in subgraphs to get an analysis of all the graphs together.
 */
51
void SceneGraphAnalyzer::add_node(PandaNode *node);

335 5 write 0 4 413 25 SceneGraphAnalyzer::write 0 1 148 44
/**
 * Describes all the data collected.
 */
73
void SceneGraphAnalyzer::write(ostream &out, int indent_level = 0) const;

336 13 get_num_nodes 0 4 413 33 SceneGraphAnalyzer::get_num_nodes 0 1 149 10
/**
 *
 */
57
inline int SceneGraphAnalyzer::get_num_nodes(void) const;

337 17 get_num_instances 0 4 413 37 SceneGraphAnalyzer::get_num_instances 0 1 150 10
/**
 *
 */
61
inline int SceneGraphAnalyzer::get_num_instances(void) const;

338 18 get_num_transforms 0 4 413 38 SceneGraphAnalyzer::get_num_transforms 0 1 151 10
/**
 *
 */
62
inline int SceneGraphAnalyzer::get_num_transforms(void) const;

339 26 get_num_nodes_with_attribs 0 4 413 46 SceneGraphAnalyzer::get_num_nodes_with_attribs 0 1 152 10
/**
 *
 */
70
inline int SceneGraphAnalyzer::get_num_nodes_with_attribs(void) const;

340 17 get_num_lod_nodes 0 4 413 37 SceneGraphAnalyzer::get_num_lod_nodes 0 1 153 10
/**
 *
 */
61
inline int SceneGraphAnalyzer::get_num_lod_nodes(void) const;

341 18 get_num_geom_nodes 0 4 413 38 SceneGraphAnalyzer::get_num_geom_nodes 0 1 154 10
/**
 *
 */
62
inline int SceneGraphAnalyzer::get_num_geom_nodes(void) const;

342 13 get_num_geoms 0 4 413 33 SceneGraphAnalyzer::get_num_geoms 0 1 155 10
/**
 *
 */
57
inline int SceneGraphAnalyzer::get_num_geoms(void) const;

343 25 get_num_geom_vertex_datas 0 4 413 45 SceneGraphAnalyzer::get_num_geom_vertex_datas 0 1 156 10
/**
 *
 */
69
inline int SceneGraphAnalyzer::get_num_geom_vertex_datas(void) const;

344 27 get_num_geom_vertex_formats 0 4 413 47 SceneGraphAnalyzer::get_num_geom_vertex_formats 0 1 157 10
/**
 *
 */
71
inline int SceneGraphAnalyzer::get_num_geom_vertex_formats(void) const;

345 20 get_vertex_data_size 0 4 413 40 SceneGraphAnalyzer::get_vertex_data_size 0 1 158 10
/**
 *
 */
72
inline std::size_t SceneGraphAnalyzer::get_vertex_data_size(void) const;

346 16 get_num_vertices 0 4 413 36 SceneGraphAnalyzer::get_num_vertices 0 1 159 10
/**
 *
 */
60
inline int SceneGraphAnalyzer::get_num_vertices(void) const;

347 15 get_num_normals 0 4 413 35 SceneGraphAnalyzer::get_num_normals 0 1 160 10
/**
 *
 */
59
inline int SceneGraphAnalyzer::get_num_normals(void) const;

348 14 get_num_colors 0 4 413 34 SceneGraphAnalyzer::get_num_colors 0 1 161 10
/**
 *
 */
58
inline int SceneGraphAnalyzer::get_num_colors(void) const;

349 17 get_num_texcoords 0 4 413 37 SceneGraphAnalyzer::get_num_texcoords 0 1 162 10
/**
 *
 */
61
inline int SceneGraphAnalyzer::get_num_texcoords(void) const;

350 12 get_num_tris 0 4 413 32 SceneGraphAnalyzer::get_num_tris 0 1 163 10
/**
 *
 */
56
inline int SceneGraphAnalyzer::get_num_tris(void) const;

351 13 get_num_lines 0 4 413 33 SceneGraphAnalyzer::get_num_lines 0 1 164 10
/**
 *
 */
57
inline int SceneGraphAnalyzer::get_num_lines(void) const;

352 14 get_num_points 0 4 413 34 SceneGraphAnalyzer::get_num_points 0 1 165 10
/**
 *
 */
58
inline int SceneGraphAnalyzer::get_num_points(void) const;

353 15 get_num_patches 0 4 413 35 SceneGraphAnalyzer::get_num_patches 0 1 166 10
/**
 *
 */
59
inline int SceneGraphAnalyzer::get_num_patches(void) const;

354 23 get_num_individual_tris 0 4 413 43 SceneGraphAnalyzer::get_num_individual_tris 0 1 167 10
/**
 *
 */
67
inline int SceneGraphAnalyzer::get_num_individual_tris(void) const;

355 17 get_num_tristrips 0 4 413 37 SceneGraphAnalyzer::get_num_tristrips 0 1 168 10
/**
 *
 */
61
inline int SceneGraphAnalyzer::get_num_tristrips(void) const;

356 27 get_num_triangles_in_strips 0 4 413 47 SceneGraphAnalyzer::get_num_triangles_in_strips 0 1 169 10
/**
 *
 */
71
inline int SceneGraphAnalyzer::get_num_triangles_in_strips(void) const;

357 15 get_num_trifans 0 4 413 35 SceneGraphAnalyzer::get_num_trifans 0 1 170 10
/**
 *
 */
59
inline int SceneGraphAnalyzer::get_num_trifans(void) const;

358 25 get_num_triangles_in_fans 0 4 413 45 SceneGraphAnalyzer::get_num_triangles_in_fans 0 1 171 10
/**
 *
 */
69
inline int SceneGraphAnalyzer::get_num_triangles_in_fans(void) const;

359 27 get_num_vertices_in_patches 0 4 413 47 SceneGraphAnalyzer::get_num_vertices_in_patches 0 1 172 10
/**
 *
 */
71
inline int SceneGraphAnalyzer::get_num_vertices_in_patches(void) const;

360 17 get_texture_bytes 0 4 413 37 SceneGraphAnalyzer::get_texture_bytes 0 1 173 10
/**
 *
 */
61
inline int SceneGraphAnalyzer::get_texture_bytes(void) const;

361 20 get_num_long_normals 0 4 413 40 SceneGraphAnalyzer::get_num_long_normals 0 1 174 10
/**
 *
 */
64
inline int SceneGraphAnalyzer::get_num_long_normals(void) const;

362 21 get_num_short_normals 0 4 413 41 SceneGraphAnalyzer::get_num_short_normals 0 1 175 10
/**
 *
 */
65
inline int SceneGraphAnalyzer::get_num_short_normals(void) const;

363 23 get_total_normal_length 0 4 413 43 SceneGraphAnalyzer::get_total_normal_length 0 1 176 10
/**
 *
 */
75
inline PN_stdfloat SceneGraphAnalyzer::get_total_normal_length(void) const;

176
1 0 0 4 8 419 0 0 88 // We have to explicitly publish these because they resolve the multiple
// inheritance. 2 4 this 3 415  3 out 1 417  
2 0 0 4 9 419 0 0 10 /**
 *
 */ 3 4 this 3 415  3 out 1 417  12 indent_level 1 393  
3 0 0 7 10 421 0 0 0 0 
4 0 0 6 3 423 0 0 0 1 4 this 3 422  
5 0 0 7 4 422 184 0 0 1 4 this 3 423  
6 0 0 7 6 424 0 0 0 1 4 this 3 422  
7 0 0 7 7 422 184 0 0 1 4 this 3 424  
8 0 0 7 13 426 187 0 10 /**
 *
 */ 1 4 name 1 425  
9 0 0 7 14 421 0 0 0 0 
10 0 0 7 17 427 196 0 10 /**
 *
 */ 1 4 name 1 425  
11 0 0 4 18 419 0 0 1131 /**
 * Sets the CallbackObject that will be notified when this node is visited
 * during the cull traversal.  This callback will be made during the cull
 * thread.
 *
 * The cull traversal is responsible for determining which nodes are visible
 * and within the view frustum, and for accumulating state and transform, and
 * generally building up the list of CullableObjects that are to be eventually
 * passed to the draw traversal for rendering.
 *
 * At the time the cull traversal callback is made, the node has been
 * determined to be visible and it has passed the bounding-volume test, so it
 * lies within the view frustum.
 *
 * The callback is passed an instance of a NodeCullCallbackData, which
 * contains pointers to the CullTraverser and CullTraverserData--enough data
 * to examine the current node and its place within the scene graph.  The
 * callback *replaces* the normal cull behavior, so if your callback does
 * nothing, the cull traversal will not continue below this node.  If you wish
 * the cull traversal to continue to visit this node and below, you must call
 * cbdata->upcall() from your callback.
 */ 2 4 this 3 427  6 object 1 369  
12 0 0 4 19 419 0 0 78 /**
 * Removes the callback set by an earlier call to set_cull_callback().
 */ 1 4 this 3 427  
13 0 0 7 20 369 0 0 65 /**
 * Returns the CallbackObject set by set_cull_callback().
 */ 1 4 this 3 428  
14 0 0 4 24 419 0 0 973 /**
 * Sets the CallbackObject that will be notified when this node is visited
 * during the draw traversal.  This callback will be made during the draw
 * thread.
 *
 * The draw traversal is responsible for actually issuing the commands to the
 * graphics engine to draw primitives.  Its job is to walk through the list of
 * CullableObjects build up by the cull traversal, as quickly as possible,
 * issuing the appropriate commands to draw each one.
 *
 * At the time the draw traversal callback is made, the graphics state has
 * been loaded with the correct modelview transform and render state, and the
 * primitives (if any) in this node are ready to be drawn.
 *
 * The callback is passed an instance of a GeomDrawCallbackData, which
 * contains pointers to the current state and transform, as well as the
 * current GSG.  There is a Geom pointer as well, but it will always be NULL
 * to this callback, since the CallbackNode does not itself contain any Geoms.
 */ 2 4 this 3 427  6 object 1 369  
15 0 0 4 25 419 0 0 78 /**
 * Removes the callback set by an earlier call to set_draw_callback().
 */ 1 4 this 3 427  
16 0 0 7 26 369 0 0 65 /**
 * Returns the CallbackObject set by set_draw_callback().
 */ 1 4 this 3 428  
17 0 0 7 28 421 0 0 0 0 
18 0 0 7 31 430 205 0 122 /**
 * Creates a ComputeNode with the given name.  Use add_dispatch and  also
 * assign a shader using a ShaderAttrib.
 */ 1 4 name 1 425  
19 0 0 4 32 419 0 0 193 /**
 * Adds a dispatch command with the given number of work groups in the X, Y,
 * and Z dimensions.  Any of these values may be set to 1 if the respective
 * dimension should not be used.
 */ 2 4 this 3 430  10 num_groups 1 431  
20 0 0 4 32 419 0 0 193 /**
 * Adds a dispatch command with the given number of work groups in the X, Y,
 * and Z dimensions.  Any of these values may be set to 1 if the respective
 * dimension should not be used.
 */ 4 4 this 3 430  12 num_groups_x 1 393  12 num_groups_y 1 393  12 num_groups_z 1 393  
21 0 0 6 33 434 0 0 83 /**
 * Returns the number of times add_dispatch has been called on this object.
 */ 1 4 this 3 432  
22 0 0 6 34 431 0 0 84 /**
 * Returns the group counts of the nth dispatch associated with this object.
 */ 2 4 this 3 432  1 i 1 434  
23 0 0 4 35 419 0 0 81 /**
 * Sets the group counts of the nth dispatch associated with this object.
 */ 3 4 this 3 430  1 i 1 434  10 num_groups 1 431  
24 0 0 4 36 419 0 0 57 /**
 * Erases the given dispatch index from the list.
 */ 2 4 this 3 430  1 i 1 434  
25 0 0 4 37 419 0 0 41 /**
 * Removes all dispatch commands.
 */ 1 4 this 3 430  
26 0 0 7 42 421 0 0 0 0 
27 0 0 6 52 377 0 0 75 /**
 * Returns whether this light is configured to cast shadows or not.
 */ 1 4 this 3 436  
28 0 0 4 53 419 0 0 297 /**
 * Sets the flag indicating whether this light should cast shadows or not.
 * This is the variant without buffer size, meaning that the current buffer
 * size will be kept (512x512 is the default). Note that enabling shadows will
 * require the shader generator to be enabled on the scene.
 */ 2 4 this 3 436  6 caster 1 377  
29 0 0 4 53 419 0 0 310 /**
 * Sets the flag indicating whether this light should cast shadows or not.
 * The xsize and ysize parameters specify the size of the shadow buffer that
 * will be set up, the sort parameter specifies the sort.  Note that enabling
 * shadows will require the shader generator to be enabled on the scene.
 */ 5 4 this 3 436  6 caster 1 377  12 buffer_xsize 1 393  12 buffer_ysize 1 393  4 sort 1 393  
30 0 0 7 54 439 0 0 85 /**
 * Returns the size of the shadow buffer to be created for this light source.
 */ 1 4 this 3 437  
31 0 0 4 55 419 0 0 82 /**
 * Sets the size of the shadow buffer to be created for this light source.
 */ 2 4 this 3 436  4 size 1 440  
32 0 0 7 56 445 0 0 214 /**
 * Returns the buffer that has been constructed for a given GSG, or NULL if no
 * such buffer has (yet) been constructed.  This should be used for debugging
 * only, you will not need to call this normally.
 */ 2 4 this 3 436  3 gsg 1 443  
33 0 0 4 61 419 0 0 88 // We have to explicitly publish these because they resolve the multiple
// inheritance. 2 4 this 3 437  3 out 1 417  
34 0 0 4 62 419 0 0 10 /**
 *
 */ 3 4 this 3 437  3 out 1 417  12 indent_level 1 393  
35 0 0 7 63 421 0 0 0 0 
36 0 0 6 46 423 0 0 0 1 4 this 3 436  
37 0 0 7 47 436 210 0 0 1 4 this 3 423  
38 0 0 7 49 446 0 0 0 1 4 this 3 436  
39 0 0 7 50 436 210 0 0 1 4 this 3 446  
40 0 0 7 65 447 228 0 10 /**
 *
 */ 1 4 name 1 425  
41 0 0 6 66 448 0 0 0 1 4 this 3 447  
42 0 0 4 67 419 0 0 72 /**
 * Sets the color of specular highlights generated by the light.
 */ 2 4 this 3 447  5 color 1 448  
43 0 0 4 68 419 0 0 115 /**
 * Clears a custom specular color setting, meaning that the specular color
 * will now come from the color.
 */ 1 4 this 3 447  
44 0 0 6 74 451 0 0 349 /**
 * Returns the point in space at which the light is located.  This is local to
 * the coordinate space in which the light is assigned.
 *
 * This actually has no bearing on the visual effect of the light, since the
 * light is rendered as if it were infinitely far away.  This is only used to
 * create a visible representation of the light.
 */ 1 4 this 3 449  
45 0 0 4 75 419 0 0 65 /**
 * Sets the point in space at which the light is located.
 */ 2 4 this 3 447  5 point 1 451  
46 0 0 6 80 452 0 0 135 /**
 * Returns the direction in which the light is aimed.  This is local to the
 * coordinate space in which the light is assigned.
 */ 1 4 this 3 449  
47 0 0 4 81 419 0 0 58 /**
 * Sets the direction in which the light is aimed.
 */ 2 4 this 3 447  9 direction 1 452  
48 0 0 7 86 421 0 0 0 0 
49 0 0 7 89 453 252 0 10 /**
 *
 */ 1 4 name 1 425  
50 0 0 7 90 453 252 0 98 /**
 * Creates a new LODNode of the type specified by the default-lod-type config
 * variable.
 */ 1 4 name 1 425  
51 0 0 4 91 419 0 0 355 /**
 * Adds a switch range to the LODNode.  This implies that the corresponding
 * child node has been parented to the node.
 *
 * The sense of in vs.  out distances is as if the object were coming towards
 * you from far away: it switches "in" at the far distance, and switches "out"
 * at the close distance.  Thus, "in" should be larger than "out".
 */ 3 4 this 3 453  2 in 1 391  3 out 1 391  
52 0 0 6 92 377 0 0 98 /**
 * Changes the switching range of a particular child of the LODNode.  See
 * add_switch().
 */ 4 4 this 3 453  5 index 1 393  2 in 1 391  3 out 1 391  
53 0 0 4 93 419 0 0 146 /**
 * Removes the set of switching ranges for the LODNode, presumably in
 * conjunction with removing all of its children.  See add_switch().
 */ 1 4 this 3 453  
54 0 0 6 94 393 0 0 184 /**
 * Returns the number of switch ranges added to the LODNode.  This should
 * correspond to the number of children of the node in order for the LODNode
 * to function correctly.
 */ 1 4 this 3 454  
55 0 0 6 95 391 0 0 136 /**
 * Returns the "in" distance of the indicated switch range.  This should be
 * larger than the "out" distance of the same range.
 */ 2 4 this 3 454  5 index 1 393  
56 0 0 6 97 391 0 0 137 /**
 * Returns the "out" distance of the indicated switch range.  This should be
 * smaller than the "in" distance of the same range.
 */ 2 4 this 3 454  5 index 1 393  
57 0 0 6 99 393 0 0 220 /**
 * Returns the index number of the child with the lowest level of detail; that
 * is, the one that is designed to be seen from the farthest away.  This is
 * usually the first child, but it is not necessarily so.
 */ 1 4 this 3 454  
58 0 0 6 100 393 0 0 228 /**
 * Returns the index number of the child with the highest level of detail;
 * that is, the one that is designed to be seen from the closest to the
 * camera.  This is usually the last child, but it is not necessarily so.
 */ 1 4 this 3 454  
59 0 0 4 101 419 0 0 149 /**
 * Forces the LODNode to show the indicated level instead of the level that
 * would normally be shown based on the distance from the camera.
 */ 2 4 this 3 453  5 index 1 393  
60 0 0 4 102 419 0 0 133 /**
 * Undoes the effect of a previous call to force_switch() and releases the
 * LODNode to once again display the normal level.
 */ 1 4 this 3 453  
61 0 0 4 103 419 0 0 113 /**
 * Sets the multiplier for lod distances.  A higher value means you'll see
 * farther switchs than normal
 */ 2 4 this 3 453  5 value 1 391  
62 0 0 6 104 391 0 0 51 /**
 * Returns the multiplier for lod distances
 */ 1 4 this 3 454  
63 0 0 4 105 419 0 0 172 /**
 * Specifies the center of the LOD.  This is the point that is compared to the
 * camera (in camera space) to determine the particular LOD that should be
 * chosen.
 */ 2 4 this 3 453  6 center 1 451  
64 0 0 6 106 451 0 0 170 /**
 * Returns the center of the LOD.  This is the point that is compared to the
 * camera (in camera space) to determine the particular LOD that should be
 * chosen.
 */ 1 4 this 3 454  
65 0 0 4 116 419 0 0 550 /**
 * This is provided as a debugging aid.  show_switch() will put the LODNode
 * into a special mode where rather than computing and drawing the appropriate
 * level of the LOD, a ring is drawn around the LODNode center indicating the
 * switch distances from the camera for the indicated level, and the geometry
 * of the indicated level is drawn in wireframe.
 *
 * Multiple different levels can be visualized this way at once.  Call
 * hide_switch() or hide_all_switches() to undo this mode and restore the
 * LODNode to its normal behavior.
 */ 2 4 this 3 453  5 index 1 393  
66 0 0 4 116 419 0 0 550 /**
 * This is provided as a debugging aid.  show_switch() will put the LODNode
 * into a special mode where rather than computing and drawing the appropriate
 * level of the LOD, a ring is drawn around the LODNode center indicating the
 * switch distances from the camera for the indicated level, and the geometry
 * of the indicated level is drawn in wireframe.
 *
 * Multiple different levels can be visualized this way at once.  Call
 * hide_switch() or hide_all_switches() to undo this mode and restore the
 * LODNode to its normal behavior.
 */ 3 4 this 3 453  5 index 1 393  5 color 1 448  
67 0 0 4 117 419 0 0 53 /**
 * Disables a previous call to show_switch().
 */ 2 4 this 3 453  5 index 1 393  
68 0 0 4 118 419 0 0 52 /**
 * Shows all levels in their default colors.
 */ 1 4 this 3 453  
69 0 0 4 119 419 0 0 71 /**
 * Hides all levels, restoring the LODNode to normal operation.
 */ 1 4 this 3 453  
70 0 0 6 120 377 0 0 159 /**
 * Returns true if any switch has been shown with show_switch(), indicating
 * the LODNode is in debug show mode; or false if it is in the normal mode.
 */ 1 4 this 3 454  
71 0 0 6 121 377 0 0 274 /**
 * Returns true if the bounding volumes for the geometry of each fhild node
 * entirely fits within the switch_in radius for that child, or false
 * otherwise.  It is almost always a mistake for the geometry of an LOD level
 * to be larger than its switch_in radius.
 */ 1 4 this 3 454  
72 0 0 7 122 421 0 0 0 0 
73 0 0 7 125 456 262 0 10 /**
 *
 */ 1 4 name 1 425  
74 0 0 4 126 419 0 0 55 /**
 * set the time taken to complete an LOD switch
 */ 2 4 this 3 456  1 t 1 391  
75 0 0 6 127 391 0 0 55 /**
 * get the time taken to complete an LOD switch
 */ 1 4 this 3 457  
76 0 0 4 129 419 0 0 124 /**
 * Specifies the cull bin and draw order that is assigned to the fading part
 * of the geometry during a transition.
 */ 3 4 this 3 456  4 name 1 425  10 draw_order 1 393  
77 0 0 6 130 425 0 0 107 /**
 * Returns the cull bin that is assigned to the fading part of the geometry
 * during a transition.
 */ 1 4 this 3 457  
78 0 0 6 131 393 0 0 135 /**
 * Returns the draw order that is assigned (along with the bin name) to the
 * fading part of the geometry during a transition.
 */ 1 4 this 3 457  
79 0 0 4 137 419 0 0 191 /**
 * Specifies the override value that is applied to the state changes necessary
 * to apply the fade effect.  This should be larger than any attrib overrides
 * on the fading geometry.
 */ 2 4 this 3 456  8 override 1 393  
80 0 0 6 138 393 0 0 189 /**
 * Returns the override value that is applied to the state changes necessary
 * to apply the fade effect.  This should be larger than any attrib overrides
 * on the fading geometry.
 */ 1 4 this 3 457  
81 0 0 7 140 421 0 0 0 0 
82 0 0 7 147 461 267 0 0 1 6 param0 0 459  
83 0 0 7 144 463 0 0 193 /**
 * Returns the CullTraverser in use at the time of the callback.  This object
 * contains data that does not change during the traversal, such as the
 * DisplayRegion and Camera in use.
 */ 1 4 this 3 459  
84 0 0 6 145 464 0 0 222 /**
 * Returns the CullTraverserData in use at the time of the callback.  This
 * object contains data that changes at each node of the traversal, such as
 * the current node and the current net transform to that node.
 */ 1 4 this 3 459  
85 0 0 7 146 421 0 0 0 0 
86 0 0 7 150 466 279 0 10 /**
 *
 */ 1 4 name 1 425  
87 0 0 6 151 448 0 0 0 1 4 this 3 466  
88 0 0 4 152 419 0 0 72 /**
 * Sets the color of specular highlights generated by the light.
 */ 2 4 this 3 466  5 color 1 448  
89 0 0 4 153 419 0 0 115 /**
 * Clears a custom specular color setting, meaning that the specular color
 * will now come from the color.
 */ 1 4 this 3 466  
90 0 0 6 155 467 0 0 0 1 4 this 3 466  
91 0 0 4 156 419 0 0 190 /**
 * Sets the terms of the attenuation equation for the light.  These are, in
 * order, the constant, linear, and quadratic terms based on the distance from
 * the point to the vertex.
 */ 2 4 this 3 466  11 attenuation 1 467  
92 0 0 6 161 391 0 0 122 /**
 * Returns the maximum distance at which the light has any effect, as previously
 * specified by set_max_distance.
 */ 1 4 this 3 468  
93 0 0 4 162 419 0 0 161 /**
 * Sets the radius of the light's sphere of influence.  Beyond this distance, the
 * light may be attenuated to zero, if this is supported by the shader.
 */ 2 4 this 3 466  12 max_distance 1 391  
94 0 0 6 164 451 0 0 160 /**
 * Returns the point in space at which the light is located.  This is local to
 * the coordinate space in which the light is assigned, and is usually 0.
 */ 1 4 this 3 468  
95 0 0 4 165 419 0 0 77 /**
 * Sets the point in space at which the light is located.  Usually 0.
 */ 2 4 this 3 466  5 point 1 451  
96 0 0 7 167 421 0 0 0 0 
97 0 0 7 170 470 282 0 10 /**
 *
 */ 1 4 name 1 425  
98 0 0 7 171 421 0 0 0 0 
99 0 0 7 179 471 291 0 10 /**
 *
 */ 1 4 name 1 425  
100 0 0 6 180 393 0 0 278 /**
 * Returns the number of frames in the animation.  This is a property of the
 * animation and may not be directly adjusted by the user (although it may
 * change without warning with certain kinds of animations, since this is a
 * virtual method that may be overridden).
 */ 1 4 this 3 472  
101 0 0 4 181 419 0 0 173 /**
 * Changes the advertised frame rate of the SequenceNode.  This can be used in
 * conjunction with get_play_rate() to change the effective frame rate of the
 * node.
 */ 2 4 this 3 471  10 frame_rate 1 474  
102 0 0 7 182 421 0 0 0 0 
103 0 0 7 174 470 282 0 0 1 4 this 3 471  
104 0 0 7 175 471 291 0 0 1 4 this 3 470  
105 0 0 6 177 475 0 0 0 1 4 this 3 471  
106 0 0 7 178 471 291 0 0 1 4 this 3 475  
107 0 0 7 186 476 0 0 189 /**
 * Create a ShaderGenerator.  This has no state, except possibly to cache
 * certain results.  The parameter that must be passed is the GSG to which the
 * shader generator belongs.
 */ 2 3 gsg 1 443  4 host 1 445  
108 0 0 7 186 476 0 0 0 1 6 param0 0 477  
109 0 0 7 187 487 0 0 825 /**
 * This is the routine that implements the next-gen fixed function pipeline by
 * synthesizing a shader.  It also takes care of setting up any buffers needed
 * to produce the requested effects.
 *
 * Currently supports: - flat colors - vertex colors - lighting - normal maps,
 * but not multiple - gloss maps, but not multiple - glow maps, but not
 * multiple - materials, but not updates to materials - 2D textures - all
 * texture stage modes, including combine modes - color scale attrib - light
 * ramps (for cartoon shading) - shadow mapping - most texgen modes -
 * texmatrix - 1D/2D/3D textures, cube textures, 2D tex arrays -
 * linear/exp/exp2 fog - animation
 *
 * Not yet supported: - dot3_rgb and dot3_rgba combine modes
 *
 * Potential optimizations - omit attenuation calculations if attenuation off
 *
 */ 3 4 this 3 476  2 rs 1 481  4 anim 1 484  
110 0 0 7 188 421 0 0 0 0 
111 0 0 7 190 488 299 0 10 /**
 *
 */ 1 4 name 1 425  
112 0 0 6 191 391 0 0 44 /**
 * Returns the radius of the sphere.
 */ 1 4 this 3 489  
113 0 0 4 192 419 0 0 41 /**
 * Sets the radius of the sphere.
 */ 2 4 this 3 488  6 radius 1 391  
114 0 0 7 194 421 0 0 0 0 
115 0 0 7 197 491 312 0 10 /**
 *
 */ 1 4 name 1 425  
116 0 0 6 198 391 0 0 0 1 4 this 3 491  
117 0 0 4 199 419 0 0 398 /**
 * Sets the exponent that controls the amount of light falloff from the center
 * of the spotlight.  The light is attenuated by the cosine of the angle
 * between the direction of the light and the direction of the point being
 * lighted, raised to the power of this exponent.  Thus, higher exponents
 * result in a more focused light source, regardless of the field-of-view of
 * the lens.
 */ 2 4 this 3 491  8 exponent 1 391  
118 0 0 6 201 448 0 0 0 1 4 this 3 491  
119 0 0 4 202 419 0 0 72 /**
 * Sets the color of specular highlights generated by the light.
 */ 2 4 this 3 491  5 color 1 448  
120 0 0 4 203 419 0 0 115 /**
 * Clears a custom specular color setting, meaning that the specular color
 * will now come from the color.
 */ 1 4 this 3 491  
121 0 0 6 205 467 0 0 0 1 4 this 3 491  
122 0 0 4 206 419 0 0 190 /**
 * Sets the terms of the attenuation equation for the light.  These are, in
 * order, the constant, linear, and quadratic terms based on the distance from
 * the point to the vertex.
 */ 2 4 this 3 491  11 attenuation 1 467  
123 0 0 6 208 391 0 0 122 /**
 * Returns the maximum distance at which the light has any effect, as previously
 * specified by set_max_distance.
 */ 1 4 this 3 492  
124 0 0 4 209 419 0 0 161 /**
 * Sets the radius of the light's sphere of influence.  Beyond this distance, the
 * light may be attenuated to zero, if this is supported by the shader.
 */ 2 4 this 3 491  12 max_distance 1 391  
125 0 0 7 211 496 0 0 619 /**
 * Returns a newly-generated Texture that renders a circular spot image as
 * might be cast from the spotlight.  This may be projected onto target
 * geometry (for instance, via NodePath::project_texture()) instead of
 * actually enabling the light itself, as a cheesy way to make a high-
 * resolution spot appear on the geometry.
 *
 * pixel_width specifies the height and width of the new texture in pixels,
 * full_radius is a value in the range 0..1 that indicates the relative size
 * of the fully bright center spot, and fg and bg are the colors of the
 * interior and exterior of the spot, respectively.
 */ 4 11 pixel_width 1 393  11 full_radius 1 391  2 fg 1 495  2 bg 1 495  
126 0 0 7 212 421 0 0 0 0 
127 0 0 7 215 497 317 0 10 /**
 *
 */ 1 4 name 1 425  
128 0 0 4 216 419 0 0 90 /**
 * Specifies the particular child of this node, by index, that will be
 * visible.
 */ 2 4 this 3 497  5 index 1 393  
129 0 0 6 217 393 0 0 65 /**
 * Returns the index of the child that should be visible.
 */ 1 4 this 3 498  
130 0 0 7 219 421 0 0 0 0 
131 0 0 7 222 500 328 0 10 /**
 *
 */ 1 4 name 1 425  
132 0 0 7 222 500 328 0 10 /**
 *
 */ 5 4 name 1 425  7 u_speed 1 391  7 v_speed 1 391  7 w_speed 1 391  7 r_speed 1 391  
133 0 0 4 223 419 0 0 10 /**
 *
 */ 2 4 this 3 500  7 u_speed 1 391  
134 0 0 4 224 419 0 0 10 /**
 *
 */ 2 4 this 3 500  7 v_speed 1 391  
135 0 0 4 225 419 0 0 10 /**
 *
 */ 2 4 this 3 500  7 w_speed 1 391  
136 0 0 4 226 419 0 0 10 /**
 *
 */ 2 4 this 3 500  7 r_speed 1 391  
137 0 0 6 227 391 0 0 10 /**
 *
 */ 1 4 this 3 501  
138 0 0 6 228 391 0 0 10 /**
 *
 */ 1 4 this 3 501  
139 0 0 6 229 391 0 0 10 /**
 *
 */ 1 4 this 3 501  
140 0 0 6 230 391 0 0 10 /**
 *
 */ 1 4 this 3 501  
141 0 0 7 235 421 0 0 0 0 
142 0 0 7 238 503 330 0 10 /**
 *
 */ 0 
143 0 0 7 238 503 330 0 0 1 6 param0 0 504  
144 0 0 4 241 419 0 0 61 /**
 * Specifies the mode in which LODNodes are analyzed.
 */ 2 4 this 3 503  8 lod_mode 1 414  
145 0 0 6 242 414 0 0 59 /**
 * Returns the mode in which LODNodes are analyzed.
 */ 2 4 this 3 504  8 lod_mode 1 414  
146 0 0 4 243 419 0 0 79 /**
 * Resets all of the data in the analyzer in preparation for a new run.
 */ 1 4 this 3 503  
147 0 0 4 244 419 0 0 244 /**
 * Adds a new node to the set of data for analysis.  Normally, this would only
 * be called once, and passed the top of the scene graph, but it's possible to
 * repeatedly pass in subgraphs to get an analysis of all the graphs together.
 */ 2 4 this 3 503  4 node 1 424  
148 0 0 4 245 419 0 0 44 /**
 * Describes all the data collected.
 */ 3 4 this 3 504  3 out 1 417  12 indent_level 1 393  
149 0 0 6 246 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
150 0 0 6 247 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
151 0 0 6 248 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
152 0 0 6 249 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
153 0 0 6 250 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
154 0 0 6 251 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
155 0 0 6 252 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
156 0 0 6 253 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
157 0 0 6 254 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
158 0 0 6 255 434 0 0 10 /**
 *
 */ 1 4 this 3 504  
159 0 0 6 256 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
160 0 0 6 257 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
161 0 0 6 258 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
162 0 0 6 259 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
163 0 0 6 260 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
164 0 0 6 261 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
165 0 0 6 262 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
166 0 0 6 263 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
167 0 0 6 264 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
168 0 0 6 265 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
169 0 0 6 266 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
170 0 0 6 267 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
171 0 0 6 268 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
172 0 0 6 269 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
173 0 0 6 270 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
174 0 0 6 271 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
175 0 0 6 272 393 0 0 10 /**
 *
 */ 1 4 this 3 504  
176 0 0 6 273 391 0 0 10 /**
 *
 */ 1 4 this 3 504  
142
364 9 LightNode 0 141313 9 LightNode 9 LightNode 0 0 0 0 184 0 3 181 182 183 0 0 2 3 365 177 178 3 366 179 180 0 0 161
/**
 * A derivative of Light and of PandaNode.  All kinds of Light except
 * Spotlight (which must inherit from LensNode instead) inherit from this
 * class.
 */

365 5 Light 0 2049 5 Light 5 Light 0 0 0 0 0 0 0 0 0 0 0 0 231
/**
 * The abstract interface to all kinds of lights.  The actual light objects
 * also inherit from PandaNode, and can therefore be added to the scene graph
 * at some arbitrary point to define the coordinate system of effect.
 */

366 9 PandaNode 0 2049 9 PandaNode 9 PandaNode 0 0 0 0 0 0 0 0 0 0 0 0 175
/**
 * A basic node of the scene graph or data graph.  This is the base class of
 * all specialized nodes, and also serves as a generic node with no special
 * properties.
 */

367 12 AmbientLight 0 141313 12 AmbientLight 12 AmbientLight 0 0 0 1 185 187 0 1 186 0 0 1 0 364 0 0 0 0 188
/**
 * A light source that seems to illuminate all points in space at once.  This
 * kind of light need not actually be part of the scene graph, since it has no
 * meaningful position.
 */

368 12 CallbackNode 0 141313 12 CallbackNode 12 CallbackNode 0 0 0 1 188 196 2 506 507 7 189 190 191 192 193 194 195 0 0 1 0 366 0 0 0 0 120
/**
 * A special node that can issue arbitrary callbacks to user code, either
 * during the cull or draw traversals.
 */

369 16 CallbackObject * 0 8576 16 CallbackObject * 16 CallbackObject * 0 0 370 0 0 0 0 0 0 0 0 0 0

370 14 CallbackObject 0 2048 14 CallbackObject 14 CallbackObject 0 0 0 0 0 0 0 0 0 0 0 0 276
/**
 * This is a generic object that can be assigned to a callback at various
 * points in the rendering process.  This is actually a base class for a
 * handful of specialized callback object types.  You can also subclass it
 * yourself to make your own callback handler.
 */

371 11 ComputeNode 0 141313 11 ComputeNode 11 ComputeNode 0 0 0 1 197 205 1 508 7 198 199 200 201 202 203 204 1 538 0 1 0 366 0 0 0 0 121
/**
 * A special node, the sole purpose of which is to invoke a dispatch operation
 * on the assigned compute shader.
 */

372 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 373 0 0 0 0 0 0 0 0 0 0

373 10 LVecBase3i 0 2048 10 LVecBase3i 10 LVecBase3i 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

374 11 LODNodeType 0 532481 11 LODNodeType 11 LODNodeType 0 0 0 0 0 0 0 0 0 0 2 7 LNT_pop 7 LNT_pop 0
0 8 LNT_fade 8 LNT_fade 0
1 0 0

375 13 LightLensNode 0 26625 13 LightLensNode 13 LightLensNode 0 0 0 0 210 2 509 510 8 211 212 213 214 215 216 217 218 0 0 2 3 365 206 207 3 376 208 209 0 0 215
/**
 * A derivative of Light and of Camera.  The name might be misleading: it does
 * not directly derive from LensNode, but through the Camera class.  The
 * Camera serves no purpose unless shadows are enabled.
 */

376 6 Camera 0 2049 6 Camera 6 Camera 0 0 0 0 0 0 0 0 0 0 0 0 121
/**
 * A node that can be positioned around in the scene graph to represent a
 * point of view for rendering a scene.
 */

377 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

378 10 LVecBase2i 0 2048 10 LVecBase2i 10 LVecBase2i 0 0 0 0 0 0 0 0 0 0 0 0 75
/**
 * This is the base class for all two-component vectors and points.
 */

379 16 DirectionalLight 0 141313 16 DirectionalLight 16 DirectionalLight 0 0 0 1 219 228 3 511 512 513 8 220 221 222 223 224 225 226 227 0 0 1 0 375 0 0 0 0 96
/**
 * A light shining from infinitely far away in a particular direction, like
 * sunlight.
 */

380 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 381 0 0 0 0 0 0 0 0 0 0

381 6 LColor 0 2105344 6 LColor 6 LColor 0 0 382 0 0 0 0 0 0 0 0 0 0

382 7 LColorf 0 2105344 7 LColorf 7 LColorf 0 0 383 0 0 0 0 0 0 0 0 0 0

383 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

384 13 LPoint3 const 0 8832 13 LPoint3 const 13 LPoint3 const 0 0 385 0 0 0 0 0 0 0 0 0 0

385 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 386 0 0 0 0 0 0 0 0 0 0

386 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

387 14 LVector3 const 0 8832 14 LVector3 const 14 LVector3 const 0 0 388 0 0 0 0 0 0 0 0 0 0

388 8 LVector3 0 2105344 8 LVector3 8 LVector3 0 0 389 0 0 0 0 0 0 0 0 0 0

389 9 LVector3f 0 2048 9 LVector3f 9 LVector3f 0 0 0 0 0 0 0 0 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

390 7 LODNode 0 141313 7 LODNode 7 LODNode 0 0 0 1 229 252 6 514 515 516 517 518 519 22 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 2 539 540 0 1 0 366 0 0 0 0 190
/**
 * A Level-of-Detail node.  This selects only one of its children for
 * rendering, according to the distance from the camera and the table
 * indicated in the associated LOD object.
 */

391 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 392 0 0 0 0 0 0 0 0 0 0

392 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

393 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

394 11 FadeLODNode 0 141313 11 FadeLODNode 11 FadeLODNode 0 0 0 1 253 262 4 520 521 522 523 8 254 255 256 257 258 259 260 261 0 0 1 0 390 0 0 0 0 61
/**
 * A Level-of-Detail node with alpha based switching.
 */

395 12 string const 0 8832 17 std::string const 17 std::string const 0 0 396 0 0 0 0 0 0 0 0 0 0

396 6 string 0 2105344 11 std::string 11 std::string 0 0 397 0 0 0 0 0 0 0 0 0 0

397 20 basic_string< char > 0 2048 25 std::basic_string< char > 25 std::basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

398 20 NodeCullCallbackData 0 141313 20 NodeCullCallbackData 20 NodeCullCallbackData 0 0 0 1 266 267 0 3 263 264 265 0 0 1 0 399 0 0 0 0 114
/**
 * This kind of CallbackData is passed to the CallbackObject added to
 * CallbackNode:set_cull_callback().
 */

399 12 CallbackData 0 2049 12 CallbackData 12 CallbackData 0 0 0 0 0 0 0 0 0 0 0 0 348
/**
 * This is a generic data block that is passed along to a CallbackObject when
 * a callback is made.  It contains data specific to the particular callback
 * type in question.
 *
 * This is actually an abstract base class and contains no data.
 * Specializations of this class will contain the actual data relevant to each
 * callback type.
 */

400 10 PointLight 0 141313 10 PointLight 10 PointLight 0 0 0 1 268 279 4 524 525 526 527 10 269 270 271 272 273 274 275 276 277 278 0 0 1 0 375 0 0 0 0 94
/**
 * A light originating from a single point in space, and shining in all
 * directions.
 */

401 15 LVecBase3 const 0 8832 15 LVecBase3 const 15 LVecBase3 const 0 0 402 0 0 0 0 0 0 0 0 0 0

402 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 403 0 0 0 0 0 0 0 0 0 0

403 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

404 18 SelectiveChildNode 0 141313 18 SelectiveChildNode 18 SelectiveChildNode 0 0 0 1 280 282 0 1 281 0 0 1 0 366 0 0 0 0 112
/**
 * A base class for nodes like LODNode and SequenceNode that select only one
 * visible child at a time.
 */

405 12 SequenceNode 0 141313 12 SequenceNode 12 SequenceNode 0 0 0 1 287 291 0 3 288 289 290 0 0 2 3 404 283 284 3 406 285 286 0 0 118
/**
 * A node that automatically cycles through rendering each one of its children
 * according to its frame rate.
 */

406 13 AnimInterface 0 2049 13 AnimInterface 13 AnimInterface 0 0 0 0 0 0 0 0 0 0 0 0 226
/**
 * This is the fundamental interface for things that have a play/loop/stop
 * type interface for frame-based animation, such as animated characters.
 * This is the base class for AnimControl and other, similar classes.
 */

407 15 ShaderGenerator 0 75777 15 ShaderGenerator 15 ShaderGenerator 0 0 0 1 292 0 0 2 293 294 0 0 1 0 408 0 0 0 0 1069
/**
 * The ShaderGenerator is a device that effectively replaces the classic fixed
 * function pipeline with a 'next-gen' fixed function pipeline.  The next-gen
 * fixed function pipeline supports features like normal mapping, gloss
 * mapping, cartoon lighting, and so forth.  It works by automatically
 * generating a shader from a given RenderState.
 *
 * Currently, there is one ShaderGenerator object per GraphicsStateGuardian.
 * It is our intent that in time, people will write classes that derive from
 * ShaderGenerator but which yield slightly different results.
 *
 * The ShaderGenerator owes its existence to the 'Bamboo Team' at Carnegie
 * Mellon's Entertainment Technology Center.  This is a group of students who,
 * as a semester project, decided that next-gen graphics should be accessible
 * to everyone, even if they don't know shader programming.  The group
 * consisted of:
 *
 * Aaron Lo, Programmer Heegun Lee, Programmer Erin Fernandez, Artist/Tester
 * Joe Grubb, Artist/Tester Ivan Ortega, Technical Artist/Tester
 *
 * Thanks to them!
 *
 */

408 19 TypedReferenceCount 0 2049 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

409 11 SphereLight 0 141313 11 SphereLight 11 SphereLight 0 0 0 1 295 299 1 528 3 296 297 298 0 0 1 0 400 0 0 0 0 154
/**
 * A sphere light is like a point light, except that it represents a sphere
 * with a radius, rather than being an infinitely thin point in space.
 */

410 9 Spotlight 0 141313 9 Spotlight 9 Spotlight 0 0 0 1 300 312 4 529 530 531 532 11 301 302 303 304 305 306 307 308 309 310 311 0 0 1 0 375 0 0 0 0 390
/**
 * A light originating from a single point in space, and shining in a
 * particular direction, with a cone-shaped falloff.
 *
 * The Spotlight frustum is defined using a Lens, so it can have any of the
 * properties that a camera lens can have.
 *
 * Note that the class is named Spotlight instead of SpotLight, because
 * "spotlight" is a single English word, instead of two words.
 */

411 10 SwitchNode 0 141313 10 SwitchNode 10 SwitchNode 0 0 0 1 313 317 1 533 3 314 315 316 0 0 1 0 404 0 0 0 0 95
/**
 * A node that renders only one of its children, according to the user's
 * indication.
 */

412 12 UvScrollNode 0 141313 12 UvScrollNode 12 UvScrollNode 0 0 0 1 318 328 4 534 535 536 537 9 319 320 321 322 323 324 325 326 327 0 0 1 0 366 0 0 0 0 83
/**
 * This node is placed at key points within the scene graph to animate uvs.
 */

413 18 SceneGraphAnalyzer 0 26625 18 SceneGraphAnalyzer 18 SceneGraphAnalyzer 0 0 0 1 329 330 0 33 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 0 0 0 0 1 414 103
/**
 * A handy class that can scrub over a scene graph and collect interesting
 * statistics on it.
 */

414 7 LodMode 0 794624 27 SceneGraphAnalyzer::LodMode 27 SceneGraphAnalyzer::LodMode 413 0 0 0 0 0 0 0 0 0 4 9 LM_lowest 29 SceneGraphAnalyzer::LM_lowest 0
0 10 LM_highest 30 SceneGraphAnalyzer::LM_highest 0
1 6 LM_all 26 SceneGraphAnalyzer::LM_all 0
2 7 LM_none 27 SceneGraphAnalyzer::LM_none 0
3 0 0

415 17 LightNode const * 0 8576 17 LightNode const * 17 LightNode const * 0 0 416 0 0 0 0 0 0 0 0 0 0

416 15 LightNode const 0 8832 15 LightNode const 15 LightNode const 0 0 364 0 0 0 0 0 0 0 0 0 0

417 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 418 0 0 0 0 0 0 0 0 0 0

418 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

419 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

420 10 TypeHandle 0 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

421 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 420 0 0 0 0 0 0 0 0 0 0

422 11 LightNode * 0 8576 11 LightNode * 11 LightNode * 0 0 364 0 0 0 0 0 0 0 0 0 0

423 7 Light * 0 8576 7 Light * 7 Light * 0 0 365 0 0 0 0 0 0 0 0 0 0

424 11 PandaNode * 0 8576 11 PandaNode * 11 PandaNode * 0 0 366 0 0 0 0 0 0 0 0 0 0

425 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

426 14 AmbientLight * 0 8576 14 AmbientLight * 14 AmbientLight * 0 0 367 0 0 0 0 0 0 0 0 0 0

427 14 CallbackNode * 0 8576 14 CallbackNode * 14 CallbackNode * 0 0 368 0 0 0 0 0 0 0 0 0 0

428 20 CallbackNode const * 0 8576 20 CallbackNode const * 20 CallbackNode const * 0 0 429 0 0 0 0 0 0 0 0 0 0

429 18 CallbackNode const 0 8832 18 CallbackNode const 18 CallbackNode const 0 0 368 0 0 0 0 0 0 0 0 0 0

430 13 ComputeNode * 0 8576 13 ComputeNode * 13 ComputeNode * 0 0 371 0 0 0 0 0 0 0 0 0 0

431 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 372 0 0 0 0 0 0 0 0 0 0

432 19 ComputeNode const * 0 8576 19 ComputeNode const * 19 ComputeNode const * 0 0 433 0 0 0 0 0 0 0 0 0 0

433 17 ComputeNode const 0 8832 17 ComputeNode const 17 ComputeNode const 0 0 371 0 0 0 0 0 0 0 0 0 0

434 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 435 0 0 0 0 0 0 0 0 0 0

435 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0

436 15 LightLensNode * 0 8576 15 LightLensNode * 15 LightLensNode * 0 0 375 0 0 0 0 0 0 0 0 0 0

437 21 LightLensNode const * 0 8576 21 LightLensNode const * 21 LightLensNode const * 0 0 438 0 0 0 0 0 0 0 0 0 0

438 19 LightLensNode const 0 8832 19 LightLensNode const 19 LightLensNode const 0 0 375 0 0 0 0 0 0 0 0 0 0

439 12 LVecBase2i * 0 8576 12 LVecBase2i * 12 LVecBase2i * 0 0 378 0 0 0 0 0 0 0 0 0 0

440 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 441 0 0 0 0 0 0 0 0 0 0

441 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 378 0 0 0 0 0 0 0 0 0 0

442 18 GraphicsOutputBase 0 2048 18 GraphicsOutputBase 18 GraphicsOutputBase 0 0 0 0 0 0 0 0 0 0 0 0 80
/**
 * An abstract base class for GraphicsOutput, for all the usual reasons.
 */

443 27 GraphicsStateGuardianBase * 0 8576 27 GraphicsStateGuardianBase * 27 GraphicsStateGuardianBase * 0 0 444 0 0 0 0 0 0 0 0 0 0

444 25 GraphicsStateGuardianBase 0 2048 25 GraphicsStateGuardianBase 25 GraphicsStateGuardianBase 0 0 0 0 0 0 0 0 0 0 0 0 607
/**
 * This is a base class for the GraphicsStateGuardian class, which is itself a
 * base class for the various GSG's for different platforms.  This class
 * contains all the function prototypes to support the double-dispatch of GSG
 * to geoms, transitions, etc.  It lives in a separate class in its own
 * package so we can avoid circular build dependency problems.
 *
 * GraphicsStateGuardians are not actually writable to bam files, of course,
 * but they may be passed as event parameters, so they inherit from
 * TypedWritableReferenceCount instead of TypedReferenceCount for that
 * convenience.
 */

445 20 GraphicsOutputBase * 0 8576 20 GraphicsOutputBase * 20 GraphicsOutputBase * 0 0 442 0 0 0 0 0 0 0 0 0 0

446 8 Camera * 0 8576 8 Camera * 8 Camera * 0 0 376 0 0 0 0 0 0 0 0 0 0

447 18 DirectionalLight * 0 8576 18 DirectionalLight * 18 DirectionalLight * 0 0 379 0 0 0 0 0 0 0 0 0 0

448 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 380 0 0 0 0 0 0 0 0 0 0

449 24 DirectionalLight const * 0 8576 24 DirectionalLight const * 24 DirectionalLight const * 0 0 450 0 0 0 0 0 0 0 0 0 0

450 22 DirectionalLight const 0 8832 22 DirectionalLight const 22 DirectionalLight const 0 0 379 0 0 0 0 0 0 0 0 0 0

451 15 LPoint3 const * 0 8576 15 LPoint3 const * 15 LPoint3 const * 0 0 384 0 0 0 0 0 0 0 0 0 0

452 16 LVector3 const * 0 8576 16 LVector3 const * 16 LVector3 const * 0 0 387 0 0 0 0 0 0 0 0 0 0

453 9 LODNode * 0 8576 9 LODNode * 9 LODNode * 0 0 390 0 0 0 0 0 0 0 0 0 0

454 15 LODNode const * 0 8576 15 LODNode const * 15 LODNode const * 0 0 455 0 0 0 0 0 0 0 0 0 0

455 13 LODNode const 0 8832 13 LODNode const 13 LODNode const 0 0 390 0 0 0 0 0 0 0 0 0 0

456 13 FadeLODNode * 0 8576 13 FadeLODNode * 13 FadeLODNode * 0 0 394 0 0 0 0 0 0 0 0 0 0

457 19 FadeLODNode const * 0 8576 19 FadeLODNode const * 19 FadeLODNode const * 0 0 458 0 0 0 0 0 0 0 0 0 0

458 17 FadeLODNode const 0 8832 17 FadeLODNode const 17 FadeLODNode const 0 0 394 0 0 0 0 0 0 0 0 0 0

459 28 NodeCullCallbackData const * 0 8576 28 NodeCullCallbackData const * 28 NodeCullCallbackData const * 0 0 460 0 0 0 0 0 0 0 0 0 0

460 26 NodeCullCallbackData const 0 8832 26 NodeCullCallbackData const 26 NodeCullCallbackData const 0 0 398 0 0 0 0 0 0 0 0 0 0

461 22 NodeCullCallbackData * 0 8576 22 NodeCullCallbackData * 22 NodeCullCallbackData * 0 0 398 0 0 0 0 0 0 0 0 0 0

462 13 CullTraverser 0 2048 13 CullTraverser 13 CullTraverser 0 0 0 0 0 0 0 0 0 0 0 0 279
/**
 * This object performs a depth-first traversal of the scene graph, with
 * optional view-frustum culling, collecting CullState and searching for
 * GeomNodes.  Each renderable Geom encountered is passed along with its
 * associated RenderState to the CullHandler object.
 */

463 15 CullTraverser * 0 8576 15 CullTraverser * 15 CullTraverser * 0 0 462 0 0 0 0 0 0 0 0 0 0

464 19 CullTraverserData * 0 8576 19 CullTraverserData * 19 CullTraverserData * 0 0 465 0 0 0 0 0 0 0 0 0 0

465 17 CullTraverserData 0 2048 17 CullTraverserData 17 CullTraverserData 0 0 0 0 0 0 0 0 0 0 0 0 464
/**
 * This collects together the pieces of data that are accumulated for each
 * node while walking the scene graph during the cull traversal.
 *
 * Having this as a separate object simplifies the parameter list to
 * CullTraverser::r_traverse(), as well as to other functions like
 * PandaNode::cull_callback().  It also makes it easier to add cull
 * parameters, and provides a place to abstract out some of the cull behavior
 * (like view-frustum culling).
 */

466 12 PointLight * 0 8576 12 PointLight * 12 PointLight * 0 0 400 0 0 0 0 0 0 0 0 0 0

467 17 LVecBase3 const * 0 8576 17 LVecBase3 const * 17 LVecBase3 const * 0 0 401 0 0 0 0 0 0 0 0 0 0

468 18 PointLight const * 0 8576 18 PointLight const * 18 PointLight const * 0 0 469 0 0 0 0 0 0 0 0 0 0

469 16 PointLight const 0 8832 16 PointLight const 16 PointLight const 0 0 400 0 0 0 0 0 0 0 0 0 0

470 20 SelectiveChildNode * 0 8576 20 SelectiveChildNode * 20 SelectiveChildNode * 0 0 404 0 0 0 0 0 0 0 0 0 0

471 14 SequenceNode * 0 8576 14 SequenceNode * 14 SequenceNode * 0 0 405 0 0 0 0 0 0 0 0 0 0

472 20 SequenceNode const * 0 8576 20 SequenceNode const * 20 SequenceNode const * 0 0 473 0 0 0 0 0 0 0 0 0 0

473 18 SequenceNode const 0 8832 18 SequenceNode const 18 SequenceNode const 0 0 405 0 0 0 0 0 0 0 0 0 0

474 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

475 15 AnimInterface * 0 8576 15 AnimInterface * 15 AnimInterface * 0 0 406 0 0 0 0 0 0 0 0 0 0

476 17 ShaderGenerator * 0 8576 17 ShaderGenerator * 17 ShaderGenerator * 0 0 407 0 0 0 0 0 0 0 0 0 0

477 23 ShaderGenerator const * 0 8576 23 ShaderGenerator const * 23 ShaderGenerator const * 0 0 478 0 0 0 0 0 0 0 0 0 0

478 21 ShaderGenerator const 0 8832 21 ShaderGenerator const 21 ShaderGenerator const 0 0 407 0 0 0 0 0 0 0 0 0 0

479 18 ShaderAttrib const 0 8832 18 ShaderAttrib const 18 ShaderAttrib const 0 0 480 0 0 0 0 0 0 0 0 0 0

480 12 ShaderAttrib 0 2048 12 ShaderAttrib 12 ShaderAttrib 0 0 0 0 0 0 0 0 0 0 0 0 10
/**
 *
 */

481 19 RenderState const * 0 8576 19 RenderState const * 19 RenderState const * 0 0 482 0 0 0 0 0 0 0 0 0 0

482 17 RenderState const 0 8832 17 RenderState const 17 RenderState const 0 0 483 0 0 0 0 0 0 0 0 0 0

483 11 RenderState 0 2048 11 RenderState 11 RenderState 0 0 0 0 0 0 0 0 0 0 0 0 340
/**
 * This represents a unique collection of RenderAttrib objects that correspond
 * to a particular renderable state.
 *
 * You should not attempt to create or modify a RenderState object directly.
 * Instead, call one of the make() functions to create one for you.  And
 * instead of modifying a RenderState object, create a new one.
 */

484 31 GeomVertexAnimationSpec const * 0 8576 31 GeomVertexAnimationSpec const * 31 GeomVertexAnimationSpec const * 0 0 485 0 0 0 0 0 0 0 0 0 0

485 29 GeomVertexAnimationSpec const 0 8832 29 GeomVertexAnimationSpec const 29 GeomVertexAnimationSpec const 0 0 486 0 0 0 0 0 0 0 0 0 0

486 23 GeomVertexAnimationSpec 0 2048 23 GeomVertexAnimationSpec 23 GeomVertexAnimationSpec 0 0 0 0 0 0 0 0 0 0 0 0 550
/**
 * This object describes how the vertex animation, if any, represented in a
 * GeomVertexData is encoded.
 *
 * Vertex animation includes soft-skinned skeleton animation and morphs (blend
 * shapes), and might be performed on the CPU by Panda, or passed down to the
 * graphics backed to be performed on the hardware (depending on the
 * hardware's advertised capabilities).
 *
 * Changing this setting doesn't by itself change the way the animation is
 * actually performed; this just specifies how the vertices are set up to be
 * animated.
 */

487 20 ShaderAttrib const * 0 8576 20 ShaderAttrib const * 20 ShaderAttrib const * 0 0 479 0 0 0 0 0 0 0 0 0 0

488 13 SphereLight * 0 8576 13 SphereLight * 13 SphereLight * 0 0 409 0 0 0 0 0 0 0 0 0 0

489 19 SphereLight const * 0 8576 19 SphereLight const * 19 SphereLight const * 0 0 490 0 0 0 0 0 0 0 0 0 0

490 17 SphereLight const 0 8832 17 SphereLight const 17 SphereLight const 0 0 409 0 0 0 0 0 0 0 0 0 0

491 11 Spotlight * 0 8576 11 Spotlight * 11 Spotlight * 0 0 410 0 0 0 0 0 0 0 0 0 0

492 17 Spotlight const * 0 8576 17 Spotlight const * 17 Spotlight const * 0 0 493 0 0 0 0 0 0 0 0 0 0

493 15 Spotlight const 0 8832 15 Spotlight const 15 Spotlight const 0 0 410 0 0 0 0 0 0 0 0 0 0

494 7 Texture 0 2048 7 Texture 7 Texture 0 0 0 0 0 0 0 0 0 0 0 0 688
/**
 * Represents a texture object, which is typically a single 2-d image but may
 * also represent a 1-d or 3-d texture image, or the six 2-d faces of a cube
 * map texture.
 *
 * A texture's image data might be stored in system RAM (see get_ram_image())
 * or its image may be represented in texture memory on one or more
 * GraphicsStateGuardians (see prepare()), or both.  The typical usage pattern
 * is that a texture is loaded from an image file on disk, which copies its
 * image data into system RAM; then the first time the texture is rendered its
 * image data is copied to texture memory (actually, to the graphics API), and
 * the system RAM image is automatically freed.
 */

495 8 LColor * 0 8576 8 LColor * 8 LColor * 0 0 381 0 0 0 0 0 0 0 0 0 0

496 9 Texture * 0 8576 9 Texture * 9 Texture * 0 0 494 0 0 0 0 0 0 0 0 0 0

497 12 SwitchNode * 0 8576 12 SwitchNode * 12 SwitchNode * 0 0 411 0 0 0 0 0 0 0 0 0 0

498 18 SwitchNode const * 0 8576 18 SwitchNode const * 18 SwitchNode const * 0 0 499 0 0 0 0 0 0 0 0 0 0

499 16 SwitchNode const 0 8832 16 SwitchNode const 16 SwitchNode const 0 0 411 0 0 0 0 0 0 0 0 0 0

500 14 UvScrollNode * 0 8576 14 UvScrollNode * 14 UvScrollNode * 0 0 412 0 0 0 0 0 0 0 0 0 0

501 20 UvScrollNode const * 0 8576 20 UvScrollNode const * 20 UvScrollNode const * 0 0 502 0 0 0 0 0 0 0 0 0 0

502 18 UvScrollNode const 0 8832 18 UvScrollNode const 18 UvScrollNode const 0 0 412 0 0 0 0 0 0 0 0 0 0

503 20 SceneGraphAnalyzer * 0 8576 20 SceneGraphAnalyzer * 20 SceneGraphAnalyzer * 0 0 413 0 0 0 0 0 0 0 0 0 0

504 26 SceneGraphAnalyzer const * 0 8576 26 SceneGraphAnalyzer const * 26 SceneGraphAnalyzer const * 0 0 505 0 0 0 0 0 0 0 0 0 0

505 24 SceneGraphAnalyzer const 0 8832 24 SceneGraphAnalyzer const 24 SceneGraphAnalyzer const 0 0 413 0 0 0 0 0 0 0 0 0 0

0
32
506 13 cull_callback 0 6 369 191 189 0 0 0 0 27 CallbackNode::cull_callback 0

507 13 draw_callback 0 6 369 194 192 0 0 0 0 27 CallbackNode::draw_callback 0

508 10 dispatches 0 102 372 200 201 0 0 202 199 23 ComputeNode::dispatches 0

509 13 shadow_caster 0 2 377 211 0 0 0 0 0 28 LightLensNode::shadow_caster 0

510 18 shadow_buffer_size 0 6 378 213 214 0 0 0 0 33 LightLensNode::shadow_buffer_size 0

511 14 specular_color 0 6 380 220 221 0 0 0 0 32 DirectionalLight::specular_color 0

512 5 point 0 6 384 223 224 0 0 0 0 23 DirectionalLight::point 0

513 9 direction 0 6 387 225 226 0 0 0 0 27 DirectionalLight::direction 0

514 3 ins 0 66 391 235 0 0 0 0 234 12 LODNode::ins 0

515 4 outs 0 66 391 236 0 0 0 0 234 13 LODNode::outs 0

516 13 lowest_switch 0 2 393 237 0 0 0 0 0 22 LODNode::lowest_switch 0

517 14 highest_switch 0 2 393 238 0 0 0 0 0 23 LODNode::highest_switch 0

518 9 lod_scale 0 6 391 242 241 0 0 0 0 18 LODNode::lod_scale 0

519 6 center 0 6 384 244 243 0 0 0 0 15 LODNode::center 0

520 9 fade_time 0 6 391 255 254 0 0 0 0 22 FadeLODNode::fade_time 0

521 13 fade_bin_name 0 2 395 257 0 0 0 0 0 26 FadeLODNode::fade_bin_name 0

522 19 fade_bin_draw_order 0 2 393 258 0 0 0 0 0 32 FadeLODNode::fade_bin_draw_order 0

523 19 fade_state_override 0 6 393 260 259 0 0 0 0 32 FadeLODNode::fade_state_override 0

524 14 specular_color 0 6 380 269 270 0 0 0 0 26 PointLight::specular_color 0

525 11 attenuation 0 6 401 272 273 0 0 0 0 23 PointLight::attenuation 0

526 12 max_distance 0 6 391 274 275 0 0 0 0 24 PointLight::max_distance 0

527 5 point 0 6 384 276 277 0 0 0 0 17 PointLight::point 0

528 6 radius 0 6 391 296 297 0 0 0 0 19 SphereLight::radius 0

529 8 exponent 0 6 391 301 302 0 0 0 0 19 Spotlight::exponent 0

530 14 specular_color 0 6 380 303 304 0 0 0 0 25 Spotlight::specular_color 0

531 11 attenuation 0 6 401 306 307 0 0 0 0 22 Spotlight::attenuation 0

532 12 max_distance 0 6 391 308 309 0 0 0 0 23 Spotlight::max_distance 0

533 13 visible_child 0 6 393 315 314 0 0 0 0 25 SwitchNode::visible_child 0

534 7 u_speed 0 6 391 323 319 0 0 0 0 21 UvScrollNode::u_speed 0

535 7 v_speed 0 6 391 324 320 0 0 0 0 21 UvScrollNode::v_speed 0

536 7 w_speed 0 6 391 325 321 0 0 0 0 21 UvScrollNode::w_speed 0

537 7 r_speed 0 6 391 326 322 0 0 0 0 21 UvScrollNode::r_speed 0

3
538 14 get_dispatches 0 199 200 27 ComputeNode::get_dispatches 0

539 7 get_ins 0 234 235 16 LODNode::get_ins 0

540 8 get_outs 0 234 236 17 LODNode::get_outs 0

