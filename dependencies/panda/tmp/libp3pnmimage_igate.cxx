/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/pnmimage -Ipanda/src/pnmimage -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3pnmimage_igate.cxx -od built/pandac/input/libp3pnmimage.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/pnmimage -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/zlib/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3pnmimage config_pnmimage.h convert_srgb.h p3pnmimage_composite1.cxx p3pnmimage_composite2.cxx pfmFile.h pfmFile_ext.h pnmBrush.h pnmFileType.h pnmFileTypeRegistry.h pnmImage.h pnmImageHeader.h pnmPainter.h pnmReader.h pnmWriter.h pnmbitio.h pnmimage_base.h ppmcmap.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3pnmimage
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "config_pnmimage.h"
#include "convert_srgb.h"
#include "dtoolbase.h"
#include "extension.h"
#include "luse.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "pfmFile.h"
#include "pfmFile_ext.h"
#include "pnmBrush.h"
#include "pnmFileType.h"
#include "pnmFileTypeRegistry.h"
#include "pnmImage.h"
#include "pnmImageHeader.h"
#include "pnmPainter.h"
#include "pnmReader.h"
#include "pnmWriter.h"
#include "pnmbitio.h"
#include "pnmimage_base.h"
#include "ppmcmap.h"
#include "py_panda.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class pixel
 */
typedef pixel pixel_localtype;
Define_Module_Class(panda3d.core, pixel, pixel_localtype, pixel);
static struct Dtool_PyTypedObject *const Dtool_Ptr_pixel = &Dtool_pixel;
static void Dtool_PyModuleClassInit_pixel(PyObject *module);
pixel *Dtool_Coerce_pixel(PyObject *args, pixel &coerced);

/**
 * Forward declarations for top-level class PNMFileType
 */
typedef PNMFileType PNMFileType_localtype;
Define_Module_Class(panda3d.core, PNMFileType, PNMFileType_localtype, PNMFileType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMFileType = &Dtool_PNMFileType;
static void Dtool_PyModuleClassInit_PNMFileType(PyObject *module);

/**
 * Forward declarations for top-level class PNMFileTypeRegistry
 */
typedef PNMFileTypeRegistry PNMFileTypeRegistry_localtype;
Define_Module_Class(panda3d.core, PNMFileTypeRegistry, PNMFileTypeRegistry_localtype, PNMFileTypeRegistry);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMFileTypeRegistry = &Dtool_PNMFileTypeRegistry;
static void Dtool_PyModuleClassInit_PNMFileTypeRegistry(PyObject *module);

/**
 * Forward declarations for top-level class PNMImageHeader
 */
typedef PNMImageHeader PNMImageHeader_localtype;
Define_Module_Class(panda3d.core, PNMImageHeader, PNMImageHeader_localtype, PNMImageHeader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMImageHeader = &Dtool_PNMImageHeader;
static void Dtool_PyModuleClassInit_PNMImageHeader(PyObject *module);

/**
 * Forward declarations for top-level class PNMImageHeader_PixelSpec
 */
typedef PNMImageHeader::PixelSpec PNMImageHeader_PixelSpec_localtype;
Define_Module_Class(panda3d.core, PNMImageHeader_PixelSpec, PNMImageHeader_PixelSpec_localtype, PixelSpec);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMImageHeader_PixelSpec = &Dtool_PNMImageHeader_PixelSpec;
static void Dtool_PyModuleClassInit_PNMImageHeader_PixelSpec(PyObject *module);
bool Dtool_ConstCoerce_PNMImageHeader_PixelSpec(PyObject *args, PNMImageHeader::PixelSpec const *&coerced, bool &manage);
bool Dtool_Coerce_PNMImageHeader_PixelSpec(PyObject *args, PNMImageHeader::PixelSpec *&coerced, bool &manage);

/**
 * Forward declarations for top-level class PNMImageHeader_PixelSpecCount
 */
typedef PNMImageHeader::PixelSpecCount PNMImageHeader_PixelSpecCount_localtype;
Define_Module_Class(panda3d.core, PNMImageHeader_PixelSpecCount, PNMImageHeader_PixelSpecCount_localtype, PixelSpecCount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMImageHeader_PixelSpecCount = &Dtool_PNMImageHeader_PixelSpecCount;
static void Dtool_PyModuleClassInit_PNMImageHeader_PixelSpecCount(PyObject *module);

/**
 * Forward declarations for top-level class PNMImageHeader_Histogram
 */
typedef PNMImageHeader::Histogram PNMImageHeader_Histogram_localtype;
Define_Module_Class(panda3d.core, PNMImageHeader_Histogram, PNMImageHeader_Histogram_localtype, Histogram);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMImageHeader_Histogram = &Dtool_PNMImageHeader_Histogram;
static void Dtool_PyModuleClassInit_PNMImageHeader_Histogram(PyObject *module);

/**
 * Forward declarations for top-level class PfmFile
 */
typedef PfmFile PfmFile_localtype;
Define_Module_Class(panda3d.core, PfmFile, PfmFile_localtype, PfmFile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PfmFile = &Dtool_PfmFile;
static void Dtool_PyModuleClassInit_PfmFile(PyObject *module);

/**
 * Forward declarations for top-level class PNMBrush
 */
typedef PNMBrush PNMBrush_localtype;
Define_Module_ClassRef(panda3d.core, PNMBrush, PNMBrush_localtype, PNMBrush);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMBrush = &Dtool_PNMBrush;
static void Dtool_PyModuleClassInit_PNMBrush(PyObject *module);

/**
 * Forward declarations for top-level class PNMImage
 */
typedef PNMImage PNMImage_localtype;
Define_Module_Class(panda3d.core, PNMImage, PNMImage_localtype, PNMImage);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMImage = &Dtool_PNMImage;
static void Dtool_PyModuleClassInit_PNMImage(PyObject *module);

/**
 * Forward declarations for top-level class PNMImage_Row
 */
typedef PNMImage::Row PNMImage_Row_localtype;
Define_Module_Class(panda3d.core, PNMImage_Row, PNMImage_Row_localtype, Row);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMImage_Row = &Dtool_PNMImage_Row;
static void Dtool_PyModuleClassInit_PNMImage_Row(PyObject *module);

/**
 * Forward declarations for top-level class PNMImage_CRow
 */
typedef PNMImage::CRow PNMImage_CRow_localtype;
Define_Module_Class(panda3d.core, PNMImage_CRow, PNMImage_CRow_localtype, CRow);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMImage_CRow = &Dtool_PNMImage_CRow;
static void Dtool_PyModuleClassInit_PNMImage_CRow(PyObject *module);

/**
 * Forward declarations for top-level class PNMPainter
 */
typedef PNMPainter PNMPainter_localtype;
Define_Module_Class(panda3d.core, PNMPainter, PNMPainter_localtype, PNMPainter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMPainter = &Dtool_PNMPainter;
static void Dtool_PyModuleClassInit_PNMPainter(PyObject *module);
bool Dtool_ConstCoerce_PNMPainter(PyObject *args, PNMPainter const *&coerced, bool &manage);
bool Dtool_Coerce_PNMPainter(PyObject *args, PNMPainter *&coerced, bool &manage);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// istream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_istream;
#else
extern struct Dtool_PyTypedObject Dtool_istream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_istream = &Dtool_istream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// Filename
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Filename;
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != NULL, NULL);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != NULL, NULL);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// LVecBase2f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase2f;
inline static LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced) {
  nassertr(Dtool_Ptr_LVecBase2f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase2f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase2f *(*)(PyObject *, LVecBase2f &))Dtool_Ptr_LVecBase2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2f = &Dtool_LVecBase2f;
extern LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced);
#endif
// LPoint4d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint4d;
inline static LPoint4d *Dtool_Coerce_LPoint4d(PyObject *args, LPoint4d &coerced) {
  nassertr(Dtool_Ptr_LPoint4d != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint4d->_Dtool_Coerce != NULL, NULL);
  return ((LPoint4d *(*)(PyObject *, LPoint4d &))Dtool_Ptr_LPoint4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint4d = &Dtool_LPoint4d;
extern LPoint4d *Dtool_Coerce_LPoint4d(PyObject *args, LPoint4d &coerced);
#endif
// LPoint4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint4f;
inline static LPoint4f *Dtool_Coerce_LPoint4f(PyObject *args, LPoint4f &coerced) {
  nassertr(Dtool_Ptr_LPoint4f != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint4f->_Dtool_Coerce != NULL, NULL);
  return ((LPoint4f *(*)(PyObject *, LPoint4f &))Dtool_Ptr_LPoint4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint4f = &Dtool_LPoint4f;
extern LPoint4f *Dtool_Coerce_LPoint4f(PyObject *args, LPoint4f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix4f;
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// LMatrix4d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix4d;
inline static LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced) {
  nassertr(Dtool_Ptr_LMatrix4d != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix4d->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix4d *(*)(PyObject *, LMatrix4d &))Dtool_Ptr_LMatrix4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4d = &Dtool_LMatrix4d;
extern LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced);
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritable;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// LVecBase3d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3d;
inline static LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced) {
  nassertr(Dtool_Ptr_LVecBase3d != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3d->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3d *(*)(PyObject *, LVecBase3d &))Dtool_Ptr_LVecBase3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3d = &Dtool_LVecBase3d;
extern LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced);
#endif
// LPoint2d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint2d;
inline static LPoint2d *Dtool_Coerce_LPoint2d(PyObject *args, LPoint2d &coerced) {
  nassertr(Dtool_Ptr_LPoint2d != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint2d->_Dtool_Coerce != NULL, NULL);
  return ((LPoint2d *(*)(PyObject *, LPoint2d &))Dtool_Ptr_LPoint2d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint2d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2d = &Dtool_LPoint2d;
extern LPoint2d *Dtool_Coerce_LPoint2d(PyObject *args, LPoint2d &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3f;
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LVecBase2i
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase2i;
inline static LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced) {
  nassertr(Dtool_Ptr_LVecBase2i != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase2i->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase2i *(*)(PyObject *, LVecBase2i &))Dtool_Ptr_LVecBase2i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2i = &Dtool_LVecBase2i;
extern LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint3f;
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != NULL, NULL);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LPoint2f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint2f;
inline static LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced) {
  nassertr(Dtool_Ptr_LPoint2f != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint2f->_Dtool_Coerce != NULL, NULL);
  return ((LPoint2f *(*)(PyObject *, LPoint2f &))Dtool_Ptr_LPoint2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2f = &Dtool_LPoint2f;
extern LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced);
#endif
// LVecBase2d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase2d;
inline static LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced) {
  nassertr(Dtool_Ptr_LVecBase2d != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase2d->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase2d *(*)(PyObject *, LVecBase2d &))Dtool_Ptr_LVecBase2d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2d = &Dtool_LVecBase2d;
extern LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4f;
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LVecBase4d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4d;
inline static LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced) {
  nassertr(Dtool_Ptr_LVecBase4d != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4d->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4d *(*)(PyObject *, LVecBase4d &))Dtool_Ptr_LVecBase4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4d = &Dtool_LVecBase4d;
extern LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced);
#endif
// BoundingHexahedron
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_BoundingHexahedron;
inline static bool Dtool_ConstCoerce_BoundingHexahedron(PyObject *args, CPT(BoundingHexahedron) &coerced) {
  nassertr(Dtool_Ptr_BoundingHexahedron != NULL, false);
  nassertr(Dtool_Ptr_BoundingHexahedron->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(BoundingHexahedron) &))Dtool_Ptr_BoundingHexahedron->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_BoundingHexahedron(PyObject *args, PT(BoundingHexahedron) &coerced) {
  nassertr(Dtool_Ptr_BoundingHexahedron != NULL, false);
  nassertr(Dtool_Ptr_BoundingHexahedron->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(BoundingHexahedron) &))Dtool_Ptr_BoundingHexahedron->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_BoundingHexahedron;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingHexahedron = &Dtool_BoundingHexahedron;
extern bool Dtool_ConstCoerce_BoundingHexahedron(PyObject *args, CPT(BoundingHexahedron) &coerced);
extern bool Dtool_Coerce_BoundingHexahedron(PyObject *args, PT(BoundingHexahedron) &coerced);
#endif
// StackedPerlinNoise2
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_StackedPerlinNoise2;
inline static bool Dtool_ConstCoerce_StackedPerlinNoise2(PyObject *args, StackedPerlinNoise2 const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_StackedPerlinNoise2 != NULL, false);
  nassertr(Dtool_Ptr_StackedPerlinNoise2->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, StackedPerlinNoise2 const *&, bool&))Dtool_Ptr_StackedPerlinNoise2->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_StackedPerlinNoise2(PyObject *args, StackedPerlinNoise2 *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_StackedPerlinNoise2 != NULL, false);
  nassertr(Dtool_Ptr_StackedPerlinNoise2->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, StackedPerlinNoise2 *&, bool&))Dtool_Ptr_StackedPerlinNoise2->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_StackedPerlinNoise2;
static struct Dtool_PyTypedObject *const Dtool_Ptr_StackedPerlinNoise2 = &Dtool_StackedPerlinNoise2;
extern bool Dtool_ConstCoerce_StackedPerlinNoise2(PyObject *args, StackedPerlinNoise2 const *&coerced, bool &manage);
extern bool Dtool_Coerce_StackedPerlinNoise2(PyObject *args, StackedPerlinNoise2 *&coerced, bool &manage);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python function wrapper for:
 * inline float decode_sRGB_float(float val)
 * inline float decode_sRGB_float(unsigned char val)
 */
static PyObject *Dtool_decode_sRGB_float_25(PyObject *, PyObject *arg) {
  {
    // -2 inline float decode_sRGB_float(unsigned char val)
    if (PyLongOrInt_Check(arg)) {
      long param0 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param0 < 0 || param0 > UCHAR_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for unsigned byte",
                            param0);
      }
#endif
      float return_value = decode_sRGB_float((unsigned char)param0);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline float decode_sRGB_float(float val)
    if (PyNumber_Check(arg)) {
      float return_value = decode_sRGB_float((float)PyFloat_AsDouble(arg));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline float decode_sRGB_float(unsigned char val)
  // No coercion possible: inline float decode_sRGB_float(float val)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decode_sRGB_float(int val)\n"
      "decode_sRGB_float(float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_decode_sRGB_float_25_comment =
  "C++ Interface:\n"
  "decode_sRGB_float(int val)\n"
  "decode_sRGB_float(float val)\n";
#else
static const char *Dtool_decode_sRGB_float_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline unsigned char decode_sRGB_uchar(float val)
 * inline unsigned char decode_sRGB_uchar(unsigned char val)
 */
static PyObject *Dtool_decode_sRGB_uchar_26(PyObject *, PyObject *arg) {
  {
    // -2 inline unsigned char decode_sRGB_uchar(unsigned char val)
    if (PyLongOrInt_Check(arg)) {
      long param0 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param0 < 0 || param0 > UCHAR_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for unsigned byte",
                            param0);
      }
#endif
      unsigned char return_value = decode_sRGB_uchar((unsigned char)param0);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline unsigned char decode_sRGB_uchar(float val)
    if (PyNumber_Check(arg)) {
      unsigned char return_value = decode_sRGB_uchar((float)PyFloat_AsDouble(arg));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline unsigned char decode_sRGB_uchar(unsigned char val)
  // No coercion possible: inline unsigned char decode_sRGB_uchar(float val)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decode_sRGB_uchar(int val)\n"
      "decode_sRGB_uchar(float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_decode_sRGB_uchar_26_comment =
  "C++ Interface:\n"
  "decode_sRGB_uchar(int val)\n"
  "decode_sRGB_uchar(float val)\n";
#else
static const char *Dtool_decode_sRGB_uchar_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float encode_sRGB_float(float val)
 * inline float encode_sRGB_float(unsigned char val)
 */
static PyObject *Dtool_encode_sRGB_float_27(PyObject *, PyObject *arg) {
  {
    // -2 inline float encode_sRGB_float(unsigned char val)
    if (PyLongOrInt_Check(arg)) {
      long param0 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param0 < 0 || param0 > UCHAR_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for unsigned byte",
                            param0);
      }
#endif
      float return_value = encode_sRGB_float((unsigned char)param0);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline float encode_sRGB_float(float val)
    if (PyNumber_Check(arg)) {
      float return_value = encode_sRGB_float((float)PyFloat_AsDouble(arg));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline float encode_sRGB_float(unsigned char val)
  // No coercion possible: inline float encode_sRGB_float(float val)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "encode_sRGB_float(int val)\n"
      "encode_sRGB_float(float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_encode_sRGB_float_27_comment =
  "C++ Interface:\n"
  "encode_sRGB_float(int val)\n"
  "encode_sRGB_float(float val)\n";
#else
static const char *Dtool_encode_sRGB_float_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline unsigned char encode_sRGB_uchar(float val)
 * inline unsigned char encode_sRGB_uchar(unsigned char val)
 */
static PyObject *Dtool_encode_sRGB_uchar_28(PyObject *, PyObject *arg) {
  {
    // -2 inline unsigned char encode_sRGB_uchar(unsigned char val)
    if (PyLongOrInt_Check(arg)) {
      long param0 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param0 < 0 || param0 > UCHAR_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for unsigned byte",
                            param0);
      }
#endif
      unsigned char return_value = encode_sRGB_uchar((unsigned char)param0);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline unsigned char encode_sRGB_uchar(float val)
    if (PyNumber_Check(arg)) {
      unsigned char return_value = encode_sRGB_uchar((float)PyFloat_AsDouble(arg));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline unsigned char encode_sRGB_uchar(unsigned char val)
  // No coercion possible: inline unsigned char encode_sRGB_uchar(float val)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "encode_sRGB_uchar(int val)\n"
      "encode_sRGB_uchar(float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_encode_sRGB_uchar_28_comment =
  "C++ Interface:\n"
  "encode_sRGB_uchar(int val)\n"
  "encode_sRGB_uchar(float val)\n";
#else
static const char *Dtool_encode_sRGB_uchar_28_comment = NULL;
#endif

/**
 * Python wrappers for functions of class pixel
 */
/**
 * Python function wrapper for:
 * void pixel::output(ostream &out)
 */
static PyObject *Dtool_pixel_output_11(PyObject *self, PyObject *arg) {
  pixel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_pixel, (void **)&local_this, "pixel.output")) {
    return NULL;
  }
  // 1-void pixel::output(ostream &out)
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "pixel.output", false, true);
  if (arg_this != NULL) {
    (*local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(const pixel self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_pixel_output_11_comment =
  "C++ Interface:\n"
  "output(const pixel self, ostream out)\n";
#else
static const char *Dtool_pixel_output_11_comment = NULL;
#endif

static PyObject *Dtool_pixel_b_Getter(PyObject *self, void *) {
  const pixel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_pixel, (void **)&local_this)) {
    return NULL;
  }

  // 1-gray pixel::get_b(void) const
  gray return_value = ((const pixel*)local_this)->b;
  return Dtool_WrapValue(return_value);
}

static int Dtool_pixel_b_Setter(PyObject *self, PyObject *arg, void *) {
  pixel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_pixel, (void **)&local_this, "pixel.b")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete b attribute");
    return -1;
  }
  // 1-void pixel::set_b(gray value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for unsigned short integer",
                   param1);
      return -1;
    }
#endif
    (local_this)->b = (gray)param1;
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_b(const pixel self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_pixel_g_Getter(PyObject *self, void *) {
  const pixel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_pixel, (void **)&local_this)) {
    return NULL;
  }

  // 1-gray pixel::get_g(void) const
  gray return_value = ((const pixel*)local_this)->g;
  return Dtool_WrapValue(return_value);
}

static int Dtool_pixel_g_Setter(PyObject *self, PyObject *arg, void *) {
  pixel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_pixel, (void **)&local_this, "pixel.g")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete g attribute");
    return -1;
  }
  // 1-void pixel::set_g(gray value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for unsigned short integer",
                   param1);
      return -1;
    }
#endif
    (local_this)->g = (gray)param1;
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_g(const pixel self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_pixel_r_Getter(PyObject *self, void *) {
  const pixel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_pixel, (void **)&local_this)) {
    return NULL;
  }

  // 1-gray pixel::get_r(void) const
  gray return_value = ((const pixel*)local_this)->r;
  return Dtool_WrapValue(return_value);
}

static int Dtool_pixel_r_Setter(PyObject *self, PyObject *arg, void *) {
  pixel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_pixel, (void **)&local_this, "pixel.r")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete r attribute");
    return -1;
  }
  // 1-void pixel::set_r(gray value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for unsigned short integer",
                   param1);
      return -1;
    }
#endif
    (local_this)->r = (gray)param1;
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_r(const pixel self, int value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * pixel::pixel(void)
 * pixel::pixel(gray fill)
 * pixel::pixel(gray r, gray g, gray b)
 * inline pixel::pixel(pixel const &) = default
 */
static int Dtool_Init_pixel(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-pixel::pixel(void)
      pixel *return_value = new pixel();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_pixel, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline pixel::pixel(pixel const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:pixel", (char **)keyword_list, &param0)) {
          pixel const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_pixel, (void **)&param0_this);
          if (param0_this != NULL) {
            pixel *return_value = new pixel(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_pixel, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 pixel::pixel(gray fill)
        long param0;
        static const char *keyword_list[] = {"fill", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "l:pixel", (char **)keyword_list, &param0)) {
#ifndef NDEBUG
          if (param0 < 0 || param0 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param0);
            return -1;
          }
#endif
          pixel *return_value = new pixel((gray)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_pixel, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline pixel::pixel(pixel const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:pixel", (char **)keyword_list, &param0)) {
          pixel param0_local;
          pixel const *param0_this = Dtool_Coerce_pixel(param0, param0_local);
          if ((param0_this != NULL)) {
            pixel *return_value = new pixel(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_pixel, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: pixel::pixel(gray fill)
    }
    break;
  case 3:
    {
      // 1-pixel::pixel(gray r, gray g, gray b)
      long param0;
      long param1;
      long param2;
      static const char *keyword_list[] = {"r", "g", "b", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "lll:pixel", (char **)keyword_list, &param0, &param1, &param2)) {
#ifndef NDEBUG
        if (param0 < 0 || param0 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param0);
          return -1;
        }
#endif
#ifndef NDEBUG
        if (param1 < 0 || param1 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param1);
          return -1;
        }
#endif
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param2);
          return -1;
        }
#endif
        pixel *return_value = new pixel((gray)param0, (gray)param1, (gray)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_pixel, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "pixel() takes 0, 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "pixel()\n"
      "pixel(const pixel param0)\n"
      "pixel(int fill)\n"
      "pixel(int r, int g, int b)\n");
  }
  return -1;
}

pixel *Dtool_Coerce_pixel(PyObject *args, pixel &coerced) {
  pixel *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_pixel, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const pixel *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-pixel::pixel(gray fill)
    if (PyLongOrInt_Check(arg)) {
      long param0 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param0 < 0 || param0 > USHRT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for unsigned short integer",
                     param0);
        return NULL;
      }
#endif
      coerced = pixel((gray)param0);
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-pixel::pixel(gray r, gray g, gray b)
      long param0;
      long param1;
      long param2;
      if (PyArg_ParseTuple(args, "lll:pixel", &param0, &param1, &param2)) {
#ifndef NDEBUG
        if (param0 < 0 || param0 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param0);
          return NULL;
        }
#endif
#ifndef NDEBUG
        if (param1 < 0 || param1 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param1);
          return NULL;
        }
#endif
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param2);
          return NULL;
        }
#endif
        coerced = pixel((gray)param0, (gray)param1, (gray)param2);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_pixel(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_pixel) {
    printf("pixel ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  pixel *local_this = (pixel *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_pixel) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_pixel(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_pixel) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PNMFileType
 */
/**
 * Python function wrapper for:
 * virtual std::string PNMFileType::get_name(void) const = 0
 */
static PyObject *Dtool_PNMFileType_get_name_31(PyObject *self, PyObject *) {
  PNMFileType *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileType, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual std::string PNMFileType::get_name(void) const = 0
  std::string return_value = (*(const PNMFileType*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMFileType_get_name_31_comment =
  "C++ Interface:\n"
  "get_name(PNMFileType self)\n";
#else
static const char *Dtool_PNMFileType_get_name_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual int PNMFileType::get_num_extensions(void) const
 */
static PyObject *Dtool_PNMFileType_get_num_extensions_32(PyObject *self, PyObject *) {
  PNMFileType *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileType, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual int PNMFileType::get_num_extensions(void) const
  int return_value = (*(const PNMFileType*)local_this).get_num_extensions();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMFileType_get_num_extensions_32_comment =
  "C++ Interface:\n"
  "get_num_extensions(PNMFileType self)\n"
  "\n"
  "/**\n"
  " * Returns the number of different possible filename extensions associated\n"
  " * with this particular file type.\n"
  " */";
#else
static const char *Dtool_PNMFileType_get_num_extensions_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual std::string PNMFileType::get_extension(int n) const
 */
static PyObject *Dtool_PNMFileType_get_extension_33(PyObject *self, PyObject *arg) {
  PNMFileType *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileType, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual std::string PNMFileType::get_extension(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (*(const PNMFileType*)local_this).get_extension((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_extension(PNMFileType self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMFileType_get_extension_33_comment =
  "C++ Interface:\n"
  "get_extension(PNMFileType self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth possible filename extension associated with this particular\n"
  " * file type, without a leading dot.\n"
  " */";
#else
static const char *Dtool_PNMFileType_get_extension_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual std::string PNMFileType::get_suggested_extension(void) const
 */
static PyObject *Dtool_PNMFileType_get_suggested_extension_35(PyObject *self, PyObject *) {
  PNMFileType *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileType, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual std::string PNMFileType::get_suggested_extension(void) const
  std::string return_value = (*(const PNMFileType*)local_this).get_suggested_extension();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMFileType_get_suggested_extension_35_comment =
  "C++ Interface:\n"
  "get_suggested_extension(PNMFileType self)\n"
  "\n"
  "/**\n"
  " * Returns a suitable filename extension (without a leading dot) to suggest\n"
  " * for files of this type, or empty string if no suggestions are available.\n"
  " */";
#else
static const char *Dtool_PNMFileType_get_suggested_extension_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PNMFileType::get_class_type(void)
 */
static PyObject *Dtool_PNMFileType_get_class_type_41(PyObject *, PyObject *) {
  // 1-static TypeHandle PNMFileType::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PNMFileType::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PNMFileType_get_class_type_41_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PNMFileType_get_class_type_41_comment = NULL;
#endif

static PyObject *Dtool_PNMFileType_name_Getter(PyObject *self, void *) {
  const PNMFileType *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileType, (void **)&local_this)) {
    return NULL;
  }

  // 1-virtual std::string PNMFileType::get_name(void) const = 0
  std::string return_value = (*(const PNMFileType*)local_this).get_name();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * sequence length function for property PNMFileType::extensions
 */
static Py_ssize_t Dtool_PNMFileType_extensions_Len(PyObject *self) {
  PNMFileType *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileType, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_extensions();
}

/**
 * sequence getter for property PNMFileType::extensions
 */
static PyObject *Dtool_PNMFileType_extensions_Getitem(PyObject *self, Py_ssize_t index) {
  PNMFileType *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileType, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_extensions()) {
    PyErr_SetString(PyExc_IndexError, "PNMFileType.extensions[] index out of range");
    return NULL;
  }
  // 1-virtual std::string PNMFileType::get_extension(int n) const
  std::string return_value = (*(const PNMFileType*)local_this).get_extension(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_extension(PNMFileType self, index)\n");
  }
}

static PyObject *Dtool_PNMFileType_extensions_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_PNMFileType_extensions_Len;
  wrap->_getitem_func = &Dtool_PNMFileType_extensions_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

static PyObject *Dtool_PNMFileType_suggested_extension_Getter(PyObject *self, void *) {
  const PNMFileType *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileType, (void **)&local_this)) {
    return NULL;
  }

  // 1-virtual std::string PNMFileType::get_suggested_extension(void) const
  std::string return_value = (*(const PNMFileType*)local_this).get_suggested_extension();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_PNMFileType(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PNMFileType_get_extensions(PyObject *self, PyObject *) {
  PNMFileType *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileType, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_extensions();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PNMFileType_get_extension_33(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PNMFileType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PNMFileType) {
    printf("PNMFileType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PNMFileType *local_this = (PNMFileType *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PNMFileType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PNMFileType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PNMFileType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PNMFileType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PNMFileType*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PNMFileTypeRegistry
 */
/**
 * Python function wrapper for:
 * int PNMFileTypeRegistry::get_num_types(void) const
 */
static PyObject *Dtool_PNMFileTypeRegistry_get_num_types_44(PyObject *self, PyObject *) {
  PNMFileTypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileTypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  // 1-int PNMFileTypeRegistry::get_num_types(void) const
  int return_value = (*(const PNMFileTypeRegistry*)local_this).get_num_types();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMFileTypeRegistry_get_num_types_44_comment =
  "C++ Interface:\n"
  "get_num_types(PNMFileTypeRegistry self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of types registered.\n"
  " */";
#else
static const char *Dtool_PNMFileTypeRegistry_get_num_types_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PNMFileType *PNMFileTypeRegistry::get_type(int n) const
 */
static PyObject *Dtool_PNMFileTypeRegistry_get_type_45(PyObject *self, PyObject *arg) {
  PNMFileTypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileTypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  // 1-PNMFileType *PNMFileTypeRegistry::get_type(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PNMFileType *return_value = (*(const PNMFileTypeRegistry*)local_this).get_type((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PNMFileType, false, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_type(PNMFileTypeRegistry self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMFileTypeRegistry_get_type_45_comment =
  "C++ Interface:\n"
  "get_type(PNMFileTypeRegistry self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth type registered.\n"
  " */";
#else
static const char *Dtool_PNMFileTypeRegistry_get_type_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PNMFileType *PNMFileTypeRegistry::get_type_from_extension(std::string const &filename) const
 */
static PyObject *Dtool_PNMFileTypeRegistry_get_type_from_extension_49(PyObject *self, PyObject *arg) {
  PNMFileTypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileTypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  // 1-PNMFileType *PNMFileTypeRegistry::get_type_from_extension(std::string const &filename) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PNMFileType *return_value = (*(const PNMFileTypeRegistry*)local_this).get_type_from_extension(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PNMFileType, false, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_type_from_extension(PNMFileTypeRegistry self, str filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMFileTypeRegistry_get_type_from_extension_49_comment =
  "C++ Interface:\n"
  "get_type_from_extension(PNMFileTypeRegistry self, str filename)\n"
  "\n"
  "/**\n"
  " * Tries to determine what the PNMFileType is likely to be for a particular\n"
  " * image file based on its extension.  Returns a suitable PNMFileType pointer,\n"
  " * or NULL if no type can be determined.\n"
  " */";
#else
static const char *Dtool_PNMFileTypeRegistry_get_type_from_extension_49_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PNMFileType *PNMFileTypeRegistry::get_type_from_magic_number(std::string const &magic_number) const
 */
static PyObject *Dtool_PNMFileTypeRegistry_get_type_from_magic_number_50(PyObject *self, PyObject *arg) {
  PNMFileTypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileTypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  // 1-PNMFileType *PNMFileTypeRegistry::get_type_from_magic_number(std::string const &magic_number) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PNMFileType *return_value = (*(const PNMFileTypeRegistry*)local_this).get_type_from_magic_number(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PNMFileType, false, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_type_from_magic_number(PNMFileTypeRegistry self, str magic_number)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMFileTypeRegistry_get_type_from_magic_number_50_comment =
  "C++ Interface:\n"
  "get_type_from_magic_number(PNMFileTypeRegistry self, str magic_number)\n"
  "\n"
  "/**\n"
  " * Tries to determine what the PNMFileType is likely to be for a particular\n"
  " * image file based on its magic number, the first two bytes read from the\n"
  " * file.  Returns a suitable PNMFileType pointer, or NULL if no type can be\n"
  " * determined.\n"
  " */";
#else
static const char *Dtool_PNMFileTypeRegistry_get_type_from_magic_number_50_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PNMFileType *PNMFileTypeRegistry::get_type_by_handle(TypeHandle handle) const
 */
static PyObject *Dtool_PNMFileTypeRegistry_get_type_by_handle_51(PyObject *self, PyObject *arg) {
  PNMFileTypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileTypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  // 1-PNMFileType *PNMFileTypeRegistry::get_type_by_handle(TypeHandle handle) const
  TypeHandle arg_local;
  TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PNMFileTypeRegistry.get_type_by_handle", "TypeHandle");
  }
  PNMFileType *return_value = (*(const PNMFileTypeRegistry*)local_this).get_type_by_handle(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PNMFileType, false, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_type_by_handle(PNMFileTypeRegistry self, TypeHandle handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMFileTypeRegistry_get_type_by_handle_51_comment =
  "C++ Interface:\n"
  "get_type_by_handle(PNMFileTypeRegistry self, TypeHandle handle)\n"
  "\n"
  "/**\n"
  " * Returns the PNMFileType instance stored in the registry for the given\n"
  " * TypeHandle, e.g.  as retrieved by a previous call to get_type() on the type\n"
  " * instance.\n"
  " */";
#else
static const char *Dtool_PNMFileTypeRegistry_get_type_by_handle_51_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMFileTypeRegistry::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_PNMFileTypeRegistry_write_52(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMFileTypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileTypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PNMFileTypeRegistry::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "PNMFileTypeRegistry.write", false, true);
    if (param1_this != NULL) {
      (*(const PNMFileTypeRegistry*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(PNMFileTypeRegistry self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMFileTypeRegistry_write_52_comment =
  "C++ Interface:\n"
  "write(PNMFileTypeRegistry self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a list of supported image file types to the indicated output stream,\n"
  " * one per line.\n"
  " */";
#else
static const char *Dtool_PNMFileTypeRegistry_write_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static PNMFileTypeRegistry *PNMFileTypeRegistry::get_global_ptr(void)
 */
static PyObject *Dtool_PNMFileTypeRegistry_get_global_ptr_53(PyObject *, PyObject *) {
  // 1-static PNMFileTypeRegistry *PNMFileTypeRegistry::get_global_ptr(void)
  PNMFileTypeRegistry *return_value = PNMFileTypeRegistry::get_global_ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMFileTypeRegistry, false, false);
}

#ifndef NDEBUG
static const char *Dtool_PNMFileTypeRegistry_get_global_ptr_53_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the global PNMFileTypeRegistry object.\n"
  " */";
#else
static const char *Dtool_PNMFileTypeRegistry_get_global_ptr_53_comment = NULL;
#endif

/**
 * sequence length function for property PNMFileTypeRegistry::types
 */
static Py_ssize_t Dtool_PNMFileTypeRegistry_types_Len(PyObject *self) {
  PNMFileTypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileTypeRegistry, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_types();
}

/**
 * sequence getter for property PNMFileTypeRegistry::types
 */
static PyObject *Dtool_PNMFileTypeRegistry_types_Getitem(PyObject *self, Py_ssize_t index) {
  PNMFileTypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileTypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_types()) {
    PyErr_SetString(PyExc_IndexError, "PNMFileTypeRegistry.types[] index out of range");
    return NULL;
  }
  // 1-PNMFileType *PNMFileTypeRegistry::get_type(int n) const
  PNMFileType *return_value = (*(const PNMFileTypeRegistry*)local_this).get_type(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PNMFileType, false, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_type(PNMFileTypeRegistry self, index)\n");
  }
}

static PyObject *Dtool_PNMFileTypeRegistry_types_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_PNMFileTypeRegistry_types_Len;
  wrap->_getitem_func = &Dtool_PNMFileTypeRegistry_types_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline PNMFileTypeRegistry::PNMFileTypeRegistry(PNMFileTypeRegistry const &) = default
 */
static int Dtool_Init_PNMFileTypeRegistry(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PNMFileTypeRegistry() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline PNMFileTypeRegistry::PNMFileTypeRegistry(PNMFileTypeRegistry const &) = default
  PNMFileTypeRegistry const *arg_this = (PNMFileTypeRegistry *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMFileTypeRegistry, 0, "PNMFileTypeRegistry.PNMFileTypeRegistry", true, true);
  if (arg_this != NULL) {
    PNMFileTypeRegistry *return_value = new PNMFileTypeRegistry(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMFileTypeRegistry, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PNMFileTypeRegistry(const PNMFileTypeRegistry param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PNMFileTypeRegistry_get_types(PyObject *self, PyObject *) {
  PNMFileTypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileTypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_types();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PNMFileTypeRegistry_get_type_45(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PNMFileTypeRegistry(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PNMFileTypeRegistry) {
    printf("PNMFileTypeRegistry ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PNMFileTypeRegistry *local_this = (PNMFileTypeRegistry *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PNMFileTypeRegistry) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PNMFileTypeRegistry(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PNMFileTypeRegistry) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PNMImageHeader
 */
/**
 * Python function wrapper for:
 * inline void PNMImageHeader::operator =(PNMImageHeader const &copy)
 */
static PyObject *Dtool_PNMImageHeader_operator_57(PyObject *self, PyObject *arg) {
  PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImageHeader, (void **)&local_this, "PNMImageHeader.assign")) {
    return NULL;
  }
  // 1-inline void PNMImageHeader::operator =(PNMImageHeader const &copy)
  PNMImageHeader const *arg_this = (PNMImageHeader *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImageHeader, 1, "PNMImageHeader.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    PNMImageHeader *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImageHeader, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PNMImageHeader self, const PNMImageHeader copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_operator_57_comment =
  "C++ Interface:\n"
  "assign(const PNMImageHeader self, const PNMImageHeader copy)\n";
#else
static const char *Dtool_PNMImageHeader_operator_57_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PNMImageHeader::ColorType PNMImageHeader::get_color_type(void) const
 */
static PyObject *Dtool_PNMImageHeader_get_color_type_60(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PNMImageHeader::ColorType PNMImageHeader::get_color_type(void) const
  PNMImageHeader::ColorType return_value = (*(const PNMImageHeader*)local_this).get_color_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_get_color_type_60_comment =
  "C++ Interface:\n"
  "get_color_type(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * Returns the image type of the image, as an enumerated value.  This is\n"
  " * really just the number of channels cast to the enumerated type.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_get_color_type_60_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PNMImageHeader::get_num_channels(void) const
 */
static PyObject *Dtool_PNMImageHeader_get_num_channels_61(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PNMImageHeader::get_num_channels(void) const
  int return_value = (*(const PNMImageHeader*)local_this).get_num_channels();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_get_num_channels_61_comment =
  "C++ Interface:\n"
  "get_num_channels(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * Returns the number of channels in the image.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_get_num_channels_61_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PNMImageHeader::is_grayscale(void) const
 * static inline bool PNMImageHeader::is_grayscale(PNMImageHeader::ColorType color_type)
 */
static PyObject *Dtool_PNMImageHeader_is_grayscale_64(PyObject *self, PyObject *args) {
  PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool PNMImageHeader::is_grayscale(void) const
      bool return_value = (*(const PNMImageHeader*)local_this).is_grayscale();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-static inline bool PNMImageHeader::is_grayscale(PNMImageHeader::ColorType color_type)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        bool return_value = PNMImageHeader::is_grayscale((PNMImageHeader::ColorType)arg_val);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "is_grayscale() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_grayscale(PNMImageHeader self)\n"
      "is_grayscale(int color_type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_is_grayscale_64_comment =
  "C++ Interface:\n"
  "is_grayscale(PNMImageHeader self)\n"
  "is_grayscale(int color_type)\n"
  "\n"
  "/**\n"
  " * This static variant of is_grayscale() returns true if the indicated image\n"
  " * type represents a grayscale image, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns false if the image is a full-color image, and has red, green, and\n"
  " * blue components; true if it is a grayscale image and has only a gray\n"
  " * component.  (The gray color is actually stored in the blue channel, and the\n"
  " * red and green channels are ignored.)\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_is_grayscale_64_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PNMImageHeader::has_alpha(void) const
 * static inline bool PNMImageHeader::has_alpha(PNMImageHeader::ColorType color_type)
 */
static PyObject *Dtool_PNMImageHeader_has_alpha_65(PyObject *self, PyObject *args) {
  PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool PNMImageHeader::has_alpha(void) const
      bool return_value = (*(const PNMImageHeader*)local_this).has_alpha();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-static inline bool PNMImageHeader::has_alpha(PNMImageHeader::ColorType color_type)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        bool return_value = PNMImageHeader::has_alpha((PNMImageHeader::ColorType)arg_val);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "has_alpha() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_alpha(PNMImageHeader self)\n"
      "has_alpha(int color_type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_has_alpha_65_comment =
  "C++ Interface:\n"
  "has_alpha(PNMImageHeader self)\n"
  "has_alpha(int color_type)\n"
  "\n"
  "/**\n"
  " * This static variant of has_alpha() returns true if the indicated image type\n"
  " * includes an alpha channel, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the image includes an alpha channel, false otherwise.\n"
  " * Unlike is_grayscale(), if this returns false it is an error to call any of\n"
  " * the functions accessing the alpha channel.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_has_alpha_65_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImageHeader::get_maxval(void) const
 */
static PyObject *Dtool_PNMImageHeader_get_maxval_66(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline xelval PNMImageHeader::get_maxval(void) const
  xelval return_value = (*(const PNMImageHeader*)local_this).get_maxval();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_get_maxval_66_comment =
  "C++ Interface:\n"
  "get_maxval(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum channel value allowable for any pixel in this image;\n"
  " * for instance, 255 for a typical 8-bit-per-channel image.  A pixel with this\n"
  " * value is full on.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_get_maxval_66_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ColorSpace PNMImageHeader::get_color_space(void) const
 */
static PyObject *Dtool_PNMImageHeader_get_color_space_67(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ColorSpace PNMImageHeader::get_color_space(void) const
  ColorSpace return_value = (*(const PNMImageHeader*)local_this).get_color_space();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_get_color_space_67_comment =
  "C++ Interface:\n"
  "get_color_space(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * Returns the color space that the image is encoded in, or CS_unspecified if\n"
  " * unknown.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_get_color_space_67_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PNMImageHeader::get_x_size(void) const
 */
static PyObject *Dtool_PNMImageHeader_get_x_size_72(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PNMImageHeader::get_x_size(void) const
  int return_value = (*(const PNMImageHeader*)local_this).get_x_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_get_x_size_72_comment =
  "C++ Interface:\n"
  "get_x_size(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * Returns the number of pixels in the X direction.  This is one more than the\n"
  " * largest allowable X coordinate.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_get_x_size_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PNMImageHeader::get_y_size(void) const
 */
static PyObject *Dtool_PNMImageHeader_get_y_size_73(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PNMImageHeader::get_y_size(void) const
  int return_value = (*(const PNMImageHeader*)local_this).get_y_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_get_y_size_73_comment =
  "C++ Interface:\n"
  "get_y_size(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * Returns the number of pixels in the Y direction.  This is one more than the\n"
  " * largest allowable Y coordinate.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_get_y_size_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i PNMImageHeader::get_size(void) const
 */
static PyObject *Dtool_PNMImageHeader_get_size_74(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2i PNMImageHeader::get_size(void) const
  LVecBase2i *return_value = new LVecBase2i((*(const PNMImageHeader*)local_this).get_size());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_get_size_74_comment =
  "C++ Interface:\n"
  "get_size(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * Returns the number of pixels in each direction.  This is one more than the\n"
  " * largest allowable coordinates.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_get_size_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PNMImageHeader::get_comment(void) const
 */
static PyObject *Dtool_PNMImageHeader_get_comment_77(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PNMImageHeader::get_comment(void) const
  std::string return_value = (*(const PNMImageHeader*)local_this).get_comment();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_get_comment_77_comment =
  "C++ Interface:\n"
  "get_comment(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * Gets the user comment from the file.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_get_comment_77_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImageHeader::set_comment(std::string const &comment)
 */
static PyObject *Dtool_PNMImageHeader_set_comment_78(PyObject *self, PyObject *arg) {
  PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImageHeader, (void **)&local_this, "PNMImageHeader.set_comment")) {
    return NULL;
  }
  // 1-inline void PNMImageHeader::set_comment(std::string const &comment)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_comment(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_comment(const PNMImageHeader self, str comment)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_set_comment_78_comment =
  "C++ Interface:\n"
  "set_comment(const PNMImageHeader self, str comment)\n"
  "\n"
  "/**\n"
  " * Writes a user comment string to the image (header).\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_set_comment_78_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PNMImageHeader::has_type(void) const
 */
static PyObject *Dtool_PNMImageHeader_has_type_80(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PNMImageHeader::has_type(void) const
  bool return_value = (*(const PNMImageHeader*)local_this).has_type();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_has_type_80_comment =
  "C++ Interface:\n"
  "has_type(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * Returns true if the PNMImageHeader knows what type it is, false otherwise.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_has_type_80_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PNMFileType *PNMImageHeader::get_type(void) const
 */
static PyObject *Dtool_PNMImageHeader_get_type_81(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PNMFileType *PNMImageHeader::get_type(void) const
  PNMFileType *return_value = (*(const PNMImageHeader*)local_this).get_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PNMFileType, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_get_type_81_comment =
  "C++ Interface:\n"
  "get_type(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * If the file type is known (e.g.  has_type() returns true), returns its\n"
  " * PNMFileType pointer; otherwise, returns NULL.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_get_type_81_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImageHeader::set_type(PNMFileType *type)
 */
static PyObject *Dtool_PNMImageHeader_set_type_82(PyObject *self, PyObject *arg) {
  PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImageHeader, (void **)&local_this, "PNMImageHeader.set_type")) {
    return NULL;
  }
  // 1-inline void PNMImageHeader::set_type(PNMFileType *type)
  PNMFileType *arg_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMFileType, 1, "PNMImageHeader.set_type", false, true);
  if (arg_this != NULL) {
    (*local_this).set_type(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_type(const PNMImageHeader self, PNMFileType type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_set_type_82_comment =
  "C++ Interface:\n"
  "set_type(const PNMImageHeader self, PNMFileType type)\n"
  "\n"
  "/**\n"
  " * Sets the file type of this PNMImage.  This will be the default type used\n"
  " * when an image is read, if the type cannot be determined by magic number or\n"
  " * inferred by extension, or the type used when the image is written, if the\n"
  " * type cannot be inferred from the filename extension.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_set_type_82_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PNMImageHeader::read_header(Filename const &filename, PNMFileType *type = 0, bool report_unknown_type = true)
 * bool PNMImageHeader::read_header(istream &data, std::string const &filename = string(), PNMFileType *type = 0, bool report_unknown_type = true)
 */
static PyObject *Dtool_PNMImageHeader_read_header_84(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImageHeader, (void **)&local_this, "PNMImageHeader.read_header")) {
    return NULL;
  }
  {
    // -2 bool PNMImageHeader::read_header(istream &data, std::string const &filename = string(), PNMFileType *type = 0, bool report_unknown_type = true)
    PyObject *param1;
    const char *param2_str = "";
    Py_ssize_t param2_len = 0;
    PyObject *param3 = NULL;
    PyObject *param4 = Py_True;
    static const char *keyword_list[] = {"data", "filename", "type", "report_unknown_type", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#OO:read_header", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3, &param4)) {
      istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_istream, 1, "PNMImageHeader.read_header", false, false);
      PNMFileType *param3_this = 0;
      if (param3 != (PyObject *)NULL) {
        param3_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_PNMFileType, 3, "PNMImageHeader.read_header", false, false);
      }
      if (param1_this != NULL && (param3 == NULL || param3_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*local_this).read_header(*param1_this, std::string(param2_str, param2_len), param3_this, (PyObject_IsTrue(param4) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool PNMImageHeader::read_header(istream &data, std::string const &filename = string(), PNMFileType *type = 0, bool report_unknown_type = true)
  {
    // -2 bool PNMImageHeader::read_header(Filename const &filename, PNMFileType *type = 0, bool report_unknown_type = true)
    PyObject *param1;
    PyObject *param2 = NULL;
    PyObject *param3 = Py_True;
    static const char *keyword_list[] = {"filename", "type", "report_unknown_type", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|OO:read_header", (char **)keyword_list, &param1, &param2, &param3)) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      PNMFileType *param2_this = 0;
      if (param2 != (PyObject *)NULL) {
        param2_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PNMFileType, 2, "PNMImageHeader.read_header", false, false);
      }
      if ((param1_this != NULL) && (param2 == NULL || param2_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*local_this).read_header(*param1_this, param2_this, (PyObject_IsTrue(param3) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_header(const PNMImageHeader self, istream data, str filename, PNMFileType type, bool report_unknown_type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_read_header_84_comment =
  "C++ Interface:\n"
  "read_header(const PNMImageHeader self, istream data, str filename, PNMFileType type, bool report_unknown_type)\n"
  "\n"
  "/**\n"
  " * Opens up the image file and tries to read its header information to\n"
  " * determine its size, number of channels, etc.  If successful, updates the\n"
  " * header information and returns true; otherwise, returns false.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Reads the image header information only from the indicated stream.\n"
  " *\n"
  " * The filename is advisory only, and may be used to suggest a type if it has\n"
  " * a known extension.\n"
  " *\n"
  " * If type is non-NULL, it is a suggestion for the type of file it is (and a\n"
  " * non-NULL type will override any magic number test or filename extension\n"
  " * lookup).\n"
  " *\n"
  " * Returns true if successful, false on error.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_read_header_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImageHeader::output(ostream &out) const
 */
static PyObject *Dtool_PNMImageHeader_output_88(PyObject *self, PyObject *arg) {
  PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PNMImageHeader::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PNMImageHeader.output", false, true);
  if (arg_this != NULL) {
    (*(const PNMImageHeader*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PNMImageHeader self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_output_88_comment =
  "C++ Interface:\n"
  "output(PNMImageHeader self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_output_88_comment = NULL;
#endif

static PyObject *Dtool_PNMImageHeader_num_channels_Getter(PyObject *self, void *) {
  const PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int PNMImageHeader::get_num_channels(void) const
  int return_value = (*(const PNMImageHeader*)local_this).get_num_channels();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PNMImageHeader_maxval_Getter(PyObject *self, void *) {
  const PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline xelval PNMImageHeader::get_maxval(void) const
  xelval return_value = (*(const PNMImageHeader*)local_this).get_maxval();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PNMImageHeader_color_space_Getter(PyObject *self, void *) {
  const PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline ColorSpace PNMImageHeader::get_color_space(void) const
  ColorSpace return_value = (*(const PNMImageHeader*)local_this).get_color_space();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PNMImageHeader_size_Getter(PyObject *self, void *) {
  const PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2i PNMImageHeader::get_size(void) const
  LVecBase2i *return_value = new LVecBase2i((*(const PNMImageHeader*)local_this).get_size());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

static PyObject *Dtool_PNMImageHeader_comment_Getter(PyObject *self, void *) {
  const PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string PNMImageHeader::get_comment(void) const
  std::string return_value = (*(const PNMImageHeader*)local_this).get_comment();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PNMImageHeader_comment_Setter(PyObject *self, PyObject *arg, void *) {
  PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImageHeader, (void **)&local_this, "PNMImageHeader.comment")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete comment attribute");
    return -1;
  }
  // 1-inline void PNMImageHeader::set_comment(std::string const &comment)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_comment(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_comment(const PNMImageHeader self, str comment)\n");
  }
  return -1;
}

static PyObject *Dtool_PNMImageHeader_type_Getter(PyObject *self, void *) {
  const PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_type()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PNMFileType *PNMImageHeader::get_type(void) const
  PNMFileType *return_value = (*(const PNMImageHeader*)local_this).get_type();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PNMFileType, false, false, return_value->as_typed_object()->get_type_index());
  }
}

/**
 * Python function wrapper for:
 * inline PNMImageHeader::PNMImageHeader(void)
 * inline PNMImageHeader::PNMImageHeader(PNMImageHeader const &copy)
 */
static int Dtool_Init_PNMImageHeader(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PNMImageHeader::PNMImageHeader(void)
      PNMImageHeader *return_value = new PNMImageHeader();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-inline PNMImageHeader::PNMImageHeader(PNMImageHeader const &copy)
      PNMImageHeader const *arg_this = (PNMImageHeader *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImageHeader, 0, "PNMImageHeader.PNMImageHeader", true, true);
      if (arg_this != NULL) {
        PNMImageHeader *return_value = new PNMImageHeader(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PNMImageHeader() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PNMImageHeader()\n"
      "PNMImageHeader(const PNMImageHeader copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PNMImageHeader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PNMImageHeader) {
    printf("PNMImageHeader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PNMImageHeader *local_this = (PNMImageHeader *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PNMImageHeader) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PNMImageHeader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PNMImageHeader) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PNMImageHeader::PixelSpec
 */
/**
 * Python function wrapper for:
 * inline void PNMImageHeader::PixelSpec::operator =(PNMImageHeader::PixelSpec const &copy)
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_operator_91(PyObject *self, PyObject *arg) {
  PNMImageHeader::PixelSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this, "PNMImageHeader::PixelSpec.assign")) {
    return NULL;
  }
  // 1-inline void PNMImageHeader::PixelSpec::operator =(PNMImageHeader::PixelSpec const &copy)
  PNMImageHeader::PixelSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_PNMImageHeader_PixelSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PixelSpec.assign", "PixelSpec");
  }
  (*local_this).operator =(*arg_this);
  PNMImageHeader::PixelSpec *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImageHeader_PixelSpec, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PixelSpec self, const PixelSpec copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_operator_91_comment =
  "C++ Interface:\n"
  "assign(const PixelSpec self, const PixelSpec copy)\n";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_operator_91_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PNMImageHeader::PixelSpec::compare_to(PNMImageHeader::PixelSpec const &other) const
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_compare_to_95(PyObject *self, PyObject *arg) {
  PNMImageHeader::PixelSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PNMImageHeader::PixelSpec::compare_to(PNMImageHeader::PixelSpec const &other) const
  PNMImageHeader::PixelSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_PNMImageHeader_PixelSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PixelSpec.compare_to", "PixelSpec");
  }
  int return_value = (*(const PNMImageHeader::PixelSpec*)local_this).compare_to(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(PixelSpec self, const PixelSpec other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_compare_to_95_comment =
  "C++ Interface:\n"
  "compare_to(PixelSpec self, const PixelSpec other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_compare_to_95_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImageHeader::PixelSpec::get_red(void) const
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_get_red_96(PyObject *self, PyObject *) {
  PNMImageHeader::PixelSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline xelval PNMImageHeader::PixelSpec::get_red(void) const
  xelval return_value = (*(const PNMImageHeader::PixelSpec*)local_this).get_red();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_get_red_96_comment =
  "C++ Interface:\n"
  "get_red(PixelSpec self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_get_red_96_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImageHeader::PixelSpec::get_green(void) const
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_get_green_97(PyObject *self, PyObject *) {
  PNMImageHeader::PixelSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline xelval PNMImageHeader::PixelSpec::get_green(void) const
  xelval return_value = (*(const PNMImageHeader::PixelSpec*)local_this).get_green();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_get_green_97_comment =
  "C++ Interface:\n"
  "get_green(PixelSpec self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_get_green_97_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImageHeader::PixelSpec::get_blue(void) const
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_get_blue_98(PyObject *self, PyObject *) {
  PNMImageHeader::PixelSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline xelval PNMImageHeader::PixelSpec::get_blue(void) const
  xelval return_value = (*(const PNMImageHeader::PixelSpec*)local_this).get_blue();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_get_blue_98_comment =
  "C++ Interface:\n"
  "get_blue(PixelSpec self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_get_blue_98_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImageHeader::PixelSpec::get_alpha(void) const
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_get_alpha_99(PyObject *self, PyObject *) {
  PNMImageHeader::PixelSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline xelval PNMImageHeader::PixelSpec::get_alpha(void) const
  xelval return_value = (*(const PNMImageHeader::PixelSpec*)local_this).get_alpha();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_get_alpha_99_comment =
  "C++ Interface:\n"
  "get_alpha(PixelSpec self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_get_alpha_99_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImageHeader::PixelSpec::set_red(xelval red)
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_set_red_100(PyObject *self, PyObject *arg) {
  PNMImageHeader::PixelSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this, "PNMImageHeader::PixelSpec.set_red")) {
    return NULL;
  }
  // 1-inline void PNMImageHeader::PixelSpec::set_red(xelval red)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    (*local_this).set_red((xelval)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_red(const PixelSpec self, int red)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_set_red_100_comment =
  "C++ Interface:\n"
  "set_red(const PixelSpec self, int red)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_set_red_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImageHeader::PixelSpec::set_green(xelval green)
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_set_green_101(PyObject *self, PyObject *arg) {
  PNMImageHeader::PixelSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this, "PNMImageHeader::PixelSpec.set_green")) {
    return NULL;
  }
  // 1-inline void PNMImageHeader::PixelSpec::set_green(xelval green)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    (*local_this).set_green((xelval)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_green(const PixelSpec self, int green)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_set_green_101_comment =
  "C++ Interface:\n"
  "set_green(const PixelSpec self, int green)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_set_green_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImageHeader::PixelSpec::set_blue(xelval blue)
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_set_blue_102(PyObject *self, PyObject *arg) {
  PNMImageHeader::PixelSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this, "PNMImageHeader::PixelSpec.set_blue")) {
    return NULL;
  }
  // 1-inline void PNMImageHeader::PixelSpec::set_blue(xelval blue)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    (*local_this).set_blue((xelval)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blue(const PixelSpec self, int blue)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_set_blue_102_comment =
  "C++ Interface:\n"
  "set_blue(const PixelSpec self, int blue)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_set_blue_102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImageHeader::PixelSpec::set_alpha(xelval alpha)
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_set_alpha_103(PyObject *self, PyObject *arg) {
  PNMImageHeader::PixelSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this, "PNMImageHeader::PixelSpec.set_alpha")) {
    return NULL;
  }
  // 1-inline void PNMImageHeader::PixelSpec::set_alpha(xelval alpha)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    (*local_this).set_alpha((xelval)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha(const PixelSpec self, int alpha)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_set_alpha_103_comment =
  "C++ Interface:\n"
  "set_alpha(const PixelSpec self, int alpha)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_set_alpha_103_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImageHeader::PixelSpec::output(ostream &out) const
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_output_106(PyObject *self, PyObject *arg) {
  PNMImageHeader::PixelSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PNMImageHeader::PixelSpec::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PixelSpec.output", false, true);
  if (arg_this != NULL) {
    (*(const PNMImageHeader::PixelSpec*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PixelSpec self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_output_106_comment =
  "C++ Interface:\n"
  "output(PixelSpec self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_output_106_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PNMImageHeader::PixelSpec::PixelSpec(PNMImageHeader::PixelSpec const &copy)
 * inline PNMImageHeader::PixelSpec::PixelSpec(xel const &rgb)
 * inline PNMImageHeader::PixelSpec::PixelSpec(xel const &rgb, xelval alpha)
 * inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value)
 * inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value, xelval alpha)
 * inline PNMImageHeader::PixelSpec::PixelSpec(xelval red, xelval green, xelval blue)
 * inline PNMImageHeader::PixelSpec::PixelSpec(xelval red, xelval green, xelval blue, xelval alpha)
 */
static int Dtool_Init_PNMImageHeader_PixelSpec(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline PNMImageHeader::PixelSpec::PixelSpec(PNMImageHeader::PixelSpec const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PixelSpec", (char **)keyword_list, &param0)) {
          PNMImageHeader::PixelSpec const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PNMImageHeader_PixelSpec, (void **)&param0_this);
          if (param0_this != NULL) {
            PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xel const &rgb)
        PyObject *param0;
        static const char *keyword_list[] = {"rgb", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PixelSpec", (char **)keyword_list, &param0)) {
          xel const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_pixel, (void **)&param0_this);
          if (param0_this != NULL) {
            PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value)
        long param0;
        static const char *keyword_list[] = {"gray_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "l:PixelSpec", (char **)keyword_list, &param0)) {
#ifndef NDEBUG
          if (param0 < 0 || param0 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param0);
            return -1;
          }
#endif
          PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec((xelval)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline PNMImageHeader::PixelSpec::PixelSpec(PNMImageHeader::PixelSpec const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PixelSpec", (char **)keyword_list, &param0)) {
          PNMImageHeader::PixelSpec const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_PNMImageHeader_PixelSpec(param0, param0_this, param0_manage)) {
            PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xel const &rgb)
        PyObject *param0;
        static const char *keyword_list[] = {"rgb", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PixelSpec", (char **)keyword_list, &param0)) {
          pixel param0_local;
          xel const *param0_this = Dtool_Coerce_pixel(param0, param0_local);
          if ((param0_this != NULL)) {
            PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value)
    }
    break;
  case 2:
    {
      {
        // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xel const &rgb, xelval alpha)
        PyObject *param0;
        long param1;
        static const char *keyword_list[] = {"rgb", "alpha", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Ol:PixelSpec", (char **)keyword_list, &param0, &param1)) {
          xel const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_pixel, (void **)&param0_this);
#ifndef NDEBUG
          if (param1 < 0 || param1 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param1);
            return -1;
          }
#endif
          if (param0_this != NULL) {
            PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(*param0_this, (xelval)param1);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value, xelval alpha)
        long param0;
        long param1;
        static const char *keyword_list[] = {"gray_value", "alpha", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "ll:PixelSpec", (char **)keyword_list, &param0, &param1)) {
#ifndef NDEBUG
          if (param0 < 0 || param0 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param0);
            return -1;
          }
#endif
#ifndef NDEBUG
          if (param1 < 0 || param1 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param1);
            return -1;
          }
#endif
          PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec((xelval)param0, (xelval)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xel const &rgb, xelval alpha)
        PyObject *param0;
        long param1;
        static const char *keyword_list[] = {"rgb", "alpha", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Ol:PixelSpec", (char **)keyword_list, &param0, &param1)) {
          pixel param0_local;
          xel const *param0_this = Dtool_Coerce_pixel(param0, param0_local);
#ifndef NDEBUG
          if (param1 < 0 || param1 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param1);
            return -1;
          }
#endif
          if ((param0_this != NULL)) {
            PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(*param0_this, (xelval)param1);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value, xelval alpha)
    }
    break;
  case 3:
    {
      // 1-inline PNMImageHeader::PixelSpec::PixelSpec(xelval red, xelval green, xelval blue)
      long param0;
      long param1;
      long param2;
      static const char *keyword_list[] = {"red", "green", "blue", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "lll:PixelSpec", (char **)keyword_list, &param0, &param1, &param2)) {
#ifndef NDEBUG
        if (param0 < 0 || param0 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param0);
          return -1;
        }
#endif
#ifndef NDEBUG
        if (param1 < 0 || param1 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param1);
          return -1;
        }
#endif
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param2);
          return -1;
        }
#endif
        PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec((xelval)param0, (xelval)param1, (xelval)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline PNMImageHeader::PixelSpec::PixelSpec(xelval red, xelval green, xelval blue, xelval alpha)
      long param0;
      long param1;
      long param2;
      long param3;
      static const char *keyword_list[] = {"red", "green", "blue", "alpha", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "llll:PixelSpec", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
#ifndef NDEBUG
        if (param0 < 0 || param0 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param0);
          return -1;
        }
#endif
#ifndef NDEBUG
        if (param1 < 0 || param1 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param1);
          return -1;
        }
#endif
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param2);
          return -1;
        }
#endif
#ifndef NDEBUG
        if (param3 < 0 || param3 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param3);
          return -1;
        }
#endif
        PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec((xelval)param0, (xelval)param1, (xelval)param2, (xelval)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PixelSpec() takes 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PixelSpec(const PixelSpec copy)\n"
      "PixelSpec(const pixel rgb)\n"
      "PixelSpec(int gray_value)\n"
      "PixelSpec(const pixel rgb, int alpha)\n"
      "PixelSpec(int gray_value, int alpha)\n"
      "PixelSpec(int red, int green, int blue)\n"
      "PixelSpec(int red, int green, int blue, int alpha)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PNMImageHeader_PixelSpec(PyObject *args, PNMImageHeader::PixelSpec const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PNMImageHeader_PixelSpec, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xel const &rgb)
      xel const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_pixel, (void **)&arg_this);
      if (arg_this != NULL) {
        PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

    {
      // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value)
      if (PyLongOrInt_Check(arg)) {
        long param0 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
        if (param0 < 0 || param0 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param0);
          return false;
        }
#endif
        PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec((xelval)param0);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        {
          // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xel const &rgb, xelval alpha)
          PyObject *param0;
          long param1;
          if (PyArg_ParseTuple(args, "Ol:PixelSpec", &param0, &param1)) {
            xel const *param0_this;
            DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_pixel, (void **)&param0_this);
#ifndef NDEBUG
            if (param1 < 0 || param1 > USHRT_MAX) {
              PyErr_Format(PyExc_OverflowError,
                           "value %ld out of range for unsigned short integer",
                           param1);
              return false;
            }
#endif
            if (param0_this != NULL) {
              PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(*param0_this, (xelval)param1);
              if (return_value == NULL) {
                PyErr_NoMemory();
                return false;
              }
              if (_PyErr_OCCURRED()) {
                delete return_value;
                return false;
              } else {
                coerced = return_value;
                manage = true;
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        {
          // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value, xelval alpha)
          long param0;
          long param1;
          if (PyArg_ParseTuple(args, "ll:PixelSpec", &param0, &param1)) {
#ifndef NDEBUG
            if (param0 < 0 || param0 > USHRT_MAX) {
              PyErr_Format(PyExc_OverflowError,
                           "value %ld out of range for unsigned short integer",
                           param0);
              return false;
            }
#endif
#ifndef NDEBUG
            if (param1 < 0 || param1 > USHRT_MAX) {
              PyErr_Format(PyExc_OverflowError,
                           "value %ld out of range for unsigned short integer",
                           param1);
              return false;
            }
#endif
            PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec((xelval)param0, (xelval)param1);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
          PyErr_Clear();
        }

        break;
      }
      case 3: {
        // 1-inline PNMImageHeader::PixelSpec::PixelSpec(xelval red, xelval green, xelval blue)
        long param0;
        long param1;
        long param2;
        if (PyArg_ParseTuple(args, "lll:PixelSpec", &param0, &param1, &param2)) {
#ifndef NDEBUG
          if (param0 < 0 || param0 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param0);
            return false;
          }
#endif
#ifndef NDEBUG
          if (param1 < 0 || param1 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param1);
            return false;
          }
#endif
#ifndef NDEBUG
          if (param2 < 0 || param2 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param2);
            return false;
          }
#endif
          PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec((xelval)param0, (xelval)param1, (xelval)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline PNMImageHeader::PixelSpec::PixelSpec(xelval red, xelval green, xelval blue, xelval alpha)
        long param0;
        long param1;
        long param2;
        long param3;
        if (PyArg_ParseTuple(args, "llll:PixelSpec", &param0, &param1, &param2, &param3)) {
#ifndef NDEBUG
          if (param0 < 0 || param0 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param0);
            return false;
          }
#endif
#ifndef NDEBUG
          if (param1 < 0 || param1 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param1);
            return false;
          }
#endif
#ifndef NDEBUG
          if (param2 < 0 || param2 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param2);
            return false;
          }
#endif
#ifndef NDEBUG
          if (param3 < 0 || param3 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param3);
            return false;
          }
#endif
          PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec((xelval)param0, (xelval)param1, (xelval)param2, (xelval)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_PNMImageHeader_PixelSpec(PyObject *args, PNMImageHeader::PixelSpec *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PNMImageHeader_PixelSpec, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xel const &rgb)
      xel const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_pixel, (void **)&arg_this);
      if (arg_this != NULL) {
        PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

    {
      // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value)
      if (PyLongOrInt_Check(arg)) {
        long param0 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
        if (param0 < 0 || param0 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param0);
          return false;
        }
#endif
        PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec((xelval)param0);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        {
          // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xel const &rgb, xelval alpha)
          PyObject *param0;
          long param1;
          if (PyArg_ParseTuple(args, "Ol:PixelSpec", &param0, &param1)) {
            xel const *param0_this;
            DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_pixel, (void **)&param0_this);
#ifndef NDEBUG
            if (param1 < 0 || param1 > USHRT_MAX) {
              PyErr_Format(PyExc_OverflowError,
                           "value %ld out of range for unsigned short integer",
                           param1);
              return false;
            }
#endif
            if (param0_this != NULL) {
              PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(*param0_this, (xelval)param1);
              if (return_value == NULL) {
                PyErr_NoMemory();
                return false;
              }
              if (_PyErr_OCCURRED()) {
                delete return_value;
                return false;
              } else {
                coerced = return_value;
                manage = true;
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        {
          // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value, xelval alpha)
          long param0;
          long param1;
          if (PyArg_ParseTuple(args, "ll:PixelSpec", &param0, &param1)) {
#ifndef NDEBUG
            if (param0 < 0 || param0 > USHRT_MAX) {
              PyErr_Format(PyExc_OverflowError,
                           "value %ld out of range for unsigned short integer",
                           param0);
              return false;
            }
#endif
#ifndef NDEBUG
            if (param1 < 0 || param1 > USHRT_MAX) {
              PyErr_Format(PyExc_OverflowError,
                           "value %ld out of range for unsigned short integer",
                           param1);
              return false;
            }
#endif
            PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec((xelval)param0, (xelval)param1);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
          PyErr_Clear();
        }

        break;
      }
      case 3: {
        // 1-inline PNMImageHeader::PixelSpec::PixelSpec(xelval red, xelval green, xelval blue)
        long param0;
        long param1;
        long param2;
        if (PyArg_ParseTuple(args, "lll:PixelSpec", &param0, &param1, &param2)) {
#ifndef NDEBUG
          if (param0 < 0 || param0 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param0);
            return false;
          }
#endif
#ifndef NDEBUG
          if (param1 < 0 || param1 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param1);
            return false;
          }
#endif
#ifndef NDEBUG
          if (param2 < 0 || param2 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param2);
            return false;
          }
#endif
          PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec((xelval)param0, (xelval)param1, (xelval)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline PNMImageHeader::PixelSpec::PixelSpec(xelval red, xelval green, xelval blue, xelval alpha)
        long param0;
        long param1;
        long param2;
        long param3;
        if (PyArg_ParseTuple(args, "llll:PixelSpec", &param0, &param1, &param2, &param3)) {
#ifndef NDEBUG
          if (param0 < 0 || param0 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param0);
            return false;
          }
#endif
#ifndef NDEBUG
          if (param1 < 0 || param1 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param1);
            return false;
          }
#endif
#ifndef NDEBUG
          if (param2 < 0 || param2 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param2);
            return false;
          }
#endif
#ifndef NDEBUG
          if (param3 < 0 || param3 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param3);
            return false;
          }
#endif
          PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec((xelval)param0, (xelval)param1, (xelval)param2, (xelval)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_PNMImageHeader_PixelSpec(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PNMImageHeader_PixelSpec) {
    printf("PNMImageHeader_PixelSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PNMImageHeader::PixelSpec *local_this = (PNMImageHeader::PixelSpec *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PNMImageHeader_PixelSpec) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PNMImageHeader_PixelSpec(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PNMImageHeader_PixelSpec) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PNMImageHeader::PixelSpecCount
 */
/**
 * Python function wrapper for:
 * inline PNMImageHeader::PixelSpecCount::PixelSpecCount(PNMImageHeader::PixelSpecCount const &) = default
 */
static int Dtool_Init_PNMImageHeader_PixelSpecCount(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PixelSpecCount() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline PNMImageHeader::PixelSpecCount::PixelSpecCount(PNMImageHeader::PixelSpecCount const &) = default
  PNMImageHeader::PixelSpecCount const *arg_this = (PNMImageHeader::PixelSpecCount *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImageHeader_PixelSpecCount, 0, "PixelSpecCount.PixelSpecCount", true, true);
  if (arg_this != NULL) {
    PNMImageHeader::PixelSpecCount *return_value = new PNMImageHeader::PixelSpecCount(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpecCount, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PixelSpecCount(const PixelSpecCount param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PNMImageHeader_PixelSpecCount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PNMImageHeader_PixelSpecCount) {
    printf("PNMImageHeader_PixelSpecCount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PNMImageHeader::PixelSpecCount *local_this = (PNMImageHeader::PixelSpecCount *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PNMImageHeader_PixelSpecCount) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PNMImageHeader_PixelSpecCount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PNMImageHeader_PixelSpecCount) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PNMImageHeader::Histogram
 */
/**
 * Python function wrapper for:
 * inline int PNMImageHeader::Histogram::get_num_pixels(void) const
 */
static PyObject *Dtool_PNMImageHeader_Histogram_get_num_pixels_119(PyObject *self, PyObject *) {
  PNMImageHeader::Histogram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_Histogram, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PNMImageHeader::Histogram::get_num_pixels(void) const
  int return_value = (*(const PNMImageHeader::Histogram*)local_this).get_num_pixels();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_Histogram_get_num_pixels_119_comment =
  "C++ Interface:\n"
  "get_num_pixels(Histogram self)\n"
  "\n"
  "/**\n"
  " * Returns the number of unique pixel colors in the histogram.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_Histogram_get_num_pixels_119_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PNMImageHeader::PixelSpec const &PNMImageHeader::Histogram::get_pixel(int n) const
 */
static PyObject *Dtool_PNMImageHeader_Histogram_get_pixel_120(PyObject *self, PyObject *arg) {
  PNMImageHeader::Histogram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_Histogram, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PNMImageHeader::PixelSpec const &PNMImageHeader::Histogram::get_pixel(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PNMImageHeader::PixelSpec const *return_value = &((*(const PNMImageHeader::Histogram*)local_this).get_pixel((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImageHeader_PixelSpec, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pixel(Histogram self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_Histogram_get_pixel_120_comment =
  "C++ Interface:\n"
  "get_pixel(Histogram self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth unique pixel color in the histogram.  These are ordered by\n"
  " * default from most common to least common.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_Histogram_get_pixel_120_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PNMImageHeader::Histogram::get_count(PNMImageHeader::PixelSpec const &pixel) const
 * inline int PNMImageHeader::Histogram::get_count(int n) const
 */
static PyObject *Dtool_PNMImageHeader_Histogram_get_count_121(PyObject *self, PyObject *arg) {
  PNMImageHeader::Histogram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_Histogram, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 inline int PNMImageHeader::Histogram::get_count(PNMImageHeader::PixelSpec const &pixel) const
    PNMImageHeader::PixelSpec const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PNMImageHeader_PixelSpec, (void **)&arg_this);
    if (arg_this != NULL) {
      int return_value = (*(const PNMImageHeader::Histogram*)local_this).get_count(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline int PNMImageHeader::Histogram::get_count(int n) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      int return_value = (*(const PNMImageHeader::Histogram*)local_this).get_count((int)arg_val);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline int PNMImageHeader::Histogram::get_count(PNMImageHeader::PixelSpec const &pixel) const
    PNMImageHeader::PixelSpec const *arg_this;
    bool arg_manage = false;
    if (Dtool_ConstCoerce_PNMImageHeader_PixelSpec(arg, arg_this, arg_manage)) {
      int return_value = (*(const PNMImageHeader::Histogram*)local_this).get_count(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline int PNMImageHeader::Histogram::get_count(int n) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_count(Histogram self, const PixelSpec pixel)\n"
      "get_count(Histogram self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_Histogram_get_count_121_comment =
  "C++ Interface:\n"
  "get_count(Histogram self, const PixelSpec pixel)\n"
  "get_count(Histogram self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the number of occurrences in the image of the nth unique pixel\n"
  " * color in the histogram.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the number of occurrences in the image of the indicated pixel\n"
  " * color.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_Histogram_get_count_121_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImageHeader::Histogram::write(ostream &out) const
 */
static PyObject *Dtool_PNMImageHeader_Histogram_write_123(PyObject *self, PyObject *arg) {
  PNMImageHeader::Histogram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_Histogram, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PNMImageHeader::Histogram::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "Histogram.write", false, true);
  if (arg_this != NULL) {
    (*(const PNMImageHeader::Histogram*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(Histogram self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_Histogram_write_123_comment =
  "C++ Interface:\n"
  "write(Histogram self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_Histogram_write_123_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PNMImageHeader::Histogram::Histogram(void)
 * inline PNMImageHeader::Histogram::Histogram(PNMImageHeader::Histogram const &) = default
 */
static int Dtool_Init_PNMImageHeader_Histogram(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PNMImageHeader::Histogram::Histogram(void)
      PNMImageHeader::Histogram *return_value = new PNMImageHeader::Histogram();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_Histogram, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline PNMImageHeader::Histogram::Histogram(PNMImageHeader::Histogram const &) = default
      PNMImageHeader::Histogram const *arg_this = (PNMImageHeader::Histogram *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImageHeader_Histogram, 0, "Histogram.Histogram", true, true);
      if (arg_this != NULL) {
        PNMImageHeader::Histogram *return_value = new PNMImageHeader::Histogram(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_Histogram, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Histogram() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Histogram()\n"
      "Histogram(const Histogram param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PNMImageHeader_Histogram_get_pixels(PyObject *self, PyObject *) {
  PNMImageHeader::Histogram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_Histogram, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_pixels();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PNMImageHeader_Histogram_get_pixel_120(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PNMImageHeader_Histogram(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PNMImageHeader_Histogram) {
    printf("PNMImageHeader_Histogram ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PNMImageHeader::Histogram *local_this = (PNMImageHeader::Histogram *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PNMImageHeader_Histogram) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PNMImageHeader_Histogram(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PNMImageHeader_Histogram) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PfmFile
 */
/**
 * Python function wrapper for:
 * void PfmFile::operator =(PfmFile const &copy)
 */
static PyObject *Dtool_PfmFile_operator_127(PyObject *self, PyObject *arg) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.assign")) {
    return NULL;
  }
  // 1-void PfmFile::operator =(PfmFile const &copy)
  PfmFile const *arg_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PfmFile, 1, "PfmFile.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    PfmFile *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PfmFile, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PfmFile self, const PfmFile copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_operator_127_comment =
  "C++ Interface:\n"
  "assign(const PfmFile self, const PfmFile copy)\n";
#else
static const char *Dtool_PfmFile_operator_127_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::clear(void)
 * void PfmFile::clear(int x_size, int y_size, int num_channels)
 */
static PyObject *Dtool_PfmFile_clear_128(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.clear")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-void PfmFile::clear(void)
      (*local_this).clear();
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-void PfmFile::clear(int x_size, int y_size, int num_channels)
      int param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"x_size", "y_size", "num_channels", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:clear", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).clear((int)param1, (int)param2, (int)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "clear() takes 1 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear(const PfmFile self)\n"
      "clear(const PfmFile self, int x_size, int y_size, int num_channels)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_clear_128_comment =
  "C++ Interface:\n"
  "clear(const PfmFile self)\n"
  "clear(const PfmFile self, int x_size, int y_size, int num_channels)\n"
  "\n"
  "/**\n"
  " * Eliminates all data in the file.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Resets to an empty table with a specific size.  The case of num_channels ==\n"
  " * 0 is allowed only in the case that x_size and y_size are also == 0; and\n"
  " * this makes an empty (and invalid) PfmFile.\n"
  " */";
#else
static const char *Dtool_PfmFile_clear_128_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::read(Filename const &fullpath)
 * Rejected Remap [bool PfmFile::read(PNMReader *reader)]
 * bool PfmFile::read(istream &in, Filename const &fullpath = Filename())
 */
static PyObject *Dtool_PfmFile_read_129(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.read")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 bool PfmFile::read(istream &in, Filename const &fullpath)
        PyObject *param1;
        static const char *keyword_list[] = {"in", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:read", (char **)keyword_list, &param1)) {
          istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_istream, 1, "PfmFile.read", false, false);
          if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (*local_this).read(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool PfmFile::read(Filename const &fullpath)
        PyObject *param1;
        static const char *keyword_list[] = {"fullpath", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:read", (char **)keyword_list, &param1)) {
          Filename const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
          if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (*local_this).read(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool PfmFile::read(istream &in, Filename const &fullpath)
        PyObject *param1;
        static const char *keyword_list[] = {"in", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:read", (char **)keyword_list, &param1)) {
          istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_istream, 1, "PfmFile.read", false, false);
          if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (*local_this).read(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool PfmFile::read(Filename const &fullpath)
        PyObject *param1;
        static const char *keyword_list[] = {"fullpath", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:read", (char **)keyword_list, &param1)) {
          Filename param1_local;
          Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
          if ((param1_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (*local_this).read(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-bool PfmFile::read(istream &in, Filename const &fullpath)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"in", "fullpath", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:read", (char **)keyword_list, &param1, &param2)) {
        istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_istream, 1, "PfmFile.read", false, true);
        Filename param2_local;
        Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "PfmFile.read", "Filename");
        }
        if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          PyThreadState *_save;
          Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          bool return_value = (*local_this).read(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "read() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read(const PfmFile self, istream in)\n"
      "read(const PfmFile self, const Filename fullpath)\n"
      "read(const PfmFile self, istream in, const Filename fullpath)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_read_129_comment =
  "C++ Interface:\n"
  "read(const PfmFile self, istream in)\n"
  "read(const PfmFile self, const Filename fullpath)\n"
  "read(const PfmFile self, istream in, const Filename fullpath)\n"
  "\n"
  "/**\n"
  " * Reads the PFM data from the indicated file, returning true on success,\n"
  " * false on failure.\n"
  " *\n"
  " * This can also handle reading a standard image file supported by PNMImage;\n"
  " * it will be quietly converted to a floating-point type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Reads the PFM data from the indicated stream, returning true on success,\n"
  " * false on failure.\n"
  " *\n"
  " * This can also handle reading a standard image file supported by PNMImage;\n"
  " * it will be quietly converted to a floating-point type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Reads the PFM data using the indicated PNMReader.\n"
  " *\n"
  " * The PNMReader is always deleted upon completion, whether successful or not.\n"
  " */";
#else
static const char *Dtool_PfmFile_read_129_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::write(Filename const &fullpath)
 * Rejected Remap [bool PfmFile::write(PNMWriter *writer)]
 * bool PfmFile::write(ostream &out, Filename const &fullpath = Filename())
 */
static PyObject *Dtool_PfmFile_write_130(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.write")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 bool PfmFile::write(ostream &out, Filename const &fullpath)
        PyObject *param1;
        static const char *keyword_list[] = {"out", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:write", (char **)keyword_list, &param1)) {
          ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "PfmFile.write", false, false);
          if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (*local_this).write(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool PfmFile::write(Filename const &fullpath)
        PyObject *param1;
        static const char *keyword_list[] = {"fullpath", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:write", (char **)keyword_list, &param1)) {
          Filename const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
          if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (*local_this).write(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool PfmFile::write(ostream &out, Filename const &fullpath)
        PyObject *param1;
        static const char *keyword_list[] = {"out", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:write", (char **)keyword_list, &param1)) {
          ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "PfmFile.write", false, false);
          if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (*local_this).write(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool PfmFile::write(Filename const &fullpath)
        PyObject *param1;
        static const char *keyword_list[] = {"fullpath", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:write", (char **)keyword_list, &param1)) {
          Filename param1_local;
          Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
          if ((param1_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (*local_this).write(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-bool PfmFile::write(ostream &out, Filename const &fullpath)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"out", "fullpath", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:write", (char **)keyword_list, &param1, &param2)) {
        ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "PfmFile.write", false, true);
        Filename param2_local;
        Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "PfmFile.write", "Filename");
        }
        if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          PyThreadState *_save;
          Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          bool return_value = (*local_this).write(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "write() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(const PfmFile self, ostream out)\n"
      "write(const PfmFile self, const Filename fullpath)\n"
      "write(const PfmFile self, ostream out, const Filename fullpath)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_write_130_comment =
  "C++ Interface:\n"
  "write(const PfmFile self, ostream out)\n"
  "write(const PfmFile self, const Filename fullpath)\n"
  "write(const PfmFile self, ostream out, const Filename fullpath)\n"
  "\n"
  "/**\n"
  " * Writes the PFM data to the indicated file, returning true on success, false\n"
  " * on failure.\n"
  " *\n"
  " * If the type implied by the filename extension supports floating-point, the\n"
  " * data will be written directly; otherwise, the floating-point data will be\n"
  " * quietly converted to the appropriate integer type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Writes the PFM data to the indicated stream, returning true on success,\n"
  " * false on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Writes the PFM data using the indicated PNMWriter.\n"
  " *\n"
  " * The PNMWriter is always deleted upon completion, whether successful or not.\n"
  " */";
#else
static const char *Dtool_PfmFile_write_130_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::load(PNMImage const &pnmimage)
 */
static PyObject *Dtool_PfmFile_load_131(PyObject *self, PyObject *arg) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.load")) {
    return NULL;
  }
  // 1-bool PfmFile::load(PNMImage const &pnmimage)
  PNMImage const *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 1, "PfmFile.load", true, true);
  if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = (*local_this).load(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load(const PfmFile self, const PNMImage pnmimage)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_load_131_comment =
  "C++ Interface:\n"
  "load(const PfmFile self, const PNMImage pnmimage)\n"
  "\n"
  "/**\n"
  " * Fills the PfmFile with the data from the indicated PNMImage, converted to\n"
  " * floating-point values.\n"
  " */";
#else
static const char *Dtool_PfmFile_load_131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::store(PNMImage &pnmimage) const
 */
static PyObject *Dtool_PfmFile_store_132(PyObject *self, PyObject *arg) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool PfmFile::store(PNMImage &pnmimage) const
  PNMImage *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 1, "PfmFile.store", false, true);
  if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = (*(const PfmFile*)local_this).store(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store(PfmFile self, PNMImage pnmimage)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_store_132_comment =
  "C++ Interface:\n"
  "store(PfmFile self, PNMImage pnmimage)\n"
  "\n"
  "/**\n"
  " * Copies the data to the indicated PNMImage, converting to RGB values.\n"
  " */";
#else
static const char *Dtool_PfmFile_store_132_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::store_mask(PNMImage &pnmimage) const
 * bool PfmFile::store_mask(PNMImage &pnmimage, LVecBase4f const &min_point, LVecBase4f const &max_point) const
 */
static PyObject *Dtool_PfmFile_store_mask_133(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pnmimage");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'pnmimage' (pos 1) not found");
      }
      // 1-bool PfmFile::store_mask(PNMImage &pnmimage) const
      PNMImage *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 1, "PfmFile.store_mask", false, true);
      if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*(const PfmFile*)local_this).store_mask(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-bool PfmFile::store_mask(PNMImage &pnmimage, LVecBase4f const &min_point, LVecBase4f const &max_point) const
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"pnmimage", "min_point", "max_point", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:store_mask", (char **)keyword_list, &param1, &param2, &param3)) {
        PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PfmFile.store_mask", false, true);
        LVecBase4f param2_local;
        LVecBase4f const *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "PfmFile.store_mask", "LVecBase4f");
        }
        LVecBase4f param3_local;
        LVecBase4f const *param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
        if (!(param3_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "PfmFile.store_mask", "LVecBase4f");
        }
        if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          PyThreadState *_save;
          Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          bool return_value = (*(const PfmFile*)local_this).store_mask(*param1_this, *param2_this, *param3_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "store_mask() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store_mask(PfmFile self, PNMImage pnmimage)\n"
      "store_mask(PfmFile self, PNMImage pnmimage, const LVecBase4f min_point, const LVecBase4f max_point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_store_mask_133_comment =
  "C++ Interface:\n"
  "store_mask(PfmFile self, PNMImage pnmimage)\n"
  "store_mask(PfmFile self, PNMImage pnmimage, const LVecBase4f min_point, const LVecBase4f max_point)\n"
  "\n"
  "/**\n"
  " * Stores 1 or 0 values into the indicated PNMImage, according to has_point()\n"
  " * for each pixel.  Each valid point gets a 1 value; each nonexistent point\n"
  " * gets a 0 value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Stores 1 or 0 values into the indicated PNMImage, according to has_point()\n"
  " * for each pixel.  Each valid point gets a 1 value; each nonexistent point\n"
  " * gets a 0 value.\n"
  " *\n"
  " * This flavor of store_mask also checks whether the valid points are within\n"
  " * the specified min/max range.  Any valid points without the condition\n"
  " * min_point[c] <= value[c] <= max_point[c], for any c, are stored with a 0 in\n"
  " * the mask.\n"
  " */";
#else
static const char *Dtool_PfmFile_store_mask_133_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PfmFile::is_valid(void) const
 */
static PyObject *Dtool_PfmFile_is_valid_134(PyObject *self, PyObject *) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PfmFile::is_valid(void) const
  bool return_value = (*(const PfmFile*)local_this).is_valid();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_is_valid_134_comment =
  "C++ Interface:\n"
  "is_valid(PfmFile self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PfmFile_is_valid_134_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_float32 PfmFile::get_scale(void) const
 */
static PyObject *Dtool_PfmFile_get_scale_137(PyObject *self, PyObject *) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_float32 PfmFile::get_scale(void) const
  PN_float32 return_value = (*(const PfmFile*)local_this).get_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_get_scale_137_comment =
  "C++ Interface:\n"
  "get_scale(PfmFile self)\n"
  "\n"
  "/**\n"
  " * The \"scale\" is reported in the pfm header and is probably meaningless.\n"
  " */";
#else
static const char *Dtool_PfmFile_get_scale_137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_scale(PN_float32 scale)
 */
static PyObject *Dtool_PfmFile_set_scale_138(PyObject *self, PyObject *arg) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_scale")) {
    return NULL;
  }
  // 1-inline void PfmFile::set_scale(PN_float32 scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_scale((PN_float32)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale(const PfmFile self, float scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_scale_138_comment =
  "C++ Interface:\n"
  "set_scale(const PfmFile self, float scale)\n"
  "\n"
  "/**\n"
  " * The \"scale\" is reported in the pfm header and is probably meaningless.\n"
  " */";
#else
static const char *Dtool_PfmFile_set_scale_138_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PfmFile::has_point(int x, int y) const
 */
static PyObject *Dtool_PfmFile_has_point_142(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PfmFile::has_point(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_point", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*(const PfmFile*)local_this).has_point((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_point(PfmFile self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_has_point_142_comment =
  "C++ Interface:\n"
  "has_point(PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns true if there is a valid point at x, y.  This always returns true\n"
  " * unless a \"no data\" value has been set, in which case it returns false if\n"
  " * the point at x, y is the \"no data\" value.\n"
  " */";
#else
static const char *Dtool_PfmFile_has_point_142_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_float32 PfmFile::get_channel(int x, int y, int c) const
 */
static PyObject *Dtool_PfmFile_get_channel_143(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_float32 PfmFile::get_channel(int x, int y, int c) const
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"x", "y", "c", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:get_channel", (char **)keyword_list, &param1, &param2, &param3)) {
    PN_float32 return_value = (*(const PfmFile*)local_this).get_channel((int)param1, (int)param2, (int)param3);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_channel(PfmFile self, int x, int y, int c)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_get_channel_143_comment =
  "C++ Interface:\n"
  "get_channel(PfmFile self, int x, int y, int c)\n"
  "\n"
  "/**\n"
  " * Returns the cth channel of the point value at the indicated point.\n"
  " */";
#else
static const char *Dtool_PfmFile_get_channel_143_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_channel(int x, int y, int c, PN_float32 value)
 */
static PyObject *Dtool_PfmFile_set_channel_144(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_channel")) {
    return NULL;
  }
  // 1-inline void PfmFile::set_channel(int x, int y, int c, PN_float32 value)
  int param1;
  int param2;
  int param3;
  float param4;
  static const char *keyword_list[] = {"x", "y", "c", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiif:set_channel", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).set_channel((int)param1, (int)param2, (int)param3, (PN_float32)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_channel(const PfmFile self, int x, int y, int c, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_channel_144_comment =
  "C++ Interface:\n"
  "set_channel(const PfmFile self, int x, int y, int c, float value)\n"
  "\n"
  "/**\n"
  " * Replaces the cth channel of the point value at the indicated point.\n"
  " */";
#else
static const char *Dtool_PfmFile_set_channel_144_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_float32 PfmFile::get_point1(int x, int y) const
 */
static PyObject *Dtool_PfmFile_get_point1_145(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_float32 PfmFile::get_point1(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_point1", (char **)keyword_list, &param1, &param2)) {
    PN_float32 return_value = (*(const PfmFile*)local_this).get_point1((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point1(PfmFile self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_get_point1_145_comment =
  "C++ Interface:\n"
  "get_point1(PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the 1-component point value at the indicated point.\n"
  " */";
#else
static const char *Dtool_PfmFile_get_point1_145_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_point1(int x, int y, PN_float32 point)
 */
static PyObject *Dtool_PfmFile_set_point1_146(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_point1")) {
    return NULL;
  }
  // 1-inline void PfmFile::set_point1(int x, int y, PN_float32 point)
  int param1;
  int param2;
  float param3;
  static const char *keyword_list[] = {"x", "y", "point", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iif:set_point1", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_point1((int)param1, (int)param2, (PN_float32)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point1(const PfmFile self, int x, int y, float point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_point1_146_comment =
  "C++ Interface:\n"
  "set_point1(const PfmFile self, int x, int y, float point)\n"
  "\n"
  "/**\n"
  " * Replaces the 1-component point value at the indicated point.\n"
  " */";
#else
static const char *Dtool_PfmFile_set_point1_146_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2f const &PfmFile::get_point2(int x, int y) const
 */
static PyObject *Dtool_PfmFile_get_point2_147(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2f const &PfmFile::get_point2(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_point2", (char **)keyword_list, &param1, &param2)) {
    LPoint2f const *return_value = &((*(const PfmFile*)local_this).get_point2((int)param1, (int)param2));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point2(PfmFile self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_get_point2_147_comment =
  "C++ Interface:\n"
  "get_point2(PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the 2-component point value at the indicated point.  In a 1-channel\n"
  " * image, the channel value is in the x component.\n"
  " */";
#else
static const char *Dtool_PfmFile_get_point2_147_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_point2(int x, int y, LVecBase2d const &point)
 * inline void PfmFile::set_point2(int x, int y, LVecBase2f const &point)
 */
static PyObject *Dtool_PfmFile_set_point2_148(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_point2")) {
    return NULL;
  }
  {
    // -2 inline void PfmFile::set_point2(int x, int y, LVecBase2d const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point2", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase2d const *param3_this;
      DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase2d, (void **)&param3_this);
      if (param3_this != NULL) {
        (*local_this).set_point2((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point2(int x, int y, LVecBase2f const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point2", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase2f const *param3_this;
      DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase2f, (void **)&param3_this);
      if (param3_this != NULL) {
        (*local_this).set_point2((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point2(int x, int y, LVecBase2d const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point2", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase2d param3_local;
      LVecBase2d const *param3_this = Dtool_Coerce_LVecBase2d(param3, param3_local);
      if ((param3_this != NULL)) {
        (*local_this).set_point2((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point2(int x, int y, LVecBase2f const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point2", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase2f param3_local;
      LVecBase2f const *param3_this = Dtool_Coerce_LVecBase2f(param3, param3_local);
      if ((param3_this != NULL)) {
        (*local_this).set_point2((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point2(const PfmFile self, int x, int y, const LVecBase2d point)\n"
      "set_point2(const PfmFile self, int x, int y, const LVecBase2f point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_point2_148_comment =
  "C++ Interface:\n"
  "set_point2(const PfmFile self, int x, int y, const LVecBase2d point)\n"
  "set_point2(const PfmFile self, int x, int y, const LVecBase2f point)\n"
  "\n"
  "/**\n"
  " * Replaces the 2-component point value at the indicated point.  In a\n"
  " * 1-channel image, the channel value is in the x component.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the 2-component point value at the indicated point.  In a\n"
  " * 1-channel image, the channel value is in the x component.\n"
  " */";
#else
static const char *Dtool_PfmFile_set_point2_148_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2f &PfmFile::modify_point2(int x, int y)
 */
static PyObject *Dtool_PfmFile_modify_point2_149(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.modify_point2")) {
    return NULL;
  }
  // 1-inline LPoint2f &PfmFile::modify_point2(int x, int y)
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:modify_point2", (char **)keyword_list, &param1, &param2)) {
    LPoint2f *return_value = &((*local_this).modify_point2((int)param1, (int)param2));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_point2(const PfmFile self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_modify_point2_149_comment =
  "C++ Interface:\n"
  "modify_point2(const PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable 2-component point value at the indicated point.\n"
  " */";
#else
static const char *Dtool_PfmFile_modify_point2_149_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f const &PfmFile::get_point(int x, int y) const
 */
static PyObject *Dtool_PfmFile_get_point_150(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3f const &PfmFile::get_point(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_point", (char **)keyword_list, &param1, &param2)) {
    LPoint3f const *return_value = &((*(const PfmFile*)local_this).get_point((int)param1, (int)param2));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(PfmFile self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_get_point_150_comment =
  "C++ Interface:\n"
  "get_point(PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the 3-component point value at the indicated point.  In a 1-channel\n"
  " * image, the channel value is in the x component.\n"
  " */";
#else
static const char *Dtool_PfmFile_get_point_150_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_point(int x, int y, LVecBase3d const &point)
 * inline void PfmFile::set_point(int x, int y, LVecBase3f const &point)
 */
static PyObject *Dtool_PfmFile_set_point_151(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_point")) {
    return NULL;
  }
  {
    // -2 inline void PfmFile::set_point(int x, int y, LVecBase3f const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3f const *param3_this;
      DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase3f, (void **)&param3_this);
      if (param3_this != NULL) {
        (*local_this).set_point((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point(int x, int y, LVecBase3d const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3d const *param3_this;
      DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase3d, (void **)&param3_this);
      if (param3_this != NULL) {
        (*local_this).set_point((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point(int x, int y, LVecBase3f const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3f param3_local;
      LVecBase3f const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
      if ((param3_this != NULL)) {
        (*local_this).set_point((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point(int x, int y, LVecBase3d const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3d param3_local;
      LVecBase3d const *param3_this = Dtool_Coerce_LVecBase3d(param3, param3_local);
      if ((param3_this != NULL)) {
        (*local_this).set_point((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point(const PfmFile self, int x, int y, const LVecBase3f point)\n"
      "set_point(const PfmFile self, int x, int y, const LVecBase3d point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_point_151_comment =
  "C++ Interface:\n"
  "set_point(const PfmFile self, int x, int y, const LVecBase3f point)\n"
  "set_point(const PfmFile self, int x, int y, const LVecBase3d point)\n"
  "\n"
  "/**\n"
  " * Replaces the 3-component point value at the indicated point.  In a\n"
  " * 1-channel image, the channel value is in the x component.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the 3-component point value at the indicated point.  In a\n"
  " * 1-channel image, the channel value is in the x component.\n"
  " */";
#else
static const char *Dtool_PfmFile_set_point_151_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f &PfmFile::modify_point(int x, int y)
 */
static PyObject *Dtool_PfmFile_modify_point_152(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.modify_point")) {
    return NULL;
  }
  // 1-inline LPoint3f &PfmFile::modify_point(int x, int y)
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:modify_point", (char **)keyword_list, &param1, &param2)) {
    LPoint3f *return_value = &((*local_this).modify_point((int)param1, (int)param2));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_point(const PfmFile self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_modify_point_152_comment =
  "C++ Interface:\n"
  "modify_point(const PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable 3-component point value at the indicated point.\n"
  " */";
#else
static const char *Dtool_PfmFile_modify_point_152_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f const &PfmFile::get_point3(int x, int y) const
 */
static PyObject *Dtool_PfmFile_get_point3_153(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3f const &PfmFile::get_point3(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_point3", (char **)keyword_list, &param1, &param2)) {
    LPoint3f const *return_value = &((*(const PfmFile*)local_this).get_point3((int)param1, (int)param2));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point3(PfmFile self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_get_point3_153_comment =
  "C++ Interface:\n"
  "get_point3(PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the 3-component point value at the indicated point.  In a 1-channel\n"
  " * image, the channel value is in the x component.\n"
  " */";
#else
static const char *Dtool_PfmFile_get_point3_153_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_point3(int x, int y, LVecBase3d const &point)
 * inline void PfmFile::set_point3(int x, int y, LVecBase3f const &point)
 */
static PyObject *Dtool_PfmFile_set_point3_154(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_point3")) {
    return NULL;
  }
  {
    // -2 inline void PfmFile::set_point3(int x, int y, LVecBase3f const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point3", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3f const *param3_this;
      DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase3f, (void **)&param3_this);
      if (param3_this != NULL) {
        (*local_this).set_point3((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point3(int x, int y, LVecBase3d const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point3", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3d const *param3_this;
      DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase3d, (void **)&param3_this);
      if (param3_this != NULL) {
        (*local_this).set_point3((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point3(int x, int y, LVecBase3f const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point3", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3f param3_local;
      LVecBase3f const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
      if ((param3_this != NULL)) {
        (*local_this).set_point3((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point3(int x, int y, LVecBase3d const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point3", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3d param3_local;
      LVecBase3d const *param3_this = Dtool_Coerce_LVecBase3d(param3, param3_local);
      if ((param3_this != NULL)) {
        (*local_this).set_point3((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point3(const PfmFile self, int x, int y, const LVecBase3f point)\n"
      "set_point3(const PfmFile self, int x, int y, const LVecBase3d point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_point3_154_comment =
  "C++ Interface:\n"
  "set_point3(const PfmFile self, int x, int y, const LVecBase3f point)\n"
  "set_point3(const PfmFile self, int x, int y, const LVecBase3d point)\n"
  "\n"
  "/**\n"
  " * Replaces the 3-component point value at the indicated point.  In a\n"
  " * 1-channel image, the channel value is in the x component.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the 3-component point value at the indicated point.  In a\n"
  " * 1-channel image, the channel value is in the x component.\n"
  " */";
#else
static const char *Dtool_PfmFile_set_point3_154_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f &PfmFile::modify_point3(int x, int y)
 */
static PyObject *Dtool_PfmFile_modify_point3_155(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.modify_point3")) {
    return NULL;
  }
  // 1-inline LPoint3f &PfmFile::modify_point3(int x, int y)
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:modify_point3", (char **)keyword_list, &param1, &param2)) {
    LPoint3f *return_value = &((*local_this).modify_point3((int)param1, (int)param2));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_point3(const PfmFile self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_modify_point3_155_comment =
  "C++ Interface:\n"
  "modify_point3(const PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable 3-component point value at the indicated point.\n"
  " */";
#else
static const char *Dtool_PfmFile_modify_point3_155_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint4f const &PfmFile::get_point4(int x, int y) const
 */
static PyObject *Dtool_PfmFile_get_point4_156(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint4f const &PfmFile::get_point4(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_point4", (char **)keyword_list, &param1, &param2)) {
    LPoint4f const *return_value = &((*(const PfmFile*)local_this).get_point4((int)param1, (int)param2));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point4(PfmFile self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_get_point4_156_comment =
  "C++ Interface:\n"
  "get_point4(PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the 4-component point value at the indicated point.  In a 1-channel\n"
  " * image, the channel value is in the x component.\n"
  " */";
#else
static const char *Dtool_PfmFile_get_point4_156_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_point4(int x, int y, LVecBase4d const &point)
 * inline void PfmFile::set_point4(int x, int y, LVecBase4f const &point)
 */
static PyObject *Dtool_PfmFile_set_point4_157(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_point4")) {
    return NULL;
  }
  {
    // -2 inline void PfmFile::set_point4(int x, int y, LVecBase4f const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point4", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase4f const *param3_this;
      DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase4f, (void **)&param3_this);
      if (param3_this != NULL) {
        (*local_this).set_point4((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point4(int x, int y, LVecBase4d const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point4", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase4d const *param3_this;
      DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase4d, (void **)&param3_this);
      if (param3_this != NULL) {
        (*local_this).set_point4((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point4(int x, int y, LVecBase4f const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point4", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase4f param3_local;
      LVecBase4f const *param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
      if ((param3_this != NULL)) {
        (*local_this).set_point4((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point4(int x, int y, LVecBase4d const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point4", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase4d param3_local;
      LVecBase4d const *param3_this = Dtool_Coerce_LVecBase4d(param3, param3_local);
      if ((param3_this != NULL)) {
        (*local_this).set_point4((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point4(const PfmFile self, int x, int y, const LVecBase4f point)\n"
      "set_point4(const PfmFile self, int x, int y, const LVecBase4d point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_point4_157_comment =
  "C++ Interface:\n"
  "set_point4(const PfmFile self, int x, int y, const LVecBase4f point)\n"
  "set_point4(const PfmFile self, int x, int y, const LVecBase4d point)\n"
  "\n"
  "/**\n"
  " * Replaces the 4-component point value at the indicated point.  In a\n"
  " * 1-channel image, the channel value is in the x component.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the 4-component point value at the indicated point.  In a\n"
  " * 1-channel image, the channel value is in the x component.\n"
  " */";
#else
static const char *Dtool_PfmFile_set_point4_157_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint4f &PfmFile::modify_point4(int x, int y)
 */
static PyObject *Dtool_PfmFile_modify_point4_158(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.modify_point4")) {
    return NULL;
  }
  // 1-inline LPoint4f &PfmFile::modify_point4(int x, int y)
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:modify_point4", (char **)keyword_list, &param1, &param2)) {
    LPoint4f *return_value = &((*local_this).modify_point4((int)param1, (int)param2));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_point4(const PfmFile self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_modify_point4_158_comment =
  "C++ Interface:\n"
  "modify_point4(const PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable 4-component point value at the indicated point.\n"
  " */";
#else
static const char *Dtool_PfmFile_modify_point4_158_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::fill(LPoint2f const &value)
 * inline void PfmFile::fill(LPoint3f const &value)
 * void PfmFile::fill(LPoint4f const &value)
 * inline void PfmFile::fill(PN_float32 value)
 */
static PyObject *Dtool_PfmFile_fill_159(PyObject *self, PyObject *arg) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.fill")) {
    return NULL;
  }
  {
    // -2 inline void PfmFile::fill(LPoint2f const &value)
    LPoint2f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint2f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).fill(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void PfmFile::fill(LPoint3f const &value)
    LPoint3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint3f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).fill(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void PfmFile::fill(LPoint4f const &value)
    LPoint4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint4f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).fill(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void PfmFile::fill(PN_float32 value)
    if (PyNumber_Check(arg)) {
      (*local_this).fill((PN_float32)PyFloat_AsDouble(arg));
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void PfmFile::fill(LPoint2f const &value)
    LPoint2f arg_local;
    LPoint2f const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).fill(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void PfmFile::fill(LPoint3f const &value)
    LPoint3f arg_local;
    LPoint3f const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).fill(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void PfmFile::fill(LPoint4f const &value)
    LPoint4f arg_local;
    LPoint4f const *arg_this = Dtool_Coerce_LPoint4f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).fill(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: inline void PfmFile::fill(PN_float32 value)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill(const PfmFile self, const LPoint2f value)\n"
      "fill(const PfmFile self, const LPoint3f value)\n"
      "fill(const PfmFile self, const LPoint4f value)\n"
      "fill(const PfmFile self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_fill_159_comment =
  "C++ Interface:\n"
  "fill(const PfmFile self, const LPoint2f value)\n"
  "fill(const PfmFile self, const LPoint3f value)\n"
  "fill(const PfmFile self, const LPoint4f value)\n"
  "fill(const PfmFile self, float value)\n"
  "\n"
  "/**\n"
  " * Fills the table with all of the same value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills the table with all of the same value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills the table with all of the same value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills the table with all of the same value.\n"
  " */";
#else
static const char *Dtool_PfmFile_fill_159_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::fill_nan(void)
 */
static PyObject *Dtool_PfmFile_fill_nan_160(PyObject *self, PyObject *) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.fill_nan")) {
    return NULL;
  }
  // 1-void PfmFile::fill_nan(void)
  (*local_this).fill_nan();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_fill_nan_160_comment =
  "C++ Interface:\n"
  "fill_nan(const PfmFile self)\n"
  "\n"
  "/**\n"
  " * Fills the table with all NaN.\n"
  " */";
#else
static const char *Dtool_PfmFile_fill_nan_160_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::fill_no_data_value(void)
 */
static PyObject *Dtool_PfmFile_fill_no_data_value_161(PyObject *self, PyObject *) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.fill_no_data_value")) {
    return NULL;
  }
  // 1-void PfmFile::fill_no_data_value(void)
  (*local_this).fill_no_data_value();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_fill_no_data_value_161_comment =
  "C++ Interface:\n"
  "fill_no_data_value(const PfmFile self)\n"
  "\n"
  "/**\n"
  " * Fills the table with the current no_data value, so that the table is empty.\n"
  " */";
#else
static const char *Dtool_PfmFile_fill_no_data_value_161_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::fill_channel(int channel, PN_float32 value)
 */
static PyObject *Dtool_PfmFile_fill_channel_162(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.fill_channel")) {
    return NULL;
  }
  // 1-void PfmFile::fill_channel(int channel, PN_float32 value)
  int param1;
  float param2;
  static const char *keyword_list[] = {"channel", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:fill_channel", (char **)keyword_list, &param1, &param2)) {
    (*local_this).fill_channel((int)param1, (PN_float32)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill_channel(const PfmFile self, int channel, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_fill_channel_162_comment =
  "C++ Interface:\n"
  "fill_channel(const PfmFile self, int channel, float value)\n"
  "\n"
  "/**\n"
  " * Fills the indicated channel with all of the same value, leaving the other\n"
  " * channels unchanged.\n"
  " */";
#else
static const char *Dtool_PfmFile_fill_channel_162_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::fill_channel_nan(int channel)
 */
static PyObject *Dtool_PfmFile_fill_channel_nan_163(PyObject *self, PyObject *arg) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.fill_channel_nan")) {
    return NULL;
  }
  // 1-void PfmFile::fill_channel_nan(int channel)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).fill_channel_nan((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill_channel_nan(const PfmFile self, int channel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_fill_channel_nan_163_comment =
  "C++ Interface:\n"
  "fill_channel_nan(const PfmFile self, int channel)\n"
  "\n"
  "/**\n"
  " * Fills the indicated channel with NaN, leaving the other channels unchanged.\n"
  " */";
#else
static const char *Dtool_PfmFile_fill_channel_nan_163_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::fill_channel_masked(int channel, PN_float32 value)
 */
static PyObject *Dtool_PfmFile_fill_channel_masked_164(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.fill_channel_masked")) {
    return NULL;
  }
  // 1-void PfmFile::fill_channel_masked(int channel, PN_float32 value)
  int param1;
  float param2;
  static const char *keyword_list[] = {"channel", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:fill_channel_masked", (char **)keyword_list, &param1, &param2)) {
    (*local_this).fill_channel_masked((int)param1, (PN_float32)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill_channel_masked(const PfmFile self, int channel, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_fill_channel_masked_164_comment =
  "C++ Interface:\n"
  "fill_channel_masked(const PfmFile self, int channel, float value)\n"
  "\n"
  "/**\n"
  " * Fills the indicated channel with all of the same value, but only where the\n"
  " * table already has a data point.  Leaves empty points unchanged.\n"
  " */";
#else
static const char *Dtool_PfmFile_fill_channel_masked_164_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::fill_channel_masked_nan(int channel)
 */
static PyObject *Dtool_PfmFile_fill_channel_masked_nan_165(PyObject *self, PyObject *arg) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.fill_channel_masked_nan")) {
    return NULL;
  }
  // 1-void PfmFile::fill_channel_masked_nan(int channel)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).fill_channel_masked_nan((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill_channel_masked_nan(const PfmFile self, int channel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_fill_channel_masked_nan_165_comment =
  "C++ Interface:\n"
  "fill_channel_masked_nan(const PfmFile self, int channel)\n"
  "\n"
  "/**\n"
  " * Fills the indicated channel with NaN, but only where the table already has\n"
  " * a data point.  Leaves empty points unchanged.\n"
  " */";
#else
static const char *Dtool_PfmFile_fill_channel_masked_nan_165_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::calc_average_point(LPoint3f &result, PN_float32 x, PN_float32 y, PN_float32 radius) const
 */
static PyObject *Dtool_PfmFile_calc_average_point_166(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool PfmFile::calc_average_point(LPoint3f &result, PN_float32 x, PN_float32 y, PN_float32 radius) const
  PyObject *param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"result", "x", "y", "radius", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:calc_average_point", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    LPoint3f param1_local;
    LPoint3f *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PfmFile.calc_average_point", "LPoint3f");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = (*(const PfmFile*)local_this).calc_average_point(*param1_this, (PN_float32)param2, (PN_float32)param3, (PN_float32)param4);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_average_point(PfmFile self, LPoint3f result, float x, float y, float radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_calc_average_point_166_comment =
  "C++ Interface:\n"
  "calc_average_point(PfmFile self, LPoint3f result, float x, float y, float radius)\n"
  "\n"
  "/**\n"
  " * Computes the unweighted average point of all points within the box centered\n"
  " * at (x, y) with the indicated Manhattan-distance radius.  Missing points are\n"
  " * assigned the value of their nearest neighbor.  Returns true if successful,\n"
  " * or false if the point value cannot be determined.\n"
  " */";
#else
static const char *Dtool_PfmFile_calc_average_point_166_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::calc_bilinear_point(LPoint3f &result, PN_float32 x, PN_float32 y) const
 */
static PyObject *Dtool_PfmFile_calc_bilinear_point_167(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool PfmFile::calc_bilinear_point(LPoint3f &result, PN_float32 x, PN_float32 y) const
  PyObject *param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"result", "x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:calc_bilinear_point", (char **)keyword_list, &param1, &param2, &param3)) {
    LPoint3f param1_local;
    LPoint3f *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PfmFile.calc_bilinear_point", "LPoint3f");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = (*(const PfmFile*)local_this).calc_bilinear_point(*param1_this, (PN_float32)param2, (PN_float32)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_bilinear_point(PfmFile self, LPoint3f result, float x, float y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_calc_bilinear_point_167_comment =
  "C++ Interface:\n"
  "calc_bilinear_point(PfmFile self, LPoint3f result, float x, float y)\n"
  "\n"
  "/**\n"
  " * Computes the weighted average of the four nearest points to the floating-\n"
  " * point index (x, y).  Returns true if the point has any contributors, false\n"
  " * if the point is unknown.\n"
  " */";
#else
static const char *Dtool_PfmFile_calc_bilinear_point_167_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::calc_min_max(LVecBase3f &min_points, LVecBase3f &max_points) const
 */
static PyObject *Dtool_PfmFile_calc_min_max_168(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool PfmFile::calc_min_max(LVecBase3f &min_points, LVecBase3f &max_points) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"min_points", "max_points", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:calc_min_max", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param1_local;
    LVecBase3f *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PfmFile.calc_min_max", "LVecBase3f");
    }
    LVecBase3f param2_local;
    LVecBase3f *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PfmFile.calc_min_max", "LVecBase3f");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = (*(const PfmFile*)local_this).calc_min_max(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_min_max(PfmFile self, LVecBase3f min_points, LVecBase3f max_points)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_calc_min_max_168_comment =
  "C++ Interface:\n"
  "calc_min_max(PfmFile self, LVecBase3f min_points, LVecBase3f max_points)\n"
  "\n"
  "/**\n"
  " * Calculates the minimum and maximum x, y, and z depth component values,\n"
  " * representing the bounding box of depth values, and places them in the\n"
  " * indicated vectors.  Returns true if successful, false if the mesh contains\n"
  " * no points.\n"
  " */";
#else
static const char *Dtool_PfmFile_calc_min_max_168_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PfmFile::calc_autocrop(LVecBase4d &range) const
 * inline bool PfmFile::calc_autocrop(LVecBase4f &range) const
 */
static PyObject *Dtool_PfmFile_calc_autocrop_169(PyObject *self, PyObject *arg) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 inline bool PfmFile::calc_autocrop(LVecBase4d &range) const
    LVecBase4d *arg_this = (LVecBase4d *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LVecBase4d, 1, "PfmFile.calc_autocrop", false, false);
    if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = (*(const PfmFile*)local_this).calc_autocrop(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool PfmFile::calc_autocrop(LVecBase4f &range) const
    LVecBase4f *arg_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LVecBase4f, 1, "PfmFile.calc_autocrop", false, false);
    if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = (*(const PfmFile*)local_this).calc_autocrop(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool PfmFile::calc_autocrop(LVecBase4d &range) const
    LVecBase4d arg_local;
    LVecBase4d *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
    if ((arg_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = (*(const PfmFile*)local_this).calc_autocrop(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool PfmFile::calc_autocrop(LVecBase4f &range) const
    LVecBase4f arg_local;
    LVecBase4f *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = (*(const PfmFile*)local_this).calc_autocrop(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_autocrop(PfmFile self, LVecBase4d range)\n"
      "calc_autocrop(PfmFile self, LVecBase4f range)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_calc_autocrop_169_comment =
  "C++ Interface:\n"
  "calc_autocrop(PfmFile self, LVecBase4d range)\n"
  "calc_autocrop(PfmFile self, LVecBase4f range)\n"
  "\n"
  "/**\n"
  " * Computes the minimum range of x and y across the PFM file that include all\n"
  " * points.  If there are no points with no_data_value in the grid--that is,\n"
  " * all points are included--then this will return (0, get_x_size(), 0,\n"
  " * get_y_size()).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Computes the minimum range of x and y across the PFM file that include all\n"
  " * points.  If there are no points with no_data_value in the grid--that is,\n"
  " * all points are included--then this will return (0, get_x_size(), 0,\n"
  " * get_y_size()).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Computes the minimum range of x and y across the PFM file that include all\n"
  " * points.  If there are no points with no_data_value in the grid--that is,\n"
  " * all points are included--then this will return (0, get_x_size(), 0,\n"
  " * get_y_size()).\n"
  " */";
#else
static const char *Dtool_PfmFile_calc_autocrop_169_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::is_row_empty(int y, int x_begin, int x_end) const
 */
static PyObject *Dtool_PfmFile_is_row_empty_170(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool PfmFile::is_row_empty(int y, int x_begin, int x_end) const
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"y", "x_begin", "x_end", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:is_row_empty", (char **)keyword_list, &param1, &param2, &param3)) {
    bool return_value = (*(const PfmFile*)local_this).is_row_empty((int)param1, (int)param2, (int)param3);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_row_empty(PfmFile self, int y, int x_begin, int x_end)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_is_row_empty_170_comment =
  "C++ Interface:\n"
  "is_row_empty(PfmFile self, int y, int x_begin, int x_end)\n"
  "\n"
  "/**\n"
  " * Returns true if all of the points on row y, in the range [x_begin, x_end),\n"
  " * are the no_data value, or false if any one of these points has a value.\n"
  " */";
#else
static const char *Dtool_PfmFile_is_row_empty_170_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::is_column_empty(int x, int y_begin, int y_end) const
 */
static PyObject *Dtool_PfmFile_is_column_empty_171(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool PfmFile::is_column_empty(int x, int y_begin, int y_end) const
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"x", "y_begin", "y_end", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:is_column_empty", (char **)keyword_list, &param1, &param2, &param3)) {
    bool return_value = (*(const PfmFile*)local_this).is_column_empty((int)param1, (int)param2, (int)param3);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_column_empty(PfmFile self, int x, int y_begin, int y_end)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_is_column_empty_171_comment =
  "C++ Interface:\n"
  "is_column_empty(PfmFile self, int x, int y_begin, int y_end)\n"
  "\n"
  "/**\n"
  " * Returns true if all of the points on column x, from [y_begin, y_end), are\n"
  " * the no_data value, or false if any one of these points has a value.\n"
  " */";
#else
static const char *Dtool_PfmFile_is_column_empty_171_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_zero_special(bool zero_special)
 */
static PyObject *Dtool_PfmFile_set_zero_special_172(PyObject *self, PyObject *arg) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_zero_special")) {
    return NULL;
  }
  // 1-inline void PfmFile::set_zero_special(bool zero_special)
  (*local_this).set_zero_special((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_zero_special(const PfmFile self, bool zero_special)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_zero_special_172_comment =
  "C++ Interface:\n"
  "set_zero_special(const PfmFile self, bool zero_special)\n"
  "\n"
  "/**\n"
  " * Sets the zero_special flag.  When this flag is true, values of (0, 0, 0) in\n"
  " * the pfm file are treated as a special case, and are not processed.\n"
  " *\n"
  " * This is a special case of set_no_data_value().\n"
  " */";
#else
static const char *Dtool_PfmFile_set_zero_special_172_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_no_data_chan4(bool chan4)
 */
static PyObject *Dtool_PfmFile_set_no_data_chan4_173(PyObject *self, PyObject *arg) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_no_data_chan4")) {
    return NULL;
  }
  // 1-inline void PfmFile::set_no_data_chan4(bool chan4)
  (*local_this).set_no_data_chan4((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_no_data_chan4(const PfmFile self, bool chan4)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_no_data_chan4_173_comment =
  "C++ Interface:\n"
  "set_no_data_chan4(const PfmFile self, bool chan4)\n"
  "\n"
  "/**\n"
  " * Sets the no_data_chan4 flag.  When this flag is true, and the pfm file has\n"
  " * 4 channels, then a negative value in the fourth channel indicates no data.\n"
  " * When it is false, all points are valid.\n"
  " *\n"
  " * This is a special case of set_no_data_value().\n"
  " */";
#else
static const char *Dtool_PfmFile_set_no_data_chan4_173_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::set_no_data_nan(int num_channels)
 */
static PyObject *Dtool_PfmFile_set_no_data_nan_174(PyObject *self, PyObject *arg) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_no_data_nan")) {
    return NULL;
  }
  // 1-void PfmFile::set_no_data_nan(int num_channels)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_no_data_nan((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_no_data_nan(const PfmFile self, int num_channels)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_no_data_nan_174_comment =
  "C++ Interface:\n"
  "set_no_data_nan(const PfmFile self, int num_channels)\n"
  "\n"
  "/**\n"
  " * Sets the no_data_nan flag.  When num_channels is nonzero, then a NaN value\n"
  " * in any of the first num_channels channels indicates no data for that point.\n"
  " * If num_channels is zero, then all points are valid.\n"
  " *\n"
  " * This is a special case of set_no_data_value().\n"
  " */";
#else
static const char *Dtool_PfmFile_set_no_data_nan_174_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_no_data_value(LPoint4d const &no_data_value)
 * void PfmFile::set_no_data_value(LPoint4f const &no_data_value)
 */
static PyObject *Dtool_PfmFile_set_no_data_value_175(PyObject *self, PyObject *arg) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_no_data_value")) {
    return NULL;
  }
  {
    // -2 void PfmFile::set_no_data_value(LPoint4f const &no_data_value)
    LPoint4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint4f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_no_data_value(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void PfmFile::set_no_data_value(LPoint4d const &no_data_value)
    LPoint4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint4d, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_no_data_value(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void PfmFile::set_no_data_value(LPoint4f const &no_data_value)
    LPoint4f arg_local;
    LPoint4f const *arg_this = Dtool_Coerce_LPoint4f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_no_data_value(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void PfmFile::set_no_data_value(LPoint4d const &no_data_value)
    LPoint4d arg_local;
    LPoint4d const *arg_this = Dtool_Coerce_LPoint4d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_no_data_value(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_no_data_value(const PfmFile self, const LPoint4f no_data_value)\n"
      "set_no_data_value(const PfmFile self, const LPoint4d no_data_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_no_data_value_175_comment =
  "C++ Interface:\n"
  "set_no_data_value(const PfmFile self, const LPoint4f no_data_value)\n"
  "set_no_data_value(const PfmFile self, const LPoint4d no_data_value)\n"
  "\n"
  "/**\n"
  " * Sets the special value that means \"no data\" when it appears in the pfm\n"
  " * file.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the special value that means \"no data\" when it appears in the pfm\n"
  " * file.\n"
  " */";
#else
static const char *Dtool_PfmFile_set_no_data_value_175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_no_data_threshold(LPoint4d const &no_data_value)
 * void PfmFile::set_no_data_threshold(LPoint4f const &no_data_value)
 */
static PyObject *Dtool_PfmFile_set_no_data_threshold_176(PyObject *self, PyObject *arg) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_no_data_threshold")) {
    return NULL;
  }
  {
    // -2 inline void PfmFile::set_no_data_threshold(LPoint4d const &no_data_value)
    LPoint4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint4d, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_no_data_threshold(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void PfmFile::set_no_data_threshold(LPoint4f const &no_data_value)
    LPoint4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint4f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_no_data_threshold(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void PfmFile::set_no_data_threshold(LPoint4d const &no_data_value)
    LPoint4d arg_local;
    LPoint4d const *arg_this = Dtool_Coerce_LPoint4d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_no_data_threshold(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void PfmFile::set_no_data_threshold(LPoint4f const &no_data_value)
    LPoint4f arg_local;
    LPoint4f const *arg_this = Dtool_Coerce_LPoint4f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_no_data_threshold(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_no_data_threshold(const PfmFile self, const LPoint4d no_data_value)\n"
      "set_no_data_threshold(const PfmFile self, const LPoint4f no_data_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_no_data_threshold_176_comment =
  "C++ Interface:\n"
  "set_no_data_threshold(const PfmFile self, const LPoint4d no_data_value)\n"
  "set_no_data_threshold(const PfmFile self, const LPoint4f no_data_value)\n"
  "\n"
  "/**\n"
  " * Sets the special threshold value.  Points that are below this value in all\n"
  " * components are considered \"no value\".\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the special threshold value.  Points that are below this value in all\n"
  " * components are considered \"no value\".\n"
  " */";
#else
static const char *Dtool_PfmFile_set_no_data_threshold_176_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::clear_no_data_value(void)
 */
static PyObject *Dtool_PfmFile_clear_no_data_value_177(PyObject *self, PyObject *) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.clear_no_data_value")) {
    return NULL;
  }
  // 1-inline void PfmFile::clear_no_data_value(void)
  (*local_this).clear_no_data_value();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_clear_no_data_value_177_comment =
  "C++ Interface:\n"
  "clear_no_data_value(const PfmFile self)\n"
  "\n"
  "/**\n"
  " * Removes the special value that means \"no data\" when it appears in the pfm\n"
  " * file.  All points will thus be considered valid.\n"
  " */";
#else
static const char *Dtool_PfmFile_clear_no_data_value_177_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PfmFile::has_no_data_value(void) const
 */
static PyObject *Dtool_PfmFile_has_no_data_value_178(PyObject *self, PyObject *) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PfmFile::has_no_data_value(void) const
  bool return_value = (*(const PfmFile*)local_this).has_no_data_value();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_has_no_data_value_178_comment =
  "C++ Interface:\n"
  "has_no_data_value(PfmFile self)\n"
  "\n"
  "/**\n"
  " * Returns whether a \"no data\" value has been established by\n"
  " * set_no_data_value().\n"
  " */";
#else
static const char *Dtool_PfmFile_has_no_data_value_178_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PfmFile::has_no_data_threshold(void) const
 */
static PyObject *Dtool_PfmFile_has_no_data_threshold_179(PyObject *self, PyObject *) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PfmFile::has_no_data_threshold(void) const
  bool return_value = (*(const PfmFile*)local_this).has_no_data_threshold();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_has_no_data_threshold_179_comment =
  "C++ Interface:\n"
  "has_no_data_threshold(PfmFile self)\n"
  "\n"
  "/**\n"
  " * Returns whether a \"no data\" threshold value has been established by\n"
  " * set_no_data_threshold().\n"
  " */";
#else
static const char *Dtool_PfmFile_has_no_data_threshold_179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint4f const &PfmFile::get_no_data_value(void) const
 */
static PyObject *Dtool_PfmFile_get_no_data_value_180(PyObject *self, PyObject *) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint4f const &PfmFile::get_no_data_value(void) const
  LPoint4f const *return_value = &((*(const PfmFile*)local_this).get_no_data_value());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_get_no_data_value_180_comment =
  "C++ Interface:\n"
  "get_no_data_value(PfmFile self)\n"
  "\n"
  "/**\n"
  " * If has_no_data_value() returns true, this returns the particular \"no data\"\n"
  " * value.\n"
  " */";
#else
static const char *Dtool_PfmFile_get_no_data_value_180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::resize(int new_x_size, int new_y_size)
 */
static PyObject *Dtool_PfmFile_resize_181(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.resize")) {
    return NULL;
  }
  // 1-void PfmFile::resize(int new_x_size, int new_y_size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"new_x_size", "new_y_size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:resize", (char **)keyword_list, &param1, &param2)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).resize((int)param1, (int)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "resize(const PfmFile self, int new_x_size, int new_y_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_resize_181_comment =
  "C++ Interface:\n"
  "resize(const PfmFile self, int new_x_size, int new_y_size)\n"
  "\n"
  "/**\n"
  " * Applies a simple filter to resample the pfm file in-place to the indicated\n"
  " * size.  Don't confuse this with applying a scale to all of the points via\n"
  " * xform().\n"
  " */";
#else
static const char *Dtool_PfmFile_resize_181_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::box_filter_from(float radius, PfmFile const &copy)
 */
static PyObject *Dtool_PfmFile_box_filter_from_182(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.box_filter_from")) {
    return NULL;
  }
  // 1-void PfmFile::box_filter_from(float radius, PfmFile const &copy)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"radius", "copy", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:box_filter_from", (char **)keyword_list, &param1, &param2)) {
    PfmFile const *param2_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PfmFile, 2, "PfmFile.box_filter_from", true, true);
    if (param2_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*local_this).box_filter_from((float)param1, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "box_filter_from(const PfmFile self, float radius, const PfmFile copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_box_filter_from_182_comment =
  "C++ Interface:\n"
  "box_filter_from(const PfmFile self, float radius, const PfmFile copy)\n"
  "\n"
  "/**\n"
  " * Makes a resized copy of the indicated image into this one using the\n"
  " * indicated filter.  The image to be copied is squashed and stretched to\n"
  " * match the dimensions of the current image, applying the appropriate filter\n"
  " * to perform the stretching.\n"
  " */";
#else
static const char *Dtool_PfmFile_box_filter_from_182_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::gaussian_filter_from(float radius, PfmFile const &copy)
 */
static PyObject *Dtool_PfmFile_gaussian_filter_from_183(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.gaussian_filter_from")) {
    return NULL;
  }
  // 1-void PfmFile::gaussian_filter_from(float radius, PfmFile const &copy)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"radius", "copy", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:gaussian_filter_from", (char **)keyword_list, &param1, &param2)) {
    PfmFile const *param2_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PfmFile, 2, "PfmFile.gaussian_filter_from", true, true);
    if (param2_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*local_this).gaussian_filter_from((float)param1, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "gaussian_filter_from(const PfmFile self, float radius, const PfmFile copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_gaussian_filter_from_183_comment =
  "C++ Interface:\n"
  "gaussian_filter_from(const PfmFile self, float radius, const PfmFile copy)\n"
  "\n"
  "/**\n"
  " * Makes a resized copy of the indicated image into this one using the\n"
  " * indicated filter.  The image to be copied is squashed and stretched to\n"
  " * match the dimensions of the current image, applying the appropriate filter\n"
  " * to perform the stretching.\n"
  " */";
#else
static const char *Dtool_PfmFile_gaussian_filter_from_183_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::quick_filter_from(PfmFile const &copy)
 */
static PyObject *Dtool_PfmFile_quick_filter_from_184(PyObject *self, PyObject *arg) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.quick_filter_from")) {
    return NULL;
  }
  // 1-void PfmFile::quick_filter_from(PfmFile const &copy)
  PfmFile const *arg_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PfmFile, 1, "PfmFile.quick_filter_from", true, true);
  if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).quick_filter_from(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "quick_filter_from(const PfmFile self, const PfmFile copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_quick_filter_from_184_comment =
  "C++ Interface:\n"
  "quick_filter_from(const PfmFile self, const PfmFile copy)\n"
  "\n"
  "/**\n"
  " * Resizes from the given image, with a fixed radius of 0.5. This is a very\n"
  " * specialized and simple algorithm that doesn't handle dropping below the\n"
  " * Nyquist rate very well, but is quite a bit faster than the more general\n"
  " * box_filter(), above.\n"
  " */";
#else
static const char *Dtool_PfmFile_quick_filter_from_184_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::reverse_rows(void)
 */
static PyObject *Dtool_PfmFile_reverse_rows_185(PyObject *self, PyObject *) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.reverse_rows")) {
    return NULL;
  }
  // 1-void PfmFile::reverse_rows(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).reverse_rows();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_reverse_rows_185_comment =
  "C++ Interface:\n"
  "reverse_rows(const PfmFile self)\n"
  "\n"
  "/**\n"
  " * Performs an in-place reversal of the row (y) data.\n"
  " */";
#else
static const char *Dtool_PfmFile_reverse_rows_185_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::flip(bool flip_x, bool flip_y, bool transpose)
 */
static PyObject *Dtool_PfmFile_flip_186(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.flip")) {
    return NULL;
  }
  // 1-void PfmFile::flip(bool flip_x, bool flip_y, bool transpose)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"flip_x", "flip_y", "transpose", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:flip", (char **)keyword_list, &param1, &param2, &param3)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).flip((PyObject_IsTrue(param1) != 0), (PyObject_IsTrue(param2) != 0), (PyObject_IsTrue(param3) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "flip(const PfmFile self, bool flip_x, bool flip_y, bool transpose)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_flip_186_comment =
  "C++ Interface:\n"
  "flip(const PfmFile self, bool flip_x, bool flip_y, bool transpose)\n"
  "\n"
  "/**\n"
  " * Reverses, transposes, and/or rotates the table in-place according to the\n"
  " * specified parameters.  If flip_x is true, the x axis is reversed; if flip_y\n"
  " * is true, the y axis is reversed.  Then, if transpose is true, the x and y\n"
  " * axes are exchanged.  These parameters can be used to select any combination\n"
  " * of 90-degree or 180-degree rotations and flips.\n"
  " */";
#else
static const char *Dtool_PfmFile_flip_186_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::xform(LMatrix4d const &transform)
 * void PfmFile::xform(LMatrix4f const &transform)
 */
static PyObject *Dtool_PfmFile_xform_187(PyObject *self, PyObject *arg) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.xform")) {
    return NULL;
  }
  {
    // -2 inline void PfmFile::xform(LMatrix4d const &transform)
    LMatrix4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4d, (void **)&arg_this);
    if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*local_this).xform(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }

  {
    // -2 void PfmFile::xform(LMatrix4f const &transform)
    LMatrix4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4f, (void **)&arg_this);
    if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*local_this).xform(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void PfmFile::xform(LMatrix4d const &transform)
    LMatrix4d arg_local;
    LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
    if ((arg_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*local_this).xform(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }

  {
    // -2 void PfmFile::xform(LMatrix4f const &transform)
    LMatrix4f arg_local;
    LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
    if ((arg_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*local_this).xform(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(const PfmFile self, const LMatrix4d transform)\n"
      "xform(const PfmFile self, const LMatrix4f transform)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_xform_187_comment =
  "C++ Interface:\n"
  "xform(const PfmFile self, const LMatrix4d transform)\n"
  "xform(const PfmFile self, const LMatrix4f transform)\n"
  "\n"
  "/**\n"
  " * Applies the indicated transform matrix to all points in-place.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Applies the indicated transform matrix to all points in-place.\n"
  " */";
#else
static const char *Dtool_PfmFile_xform_187_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::forward_distort(PfmFile const &dist, PN_float32 scale_factor = 1.0)
 */
static PyObject *Dtool_PfmFile_forward_distort_188(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.forward_distort")) {
    return NULL;
  }
  // 1-void PfmFile::forward_distort(PfmFile const &dist, PN_float32 scale_factor = 1.0)
  PyObject *param1;
  float param2 = 1.0;
  static const char *keyword_list[] = {"dist", "scale_factor", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|f:forward_distort", (char **)keyword_list, &param1, &param2)) {
    PfmFile const *param1_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PfmFile, 1, "PfmFile.forward_distort", true, true);
    if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*local_this).forward_distort(*param1_this, (PN_float32)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "forward_distort(const PfmFile self, const PfmFile dist, float scale_factor)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_forward_distort_188_comment =
  "C++ Interface:\n"
  "forward_distort(const PfmFile self, const PfmFile dist, float scale_factor)\n"
  "\n"
  "/**\n"
  " * Applies the distortion indicated in the supplied dist map to the current\n"
  " * map.  The dist map is understood to be a mapping of points in the range\n"
  " * 0..1 in the first two dimensions.\n"
  " *\n"
  " * The operation can be expressed symbolically as:\n"
  " *\n"
  " * this(u, v) = this(dist(u, v))\n"
  " *\n"
  " * If scale_factor is not 1, it should be a value > 1, and it specifies the\n"
  " * factor to upscale the working table while processing, to reduce artifacts\n"
  " * from integer truncation.\n"
  " *\n"
  " * By convention, the y axis is inverted in the distortion map relative to the\n"
  " * coordinates here.  A y value of 0 in the distortion map corresponds with a\n"
  " * v value of 1 in this file.\n"
  " */";
#else
static const char *Dtool_PfmFile_forward_distort_188_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::reverse_distort(PfmFile const &dist, PN_float32 scale_factor = 1.0)
 */
static PyObject *Dtool_PfmFile_reverse_distort_189(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.reverse_distort")) {
    return NULL;
  }
  // 1-void PfmFile::reverse_distort(PfmFile const &dist, PN_float32 scale_factor = 1.0)
  PyObject *param1;
  float param2 = 1.0;
  static const char *keyword_list[] = {"dist", "scale_factor", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|f:reverse_distort", (char **)keyword_list, &param1, &param2)) {
    PfmFile const *param1_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PfmFile, 1, "PfmFile.reverse_distort", true, true);
    if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*local_this).reverse_distort(*param1_this, (PN_float32)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reverse_distort(const PfmFile self, const PfmFile dist, float scale_factor)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_reverse_distort_189_comment =
  "C++ Interface:\n"
  "reverse_distort(const PfmFile self, const PfmFile dist, float scale_factor)\n"
  "\n"
  "/**\n"
  " * Applies the distortion indicated in the supplied dist map to the current\n"
  " * map.  The dist map is understood to be a mapping of points in the range\n"
  " * 0..1 in the first two dimensions.\n"
  " *\n"
  " * The operation can be expressed symbolically as:\n"
  " *\n"
  " * this(u, v) = dist(this(u, v))\n"
  " *\n"
  " * If scale_factor is not 1, it should be a value > 1, and it specifies the\n"
  " * factor to upscale the working table while processing, to reduce artifacts\n"
  " * from integer truncation.\n"
  " *\n"
  " * By convention, the y axis in inverted in the distortion map relative to the\n"
  " * coordinates here.  A y value of 0 in the distortion map corresponds with a\n"
  " * v value of 1 in this file.\n"
  " */";
#else
static const char *Dtool_PfmFile_reverse_distort_189_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::apply_1d_lut(int channel, PfmFile const &lut, PN_float32 x_scale = 1.0)
 */
static PyObject *Dtool_PfmFile_apply_1d_lut_190(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.apply_1d_lut")) {
    return NULL;
  }
  // 1-void PfmFile::apply_1d_lut(int channel, PfmFile const &lut, PN_float32 x_scale = 1.0)
  int param1;
  PyObject *param2;
  float param3 = 1.0;
  static const char *keyword_list[] = {"channel", "lut", "x_scale", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO|f:apply_1d_lut", (char **)keyword_list, &param1, &param2, &param3)) {
    PfmFile const *param2_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PfmFile, 2, "PfmFile.apply_1d_lut", true, true);
    if (param2_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*local_this).apply_1d_lut((int)param1, *param2_this, (PN_float32)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_1d_lut(const PfmFile self, int channel, const PfmFile lut, float x_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_apply_1d_lut_190_comment =
  "C++ Interface:\n"
  "apply_1d_lut(const PfmFile self, int channel, const PfmFile lut, float x_scale)\n"
  "\n"
  "/**\n"
  " * Assumes that lut is an X by 1, 1-component PfmFile whose X axis maps points\n"
  " * to target points.  For each point in this pfm file, computes: p(u,\n"
  " * v)[channel] = lut(p(u, v)[channel] * x_scale, 0)[0]\n"
  " */";
#else
static const char *Dtool_PfmFile_apply_1d_lut_190_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::merge(PfmFile const &other)
 */
static PyObject *Dtool_PfmFile_merge_191(PyObject *self, PyObject *arg) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.merge")) {
    return NULL;
  }
  // 1-void PfmFile::merge(PfmFile const &other)
  PfmFile const *arg_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PfmFile, 1, "PfmFile.merge", true, true);
  if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).merge(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "merge(const PfmFile self, const PfmFile other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_merge_191_comment =
  "C++ Interface:\n"
  "merge(const PfmFile self, const PfmFile other)\n"
  "\n"
  "/**\n"
  " * Wherever there is missing data in this PfmFile (that is, wherever\n"
  " * has_point() returns false), copy data from the other PfmFile, which must be\n"
  " * exactly the same dimensions as this one.\n"
  " */";
#else
static const char *Dtool_PfmFile_merge_191_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::apply_mask(PfmFile const &other)
 */
static PyObject *Dtool_PfmFile_apply_mask_192(PyObject *self, PyObject *arg) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.apply_mask")) {
    return NULL;
  }
  // 1-void PfmFile::apply_mask(PfmFile const &other)
  PfmFile const *arg_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PfmFile, 1, "PfmFile.apply_mask", true, true);
  if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).apply_mask(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_mask(const PfmFile self, const PfmFile other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_apply_mask_192_comment =
  "C++ Interface:\n"
  "apply_mask(const PfmFile self, const PfmFile other)\n"
  "\n"
  "/**\n"
  " * Wherever there is missing data in the other PfmFile, set this the\n"
  " * corresponding point in this PfmFile to missing as well, so that this\n"
  " * PfmFile has only points where both files have points.\n"
  " *\n"
  " * The point is set to \"missing\" by setting it the no_data_value.\n"
  " */";
#else
static const char *Dtool_PfmFile_apply_mask_192_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::copy_channel(int to_channel, PfmFile const &other, int from_channel)
 */
static PyObject *Dtool_PfmFile_copy_channel_193(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.copy_channel")) {
    return NULL;
  }
  // 1-void PfmFile::copy_channel(int to_channel, PfmFile const &other, int from_channel)
  int param1;
  PyObject *param2;
  int param3;
  static const char *keyword_list[] = {"to_channel", "other", "from_channel", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iOi:copy_channel", (char **)keyword_list, &param1, &param2, &param3)) {
    PfmFile const *param2_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PfmFile, 2, "PfmFile.copy_channel", true, true);
    if (param2_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*local_this).copy_channel((int)param1, *param2_this, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_channel(const PfmFile self, int to_channel, const PfmFile other, int from_channel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_copy_channel_193_comment =
  "C++ Interface:\n"
  "copy_channel(const PfmFile self, int to_channel, const PfmFile other, int from_channel)\n"
  "\n"
  "/**\n"
  " * Copies just the specified channel values from the indicated PfmFile (which\n"
  " * could be same as this PfmFile) into the specified channel of this one.\n"
  " */";
#else
static const char *Dtool_PfmFile_copy_channel_193_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::copy_channel_masked(int to_channel, PfmFile const &other, int from_channel)
 */
static PyObject *Dtool_PfmFile_copy_channel_masked_194(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.copy_channel_masked")) {
    return NULL;
  }
  // 1-void PfmFile::copy_channel_masked(int to_channel, PfmFile const &other, int from_channel)
  int param1;
  PyObject *param2;
  int param3;
  static const char *keyword_list[] = {"to_channel", "other", "from_channel", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iOi:copy_channel_masked", (char **)keyword_list, &param1, &param2, &param3)) {
    PfmFile const *param2_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PfmFile, 2, "PfmFile.copy_channel_masked", true, true);
    if (param2_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*local_this).copy_channel_masked((int)param1, *param2_this, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_channel_masked(const PfmFile self, int to_channel, const PfmFile other, int from_channel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_copy_channel_masked_194_comment =
  "C++ Interface:\n"
  "copy_channel_masked(const PfmFile self, int to_channel, const PfmFile other, int from_channel)\n"
  "\n"
  "/**\n"
  " * Copies just the specified channel values from the indicated PfmFile, but\n"
  " * only where the other file has a data point.\n"
  " */";
#else
static const char *Dtool_PfmFile_copy_channel_masked_194_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::apply_crop(int x_begin, int x_end, int y_begin, int y_end)
 */
static PyObject *Dtool_PfmFile_apply_crop_195(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.apply_crop")) {
    return NULL;
  }
  // 1-void PfmFile::apply_crop(int x_begin, int x_end, int y_begin, int y_end)
  int param1;
  int param2;
  int param3;
  int param4;
  static const char *keyword_list[] = {"x_begin", "x_end", "y_begin", "y_end", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiii:apply_crop", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).apply_crop((int)param1, (int)param2, (int)param3, (int)param4);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_crop(const PfmFile self, int x_begin, int x_end, int y_begin, int y_end)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_apply_crop_195_comment =
  "C++ Interface:\n"
  "apply_crop(const PfmFile self, int x_begin, int x_end, int y_begin, int y_end)\n"
  "\n"
  "/**\n"
  " * Reduces the PFM file to the cells in the rectangle bounded by (x_begin,\n"
  " * x_end, y_begin, y_end), where the _end cells are not included.\n"
  " */";
#else
static const char *Dtool_PfmFile_apply_crop_195_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::clear_to_texcoords(int x_size, int y_size)
 */
static PyObject *Dtool_PfmFile_clear_to_texcoords_196(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.clear_to_texcoords")) {
    return NULL;
  }
  // 1-void PfmFile::clear_to_texcoords(int x_size, int y_size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"x_size", "y_size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:clear_to_texcoords", (char **)keyword_list, &param1, &param2)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).clear_to_texcoords((int)param1, (int)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_to_texcoords(const PfmFile self, int x_size, int y_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_clear_to_texcoords_196_comment =
  "C++ Interface:\n"
  "clear_to_texcoords(const PfmFile self, int x_size, int y_size)\n"
  "\n"
  "/**\n"
  " * Replaces this PfmFile with a new PfmFile of size x_size x y_size x 3,\n"
  " * containing the x y 0 values in the range 0 .. 1 according to the x y index.\n"
  " */";
#else
static const char *Dtool_PfmFile_clear_to_texcoords_196_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int PfmFile::pull_spot(LPoint4f const &delta, float xc, float yc, float xr, float yr, float exponent)
 */
static PyObject *Dtool_PfmFile_pull_spot_197(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.pull_spot")) {
    return NULL;
  }
  // 1-int PfmFile::pull_spot(LPoint4f const &delta, float xc, float yc, float xr, float yr, float exponent)
  PyObject *param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  static const char *keyword_list[] = {"delta", "xc", "yc", "xr", "yr", "exponent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Offfff:pull_spot", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
    LPoint4f param1_local;
    LPoint4f const *param1_this = Dtool_Coerce_LPoint4f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PfmFile.pull_spot", "LPoint4f");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    int return_value = (*local_this).pull_spot(*param1_this, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pull_spot(const PfmFile self, const LPoint4f delta, float xc, float yc, float xr, float yr, float exponent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_pull_spot_197_comment =
  "C++ Interface:\n"
  "pull_spot(const PfmFile self, const LPoint4f delta, float xc, float yc, float xr, float yr, float exponent)\n"
  "\n"
  "/**\n"
  " * Applies delta * t to the point values within radius (xr, yr) distance of\n"
  " * (xc, yc).  The t value is scaled from 1.0 at the center to 0.0 at radius\n"
  " * (xr, yr), and this scale follows the specified exponent.  Returns the\n"
  " * number of points affected.\n"
  " */";
#else
static const char *Dtool_PfmFile_pull_spot_197_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::calc_tight_bounds(LPoint3f &min_point, LPoint3f &max_point) const
 */
static PyObject *Dtool_PfmFile_calc_tight_bounds_198(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool PfmFile::calc_tight_bounds(LPoint3f &min_point, LPoint3f &max_point) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"min_point", "max_point", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:calc_tight_bounds", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3f *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PfmFile.calc_tight_bounds", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3f *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PfmFile.calc_tight_bounds", "LPoint3f");
    }
    bool return_value = (*(const PfmFile*)local_this).calc_tight_bounds(*param1_this, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_tight_bounds(PfmFile self, LPoint3f min_point, LPoint3f max_point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_calc_tight_bounds_198_comment =
  "C++ Interface:\n"
  "calc_tight_bounds(PfmFile self, LPoint3f min_point, LPoint3f max_point)\n"
  "\n"
  "/**\n"
  " * Calculates the minimum and maximum vertices of all points within the table.\n"
  " * Assumes the table contains 3-D points.\n"
  " *\n"
  " * The return value is true if any points in the table, or false if none are.\n"
  " */";
#else
static const char *Dtool_PfmFile_calc_tight_bounds_198_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< BoundingHexahedron > PfmFile::compute_planar_bounds(LPoint2d const &center, PN_float32 point_dist, PN_float32 sample_radius, bool points_only) const
 * PointerTo< BoundingHexahedron > PfmFile::compute_planar_bounds(LPoint2f const &center, PN_float32 point_dist, PN_float32 sample_radius, bool points_only) const
 */
static PyObject *Dtool_PfmFile_compute_planar_bounds_199(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 inline PointerTo< BoundingHexahedron > PfmFile::compute_planar_bounds(LPoint2d const &center, PN_float32 point_dist, PN_float32 sample_radius, bool points_only) const
    PyObject *param1;
    float param2;
    float param3;
    PyObject *param4;
    static const char *keyword_list[] = {"center", "point_dist", "sample_radius", "points_only", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OffO:compute_planar_bounds", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      LPoint2d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint2d, (void **)&param1_this);
      if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        PointerTo< BoundingHexahedron > return_value = (*(const PfmFile*)local_this).compute_planar_bounds(*param1_this, (PN_float32)param2, (PN_float32)param3, (PyObject_IsTrue(param4) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        // Transfer ownership of return_value.
        BoundingHexahedron *return_ptr = return_value.p();
        return_value.cheat() = NULL;
        if (return_ptr == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingHexahedron, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    PyErr_Clear();
  }

  {
    // -2 PointerTo< BoundingHexahedron > PfmFile::compute_planar_bounds(LPoint2f const &center, PN_float32 point_dist, PN_float32 sample_radius, bool points_only) const
    PyObject *param1;
    float param2;
    float param3;
    PyObject *param4;
    static const char *keyword_list[] = {"center", "point_dist", "sample_radius", "points_only", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OffO:compute_planar_bounds", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      LPoint2f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint2f, (void **)&param1_this);
      if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        PointerTo< BoundingHexahedron > return_value = (*(const PfmFile*)local_this).compute_planar_bounds(*param1_this, (PN_float32)param2, (PN_float32)param3, (PyObject_IsTrue(param4) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        // Transfer ownership of return_value.
        BoundingHexahedron *return_ptr = return_value.p();
        return_value.cheat() = NULL;
        if (return_ptr == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingHexahedron, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline PointerTo< BoundingHexahedron > PfmFile::compute_planar_bounds(LPoint2d const &center, PN_float32 point_dist, PN_float32 sample_radius, bool points_only) const
    PyObject *param1;
    float param2;
    float param3;
    PyObject *param4;
    static const char *keyword_list[] = {"center", "point_dist", "sample_radius", "points_only", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OffO:compute_planar_bounds", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      LPoint2d param1_local;
      LPoint2d const *param1_this = Dtool_Coerce_LPoint2d(param1, param1_local);
      if ((param1_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        PointerTo< BoundingHexahedron > return_value = (*(const PfmFile*)local_this).compute_planar_bounds(*param1_this, (PN_float32)param2, (PN_float32)param3, (PyObject_IsTrue(param4) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        // Transfer ownership of return_value.
        BoundingHexahedron *return_ptr = return_value.p();
        return_value.cheat() = NULL;
        if (return_ptr == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingHexahedron, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    PyErr_Clear();
  }

  {
    // -2 PointerTo< BoundingHexahedron > PfmFile::compute_planar_bounds(LPoint2f const &center, PN_float32 point_dist, PN_float32 sample_radius, bool points_only) const
    PyObject *param1;
    float param2;
    float param3;
    PyObject *param4;
    static const char *keyword_list[] = {"center", "point_dist", "sample_radius", "points_only", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OffO:compute_planar_bounds", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      LPoint2f param1_local;
      LPoint2f const *param1_this = Dtool_Coerce_LPoint2f(param1, param1_local);
      if ((param1_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        PointerTo< BoundingHexahedron > return_value = (*(const PfmFile*)local_this).compute_planar_bounds(*param1_this, (PN_float32)param2, (PN_float32)param3, (PyObject_IsTrue(param4) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        // Transfer ownership of return_value.
        BoundingHexahedron *return_ptr = return_value.p();
        return_value.cheat() = NULL;
        if (return_ptr == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingHexahedron, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compute_planar_bounds(PfmFile self, const LPoint2d center, float point_dist, float sample_radius, bool points_only)\n"
      "compute_planar_bounds(PfmFile self, const LPoint2f center, float point_dist, float sample_radius, bool points_only)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_compute_planar_bounds_199_comment =
  "C++ Interface:\n"
  "compute_planar_bounds(PfmFile self, const LPoint2d center, float point_dist, float sample_radius, bool points_only)\n"
  "compute_planar_bounds(PfmFile self, const LPoint2f center, float point_dist, float sample_radius, bool points_only)\n"
  "\n"
  "/**\n"
  " * Computes the minmax bounding volume of the points in 3-D space, assuming\n"
  " * the points represent a mostly-planar surface.\n"
  " *\n"
  " * This algorithm works by sampling the (square) sample_radius pixels at the\n"
  " * four point_dist corners around the center (cx - pd, cx + pd) and so on, to\n"
  " * approximate the plane of the surface.  Then all of the points are projected\n"
  " * into that plane and the bounding volume of the entire mesh within that\n"
  " * plane is determined.  If points_only is true, the bounding volume of only\n"
  " * those four points is determined.\n"
  " *\n"
  " * center, point_dist and sample_radius are in UV space, i.e.  in the range\n"
  " * 0..1.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Computes the minmax bounding volume of the points in 3-D space, assuming\n"
  " * the points represent a mostly-planar surface.\n"
  " *\n"
  " * This algorithm works by sampling the (square) sample_radius pixels at the\n"
  " * four point_dist corners around the center (cx - pd, cx + pd) and so on, to\n"
  " * approximate the plane of the surface.  Then all of the points are projected\n"
  " * into that plane and the bounding volume of the entire mesh within that\n"
  " * plane is determined.  If points_only is true, the bounding volume of only\n"
  " * those four points is determined.\n"
  " *\n"
  " * center, point_dist and sample_radius are in UV space, i.e.  in the range\n"
  " * 0..1.\n"
  " */";
#else
static const char *Dtool_PfmFile_compute_planar_bounds_199_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::compute_sample_point(LPoint3f &result, PN_float32 x, PN_float32 y, PN_float32 sample_radius) const
 */
static PyObject *Dtool_PfmFile_compute_sample_point_200(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PfmFile::compute_sample_point(LPoint3f &result, PN_float32 x, PN_float32 y, PN_float32 sample_radius) const
  PyObject *param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"result", "x", "y", "sample_radius", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:compute_sample_point", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    LPoint3f param1_local;
    LPoint3f *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PfmFile.compute_sample_point", "LPoint3f");
    }
    (*(const PfmFile*)local_this).compute_sample_point(*param1_this, (PN_float32)param2, (PN_float32)param3, (PN_float32)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compute_sample_point(PfmFile self, LPoint3f result, float x, float y, float sample_radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_compute_sample_point_200_comment =
  "C++ Interface:\n"
  "compute_sample_point(PfmFile self, LPoint3f result, float x, float y, float sample_radius)\n"
  "\n"
  "/**\n"
  " * Computes the average of all the point within sample_radius (manhattan\n"
  " * distance) and the indicated point.\n"
  " *\n"
  " * The point coordinates are given in UV space, in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PfmFile_compute_sample_point_200_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::copy_sub_image(PfmFile const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1)
 */
static PyObject *Dtool_PfmFile_copy_sub_image_201(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.copy_sub_image")) {
    return NULL;
  }
  // 1-void PfmFile::copy_sub_image(PfmFile const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiii:copy_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
    PfmFile const *param1_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PfmFile, 1, "PfmFile.copy_sub_image", true, true);
    if (param1_this != NULL) {
      (*local_this).copy_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_sub_image(const PfmFile self, const PfmFile copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_copy_sub_image_201_comment =
  "C++ Interface:\n"
  "copy_sub_image(const PfmFile self, const PfmFile copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size)\n"
  "\n"
  "/**\n"
  " * Copies a rectangular area of another image into a rectangular area of this\n"
  " * image.  Both images must already have been initialized.  The upper-left\n"
  " * corner of the region in both images is specified, and the size of the area;\n"
  " * if the size is omitted, it defaults to the entire other image, or the\n"
  " * largest piece that will fit.\n"
  " */";
#else
static const char *Dtool_PfmFile_copy_sub_image_201_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::add_sub_image(PfmFile const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
 */
static PyObject *Dtool_PfmFile_add_sub_image_202(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.add_sub_image")) {
    return NULL;
  }
  // 1-void PfmFile::add_sub_image(PfmFile const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  float param8 = 1.0;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", "pixel_scale", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiiif:add_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
    PfmFile const *param1_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PfmFile, 1, "PfmFile.add_sub_image", true, true);
    if (param1_this != NULL) {
      (*local_this).add_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (float)param8);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_sub_image(const PfmFile self, const PfmFile copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_add_sub_image_202_comment =
  "C++ Interface:\n"
  "add_sub_image(const PfmFile self, const PfmFile copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
  "\n"
  "/**\n"
  " * Behaves like copy_sub_image(), except the copy pixels are added to the\n"
  " * pixels of the destination, after scaling by the specified pixel_scale.\n"
  " */";
#else
static const char *Dtool_PfmFile_add_sub_image_202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::mult_sub_image(PfmFile const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
 */
static PyObject *Dtool_PfmFile_mult_sub_image_203(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.mult_sub_image")) {
    return NULL;
  }
  // 1-void PfmFile::mult_sub_image(PfmFile const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  float param8 = 1.0;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", "pixel_scale", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiiif:mult_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
    PfmFile const *param1_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PfmFile, 1, "PfmFile.mult_sub_image", true, true);
    if (param1_this != NULL) {
      (*local_this).mult_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (float)param8);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "mult_sub_image(const PfmFile self, const PfmFile copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_mult_sub_image_203_comment =
  "C++ Interface:\n"
  "mult_sub_image(const PfmFile self, const PfmFile copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
  "\n"
  "/**\n"
  " * Behaves like copy_sub_image(), except the copy pixels are multiplied to the\n"
  " * pixels of the destination, after scaling by the specified pixel_scale.\n"
  " */";
#else
static const char *Dtool_PfmFile_mult_sub_image_203_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::divide_sub_image(PfmFile const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
 */
static PyObject *Dtool_PfmFile_divide_sub_image_204(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.divide_sub_image")) {
    return NULL;
  }
  // 1-void PfmFile::divide_sub_image(PfmFile const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  float param8 = 1.0;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", "pixel_scale", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiiif:divide_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
    PfmFile const *param1_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PfmFile, 1, "PfmFile.divide_sub_image", true, true);
    if (param1_this != NULL) {
      (*local_this).divide_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (float)param8);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "divide_sub_image(const PfmFile self, const PfmFile copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_divide_sub_image_204_comment =
  "C++ Interface:\n"
  "divide_sub_image(const PfmFile self, const PfmFile copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
  "\n"
  "/**\n"
  " * Behaves like copy_sub_image(), except the copy pixels are divided into the\n"
  " * pixels of the destination, after scaling by the specified pixel_scale.\n"
  " * dest(x, y) = dest(x, y) / (copy(x, y) * pixel_scale).\n"
  " */";
#else
static const char *Dtool_PfmFile_divide_sub_image_204_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::indirect_1d_lookup(PfmFile const &index_image, int channel, PfmFile const &pixel_values)
 */
static PyObject *Dtool_PfmFile_indirect_1d_lookup_206(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.indirect_1d_lookup")) {
    return NULL;
  }
  // 1-void PfmFile::indirect_1d_lookup(PfmFile const &index_image, int channel, PfmFile const &pixel_values)
  PyObject *param1;
  int param2;
  PyObject *param3;
  static const char *keyword_list[] = {"index_image", "channel", "pixel_values", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OiO:indirect_1d_lookup", (char **)keyword_list, &param1, &param2, &param3)) {
    PfmFile const *param1_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PfmFile, 1, "PfmFile.indirect_1d_lookup", true, true);
    PfmFile const *param3_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_PfmFile, 3, "PfmFile.indirect_1d_lookup", true, true);
    if (param1_this != NULL && param3_this != NULL) {
      (*local_this).indirect_1d_lookup(*param1_this, (int)param2, *param3_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "indirect_1d_lookup(const PfmFile self, const PfmFile index_image, int channel, const PfmFile pixel_values)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_indirect_1d_lookup_206_comment =
  "C++ Interface:\n"
  "indirect_1d_lookup(const PfmFile self, const PfmFile index_image, int channel, const PfmFile pixel_values)\n"
  "\n"
  "/**\n"
  " * index_image is a WxH 1-channel image, while pixel_values is an Nx1\n"
  " * image with any number of channels.  Typically pixel_values will be\n"
  " * a 256x1 image.\n"
  " *\n"
  " * Fills the PfmFile with a new image the same width and height as\n"
  " * index_image, with the same number of channels as pixel_values.\n"
  " *\n"
  " * Each pixel of the new image is computed with the formula:\n"
  " *\n"
  " * new_image(x, y) = pixel_values(index_image(x, y)[channel], 0)\n"
  " *\n"
  " * At present, no interpolation is performed; the nearest value in\n"
  " * pixel_values is discovered.  This may change in the future.\n"
  " */";
#else
static const char *Dtool_PfmFile_indirect_1d_lookup_206_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::gamma_correct(float from_gamma, float to_gamma)
 */
static PyObject *Dtool_PfmFile_gamma_correct_207(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.gamma_correct")) {
    return NULL;
  }
  // 1-inline void PfmFile::gamma_correct(float from_gamma, float to_gamma)
  float param1;
  float param2;
  static const char *keyword_list[] = {"from_gamma", "to_gamma", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:gamma_correct", (char **)keyword_list, &param1, &param2)) {
    (*local_this).gamma_correct((float)param1, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "gamma_correct(const PfmFile self, float from_gamma, float to_gamma)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_gamma_correct_207_comment =
  "C++ Interface:\n"
  "gamma_correct(const PfmFile self, float from_gamma, float to_gamma)\n"
  "\n"
  "/**\n"
  " * Assuming the image was constructed with a gamma curve of from_gamma in the\n"
  " * RGB channels, converts it to an image with a gamma curve of to_gamma in the\n"
  " * RGB channels.  Does not affect the alpha channel.\n"
  " */";
#else
static const char *Dtool_PfmFile_gamma_correct_207_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::gamma_correct_alpha(float from_gamma, float to_gamma)
 */
static PyObject *Dtool_PfmFile_gamma_correct_alpha_208(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.gamma_correct_alpha")) {
    return NULL;
  }
  // 1-inline void PfmFile::gamma_correct_alpha(float from_gamma, float to_gamma)
  float param1;
  float param2;
  static const char *keyword_list[] = {"from_gamma", "to_gamma", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:gamma_correct_alpha", (char **)keyword_list, &param1, &param2)) {
    (*local_this).gamma_correct_alpha((float)param1, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "gamma_correct_alpha(const PfmFile self, float from_gamma, float to_gamma)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_gamma_correct_alpha_208_comment =
  "C++ Interface:\n"
  "gamma_correct_alpha(const PfmFile self, float from_gamma, float to_gamma)\n"
  "\n"
  "/**\n"
  " * Assuming the image was constructed with a gamma curve of from_gamma in the\n"
  " * alpha channel, converts it to an image with a gamma curve of to_gamma in\n"
  " * the alpha channel.  Does not affect the RGB channels.\n"
  " */";
#else
static const char *Dtool_PfmFile_gamma_correct_alpha_208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::apply_exponent(float gray_exponent)
 * inline void PfmFile::apply_exponent(float gray_exponent, float alpha_exponent)
 * inline void PfmFile::apply_exponent(float c0_exponent, float c1_exponent, float c2_exponent)
 * void PfmFile::apply_exponent(float c0_exponent, float c1_exponent, float c2_exponent, float c3_exponent)
 */
static PyObject *Dtool_PfmFile_apply_exponent_209(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.apply_exponent")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "gray_exponent");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'gray_exponent' (pos 1) not found");
      }
      // 1-inline void PfmFile::apply_exponent(float gray_exponent)
      if (PyNumber_Check(arg)) {
        (*local_this).apply_exponent((float)PyFloat_AsDouble(arg));
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void PfmFile::apply_exponent(float gray_exponent, float alpha_exponent)
      float param1;
      float param2;
      static const char *keyword_list[] = {"gray_exponent", "alpha_exponent", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:apply_exponent", (char **)keyword_list, &param1, &param2)) {
        (*local_this).apply_exponent((float)param1, (float)param2);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void PfmFile::apply_exponent(float c0_exponent, float c1_exponent, float c2_exponent)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"c0_exponent", "c1_exponent", "c2_exponent", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:apply_exponent", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).apply_exponent((float)param1, (float)param2, (float)param3);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-void PfmFile::apply_exponent(float c0_exponent, float c1_exponent, float c2_exponent, float c3_exponent)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"c0_exponent", "c1_exponent", "c2_exponent", "c3_exponent", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:apply_exponent", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).apply_exponent((float)param1, (float)param2, (float)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "apply_exponent() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_exponent(const PfmFile self, float gray_exponent)\n"
      "apply_exponent(const PfmFile self, float gray_exponent, float alpha_exponent)\n"
      "apply_exponent(const PfmFile self, float c0_exponent, float c1_exponent, float c2_exponent)\n"
      "apply_exponent(const PfmFile self, float c0_exponent, float c1_exponent, float c2_exponent, float c3_exponent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_apply_exponent_209_comment =
  "C++ Interface:\n"
  "apply_exponent(const PfmFile self, float gray_exponent)\n"
  "apply_exponent(const PfmFile self, float gray_exponent, float alpha_exponent)\n"
  "apply_exponent(const PfmFile self, float c0_exponent, float c1_exponent, float c2_exponent)\n"
  "apply_exponent(const PfmFile self, float c0_exponent, float c1_exponent, float c2_exponent, float c3_exponent)\n"
  "\n"
  "/**\n"
  " * Adjusts each channel of the image by raising the corresponding component\n"
  " * value to the indicated exponent, such that L' = L ^ exponent.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adjusts each channel of the image by raising the corresponding component\n"
  " * value to the indicated exponent, such that L' = L ^ exponent.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adjusts each channel of the image by raising the corresponding component\n"
  " * value to the indicated exponent, such that L' = L ^ exponent.  For a\n"
  " * grayscale image, the blue_exponent value is used for the grayscale value,\n"
  " * and red_exponent and green_exponent are unused.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adjusts each channel of the image by raising the corresponding component\n"
  " * value to the indicated exponent, such that L' = L ^ exponent.\n"
  " */";
#else
static const char *Dtool_PfmFile_apply_exponent_209_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::output(ostream &out) const
 */
static PyObject *Dtool_PfmFile_output_210(PyObject *self, PyObject *arg) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PfmFile::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PfmFile.output", false, true);
  if (arg_this != NULL) {
    (*(const PfmFile*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PfmFile self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_output_210_comment =
  "C++ Interface:\n"
  "output(PfmFile self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PfmFile_output_210_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *PfmFile::get_points(void) const
 */
static PyObject *Dtool_PfmFile_get_points_211(PyObject *self, PyObject *) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-PyObject *PfmFile::get_points(void) const
  PyObject *return_value = invoke_extension((const PfmFile*)local_this).get_points();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_get_points_211_comment =
  "C++ Interface:\n"
  "get_points(PfmFile self)\n";
#else
static const char *Dtool_PfmFile_get_points_211_comment = NULL;
#endif

static PyObject *Dtool_PfmFile_valid_Getter(PyObject *self, void *) {
  const PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool PfmFile::is_valid(void) const
  bool return_value = (*(const PfmFile*)local_this).is_valid();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PfmFile_scale_Getter(PyObject *self, void *) {
  const PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_float32 PfmFile::get_scale(void) const
  PN_float32 return_value = (*(const PfmFile*)local_this).get_scale();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PfmFile_scale_Setter(PyObject *self, PyObject *arg, void *) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.scale")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete scale attribute");
    return -1;
  }
  // 1-inline void PfmFile::set_scale(PN_float32 scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_scale((PN_float32)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_scale(const PfmFile self, float scale)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * PfmFile::PfmFile(void)
 * PfmFile::PfmFile(PfmFile const &copy)
 */
static int Dtool_Init_PfmFile(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PfmFile::PfmFile(void)
      PfmFile *return_value = new PfmFile();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PfmFile, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-PfmFile::PfmFile(PfmFile const &copy)
      PfmFile const *arg_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PfmFile, 0, "PfmFile.PfmFile", true, true);
      if (arg_this != NULL) {
        PfmFile *return_value = new PfmFile(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PfmFile, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PfmFile() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PfmFile()\n"
      "PfmFile(const PfmFile copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PfmFile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PfmFile) {
    printf("PfmFile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PfmFile *local_this = (PfmFile *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PfmFile) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PNMImageHeader) {
    return (PNMImageHeader *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PfmFile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PfmFile) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PNMImageHeader) {
    PNMImageHeader* other_this = (PNMImageHeader*)from_this;
    return (PfmFile*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PNMBrush
 */
/**
 * Python function wrapper for:
 * static PointerTo< PNMBrush > PNMBrush::make_transparent(void)
 */
static PyObject *Dtool_PNMBrush_make_transparent_217(PyObject *, PyObject *) {
  // 1-static PointerTo< PNMBrush > PNMBrush::make_transparent(void)
  PointerTo< PNMBrush > return_value = PNMBrush::make_transparent();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  PNMBrush *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_PNMBrush, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PNMBrush_make_transparent_217_comment =
  "C++ Interface:\n"
  "make_transparent()\n"
  "\n"
  "/**\n"
  " * Returns a new brush that does not paint anything.  Can be used as either a\n"
  " * pen or a fill brush to make borderless or unfilled shapes, respectively.\n"
  " */";
#else
static const char *Dtool_PNMBrush_make_transparent_217_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< PNMBrush > PNMBrush::make_pixel(LColorf const &color, PNMBrush::BrushEffect effect = ::PNMBrush::BE_blend)
 */
static PyObject *Dtool_PNMBrush_make_pixel_218(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< PNMBrush > PNMBrush::make_pixel(LColorf const &color, PNMBrush::BrushEffect effect = ::PNMBrush::BE_blend)
  PyObject *param0;
  int param1 = PNMBrush::BE_blend;
  static const char *keyword_list[] = {"color", "effect", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:make_pixel", (char **)keyword_list, &param0, &param1)) {
    LVecBase4f param0_local;
    LColorf const *param0_this = Dtool_Coerce_LVecBase4f(param0, param0_local);
    if (!(param0_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "PNMBrush.make_pixel", "LVecBase4f");
    }
    PointerTo< PNMBrush > return_value = PNMBrush::make_pixel(*param0_this, (PNMBrush::BrushEffect)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    PNMBrush *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_PNMBrush, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_pixel(const LVecBase4f color, int effect)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMBrush_make_pixel_218_comment =
  "C++ Interface:\n"
  "make_pixel(const LVecBase4f color, int effect)\n"
  "\n"
  "/**\n"
  " * Returns a new brush that paints a single pixel of the indicated color on a\n"
  " * border, or paints a solid color in an interior.\n"
  " */";
#else
static const char *Dtool_PNMBrush_make_pixel_218_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< PNMBrush > PNMBrush::make_spot(LColorf const &color, float radius, bool fuzzy, PNMBrush::BrushEffect effect = ::PNMBrush::BE_blend)
 */
static PyObject *Dtool_PNMBrush_make_spot_219(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< PNMBrush > PNMBrush::make_spot(LColorf const &color, float radius, bool fuzzy, PNMBrush::BrushEffect effect = ::PNMBrush::BE_blend)
  PyObject *param0;
  float param1;
  PyObject *param2;
  int param3 = PNMBrush::BE_blend;
  static const char *keyword_list[] = {"color", "radius", "fuzzy", "effect", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OfO|i:make_spot", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    LVecBase4f param0_local;
    LColorf const *param0_this = Dtool_Coerce_LVecBase4f(param0, param0_local);
    if (!(param0_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "PNMBrush.make_spot", "LVecBase4f");
    }
    PointerTo< PNMBrush > return_value = PNMBrush::make_spot(*param0_this, (float)param1, (PyObject_IsTrue(param2) != 0), (PNMBrush::BrushEffect)param3);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    PNMBrush *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_PNMBrush, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_spot(const LVecBase4f color, float radius, bool fuzzy, int effect)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMBrush_make_spot_219_comment =
  "C++ Interface:\n"
  "make_spot(const LVecBase4f color, float radius, bool fuzzy, int effect)\n"
  "\n"
  "/**\n"
  " * Returns a new brush that paints a spot of the indicated color and radius.\n"
  " * If fuzzy is true, the spot is fuzzy; otherwise, it is hard-edged.\n"
  " */";
#else
static const char *Dtool_PNMBrush_make_spot_219_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< PNMBrush > PNMBrush::make_image(PNMImage const &image, float xc, float yc, PNMBrush::BrushEffect effect = ::PNMBrush::BE_blend)
 */
static PyObject *Dtool_PNMBrush_make_image_220(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< PNMBrush > PNMBrush::make_image(PNMImage const &image, float xc, float yc, PNMBrush::BrushEffect effect = ::PNMBrush::BE_blend)
  PyObject *param0;
  float param1;
  float param2;
  int param3 = PNMBrush::BE_blend;
  static const char *keyword_list[] = {"image", "xc", "yc", "effect", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Off|i:make_image", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    PNMImage const *param0_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PNMImage, 0, "PNMBrush.make_image", true, true);
    if (param0_this != NULL) {
      PointerTo< PNMBrush > return_value = PNMBrush::make_image(*param0_this, (float)param1, (float)param2, (PNMBrush::BrushEffect)param3);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      // Transfer ownership of return_value.
      PNMBrush *return_ptr = return_value.p();
      return_value.cheat() = NULL;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_PNMBrush, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_image(const PNMImage image, float xc, float yc, int effect)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMBrush_make_image_220_comment =
  "C++ Interface:\n"
  "make_image(const PNMImage image, float xc, float yc, int effect)\n"
  "\n"
  "/**\n"
  " * Returns a new brush that paints with the indicated image.  xc and yc\n"
  " * indicate the pixel in the center of the brush.\n"
  " *\n"
  " * The brush makes a copy of the image; it is safe to deallocate or modify the\n"
  " * image after making this call.\n"
  " */";
#else
static const char *Dtool_PNMBrush_make_image_220_comment = NULL;
#endif

static int Dtool_Init_PNMBrush(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PNMBrush(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PNMBrush) {
    printf("PNMBrush ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PNMBrush *local_this = (PNMBrush *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PNMBrush) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PNMBrush(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PNMBrush) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PNMBrush*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PNMImage
 */
/**
 * Python function wrapper for:
 * inline void PNMImage::operator =(PNMImage const &copy)
 */
static PyObject *Dtool_PNMImage_operator_223(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.assign")) {
    return NULL;
  }
  // 1-inline void PNMImage::operator =(PNMImage const &copy)
  PNMImage const *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 1, "PNMImage.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    PNMImage *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PNMImage self, const PNMImage copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_operator_223_comment =
  "C++ Interface:\n"
  "assign(const PNMImage self, const PNMImage copy)\n";
#else
static const char *Dtool_PNMImage_operator_223_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImage::clamp_val(int input_value) const
 */
static PyObject *Dtool_PNMImage_clamp_val_225(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline xelval PNMImage::clamp_val(int input_value) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    xelval return_value = (*(const PNMImage*)local_this).clamp_val((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clamp_val(PNMImage self, int input_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_clamp_val_225_comment =
  "C++ Interface:\n"
  "clamp_val(PNMImage self, int input_value)\n"
  "\n"
  "/**\n"
  " * A handy function to clamp values to [0..get_maxval()].\n"
  " */";
#else
static const char *Dtool_PNMImage_clamp_val_225_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImage::to_val(float input_value) const
 */
static PyObject *Dtool_PNMImage_to_val_226(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline xelval PNMImage::to_val(float input_value) const
  if (PyNumber_Check(arg)) {
    xelval return_value = (*(const PNMImage*)local_this).to_val((float)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "to_val(PNMImage self, float input_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_to_val_226_comment =
  "C++ Interface:\n"
  "to_val(PNMImage self, float input_value)\n"
  "\n"
  "/**\n"
  " * A handy function to scale non-alpha values from [0..1] to\n"
  " * [0..get_maxval()].  Do not use this for alpha values, see to_alpha_val.\n"
  " */";
#else
static const char *Dtool_PNMImage_to_val_226_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImage::to_alpha_val(float input_value) const
 */
static PyObject *Dtool_PNMImage_to_alpha_val_227(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline xelval PNMImage::to_alpha_val(float input_value) const
  if (PyNumber_Check(arg)) {
    xelval return_value = (*(const PNMImage*)local_this).to_alpha_val((float)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "to_alpha_val(PNMImage self, float input_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_to_alpha_val_227_comment =
  "C++ Interface:\n"
  "to_alpha_val(PNMImage self, float input_value)\n"
  "\n"
  "/**\n"
  " * A handy function to scale alpha values from [0..1] to [0..get_maxval()].\n"
  " */";
#else
static const char *Dtool_PNMImage_to_alpha_val_227_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float PNMImage::from_val(xelval input_value) const
 */
static PyObject *Dtool_PNMImage_from_val_228(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float PNMImage::from_val(xelval input_value) const
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    float return_value = (*(const PNMImage*)local_this).from_val((xelval)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "from_val(PNMImage self, int input_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_from_val_228_comment =
  "C++ Interface:\n"
  "from_val(PNMImage self, int input_value)\n"
  "\n"
  "/**\n"
  " * A handy function to scale non-alpha values from [0..get_maxval()] to\n"
  " * [0..1].  Do not use this for alpha values, see from_alpha_val.\n"
  " */";
#else
static const char *Dtool_PNMImage_from_val_228_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float PNMImage::from_alpha_val(xelval input_value) const
 */
static PyObject *Dtool_PNMImage_from_alpha_val_229(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float PNMImage::from_alpha_val(xelval input_value) const
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    float return_value = (*(const PNMImage*)local_this).from_alpha_val((xelval)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "from_alpha_val(PNMImage self, int input_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_from_alpha_val_229_comment =
  "C++ Interface:\n"
  "from_alpha_val(PNMImage self, int input_value)\n"
  "\n"
  "/**\n"
  " * A handy function to scale alpha values from [0..get_maxval()] to [0..1].\n"
  " */";
#else
static const char *Dtool_PNMImage_from_alpha_val_229_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::clear(void)
 * void PNMImage::clear(int x_size, int y_size, int num_channels = 3, xelval maxval = 255, PNMFileType *type = 0, ColorSpace color_space = ::CS_linear)
 */
static PyObject *Dtool_PNMImage_clear_230(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.clear")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-void PNMImage::clear(void)
      (*local_this).clear();
      return Dtool_Return_None();
    }
    break;
  case 2:
  case 3:
  case 4:
  case 5:
  case 6:
    {
      // 1-void PNMImage::clear(int x_size, int y_size, int num_channels = 3, xelval maxval = 255, PNMFileType *type = 0, ColorSpace color_space = ::CS_linear)
      int param1;
      int param2;
      int param3 = 3;
      long param4 = 255;
      PyObject *param5 = NULL;
      int param6 = ::CS_linear;
      static const char *keyword_list[] = {"x_size", "y_size", "num_channels", "maxval", "type", "color_space", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii|ilOi:clear", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
#ifndef NDEBUG
        if (param4 < 0 || param4 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param4);
        }
#endif
        PNMFileType *param5_this = 0;
        if (param5 != (PyObject *)NULL) {
          param5_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param5, Dtool_Ptr_PNMFileType, 5, "PNMImage.clear", false, true);
        }
        if ((param5 == NULL || param5_this != NULL)) {
          (*local_this).clear((int)param1, (int)param2, (int)param3, (xelval)param4, param5_this, (ColorSpace)param6);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "clear() takes 1, 3, 4, 5, 6 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear(const PNMImage self)\n"
      "clear(const PNMImage self, int x_size, int y_size, int num_channels, int maxval, PNMFileType type, int color_space)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_clear_230_comment =
  "C++ Interface:\n"
  "clear(const PNMImage self)\n"
  "clear(const PNMImage self, int x_size, int y_size, int num_channels, int maxval, PNMFileType type, int color_space)\n"
  "\n"
  "/**\n"
  " * Frees all memory allocated for the image, and clears all its parameters\n"
  " * (size, color, type, etc).\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of clear() reinitializes the image to an empty (black) image\n"
  " * with the given dimensions.\n"
  " */";
#else
static const char *Dtool_PNMImage_clear_230_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::copy_from(PNMImage const &copy)
 */
static PyObject *Dtool_PNMImage_copy_from_231(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.copy_from")) {
    return NULL;
  }
  // 1-void PNMImage::copy_from(PNMImage const &copy)
  PNMImage const *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 1, "PNMImage.copy_from", true, true);
  if (arg_this != NULL) {
    (*local_this).copy_from(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_from(const PNMImage self, const PNMImage copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_copy_from_231_comment =
  "C++ Interface:\n"
  "copy_from(const PNMImage self, const PNMImage copy)\n"
  "\n"
  "/**\n"
  " * Makes this image become a copy of the other image.\n"
  " */";
#else
static const char *Dtool_PNMImage_copy_from_231_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::copy_channel(PNMImage const &copy, int src_channel, int dest_channel)
 * void PNMImage::copy_channel(PNMImage const &copy, int xto, int yto, int cto, int xfrom = 0, int yfrom = 0, int cfrom = 0, int x_size = -1, int y_size = -1)
 */
static PyObject *Dtool_PNMImage_copy_channel_232(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.copy_channel")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-void PNMImage::copy_channel(PNMImage const &copy, int src_channel, int dest_channel)
      PyObject *param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"copy", "src_channel", "dest_channel", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:copy_channel", (char **)keyword_list, &param1, &param2, &param3)) {
        PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.copy_channel", true, true);
        if (param1_this != NULL) {
          (*local_this).copy_channel(*param1_this, (int)param2, (int)param3);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 4:
  case 5:
  case 6:
  case 7:
  case 8:
  case 9:
    {
      // 1-void PNMImage::copy_channel(PNMImage const &copy, int xto, int yto, int cto, int xfrom = 0, int yfrom = 0, int cfrom = 0, int x_size = -1, int y_size = -1)
      PyObject *param1;
      int param2;
      int param3;
      int param4;
      int param5 = 0;
      int param6 = 0;
      int param7 = 0;
      int param8 = -1;
      int param9 = -1;
      static const char *keyword_list[] = {"copy", "xto", "yto", "cto", "xfrom", "yfrom", "cfrom", "x_size", "y_size", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oiii|iiiii:copy_channel", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9)) {
        PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.copy_channel", true, true);
        if (param1_this != NULL) {
          (*local_this).copy_channel(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (int)param8, (int)param9);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "copy_channel() takes 4, 5, 6, 7, 8, 9 or 10 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_channel(const PNMImage self, const PNMImage copy, int src_channel, int dest_channel)\n"
      "copy_channel(const PNMImage self, const PNMImage copy, int xto, int yto, int cto, int xfrom, int yfrom, int cfrom, int x_size, int y_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_copy_channel_232_comment =
  "C++ Interface:\n"
  "copy_channel(const PNMImage self, const PNMImage copy, int src_channel, int dest_channel)\n"
  "copy_channel(const PNMImage self, const PNMImage copy, int xto, int yto, int cto, int xfrom, int yfrom, int cfrom, int x_size, int y_size)\n"
  "\n"
  "/**\n"
  " * Copies a channel from one image into another.  Images must be the same size\n"
  " */\n"
  "\n"
  "/**\n"
  " * Copies just a single channel from the source image into a single channel of\n"
  " * this image, leaving the remaining channels alone.\n"
  " */";
#else
static const char *Dtool_PNMImage_copy_channel_232_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::copy_channel_bits(PNMImage const &copy, int src_channel, int dest_channel, xelval src_mask, int right_shift)
 */
static PyObject *Dtool_PNMImage_copy_channel_bits_233(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.copy_channel_bits")) {
    return NULL;
  }
  // 1-void PNMImage::copy_channel_bits(PNMImage const &copy, int src_channel, int dest_channel, xelval src_mask, int right_shift)
  PyObject *param1;
  int param2;
  int param3;
  long param4;
  int param5;
  static const char *keyword_list[] = {"copy", "src_channel", "dest_channel", "src_mask", "right_shift", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oiili:copy_channel_bits", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.copy_channel_bits", true, true);
#ifndef NDEBUG
    if (param4 < 0 || param4 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param4);
    }
#endif
    if (param1_this != NULL) {
      (*local_this).copy_channel_bits(*param1_this, (int)param2, (int)param3, (xelval)param4, (int)param5);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_channel_bits(const PNMImage self, const PNMImage copy, int src_channel, int dest_channel, int src_mask, int right_shift)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_copy_channel_bits_233_comment =
  "C++ Interface:\n"
  "copy_channel_bits(const PNMImage self, const PNMImage copy, int src_channel, int dest_channel, int src_mask, int right_shift)\n"
  "\n"
  "/**\n"
  " * Copies some subset of the bits of the specified channel from one image into\n"
  " * some subset of the bits of the specified channel in another image.  Images\n"
  " * must be the same size.\n"
  " *\n"
  " * If right_shift is negative, it means a left shift.\n"
  " */";
#else
static const char *Dtool_PNMImage_copy_channel_bits_233_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::copy_header_from(PNMImageHeader const &header)
 */
static PyObject *Dtool_PNMImage_copy_header_from_234(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.copy_header_from")) {
    return NULL;
  }
  // 1-void PNMImage::copy_header_from(PNMImageHeader const &header)
  PNMImageHeader const *arg_this = (PNMImageHeader *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImageHeader, 1, "PNMImage.copy_header_from", true, true);
  if (arg_this != NULL) {
    (*local_this).copy_header_from(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_header_from(const PNMImage self, const PNMImageHeader header)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_copy_header_from_234_comment =
  "C++ Interface:\n"
  "copy_header_from(const PNMImage self, const PNMImageHeader header)\n"
  "\n"
  "/**\n"
  " * Copies just the header information into this image.  This will blow away\n"
  " * any image data stored in the image.  The new image data will be allocated,\n"
  " * but left unitialized.\n"
  " */";
#else
static const char *Dtool_PNMImage_copy_header_from_234_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::take_from(PNMImage &orig)
 */
static PyObject *Dtool_PNMImage_take_from_235(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.take_from")) {
    return NULL;
  }
  // 1-void PNMImage::take_from(PNMImage &orig)
  PNMImage *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 1, "PNMImage.take_from", false, true);
  if (arg_this != NULL) {
    (*local_this).take_from(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "take_from(const PNMImage self, PNMImage orig)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_take_from_235_comment =
  "C++ Interface:\n"
  "take_from(const PNMImage self, PNMImage orig)\n"
  "\n"
  "/**\n"
  " * Move the contents of the other image into this one, and empty the other\n"
  " * image.\n"
  " */";
#else
static const char *Dtool_PNMImage_take_from_235_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::fill(float gray = 0.0)
 * inline void PNMImage::fill(float red, float green, float blue)
 */
static PyObject *Dtool_PNMImage_fill_236(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.fill")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void PNMImage::fill(float gray)
      (*local_this).fill();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "gray");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'gray' (pos 1) not found");
      }
      // 1-inline void PNMImage::fill(float gray)
      if (PyNumber_Check(arg)) {
        (*local_this).fill((float)PyFloat_AsDouble(arg));
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void PNMImage::fill(float red, float green, float blue)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"red", "green", "blue", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:fill", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).fill((float)param1, (float)param2, (float)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "fill() takes 1, 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill(const PNMImage self)\n"
      "fill(const PNMImage self, float gray)\n"
      "fill(const PNMImage self, float red, float green, float blue)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_fill_236_comment =
  "C++ Interface:\n"
  "fill(const PNMImage self)\n"
  "fill(const PNMImage self, float gray)\n"
  "fill(const PNMImage self, float red, float green, float blue)\n"
  "\n"
  "/**\n"
  " * Sets the entire image (except the alpha channel) to the given color.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the entire image (except the alpha channel) to the given grayscale\n"
  " * level.\n"
  " */";
#else
static const char *Dtool_PNMImage_fill_236_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::fill_val(xelval gray = 0)
 * void PNMImage::fill_val(xelval red, xelval green, xelval blue)
 */
static PyObject *Dtool_PNMImage_fill_val_237(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.fill_val")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void PNMImage::fill_val(xelval gray)
      (*local_this).fill_val();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "gray");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'gray' (pos 1) not found");
      }
      // 1-inline void PNMImage::fill_val(xelval gray)
      if (PyLongOrInt_Check(arg)) {
        long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
        if (param1 < 0 || param1 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param1);
        }
#endif
        (*local_this).fill_val((xelval)param1);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-void PNMImage::fill_val(xelval red, xelval green, xelval blue)
      long param1;
      long param2;
      long param3;
      static const char *keyword_list[] = {"red", "green", "blue", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "lll:fill_val", (char **)keyword_list, &param1, &param2, &param3)) {
#ifndef NDEBUG
        if (param1 < 0 || param1 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param1);
        }
#endif
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param2);
        }
#endif
#ifndef NDEBUG
        if (param3 < 0 || param3 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param3);
        }
#endif
        (*local_this).fill_val((xelval)param1, (xelval)param2, (xelval)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "fill_val() takes 1, 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill_val(const PNMImage self)\n"
      "fill_val(const PNMImage self, int gray)\n"
      "fill_val(const PNMImage self, int red, int green, int blue)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_fill_val_237_comment =
  "C++ Interface:\n"
  "fill_val(const PNMImage self)\n"
  "fill_val(const PNMImage self, int gray)\n"
  "fill_val(const PNMImage self, int red, int green, int blue)\n"
  "\n"
  "/**\n"
  " * Sets the entire image (except the alpha channel) to the given grayscale\n"
  " * level.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the entire image (except the alpha channel) to the given color.\n"
  " */";
#else
static const char *Dtool_PNMImage_fill_val_237_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::alpha_fill(float alpha = 0.0)
 */
static PyObject *Dtool_PNMImage_alpha_fill_238(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.alpha_fill")) {
    return NULL;
  }
  // 1-inline void PNMImage::alpha_fill(float alpha = 0.0)
  float param1 = 0.0;
  static const char *keyword_list[] = {"alpha", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|f:alpha_fill", (char **)keyword_list, &param1)) {
    (*local_this).alpha_fill((float)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "alpha_fill(const PNMImage self, float alpha)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_alpha_fill_238_comment =
  "C++ Interface:\n"
  "alpha_fill(const PNMImage self, float alpha)\n"
  "\n"
  "/**\n"
  " * Sets the entire alpha channel to the given level.\n"
  " */";
#else
static const char *Dtool_PNMImage_alpha_fill_238_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::alpha_fill_val(xelval alpha = 0)
 */
static PyObject *Dtool_PNMImage_alpha_fill_val_239(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.alpha_fill_val")) {
    return NULL;
  }
  // 1-void PNMImage::alpha_fill_val(xelval alpha = 0)
  long param1 = 0;
  static const char *keyword_list[] = {"alpha", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|l:alpha_fill_val", (char **)keyword_list, &param1)) {
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    (*local_this).alpha_fill_val((xelval)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "alpha_fill_val(const PNMImage self, int alpha)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_alpha_fill_val_239_comment =
  "C++ Interface:\n"
  "alpha_fill_val(const PNMImage self, int alpha)\n"
  "\n"
  "/**\n"
  " * Sets the entire alpha channel to the given level.\n"
  " */";
#else
static const char *Dtool_PNMImage_alpha_fill_val_239_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_read_size(int x_size, int y_size)
 */
static PyObject *Dtool_PNMImage_set_read_size_240(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_read_size")) {
    return NULL;
  }
  // 1-inline void PNMImage::set_read_size(int x_size, int y_size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"x_size", "y_size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_read_size", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_read_size((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_read_size(const PNMImage self, int x_size, int y_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_read_size_240_comment =
  "C++ Interface:\n"
  "set_read_size(const PNMImage self, int x_size, int y_size)\n"
  "\n"
  "/**\n"
  " * Specifies the size to we'd like to scale the image upon reading it.  This\n"
  " * will affect the next call to read().  This is usually used to reduce the\n"
  " * image size, e.g.  for a thumbnail.\n"
  " *\n"
  " * If the file type reader supports it (e.g.  JPEG), then this will scale the\n"
  " * image during the read operation, consequently reducing memory and CPU\n"
  " * utilization.  If the file type reader does not support it, this will load\n"
  " * the image normally, and them perform a linear scale after it has been\n"
  " * loaded.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_read_size_240_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::clear_read_size(void)
 */
static PyObject *Dtool_PNMImage_clear_read_size_241(PyObject *self, PyObject *) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.clear_read_size")) {
    return NULL;
  }
  // 1-inline void PNMImage::clear_read_size(void)
  (*local_this).clear_read_size();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_clear_read_size_241_comment =
  "C++ Interface:\n"
  "clear_read_size(const PNMImage self)\n"
  "\n"
  "/**\n"
  " * Undoes the effect of a previous call to set_read_size().\n"
  " */";
#else
static const char *Dtool_PNMImage_clear_read_size_241_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PNMImage::has_read_size(void) const
 */
static PyObject *Dtool_PNMImage_has_read_size_242(PyObject *self, PyObject *) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PNMImage::has_read_size(void) const
  bool return_value = (*(const PNMImage*)local_this).has_read_size();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_has_read_size_242_comment =
  "C++ Interface:\n"
  "has_read_size(PNMImage self)\n"
  "\n"
  "/**\n"
  " * Returns true if set_read_size() has been called.\n"
  " */";
#else
static const char *Dtool_PNMImage_has_read_size_242_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PNMImage::get_read_x_size(void) const
 */
static PyObject *Dtool_PNMImage_get_read_x_size_243(PyObject *self, PyObject *) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PNMImage::get_read_x_size(void) const
  int return_value = (*(const PNMImage*)local_this).get_read_x_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_read_x_size_243_comment =
  "C++ Interface:\n"
  "get_read_x_size(PNMImage self)\n"
  "\n"
  "/**\n"
  " * Returns the requested x_size of the image if set_read_size() has been\n"
  " * called, or the image x_size otherwise (if it is known).\n"
  " */";
#else
static const char *Dtool_PNMImage_get_read_x_size_243_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PNMImage::get_read_y_size(void) const
 */
static PyObject *Dtool_PNMImage_get_read_y_size_244(PyObject *self, PyObject *) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PNMImage::get_read_y_size(void) const
  int return_value = (*(const PNMImage*)local_this).get_read_y_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_read_y_size_244_comment =
  "C++ Interface:\n"
  "get_read_y_size(PNMImage self)\n"
  "\n"
  "/**\n"
  " * Returns the requested y_size of the image if set_read_size() has been\n"
  " * called, or the image y_size otherwise (if it is known).\n"
  " */";
#else
static const char *Dtool_PNMImage_get_read_y_size_244_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ColorSpace PNMImage::get_color_space(void) const
 */
static PyObject *Dtool_PNMImage_get_color_space_245(PyObject *self, PyObject *) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ColorSpace PNMImage::get_color_space(void) const
  ColorSpace return_value = (*(const PNMImage*)local_this).get_color_space();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_color_space_245_comment =
  "C++ Interface:\n"
  "get_color_space(PNMImage self)\n"
  "\n"
  "/**\n"
  " * Returns the color space in which the image is encoded.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_color_space_245_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PNMImage::read(Filename const &filename, PNMFileType *type = 0, bool report_unknown_type = true)
 * Rejected Remap [bool PNMImage::read(PNMReader *reader)]
 * bool PNMImage::read(istream &data, std::string const &filename = string(), PNMFileType *type = 0, bool report_unknown_type = true)
 */
static PyObject *Dtool_PNMImage_read_246(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.read")) {
    return NULL;
  }
  {
    // -2 bool PNMImage::read(istream &data, std::string const &filename = string(), PNMFileType *type = 0, bool report_unknown_type = true)
    PyObject *param1;
    const char *param2_str = "";
    Py_ssize_t param2_len = 0;
    PyObject *param3 = NULL;
    PyObject *param4 = Py_True;
    static const char *keyword_list[] = {"data", "filename", "type", "report_unknown_type", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#OO:read", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3, &param4)) {
      istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_istream, 1, "PNMImage.read", false, false);
      PNMFileType *param3_this = 0;
      if (param3 != (PyObject *)NULL) {
        param3_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_PNMFileType, 3, "PNMImage.read", false, false);
      }
      if (param1_this != NULL && (param3 == NULL || param3_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*local_this).read(*param1_this, std::string(param2_str, param2_len), param3_this, (PyObject_IsTrue(param4) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool PNMImage::read(istream &data, std::string const &filename = string(), PNMFileType *type = 0, bool report_unknown_type = true)
  {
    // -2 bool PNMImage::read(Filename const &filename, PNMFileType *type = 0, bool report_unknown_type = true)
    PyObject *param1;
    PyObject *param2 = NULL;
    PyObject *param3 = Py_True;
    static const char *keyword_list[] = {"filename", "type", "report_unknown_type", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|OO:read", (char **)keyword_list, &param1, &param2, &param3)) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      PNMFileType *param2_this = 0;
      if (param2 != (PyObject *)NULL) {
        param2_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PNMFileType, 2, "PNMImage.read", false, false);
      }
      if ((param1_this != NULL) && (param2 == NULL || param2_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*local_this).read(*param1_this, param2_this, (PyObject_IsTrue(param3) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read(const PNMImage self, istream data, str filename, PNMFileType type, bool report_unknown_type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_read_246_comment =
  "C++ Interface:\n"
  "read(const PNMImage self, istream data, str filename, PNMFileType type, bool report_unknown_type)\n"
  "\n"
  "/**\n"
  " * Reads the indicated image filename.  If type is non-NULL, it is a\n"
  " * suggestion for the type of file it is.  Returns true if successful, false\n"
  " * on error.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Reads the image data from the indicated stream.\n"
  " *\n"
  " * The filename is advisory only, and may be used to suggest a type if it has\n"
  " * a known extension.\n"
  " *\n"
  " * If type is non-NULL, it is a suggestion for the type of file it is (and a\n"
  " * non-NULL type will override any magic number test or filename extension\n"
  " * lookup).\n"
  " *\n"
  " * Returns true if successful, false on error.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of read() uses an already-existing PNMReader to read the image\n"
  " * file.  You can get a reader via the PNMImageHeader::make_reader() methods.\n"
  " * This is a good way to examine the header of a file (for instance, to\n"
  " * determine its size) before actually reading the entire image.\n"
  " *\n"
  " * The PNMReader is always deleted upon completion, whether successful or not.\n"
  " */";
#else
static const char *Dtool_PNMImage_read_246_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PNMImage::write(Filename const &filename, PNMFileType *type = 0) const
 * Rejected Remap [bool PNMImage::write(PNMWriter *writer) const]
 * bool PNMImage::write(ostream &data, std::string const &filename = string(), PNMFileType *type = 0) const
 */
static PyObject *Dtool_PNMImage_write_247(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 bool PNMImage::write(ostream &data, std::string const &filename = string(), PNMFileType *type = 0) const
    PyObject *param1;
    const char *param2_str = "";
    Py_ssize_t param2_len = 0;
    PyObject *param3 = NULL;
    static const char *keyword_list[] = {"data", "filename", "type", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#O:write", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3)) {
      ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "PNMImage.write", false, false);
      PNMFileType *param3_this = 0;
      if (param3 != (PyObject *)NULL) {
        param3_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_PNMFileType, 3, "PNMImage.write", false, false);
      }
      if (param1_this != NULL && (param3 == NULL || param3_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*(const PNMImage*)local_this).write(*param1_this, std::string(param2_str, param2_len), param3_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool PNMImage::write(ostream &data, std::string const &filename = string(), PNMFileType *type = 0) const
  {
    // -2 bool PNMImage::write(Filename const &filename, PNMFileType *type = 0) const
    PyObject *param1;
    PyObject *param2 = NULL;
    static const char *keyword_list[] = {"filename", "type", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:write", (char **)keyword_list, &param1, &param2)) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      PNMFileType *param2_this = 0;
      if (param2 != (PyObject *)NULL) {
        param2_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PNMFileType, 2, "PNMImage.write", false, false);
      }
      if ((param1_this != NULL) && (param2 == NULL || param2_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*(const PNMImage*)local_this).write(*param1_this, param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(PNMImage self, ostream data, str filename, PNMFileType type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_write_247_comment =
  "C++ Interface:\n"
  "write(PNMImage self, ostream data, str filename, PNMFileType type)\n"
  "\n"
  "/**\n"
  " * Writes the image to the indicated filename.  If type is non-NULL, it is a\n"
  " * suggestion for the type of image file to write.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Writes the image to the indicated ostream.\n"
  " *\n"
  " * The filename is advisory only, and may be used suggest a type if it has a\n"
  " * known extension.\n"
  " *\n"
  " * If type is non-NULL, it is a suggestion for the type of image file to\n"
  " * write.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of write() uses an already-existing PNMWriter to write the\n"
  " * image file.  You can get a writer via the PNMImageHeader::make_writer()\n"
  " * methods.\n"
  " *\n"
  " * The PNMWriter is always deleted upon completion, whether successful or not.\n"
  " */";
#else
static const char *Dtool_PNMImage_write_247_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PNMImage::is_valid(void) const
 */
static PyObject *Dtool_PNMImage_is_valid_248(PyObject *self, PyObject *) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PNMImage::is_valid(void) const
  bool return_value = (*(const PNMImage*)local_this).is_valid();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_is_valid_248_comment =
  "C++ Interface:\n"
  "is_valid(PNMImage self)\n"
  "\n"
  "/**\n"
  " * Returns true if the image has been read in or correctly initialized with a\n"
  " * height and width.  If this returns false, virtually all member functions\n"
  " * except clear() and read() are invalid function calls.\n"
  " */";
#else
static const char *Dtool_PNMImage_is_valid_248_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_num_channels(int num_channels)
 */
static PyObject *Dtool_PNMImage_set_num_channels_249(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_num_channels")) {
    return NULL;
  }
  // 1-inline void PNMImage::set_num_channels(int num_channels)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_num_channels((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_channels(const PNMImage self, int num_channels)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_num_channels_249_comment =
  "C++ Interface:\n"
  "set_num_channels(const PNMImage self, int num_channels)\n"
  "\n"
  "/**\n"
  " * Changes the number of channels associated with the image.  The new number\n"
  " * of channels must be an integer in the range 1 through 4, inclusive.  This\n"
  " * will allocate and/or deallocate memory as necessary to accommodate; see\n"
  " * set_color_type().\n"
  " */";
#else
static const char *Dtool_PNMImage_set_num_channels_249_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::set_color_type(PNMImageHeader::ColorType color_type)
 */
static PyObject *Dtool_PNMImage_set_color_type_250(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_color_type")) {
    return NULL;
  }
  // 1-void PNMImage::set_color_type(PNMImageHeader::ColorType color_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_color_type((PNMImageHeader::ColorType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color_type(const PNMImage self, int color_type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_color_type_250_comment =
  "C++ Interface:\n"
  "set_color_type(const PNMImage self, int color_type)\n"
  "\n"
  "/**\n"
  " * Translates the image to or from grayscale, color, or four-color mode.\n"
  " * Grayscale images are converted to full-color images with R, G, B set to the\n"
  " * original gray level; color images are converted to grayscale according to\n"
  " * the value of Bright().  The alpha channel, if added, is initialized to\n"
  " * zero.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_color_type_250_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::set_color_space(ColorSpace color_space)
 */
static PyObject *Dtool_PNMImage_set_color_space_251(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_color_space")) {
    return NULL;
  }
  // 1-void PNMImage::set_color_space(ColorSpace color_space)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_color_space((ColorSpace)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color_space(const PNMImage self, int color_space)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_color_space_251_comment =
  "C++ Interface:\n"
  "set_color_space(const PNMImage self, int color_space)\n"
  "\n"
  "/**\n"
  " * Converts the colors in the image to the indicated color space.  This may be\n"
  " * a lossy operation, in particular when going from sRGB to linear.  The alpha\n"
  " * channel remains untouched.\n"
  " *\n"
  " * Note that, because functions like get_xel() and set_xel() work on\n"
  " * linearized floating-point values, this conversion won't affect those values\n"
  " * (aside from some minor discrepancies due to storage precision).  It does\n"
  " * affect the values used by get_xel_val() and set_xel_val(), though, since\n"
  " * those operate on encoded colors.\n"
  " *\n"
  " * Some color spaces, particularly scRGB, may enforce the use of a particular\n"
  " * maxval setting.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_color_space_251_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::add_alpha(void)
 */
static PyObject *Dtool_PNMImage_add_alpha_252(PyObject *self, PyObject *) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.add_alpha")) {
    return NULL;
  }
  // 1-inline void PNMImage::add_alpha(void)
  (*local_this).add_alpha();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_add_alpha_252_comment =
  "C++ Interface:\n"
  "add_alpha(const PNMImage self)\n"
  "\n"
  "/**\n"
  " * Adds an alpha channel to the image, if it does not already have one.  The\n"
  " * alpha channel is initialized to zeros.\n"
  " */";
#else
static const char *Dtool_PNMImage_add_alpha_252_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::remove_alpha(void)
 */
static PyObject *Dtool_PNMImage_remove_alpha_253(PyObject *self, PyObject *) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.remove_alpha")) {
    return NULL;
  }
  // 1-inline void PNMImage::remove_alpha(void)
  (*local_this).remove_alpha();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_remove_alpha_253_comment =
  "C++ Interface:\n"
  "remove_alpha(const PNMImage self)\n"
  "\n"
  "/**\n"
  " * Removes the image's alpha channel, if it exists.\n"
  " */";
#else
static const char *Dtool_PNMImage_remove_alpha_253_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::make_grayscale(void)
 * void PNMImage::make_grayscale(float rc, float gc, float bc)
 */
static PyObject *Dtool_PNMImage_make_grayscale_254(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.make_grayscale")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void PNMImage::make_grayscale(void)
      (*local_this).make_grayscale();
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-void PNMImage::make_grayscale(float rc, float gc, float bc)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"rc", "gc", "bc", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:make_grayscale", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).make_grayscale((float)param1, (float)param2, (float)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make_grayscale() takes 1 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_grayscale(const PNMImage self)\n"
      "make_grayscale(const PNMImage self, float rc, float gc, float bc)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_make_grayscale_254_comment =
  "C++ Interface:\n"
  "make_grayscale(const PNMImage self)\n"
  "make_grayscale(const PNMImage self, float rc, float gc, float bc)\n"
  "\n"
  "/**\n"
  " * Converts the image from RGB to grayscale.  Any alpha channel, if present,\n"
  " * is left undisturbed.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Converts the image from RGB to grayscale.  Any alpha channel, if present,\n"
  " * is left undisturbed.  The optional rc, gc, bc values represent the relative\n"
  " * weights to apply to each channel to convert it to grayscale.\n"
  " */";
#else
static const char *Dtool_PNMImage_make_grayscale_254_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::make_rgb(void)
 */
static PyObject *Dtool_PNMImage_make_rgb_255(PyObject *self, PyObject *) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.make_rgb")) {
    return NULL;
  }
  // 1-inline void PNMImage::make_rgb(void)
  (*local_this).make_rgb();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_make_rgb_255_comment =
  "C++ Interface:\n"
  "make_rgb(const PNMImage self)\n"
  "\n"
  "/**\n"
  " * Converts the image from grayscale to RGB.  Any alpha channel, if present,\n"
  " * is left undisturbed.\n"
  " */";
#else
static const char *Dtool_PNMImage_make_rgb_255_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::premultiply_alpha(void)
 */
static PyObject *Dtool_PNMImage_premultiply_alpha_256(PyObject *self, PyObject *) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.premultiply_alpha")) {
    return NULL;
  }
  // 1-void PNMImage::premultiply_alpha(void)
  (*local_this).premultiply_alpha();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_premultiply_alpha_256_comment =
  "C++ Interface:\n"
  "premultiply_alpha(const PNMImage self)\n"
  "\n"
  "/**\n"
  " * Converts an image in-place to its \"premultiplied\" form, where, for every\n"
  " * pixel in the image, the red, green, and blue components are multiplied by\n"
  " * that pixel's alpha value.\n"
  " *\n"
  " * This does not modify any alpha values.\n"
  " */";
#else
static const char *Dtool_PNMImage_premultiply_alpha_256_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::unpremultiply_alpha(void)
 */
static PyObject *Dtool_PNMImage_unpremultiply_alpha_257(PyObject *self, PyObject *) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.unpremultiply_alpha")) {
    return NULL;
  }
  // 1-void PNMImage::unpremultiply_alpha(void)
  (*local_this).unpremultiply_alpha();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_unpremultiply_alpha_257_comment =
  "C++ Interface:\n"
  "unpremultiply_alpha(const PNMImage self)\n"
  "\n"
  "/**\n"
  " * Converts an image in-place to its \"straight alpha\" form (presumably from a\n"
  " * \"premultiplied\" form), where, for every pixel in the image, the red, green,\n"
  " * and blue components are divided by that pixel's alpha value.\n"
  " *\n"
  " * This does not modify any alpha values.\n"
  " */";
#else
static const char *Dtool_PNMImage_unpremultiply_alpha_257_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::reverse_rows(void)
 */
static PyObject *Dtool_PNMImage_reverse_rows_258(PyObject *self, PyObject *) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.reverse_rows")) {
    return NULL;
  }
  // 1-void PNMImage::reverse_rows(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).reverse_rows();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_reverse_rows_258_comment =
  "C++ Interface:\n"
  "reverse_rows(const PNMImage self)\n"
  "\n"
  "/**\n"
  " * Performs an in-place reversal of the row (y) data.\n"
  " */";
#else
static const char *Dtool_PNMImage_reverse_rows_258_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::flip(bool flip_x, bool flip_y, bool transpose)
 */
static PyObject *Dtool_PNMImage_flip_259(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.flip")) {
    return NULL;
  }
  // 1-void PNMImage::flip(bool flip_x, bool flip_y, bool transpose)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"flip_x", "flip_y", "transpose", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:flip", (char **)keyword_list, &param1, &param2, &param3)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).flip((PyObject_IsTrue(param1) != 0), (PyObject_IsTrue(param2) != 0), (PyObject_IsTrue(param3) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "flip(const PNMImage self, bool flip_x, bool flip_y, bool transpose)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_flip_259_comment =
  "C++ Interface:\n"
  "flip(const PNMImage self, bool flip_x, bool flip_y, bool transpose)\n"
  "\n"
  "/**\n"
  " * Reverses, transposes, and/or rotates the image in-place according to the\n"
  " * specified parameters.  If flip_x is true, the x axis is reversed; if flip_y\n"
  " * is true, the y axis is reversed.  Then, if transpose is true, the x and y\n"
  " * axes are exchanged.  These parameters can be used to select any combination\n"
  " * of 90-degree or 180-degree rotations and flips.\n"
  " */";
#else
static const char *Dtool_PNMImage_flip_259_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::set_maxval(xelval maxval)
 */
static PyObject *Dtool_PNMImage_set_maxval_260(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_maxval")) {
    return NULL;
  }
  // 1-void PNMImage::set_maxval(xelval maxval)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).set_maxval((xelval)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_maxval(const PNMImage self, int maxval)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_maxval_260_comment =
  "C++ Interface:\n"
  "set_maxval(const PNMImage self, int maxval)\n"
  "\n"
  "/**\n"
  " * Rescales the image to the indicated maxval.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_maxval_260_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline xel &PNMImage::get_xel_val(int x, int y)
 * inline xel PNMImage::get_xel_val(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_xel_val_261(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 inline xel &PNMImage::get_xel_val(int x, int y)
    int param1;
    int param2;
    static const char *keyword_list[] = {"x", "y", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_xel_val", (char **)keyword_list, &param1, &param2)) {
      xel *return_value = &((*local_this).get_xel_val((int)param1, (int)param2));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_pixel, false, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline xel PNMImage::get_xel_val(int x, int y) const
    int param1;
    int param2;
    static const char *keyword_list[] = {"x", "y", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_xel_val", (char **)keyword_list, &param1, &param2)) {
      xel *return_value = new xel((*(const PNMImage*)local_this).get_xel_val((int)param1, (int)param2));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_pixel, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: inline xel &PNMImage::get_xel_val(int x, int y)
  // No coercion possible: inline xel PNMImage::get_xel_val(int x, int y) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_xel_val(const PNMImage self, int x, int y)\n"
      "get_xel_val(PNMImage self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_xel_val_261_comment =
  "C++ Interface:\n"
  "get_xel_val(const PNMImage self, int x, int y)\n"
  "get_xel_val(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the RGB color at the indicated pixel.  Each component is in the\n"
  " * range 0..maxval.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the RGB color at the indicated pixel.  Each component is in the\n"
  " * range 0..maxval.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_xel_val_261_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_xel_val(int x, int y, xel const &value)
 * inline void PNMImage::set_xel_val(int x, int y, xelval gray)
 * inline void PNMImage::set_xel_val(int x, int y, xelval r, xelval g, xelval b)
 */
static PyObject *Dtool_PNMImage_set_xel_val_262(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_xel_val")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      {
        // -2 inline void PNMImage::set_xel_val(int x, int y, xel const &value)
        int param1;
        int param2;
        PyObject *param3;
        static const char *keyword_list[] = {"x", "y", "value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_xel_val", (char **)keyword_list, &param1, &param2, &param3)) {
          xel const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_pixel, (void **)&param3_this);
          if (param3_this != NULL) {
            (*local_this).set_xel_val((int)param1, (int)param2, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void PNMImage::set_xel_val(int x, int y, xelval gray)
        int param1;
        int param2;
        long param3;
        static const char *keyword_list[] = {"x", "y", "gray", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "iil:set_xel_val", (char **)keyword_list, &param1, &param2, &param3)) {
#ifndef NDEBUG
          if (param3 < 0 || param3 > USHRT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for unsigned short integer",
                                param3);
          }
#endif
          (*local_this).set_xel_val((int)param1, (int)param2, (xelval)param3);
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      {
        // -2 inline void PNMImage::set_xel_val(int x, int y, xel const &value)
        int param1;
        int param2;
        PyObject *param3;
        static const char *keyword_list[] = {"x", "y", "value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_xel_val", (char **)keyword_list, &param1, &param2, &param3)) {
          pixel param3_local;
          xel const *param3_this = Dtool_Coerce_pixel(param3, param3_local);
          if ((param3_this != NULL)) {
            (*local_this).set_xel_val((int)param1, (int)param2, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void PNMImage::set_xel_val(int x, int y, xelval gray)
    }
    break;
  case 5:
    {
      // 1-inline void PNMImage::set_xel_val(int x, int y, xelval r, xelval g, xelval b)
      int param1;
      int param2;
      long param3;
      long param4;
      long param5;
      static const char *keyword_list[] = {"x", "y", "r", "g", "b", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iilll:set_xel_val", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
#ifndef NDEBUG
        if (param3 < 0 || param3 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param3);
        }
#endif
#ifndef NDEBUG
        if (param4 < 0 || param4 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param4);
        }
#endif
#ifndef NDEBUG
        if (param5 < 0 || param5 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param5);
        }
#endif
        (*local_this).set_xel_val((int)param1, (int)param2, (xelval)param3, (xelval)param4, (xelval)param5);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_xel_val() takes 4 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_xel_val(const PNMImage self, int x, int y, const pixel value)\n"
      "set_xel_val(const PNMImage self, int x, int y, int gray)\n"
      "set_xel_val(const PNMImage self, int x, int y, int r, int g, int b)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_xel_val_262_comment =
  "C++ Interface:\n"
  "set_xel_val(const PNMImage self, int x, int y, const pixel value)\n"
  "set_xel_val(const PNMImage self, int x, int y, int gray)\n"
  "set_xel_val(const PNMImage self, int x, int y, int r, int g, int b)\n"
  "\n"
  "/**\n"
  " * Changes the RGB color at the indicated pixel.  Each component is in the\n"
  " * range 0..maxval, encoded in the configured color space.  See set_xel if you\n"
  " * instead have a linearized and normalized floating-point value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the RGB color at the indicated pixel.  Each component is in the\n"
  " * range 0..maxval, encoded in the configured color space.  See set_xel if you\n"
  " * instead have a linearized and normalized floating-point value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes all three color components at the indicated pixel to the same\n"
  " * value.  The value is in the range component is in the range 0..maxval,\n"
  " * encoded in the configured color space.  See set_xel if you instead have a\n"
  " * linearized and normalized floating-point value.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_xel_val_262_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImage::get_red_val(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_red_val_263(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline xelval PNMImage::get_red_val(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_red_val", (char **)keyword_list, &param1, &param2)) {
    xelval return_value = (*(const PNMImage*)local_this).get_red_val((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_red_val(PNMImage self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_red_val_263_comment =
  "C++ Interface:\n"
  "get_red_val(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the red component color at the indicated pixel.  The value returned\n"
  " * is in the range 0..maxval and encoded in the configured color space.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_red_val_263_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImage::get_green_val(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_green_val_264(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline xelval PNMImage::get_green_val(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_green_val", (char **)keyword_list, &param1, &param2)) {
    xelval return_value = (*(const PNMImage*)local_this).get_green_val((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_green_val(PNMImage self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_green_val_264_comment =
  "C++ Interface:\n"
  "get_green_val(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the green component color at the indicated pixel.  The value\n"
  " * returned is in the range 0..maxval and encoded in the configured color\n"
  " * space.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_green_val_264_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImage::get_blue_val(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_blue_val_265(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline xelval PNMImage::get_blue_val(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_blue_val", (char **)keyword_list, &param1, &param2)) {
    xelval return_value = (*(const PNMImage*)local_this).get_blue_val((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_blue_val(PNMImage self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_blue_val_265_comment =
  "C++ Interface:\n"
  "get_blue_val(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the blue component color at the indicated pixel.  The value\n"
  " * returned is in the range 0..maxval and encoded in the configured color\n"
  " * space.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_blue_val_265_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImage::get_gray_val(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_gray_val_266(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline xelval PNMImage::get_gray_val(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_gray_val", (char **)keyword_list, &param1, &param2)) {
    xelval return_value = (*(const PNMImage*)local_this).get_gray_val((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_gray_val(PNMImage self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_gray_val_266_comment =
  "C++ Interface:\n"
  "get_gray_val(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the gray component color at the indicated pixel.  This only has a\n"
  " * meaningful value for grayscale images; for other image types, this returns\n"
  " * the value of the blue channel only.  However, also see the get_bright()\n"
  " * function.  The value returned is in the range 0..maxval and encoded in the\n"
  " * configured color space.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_gray_val_266_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImage::get_alpha_val(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_alpha_val_267(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline xelval PNMImage::get_alpha_val(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_alpha_val", (char **)keyword_list, &param1, &param2)) {
    xelval return_value = (*(const PNMImage*)local_this).get_alpha_val((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_alpha_val(PNMImage self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_alpha_val_267_comment =
  "C++ Interface:\n"
  "get_alpha_val(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the alpha component color at the indicated pixel.  It is an error\n"
  " * to call this unless has_alpha() is true.  The value returned is in the\n"
  " * range 0..maxval and always linear.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_alpha_val_267_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_red_val(int x, int y, xelval r)
 */
static PyObject *Dtool_PNMImage_set_red_val_268(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_red_val")) {
    return NULL;
  }
  // 1-inline void PNMImage::set_red_val(int x, int y, xelval r)
  int param1;
  int param2;
  long param3;
  static const char *keyword_list[] = {"x", "y", "r", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iil:set_red_val", (char **)keyword_list, &param1, &param2, &param3)) {
#ifndef NDEBUG
    if (param3 < 0 || param3 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param3);
    }
#endif
    (*local_this).set_red_val((int)param1, (int)param2, (xelval)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_red_val(const PNMImage self, int x, int y, int r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_red_val_268_comment =
  "C++ Interface:\n"
  "set_red_val(const PNMImage self, int x, int y, int r)\n"
  "\n"
  "/**\n"
  " * Sets the red component color only at the indicated pixel.  The value given\n"
  " * should be in the range 0..maxval, encoded in the configured color space.\n"
  " * See set_red if you instead have a linearized and normalized floating-point\n"
  " * value.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_red_val_268_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_green_val(int x, int y, xelval g)
 */
static PyObject *Dtool_PNMImage_set_green_val_269(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_green_val")) {
    return NULL;
  }
  // 1-inline void PNMImage::set_green_val(int x, int y, xelval g)
  int param1;
  int param2;
  long param3;
  static const char *keyword_list[] = {"x", "y", "g", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iil:set_green_val", (char **)keyword_list, &param1, &param2, &param3)) {
#ifndef NDEBUG
    if (param3 < 0 || param3 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param3);
    }
#endif
    (*local_this).set_green_val((int)param1, (int)param2, (xelval)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_green_val(const PNMImage self, int x, int y, int g)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_green_val_269_comment =
  "C++ Interface:\n"
  "set_green_val(const PNMImage self, int x, int y, int g)\n"
  "\n"
  "/**\n"
  " * Sets the green component color only at the indicated pixel.  The value\n"
  " * given should be in the range 0..maxval, encoded in the configured color\n"
  " * space.  See set_green if you instead have a linearized and normalized\n"
  " * floating-point value.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_green_val_269_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_blue_val(int x, int y, xelval b)
 */
static PyObject *Dtool_PNMImage_set_blue_val_270(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_blue_val")) {
    return NULL;
  }
  // 1-inline void PNMImage::set_blue_val(int x, int y, xelval b)
  int param1;
  int param2;
  long param3;
  static const char *keyword_list[] = {"x", "y", "b", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iil:set_blue_val", (char **)keyword_list, &param1, &param2, &param3)) {
#ifndef NDEBUG
    if (param3 < 0 || param3 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param3);
    }
#endif
    (*local_this).set_blue_val((int)param1, (int)param2, (xelval)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blue_val(const PNMImage self, int x, int y, int b)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_blue_val_270_comment =
  "C++ Interface:\n"
  "set_blue_val(const PNMImage self, int x, int y, int b)\n"
  "\n"
  "/**\n"
  " * Sets the blue component color only at the indicated pixel.  The value given\n"
  " * should be in the range 0..maxval, encoded in the configured color space.\n"
  " * See set_blue if you instead have a linearized and normalized floating-point\n"
  " * value.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_blue_val_270_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_gray_val(int x, int y, xelval gray)
 */
static PyObject *Dtool_PNMImage_set_gray_val_271(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_gray_val")) {
    return NULL;
  }
  // 1-inline void PNMImage::set_gray_val(int x, int y, xelval gray)
  int param1;
  int param2;
  long param3;
  static const char *keyword_list[] = {"x", "y", "gray", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iil:set_gray_val", (char **)keyword_list, &param1, &param2, &param3)) {
#ifndef NDEBUG
    if (param3 < 0 || param3 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param3);
    }
#endif
    (*local_this).set_gray_val((int)param1, (int)param2, (xelval)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_gray_val(const PNMImage self, int x, int y, int gray)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_gray_val_271_comment =
  "C++ Interface:\n"
  "set_gray_val(const PNMImage self, int x, int y, int gray)\n"
  "\n"
  "/**\n"
  " * Sets the gray component color at the indicated pixel.  This is only\n"
  " * meaningful for grayscale images; for other image types, this simply sets\n"
  " * the blue component color.  However, also see set_xel_val(), which can set\n"
  " * all the component colors to the same grayscale level, and hence works\n"
  " * correctly both for grayscale and color images.  The value given should be\n"
  " * in the range 0..maxval, encoded in the configured color space.  See\n"
  " * set_gray if you instead have a linearized normalized floating-point value.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_gray_val_271_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_alpha_val(int x, int y, xelval a)
 */
static PyObject *Dtool_PNMImage_set_alpha_val_272(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_alpha_val")) {
    return NULL;
  }
  // 1-inline void PNMImage::set_alpha_val(int x, int y, xelval a)
  int param1;
  int param2;
  long param3;
  static const char *keyword_list[] = {"x", "y", "a", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iil:set_alpha_val", (char **)keyword_list, &param1, &param2, &param3)) {
#ifndef NDEBUG
    if (param3 < 0 || param3 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param3);
    }
#endif
    (*local_this).set_alpha_val((int)param1, (int)param2, (xelval)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_val(const PNMImage self, int x, int y, int a)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_alpha_val_272_comment =
  "C++ Interface:\n"
  "set_alpha_val(const PNMImage self, int x, int y, int a)\n"
  "\n"
  "/**\n"
  " * Sets the alpha component color only at the indicated pixel.  It is an error\n"
  " * to call this unless has_alpha() is true.  The value given should be in the\n"
  " * range 0..maxval.\n"
  " *\n"
  " * This value is always linearly encoded, even if the image is set to the sRGB\n"
  " * color space.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_alpha_val_272_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * xelval PNMImage::get_channel_val(int x, int y, int channel) const
 */
static PyObject *Dtool_PNMImage_get_channel_val_273(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-xelval PNMImage::get_channel_val(int x, int y, int channel) const
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"x", "y", "channel", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:get_channel_val", (char **)keyword_list, &param1, &param2, &param3)) {
    xelval return_value = (*(const PNMImage*)local_this).get_channel_val((int)param1, (int)param2, (int)param3);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_channel_val(PNMImage self, int x, int y, int channel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_channel_val_273_comment =
  "C++ Interface:\n"
  "get_channel_val(PNMImage self, int x, int y, int channel)\n"
  "\n"
  "/**\n"
  " * Returns the nth component color at the indicated pixel.  The channel index\n"
  " * should be in the range 0..(get_num_channels()-1).  The channels are ordered\n"
  " * B, G, R, A.  This is slightly less optimal than accessing the component\n"
  " * values directly by named methods.  The value returned is in the range\n"
  " * 0..maxval.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_channel_val_273_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::set_channel_val(int x, int y, int channel, xelval value)
 */
static PyObject *Dtool_PNMImage_set_channel_val_274(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_channel_val")) {
    return NULL;
  }
  // 1-void PNMImage::set_channel_val(int x, int y, int channel, xelval value)
  int param1;
  int param2;
  int param3;
  long param4;
  static const char *keyword_list[] = {"x", "y", "channel", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiil:set_channel_val", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
#ifndef NDEBUG
    if (param4 < 0 || param4 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param4);
    }
#endif
    (*local_this).set_channel_val((int)param1, (int)param2, (int)param3, (xelval)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_channel_val(const PNMImage self, int x, int y, int channel, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_channel_val_274_comment =
  "C++ Interface:\n"
  "set_channel_val(const PNMImage self, int x, int y, int channel, int value)\n"
  "\n"
  "/**\n"
  " * Sets the nth component color at the indicated pixel.  The channel index\n"
  " * should be in the range 0..(get_num_channels()-1).  The channels are ordered\n"
  " * B, G, R, A.  This is slightly less optimal than setting the component\n"
  " * values directly by named methods.  The value given should be in the range\n"
  " * 0..maxval.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_channel_val_274_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * float PNMImage::get_channel(int x, int y, int channel) const
 */
static PyObject *Dtool_PNMImage_get_channel_275(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-float PNMImage::get_channel(int x, int y, int channel) const
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"x", "y", "channel", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:get_channel", (char **)keyword_list, &param1, &param2, &param3)) {
    float return_value = (*(const PNMImage*)local_this).get_channel((int)param1, (int)param2, (int)param3);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_channel(PNMImage self, int x, int y, int channel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_channel_275_comment =
  "C++ Interface:\n"
  "get_channel(PNMImage self, int x, int y, int channel)\n"
  "\n"
  "/**\n"
  " * Returns the nth component color at the indicated pixel.  The channel index\n"
  " * should be in the range 0..(get_num_channels()-1).  The channels are ordered\n"
  " * B, G, R, A.  This is slightly less optimal than accessing the component\n"
  " * values directly by named methods.  The value returned is a float in the\n"
  " * range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_channel_275_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::set_channel(int x, int y, int channel, float value)
 */
static PyObject *Dtool_PNMImage_set_channel_276(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_channel")) {
    return NULL;
  }
  // 1-void PNMImage::set_channel(int x, int y, int channel, float value)
  int param1;
  int param2;
  int param3;
  float param4;
  static const char *keyword_list[] = {"x", "y", "channel", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiif:set_channel", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).set_channel((int)param1, (int)param2, (int)param3, (float)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_channel(const PNMImage self, int x, int y, int channel, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_channel_276_comment =
  "C++ Interface:\n"
  "set_channel(const PNMImage self, int x, int y, int channel, float value)\n"
  "\n"
  "/**\n"
  " * Sets the nth component color at the indicated pixel.  The channel index\n"
  " * should be in the range 0..(get_num_channels()-1).  The channels are ordered\n"
  " * B, G, R, A.  This is slightly less optimal than setting the component\n"
  " * values directly by named methods.  The value given should be a float in the\n"
  " * range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_channel_276_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PNMImageHeader::PixelSpec PNMImage::get_pixel(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_pixel_277(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-PNMImageHeader::PixelSpec PNMImage::get_pixel(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_pixel", (char **)keyword_list, &param1, &param2)) {
    PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec((*(const PNMImage*)local_this).get_pixel((int)param1, (int)param2));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImageHeader_PixelSpec, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pixel(PNMImage self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_pixel_277_comment =
  "C++ Interface:\n"
  "get_pixel(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the (r, g, b, a) pixel value at the indicated pixel, using a\n"
  " * PixelSpec object.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_pixel_277_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::set_pixel(int x, int y, PNMImageHeader::PixelSpec const &pixel)
 */
static PyObject *Dtool_PNMImage_set_pixel_278(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_pixel")) {
    return NULL;
  }
  // 1-void PNMImage::set_pixel(int x, int y, PNMImageHeader::PixelSpec const &pixel)
  int param1;
  int param2;
  PyObject *param3;
  static const char *keyword_list[] = {"x", "y", "pixel", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_pixel", (char **)keyword_list, &param1, &param2, &param3)) {
    PNMImageHeader::PixelSpec const *param3_this;
    bool param3_manage = false;
    if (!Dtool_ConstCoerce_PNMImageHeader_PixelSpec(param3, param3_this, param3_manage)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "PNMImage.set_pixel", "PixelSpec");
    }
    (*local_this).set_pixel((int)param1, (int)param2, *param3_this);
    if (param3_manage) {
      delete param3_this;
    }
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pixel(const PNMImage self, int x, int y, const PixelSpec pixel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_pixel_278_comment =
  "C++ Interface:\n"
  "set_pixel(const PNMImage self, int x, int y, const PixelSpec pixel)\n"
  "\n"
  "/**\n"
  " * Sets the (r, g, b, a) pixel value at the indicated pixel, using a PixelSpec\n"
  " * object.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_pixel_278_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LRGBColorf PNMImage::get_xel(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_xel_279(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LRGBColorf PNMImage::get_xel(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_xel", (char **)keyword_list, &param1, &param2)) {
    LRGBColorf *return_value = new LRGBColorf((*(const PNMImage*)local_this).get_xel((int)param1, (int)param2));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_xel(PNMImage self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_xel_279_comment =
  "C++ Interface:\n"
  "get_xel(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the RGB color at the indicated pixel.  Each component is a\n"
  " * linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_xel_279_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_xel(int x, int y, LRGBColorf const &value)
 * inline void PNMImage::set_xel(int x, int y, float gray)
 * inline void PNMImage::set_xel(int x, int y, float r, float g, float b)
 */
static PyObject *Dtool_PNMImage_set_xel_280(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_xel")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      {
        // -2 inline void PNMImage::set_xel(int x, int y, LRGBColorf const &value)
        int param1;
        int param2;
        PyObject *param3;
        static const char *keyword_list[] = {"x", "y", "value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_xel", (char **)keyword_list, &param1, &param2, &param3)) {
          LRGBColorf const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase3f, (void **)&param3_this);
          if (param3_this != NULL) {
            (*local_this).set_xel((int)param1, (int)param2, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void PNMImage::set_xel(int x, int y, float gray)
        int param1;
        int param2;
        float param3;
        static const char *keyword_list[] = {"x", "y", "gray", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "iif:set_xel", (char **)keyword_list, &param1, &param2, &param3)) {
          (*local_this).set_xel((int)param1, (int)param2, (float)param3);
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      {
        // -2 inline void PNMImage::set_xel(int x, int y, LRGBColorf const &value)
        int param1;
        int param2;
        PyObject *param3;
        static const char *keyword_list[] = {"x", "y", "value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_xel", (char **)keyword_list, &param1, &param2, &param3)) {
          LVecBase3f param3_local;
          LRGBColorf const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
          if ((param3_this != NULL)) {
            (*local_this).set_xel((int)param1, (int)param2, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void PNMImage::set_xel(int x, int y, float gray)
    }
    break;
  case 5:
    {
      // 1-inline void PNMImage::set_xel(int x, int y, float r, float g, float b)
      int param1;
      int param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"x", "y", "r", "g", "b", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iifff:set_xel", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        (*local_this).set_xel((int)param1, (int)param2, (float)param3, (float)param4, (float)param5);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_xel() takes 4 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_xel(const PNMImage self, int x, int y, const LVecBase3f value)\n"
      "set_xel(const PNMImage self, int x, int y, float gray)\n"
      "set_xel(const PNMImage self, int x, int y, float r, float g, float b)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_xel_280_comment =
  "C++ Interface:\n"
  "set_xel(const PNMImage self, int x, int y, const LVecBase3f value)\n"
  "set_xel(const PNMImage self, int x, int y, float gray)\n"
  "set_xel(const PNMImage self, int x, int y, float r, float g, float b)\n"
  "\n"
  "/**\n"
  " * Changes the RGB color at the indicated pixel.  Each component is a\n"
  " * linearized float in the range 0..1.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the RGB color at the indicated pixel.  Each component is a\n"
  " * linearized float in the range 0..1.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes all three color components at the indicated pixel to the same\n"
  " * value.  The value is a linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_xel_280_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColorf PNMImage::get_xel_a(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_xel_a_281(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColorf PNMImage::get_xel_a(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_xel_a", (char **)keyword_list, &param1, &param2)) {
    LColorf *return_value = new LColorf((*(const PNMImage*)local_this).get_xel_a((int)param1, (int)param2));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_xel_a(PNMImage self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_xel_a_281_comment =
  "C++ Interface:\n"
  "get_xel_a(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the RGBA color at the indicated pixel.  Each component is a\n"
  " * linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_xel_a_281_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_xel_a(int x, int y, LColorf const &value)
 * inline void PNMImage::set_xel_a(int x, int y, float r, float g, float b, float a)
 */
static PyObject *Dtool_PNMImage_set_xel_a_282(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_xel_a")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-inline void PNMImage::set_xel_a(int x, int y, LColorf const &value)
      int param1;
      int param2;
      PyObject *param3;
      static const char *keyword_list[] = {"x", "y", "value", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_xel_a", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase4f param3_local;
        LColorf const *param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
        if (!(param3_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "PNMImage.set_xel_a", "LVecBase4f");
        }
        (*local_this).set_xel_a((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void PNMImage::set_xel_a(int x, int y, float r, float g, float b, float a)
      int param1;
      int param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"x", "y", "r", "g", "b", "a", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiffff:set_xel_a", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        (*local_this).set_xel_a((int)param1, (int)param2, (float)param3, (float)param4, (float)param5, (float)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_xel_a() takes 4 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_xel_a(const PNMImage self, int x, int y, const LVecBase4f value)\n"
      "set_xel_a(const PNMImage self, int x, int y, float r, float g, float b, float a)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_xel_a_282_comment =
  "C++ Interface:\n"
  "set_xel_a(const PNMImage self, int x, int y, const LVecBase4f value)\n"
  "set_xel_a(const PNMImage self, int x, int y, float r, float g, float b, float a)\n"
  "\n"
  "/**\n"
  " * Changes the RGBA color at the indicated pixel.  Each component is a\n"
  " * linearized float in the range 0..1.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the RGBA color at the indicated pixel.  Each component is a\n"
  " * linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_xel_a_282_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float PNMImage::get_red(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_red_283(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float PNMImage::get_red(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_red", (char **)keyword_list, &param1, &param2)) {
    float return_value = (*(const PNMImage*)local_this).get_red((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_red(PNMImage self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_red_283_comment =
  "C++ Interface:\n"
  "get_red(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the red component color at the indicated pixel.  The value returned\n"
  " * is a linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_red_283_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float PNMImage::get_green(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_green_284(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float PNMImage::get_green(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_green", (char **)keyword_list, &param1, &param2)) {
    float return_value = (*(const PNMImage*)local_this).get_green((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_green(PNMImage self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_green_284_comment =
  "C++ Interface:\n"
  "get_green(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the green component color at the indicated pixel.  The value\n"
  " * returned is a linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_green_284_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float PNMImage::get_blue(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_blue_285(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float PNMImage::get_blue(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_blue", (char **)keyword_list, &param1, &param2)) {
    float return_value = (*(const PNMImage*)local_this).get_blue((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_blue(PNMImage self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_blue_285_comment =
  "C++ Interface:\n"
  "get_blue(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the blue component color at the indicated pixel.  The value\n"
  " * returned is a linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_blue_285_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float PNMImage::get_gray(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_gray_286(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float PNMImage::get_gray(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_gray", (char **)keyword_list, &param1, &param2)) {
    float return_value = (*(const PNMImage*)local_this).get_gray((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_gray(PNMImage self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_gray_286_comment =
  "C++ Interface:\n"
  "get_gray(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the gray component color at the indicated pixel.  This only has a\n"
  " * meaningful value for grayscale images; for other image types, this returns\n"
  " * the value of the blue channel only.  However, also see the get_bright()\n"
  " * function.  The value returned is a linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_gray_286_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float PNMImage::get_alpha(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_alpha_287(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float PNMImage::get_alpha(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_alpha", (char **)keyword_list, &param1, &param2)) {
    float return_value = (*(const PNMImage*)local_this).get_alpha((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_alpha(PNMImage self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_alpha_287_comment =
  "C++ Interface:\n"
  "get_alpha(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the alpha component color at the indicated pixel.  It is an error\n"
  " * to call this unless has_alpha() is true.  The value returned is a float in\n"
  " * the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_alpha_287_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_red(int x, int y, float r)
 */
static PyObject *Dtool_PNMImage_set_red_288(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_red")) {
    return NULL;
  }
  // 1-inline void PNMImage::set_red(int x, int y, float r)
  int param1;
  int param2;
  float param3;
  static const char *keyword_list[] = {"x", "y", "r", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iif:set_red", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_red((int)param1, (int)param2, (float)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_red(const PNMImage self, int x, int y, float r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_red_288_comment =
  "C++ Interface:\n"
  "set_red(const PNMImage self, int x, int y, float r)\n"
  "\n"
  "/**\n"
  " * Sets the red component color only at the indicated pixel.  The value given\n"
  " * should be a linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_red_288_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_green(int x, int y, float g)
 */
static PyObject *Dtool_PNMImage_set_green_289(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_green")) {
    return NULL;
  }
  // 1-inline void PNMImage::set_green(int x, int y, float g)
  int param1;
  int param2;
  float param3;
  static const char *keyword_list[] = {"x", "y", "g", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iif:set_green", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_green((int)param1, (int)param2, (float)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_green(const PNMImage self, int x, int y, float g)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_green_289_comment =
  "C++ Interface:\n"
  "set_green(const PNMImage self, int x, int y, float g)\n"
  "\n"
  "/**\n"
  " * Sets the green component color only at the indicated pixel.  The value\n"
  " * given should be a linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_green_289_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_blue(int x, int y, float b)
 */
static PyObject *Dtool_PNMImage_set_blue_290(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_blue")) {
    return NULL;
  }
  // 1-inline void PNMImage::set_blue(int x, int y, float b)
  int param1;
  int param2;
  float param3;
  static const char *keyword_list[] = {"x", "y", "b", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iif:set_blue", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_blue((int)param1, (int)param2, (float)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blue(const PNMImage self, int x, int y, float b)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_blue_290_comment =
  "C++ Interface:\n"
  "set_blue(const PNMImage self, int x, int y, float b)\n"
  "\n"
  "/**\n"
  " * Sets the blue component color only at the indicated pixel.  The value given\n"
  " * should be a linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_blue_290_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_gray(int x, int y, float gray)
 */
static PyObject *Dtool_PNMImage_set_gray_291(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_gray")) {
    return NULL;
  }
  // 1-inline void PNMImage::set_gray(int x, int y, float gray)
  int param1;
  int param2;
  float param3;
  static const char *keyword_list[] = {"x", "y", "gray", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iif:set_gray", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_gray((int)param1, (int)param2, (float)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_gray(const PNMImage self, int x, int y, float gray)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_gray_291_comment =
  "C++ Interface:\n"
  "set_gray(const PNMImage self, int x, int y, float gray)\n"
  "\n"
  "/**\n"
  " * Sets the gray component color at the indicated pixel.  This is only\n"
  " * meaningful for grayscale images; for other image types, this simply sets\n"
  " * the blue component color.  However, also see set_xel(), which can set all\n"
  " * the component colors to the same grayscale level, and hence works correctly\n"
  " * both for grayscale and color images.  The value given should be a\n"
  " * linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_gray_291_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_alpha(int x, int y, float a)
 */
static PyObject *Dtool_PNMImage_set_alpha_292(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_alpha")) {
    return NULL;
  }
  // 1-inline void PNMImage::set_alpha(int x, int y, float a)
  int param1;
  int param2;
  float param3;
  static const char *keyword_list[] = {"x", "y", "a", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iif:set_alpha", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_alpha((int)param1, (int)param2, (float)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha(const PNMImage self, int x, int y, float a)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_alpha_292_comment =
  "C++ Interface:\n"
  "set_alpha(const PNMImage self, int x, int y, float a)\n"
  "\n"
  "/**\n"
  " * Sets the alpha component color only at the indicated pixel.  It is an error\n"
  " * to call this unless has_alpha() is true.  The value given should be in the\n"
  " * range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_alpha_292_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float PNMImage::get_bright(int x, int y) const
 * inline float PNMImage::get_bright(int x, int y, float rc, float gc, float bc) const
 * inline float PNMImage::get_bright(int x, int y, float rc, float gc, float bc, float ac) const
 */
static PyObject *Dtool_PNMImage_get_bright_293(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline float PNMImage::get_bright(int x, int y) const
      int param1;
      int param2;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_bright", (char **)keyword_list, &param1, &param2)) {
        float return_value = (*(const PNMImage*)local_this).get_bright((int)param1, (int)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 5:
    {
      // 1-inline float PNMImage::get_bright(int x, int y, float rc, float gc, float bc) const
      int param1;
      int param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"x", "y", "rc", "gc", "bc", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iifff:get_bright", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        float return_value = (*(const PNMImage*)local_this).get_bright((int)param1, (int)param2, (float)param3, (float)param4, (float)param5);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 6:
    {
      // 1-inline float PNMImage::get_bright(int x, int y, float rc, float gc, float bc, float ac) const
      int param1;
      int param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"x", "y", "rc", "gc", "bc", "ac", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiffff:get_bright", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        float return_value = (*(const PNMImage*)local_this).get_bright((int)param1, (int)param2, (float)param3, (float)param4, (float)param5, (float)param6);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_bright() takes 3, 6 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bright(PNMImage self, int x, int y)\n"
      "get_bright(PNMImage self, int x, int y, float rc, float gc, float bc)\n"
      "get_bright(PNMImage self, int x, int y, float rc, float gc, float bc, float ac)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_bright_293_comment =
  "C++ Interface:\n"
  "get_bright(PNMImage self, int x, int y)\n"
  "get_bright(PNMImage self, int x, int y, float rc, float gc, float bc)\n"
  "get_bright(PNMImage self, int x, int y, float rc, float gc, float bc, float ac)\n"
  "\n"
  "/**\n"
  " * Returns the linear brightness of the given xel, as a linearized float in\n"
  " * the range 0..1.  This flavor of get_bright() returns the correct grayscale\n"
  " * brightness level for both full-color and grayscale images.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of get_bright() works correctly only for color images.  It\n"
  " * returns a single brightness value for the RGB color at the indicated pixel,\n"
  " * based on the supplied weights for each component.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of get_bright() works correctly only for four-channel images.\n"
  " * It returns a single brightness value for the RGBA color at the indicated\n"
  " * pixel, based on the supplied weights for each component.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_bright_293_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::blend(int x, int y, LRGBColorf const &val, float alpha)
 * void PNMImage::blend(int x, int y, float r, float g, float b, float alpha)
 */
static PyObject *Dtool_PNMImage_blend_294(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.blend")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 4:
    {
      // 1-inline void PNMImage::blend(int x, int y, LRGBColorf const &val, float alpha)
      int param1;
      int param2;
      PyObject *param3;
      float param4;
      static const char *keyword_list[] = {"x", "y", "val", "alpha", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiOf:blend", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        LVecBase3f param3_local;
        LRGBColorf const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "PNMImage.blend", "LVecBase3f");
        }
        (*local_this).blend((int)param1, (int)param2, *param3_this, (float)param4);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-void PNMImage::blend(int x, int y, float r, float g, float b, float alpha)
      int param1;
      int param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"x", "y", "r", "g", "b", "alpha", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiffff:blend", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        (*local_this).blend((int)param1, (int)param2, (float)param3, (float)param4, (float)param5, (float)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "blend() takes 5 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "blend(const PNMImage self, int x, int y, const LVecBase3f val, float alpha)\n"
      "blend(const PNMImage self, int x, int y, float r, float g, float b, float alpha)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_blend_294_comment =
  "C++ Interface:\n"
  "blend(const PNMImage self, int x, int y, const LVecBase3f val, float alpha)\n"
  "blend(const PNMImage self, int x, int y, float r, float g, float b, float alpha)\n"
  "\n"
  "/**\n"
  " * Smoothly blends the indicated pixel value in with whatever was already in\n"
  " * the image, based on the given alpha value.  An alpha of 1.0 is fully opaque\n"
  " * and completely replaces whatever was there previously; alpha of 0.0 is\n"
  " * fully transparent and does nothing.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Smoothly blends the indicated pixel value in with whatever was already in\n"
  " * the image, based on the given alpha value.  An alpha of 1.0 is fully opaque\n"
  " * and completely replaces whatever was there previously; alpha of 0.0 is\n"
  " * fully transparent and does nothing.\n"
  " */";
#else
static const char *Dtool_PNMImage_blend_294_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::copy_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1)
 */
static PyObject *Dtool_PNMImage_copy_sub_image_295(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.copy_sub_image")) {
    return NULL;
  }
  // 1-void PNMImage::copy_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiii:copy_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.copy_sub_image", true, true);
    if (param1_this != NULL) {
      (*local_this).copy_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_copy_sub_image_295_comment =
  "C++ Interface:\n"
  "copy_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size)\n"
  "\n"
  "/**\n"
  " * Copies a rectangular area of another image into a rectangular area of this\n"
  " * image.  Both images must already have been initialized.  The upper-left\n"
  " * corner of the region in both images is specified, and the size of the area;\n"
  " * if the size is omitted, it defaults to the entire other image, or the\n"
  " * largest piece that will fit.\n"
  " */";
#else
static const char *Dtool_PNMImage_copy_sub_image_295_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::blend_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
 */
static PyObject *Dtool_PNMImage_blend_sub_image_296(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.blend_sub_image")) {
    return NULL;
  }
  // 1-void PNMImage::blend_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  float param8 = 1.0;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", "pixel_scale", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiiif:blend_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.blend_sub_image", true, true);
    if (param1_this != NULL) {
      (*local_this).blend_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (float)param8);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "blend_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_blend_sub_image_296_comment =
  "C++ Interface:\n"
  "blend_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
  "\n"
  "/**\n"
  " * Behaves like copy_sub_image(), except the alpha channel of the copy is used\n"
  " * to blend the copy into the destination image, instead of overwriting pixels\n"
  " * unconditionally.\n"
  " *\n"
  " * If pixel_scale is not 1.0, it specifies an amount to scale each *alpha*\n"
  " * value of the source image before applying it to the target image.\n"
  " *\n"
  " * If pixel_scale is 1.0 and the copy has no alpha channel, this degenerates\n"
  " * into copy_sub_image().\n"
  " */";
#else
static const char *Dtool_PNMImage_blend_sub_image_296_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::add_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
 */
static PyObject *Dtool_PNMImage_add_sub_image_297(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.add_sub_image")) {
    return NULL;
  }
  // 1-void PNMImage::add_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  float param8 = 1.0;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", "pixel_scale", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiiif:add_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.add_sub_image", true, true);
    if (param1_this != NULL) {
      (*local_this).add_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (float)param8);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_add_sub_image_297_comment =
  "C++ Interface:\n"
  "add_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
  "\n"
  "/**\n"
  " * Behaves like copy_sub_image(), except the copy pixels are added to the\n"
  " * pixels of the destination, after scaling by the specified pixel_scale.\n"
  " * Unlike blend_sub_image(), the alpha channel is not treated specially.\n"
  " */";
#else
static const char *Dtool_PNMImage_add_sub_image_297_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::mult_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
 */
static PyObject *Dtool_PNMImage_mult_sub_image_298(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.mult_sub_image")) {
    return NULL;
  }
  // 1-void PNMImage::mult_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  float param8 = 1.0;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", "pixel_scale", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiiif:mult_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.mult_sub_image", true, true);
    if (param1_this != NULL) {
      (*local_this).mult_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (float)param8);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "mult_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_mult_sub_image_298_comment =
  "C++ Interface:\n"
  "mult_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
  "\n"
  "/**\n"
  " * Behaves like copy_sub_image(), except the copy pixels are multiplied to the\n"
  " * pixels of the destination, after scaling by the specified pixel_scale.\n"
  " * Unlike blend_sub_image(), the alpha channel is not treated specially.\n"
  " */";
#else
static const char *Dtool_PNMImage_mult_sub_image_298_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::darken_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
 */
static PyObject *Dtool_PNMImage_darken_sub_image_299(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.darken_sub_image")) {
    return NULL;
  }
  // 1-void PNMImage::darken_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  float param8 = 1.0;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", "pixel_scale", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiiif:darken_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.darken_sub_image", true, true);
    if (param1_this != NULL) {
      (*local_this).darken_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (float)param8);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "darken_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_darken_sub_image_299_comment =
  "C++ Interface:\n"
  "darken_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
  "\n"
  "/**\n"
  " * Behaves like copy_sub_image(), but the resulting color will be the darker\n"
  " * of the source and destination colors at each pixel (and at each R, G, B, A\n"
  " * component value).\n"
  " *\n"
  " * If pixel_scale is not 1.0, it specifies an amount to scale each pixel value\n"
  " * of the source image before applying it to the target image.  The scale is\n"
  " * applied with the center at 1.0: scaling the pixel value smaller brings it\n"
  " * closer to 1.0.\n"
  " */";
#else
static const char *Dtool_PNMImage_darken_sub_image_299_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::lighten_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
 */
static PyObject *Dtool_PNMImage_lighten_sub_image_300(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.lighten_sub_image")) {
    return NULL;
  }
  // 1-void PNMImage::lighten_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  float param8 = 1.0;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", "pixel_scale", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiiif:lighten_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.lighten_sub_image", true, true);
    if (param1_this != NULL) {
      (*local_this).lighten_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (float)param8);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lighten_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_lighten_sub_image_300_comment =
  "C++ Interface:\n"
  "lighten_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
  "\n"
  "/**\n"
  " * Behaves like copy_sub_image(), but the resulting color will be the lighter\n"
  " * of the source and destination colors at each pixel (and at each R, G, B, A\n"
  " * component value).\n"
  " *\n"
  " * If pixel_scale is not 1.0, it specifies an amount to scale each pixel value\n"
  " * of the source image before applying it to the target image.\n"
  " */";
#else
static const char *Dtool_PNMImage_lighten_sub_image_300_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::threshold(PNMImage const &select_image, int channel, float threshold, PNMImage const &lt, PNMImage const &ge)
 */
static PyObject *Dtool_PNMImage_threshold_301(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.threshold")) {
    return NULL;
  }
  // 1-void PNMImage::threshold(PNMImage const &select_image, int channel, float threshold, PNMImage const &lt, PNMImage const &ge)
  PyObject *param1;
  int param2;
  float param3;
  PyObject *param4;
  PyObject *param5;
  static const char *keyword_list[] = {"select_image", "channel", "threshold", "lt", "ge", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OifOO:threshold", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.threshold", true, true);
    PNMImage const *param4_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_PNMImage, 4, "PNMImage.threshold", true, true);
    PNMImage const *param5_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param5, Dtool_Ptr_PNMImage, 5, "PNMImage.threshold", true, true);
    if (param1_this != NULL && param4_this != NULL && param5_this != NULL) {
      (*local_this).threshold(*param1_this, (int)param2, (float)param3, *param4_this, *param5_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "threshold(const PNMImage self, const PNMImage select_image, int channel, float threshold, const PNMImage lt, const PNMImage ge)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_threshold_301_comment =
  "C++ Interface:\n"
  "threshold(const PNMImage self, const PNMImage select_image, int channel, float threshold, const PNMImage lt, const PNMImage ge)\n"
  "\n"
  "/**\n"
  " * Selectively copies each pixel from either one source or another source,\n"
  " * depending on the pixel value of the indicated channel of select_image.\n"
  " *\n"
  " * For each pixel (x, y):\n"
  " *\n"
  " * s = select_image.get_channel(x, y, channel). Set this image's (x, y) to:\n"
  " *\n"
  " * lt.get_xel(x, y) if s < threshold, or\n"
  " *\n"
  " * ge.get_xel(x, y) if s >= threshold\n"
  " *\n"
  " * Any of select_image, lt, or ge may be the same PNMImge object as this\n"
  " * image, or the same as each other; or they may all be different.  All images\n"
  " * must be the same size.  As a special case, lt and ge may both be 1x1 images\n"
  " * instead of the source image size.\n"
  " */";
#else
static const char *Dtool_PNMImage_threshold_301_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::fill_distance_inside(PNMImage const &mask, float threshold, int radius, bool shrink_from_border)
 */
static PyObject *Dtool_PNMImage_fill_distance_inside_302(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.fill_distance_inside")) {
    return NULL;
  }
  // 1-void PNMImage::fill_distance_inside(PNMImage const &mask, float threshold, int radius, bool shrink_from_border)
  PyObject *param1;
  float param2;
  int param3;
  PyObject *param4;
  static const char *keyword_list[] = {"mask", "threshold", "radius", "shrink_from_border", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OfiO:fill_distance_inside", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.fill_distance_inside", true, true);
    if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*local_this).fill_distance_inside(*param1_this, (float)param2, (int)param3, (PyObject_IsTrue(param4) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill_distance_inside(const PNMImage self, const PNMImage mask, float threshold, int radius, bool shrink_from_border)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_fill_distance_inside_302_comment =
  "C++ Interface:\n"
  "fill_distance_inside(const PNMImage self, const PNMImage mask, float threshold, int radius, bool shrink_from_border)\n"
  "\n"
  "/**\n"
  " * Replaces this image with a grayscale image whose gray channel represents\n"
  " * the linear Manhattan distance from the nearest dark pixel in the given mask\n"
  " * image, up to the specified radius value (which also becomes the new\n"
  " * maxval).  radius may range from 0 to maxmaxval; smaller values will compute\n"
  " * faster.  A dark pixel is defined as one whose pixel value is < threshold.\n"
  " *\n"
  " * If shrink_from_border is true, then the mask image is considered to be\n"
  " * surrounded by a border of dark pixels; otherwise, the border isn't\n"
  " * considered.\n"
  " *\n"
  " * This can be used, in conjunction with threshold, to shrink a mask image\n"
  " * inwards by a certain number of pixels.\n"
  " *\n"
  " * The mask image may be the same image as this one, in which case it is\n"
  " * destructively modified by this process.\n"
  " */";
#else
static const char *Dtool_PNMImage_fill_distance_inside_302_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::fill_distance_outside(PNMImage const &mask, float threshold, int radius)
 */
static PyObject *Dtool_PNMImage_fill_distance_outside_303(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.fill_distance_outside")) {
    return NULL;
  }
  // 1-void PNMImage::fill_distance_outside(PNMImage const &mask, float threshold, int radius)
  PyObject *param1;
  float param2;
  int param3;
  static const char *keyword_list[] = {"mask", "threshold", "radius", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Ofi:fill_distance_outside", (char **)keyword_list, &param1, &param2, &param3)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.fill_distance_outside", true, true);
    if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*local_this).fill_distance_outside(*param1_this, (float)param2, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill_distance_outside(const PNMImage self, const PNMImage mask, float threshold, int radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_fill_distance_outside_303_comment =
  "C++ Interface:\n"
  "fill_distance_outside(const PNMImage self, const PNMImage mask, float threshold, int radius)\n"
  "\n"
  "/**\n"
  " * Replaces this image with a grayscale image whose gray channel represents\n"
  " * the linear Manhattan distance from the nearest white pixel in the given\n"
  " * mask image, up to the specified radius value (which also becomes the new\n"
  " * maxval).  radius may range from 0 to maxmaxval; smaller values will compute\n"
  " * faster.  A white pixel is defined as one whose pixel value is >= threshold.\n"
  " *\n"
  " * This can be used, in conjunction with threshold, to grow a mask image\n"
  " * outwards by a certain number of pixels.\n"
  " *\n"
  " * The mask image may be the same image as this one, in which case it is\n"
  " * destructively modified by this process.\n"
  " */";
#else
static const char *Dtool_PNMImage_fill_distance_outside_303_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::indirect_1d_lookup(PNMImage const &index_image, int channel, PNMImage const &pixel_values)
 */
static PyObject *Dtool_PNMImage_indirect_1d_lookup_304(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.indirect_1d_lookup")) {
    return NULL;
  }
  // 1-void PNMImage::indirect_1d_lookup(PNMImage const &index_image, int channel, PNMImage const &pixel_values)
  PyObject *param1;
  int param2;
  PyObject *param3;
  static const char *keyword_list[] = {"index_image", "channel", "pixel_values", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OiO:indirect_1d_lookup", (char **)keyword_list, &param1, &param2, &param3)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.indirect_1d_lookup", true, true);
    PNMImage const *param3_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_PNMImage, 3, "PNMImage.indirect_1d_lookup", true, true);
    if (param1_this != NULL && param3_this != NULL) {
      (*local_this).indirect_1d_lookup(*param1_this, (int)param2, *param3_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "indirect_1d_lookup(const PNMImage self, const PNMImage index_image, int channel, const PNMImage pixel_values)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_indirect_1d_lookup_304_comment =
  "C++ Interface:\n"
  "indirect_1d_lookup(const PNMImage self, const PNMImage index_image, int channel, const PNMImage pixel_values)\n"
  "\n"
  "/**\n"
  " * index_image is a WxH grayscale image, while pixel_values is an Nx1 color\n"
  " * (or grayscale) image.  Typically pixel_values will be a 256x1 image.\n"
  " *\n"
  " * Fills the PNMImage with a new image the same width and height as\n"
  " * index_image, with the same number of channels as pixel_values.\n"
  " *\n"
  " * Each pixel of the new image is computed with the formula:\n"
  " *\n"
  " * new_image(x, y) = pixel_values(index_image(x, y)[channel], 0)\n"
  " *\n"
  " * At present, no interpolation is performed; the nearest value in\n"
  " * pixel_values is discovered.  This may change in the future.\n"
  " */";
#else
static const char *Dtool_PNMImage_indirect_1d_lookup_304_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::rescale(float min_val, float max_val)
 */
static PyObject *Dtool_PNMImage_rescale_305(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.rescale")) {
    return NULL;
  }
  // 1-void PNMImage::rescale(float min_val, float max_val)
  float param1;
  float param2;
  static const char *keyword_list[] = {"min_val", "max_val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:rescale", (char **)keyword_list, &param1, &param2)) {
    (*local_this).rescale((float)param1, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rescale(const PNMImage self, float min_val, float max_val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_rescale_305_comment =
  "C++ Interface:\n"
  "rescale(const PNMImage self, float min_val, float max_val)\n"
  "\n"
  "/**\n"
  " * Rescales the RGB channel values so that any values in the original image\n"
  " * between min_val and max_val are expanded to the range 0 .. 1.  Values below\n"
  " * min_val are set to 0, and values above max_val are set to 1. Does not\n"
  " * affect the alpha channel, if any.\n"
  " */";
#else
static const char *Dtool_PNMImage_rescale_305_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::render_spot(LColorf const &fg, LColorf const &bg, float min_radius, float max_radius)
 */
static PyObject *Dtool_PNMImage_render_spot_306(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.render_spot")) {
    return NULL;
  }
  // 1-void PNMImage::render_spot(LColorf const &fg, LColorf const &bg, float min_radius, float max_radius)
  PyObject *param1;
  PyObject *param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"fg", "bg", "min_radius", "max_radius", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOff:render_spot", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    LVecBase4f param1_local;
    LColorf const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PNMImage.render_spot", "LVecBase4f");
    }
    LVecBase4f param2_local;
    LColorf const *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PNMImage.render_spot", "LVecBase4f");
    }
    (*local_this).render_spot(*param1_this, *param2_this, (float)param3, (float)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "render_spot(const PNMImage self, const LVecBase4f fg, const LVecBase4f bg, float min_radius, float max_radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_render_spot_306_comment =
  "C++ Interface:\n"
  "render_spot(const PNMImage self, const LVecBase4f fg, const LVecBase4f bg, float min_radius, float max_radius)\n"
  "\n"
  "/**\n"
  " * Renders a solid-color circle, with a fuzzy edge, into the center of the\n"
  " * PNMImage.  If the PNMImage is non-square, this actually renders an ellipse.\n"
  " *\n"
  " * The min_radius and max_radius are in the scale 0..1, where 1.0 means the\n"
  " * full width of the image.  If min_radius == max_radius, the edge is sharp\n"
  " * (but still antialiased); otherwise, the pixels between min_radius and\n"
  " * max_radius are smoothly blended between fg and bg colors.\n"
  " */";
#else
static const char *Dtool_PNMImage_render_spot_306_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::expand_border(int left, int right, int bottom, int top, LColorf const &color)
 */
static PyObject *Dtool_PNMImage_expand_border_307(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.expand_border")) {
    return NULL;
  }
  // 1-void PNMImage::expand_border(int left, int right, int bottom, int top, LColorf const &color)
  int param1;
  int param2;
  int param3;
  int param4;
  PyObject *param5;
  static const char *keyword_list[] = {"left", "right", "bottom", "top", "color", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiiiO:expand_border", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    LVecBase4f param5_local;
    LColorf const *param5_this = Dtool_Coerce_LVecBase4f(param5, param5_local);
    if (!(param5_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param5, 5, "PNMImage.expand_border", "LVecBase4f");
    }
    (*local_this).expand_border((int)param1, (int)param2, (int)param3, (int)param4, *param5_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "expand_border(const PNMImage self, int left, int right, int bottom, int top, const LVecBase4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_expand_border_307_comment =
  "C++ Interface:\n"
  "expand_border(const PNMImage self, int left, int right, int bottom, int top, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Expands the image by the indicated number of pixels on each edge.  The new\n"
  " * pixels are set to the indicated color.\n"
  " *\n"
  " * If any of the values is negative, this actually crops the image.\n"
  " */";
#else
static const char *Dtool_PNMImage_expand_border_307_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::box_filter(float radius = 1.0)
 */
static PyObject *Dtool_PNMImage_box_filter_308(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.box_filter")) {
    return NULL;
  }
  // 1-inline void PNMImage::box_filter(float radius = 1.0)
  float param1 = 1.0;
  static const char *keyword_list[] = {"radius", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|f:box_filter", (char **)keyword_list, &param1)) {
    (*local_this).box_filter((float)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "box_filter(const PNMImage self, float radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_box_filter_308_comment =
  "C++ Interface:\n"
  "box_filter(const PNMImage self, float radius)\n"
  "\n"
  "/**\n"
  " * This flavor of box_filter() will apply the filter over the entire image\n"
  " * without resizing or copying; the effect is that of a blur operation.\n"
  " */";
#else
static const char *Dtool_PNMImage_box_filter_308_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::gaussian_filter(float radius = 1.0)
 */
static PyObject *Dtool_PNMImage_gaussian_filter_309(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.gaussian_filter")) {
    return NULL;
  }
  // 1-inline void PNMImage::gaussian_filter(float radius = 1.0)
  float param1 = 1.0;
  static const char *keyword_list[] = {"radius", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|f:gaussian_filter", (char **)keyword_list, &param1)) {
    (*local_this).gaussian_filter((float)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "gaussian_filter(const PNMImage self, float radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_gaussian_filter_309_comment =
  "C++ Interface:\n"
  "gaussian_filter(const PNMImage self, float radius)\n"
  "\n"
  "/**\n"
  " * This flavor of gaussian_filter() will apply the filter over the entire\n"
  " * image without resizing or copying; the effect is that of a blur operation.\n"
  " */";
#else
static const char *Dtool_PNMImage_gaussian_filter_309_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::unfiltered_stretch_from(PNMImage const &copy)
 */
static PyObject *Dtool_PNMImage_unfiltered_stretch_from_310(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.unfiltered_stretch_from")) {
    return NULL;
  }
  // 1-void PNMImage::unfiltered_stretch_from(PNMImage const &copy)
  PNMImage const *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 1, "PNMImage.unfiltered_stretch_from", true, true);
  if (arg_this != NULL) {
    (*local_this).unfiltered_stretch_from(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unfiltered_stretch_from(const PNMImage self, const PNMImage copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_unfiltered_stretch_from_310_comment =
  "C++ Interface:\n"
  "unfiltered_stretch_from(const PNMImage self, const PNMImage copy)\n"
  "\n"
  "/**\n"
  " * Resizes from the indicated image into this one by performing a nearest-\n"
  " * point sample.\n"
  " */";
#else
static const char *Dtool_PNMImage_unfiltered_stretch_from_310_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::box_filter_from(float radius, PNMImage const &copy)
 */
static PyObject *Dtool_PNMImage_box_filter_from_311(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.box_filter_from")) {
    return NULL;
  }
  // 1-void PNMImage::box_filter_from(float radius, PNMImage const &copy)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"radius", "copy", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:box_filter_from", (char **)keyword_list, &param1, &param2)) {
    PNMImage const *param2_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PNMImage, 2, "PNMImage.box_filter_from", true, true);
    if (param2_this != NULL) {
      (*local_this).box_filter_from((float)param1, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "box_filter_from(const PNMImage self, float radius, const PNMImage copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_box_filter_from_311_comment =
  "C++ Interface:\n"
  "box_filter_from(const PNMImage self, float radius, const PNMImage copy)\n"
  "\n"
  "/**\n"
  " * Makes a resized copy of the indicated image into this one using the\n"
  " * indicated filter.  The image to be copied is squashed and stretched to\n"
  " * match the dimensions of the current image, applying the appropriate filter\n"
  " * to perform the stretching.\n"
  " */";
#else
static const char *Dtool_PNMImage_box_filter_from_311_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::gaussian_filter_from(float radius, PNMImage const &copy)
 */
static PyObject *Dtool_PNMImage_gaussian_filter_from_312(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.gaussian_filter_from")) {
    return NULL;
  }
  // 1-void PNMImage::gaussian_filter_from(float radius, PNMImage const &copy)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"radius", "copy", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:gaussian_filter_from", (char **)keyword_list, &param1, &param2)) {
    PNMImage const *param2_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PNMImage, 2, "PNMImage.gaussian_filter_from", true, true);
    if (param2_this != NULL) {
      (*local_this).gaussian_filter_from((float)param1, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "gaussian_filter_from(const PNMImage self, float radius, const PNMImage copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_gaussian_filter_from_312_comment =
  "C++ Interface:\n"
  "gaussian_filter_from(const PNMImage self, float radius, const PNMImage copy)\n"
  "\n"
  "/**\n"
  " * Makes a resized copy of the indicated image into this one using the\n"
  " * indicated filter.  The image to be copied is squashed and stretched to\n"
  " * match the dimensions of the current image, applying the appropriate filter\n"
  " * to perform the stretching.\n"
  " */";
#else
static const char *Dtool_PNMImage_gaussian_filter_from_312_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::quick_filter_from(PNMImage const &copy, int xborder = 0, int yborder = 0)
 */
static PyObject *Dtool_PNMImage_quick_filter_from_313(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.quick_filter_from")) {
    return NULL;
  }
  // 1-void PNMImage::quick_filter_from(PNMImage const &copy, int xborder = 0, int yborder = 0)
  PyObject *param1;
  int param2 = 0;
  int param3 = 0;
  static const char *keyword_list[] = {"copy", "xborder", "yborder", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|ii:quick_filter_from", (char **)keyword_list, &param1, &param2, &param3)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.quick_filter_from", true, true);
    if (param1_this != NULL) {
      (*local_this).quick_filter_from(*param1_this, (int)param2, (int)param3);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "quick_filter_from(const PNMImage self, const PNMImage copy, int xborder, int yborder)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_quick_filter_from_313_comment =
  "C++ Interface:\n"
  "quick_filter_from(const PNMImage self, const PNMImage copy, int xborder, int yborder)\n"
  "\n"
  "/**\n"
  " * Resizes from the given image, with a fixed radius of 0.5. This is a very\n"
  " * specialized and simple algorithm that doesn't handle dropping below the\n"
  " * Nyquist rate very well, but is quite a bit faster than the more general\n"
  " * box_filter(), above.  If borders are specified, they will further restrict\n"
  " * the size of the resulting image.  There's no point in using\n"
  " * quick_box_filter() on a single image.\n"
  " */";
#else
static const char *Dtool_PNMImage_quick_filter_from_313_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::make_histogram(PNMImageHeader::Histogram &hist)
 */
static PyObject *Dtool_PNMImage_make_histogram_314(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.make_histogram")) {
    return NULL;
  }
  // 1-void PNMImage::make_histogram(PNMImageHeader::Histogram &hist)
  PNMImageHeader::Histogram *arg_this = (PNMImageHeader::Histogram *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImageHeader_Histogram, 1, "PNMImage.make_histogram", false, true);
  if (arg_this != NULL) {
    (*local_this).make_histogram(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_histogram(const PNMImage self, Histogram hist)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_make_histogram_314_comment =
  "C++ Interface:\n"
  "make_histogram(const PNMImage self, Histogram hist)\n"
  "\n"
  "/**\n"
  " * Computes a histogram of the colors used in the image.\n"
  " */";
#else
static const char *Dtool_PNMImage_make_histogram_314_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::perlin_noise_fill(StackedPerlinNoise2 &perlin)
 * void PNMImage::perlin_noise_fill(float sx, float sy, int table_size = 256, unsigned long int seed = 0)
 */
static PyObject *Dtool_PNMImage_perlin_noise_fill_315(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.perlin_noise_fill")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "perlin");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'perlin' (pos 1) not found");
      }
      // 1-void PNMImage::perlin_noise_fill(StackedPerlinNoise2 &perlin)
      StackedPerlinNoise2 *arg_this;
      bool arg_manage = false;
      if (!Dtool_Coerce_StackedPerlinNoise2(arg, arg_this, arg_manage)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "PNMImage.perlin_noise_fill", "StackedPerlinNoise2");
      }
      (*local_this).perlin_noise_fill(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      return Dtool_Return_None();
    }
    break;
  case 2:
  case 3:
  case 4:
    {
      // 1-void PNMImage::perlin_noise_fill(float sx, float sy, int table_size = 256, unsigned long int seed = 0)
      float param1;
      float param2;
      int param3 = 256;
      unsigned long param4 = 0;
      static const char *keyword_list[] = {"sx", "sy", "table_size", "seed", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff|ik:perlin_noise_fill", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).perlin_noise_fill((float)param1, (float)param2, (int)param3, (unsigned long int)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "perlin_noise_fill() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "perlin_noise_fill(const PNMImage self, StackedPerlinNoise2 perlin)\n"
      "perlin_noise_fill(const PNMImage self, float sx, float sy, int table_size, int seed)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_perlin_noise_fill_315_comment =
  "C++ Interface:\n"
  "perlin_noise_fill(const PNMImage self, StackedPerlinNoise2 perlin)\n"
  "perlin_noise_fill(const PNMImage self, float sx, float sy, int table_size, int seed)\n"
  "\n"
  "/**\n"
  " * Fills the image with a grayscale perlin noise pattern based on the\n"
  " * indicated parameters.  Uses set_xel to set the grayscale values.  The sx\n"
  " * and sy parameters are in multiples of the size of this image.  See also the\n"
  " * PerlinNoise2 class in mathutil.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Variant of perlin_noise_fill that uses an existing StackedPerlinNoise2\n"
  " * object.\n"
  " */";
#else
static const char *Dtool_PNMImage_perlin_noise_fill_315_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::remix_channels(LMatrix4 const &conv)
 */
static PyObject *Dtool_PNMImage_remix_channels_316(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.remix_channels")) {
    return NULL;
  }
  // 1-void PNMImage::remix_channels(LMatrix4 const &conv)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PNMImage.remix_channels", "LMatrix4f");
  }
  (*local_this).remix_channels(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remix_channels(const PNMImage self, const LMatrix4f conv)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_remix_channels_316_comment =
  "C++ Interface:\n"
  "remix_channels(const PNMImage self, const LMatrix4f conv)\n"
  "\n"
  "/**\n"
  " * Transforms every pixel using the operation (Ro,Go,Bo) =\n"
  " * conv.xform_point(Ri,Gi,Bi); Input must be a color image.\n"
  " */";
#else
static const char *Dtool_PNMImage_remix_channels_316_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::gamma_correct(float from_gamma, float to_gamma)
 */
static PyObject *Dtool_PNMImage_gamma_correct_317(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.gamma_correct")) {
    return NULL;
  }
  // 1-inline void PNMImage::gamma_correct(float from_gamma, float to_gamma)
  float param1;
  float param2;
  static const char *keyword_list[] = {"from_gamma", "to_gamma", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:gamma_correct", (char **)keyword_list, &param1, &param2)) {
    (*local_this).gamma_correct((float)param1, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "gamma_correct(const PNMImage self, float from_gamma, float to_gamma)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_gamma_correct_317_comment =
  "C++ Interface:\n"
  "gamma_correct(const PNMImage self, float from_gamma, float to_gamma)\n"
  "\n"
  "/**\n"
  " * Assuming the image was constructed with a gamma curve of from_gamma in the\n"
  " * RGB channels, converts it to an image with a gamma curve of to_gamma in the\n"
  " * RGB channels.  Does not affect the alpha channel.\n"
  " */";
#else
static const char *Dtool_PNMImage_gamma_correct_317_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::gamma_correct_alpha(float from_gamma, float to_gamma)
 */
static PyObject *Dtool_PNMImage_gamma_correct_alpha_318(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.gamma_correct_alpha")) {
    return NULL;
  }
  // 1-inline void PNMImage::gamma_correct_alpha(float from_gamma, float to_gamma)
  float param1;
  float param2;
  static const char *keyword_list[] = {"from_gamma", "to_gamma", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:gamma_correct_alpha", (char **)keyword_list, &param1, &param2)) {
    (*local_this).gamma_correct_alpha((float)param1, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "gamma_correct_alpha(const PNMImage self, float from_gamma, float to_gamma)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_gamma_correct_alpha_318_comment =
  "C++ Interface:\n"
  "gamma_correct_alpha(const PNMImage self, float from_gamma, float to_gamma)\n"
  "\n"
  "/**\n"
  " * Assuming the image was constructed with a gamma curve of from_gamma in the\n"
  " * alpha channel, converts it to an image with a gamma curve of to_gamma in\n"
  " * the alpha channel.  Does not affect the RGB channels.\n"
  " */";
#else
static const char *Dtool_PNMImage_gamma_correct_alpha_318_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::apply_exponent(float gray_exponent)
 * inline void PNMImage::apply_exponent(float gray_exponent, float alpha_exponent)
 * inline void PNMImage::apply_exponent(float red_exponent, float green_exponent, float blue_exponent)
 * void PNMImage::apply_exponent(float red_exponent, float green_exponent, float blue_exponent, float alpha_exponent)
 */
static PyObject *Dtool_PNMImage_apply_exponent_319(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.apply_exponent")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "gray_exponent");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'gray_exponent' (pos 1) not found");
      }
      // 1-inline void PNMImage::apply_exponent(float gray_exponent)
      if (PyNumber_Check(arg)) {
        (*local_this).apply_exponent((float)PyFloat_AsDouble(arg));
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void PNMImage::apply_exponent(float gray_exponent, float alpha_exponent)
      float param1;
      float param2;
      static const char *keyword_list[] = {"gray_exponent", "alpha_exponent", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:apply_exponent", (char **)keyword_list, &param1, &param2)) {
        (*local_this).apply_exponent((float)param1, (float)param2);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void PNMImage::apply_exponent(float red_exponent, float green_exponent, float blue_exponent)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"red_exponent", "green_exponent", "blue_exponent", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:apply_exponent", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).apply_exponent((float)param1, (float)param2, (float)param3);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-void PNMImage::apply_exponent(float red_exponent, float green_exponent, float blue_exponent, float alpha_exponent)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"red_exponent", "green_exponent", "blue_exponent", "alpha_exponent", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:apply_exponent", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).apply_exponent((float)param1, (float)param2, (float)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "apply_exponent() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_exponent(const PNMImage self, float gray_exponent)\n"
      "apply_exponent(const PNMImage self, float gray_exponent, float alpha_exponent)\n"
      "apply_exponent(const PNMImage self, float red_exponent, float green_exponent, float blue_exponent)\n"
      "apply_exponent(const PNMImage self, float red_exponent, float green_exponent, float blue_exponent, float alpha_exponent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_apply_exponent_319_comment =
  "C++ Interface:\n"
  "apply_exponent(const PNMImage self, float gray_exponent)\n"
  "apply_exponent(const PNMImage self, float gray_exponent, float alpha_exponent)\n"
  "apply_exponent(const PNMImage self, float red_exponent, float green_exponent, float blue_exponent)\n"
  "apply_exponent(const PNMImage self, float red_exponent, float green_exponent, float blue_exponent, float alpha_exponent)\n"
  "\n"
  "/**\n"
  " * Adjusts each channel of the image by raising the corresponding component\n"
  " * value to the indicated exponent, such that L' = L ^ exponent.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adjusts each channel of the image by raising the corresponding component\n"
  " * value to the indicated exponent, such that L' = L ^ exponent.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adjusts each channel of the image by raising the corresponding component\n"
  " * value to the indicated exponent, such that L' = L ^ exponent.  For a\n"
  " * grayscale image, the blue_exponent value is used for the grayscale value,\n"
  " * and red_exponent and green_exponent are unused.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adjusts each channel of the image by raising the corresponding component\n"
  " * value to the indicated exponent, such that L' = L ^ exponent.  For a\n"
  " * grayscale image, the blue_exponent value is used for the grayscale value,\n"
  " * and red_exponent and green_exponent are unused.\n"
  " */";
#else
static const char *Dtool_PNMImage_apply_exponent_319_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LRGBColorf PNMImage::get_average_xel(void) const
 */
static PyObject *Dtool_PNMImage_get_average_xel_320(PyObject *self, PyObject *) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-LRGBColorf PNMImage::get_average_xel(void) const
  LRGBColorf *return_value = new LRGBColorf((*(const PNMImage*)local_this).get_average_xel());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_average_xel_320_comment =
  "C++ Interface:\n"
  "get_average_xel(PNMImage self)\n"
  "\n"
  "/**\n"
  " * Returns the average color of all of the pixels in the image.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_average_xel_320_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LColorf PNMImage::get_average_xel_a(void) const
 */
static PyObject *Dtool_PNMImage_get_average_xel_a_321(PyObject *self, PyObject *) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-LColorf PNMImage::get_average_xel_a(void) const
  LColorf *return_value = new LColorf((*(const PNMImage*)local_this).get_average_xel_a());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_average_xel_a_321_comment =
  "C++ Interface:\n"
  "get_average_xel_a(PNMImage self)\n"
  "\n"
  "/**\n"
  " * Returns the average color of all of the pixels in the image, including the\n"
  " * alpha channel.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_average_xel_a_321_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * float PNMImage::get_average_gray(void) const
 */
static PyObject *Dtool_PNMImage_get_average_gray_322(PyObject *self, PyObject *) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  // 1-float PNMImage::get_average_gray(void) const
  float return_value = (*(const PNMImage*)local_this).get_average_gray();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_average_gray_322_comment =
  "C++ Interface:\n"
  "get_average_gray(PNMImage self)\n"
  "\n"
  "/**\n"
  " * Returns the average grayscale component of all of the pixels in the image.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_average_gray_322_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::do_fill_distance(int xi, int yi, int d)
 */
static PyObject *Dtool_PNMImage_do_fill_distance_323(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.do_fill_distance")) {
    return NULL;
  }
  // 1-void PNMImage::do_fill_distance(int xi, int yi, int d)
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"xi", "yi", "d", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:do_fill_distance", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).do_fill_distance((int)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "do_fill_distance(const PNMImage self, int xi, int yi, int d)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_do_fill_distance_323_comment =
  "C++ Interface:\n"
  "do_fill_distance(const PNMImage self, int xi, int yi, int d)\n"
  "\n"
  "/**\n"
  " * Recursively fills in the minimum distance measured from a certain set of\n"
  " * points into the gray channel.\n"
  " */";
#else
static const char *Dtool_PNMImage_do_fill_distance_323_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PNMImage::PNMImage(void)
 * explicit PNMImage::PNMImage(Filename const &filename, PNMFileType *type = 0)
 * inline PNMImage::PNMImage(PNMImage const &copy)
 * inline explicit PNMImage::PNMImage(int x_size, int y_size, int num_channels = 3, xelval maxval = 255, PNMFileType *type = 0, ColorSpace color_space = ::CS_linear)
 */
static int Dtool_Init_PNMImage(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PNMImage::PNMImage(void)
      PNMImage *return_value = new PNMImage();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImage, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 explicit PNMImage::PNMImage(Filename const &filename, PNMFileType *type)
        PyObject *param0;
        static const char *keyword_list[] = {"filename", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PNMImage", (char **)keyword_list, &param0)) {
          Filename const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Filename, (void **)&param0_this);
          if (param0_this != NULL) {
            PNMImage *return_value = new PNMImage(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImage, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PNMImage::PNMImage(PNMImage const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PNMImage", (char **)keyword_list, &param0)) {
          PNMImage const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PNMImage, (void **)&param0_this);
          if (param0_this != NULL) {
            PNMImage *return_value = new PNMImage(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImage, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 explicit PNMImage::PNMImage(Filename const &filename, PNMFileType *type)
        PyObject *param0;
        static const char *keyword_list[] = {"filename", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PNMImage", (char **)keyword_list, &param0)) {
          Filename param0_local;
          Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
          if ((param0_this != NULL)) {
            PNMImage *return_value = new PNMImage(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImage, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline PNMImage::PNMImage(PNMImage const &copy)
    }
    break;
  case 2:
  case 3:
  case 4:
  case 5:
  case 6:
    {
      {
        // -2 inline explicit PNMImage::PNMImage(int x_size, int y_size, int num_channels = 3, xelval maxval = 255, PNMFileType *type = 0, ColorSpace color_space = ::CS_linear)
        int param0;
        int param1;
        int param2 = 3;
        long param3 = 255;
        PyObject *param4 = NULL;
        int param5 = ::CS_linear;
        static const char *keyword_list[] = {"x_size", "y_size", "num_channels", "maxval", "type", "color_space", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "ii|ilOi:PNMImage", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
#ifndef NDEBUG
          if (param3 < 0 || param3 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param3);
            return -1;
          }
#endif
          PNMFileType *param4_this = 0;
          if (param4 != (PyObject *)NULL) {
            param4_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_PNMFileType, 4, "PNMImage.PNMImage", false, false);
          }
          if ((param4 == NULL || param4_this != NULL)) {
            PNMImage *return_value = new PNMImage((int)param0, (int)param1, (int)param2, (xelval)param3, param4_this, (ColorSpace)param5);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImage, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline explicit PNMImage::PNMImage(int x_size, int y_size, int num_channels = 3, xelval maxval = 255, PNMFileType *type = 0, ColorSpace color_space = ::CS_linear)
      {
        // -2 explicit PNMImage::PNMImage(Filename const &filename, PNMFileType *type = 0)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"filename", "type", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:PNMImage", (char **)keyword_list, &param0, &param1)) {
          Filename param0_local;
          Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
          PNMFileType *param1_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMFileType, 1, "PNMImage.PNMImage", false, false);
          if ((param0_this != NULL) && param1_this != NULL) {
            PNMImage *return_value = new PNMImage(*param0_this, param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImage, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PNMImage() takes 0, 1, 2, 3, 4, 5 or 6 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PNMImage()\n"
      "PNMImage(const Filename filename)\n"
      "PNMImage(const PNMImage copy)\n"
      "PNMImage(int x_size, int y_size, int num_channels, int maxval, PNMFileType type, int color_space)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PNMImage(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PNMImage) {
    printf("PNMImage ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PNMImage *local_this = (PNMImage *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PNMImage) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PNMImageHeader) {
    return (PNMImageHeader *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PNMImage(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PNMImage) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PNMImageHeader) {
    PNMImageHeader* other_this = (PNMImageHeader*)from_this;
    return (PNMImage*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PNMImage::Row
 */
/**
 * Python function wrapper for:
 * inline xel &PNMImage::Row::get_xel_val(int x)
 */
static PyObject *Dtool_PNMImage_Row_get_xel_val_328(PyObject *self, PyObject *arg) {
  PNMImage::Row *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage_Row, (void **)&local_this, "PNMImage::Row.get_xel_val")) {
    return NULL;
  }
  // 1-inline xel &PNMImage::Row::get_xel_val(int x)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    xel *return_value = &((*local_this).get_xel_val((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_pixel, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_xel_val(const Row self, int x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_Row_get_xel_val_328_comment =
  "C++ Interface:\n"
  "get_xel_val(const Row self, int x)\n"
  "\n"
  "/**\n"
  " * Fetch the pixel at the given column in the row.\n"
  " */";
#else
static const char *Dtool_PNMImage_Row_get_xel_val_328_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::Row::set_xel_val(int x, xel const &v)
 */
static PyObject *Dtool_PNMImage_Row_set_xel_val_329(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage::Row *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage_Row, (void **)&local_this, "PNMImage::Row.set_xel_val")) {
    return NULL;
  }
  // 1-inline void PNMImage::Row::set_xel_val(int x, xel const &v)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"x", "v", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_xel_val", (char **)keyword_list, &param1, &param2)) {
    pixel param2_local;
    xel const *param2_this = Dtool_Coerce_pixel(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Row.set_xel_val", "pixel");
    }
    (*local_this).set_xel_val((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_xel_val(const Row self, int x, const pixel v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_Row_set_xel_val_329_comment =
  "C++ Interface:\n"
  "set_xel_val(const Row self, int x, const pixel v)\n"
  "\n"
  "/**\n"
  " * Set the pixel at the given column in the row.\n"
  " */";
#else
static const char *Dtool_PNMImage_Row_set_xel_val_329_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImage::Row::get_alpha_val(int x) const
 */
static PyObject *Dtool_PNMImage_Row_get_alpha_val_330(PyObject *self, PyObject *arg) {
  PNMImage::Row *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage_Row, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline xelval PNMImage::Row::get_alpha_val(int x) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    xelval return_value = (*(const PNMImage::Row*)local_this).get_alpha_val((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_alpha_val(Row self, int x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_Row_get_alpha_val_330_comment =
  "C++ Interface:\n"
  "get_alpha_val(Row self, int x)\n"
  "\n"
  "/**\n"
  " * Fetch the alpha value at the given column in the row.\n"
  " */";
#else
static const char *Dtool_PNMImage_Row_get_alpha_val_330_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::Row::set_alpha_val(int x, xelval v)
 */
static PyObject *Dtool_PNMImage_Row_set_alpha_val_331(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage::Row *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage_Row, (void **)&local_this, "PNMImage::Row.set_alpha_val")) {
    return NULL;
  }
  // 1-inline void PNMImage::Row::set_alpha_val(int x, xelval v)
  int param1;
  long param2;
  static const char *keyword_list[] = {"x", "v", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "il:set_alpha_val", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param2 < 0 || param2 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param2);
    }
#endif
    (*local_this).set_alpha_val((int)param1, (xelval)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_val(const Row self, int x, int v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_Row_set_alpha_val_331_comment =
  "C++ Interface:\n"
  "set_alpha_val(const Row self, int x, int v)\n"
  "\n"
  "/**\n"
  " * Set the alpha value at the given column in the row.\n"
  " */";
#else
static const char *Dtool_PNMImage_Row_set_alpha_val_331_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PNMImage::Row::Row(PNMImage::Row const &) = default
 */
static int Dtool_Init_PNMImage_Row(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Row() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline PNMImage::Row::Row(PNMImage::Row const &) = default
  PNMImage::Row const *arg_this = (PNMImage::Row *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage_Row, 0, "Row.Row", true, true);
  if (arg_this != NULL) {
    PNMImage::Row *return_value = new PNMImage::Row(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImage_Row, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Row(const Row param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PNMImage_Row(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PNMImage_Row) {
    printf("PNMImage_Row ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PNMImage::Row *local_this = (PNMImage::Row *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PNMImage_Row) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PNMImage_Row(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PNMImage_Row) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PNMImage::CRow
 */
/**
 * Python function wrapper for:
 * inline xel PNMImage::CRow::get_xel_val(int x) const
 */
static PyObject *Dtool_PNMImage_CRow_get_xel_val_337(PyObject *self, PyObject *arg) {
  PNMImage::CRow *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage_CRow, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline xel PNMImage::CRow::get_xel_val(int x) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    xel *return_value = new xel((*(const PNMImage::CRow*)local_this).get_xel_val((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_pixel, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_xel_val(CRow self, int x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_CRow_get_xel_val_337_comment =
  "C++ Interface:\n"
  "get_xel_val(CRow self, int x)\n"
  "\n"
  "/**\n"
  " * Fetch the pixel at the given column in the row.\n"
  " */";
#else
static const char *Dtool_PNMImage_CRow_get_xel_val_337_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImage::CRow::get_alpha_val(int x) const
 */
static PyObject *Dtool_PNMImage_CRow_get_alpha_val_338(PyObject *self, PyObject *arg) {
  PNMImage::CRow *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage_CRow, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline xelval PNMImage::CRow::get_alpha_val(int x) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    xelval return_value = (*(const PNMImage::CRow*)local_this).get_alpha_val((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_alpha_val(CRow self, int x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_CRow_get_alpha_val_338_comment =
  "C++ Interface:\n"
  "get_alpha_val(CRow self, int x)\n"
  "\n"
  "/**\n"
  " * Fetch the alpha value at the given column in the row.\n"
  " */";
#else
static const char *Dtool_PNMImage_CRow_get_alpha_val_338_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PNMImage::CRow::CRow(PNMImage::CRow const &) = default
 */
static int Dtool_Init_PNMImage_CRow(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CRow() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline PNMImage::CRow::CRow(PNMImage::CRow const &) = default
  PNMImage::CRow const *arg_this = (PNMImage::CRow *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage_CRow, 0, "CRow.CRow", true, true);
  if (arg_this != NULL) {
    PNMImage::CRow *return_value = new PNMImage::CRow(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImage_CRow, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CRow(const CRow param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PNMImage_CRow(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PNMImage_CRow) {
    printf("PNMImage_CRow ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PNMImage::CRow *local_this = (PNMImage::CRow *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PNMImage_CRow) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PNMImage_CRow(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PNMImage_CRow) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PNMPainter
 */
/**
 * Python function wrapper for:
 * inline void PNMPainter::set_pen(PNMBrush *pen)
 */
static PyObject *Dtool_PNMPainter_set_pen_352(PyObject *self, PyObject *arg) {
  PNMPainter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMPainter, (void **)&local_this, "PNMPainter.set_pen")) {
    return NULL;
  }
  // 1-inline void PNMPainter::set_pen(PNMBrush *pen)
  PNMBrush *arg_this = (PNMBrush *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMBrush, 1, "PNMPainter.set_pen", false, true);
  if (arg_this != NULL) {
    (*local_this).set_pen(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pen(const PNMPainter self, PNMBrush pen)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMPainter_set_pen_352_comment =
  "C++ Interface:\n"
  "set_pen(const PNMPainter self, PNMBrush pen)\n"
  "\n"
  "/**\n"
  " * Specifies a PNMBrush that will be used for drawing lines and edges.  If the\n"
  " * brush is a bitmap brush, its image will be smeared pixelwise along the\n"
  " * line.\n"
  " *\n"
  " * Unlike the PNMImage passed to the constructor, the PNMPainter will take\n"
  " * ownership of the pen.  It is not necessary to keep a separate pointer to\n"
  " * it.\n"
  " */";
#else
static const char *Dtool_PNMPainter_set_pen_352_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PNMBrush *PNMPainter::get_pen(void) const
 */
static PyObject *Dtool_PNMPainter_get_pen_353(PyObject *self, PyObject *) {
  PNMPainter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMPainter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PNMBrush *PNMPainter::get_pen(void) const
  PNMBrush *return_value = (*(const PNMPainter*)local_this).get_pen();
  if (return_value != (PNMBrush *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PNMBrush *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMBrush, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PNMPainter_get_pen_353_comment =
  "C++ Interface:\n"
  "get_pen(PNMPainter self)\n"
  "\n"
  "/**\n"
  " * Returns the current pen.  See set_pen().\n"
  " */";
#else
static const char *Dtool_PNMPainter_get_pen_353_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMPainter::set_fill(PNMBrush *fill)
 */
static PyObject *Dtool_PNMPainter_set_fill_354(PyObject *self, PyObject *arg) {
  PNMPainter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMPainter, (void **)&local_this, "PNMPainter.set_fill")) {
    return NULL;
  }
  // 1-inline void PNMPainter::set_fill(PNMBrush *fill)
  PNMBrush *arg_this = (PNMBrush *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMBrush, 1, "PNMPainter.set_fill", false, true);
  if (arg_this != NULL) {
    (*local_this).set_fill(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fill(const PNMPainter self, PNMBrush fill)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMPainter_set_fill_354_comment =
  "C++ Interface:\n"
  "set_fill(const PNMPainter self, PNMBrush fill)\n"
  "\n"
  "/**\n"
  " * Specifies a PNMBrush that will be used for filling in the interiors of\n"
  " * objects.  If the brush is a bitmap brush, its image will be tiled\n"
  " * throughout the space.\n"
  " *\n"
  " * Unlike the PNMImage passed to the constructor, the PNMPainter will take\n"
  " * ownership of the fill brush.  It is not necessary to keep a separate\n"
  " * pointer to it.\n"
  " */";
#else
static const char *Dtool_PNMPainter_set_fill_354_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PNMBrush *PNMPainter::get_fill(void) const
 */
static PyObject *Dtool_PNMPainter_get_fill_355(PyObject *self, PyObject *) {
  PNMPainter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMPainter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PNMBrush *PNMPainter::get_fill(void) const
  PNMBrush *return_value = (*(const PNMPainter*)local_this).get_fill();
  if (return_value != (PNMBrush *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PNMBrush *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMBrush, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PNMPainter_get_fill_355_comment =
  "C++ Interface:\n"
  "get_fill(PNMPainter self)\n"
  "\n"
  "/**\n"
  " * Returns the current fill brush.  See set_fill().\n"
  " */";
#else
static const char *Dtool_PNMPainter_get_fill_355_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PNMPainter::draw_point(float x, float y)
 */
static PyObject *Dtool_PNMPainter_draw_point_359(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMPainter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMPainter, (void **)&local_this, "PNMPainter.draw_point")) {
    return NULL;
  }
  // 1-inline void PNMPainter::draw_point(float x, float y)
  float param1;
  float param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:draw_point", (char **)keyword_list, &param1, &param2)) {
    (*local_this).draw_point((float)param1, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "draw_point(const PNMPainter self, float x, float y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMPainter_draw_point_359_comment =
  "C++ Interface:\n"
  "draw_point(const PNMPainter self, float x, float y)\n"
  "\n"
  "/**\n"
  " * Draws an antialiased point on the PNMImage, using the current pen.\n"
  " */";
#else
static const char *Dtool_PNMPainter_draw_point_359_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMPainter::draw_line(float xa, float ya, float xb, float yb)
 */
static PyObject *Dtool_PNMPainter_draw_line_360(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMPainter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMPainter, (void **)&local_this, "PNMPainter.draw_line")) {
    return NULL;
  }
  // 1-void PNMPainter::draw_line(float xa, float ya, float xb, float yb)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"xa", "ya", "xb", "yb", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:draw_line", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).draw_line((float)param1, (float)param2, (float)param3, (float)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "draw_line(const PNMPainter self, float xa, float ya, float xb, float yb)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMPainter_draw_line_360_comment =
  "C++ Interface:\n"
  "draw_line(const PNMPainter self, float xa, float ya, float xb, float yb)\n"
  "\n"
  "/**\n"
  " * Draws an antialiased line on the PNMImage, using the current pen.\n"
  " */";
#else
static const char *Dtool_PNMPainter_draw_line_360_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PNMPainter::draw_rectangle(float xa, float ya, float xb, float yb)
 */
static PyObject *Dtool_PNMPainter_draw_rectangle_361(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMPainter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMPainter, (void **)&local_this, "PNMPainter.draw_rectangle")) {
    return NULL;
  }
  // 1-void PNMPainter::draw_rectangle(float xa, float ya, float xb, float yb)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"xa", "ya", "xb", "yb", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:draw_rectangle", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).draw_rectangle((float)param1, (float)param2, (float)param3, (float)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "draw_rectangle(const PNMPainter self, float xa, float ya, float xb, float yb)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PNMPainter_draw_rectangle_361_comment =
  "C++ Interface:\n"
  "draw_rectangle(const PNMPainter self, float xa, float ya, float xb, float yb)\n"
  "\n"
  "/**\n"
  " * Draws a filled rectangule on the PNMImage, using the current pen for the\n"
  " * outline, and the current fill brush for the interior.\n"
  " *\n"
  " * The two coordinates specify any two diagonally opposite corners.\n"
  " */";
#else
static const char *Dtool_PNMPainter_draw_rectangle_361_comment = NULL;
#endif

static PyObject *Dtool_PNMPainter_pen_Getter(PyObject *self, void *) {
  const PNMPainter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMPainter, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PNMBrush *PNMPainter::get_pen(void) const
  PNMBrush *return_value = (*(const PNMPainter*)local_this).get_pen();
  if (return_value != (PNMBrush *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (PNMBrush *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMBrush, true, false);
}

static int Dtool_PNMPainter_pen_Setter(PyObject *self, PyObject *arg, void *) {
  PNMPainter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMPainter, (void **)&local_this, "PNMPainter.pen")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete pen attribute");
    return -1;
  }
  // 1-inline void PNMPainter::set_pen(PNMBrush *pen)
  PNMBrush *arg_this = (PNMBrush *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMBrush, 1, "PNMPainter.set_pen", false, true);
  if (arg_this != NULL) {
    (*local_this).set_pen(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_pen(const PNMPainter self, PNMBrush pen)\n");
  }
  return -1;
}

static PyObject *Dtool_PNMPainter_fill_Getter(PyObject *self, void *) {
  const PNMPainter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMPainter, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PNMBrush *PNMPainter::get_fill(void) const
  PNMBrush *return_value = (*(const PNMPainter*)local_this).get_fill();
  if (return_value != (PNMBrush *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (PNMBrush *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMBrush, true, false);
}

static int Dtool_PNMPainter_fill_Setter(PyObject *self, PyObject *arg, void *) {
  PNMPainter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMPainter, (void **)&local_this, "PNMPainter.fill")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete fill attribute");
    return -1;
  }
  // 1-inline void PNMPainter::set_fill(PNMBrush *fill)
  PNMBrush *arg_this = (PNMBrush *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMBrush, 1, "PNMPainter.set_fill", false, true);
  if (arg_this != NULL) {
    (*local_this).set_fill(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_fill(const PNMPainter self, PNMBrush fill)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * PNMPainter::PNMPainter(PNMImage &image, int xo = 0, int yo = 0)
 * inline PNMPainter::PNMPainter(PNMPainter const &) = default
 */
static int Dtool_Init_PNMPainter(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    // -2 PNMPainter::PNMPainter(PNMImage &image, int xo = 0, int yo = 0)
    PyObject *param0;
    int param1 = 0;
    int param2 = 0;
    static const char *keyword_list[] = {"image", "xo", "yo", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|ii:PNMPainter", (char **)keyword_list, &param0, &param1, &param2)) {
      PNMImage *param0_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PNMImage, 0, "PNMPainter.PNMPainter", false, false);
      if (param0_this != NULL) {
        PNMPainter *return_value = new PNMPainter(*param0_this, (int)param1, (int)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMPainter, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: PNMPainter::PNMPainter(PNMImage &image, int xo = 0, int yo = 0)
  {
    // -2 inline PNMPainter::PNMPainter(PNMPainter const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PNMPainter", (char **)keyword_list, &param0)) {
      PNMPainter const *param0_this;
      bool param0_manage = false;
      if (Dtool_ConstCoerce_PNMPainter(param0, param0_this, param0_manage)) {
        PNMPainter *return_value = new PNMPainter(*param0_this);
        if (param0_manage) {
          delete param0_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMPainter, true, false);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PNMPainter(PNMImage image, int xo, int yo)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PNMPainter(PyObject *args, PNMPainter const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PNMPainter, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PNMPainter::PNMPainter(PNMImage &image, int xo, int yo)
    PNMImage *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 0, "PNMPainter.PNMPainter", false, false);
    if (arg_this != NULL) {
      PNMPainter *return_value = new PNMPainter(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      // 1-PNMPainter::PNMPainter(PNMImage &image, int xo, int yo = 0)
      PyObject *param0;
      int param1;
      int param2 = 0;
      if (PyArg_ParseTuple(args, "Oi|i:PNMPainter", &param0, &param1, &param2)) {
        PNMImage *param0_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PNMImage, 0, "PNMPainter.PNMPainter", false, false);
        if (param0_this != NULL) {
          PNMPainter *return_value = new PNMPainter(*param0_this, (int)param1, (int)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_PNMPainter(PyObject *args, PNMPainter *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PNMPainter, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PNMPainter::PNMPainter(PNMImage &image, int xo, int yo)
    PNMImage *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 0, "PNMPainter.PNMPainter", false, false);
    if (arg_this != NULL) {
      PNMPainter *return_value = new PNMPainter(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      // 1-PNMPainter::PNMPainter(PNMImage &image, int xo, int yo = 0)
      PyObject *param0;
      int param1;
      int param2 = 0;
      if (PyArg_ParseTuple(args, "Oi|i:PNMPainter", &param0, &param1, &param2)) {
        PNMImage *param0_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PNMImage, 0, "PNMPainter.PNMPainter", false, false);
        if (param0_this != NULL) {
          PNMPainter *return_value = new PNMPainter(*param0_this, (int)param1, (int)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_PNMPainter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PNMPainter) {
    printf("PNMPainter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PNMPainter *local_this = (PNMPainter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PNMPainter) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PNMPainter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PNMPainter) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for pixel (pixel)
 */
static PyMethodDef Dtool_Methods_pixel[] = {
  {"output", &Dtool_pixel_output_11, METH_O, (const char *)Dtool_pixel_output_11_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// pixel slot nb_add -> operator +
//////////////////
static PyObject *Dtool_pixel_operator_4_nb_add(PyObject *self, PyObject *arg) {
  pixel *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_pixel, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-pixel pixel::operator +(pixel const &other) const
  pixel arg_local;
  pixel const *arg_this = Dtool_Coerce_pixel(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "pixel.__add__", "pixel");
  }
  pixel *return_value = new pixel((*(const pixel*)local_this).operator +(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_pixel, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// pixel slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_pixel_operator_7_nb_inplace_add(PyObject *self, PyObject *arg) {
  pixel *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_pixel, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void pixel::operator +=(pixel const &other)
    pixel arg_local;
    pixel const *arg_this = Dtool_Coerce_pixel(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "pixel.__iadd__", "pixel");
      return NULL;
    }
    (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call pixel.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// pixel slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_pixel_operator_9_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  pixel *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_pixel, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void pixel::operator *=(double const mult)
    if (PyNumber_Check(arg)) {
      (*local_this).operator *=(PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call pixel.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// pixel slot nb_inplace_subtract -> operator -=
//////////////////
static PyObject *Dtool_pixel_operator_8_nb_inplace_subtract(PyObject *self, PyObject *arg) {
  pixel *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_pixel, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void pixel::operator -=(pixel const &other)
    pixel arg_local;
    pixel const *arg_this = Dtool_Coerce_pixel(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "pixel.__isub__", "pixel");
      return NULL;
    }
    (*local_this).operator -=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call pixel.__isub__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// pixel slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_pixel_operator_6_nb_multiply(PyObject *self, PyObject *arg) {
  pixel *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_pixel, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-pixel pixel::operator *(double const mult) const
  if (PyNumber_Check(arg)) {
    pixel *return_value = new pixel((*(const pixel*)local_this).operator *(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_pixel, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// pixel slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_pixel_operator_5_nb_subtract(PyObject *self, PyObject *arg) {
  pixel *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_pixel, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-pixel pixel::operator -(pixel const &other) const
  pixel arg_local;
  pixel const *arg_this = Dtool_Coerce_pixel(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "pixel.__sub__", "pixel");
  }
  pixel *return_value = new pixel((*(const pixel*)local_this).operator -(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_pixel, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// pixel slot sq_ass_item -> operator []
//////////////////
static int Dtool_pixel_operator_3_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  pixel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_pixel, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "pixel index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-gray &pixel::operator [](int i)
      if (PyLongOrInt_Check(arg)) {
        long param2 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param2);
          return -1;
        }
#endif
        (*local_this).operator [](index) = (gray)param2;
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call pixel.__getitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__getitem__(const pixel self, index, int assign_val)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// pixel slot sq_item -> operator []
//////////////////
static PyObject *Dtool_pixel_operator_3_sq_item(PyObject *self, Py_ssize_t index) {
  pixel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_pixel, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "pixel index out of range");
    return NULL;
  }
  // 1-gray pixel::operator [](int i) const
  gray return_value = (*(const pixel*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(pixel self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// pixel slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_pixel_size_10_sq_length(PyObject *self) {
  pixel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_pixel, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
//  A __repr__ function
//     pixel
//////////////////
static PyObject *Dtool_Repr_pixel(PyObject *self) {
  pixel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_pixel, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_pixel[] = {
  {(char *)"b", &Dtool_pixel_b_Getter, &Dtool_pixel_b_Setter, NULL, NULL},
  {(char *)"g", &Dtool_pixel_g_Getter, &Dtool_pixel_g_Setter, NULL, NULL},
  {(char *)"r", &Dtool_pixel_r_Getter, &Dtool_pixel_r_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_pixel = {
  &Dtool_pixel_operator_4_nb_add,
  &Dtool_pixel_operator_5_nb_subtract,
  &Dtool_pixel_operator_6_nb_multiply,
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_pixel_operator_7_nb_inplace_add,
  &Dtool_pixel_operator_8_nb_inplace_subtract,
  &Dtool_pixel_operator_9_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_pixel = {
  &Dtool_pixel_size_10_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_pixel_operator_3_sq_item,
  0, // sq_slice
  &Dtool_pixel_operator_3_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_pixel = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.pixel",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_pixel,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_pixel,
    &Dtool_NumberMethods_pixel,
    &Dtool_SequenceMethods_pixel,
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_pixel,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_pixel,
    0, // tp_members
    Dtool_Properties_pixel,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_pixel,
    PyType_GenericAlloc,
    Dtool_new_pixel,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_pixel,
  Dtool_UpcastInterface_pixel,
  Dtool_DowncastInterface_pixel,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_pixel,
};

static void Dtool_PyModuleClassInit_pixel(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_pixel._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_pixel._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_pixel) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(pixel)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_pixel);
  }
}

/**
 * Python method tables for PNMFileType (PNMFileType)
 */
static PyMethodDef Dtool_Methods_PNMFileType[] = {
  {"get_name", &Dtool_PNMFileType_get_name_31, METH_NOARGS, (const char *)Dtool_PNMFileType_get_name_31_comment},
  {"getName", &Dtool_PNMFileType_get_name_31, METH_NOARGS, (const char *)Dtool_PNMFileType_get_name_31_comment},
  {"get_num_extensions", &Dtool_PNMFileType_get_num_extensions_32, METH_NOARGS, (const char *)Dtool_PNMFileType_get_num_extensions_32_comment},
  {"getNumExtensions", &Dtool_PNMFileType_get_num_extensions_32, METH_NOARGS, (const char *)Dtool_PNMFileType_get_num_extensions_32_comment},
  {"get_extension", &Dtool_PNMFileType_get_extension_33, METH_O, (const char *)Dtool_PNMFileType_get_extension_33_comment},
  {"getExtension", &Dtool_PNMFileType_get_extension_33, METH_O, (const char *)Dtool_PNMFileType_get_extension_33_comment},
  {"get_suggested_extension", &Dtool_PNMFileType_get_suggested_extension_35, METH_NOARGS, (const char *)Dtool_PNMFileType_get_suggested_extension_35_comment},
  {"getSuggestedExtension", &Dtool_PNMFileType_get_suggested_extension_35, METH_NOARGS, (const char *)Dtool_PNMFileType_get_suggested_extension_35_comment},
  {"get_class_type", &Dtool_PNMFileType_get_class_type_41, METH_NOARGS | METH_STATIC, (const char *)Dtool_PNMFileType_get_class_type_41_comment},
  {"getClassType", &Dtool_PNMFileType_get_class_type_41, METH_NOARGS | METH_STATIC, (const char *)Dtool_PNMFileType_get_class_type_41_comment},
  {"get_extensions", (PyCFunction) &MakeSeq_PNMFileType_get_extensions, METH_NOARGS, NULL},
  { "getExtensions", (PyCFunction) &MakeSeq_PNMFileType_get_extensions, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_PNMFileType[] = {
  {(char *)"name", &Dtool_PNMFileType_name_Getter, NULL, NULL, NULL},
  {(char *)"extensions", &Dtool_PNMFileType_extensions_Getter, NULL, NULL, NULL},
  {(char *)"suggested_extension", &Dtool_PNMFileType_suggested_extension_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_PNMFileType = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PNMFileType = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PNMFileType = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PNMFileType = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PNMFileType = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PNMFileType",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMFileType,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PNMFileType,
    &Dtool_SequenceMethods_PNMFileType,
    &Dtool_MappingMethods_PNMFileType,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PNMFileType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class of a family of classes that represent particular\n"
    " * image file types that PNMImage supports.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PNMFileType,
    0, // tp_members
    Dtool_Properties_PNMFileType,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PNMFileType,
    PyType_GenericAlloc,
    Dtool_new_PNMFileType,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMFileType,
  Dtool_UpcastInterface_PNMFileType,
  Dtool_DowncastInterface_PNMFileType,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PNMFileType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritable != NULL);
    assert(Dtool_Ptr_TypedWritable->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedWritable->_Dtool_ModuleClassInit(NULL);
    Dtool_PNMFileType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedWritable);
    PyObject *dict = PyDict_New();
    Dtool_PNMFileType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMFileType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMFileType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMFileType);
  }
}

/**
 * Python method tables for PNMFileTypeRegistry (PNMFileTypeRegistry)
 */
static PyMethodDef Dtool_Methods_PNMFileTypeRegistry[] = {
  {"get_num_types", &Dtool_PNMFileTypeRegistry_get_num_types_44, METH_NOARGS, (const char *)Dtool_PNMFileTypeRegistry_get_num_types_44_comment},
  {"getNumTypes", &Dtool_PNMFileTypeRegistry_get_num_types_44, METH_NOARGS, (const char *)Dtool_PNMFileTypeRegistry_get_num_types_44_comment},
  {"get_type", &Dtool_PNMFileTypeRegistry_get_type_45, METH_O, (const char *)Dtool_PNMFileTypeRegistry_get_type_45_comment},
  {"getType", &Dtool_PNMFileTypeRegistry_get_type_45, METH_O, (const char *)Dtool_PNMFileTypeRegistry_get_type_45_comment},
  {"get_type_from_extension", &Dtool_PNMFileTypeRegistry_get_type_from_extension_49, METH_O, (const char *)Dtool_PNMFileTypeRegistry_get_type_from_extension_49_comment},
  {"getTypeFromExtension", &Dtool_PNMFileTypeRegistry_get_type_from_extension_49, METH_O, (const char *)Dtool_PNMFileTypeRegistry_get_type_from_extension_49_comment},
  {"get_type_from_magic_number", &Dtool_PNMFileTypeRegistry_get_type_from_magic_number_50, METH_O, (const char *)Dtool_PNMFileTypeRegistry_get_type_from_magic_number_50_comment},
  {"getTypeFromMagicNumber", &Dtool_PNMFileTypeRegistry_get_type_from_magic_number_50, METH_O, (const char *)Dtool_PNMFileTypeRegistry_get_type_from_magic_number_50_comment},
  {"get_type_by_handle", &Dtool_PNMFileTypeRegistry_get_type_by_handle_51, METH_O, (const char *)Dtool_PNMFileTypeRegistry_get_type_by_handle_51_comment},
  {"getTypeByHandle", &Dtool_PNMFileTypeRegistry_get_type_by_handle_51, METH_O, (const char *)Dtool_PNMFileTypeRegistry_get_type_by_handle_51_comment},
  {"write", (PyCFunction) &Dtool_PNMFileTypeRegistry_write_52, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMFileTypeRegistry_write_52_comment},
  {"get_global_ptr", &Dtool_PNMFileTypeRegistry_get_global_ptr_53, METH_NOARGS | METH_STATIC, (const char *)Dtool_PNMFileTypeRegistry_get_global_ptr_53_comment},
  {"getGlobalPtr", &Dtool_PNMFileTypeRegistry_get_global_ptr_53, METH_NOARGS | METH_STATIC, (const char *)Dtool_PNMFileTypeRegistry_get_global_ptr_53_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_types", (PyCFunction) &MakeSeq_PNMFileTypeRegistry_get_types, METH_NOARGS, NULL},
  { "getTypes", (PyCFunction) &MakeSeq_PNMFileTypeRegistry_get_types, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     PNMFileTypeRegistry
//////////////////
static PyObject *Dtool_Str_PNMFileTypeRegistry(PyObject *self) {
  PNMFileTypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileTypeRegistry, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_PNMFileTypeRegistry[] = {
  {(char *)"types", &Dtool_PNMFileTypeRegistry_types_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_PNMFileTypeRegistry = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_PNMFileTypeRegistry = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PNMFileTypeRegistry",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMFileTypeRegistry,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PNMFileTypeRegistry,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_PNMFileTypeRegistry,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class maintains the set of all known PNMFileTypes in the universe.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PNMFileTypeRegistry,
    0, // tp_members
    Dtool_Properties_PNMFileTypeRegistry,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PNMFileTypeRegistry,
    PyType_GenericAlloc,
    Dtool_new_PNMFileTypeRegistry,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMFileTypeRegistry,
  Dtool_UpcastInterface_PNMFileTypeRegistry,
  Dtool_DowncastInterface_PNMFileTypeRegistry,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PNMFileTypeRegistry(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PNMFileTypeRegistry._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_PNMFileTypeRegistry._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMFileTypeRegistry) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMFileTypeRegistry)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMFileTypeRegistry);
  }
}

/**
 * Python method tables for PNMImageHeader_PixelSpec (PixelSpec)
 */
static PyMethodDef Dtool_Methods_PNMImageHeader_PixelSpec[] = {
  {"assign", &Dtool_PNMImageHeader_PixelSpec_operator_91, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_operator_91_comment},
  {"compare_to", &Dtool_PNMImageHeader_PixelSpec_compare_to_95, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_compare_to_95_comment},
  {"compareTo", &Dtool_PNMImageHeader_PixelSpec_compare_to_95, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_compare_to_95_comment},
  {"get_red", &Dtool_PNMImageHeader_PixelSpec_get_red_96, METH_NOARGS, (const char *)Dtool_PNMImageHeader_PixelSpec_get_red_96_comment},
  {"getRed", &Dtool_PNMImageHeader_PixelSpec_get_red_96, METH_NOARGS, (const char *)Dtool_PNMImageHeader_PixelSpec_get_red_96_comment},
  {"get_green", &Dtool_PNMImageHeader_PixelSpec_get_green_97, METH_NOARGS, (const char *)Dtool_PNMImageHeader_PixelSpec_get_green_97_comment},
  {"getGreen", &Dtool_PNMImageHeader_PixelSpec_get_green_97, METH_NOARGS, (const char *)Dtool_PNMImageHeader_PixelSpec_get_green_97_comment},
  {"get_blue", &Dtool_PNMImageHeader_PixelSpec_get_blue_98, METH_NOARGS, (const char *)Dtool_PNMImageHeader_PixelSpec_get_blue_98_comment},
  {"getBlue", &Dtool_PNMImageHeader_PixelSpec_get_blue_98, METH_NOARGS, (const char *)Dtool_PNMImageHeader_PixelSpec_get_blue_98_comment},
  {"get_alpha", &Dtool_PNMImageHeader_PixelSpec_get_alpha_99, METH_NOARGS, (const char *)Dtool_PNMImageHeader_PixelSpec_get_alpha_99_comment},
  {"getAlpha", &Dtool_PNMImageHeader_PixelSpec_get_alpha_99, METH_NOARGS, (const char *)Dtool_PNMImageHeader_PixelSpec_get_alpha_99_comment},
  {"set_red", &Dtool_PNMImageHeader_PixelSpec_set_red_100, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_set_red_100_comment},
  {"setRed", &Dtool_PNMImageHeader_PixelSpec_set_red_100, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_set_red_100_comment},
  {"set_green", &Dtool_PNMImageHeader_PixelSpec_set_green_101, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_set_green_101_comment},
  {"setGreen", &Dtool_PNMImageHeader_PixelSpec_set_green_101, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_set_green_101_comment},
  {"set_blue", &Dtool_PNMImageHeader_PixelSpec_set_blue_102, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_set_blue_102_comment},
  {"setBlue", &Dtool_PNMImageHeader_PixelSpec_set_blue_102, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_set_blue_102_comment},
  {"set_alpha", &Dtool_PNMImageHeader_PixelSpec_set_alpha_103, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_set_alpha_103_comment},
  {"setAlpha", &Dtool_PNMImageHeader_PixelSpec_set_alpha_103, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_set_alpha_103_comment},
  {"output", &Dtool_PNMImageHeader_PixelSpec_output_106, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_output_106_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImageHeader_PixelSpec slot sq_item -> operator []
//////////////////
static PyObject *Dtool_PNMImageHeader_PixelSpec_operator_104_sq_item(PyObject *self, Py_ssize_t index) {
  PNMImageHeader::PixelSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PNMImageHeader_PixelSpec index out of range");
    return NULL;
  }
  // 1-inline xelval PNMImageHeader::PixelSpec::operator [](int n) const
  xelval return_value = (*(const PNMImageHeader::PixelSpec*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PixelSpec self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImageHeader_PixelSpec slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PNMImageHeader_PixelSpec_size_105_sq_length(PyObject *self) {
  PNMImageHeader::PixelSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImageHeader_PixelSpec slot tp_compare -> compare_to
//////////////////
static int Dtool_PNMImageHeader_PixelSpec_compare_to_95_tp_compare(PyObject *self, PyObject *arg) {
  PNMImageHeader::PixelSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int PNMImageHeader::PixelSpec::compare_to(PNMImageHeader::PixelSpec const &other) const
  PNMImageHeader::PixelSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_PNMImageHeader_PixelSpec(arg, arg_this, arg_manage)) {
    Dtool_Raise_ArgTypeError(arg, 1, "PixelSpec.compare_to", "PixelSpec");
    return -1;
  }
  int return_value = (*(const PNMImageHeader::PixelSpec*)local_this).compare_to(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(PixelSpec self, const PixelSpec other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     PNMImageHeader_PixelSpec
//////////////////
static PyObject *Dtool_Repr_PNMImageHeader_PixelSpec(PyObject *self) {
  PNMImageHeader::PixelSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     PNMImageHeader_PixelSpec
//////////////////
static PyObject *Dtool_RichCompare_PNMImageHeader_PixelSpec(PyObject *self, PyObject *arg, int op) {
  PNMImageHeader::PixelSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_LT:
    {
      // 1-inline bool PNMImageHeader::PixelSpec::operator <(PNMImageHeader::PixelSpec const &other) const
      PNMImageHeader::PixelSpec const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_PNMImageHeader_PixelSpec(arg, arg_this, arg_manage)) {
        bool return_value = (*(const PNMImageHeader::PixelSpec*)local_this).operator <(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_EQ:
    {
      // 1-inline bool PNMImageHeader::PixelSpec::operator ==(PNMImageHeader::PixelSpec const &other) const
      PNMImageHeader::PixelSpec const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_PNMImageHeader_PixelSpec(arg, arg_this, arg_manage)) {
        bool return_value = (*(const PNMImageHeader::PixelSpec*)local_this).operator ==(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool PNMImageHeader::PixelSpec::operator !=(PNMImageHeader::PixelSpec const &other) const
      PNMImageHeader::PixelSpec const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_PNMImageHeader_PixelSpec(arg, arg_this, arg_manage)) {
        bool return_value = (*(const PNMImageHeader::PixelSpec*)local_this).operator !=(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_PNMImageHeader_PixelSpec_compare_to_95_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_PNMImageHeader_PixelSpec = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PNMImageHeader_PixelSpec = {
  &Dtool_PNMImageHeader_PixelSpec_size_105_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PNMImageHeader_PixelSpec_operator_104_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_PNMImageHeader_PixelSpec = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PixelSpec",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMImageHeader_PixelSpec,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_PNMImageHeader_PixelSpec_compare_to_95_tp_compare,
#endif
    &Dtool_Repr_PNMImageHeader_PixelSpec,
    &Dtool_NumberMethods_PNMImageHeader_PixelSpec,
    &Dtool_SequenceMethods_PNMImageHeader_PixelSpec,
    0, // tp_as_mapping
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Repr_PNMImageHeader_PixelSpec,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// Contains a single pixel specification used in compute_histogram() and\n"
    "// make_histogram().  Note that pixels are stored by integer value, not by\n"
    "// floating-point scaled value.",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_PNMImageHeader_PixelSpec,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PNMImageHeader_PixelSpec,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PNMImageHeader_PixelSpec,
    PyType_GenericAlloc,
    Dtool_new_PNMImageHeader_PixelSpec,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMImageHeader_PixelSpec,
  Dtool_UpcastInterface_PNMImageHeader_PixelSpec,
  Dtool_DowncastInterface_PNMImageHeader_PixelSpec,
  (CoerceFunction)Dtool_ConstCoerce_PNMImageHeader_PixelSpec,
  (CoerceFunction)Dtool_Coerce_PNMImageHeader_PixelSpec,
};

static void Dtool_PyModuleClassInit_PNMImageHeader_PixelSpec(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PNMImageHeader_PixelSpec._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_PNMImageHeader_PixelSpec._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMImageHeader_PixelSpec) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMImageHeader_PixelSpec)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMImageHeader_PixelSpec);
  }
}

/**
 * Python method tables for PNMImageHeader_PixelSpecCount (PixelSpecCount)
 */
static PyMethodDef Dtool_Methods_PNMImageHeader_PixelSpecCount[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PNMImageHeader_PixelSpecCount = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_PNMImageHeader_PixelSpecCount = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PixelSpecCount",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMImageHeader_PixelSpecCount,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PNMImageHeader_PixelSpecCount,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// Associates a pixel specification with an appearance count, for use in\n"
    "// Histogram, below.",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PNMImageHeader_PixelSpecCount,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PNMImageHeader_PixelSpecCount,
    PyType_GenericAlloc,
    Dtool_new_PNMImageHeader_PixelSpecCount,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMImageHeader_PixelSpecCount,
  Dtool_UpcastInterface_PNMImageHeader_PixelSpecCount,
  Dtool_DowncastInterface_PNMImageHeader_PixelSpecCount,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PNMImageHeader_PixelSpecCount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PNMImageHeader_PixelSpecCount._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_PNMImageHeader_PixelSpecCount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMImageHeader_PixelSpecCount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMImageHeader_PixelSpecCount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMImageHeader_PixelSpecCount);
  }
}

/**
 * Python method tables for PNMImageHeader_Histogram (Histogram)
 */
static PyMethodDef Dtool_Methods_PNMImageHeader_Histogram[] = {
  {"get_num_pixels", &Dtool_PNMImageHeader_Histogram_get_num_pixels_119, METH_NOARGS, (const char *)Dtool_PNMImageHeader_Histogram_get_num_pixels_119_comment},
  {"getNumPixels", &Dtool_PNMImageHeader_Histogram_get_num_pixels_119, METH_NOARGS, (const char *)Dtool_PNMImageHeader_Histogram_get_num_pixels_119_comment},
  {"get_pixel", &Dtool_PNMImageHeader_Histogram_get_pixel_120, METH_O, (const char *)Dtool_PNMImageHeader_Histogram_get_pixel_120_comment},
  {"getPixel", &Dtool_PNMImageHeader_Histogram_get_pixel_120, METH_O, (const char *)Dtool_PNMImageHeader_Histogram_get_pixel_120_comment},
  {"get_count", &Dtool_PNMImageHeader_Histogram_get_count_121, METH_O, (const char *)Dtool_PNMImageHeader_Histogram_get_count_121_comment},
  {"getCount", &Dtool_PNMImageHeader_Histogram_get_count_121, METH_O, (const char *)Dtool_PNMImageHeader_Histogram_get_count_121_comment},
  {"write", &Dtool_PNMImageHeader_Histogram_write_123, METH_O, (const char *)Dtool_PNMImageHeader_Histogram_write_123_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_pixels", (PyCFunction) &MakeSeq_PNMImageHeader_Histogram_get_pixels, METH_NOARGS, NULL},
  { "getPixels", (PyCFunction) &MakeSeq_PNMImageHeader_Histogram_get_pixels, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     PNMImageHeader_Histogram
//////////////////
static PyObject *Dtool_Str_PNMImageHeader_Histogram(PyObject *self) {
  PNMImageHeader::Histogram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_Histogram, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PNMImageHeader_Histogram = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_PNMImageHeader_Histogram = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Histogram",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMImageHeader_Histogram,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PNMImageHeader_Histogram,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_PNMImageHeader_Histogram,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// Used to return a pixel histogram in PNMImage::get_histogram().",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PNMImageHeader_Histogram,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PNMImageHeader_Histogram,
    PyType_GenericAlloc,
    Dtool_new_PNMImageHeader_Histogram,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMImageHeader_Histogram,
  Dtool_UpcastInterface_PNMImageHeader_Histogram,
  Dtool_DowncastInterface_PNMImageHeader_Histogram,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PNMImageHeader_Histogram(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PNMImageHeader_Histogram._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_PNMImageHeader_Histogram._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMImageHeader_Histogram) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMImageHeader_Histogram)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMImageHeader_Histogram);
  }
}

/**
 * Python method tables for PNMImageHeader (PNMImageHeader)
 */
static PyMethodDef Dtool_Methods_PNMImageHeader[] = {
  {"assign", &Dtool_PNMImageHeader_operator_57, METH_O, (const char *)Dtool_PNMImageHeader_operator_57_comment},
  {"get_color_type", &Dtool_PNMImageHeader_get_color_type_60, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_color_type_60_comment},
  {"getColorType", &Dtool_PNMImageHeader_get_color_type_60, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_color_type_60_comment},
  {"get_num_channels", &Dtool_PNMImageHeader_get_num_channels_61, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_num_channels_61_comment},
  {"getNumChannels", &Dtool_PNMImageHeader_get_num_channels_61, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_num_channels_61_comment},
  {"is_grayscale", &Dtool_PNMImageHeader_is_grayscale_64, METH_VARARGS, (const char *)Dtool_PNMImageHeader_is_grayscale_64_comment},
  {"isGrayscale", &Dtool_PNMImageHeader_is_grayscale_64, METH_VARARGS, (const char *)Dtool_PNMImageHeader_is_grayscale_64_comment},
  {"has_alpha", &Dtool_PNMImageHeader_has_alpha_65, METH_VARARGS, (const char *)Dtool_PNMImageHeader_has_alpha_65_comment},
  {"hasAlpha", &Dtool_PNMImageHeader_has_alpha_65, METH_VARARGS, (const char *)Dtool_PNMImageHeader_has_alpha_65_comment},
  {"get_maxval", &Dtool_PNMImageHeader_get_maxval_66, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_maxval_66_comment},
  {"getMaxval", &Dtool_PNMImageHeader_get_maxval_66, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_maxval_66_comment},
  {"get_color_space", &Dtool_PNMImageHeader_get_color_space_67, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_color_space_67_comment},
  {"getColorSpace", &Dtool_PNMImageHeader_get_color_space_67, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_color_space_67_comment},
  {"get_x_size", &Dtool_PNMImageHeader_get_x_size_72, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_x_size_72_comment},
  {"getXSize", &Dtool_PNMImageHeader_get_x_size_72, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_x_size_72_comment},
  {"get_y_size", &Dtool_PNMImageHeader_get_y_size_73, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_y_size_73_comment},
  {"getYSize", &Dtool_PNMImageHeader_get_y_size_73, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_y_size_73_comment},
  {"get_size", &Dtool_PNMImageHeader_get_size_74, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_size_74_comment},
  {"getSize", &Dtool_PNMImageHeader_get_size_74, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_size_74_comment},
  {"get_comment", &Dtool_PNMImageHeader_get_comment_77, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_comment_77_comment},
  {"getComment", &Dtool_PNMImageHeader_get_comment_77, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_comment_77_comment},
  {"set_comment", &Dtool_PNMImageHeader_set_comment_78, METH_O, (const char *)Dtool_PNMImageHeader_set_comment_78_comment},
  {"setComment", &Dtool_PNMImageHeader_set_comment_78, METH_O, (const char *)Dtool_PNMImageHeader_set_comment_78_comment},
  {"has_type", &Dtool_PNMImageHeader_has_type_80, METH_NOARGS, (const char *)Dtool_PNMImageHeader_has_type_80_comment},
  {"hasType", &Dtool_PNMImageHeader_has_type_80, METH_NOARGS, (const char *)Dtool_PNMImageHeader_has_type_80_comment},
  {"get_type", &Dtool_PNMImageHeader_get_type_81, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_type_81_comment},
  {"getType", &Dtool_PNMImageHeader_get_type_81, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_type_81_comment},
  {"set_type", &Dtool_PNMImageHeader_set_type_82, METH_O, (const char *)Dtool_PNMImageHeader_set_type_82_comment},
  {"setType", &Dtool_PNMImageHeader_set_type_82, METH_O, (const char *)Dtool_PNMImageHeader_set_type_82_comment},
  {"read_header", (PyCFunction) &Dtool_PNMImageHeader_read_header_84, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImageHeader_read_header_84_comment},
  {"readHeader", (PyCFunction) &Dtool_PNMImageHeader_read_header_84, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImageHeader_read_header_84_comment},
  {"output", &Dtool_PNMImageHeader_output_88, METH_O, (const char *)Dtool_PNMImageHeader_output_88_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PNMImageHeader
//////////////////
static PyObject *Dtool_Repr_PNMImageHeader(PyObject *self) {
  PNMImageHeader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_PNMImageHeader[] = {
  {(char *)"num_channels", &Dtool_PNMImageHeader_num_channels_Getter, NULL, NULL, NULL},
  {(char *)"maxval", &Dtool_PNMImageHeader_maxval_Getter, NULL, NULL, NULL},
  {(char *)"color_space", &Dtool_PNMImageHeader_color_space_Getter, NULL, NULL, NULL},
  {(char *)"size", &Dtool_PNMImageHeader_size_Getter, NULL, NULL, NULL},
  {(char *)"comment", &Dtool_PNMImageHeader_comment_Getter, &Dtool_PNMImageHeader_comment_Setter, NULL, NULL},
  {(char *)"type", &Dtool_PNMImageHeader_type_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_PNMImageHeader = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_PNMImageHeader = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PNMImageHeader",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMImageHeader,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PNMImageHeader,
    &Dtool_NumberMethods_PNMImageHeader,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PNMImageHeader,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class of PNMImage, PNMReader, and PNMWriter.  It\n"
    " * encapsulates all the information associated with an image that describes\n"
    " * its size, number of channels, etc; that is, all the information about the\n"
    " * image except the image data itself.  It's the sort of information you\n"
    " * typically read from the image file's header.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PNMImageHeader,
    0, // tp_members
    Dtool_Properties_PNMImageHeader,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PNMImageHeader,
    PyType_GenericAlloc,
    Dtool_new_PNMImageHeader,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMImageHeader,
  Dtool_UpcastInterface_PNMImageHeader,
  Dtool_DowncastInterface_PNMImageHeader,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PNMImageHeader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PNMImageHeader._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(18);
    Dtool_PNMImageHeader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum PNMImageHeader::ColorType;
    PyDict_SetItemString(dict, "CT_invalid", Dtool_WrapValue(PNMImageHeader::CT_invalid));
    PyDict_SetItemString(dict, "CTInvalid", Dtool_WrapValue(PNMImageHeader::CT_invalid));
    PyDict_SetItemString(dict, "CT_grayscale", Dtool_WrapValue(PNMImageHeader::CT_grayscale));
    PyDict_SetItemString(dict, "CTGrayscale", Dtool_WrapValue(PNMImageHeader::CT_grayscale));
    PyDict_SetItemString(dict, "CT_two_channel", Dtool_WrapValue(PNMImageHeader::CT_two_channel));
    PyDict_SetItemString(dict, "CTTwoChannel", Dtool_WrapValue(PNMImageHeader::CT_two_channel));
    PyDict_SetItemString(dict, "CT_color", Dtool_WrapValue(PNMImageHeader::CT_color));
    PyDict_SetItemString(dict, "CTColor", Dtool_WrapValue(PNMImageHeader::CT_color));
    PyDict_SetItemString(dict, "CT_four_channel", Dtool_WrapValue(PNMImageHeader::CT_four_channel));
    PyDict_SetItemString(dict, "CTFourChannel", Dtool_WrapValue(PNMImageHeader::CT_four_channel));
    // Nested Object   PNMImageHeader_PixelSpec;
    Dtool_PyModuleClassInit_PNMImageHeader_PixelSpec(NULL);
    PyDict_SetItemString(dict, "PixelSpec", (PyObject *)&Dtool_PNMImageHeader_PixelSpec);
    // Nested Object   PNMImageHeader_PixelSpecCount;
    Dtool_PyModuleClassInit_PNMImageHeader_PixelSpecCount(NULL);
    PyDict_SetItemString(dict, "PixelSpecCount", (PyObject *)&Dtool_PNMImageHeader_PixelSpecCount);
    // Nested Object   PNMImageHeader_Histogram;
    Dtool_PyModuleClassInit_PNMImageHeader_Histogram(NULL);
    PyDict_SetItemString(dict, "Histogram", (PyObject *)&Dtool_PNMImageHeader_Histogram);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMImageHeader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMImageHeader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMImageHeader);
  }
}

/**
 * Python method tables for PfmFile (PfmFile)
 */
static PyMethodDef Dtool_Methods_PfmFile[] = {
  {"assign", &Dtool_PfmFile_operator_127, METH_O, (const char *)Dtool_PfmFile_operator_127_comment},
  {"clear", (PyCFunction) &Dtool_PfmFile_clear_128, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_clear_128_comment},
  {"read", (PyCFunction) &Dtool_PfmFile_read_129, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_read_129_comment},
  {"write", (PyCFunction) &Dtool_PfmFile_write_130, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_write_130_comment},
  {"load", &Dtool_PfmFile_load_131, METH_O, (const char *)Dtool_PfmFile_load_131_comment},
  {"store", &Dtool_PfmFile_store_132, METH_O, (const char *)Dtool_PfmFile_store_132_comment},
  {"store_mask", (PyCFunction) &Dtool_PfmFile_store_mask_133, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_store_mask_133_comment},
  {"storeMask", (PyCFunction) &Dtool_PfmFile_store_mask_133, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_store_mask_133_comment},
  {"is_valid", &Dtool_PfmFile_is_valid_134, METH_NOARGS, (const char *)Dtool_PfmFile_is_valid_134_comment},
  {"isValid", &Dtool_PfmFile_is_valid_134, METH_NOARGS, (const char *)Dtool_PfmFile_is_valid_134_comment},
  {"get_scale", &Dtool_PfmFile_get_scale_137, METH_NOARGS, (const char *)Dtool_PfmFile_get_scale_137_comment},
  {"getScale", &Dtool_PfmFile_get_scale_137, METH_NOARGS, (const char *)Dtool_PfmFile_get_scale_137_comment},
  {"set_scale", &Dtool_PfmFile_set_scale_138, METH_O, (const char *)Dtool_PfmFile_set_scale_138_comment},
  {"setScale", &Dtool_PfmFile_set_scale_138, METH_O, (const char *)Dtool_PfmFile_set_scale_138_comment},
  {"has_point", (PyCFunction) &Dtool_PfmFile_has_point_142, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_has_point_142_comment},
  {"hasPoint", (PyCFunction) &Dtool_PfmFile_has_point_142, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_has_point_142_comment},
  {"get_channel", (PyCFunction) &Dtool_PfmFile_get_channel_143, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_channel_143_comment},
  {"getChannel", (PyCFunction) &Dtool_PfmFile_get_channel_143, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_channel_143_comment},
  {"set_channel", (PyCFunction) &Dtool_PfmFile_set_channel_144, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_channel_144_comment},
  {"setChannel", (PyCFunction) &Dtool_PfmFile_set_channel_144, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_channel_144_comment},
  {"get_point1", (PyCFunction) &Dtool_PfmFile_get_point1_145, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point1_145_comment},
  {"getPoint1", (PyCFunction) &Dtool_PfmFile_get_point1_145, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point1_145_comment},
  {"set_point1", (PyCFunction) &Dtool_PfmFile_set_point1_146, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point1_146_comment},
  {"setPoint1", (PyCFunction) &Dtool_PfmFile_set_point1_146, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point1_146_comment},
  {"get_point2", (PyCFunction) &Dtool_PfmFile_get_point2_147, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point2_147_comment},
  {"getPoint2", (PyCFunction) &Dtool_PfmFile_get_point2_147, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point2_147_comment},
  {"set_point2", (PyCFunction) &Dtool_PfmFile_set_point2_148, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point2_148_comment},
  {"setPoint2", (PyCFunction) &Dtool_PfmFile_set_point2_148, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point2_148_comment},
  {"modify_point2", (PyCFunction) &Dtool_PfmFile_modify_point2_149, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_modify_point2_149_comment},
  {"modifyPoint2", (PyCFunction) &Dtool_PfmFile_modify_point2_149, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_modify_point2_149_comment},
  {"get_point", (PyCFunction) &Dtool_PfmFile_get_point_150, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point_150_comment},
  {"getPoint", (PyCFunction) &Dtool_PfmFile_get_point_150, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point_150_comment},
  {"set_point", (PyCFunction) &Dtool_PfmFile_set_point_151, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point_151_comment},
  {"setPoint", (PyCFunction) &Dtool_PfmFile_set_point_151, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point_151_comment},
  {"modify_point", (PyCFunction) &Dtool_PfmFile_modify_point_152, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_modify_point_152_comment},
  {"modifyPoint", (PyCFunction) &Dtool_PfmFile_modify_point_152, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_modify_point_152_comment},
  {"get_point3", (PyCFunction) &Dtool_PfmFile_get_point3_153, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point3_153_comment},
  {"getPoint3", (PyCFunction) &Dtool_PfmFile_get_point3_153, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point3_153_comment},
  {"set_point3", (PyCFunction) &Dtool_PfmFile_set_point3_154, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point3_154_comment},
  {"setPoint3", (PyCFunction) &Dtool_PfmFile_set_point3_154, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point3_154_comment},
  {"modify_point3", (PyCFunction) &Dtool_PfmFile_modify_point3_155, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_modify_point3_155_comment},
  {"modifyPoint3", (PyCFunction) &Dtool_PfmFile_modify_point3_155, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_modify_point3_155_comment},
  {"get_point4", (PyCFunction) &Dtool_PfmFile_get_point4_156, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point4_156_comment},
  {"getPoint4", (PyCFunction) &Dtool_PfmFile_get_point4_156, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point4_156_comment},
  {"set_point4", (PyCFunction) &Dtool_PfmFile_set_point4_157, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point4_157_comment},
  {"setPoint4", (PyCFunction) &Dtool_PfmFile_set_point4_157, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point4_157_comment},
  {"modify_point4", (PyCFunction) &Dtool_PfmFile_modify_point4_158, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_modify_point4_158_comment},
  {"modifyPoint4", (PyCFunction) &Dtool_PfmFile_modify_point4_158, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_modify_point4_158_comment},
  {"fill", &Dtool_PfmFile_fill_159, METH_O, (const char *)Dtool_PfmFile_fill_159_comment},
  {"fill_nan", &Dtool_PfmFile_fill_nan_160, METH_NOARGS, (const char *)Dtool_PfmFile_fill_nan_160_comment},
  {"fillNan", &Dtool_PfmFile_fill_nan_160, METH_NOARGS, (const char *)Dtool_PfmFile_fill_nan_160_comment},
  {"fill_no_data_value", &Dtool_PfmFile_fill_no_data_value_161, METH_NOARGS, (const char *)Dtool_PfmFile_fill_no_data_value_161_comment},
  {"fillNoDataValue", &Dtool_PfmFile_fill_no_data_value_161, METH_NOARGS, (const char *)Dtool_PfmFile_fill_no_data_value_161_comment},
  {"fill_channel", (PyCFunction) &Dtool_PfmFile_fill_channel_162, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_fill_channel_162_comment},
  {"fillChannel", (PyCFunction) &Dtool_PfmFile_fill_channel_162, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_fill_channel_162_comment},
  {"fill_channel_nan", &Dtool_PfmFile_fill_channel_nan_163, METH_O, (const char *)Dtool_PfmFile_fill_channel_nan_163_comment},
  {"fillChannelNan", &Dtool_PfmFile_fill_channel_nan_163, METH_O, (const char *)Dtool_PfmFile_fill_channel_nan_163_comment},
  {"fill_channel_masked", (PyCFunction) &Dtool_PfmFile_fill_channel_masked_164, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_fill_channel_masked_164_comment},
  {"fillChannelMasked", (PyCFunction) &Dtool_PfmFile_fill_channel_masked_164, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_fill_channel_masked_164_comment},
  {"fill_channel_masked_nan", &Dtool_PfmFile_fill_channel_masked_nan_165, METH_O, (const char *)Dtool_PfmFile_fill_channel_masked_nan_165_comment},
  {"fillChannelMaskedNan", &Dtool_PfmFile_fill_channel_masked_nan_165, METH_O, (const char *)Dtool_PfmFile_fill_channel_masked_nan_165_comment},
  {"calc_average_point", (PyCFunction) &Dtool_PfmFile_calc_average_point_166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_calc_average_point_166_comment},
  {"calcAveragePoint", (PyCFunction) &Dtool_PfmFile_calc_average_point_166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_calc_average_point_166_comment},
  {"calc_bilinear_point", (PyCFunction) &Dtool_PfmFile_calc_bilinear_point_167, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_calc_bilinear_point_167_comment},
  {"calcBilinearPoint", (PyCFunction) &Dtool_PfmFile_calc_bilinear_point_167, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_calc_bilinear_point_167_comment},
  {"calc_min_max", (PyCFunction) &Dtool_PfmFile_calc_min_max_168, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_calc_min_max_168_comment},
  {"calcMinMax", (PyCFunction) &Dtool_PfmFile_calc_min_max_168, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_calc_min_max_168_comment},
  {"calc_autocrop", &Dtool_PfmFile_calc_autocrop_169, METH_O, (const char *)Dtool_PfmFile_calc_autocrop_169_comment},
  {"calcAutocrop", &Dtool_PfmFile_calc_autocrop_169, METH_O, (const char *)Dtool_PfmFile_calc_autocrop_169_comment},
  {"is_row_empty", (PyCFunction) &Dtool_PfmFile_is_row_empty_170, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_is_row_empty_170_comment},
  {"isRowEmpty", (PyCFunction) &Dtool_PfmFile_is_row_empty_170, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_is_row_empty_170_comment},
  {"is_column_empty", (PyCFunction) &Dtool_PfmFile_is_column_empty_171, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_is_column_empty_171_comment},
  {"isColumnEmpty", (PyCFunction) &Dtool_PfmFile_is_column_empty_171, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_is_column_empty_171_comment},
  {"set_zero_special", &Dtool_PfmFile_set_zero_special_172, METH_O, (const char *)Dtool_PfmFile_set_zero_special_172_comment},
  {"setZeroSpecial", &Dtool_PfmFile_set_zero_special_172, METH_O, (const char *)Dtool_PfmFile_set_zero_special_172_comment},
  {"set_no_data_chan4", &Dtool_PfmFile_set_no_data_chan4_173, METH_O, (const char *)Dtool_PfmFile_set_no_data_chan4_173_comment},
  {"setNoDataChan4", &Dtool_PfmFile_set_no_data_chan4_173, METH_O, (const char *)Dtool_PfmFile_set_no_data_chan4_173_comment},
  {"set_no_data_nan", &Dtool_PfmFile_set_no_data_nan_174, METH_O, (const char *)Dtool_PfmFile_set_no_data_nan_174_comment},
  {"setNoDataNan", &Dtool_PfmFile_set_no_data_nan_174, METH_O, (const char *)Dtool_PfmFile_set_no_data_nan_174_comment},
  {"set_no_data_value", &Dtool_PfmFile_set_no_data_value_175, METH_O, (const char *)Dtool_PfmFile_set_no_data_value_175_comment},
  {"setNoDataValue", &Dtool_PfmFile_set_no_data_value_175, METH_O, (const char *)Dtool_PfmFile_set_no_data_value_175_comment},
  {"set_no_data_threshold", &Dtool_PfmFile_set_no_data_threshold_176, METH_O, (const char *)Dtool_PfmFile_set_no_data_threshold_176_comment},
  {"setNoDataThreshold", &Dtool_PfmFile_set_no_data_threshold_176, METH_O, (const char *)Dtool_PfmFile_set_no_data_threshold_176_comment},
  {"clear_no_data_value", &Dtool_PfmFile_clear_no_data_value_177, METH_NOARGS, (const char *)Dtool_PfmFile_clear_no_data_value_177_comment},
  {"clearNoDataValue", &Dtool_PfmFile_clear_no_data_value_177, METH_NOARGS, (const char *)Dtool_PfmFile_clear_no_data_value_177_comment},
  {"has_no_data_value", &Dtool_PfmFile_has_no_data_value_178, METH_NOARGS, (const char *)Dtool_PfmFile_has_no_data_value_178_comment},
  {"hasNoDataValue", &Dtool_PfmFile_has_no_data_value_178, METH_NOARGS, (const char *)Dtool_PfmFile_has_no_data_value_178_comment},
  {"has_no_data_threshold", &Dtool_PfmFile_has_no_data_threshold_179, METH_NOARGS, (const char *)Dtool_PfmFile_has_no_data_threshold_179_comment},
  {"hasNoDataThreshold", &Dtool_PfmFile_has_no_data_threshold_179, METH_NOARGS, (const char *)Dtool_PfmFile_has_no_data_threshold_179_comment},
  {"get_no_data_value", &Dtool_PfmFile_get_no_data_value_180, METH_NOARGS, (const char *)Dtool_PfmFile_get_no_data_value_180_comment},
  {"getNoDataValue", &Dtool_PfmFile_get_no_data_value_180, METH_NOARGS, (const char *)Dtool_PfmFile_get_no_data_value_180_comment},
  {"resize", (PyCFunction) &Dtool_PfmFile_resize_181, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_resize_181_comment},
  {"box_filter_from", (PyCFunction) &Dtool_PfmFile_box_filter_from_182, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_box_filter_from_182_comment},
  {"boxFilterFrom", (PyCFunction) &Dtool_PfmFile_box_filter_from_182, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_box_filter_from_182_comment},
  {"gaussian_filter_from", (PyCFunction) &Dtool_PfmFile_gaussian_filter_from_183, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_gaussian_filter_from_183_comment},
  {"gaussianFilterFrom", (PyCFunction) &Dtool_PfmFile_gaussian_filter_from_183, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_gaussian_filter_from_183_comment},
  {"quick_filter_from", &Dtool_PfmFile_quick_filter_from_184, METH_O, (const char *)Dtool_PfmFile_quick_filter_from_184_comment},
  {"quickFilterFrom", &Dtool_PfmFile_quick_filter_from_184, METH_O, (const char *)Dtool_PfmFile_quick_filter_from_184_comment},
  {"reverse_rows", &Dtool_PfmFile_reverse_rows_185, METH_NOARGS, (const char *)Dtool_PfmFile_reverse_rows_185_comment},
  {"reverseRows", &Dtool_PfmFile_reverse_rows_185, METH_NOARGS, (const char *)Dtool_PfmFile_reverse_rows_185_comment},
  {"flip", (PyCFunction) &Dtool_PfmFile_flip_186, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_flip_186_comment},
  {"xform", &Dtool_PfmFile_xform_187, METH_O, (const char *)Dtool_PfmFile_xform_187_comment},
  {"forward_distort", (PyCFunction) &Dtool_PfmFile_forward_distort_188, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_forward_distort_188_comment},
  {"forwardDistort", (PyCFunction) &Dtool_PfmFile_forward_distort_188, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_forward_distort_188_comment},
  {"reverse_distort", (PyCFunction) &Dtool_PfmFile_reverse_distort_189, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_reverse_distort_189_comment},
  {"reverseDistort", (PyCFunction) &Dtool_PfmFile_reverse_distort_189, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_reverse_distort_189_comment},
  {"apply_1d_lut", (PyCFunction) &Dtool_PfmFile_apply_1d_lut_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_apply_1d_lut_190_comment},
  {"apply1dLut", (PyCFunction) &Dtool_PfmFile_apply_1d_lut_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_apply_1d_lut_190_comment},
  {"merge", &Dtool_PfmFile_merge_191, METH_O, (const char *)Dtool_PfmFile_merge_191_comment},
  {"apply_mask", &Dtool_PfmFile_apply_mask_192, METH_O, (const char *)Dtool_PfmFile_apply_mask_192_comment},
  {"applyMask", &Dtool_PfmFile_apply_mask_192, METH_O, (const char *)Dtool_PfmFile_apply_mask_192_comment},
  {"copy_channel", (PyCFunction) &Dtool_PfmFile_copy_channel_193, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_copy_channel_193_comment},
  {"copyChannel", (PyCFunction) &Dtool_PfmFile_copy_channel_193, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_copy_channel_193_comment},
  {"copy_channel_masked", (PyCFunction) &Dtool_PfmFile_copy_channel_masked_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_copy_channel_masked_194_comment},
  {"copyChannelMasked", (PyCFunction) &Dtool_PfmFile_copy_channel_masked_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_copy_channel_masked_194_comment},
  {"apply_crop", (PyCFunction) &Dtool_PfmFile_apply_crop_195, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_apply_crop_195_comment},
  {"applyCrop", (PyCFunction) &Dtool_PfmFile_apply_crop_195, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_apply_crop_195_comment},
  {"clear_to_texcoords", (PyCFunction) &Dtool_PfmFile_clear_to_texcoords_196, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_clear_to_texcoords_196_comment},
  {"clearToTexcoords", (PyCFunction) &Dtool_PfmFile_clear_to_texcoords_196, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_clear_to_texcoords_196_comment},
  {"pull_spot", (PyCFunction) &Dtool_PfmFile_pull_spot_197, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_pull_spot_197_comment},
  {"pullSpot", (PyCFunction) &Dtool_PfmFile_pull_spot_197, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_pull_spot_197_comment},
  {"calc_tight_bounds", (PyCFunction) &Dtool_PfmFile_calc_tight_bounds_198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_calc_tight_bounds_198_comment},
  {"calcTightBounds", (PyCFunction) &Dtool_PfmFile_calc_tight_bounds_198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_calc_tight_bounds_198_comment},
  {"compute_planar_bounds", (PyCFunction) &Dtool_PfmFile_compute_planar_bounds_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_compute_planar_bounds_199_comment},
  {"computePlanarBounds", (PyCFunction) &Dtool_PfmFile_compute_planar_bounds_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_compute_planar_bounds_199_comment},
  {"compute_sample_point", (PyCFunction) &Dtool_PfmFile_compute_sample_point_200, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_compute_sample_point_200_comment},
  {"computeSamplePoint", (PyCFunction) &Dtool_PfmFile_compute_sample_point_200, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_compute_sample_point_200_comment},
  {"copy_sub_image", (PyCFunction) &Dtool_PfmFile_copy_sub_image_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_copy_sub_image_201_comment},
  {"copySubImage", (PyCFunction) &Dtool_PfmFile_copy_sub_image_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_copy_sub_image_201_comment},
  {"add_sub_image", (PyCFunction) &Dtool_PfmFile_add_sub_image_202, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_add_sub_image_202_comment},
  {"addSubImage", (PyCFunction) &Dtool_PfmFile_add_sub_image_202, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_add_sub_image_202_comment},
  {"mult_sub_image", (PyCFunction) &Dtool_PfmFile_mult_sub_image_203, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_mult_sub_image_203_comment},
  {"multSubImage", (PyCFunction) &Dtool_PfmFile_mult_sub_image_203, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_mult_sub_image_203_comment},
  {"divide_sub_image", (PyCFunction) &Dtool_PfmFile_divide_sub_image_204, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_divide_sub_image_204_comment},
  {"divideSubImage", (PyCFunction) &Dtool_PfmFile_divide_sub_image_204, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_divide_sub_image_204_comment},
  {"indirect_1d_lookup", (PyCFunction) &Dtool_PfmFile_indirect_1d_lookup_206, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_indirect_1d_lookup_206_comment},
  {"indirect1dLookup", (PyCFunction) &Dtool_PfmFile_indirect_1d_lookup_206, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_indirect_1d_lookup_206_comment},
  {"gamma_correct", (PyCFunction) &Dtool_PfmFile_gamma_correct_207, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_gamma_correct_207_comment},
  {"gammaCorrect", (PyCFunction) &Dtool_PfmFile_gamma_correct_207, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_gamma_correct_207_comment},
  {"gamma_correct_alpha", (PyCFunction) &Dtool_PfmFile_gamma_correct_alpha_208, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_gamma_correct_alpha_208_comment},
  {"gammaCorrectAlpha", (PyCFunction) &Dtool_PfmFile_gamma_correct_alpha_208, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_gamma_correct_alpha_208_comment},
  {"apply_exponent", (PyCFunction) &Dtool_PfmFile_apply_exponent_209, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_apply_exponent_209_comment},
  {"applyExponent", (PyCFunction) &Dtool_PfmFile_apply_exponent_209, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_apply_exponent_209_comment},
  {"output", &Dtool_PfmFile_output_210, METH_O, (const char *)Dtool_PfmFile_output_210_comment},
  {"get_points", &Dtool_PfmFile_get_points_211, METH_NOARGS, (const char *)Dtool_PfmFile_get_points_211_comment},
  {"getPoints", &Dtool_PfmFile_get_points_211, METH_NOARGS, (const char *)Dtool_PfmFile_get_points_211_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PfmFile slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PfmFile_getbuffer_212_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const PfmFile *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PfmFile slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_PfmFile_operator_205_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  PfmFile *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PfmFile, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void PfmFile::operator *=(float multiplier)
    if (PyNumber_Check(arg)) {
      (*local_this).operator *=((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call PfmFile.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
//  A __repr__ function
//     PfmFile
//////////////////
static PyObject *Dtool_Repr_PfmFile(PyObject *self) {
  PfmFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_PfmFile[] = {
  {(char *)"valid", &Dtool_PfmFile_valid_Getter, NULL, NULL, NULL},
  {(char *)"scale", &Dtool_PfmFile_scale_Getter, &Dtool_PfmFile_scale_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_PfmFile = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  &Dtool_PfmFile_operator_205_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PfmFile = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PfmFile = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PfmFile = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PfmFile_getbuffer_212_bf_getbuffer,
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PfmFile = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PfmFile",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PfmFile,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PfmFile,
    &Dtool_NumberMethods_PfmFile,
    &Dtool_SequenceMethods_PfmFile,
    &Dtool_MappingMethods_PfmFile,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PfmFile,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PfmFile,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a pfm file, a 2-d table of floating-point numbers, either\n"
    " * 3-component or 1-component, or with a special extension, 2- or 4-component.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PfmFile,
    0, // tp_members
    Dtool_Properties_PfmFile,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PfmFile,
    PyType_GenericAlloc,
    Dtool_new_PfmFile,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PfmFile,
  Dtool_UpcastInterface_PfmFile,
  Dtool_DowncastInterface_PfmFile,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PfmFile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PNMImageHeader(NULL);
    Dtool_PfmFile._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PNMImageHeader);
    PyObject *dict = PyDict_New();
    Dtool_PfmFile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PfmFile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PfmFile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PfmFile);
  }
}

/**
 * Python method tables for PNMBrush (PNMBrush)
 */
static PyMethodDef Dtool_Methods_PNMBrush[] = {
  {"make_transparent", &Dtool_PNMBrush_make_transparent_217, METH_NOARGS | METH_STATIC, (const char *)Dtool_PNMBrush_make_transparent_217_comment},
  {"makeTransparent", &Dtool_PNMBrush_make_transparent_217, METH_NOARGS | METH_STATIC, (const char *)Dtool_PNMBrush_make_transparent_217_comment},
  {"make_pixel", (PyCFunction) &Dtool_PNMBrush_make_pixel_218, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PNMBrush_make_pixel_218_comment},
  {"makePixel", (PyCFunction) &Dtool_PNMBrush_make_pixel_218, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PNMBrush_make_pixel_218_comment},
  {"make_spot", (PyCFunction) &Dtool_PNMBrush_make_spot_219, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PNMBrush_make_spot_219_comment},
  {"makeSpot", (PyCFunction) &Dtool_PNMBrush_make_spot_219, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PNMBrush_make_spot_219_comment},
  {"make_image", (PyCFunction) &Dtool_PNMBrush_make_image_220, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PNMBrush_make_image_220_comment},
  {"makeImage", (PyCFunction) &Dtool_PNMBrush_make_image_220, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PNMBrush_make_image_220_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PNMBrush = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PNMBrush = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PNMBrush = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PNMBrush = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PNMBrush = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PNMBrush",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMBrush,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PNMBrush,
    &Dtool_SequenceMethods_PNMBrush,
    &Dtool_MappingMethods_PNMBrush,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PNMBrush,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is used to control the shape and color of the drawing operations\n"
    " * performed by a PNMPainter object.\n"
    " *\n"
    " * Normally, you don't create a PNMBrush directly; instead, use one of the\n"
    " * static PNMBrush::make_*() methods provided here.\n"
    " *\n"
    " * A PNMBrush is used to draw the border of a polygon or rectangle, as well as\n"
    " * for filling its interior.  When it is used to draw a border, the brush is\n"
    " * \"smeared\" over the border; when it is used to fill the interior, it is\n"
    " * tiled through the interior.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PNMBrush,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PNMBrush,
    PyType_GenericAlloc,
    Dtool_new_PNMBrush,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMBrush,
  Dtool_UpcastInterface_PNMBrush,
  Dtool_DowncastInterface_PNMBrush,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PNMBrush(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_PNMBrush._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_PNMBrush._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum PNMBrush::BrushEffect;
    PyDict_SetItemString(dict, "BE_set", Dtool_WrapValue(PNMBrush::BE_set));
    PyDict_SetItemString(dict, "BESet", Dtool_WrapValue(PNMBrush::BE_set));
    PyDict_SetItemString(dict, "BE_blend", Dtool_WrapValue(PNMBrush::BE_blend));
    PyDict_SetItemString(dict, "BEBlend", Dtool_WrapValue(PNMBrush::BE_blend));
    PyDict_SetItemString(dict, "BE_darken", Dtool_WrapValue(PNMBrush::BE_darken));
    PyDict_SetItemString(dict, "BEDarken", Dtool_WrapValue(PNMBrush::BE_darken));
    PyDict_SetItemString(dict, "BE_lighten", Dtool_WrapValue(PNMBrush::BE_lighten));
    PyDict_SetItemString(dict, "BELighten", Dtool_WrapValue(PNMBrush::BE_lighten));
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMBrush) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMBrush)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMBrush);
  }
}

/**
 * Python method tables for PNMImage_Row (Row)
 */
static PyMethodDef Dtool_Methods_PNMImage_Row[] = {
  {"get_xel_val", &Dtool_PNMImage_Row_get_xel_val_328, METH_O, (const char *)Dtool_PNMImage_Row_get_xel_val_328_comment},
  {"getXelVal", &Dtool_PNMImage_Row_get_xel_val_328, METH_O, (const char *)Dtool_PNMImage_Row_get_xel_val_328_comment},
  {"set_xel_val", (PyCFunction) &Dtool_PNMImage_Row_set_xel_val_329, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_Row_set_xel_val_329_comment},
  {"setXelVal", (PyCFunction) &Dtool_PNMImage_Row_set_xel_val_329, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_Row_set_xel_val_329_comment},
  {"get_alpha_val", &Dtool_PNMImage_Row_get_alpha_val_330, METH_O, (const char *)Dtool_PNMImage_Row_get_alpha_val_330_comment},
  {"getAlphaVal", &Dtool_PNMImage_Row_get_alpha_val_330, METH_O, (const char *)Dtool_PNMImage_Row_get_alpha_val_330_comment},
  {"set_alpha_val", (PyCFunction) &Dtool_PNMImage_Row_set_alpha_val_331, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_Row_set_alpha_val_331_comment},
  {"setAlphaVal", (PyCFunction) &Dtool_PNMImage_Row_set_alpha_val_331, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_Row_set_alpha_val_331_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage_Row slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PNMImage_Row_setitem_327_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PNMImage::Row *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage_Row, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PNMImage_Row index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImage::Row::__setitem__(int x, LColorf const &v)
      LVecBase4f arg_local;
      LColorf const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 2, "Row.__setitem__", "LVecBase4f");
        return -1;
      }
      (*local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call Row.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const Row self, index, const LVecBase4f v)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage_Row slot sq_item -> operator []
//////////////////
static PyObject *Dtool_PNMImage_Row_operator_326_sq_item(PyObject *self, Py_ssize_t index) {
  PNMImage::Row *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage_Row, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PNMImage_Row index out of range");
    return NULL;
  }
  // 1-inline LColorf PNMImage::Row::operator [](int x) const
  LColorf *return_value = new LColorf((*(const PNMImage::Row*)local_this).operator [](index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(Row self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage_Row slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PNMImage_Row_size_325_sq_length(PyObject *self) {
  PNMImage::Row *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage_Row, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PNMImage_Row = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PNMImage_Row = {
  &Dtool_PNMImage_Row_size_325_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PNMImage_Row_operator_326_sq_item,
  0, // sq_slice
  &Dtool_PNMImage_Row_setitem_327_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_PNMImage_Row = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Row",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMImage_Row,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PNMImage_Row,
    &Dtool_SequenceMethods_PNMImage_Row,
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// Provides an accessor for reading or writing the contents of one row of\n"
    "// the image in-place.",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PNMImage_Row,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PNMImage_Row,
    PyType_GenericAlloc,
    Dtool_new_PNMImage_Row,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMImage_Row,
  Dtool_UpcastInterface_PNMImage_Row,
  Dtool_DowncastInterface_PNMImage_Row,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PNMImage_Row(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PNMImage_Row._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_PNMImage_Row._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMImage_Row) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMImage_Row)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMImage_Row);
  }
}

/**
 * Python method tables for PNMImage_CRow (CRow)
 */
static PyMethodDef Dtool_Methods_PNMImage_CRow[] = {
  {"get_xel_val", &Dtool_PNMImage_CRow_get_xel_val_337, METH_O, (const char *)Dtool_PNMImage_CRow_get_xel_val_337_comment},
  {"getXelVal", &Dtool_PNMImage_CRow_get_xel_val_337, METH_O, (const char *)Dtool_PNMImage_CRow_get_xel_val_337_comment},
  {"get_alpha_val", &Dtool_PNMImage_CRow_get_alpha_val_338, METH_O, (const char *)Dtool_PNMImage_CRow_get_alpha_val_338_comment},
  {"getAlphaVal", &Dtool_PNMImage_CRow_get_alpha_val_338, METH_O, (const char *)Dtool_PNMImage_CRow_get_alpha_val_338_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage_CRow slot sq_item -> operator []
//////////////////
static PyObject *Dtool_PNMImage_CRow_operator_336_sq_item(PyObject *self, Py_ssize_t index) {
  PNMImage::CRow *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage_CRow, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PNMImage_CRow index out of range");
    return NULL;
  }
  // 1-inline LColorf PNMImage::CRow::operator [](int x) const
  LColorf *return_value = new LColorf((*(const PNMImage::CRow*)local_this).operator [](index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(CRow self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage_CRow slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PNMImage_CRow_size_335_sq_length(PyObject *self) {
  PNMImage::CRow *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage_CRow, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PNMImage_CRow = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PNMImage_CRow = {
  &Dtool_PNMImage_CRow_size_335_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PNMImage_CRow_operator_336_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_PNMImage_CRow = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CRow",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMImage_CRow,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PNMImage_CRow,
    &Dtool_SequenceMethods_PNMImage_CRow,
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// Provides an accessor for reading the contents of one row of the image in-\n"
    "// place.",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PNMImage_CRow,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PNMImage_CRow,
    PyType_GenericAlloc,
    Dtool_new_PNMImage_CRow,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMImage_CRow,
  Dtool_UpcastInterface_PNMImage_CRow,
  Dtool_DowncastInterface_PNMImage_CRow,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PNMImage_CRow(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PNMImage_CRow._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_PNMImage_CRow._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMImage_CRow) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMImage_CRow)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMImage_CRow);
  }
}

/**
 * Python method tables for PNMImage (PNMImage)
 */
static PyMethodDef Dtool_Methods_PNMImage[] = {
  {"assign", &Dtool_PNMImage_operator_223, METH_O, (const char *)Dtool_PNMImage_operator_223_comment},
  {"clamp_val", &Dtool_PNMImage_clamp_val_225, METH_O, (const char *)Dtool_PNMImage_clamp_val_225_comment},
  {"clampVal", &Dtool_PNMImage_clamp_val_225, METH_O, (const char *)Dtool_PNMImage_clamp_val_225_comment},
  {"to_val", &Dtool_PNMImage_to_val_226, METH_O, (const char *)Dtool_PNMImage_to_val_226_comment},
  {"toVal", &Dtool_PNMImage_to_val_226, METH_O, (const char *)Dtool_PNMImage_to_val_226_comment},
  {"to_alpha_val", &Dtool_PNMImage_to_alpha_val_227, METH_O, (const char *)Dtool_PNMImage_to_alpha_val_227_comment},
  {"toAlphaVal", &Dtool_PNMImage_to_alpha_val_227, METH_O, (const char *)Dtool_PNMImage_to_alpha_val_227_comment},
  {"from_val", &Dtool_PNMImage_from_val_228, METH_O, (const char *)Dtool_PNMImage_from_val_228_comment},
  {"fromVal", &Dtool_PNMImage_from_val_228, METH_O, (const char *)Dtool_PNMImage_from_val_228_comment},
  {"from_alpha_val", &Dtool_PNMImage_from_alpha_val_229, METH_O, (const char *)Dtool_PNMImage_from_alpha_val_229_comment},
  {"fromAlphaVal", &Dtool_PNMImage_from_alpha_val_229, METH_O, (const char *)Dtool_PNMImage_from_alpha_val_229_comment},
  {"clear", (PyCFunction) &Dtool_PNMImage_clear_230, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_clear_230_comment},
  {"copy_from", &Dtool_PNMImage_copy_from_231, METH_O, (const char *)Dtool_PNMImage_copy_from_231_comment},
  {"copyFrom", &Dtool_PNMImage_copy_from_231, METH_O, (const char *)Dtool_PNMImage_copy_from_231_comment},
  {"copy_channel", (PyCFunction) &Dtool_PNMImage_copy_channel_232, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_copy_channel_232_comment},
  {"copyChannel", (PyCFunction) &Dtool_PNMImage_copy_channel_232, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_copy_channel_232_comment},
  {"copy_channel_bits", (PyCFunction) &Dtool_PNMImage_copy_channel_bits_233, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_copy_channel_bits_233_comment},
  {"copyChannelBits", (PyCFunction) &Dtool_PNMImage_copy_channel_bits_233, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_copy_channel_bits_233_comment},
  {"copy_header_from", &Dtool_PNMImage_copy_header_from_234, METH_O, (const char *)Dtool_PNMImage_copy_header_from_234_comment},
  {"copyHeaderFrom", &Dtool_PNMImage_copy_header_from_234, METH_O, (const char *)Dtool_PNMImage_copy_header_from_234_comment},
  {"take_from", &Dtool_PNMImage_take_from_235, METH_O, (const char *)Dtool_PNMImage_take_from_235_comment},
  {"takeFrom", &Dtool_PNMImage_take_from_235, METH_O, (const char *)Dtool_PNMImage_take_from_235_comment},
  {"fill", (PyCFunction) &Dtool_PNMImage_fill_236, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_fill_236_comment},
  {"fill_val", (PyCFunction) &Dtool_PNMImage_fill_val_237, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_fill_val_237_comment},
  {"fillVal", (PyCFunction) &Dtool_PNMImage_fill_val_237, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_fill_val_237_comment},
  {"alpha_fill", (PyCFunction) &Dtool_PNMImage_alpha_fill_238, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_alpha_fill_238_comment},
  {"alphaFill", (PyCFunction) &Dtool_PNMImage_alpha_fill_238, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_alpha_fill_238_comment},
  {"alpha_fill_val", (PyCFunction) &Dtool_PNMImage_alpha_fill_val_239, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_alpha_fill_val_239_comment},
  {"alphaFillVal", (PyCFunction) &Dtool_PNMImage_alpha_fill_val_239, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_alpha_fill_val_239_comment},
  {"set_read_size", (PyCFunction) &Dtool_PNMImage_set_read_size_240, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_read_size_240_comment},
  {"setReadSize", (PyCFunction) &Dtool_PNMImage_set_read_size_240, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_read_size_240_comment},
  {"clear_read_size", &Dtool_PNMImage_clear_read_size_241, METH_NOARGS, (const char *)Dtool_PNMImage_clear_read_size_241_comment},
  {"clearReadSize", &Dtool_PNMImage_clear_read_size_241, METH_NOARGS, (const char *)Dtool_PNMImage_clear_read_size_241_comment},
  {"has_read_size", &Dtool_PNMImage_has_read_size_242, METH_NOARGS, (const char *)Dtool_PNMImage_has_read_size_242_comment},
  {"hasReadSize", &Dtool_PNMImage_has_read_size_242, METH_NOARGS, (const char *)Dtool_PNMImage_has_read_size_242_comment},
  {"get_read_x_size", &Dtool_PNMImage_get_read_x_size_243, METH_NOARGS, (const char *)Dtool_PNMImage_get_read_x_size_243_comment},
  {"getReadXSize", &Dtool_PNMImage_get_read_x_size_243, METH_NOARGS, (const char *)Dtool_PNMImage_get_read_x_size_243_comment},
  {"get_read_y_size", &Dtool_PNMImage_get_read_y_size_244, METH_NOARGS, (const char *)Dtool_PNMImage_get_read_y_size_244_comment},
  {"getReadYSize", &Dtool_PNMImage_get_read_y_size_244, METH_NOARGS, (const char *)Dtool_PNMImage_get_read_y_size_244_comment},
  {"get_color_space", &Dtool_PNMImage_get_color_space_245, METH_NOARGS, (const char *)Dtool_PNMImage_get_color_space_245_comment},
  {"getColorSpace", &Dtool_PNMImage_get_color_space_245, METH_NOARGS, (const char *)Dtool_PNMImage_get_color_space_245_comment},
  {"read", (PyCFunction) &Dtool_PNMImage_read_246, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_read_246_comment},
  {"write", (PyCFunction) &Dtool_PNMImage_write_247, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_write_247_comment},
  {"is_valid", &Dtool_PNMImage_is_valid_248, METH_NOARGS, (const char *)Dtool_PNMImage_is_valid_248_comment},
  {"isValid", &Dtool_PNMImage_is_valid_248, METH_NOARGS, (const char *)Dtool_PNMImage_is_valid_248_comment},
  {"set_num_channels", &Dtool_PNMImage_set_num_channels_249, METH_O, (const char *)Dtool_PNMImage_set_num_channels_249_comment},
  {"setNumChannels", &Dtool_PNMImage_set_num_channels_249, METH_O, (const char *)Dtool_PNMImage_set_num_channels_249_comment},
  {"set_color_type", &Dtool_PNMImage_set_color_type_250, METH_O, (const char *)Dtool_PNMImage_set_color_type_250_comment},
  {"setColorType", &Dtool_PNMImage_set_color_type_250, METH_O, (const char *)Dtool_PNMImage_set_color_type_250_comment},
  {"set_color_space", &Dtool_PNMImage_set_color_space_251, METH_O, (const char *)Dtool_PNMImage_set_color_space_251_comment},
  {"setColorSpace", &Dtool_PNMImage_set_color_space_251, METH_O, (const char *)Dtool_PNMImage_set_color_space_251_comment},
  {"add_alpha", &Dtool_PNMImage_add_alpha_252, METH_NOARGS, (const char *)Dtool_PNMImage_add_alpha_252_comment},
  {"addAlpha", &Dtool_PNMImage_add_alpha_252, METH_NOARGS, (const char *)Dtool_PNMImage_add_alpha_252_comment},
  {"remove_alpha", &Dtool_PNMImage_remove_alpha_253, METH_NOARGS, (const char *)Dtool_PNMImage_remove_alpha_253_comment},
  {"removeAlpha", &Dtool_PNMImage_remove_alpha_253, METH_NOARGS, (const char *)Dtool_PNMImage_remove_alpha_253_comment},
  {"make_grayscale", (PyCFunction) &Dtool_PNMImage_make_grayscale_254, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_make_grayscale_254_comment},
  {"makeGrayscale", (PyCFunction) &Dtool_PNMImage_make_grayscale_254, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_make_grayscale_254_comment},
  {"make_rgb", &Dtool_PNMImage_make_rgb_255, METH_NOARGS, (const char *)Dtool_PNMImage_make_rgb_255_comment},
  {"makeRgb", &Dtool_PNMImage_make_rgb_255, METH_NOARGS, (const char *)Dtool_PNMImage_make_rgb_255_comment},
  {"premultiply_alpha", &Dtool_PNMImage_premultiply_alpha_256, METH_NOARGS, (const char *)Dtool_PNMImage_premultiply_alpha_256_comment},
  {"premultiplyAlpha", &Dtool_PNMImage_premultiply_alpha_256, METH_NOARGS, (const char *)Dtool_PNMImage_premultiply_alpha_256_comment},
  {"unpremultiply_alpha", &Dtool_PNMImage_unpremultiply_alpha_257, METH_NOARGS, (const char *)Dtool_PNMImage_unpremultiply_alpha_257_comment},
  {"unpremultiplyAlpha", &Dtool_PNMImage_unpremultiply_alpha_257, METH_NOARGS, (const char *)Dtool_PNMImage_unpremultiply_alpha_257_comment},
  {"reverse_rows", &Dtool_PNMImage_reverse_rows_258, METH_NOARGS, (const char *)Dtool_PNMImage_reverse_rows_258_comment},
  {"reverseRows", &Dtool_PNMImage_reverse_rows_258, METH_NOARGS, (const char *)Dtool_PNMImage_reverse_rows_258_comment},
  {"flip", (PyCFunction) &Dtool_PNMImage_flip_259, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_flip_259_comment},
  {"set_maxval", &Dtool_PNMImage_set_maxval_260, METH_O, (const char *)Dtool_PNMImage_set_maxval_260_comment},
  {"setMaxval", &Dtool_PNMImage_set_maxval_260, METH_O, (const char *)Dtool_PNMImage_set_maxval_260_comment},
  {"get_xel_val", (PyCFunction) &Dtool_PNMImage_get_xel_val_261, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_xel_val_261_comment},
  {"getXelVal", (PyCFunction) &Dtool_PNMImage_get_xel_val_261, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_xel_val_261_comment},
  {"set_xel_val", (PyCFunction) &Dtool_PNMImage_set_xel_val_262, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_xel_val_262_comment},
  {"setXelVal", (PyCFunction) &Dtool_PNMImage_set_xel_val_262, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_xel_val_262_comment},
  {"get_red_val", (PyCFunction) &Dtool_PNMImage_get_red_val_263, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_red_val_263_comment},
  {"getRedVal", (PyCFunction) &Dtool_PNMImage_get_red_val_263, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_red_val_263_comment},
  {"get_green_val", (PyCFunction) &Dtool_PNMImage_get_green_val_264, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_green_val_264_comment},
  {"getGreenVal", (PyCFunction) &Dtool_PNMImage_get_green_val_264, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_green_val_264_comment},
  {"get_blue_val", (PyCFunction) &Dtool_PNMImage_get_blue_val_265, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_blue_val_265_comment},
  {"getBlueVal", (PyCFunction) &Dtool_PNMImage_get_blue_val_265, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_blue_val_265_comment},
  {"get_gray_val", (PyCFunction) &Dtool_PNMImage_get_gray_val_266, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_gray_val_266_comment},
  {"getGrayVal", (PyCFunction) &Dtool_PNMImage_get_gray_val_266, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_gray_val_266_comment},
  {"get_alpha_val", (PyCFunction) &Dtool_PNMImage_get_alpha_val_267, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_alpha_val_267_comment},
  {"getAlphaVal", (PyCFunction) &Dtool_PNMImage_get_alpha_val_267, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_alpha_val_267_comment},
  {"set_red_val", (PyCFunction) &Dtool_PNMImage_set_red_val_268, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_red_val_268_comment},
  {"setRedVal", (PyCFunction) &Dtool_PNMImage_set_red_val_268, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_red_val_268_comment},
  {"set_green_val", (PyCFunction) &Dtool_PNMImage_set_green_val_269, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_green_val_269_comment},
  {"setGreenVal", (PyCFunction) &Dtool_PNMImage_set_green_val_269, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_green_val_269_comment},
  {"set_blue_val", (PyCFunction) &Dtool_PNMImage_set_blue_val_270, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_blue_val_270_comment},
  {"setBlueVal", (PyCFunction) &Dtool_PNMImage_set_blue_val_270, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_blue_val_270_comment},
  {"set_gray_val", (PyCFunction) &Dtool_PNMImage_set_gray_val_271, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_gray_val_271_comment},
  {"setGrayVal", (PyCFunction) &Dtool_PNMImage_set_gray_val_271, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_gray_val_271_comment},
  {"set_alpha_val", (PyCFunction) &Dtool_PNMImage_set_alpha_val_272, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_alpha_val_272_comment},
  {"setAlphaVal", (PyCFunction) &Dtool_PNMImage_set_alpha_val_272, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_alpha_val_272_comment},
  {"get_channel_val", (PyCFunction) &Dtool_PNMImage_get_channel_val_273, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_channel_val_273_comment},
  {"getChannelVal", (PyCFunction) &Dtool_PNMImage_get_channel_val_273, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_channel_val_273_comment},
  {"set_channel_val", (PyCFunction) &Dtool_PNMImage_set_channel_val_274, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_channel_val_274_comment},
  {"setChannelVal", (PyCFunction) &Dtool_PNMImage_set_channel_val_274, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_channel_val_274_comment},
  {"get_channel", (PyCFunction) &Dtool_PNMImage_get_channel_275, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_channel_275_comment},
  {"getChannel", (PyCFunction) &Dtool_PNMImage_get_channel_275, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_channel_275_comment},
  {"set_channel", (PyCFunction) &Dtool_PNMImage_set_channel_276, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_channel_276_comment},
  {"setChannel", (PyCFunction) &Dtool_PNMImage_set_channel_276, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_channel_276_comment},
  {"get_pixel", (PyCFunction) &Dtool_PNMImage_get_pixel_277, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_pixel_277_comment},
  {"getPixel", (PyCFunction) &Dtool_PNMImage_get_pixel_277, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_pixel_277_comment},
  {"set_pixel", (PyCFunction) &Dtool_PNMImage_set_pixel_278, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_pixel_278_comment},
  {"setPixel", (PyCFunction) &Dtool_PNMImage_set_pixel_278, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_pixel_278_comment},
  {"get_xel", (PyCFunction) &Dtool_PNMImage_get_xel_279, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_xel_279_comment},
  {"getXel", (PyCFunction) &Dtool_PNMImage_get_xel_279, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_xel_279_comment},
  {"set_xel", (PyCFunction) &Dtool_PNMImage_set_xel_280, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_xel_280_comment},
  {"setXel", (PyCFunction) &Dtool_PNMImage_set_xel_280, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_xel_280_comment},
  {"get_xel_a", (PyCFunction) &Dtool_PNMImage_get_xel_a_281, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_xel_a_281_comment},
  {"getXelA", (PyCFunction) &Dtool_PNMImage_get_xel_a_281, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_xel_a_281_comment},
  {"set_xel_a", (PyCFunction) &Dtool_PNMImage_set_xel_a_282, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_xel_a_282_comment},
  {"setXelA", (PyCFunction) &Dtool_PNMImage_set_xel_a_282, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_xel_a_282_comment},
  {"get_red", (PyCFunction) &Dtool_PNMImage_get_red_283, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_red_283_comment},
  {"getRed", (PyCFunction) &Dtool_PNMImage_get_red_283, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_red_283_comment},
  {"get_green", (PyCFunction) &Dtool_PNMImage_get_green_284, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_green_284_comment},
  {"getGreen", (PyCFunction) &Dtool_PNMImage_get_green_284, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_green_284_comment},
  {"get_blue", (PyCFunction) &Dtool_PNMImage_get_blue_285, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_blue_285_comment},
  {"getBlue", (PyCFunction) &Dtool_PNMImage_get_blue_285, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_blue_285_comment},
  {"get_gray", (PyCFunction) &Dtool_PNMImage_get_gray_286, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_gray_286_comment},
  {"getGray", (PyCFunction) &Dtool_PNMImage_get_gray_286, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_gray_286_comment},
  {"get_alpha", (PyCFunction) &Dtool_PNMImage_get_alpha_287, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_alpha_287_comment},
  {"getAlpha", (PyCFunction) &Dtool_PNMImage_get_alpha_287, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_alpha_287_comment},
  {"set_red", (PyCFunction) &Dtool_PNMImage_set_red_288, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_red_288_comment},
  {"setRed", (PyCFunction) &Dtool_PNMImage_set_red_288, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_red_288_comment},
  {"set_green", (PyCFunction) &Dtool_PNMImage_set_green_289, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_green_289_comment},
  {"setGreen", (PyCFunction) &Dtool_PNMImage_set_green_289, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_green_289_comment},
  {"set_blue", (PyCFunction) &Dtool_PNMImage_set_blue_290, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_blue_290_comment},
  {"setBlue", (PyCFunction) &Dtool_PNMImage_set_blue_290, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_blue_290_comment},
  {"set_gray", (PyCFunction) &Dtool_PNMImage_set_gray_291, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_gray_291_comment},
  {"setGray", (PyCFunction) &Dtool_PNMImage_set_gray_291, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_gray_291_comment},
  {"set_alpha", (PyCFunction) &Dtool_PNMImage_set_alpha_292, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_alpha_292_comment},
  {"setAlpha", (PyCFunction) &Dtool_PNMImage_set_alpha_292, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_alpha_292_comment},
  {"get_bright", (PyCFunction) &Dtool_PNMImage_get_bright_293, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_bright_293_comment},
  {"getBright", (PyCFunction) &Dtool_PNMImage_get_bright_293, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_bright_293_comment},
  {"blend", (PyCFunction) &Dtool_PNMImage_blend_294, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_blend_294_comment},
  {"copy_sub_image", (PyCFunction) &Dtool_PNMImage_copy_sub_image_295, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_copy_sub_image_295_comment},
  {"copySubImage", (PyCFunction) &Dtool_PNMImage_copy_sub_image_295, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_copy_sub_image_295_comment},
  {"blend_sub_image", (PyCFunction) &Dtool_PNMImage_blend_sub_image_296, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_blend_sub_image_296_comment},
  {"blendSubImage", (PyCFunction) &Dtool_PNMImage_blend_sub_image_296, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_blend_sub_image_296_comment},
  {"add_sub_image", (PyCFunction) &Dtool_PNMImage_add_sub_image_297, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_add_sub_image_297_comment},
  {"addSubImage", (PyCFunction) &Dtool_PNMImage_add_sub_image_297, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_add_sub_image_297_comment},
  {"mult_sub_image", (PyCFunction) &Dtool_PNMImage_mult_sub_image_298, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_mult_sub_image_298_comment},
  {"multSubImage", (PyCFunction) &Dtool_PNMImage_mult_sub_image_298, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_mult_sub_image_298_comment},
  {"darken_sub_image", (PyCFunction) &Dtool_PNMImage_darken_sub_image_299, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_darken_sub_image_299_comment},
  {"darkenSubImage", (PyCFunction) &Dtool_PNMImage_darken_sub_image_299, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_darken_sub_image_299_comment},
  {"lighten_sub_image", (PyCFunction) &Dtool_PNMImage_lighten_sub_image_300, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_lighten_sub_image_300_comment},
  {"lightenSubImage", (PyCFunction) &Dtool_PNMImage_lighten_sub_image_300, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_lighten_sub_image_300_comment},
  {"threshold", (PyCFunction) &Dtool_PNMImage_threshold_301, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_threshold_301_comment},
  {"fill_distance_inside", (PyCFunction) &Dtool_PNMImage_fill_distance_inside_302, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_fill_distance_inside_302_comment},
  {"fillDistanceInside", (PyCFunction) &Dtool_PNMImage_fill_distance_inside_302, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_fill_distance_inside_302_comment},
  {"fill_distance_outside", (PyCFunction) &Dtool_PNMImage_fill_distance_outside_303, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_fill_distance_outside_303_comment},
  {"fillDistanceOutside", (PyCFunction) &Dtool_PNMImage_fill_distance_outside_303, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_fill_distance_outside_303_comment},
  {"indirect_1d_lookup", (PyCFunction) &Dtool_PNMImage_indirect_1d_lookup_304, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_indirect_1d_lookup_304_comment},
  {"indirect1dLookup", (PyCFunction) &Dtool_PNMImage_indirect_1d_lookup_304, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_indirect_1d_lookup_304_comment},
  {"rescale", (PyCFunction) &Dtool_PNMImage_rescale_305, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_rescale_305_comment},
  {"render_spot", (PyCFunction) &Dtool_PNMImage_render_spot_306, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_render_spot_306_comment},
  {"renderSpot", (PyCFunction) &Dtool_PNMImage_render_spot_306, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_render_spot_306_comment},
  {"expand_border", (PyCFunction) &Dtool_PNMImage_expand_border_307, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_expand_border_307_comment},
  {"expandBorder", (PyCFunction) &Dtool_PNMImage_expand_border_307, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_expand_border_307_comment},
  {"box_filter", (PyCFunction) &Dtool_PNMImage_box_filter_308, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_box_filter_308_comment},
  {"boxFilter", (PyCFunction) &Dtool_PNMImage_box_filter_308, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_box_filter_308_comment},
  {"gaussian_filter", (PyCFunction) &Dtool_PNMImage_gaussian_filter_309, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_gaussian_filter_309_comment},
  {"gaussianFilter", (PyCFunction) &Dtool_PNMImage_gaussian_filter_309, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_gaussian_filter_309_comment},
  {"unfiltered_stretch_from", &Dtool_PNMImage_unfiltered_stretch_from_310, METH_O, (const char *)Dtool_PNMImage_unfiltered_stretch_from_310_comment},
  {"unfilteredStretchFrom", &Dtool_PNMImage_unfiltered_stretch_from_310, METH_O, (const char *)Dtool_PNMImage_unfiltered_stretch_from_310_comment},
  {"box_filter_from", (PyCFunction) &Dtool_PNMImage_box_filter_from_311, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_box_filter_from_311_comment},
  {"boxFilterFrom", (PyCFunction) &Dtool_PNMImage_box_filter_from_311, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_box_filter_from_311_comment},
  {"gaussian_filter_from", (PyCFunction) &Dtool_PNMImage_gaussian_filter_from_312, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_gaussian_filter_from_312_comment},
  {"gaussianFilterFrom", (PyCFunction) &Dtool_PNMImage_gaussian_filter_from_312, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_gaussian_filter_from_312_comment},
  {"quick_filter_from", (PyCFunction) &Dtool_PNMImage_quick_filter_from_313, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_quick_filter_from_313_comment},
  {"quickFilterFrom", (PyCFunction) &Dtool_PNMImage_quick_filter_from_313, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_quick_filter_from_313_comment},
  {"make_histogram", &Dtool_PNMImage_make_histogram_314, METH_O, (const char *)Dtool_PNMImage_make_histogram_314_comment},
  {"makeHistogram", &Dtool_PNMImage_make_histogram_314, METH_O, (const char *)Dtool_PNMImage_make_histogram_314_comment},
  {"perlin_noise_fill", (PyCFunction) &Dtool_PNMImage_perlin_noise_fill_315, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_perlin_noise_fill_315_comment},
  {"perlinNoiseFill", (PyCFunction) &Dtool_PNMImage_perlin_noise_fill_315, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_perlin_noise_fill_315_comment},
  {"remix_channels", &Dtool_PNMImage_remix_channels_316, METH_O, (const char *)Dtool_PNMImage_remix_channels_316_comment},
  {"remixChannels", &Dtool_PNMImage_remix_channels_316, METH_O, (const char *)Dtool_PNMImage_remix_channels_316_comment},
  {"gamma_correct", (PyCFunction) &Dtool_PNMImage_gamma_correct_317, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_gamma_correct_317_comment},
  {"gammaCorrect", (PyCFunction) &Dtool_PNMImage_gamma_correct_317, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_gamma_correct_317_comment},
  {"gamma_correct_alpha", (PyCFunction) &Dtool_PNMImage_gamma_correct_alpha_318, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_gamma_correct_alpha_318_comment},
  {"gammaCorrectAlpha", (PyCFunction) &Dtool_PNMImage_gamma_correct_alpha_318, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_gamma_correct_alpha_318_comment},
  {"apply_exponent", (PyCFunction) &Dtool_PNMImage_apply_exponent_319, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_apply_exponent_319_comment},
  {"applyExponent", (PyCFunction) &Dtool_PNMImage_apply_exponent_319, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_apply_exponent_319_comment},
  {"get_average_xel", &Dtool_PNMImage_get_average_xel_320, METH_NOARGS, (const char *)Dtool_PNMImage_get_average_xel_320_comment},
  {"getAverageXel", &Dtool_PNMImage_get_average_xel_320, METH_NOARGS, (const char *)Dtool_PNMImage_get_average_xel_320_comment},
  {"get_average_xel_a", &Dtool_PNMImage_get_average_xel_a_321, METH_NOARGS, (const char *)Dtool_PNMImage_get_average_xel_a_321_comment},
  {"getAverageXelA", &Dtool_PNMImage_get_average_xel_a_321, METH_NOARGS, (const char *)Dtool_PNMImage_get_average_xel_a_321_comment},
  {"get_average_gray", &Dtool_PNMImage_get_average_gray_322, METH_NOARGS, (const char *)Dtool_PNMImage_get_average_gray_322_comment},
  {"getAverageGray", &Dtool_PNMImage_get_average_gray_322, METH_NOARGS, (const char *)Dtool_PNMImage_get_average_gray_322_comment},
  {"do_fill_distance", (PyCFunction) &Dtool_PNMImage_do_fill_distance_323, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_do_fill_distance_323_comment},
  {"doFillDistance", (PyCFunction) &Dtool_PNMImage_do_fill_distance_323, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_do_fill_distance_323_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage slot mp_subscript -> operator []
//////////////////
static PyObject *Dtool_PNMImage_operator_341_mp_subscript(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 inline PNMImage::Row PNMImage::operator [](int y)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      PNMImage::Row *return_value = new PNMImage::Row((*local_this).operator []((int)arg_val));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage_Row, true, false);
    }
  }

  {
    // -2 inline PNMImage::CRow PNMImage::operator [](int y) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      PNMImage::CRow *return_value = new PNMImage::CRow((*(const PNMImage*)local_this).operator []((int)arg_val));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage_CRow, true, false);
    }
  }

  // No coercion possible: inline PNMImage::Row PNMImage::operator [](int y)
  // No coercion possible: inline PNMImage::CRow PNMImage::operator [](int y) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(const PNMImage self, int y)\n"
      "__getitem__(PNMImage self, int y)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage slot nb_add -> operator +
//////////////////
static PyObject *Dtool_PNMImage_operator_343_nb_add(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PNMImage, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline PNMImage PNMImage::operator +(PNMImage const &other) const
    PNMImage const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PNMImage, (void **)&arg_this);
    if (arg_this != NULL) {
      PNMImage *return_value = new PNMImage((*(const PNMImage*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, true, false);
    }
  }

  // No coercion possible: inline PNMImage PNMImage::operator +(PNMImage const &other) const
  {
    // -2 inline PNMImage PNMImage::operator +(LColorf const &other) const
    LVecBase4f arg_local;
    LColorf const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != NULL)) {
      PNMImage *return_value = new PNMImage((*(const PNMImage*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_PNMImage_operator_346_nb_inplace_add(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PNMImage, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    {
      // -2 void PNMImage::operator +=(PNMImage const &other)
      PNMImage const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PNMImage, (void **)&arg_this);
      if (arg_this != NULL) {
        (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

    // No coercion possible: void PNMImage::operator +=(PNMImage const &other)
    {
      // -2 void PNMImage::operator +=(LColorf const &other)
      LVecBase4f arg_local;
      LColorf const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if ((arg_this != NULL)) {
        (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call PNMImage.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_PNMImage_operator_348_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PNMImage, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    {
      // -2 void PNMImage::operator *=(PNMImage const &other)
      PNMImage const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PNMImage, (void **)&arg_this);
      if (arg_this != NULL) {
        (*local_this).operator *=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

    {
      // -2 void PNMImage::operator *=(LColorf const &other)
      LColorf const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
      if (arg_this != NULL) {
        (*local_this).operator *=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

    {
      // -2 void PNMImage::operator *=(float multiplier)
      if (PyNumber_Check(arg)) {
        (*local_this).operator *=((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

    // No coercion possible: void PNMImage::operator *=(PNMImage const &other)
    {
      // -2 void PNMImage::operator *=(LColorf const &other)
      LVecBase4f arg_local;
      LColorf const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if ((arg_this != NULL)) {
        (*local_this).operator *=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

    // No coercion possible: void PNMImage::operator *=(float multiplier)
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call PNMImage.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage slot nb_inplace_subtract -> operator -=
//////////////////
static PyObject *Dtool_PNMImage_operator_347_nb_inplace_subtract(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PNMImage, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    {
      // -2 void PNMImage::operator -=(PNMImage const &other)
      PNMImage const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PNMImage, (void **)&arg_this);
      if (arg_this != NULL) {
        (*local_this).operator -=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

    // No coercion possible: void PNMImage::operator -=(PNMImage const &other)
    {
      // -2 void PNMImage::operator -=(LColorf const &other)
      LVecBase4f arg_local;
      LColorf const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if ((arg_this != NULL)) {
        (*local_this).operator -=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call PNMImage.__isub__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage slot nb_invert -> operator ~
//////////////////
static PyObject *Dtool_PNMImage_operator_342_nb_invert(PyObject *self) {
  PNMImage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return NULL;
  }

  // 1-PNMImage PNMImage::operator ~(void) const
  PNMImage *return_value = new PNMImage((*(const PNMImage*)local_this).operator ~());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__invert__(PNMImage self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_PNMImage_operator_345_nb_multiply(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PNMImage, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline PNMImage PNMImage::operator *(PNMImage const &other) const
    PNMImage const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PNMImage, (void **)&arg_this);
    if (arg_this != NULL) {
      PNMImage *return_value = new PNMImage((*(const PNMImage*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, true, false);
    }
  }

  {
    // -2 inline PNMImage PNMImage::operator *(LColorf const &other) const
    LColorf const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
    if (arg_this != NULL) {
      PNMImage *return_value = new PNMImage((*(const PNMImage*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, true, false);
    }
  }

  {
    // -2 inline PNMImage PNMImage::operator *(float multiplier) const
    if (PyNumber_Check(arg)) {
      PNMImage *return_value = new PNMImage((*(const PNMImage*)local_this).operator *((float)PyFloat_AsDouble(arg)));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, true, false);
    }
  }

  // No coercion possible: inline PNMImage PNMImage::operator *(PNMImage const &other) const
  {
    // -2 inline PNMImage PNMImage::operator *(LColorf const &other) const
    LVecBase4f arg_local;
    LColorf const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != NULL)) {
      PNMImage *return_value = new PNMImage((*(const PNMImage*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, true, false);
    }
  }

  // No coercion possible: inline PNMImage PNMImage::operator *(float multiplier) const
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_PNMImage_operator_344_nb_subtract(PyObject *self, PyObject *arg) {
  PNMImage *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PNMImage, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline PNMImage PNMImage::operator -(PNMImage const &other) const
    PNMImage const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PNMImage, (void **)&arg_this);
    if (arg_this != NULL) {
      PNMImage *return_value = new PNMImage((*(const PNMImage*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, true, false);
    }
  }

  // No coercion possible: inline PNMImage PNMImage::operator -(PNMImage const &other) const
  {
    // -2 inline PNMImage PNMImage::operator -(LColorf const &other) const
    LVecBase4f arg_local;
    LColorf const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != NULL)) {
      PNMImage *return_value = new PNMImage((*(const PNMImage*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_PNMImage = {
  &Dtool_PNMImage_operator_343_nb_add,
  &Dtool_PNMImage_operator_344_nb_subtract,
  &Dtool_PNMImage_operator_345_nb_multiply,
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  &Dtool_PNMImage_operator_342_nb_invert,
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_PNMImage_operator_346_nb_inplace_add,
  &Dtool_PNMImage_operator_347_nb_inplace_subtract,
  &Dtool_PNMImage_operator_348_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PNMImage = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PNMImage = {
  0, // mp_length
  &Dtool_PNMImage_operator_341_mp_subscript,
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PNMImage = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PNMImage = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PNMImage",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMImage,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PNMImage,
    &Dtool_SequenceMethods_PNMImage,
    &Dtool_MappingMethods_PNMImage,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PNMImage,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The name of this class derives from the fact that we originally implemented\n"
    " * it as a layer on top of the \"pnm library\", based on netpbm, which was built\n"
    " * to implement pbm, pgm, and pbm files, and is the underlying support of a\n"
    " * number of public-domain image file converters.  Nowadays we are no longer\n"
    " * derived directly from the pnm library, mainly to allow support of C++\n"
    " * iostreams instead of the C stdio FILE interface.\n"
    " *\n"
    " * Conceptually, a PNMImage is a two-dimensional array of xels, which are the\n"
    " * PNM-defined generic pixel type.  Each xel may have a red, green, and blue\n"
    " * component, or (if the image is grayscale) a gray component.  The image may\n"
    " * be read in, the individual xels manipulated, and written out again, or a\n"
    " * black image may be constructed from scratch.\n"
    " *\n"
    " * A PNMImage has a color space and a maxval, the combination of which defines\n"
    " * how a floating-point linear color value is encoded as an integer value in\n"
    " * memory.  The functions ending in _val operate on encoded colors, whereas\n"
    " * the regular ones work with linear floating-point values.  All operations\n"
    " * are color space correct unless otherwise specified.\n"
    " *\n"
    " * The image is of size XSize() by YSize() xels, numbered from top to bottom,\n"
    " * left to right, beginning at zero.\n"
    " *\n"
    " * Files can be specified by filename, or by an iostream pointer.  The\n"
    " * filename \"-\" refers to stdin or stdout.\n"
    " *\n"
    " * This class is not inherently thread-safe; use it from a single thread or\n"
    " * protect access using a mutex.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PNMImage,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PNMImage,
    PyType_GenericAlloc,
    Dtool_new_PNMImage,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMImage,
  Dtool_UpcastInterface_PNMImage,
  Dtool_DowncastInterface_PNMImage,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PNMImage(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PNMImageHeader(NULL);
    Dtool_PNMImage._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PNMImageHeader);
    PyObject *dict = PyDict_New();
    Dtool_PNMImage._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // Nested Object   PNMImage_Row;
    Dtool_PyModuleClassInit_PNMImage_Row(NULL);
    PyDict_SetItemString(dict, "Row", (PyObject *)&Dtool_PNMImage_Row);
    // Nested Object   PNMImage_CRow;
    Dtool_PyModuleClassInit_PNMImage_CRow(NULL);
    PyDict_SetItemString(dict, "CRow", (PyObject *)&Dtool_PNMImage_CRow);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMImage) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMImage)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMImage);
  }
}

/**
 * Python method tables for PNMPainter (PNMPainter)
 */
static PyMethodDef Dtool_Methods_PNMPainter[] = {
  {"set_pen", &Dtool_PNMPainter_set_pen_352, METH_O, (const char *)Dtool_PNMPainter_set_pen_352_comment},
  {"setPen", &Dtool_PNMPainter_set_pen_352, METH_O, (const char *)Dtool_PNMPainter_set_pen_352_comment},
  {"get_pen", &Dtool_PNMPainter_get_pen_353, METH_NOARGS, (const char *)Dtool_PNMPainter_get_pen_353_comment},
  {"getPen", &Dtool_PNMPainter_get_pen_353, METH_NOARGS, (const char *)Dtool_PNMPainter_get_pen_353_comment},
  {"set_fill", &Dtool_PNMPainter_set_fill_354, METH_O, (const char *)Dtool_PNMPainter_set_fill_354_comment},
  {"setFill", &Dtool_PNMPainter_set_fill_354, METH_O, (const char *)Dtool_PNMPainter_set_fill_354_comment},
  {"get_fill", &Dtool_PNMPainter_get_fill_355, METH_NOARGS, (const char *)Dtool_PNMPainter_get_fill_355_comment},
  {"getFill", &Dtool_PNMPainter_get_fill_355, METH_NOARGS, (const char *)Dtool_PNMPainter_get_fill_355_comment},
  {"draw_point", (PyCFunction) &Dtool_PNMPainter_draw_point_359, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMPainter_draw_point_359_comment},
  {"drawPoint", (PyCFunction) &Dtool_PNMPainter_draw_point_359, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMPainter_draw_point_359_comment},
  {"draw_line", (PyCFunction) &Dtool_PNMPainter_draw_line_360, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMPainter_draw_line_360_comment},
  {"drawLine", (PyCFunction) &Dtool_PNMPainter_draw_line_360, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMPainter_draw_line_360_comment},
  {"draw_rectangle", (PyCFunction) &Dtool_PNMPainter_draw_rectangle_361, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMPainter_draw_rectangle_361_comment},
  {"drawRectangle", (PyCFunction) &Dtool_PNMPainter_draw_rectangle_361, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMPainter_draw_rectangle_361_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_PNMPainter[] = {
  {(char *)"pen", &Dtool_PNMPainter_pen_Getter, &Dtool_PNMPainter_pen_Setter, NULL, NULL},
  {(char *)"fill", &Dtool_PNMPainter_fill_Getter, &Dtool_PNMPainter_fill_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_PNMPainter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_PNMPainter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PNMPainter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMPainter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PNMPainter,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class provides a number of convenient methods for painting drawings\n"
    " * directly into a PNMImage.\n"
    " *\n"
    " * It stores a pointer to the PNMImage you pass it, but it does not take\n"
    " * ownership of the object; you are responsible for ensuring that the PNMImage\n"
    " * does not destruct during the lifetime of the PNMPainter object.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PNMPainter,
    0, // tp_members
    Dtool_Properties_PNMPainter,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PNMPainter,
    PyType_GenericAlloc,
    Dtool_new_PNMPainter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMPainter,
  Dtool_UpcastInterface_PNMPainter,
  Dtool_DowncastInterface_PNMPainter,
  (CoerceFunction)Dtool_ConstCoerce_PNMPainter,
  (CoerceFunction)Dtool_Coerce_PNMPainter,
};

static void Dtool_PyModuleClassInit_PNMPainter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PNMPainter._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_PNMPainter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMPainter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMPainter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMPainter);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3pnmimage_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("pixel", Dtool_pixel);
#endif
  Dtool_PNMFileType._type = PNMFileType::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PNMFileType);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PNMFileTypeRegistry", Dtool_PNMFileTypeRegistry);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PNMImageHeader", Dtool_PNMImageHeader);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PNMImageHeader::PixelSpec", Dtool_PNMImageHeader_PixelSpec);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PNMImageHeader::PixelSpecCount", Dtool_PNMImageHeader_PixelSpecCount);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PNMImageHeader::Histogram", Dtool_PNMImageHeader_Histogram);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PfmFile", Dtool_PfmFile);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PNMBrush", Dtool_PNMBrush);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PNMImage", Dtool_PNMImage);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PNMImage::Row", Dtool_PNMImage_Row);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PNMImage::CRow", Dtool_PNMImage_CRow);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PNMPainter", Dtool_PNMPainter);
#endif
}

void Dtool_libp3pnmimage_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_istream = LookupNamedClass("istream");
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_Filename = LookupRuntimeTypedClass(Filename::get_class_type());
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_LVecBase2f = LookupRuntimeTypedClass(LVecBase2f::get_class_type());
  Dtool_Ptr_LPoint4d = LookupRuntimeTypedClass(LPoint4d::get_class_type());
  Dtool_Ptr_LPoint4f = LookupRuntimeTypedClass(LPoint4f::get_class_type());
  Dtool_Ptr_LMatrix4f = LookupRuntimeTypedClass(LMatrix4f::get_class_type());
  Dtool_Ptr_LMatrix4d = LookupRuntimeTypedClass(LMatrix4d::get_class_type());
  Dtool_Ptr_TypedWritable = LookupRuntimeTypedClass(TypedWritable::get_class_type());
  Dtool_Ptr_LVecBase3d = LookupRuntimeTypedClass(LVecBase3d::get_class_type());
  Dtool_Ptr_LPoint2d = LookupRuntimeTypedClass(LPoint2d::get_class_type());
  Dtool_Ptr_LVecBase3f = LookupRuntimeTypedClass(LVecBase3f::get_class_type());
  Dtool_Ptr_LVecBase2i = LookupRuntimeTypedClass(LVecBase2i::get_class_type());
  Dtool_Ptr_LPoint3f = LookupRuntimeTypedClass(LPoint3f::get_class_type());
  Dtool_Ptr_LPoint2f = LookupRuntimeTypedClass(LPoint2f::get_class_type());
  Dtool_Ptr_LVecBase2d = LookupRuntimeTypedClass(LVecBase2d::get_class_type());
  Dtool_Ptr_LVecBase4f = LookupRuntimeTypedClass(LVecBase4f::get_class_type());
  Dtool_Ptr_LVecBase4d = LookupRuntimeTypedClass(LVecBase4d::get_class_type());
  Dtool_Ptr_BoundingHexahedron = LookupRuntimeTypedClass(BoundingHexahedron::get_class_type());
  Dtool_Ptr_StackedPerlinNoise2 = LookupNamedClass("StackedPerlinNoise2");
#endif
}

void Dtool_libp3pnmimage_BuildInstants(PyObject *module) {
  (void) module;
  // pixel
  Dtool_PyModuleClassInit_pixel(module);
  PyModule_AddObject(module, "pixel", (PyObject *)&Dtool_pixel);
  Py_INCREF(Dtool_Ptr_pixel);
  PyModule_AddObject(module, "Pixel", (PyObject *)&Dtool_pixel);
  // typedef pixel xel
  Dtool_PyModuleClassInit_pixel(module);
  Py_INCREF((PyObject *)&Dtool_pixel);
  PyModule_AddObject(module, "xel", (PyObject *)&Dtool_pixel);
  Py_INCREF(Dtool_Ptr_pixel);
  PyModule_AddObject(module, "Xel", (PyObject *)&Dtool_pixel);
  // PNMFileType
  Dtool_PyModuleClassInit_PNMFileType(module);
  PyModule_AddObject(module, "PNMFileType", (PyObject *)&Dtool_PNMFileType);
  // PNMFileTypeRegistry
  Dtool_PyModuleClassInit_PNMFileTypeRegistry(module);
  PyModule_AddObject(module, "PNMFileTypeRegistry", (PyObject *)&Dtool_PNMFileTypeRegistry);
  // PNMImageHeader
  Dtool_PyModuleClassInit_PNMImageHeader(module);
  PyModule_AddObject(module, "PNMImageHeader", (PyObject *)&Dtool_PNMImageHeader);
  // PfmFile
  Dtool_PyModuleClassInit_PfmFile(module);
  PyModule_AddObject(module, "PfmFile", (PyObject *)&Dtool_PfmFile);
  // PNMBrush
  Dtool_PyModuleClassInit_PNMBrush(module);
  PyModule_AddObject(module, "PNMBrush", (PyObject *)&Dtool_PNMBrush);
  // PNMImage
  Dtool_PyModuleClassInit_PNMImage(module);
  PyModule_AddObject(module, "PNMImage", (PyObject *)&Dtool_PNMImage);
  // PNMPainter
  Dtool_PyModuleClassInit_PNMPainter(module);
  PyModule_AddObject(module, "PNMPainter", (PyObject *)&Dtool_PNMPainter);
}

static PyMethodDef python_simple_funcs[] = {
  {"decode_sRGB_float", &Dtool_decode_sRGB_float_25, METH_O, (const char *)Dtool_decode_sRGB_float_25_comment},
  {"decodeSRGBFloat", &Dtool_decode_sRGB_float_25, METH_O, (const char *)Dtool_decode_sRGB_float_25_comment},
  {"decode_sRGB_uchar", &Dtool_decode_sRGB_uchar_26, METH_O, (const char *)Dtool_decode_sRGB_uchar_26_comment},
  {"decodeSRGBUchar", &Dtool_decode_sRGB_uchar_26, METH_O, (const char *)Dtool_decode_sRGB_uchar_26_comment},
  {"encode_sRGB_float", &Dtool_encode_sRGB_float_27, METH_O, (const char *)Dtool_encode_sRGB_float_27_comment},
  {"encodeSRGBFloat", &Dtool_encode_sRGB_float_27, METH_O, (const char *)Dtool_encode_sRGB_float_27_comment},
  {"encode_sRGB_uchar", &Dtool_encode_sRGB_uchar_28, METH_O, (const char *)Dtool_encode_sRGB_uchar_28_comment},
  {"encodeSRGBUchar", &Dtool_encode_sRGB_uchar_28, METH_O, (const char *)Dtool_encode_sRGB_uchar_28_comment},
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3pnmimage_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478210403,  /* file_identifier */
  "libp3pnmimage",  /* library_name */
  "BCNh",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3pnmimage.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  857  /* next_index */
};

Configure(_in_configure_libp3pnmimage);
ConfigureFn(_in_configure_libp3pnmimage) {
  interrogate_request_module(&_in_module_def);
}

