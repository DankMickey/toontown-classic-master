/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/grutil -Ipanda/src/grutil -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3grutil_igate.cxx -od built/pandac/input/libp3grutil.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/grutil -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3grutil cardMaker.h config_grutil.h fisheyeMaker.h frameRateMeter.h geoMipTerrain.h heightfieldTesselator.h lineSegs.h meshDrawer.h meshDrawer2D.h movieTexture.h multitexReducer.h nodeVertexTransform.h p3grutil_composite1.cxx p3grutil_composite2.cxx pfmVizzer.h pipeOcclusionCullTraverser.h rigidBodyCombiner.h sceneGraphAnalyzerMeter.h shaderTerrainMesh.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3grutil
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "audioSound.h"
#include "boundingVolume.h"
#include "cardMaker.h"
#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "configVariableInt.h"
#include "configVariableString.h"
#include "config_grutil.h"
#include "cycleData.h"
#include "cycleDataReader.h"
#include "cycleDataWriter.h"
#include "displayRegion.h"
#include "fisheyeMaker.h"
#include "frameRateMeter.h"
#include "geoMipTerrain.h"
#include "geom.h"
#include "geomNode.h"
#include "geomTriangles.h"
#include "geomTristrips.h"
#include "geomVertexArrayFormat.h"
#include "geomVertexData.h"
#include "geomVertexFormat.h"
#include "geomVertexRewriter.h"
#include "geomVertexWriter.h"
#include "graphicsOutput.h"
#include "heightfieldTesselator.h"
#include "lineSegs.h"
#include "lpoint2.h"
#include "luse.h"
#include "lvecBase2.h"
#include "meshDrawer.h"
#include "meshDrawer2D.h"
#include "movieTexture.h"
#include "movieVideo.h"
#include "movieVideoCursor.h"
#include "multitexReducer.h"
#include "namable.h"
#include "nodePath.h"
#include "nodePathCollection.h"
#include "nodeVertexTransform.h"
#include "notifyCategoryProxy.h"
#include "pStatCollector.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "pfmVizzer.h"
#include "pipeOcclusionCullTraverser.h"
#include "pipelineCycler.h"
#include "pmap.h"
#include "pnmImage.h"
#include "pointerTo.h"
#include "pvector.h"
#include "rigidBodyCombiner.h"
#include "sceneGraphAnalyzerMeter.h"
#include "shaderTerrainMesh.h"
#include "texMatrixAttrib.h"
#include "textNode.h"
#include "texture.h"
#include "textureAttrib.h"
#include "textureStage.h"
#include "transformState.h"
#include "vertexTransform.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class CardMaker
 */
typedef CardMaker CardMaker_localtype;
Define_Module_Class(panda3d.core, CardMaker, CardMaker_localtype, CardMaker);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CardMaker = &Dtool_CardMaker;
static void Dtool_PyModuleClassInit_CardMaker(PyObject *module);
bool Dtool_ConstCoerce_CardMaker(PyObject *args, CardMaker const *&coerced, bool &manage);
bool Dtool_Coerce_CardMaker(PyObject *args, CardMaker *&coerced, bool &manage);

/**
 * Forward declarations for top-level class FisheyeMaker
 */
typedef FisheyeMaker FisheyeMaker_localtype;
Define_Module_Class(panda3d.core, FisheyeMaker, FisheyeMaker_localtype, FisheyeMaker);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FisheyeMaker = &Dtool_FisheyeMaker;
static void Dtool_PyModuleClassInit_FisheyeMaker(PyObject *module);
bool Dtool_ConstCoerce_FisheyeMaker(PyObject *args, FisheyeMaker const *&coerced, bool &manage);
bool Dtool_Coerce_FisheyeMaker(PyObject *args, FisheyeMaker *&coerced, bool &manage);

/**
 * Forward declarations for top-level class FrameRateMeter
 */
typedef FrameRateMeter FrameRateMeter_localtype;
Define_Module_ClassRef(panda3d.core, FrameRateMeter, FrameRateMeter_localtype, FrameRateMeter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FrameRateMeter = &Dtool_FrameRateMeter;
static void Dtool_PyModuleClassInit_FrameRateMeter(PyObject *module);
bool Dtool_ConstCoerce_FrameRateMeter(PyObject *args, CPT(FrameRateMeter) &coerced);
bool Dtool_Coerce_FrameRateMeter(PyObject *args, PT(FrameRateMeter) &coerced);

/**
 * Forward declarations for top-level class GeoMipTerrain
 */
typedef GeoMipTerrain GeoMipTerrain_localtype;
Define_Module_Class(panda3d.core, GeoMipTerrain, GeoMipTerrain_localtype, GeoMipTerrain);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeoMipTerrain = &Dtool_GeoMipTerrain;
static void Dtool_PyModuleClassInit_GeoMipTerrain(PyObject *module);
bool Dtool_ConstCoerce_GeoMipTerrain(PyObject *args, GeoMipTerrain const *&coerced, bool &manage);
bool Dtool_Coerce_GeoMipTerrain(PyObject *args, GeoMipTerrain *&coerced, bool &manage);

/**
 * Forward declarations for top-level class HeightfieldTesselator
 */
typedef HeightfieldTesselator HeightfieldTesselator_localtype;
Define_Module_Class(panda3d.core, HeightfieldTesselator, HeightfieldTesselator_localtype, HeightfieldTesselator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_HeightfieldTesselator = &Dtool_HeightfieldTesselator;
static void Dtool_PyModuleClassInit_HeightfieldTesselator(PyObject *module);
bool Dtool_ConstCoerce_HeightfieldTesselator(PyObject *args, HeightfieldTesselator const *&coerced, bool &manage);
bool Dtool_Coerce_HeightfieldTesselator(PyObject *args, HeightfieldTesselator *&coerced, bool &manage);

/**
 * Forward declarations for top-level class LineSegs
 */
typedef LineSegs LineSegs_localtype;
Define_Module_Class(panda3d.core, LineSegs, LineSegs_localtype, LineSegs);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LineSegs = &Dtool_LineSegs;
static void Dtool_PyModuleClassInit_LineSegs(PyObject *module);
bool Dtool_ConstCoerce_LineSegs(PyObject *args, LineSegs const *&coerced, bool &manage);
bool Dtool_Coerce_LineSegs(PyObject *args, LineSegs *&coerced, bool &manage);

/**
 * Forward declarations for top-level class MeshDrawer
 */
typedef MeshDrawer MeshDrawer_localtype;
Define_Module_Class(panda3d.core, MeshDrawer, MeshDrawer_localtype, MeshDrawer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MeshDrawer = &Dtool_MeshDrawer;
static void Dtool_PyModuleClassInit_MeshDrawer(PyObject *module);

/**
 * Forward declarations for top-level class MeshDrawer2D
 */
typedef MeshDrawer2D MeshDrawer2D_localtype;
Define_Module_Class(panda3d.core, MeshDrawer2D, MeshDrawer2D_localtype, MeshDrawer2D);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MeshDrawer2D = &Dtool_MeshDrawer2D;
static void Dtool_PyModuleClassInit_MeshDrawer2D(PyObject *module);

/**
 * Forward declarations for top-level class MovieTexture
 */
typedef MovieTexture MovieTexture_localtype;
Define_Module_ClassRef(panda3d.core, MovieTexture, MovieTexture_localtype, MovieTexture);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovieTexture = &Dtool_MovieTexture;
static void Dtool_PyModuleClassInit_MovieTexture(PyObject *module);
bool Dtool_ConstCoerce_MovieTexture(PyObject *args, CPT(MovieTexture) &coerced);
bool Dtool_Coerce_MovieTexture(PyObject *args, PT(MovieTexture) &coerced);

/**
 * Forward declarations for top-level class MultitexReducer
 */
typedef MultitexReducer MultitexReducer_localtype;
Define_Module_Class(panda3d.core, MultitexReducer, MultitexReducer_localtype, MultitexReducer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MultitexReducer = &Dtool_MultitexReducer;
static void Dtool_PyModuleClassInit_MultitexReducer(PyObject *module);

/**
 * Forward declarations for top-level class NodeVertexTransform
 */
typedef NodeVertexTransform NodeVertexTransform_localtype;
Define_Module_ClassRef(panda3d.core, NodeVertexTransform, NodeVertexTransform_localtype, NodeVertexTransform);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodeVertexTransform = &Dtool_NodeVertexTransform;
static void Dtool_PyModuleClassInit_NodeVertexTransform(PyObject *module);
bool Dtool_ConstCoerce_NodeVertexTransform(PyObject *args, CPT(NodeVertexTransform) &coerced);
bool Dtool_Coerce_NodeVertexTransform(PyObject *args, PT(NodeVertexTransform) &coerced);

/**
 * Forward declarations for top-level class ShaderTerrainMesh
 */
typedef ShaderTerrainMesh ShaderTerrainMesh_localtype;
Define_Module_ClassRef(panda3d.core, ShaderTerrainMesh, ShaderTerrainMesh_localtype, ShaderTerrainMesh);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderTerrainMesh = &Dtool_ShaderTerrainMesh;
static void Dtool_PyModuleClassInit_ShaderTerrainMesh(PyObject *module);

/**
 * Forward declarations for top-level class SceneGraphAnalyzerMeter
 */
typedef SceneGraphAnalyzerMeter SceneGraphAnalyzerMeter_localtype;
Define_Module_ClassRef(panda3d.core, SceneGraphAnalyzerMeter, SceneGraphAnalyzerMeter_localtype, SceneGraphAnalyzerMeter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SceneGraphAnalyzerMeter = &Dtool_SceneGraphAnalyzerMeter;
static void Dtool_PyModuleClassInit_SceneGraphAnalyzerMeter(PyObject *module);
bool Dtool_ConstCoerce_SceneGraphAnalyzerMeter(PyObject *args, CPT(SceneGraphAnalyzerMeter) &coerced);
bool Dtool_Coerce_SceneGraphAnalyzerMeter(PyObject *args, PT(SceneGraphAnalyzerMeter) &coerced);

/**
 * Forward declarations for top-level class RigidBodyCombiner
 */
typedef RigidBodyCombiner RigidBodyCombiner_localtype;
Define_Module_ClassRef(panda3d.core, RigidBodyCombiner, RigidBodyCombiner_localtype, RigidBodyCombiner);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RigidBodyCombiner = &Dtool_RigidBodyCombiner;
static void Dtool_PyModuleClassInit_RigidBodyCombiner(PyObject *module);
bool Dtool_ConstCoerce_RigidBodyCombiner(PyObject *args, CPT(RigidBodyCombiner) &coerced);
bool Dtool_Coerce_RigidBodyCombiner(PyObject *args, PT(RigidBodyCombiner) &coerced);

/**
 * Forward declarations for top-level class PipeOcclusionCullTraverser
 */
typedef PipeOcclusionCullTraverser PipeOcclusionCullTraverser_localtype;
Define_Module_ClassRef(panda3d.core, PipeOcclusionCullTraverser, PipeOcclusionCullTraverser_localtype, PipeOcclusionCullTraverser);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PipeOcclusionCullTraverser = &Dtool_PipeOcclusionCullTraverser;
static void Dtool_PyModuleClassInit_PipeOcclusionCullTraverser(PyObject *module);
bool Dtool_ConstCoerce_PipeOcclusionCullTraverser(PyObject *args, CPT(PipeOcclusionCullTraverser) &coerced);
bool Dtool_Coerce_PipeOcclusionCullTraverser(PyObject *args, PT(PipeOcclusionCullTraverser) &coerced);

/**
 * Forward declarations for top-level class PfmVizzer
 */
typedef PfmVizzer PfmVizzer_localtype;
Define_Module_Class(panda3d.core, PfmVizzer, PfmVizzer_localtype, PfmVizzer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PfmVizzer = &Dtool_PfmVizzer;
static void Dtool_PyModuleClassInit_PfmVizzer(PyObject *module);
bool Dtool_ConstCoerce_PfmVizzer(PyObject *args, PfmVizzer const *&coerced, bool &manage);
bool Dtool_Coerce_PfmVizzer(PyObject *args, PfmVizzer *&coerced, bool &manage);

/**
 * Extern declarations for imported classes
 */
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Filename
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Filename;
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != NULL, NULL);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != NULL, NULL);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// TextEncoder
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TextEncoder;
#else
extern struct Dtool_PyTypedObject Dtool_TextEncoder;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextEncoder = &Dtool_TextEncoder;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// LVecBase2f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase2f;
inline static LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced) {
  nassertr(Dtool_Ptr_LVecBase2f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase2f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase2f *(*)(PyObject *, LVecBase2f &))Dtool_Ptr_LVecBase2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2f = &Dtool_LVecBase2f;
extern LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced);
#endif
// LVector2f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVector2f;
inline static LVector2f *Dtool_Coerce_LVector2f(PyObject *args, LVector2f &coerced) {
  nassertr(Dtool_Ptr_LVector2f != NULL, NULL);
  nassertr(Dtool_Ptr_LVector2f->_Dtool_Coerce != NULL, NULL);
  return ((LVector2f *(*)(PyObject *, LVector2f &))Dtool_Ptr_LVector2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector2f = &Dtool_LVector2f;
extern LVector2f *Dtool_Coerce_LVector2f(PyObject *args, LVector2f &coerced);
#endif
// LPoint2f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint2f;
inline static LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced) {
  nassertr(Dtool_Ptr_LPoint2f != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint2f->_Dtool_Coerce != NULL, NULL);
  return ((LPoint2f *(*)(PyObject *, LPoint2f &))Dtool_Ptr_LPoint2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2f = &Dtool_LPoint2f;
extern LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced);
#endif
// LPoint2d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint2d;
inline static LPoint2d *Dtool_Coerce_LPoint2d(PyObject *args, LPoint2d &coerced) {
  nassertr(Dtool_Ptr_LPoint2d != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint2d->_Dtool_Coerce != NULL, NULL);
  return ((LPoint2d *(*)(PyObject *, LPoint2d &))Dtool_Ptr_LPoint2d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint2d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2d = &Dtool_LPoint2d;
extern LPoint2d *Dtool_Coerce_LPoint2d(PyObject *args, LPoint2d &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3f;
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVector3f;
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != NULL, NULL);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LPoint3d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint3d;
inline static LPoint3d *Dtool_Coerce_LPoint3d(PyObject *args, LPoint3d &coerced) {
  nassertr(Dtool_Ptr_LPoint3d != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint3d->_Dtool_Coerce != NULL, NULL);
  return ((LPoint3d *(*)(PyObject *, LPoint3d &))Dtool_Ptr_LPoint3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3d = &Dtool_LPoint3d;
extern LPoint3d *Dtool_Coerce_LPoint3d(PyObject *args, LPoint3d &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint3f;
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != NULL, NULL);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LVector4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVector4f;
inline static LVector4f *Dtool_Coerce_LVector4f(PyObject *args, LVector4f &coerced) {
  nassertr(Dtool_Ptr_LVector4f != NULL, NULL);
  nassertr(Dtool_Ptr_LVector4f->_Dtool_Coerce != NULL, NULL);
  return ((LVector4f *(*)(PyObject *, LVector4f &))Dtool_Ptr_LVector4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector4f = &Dtool_LVector4f;
extern LVector4f *Dtool_Coerce_LVector4f(PyObject *args, LVector4f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4f;
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritable;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// InternalName
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_InternalName;
inline static bool Dtool_ConstCoerce_InternalName(PyObject *args, CPT(InternalName) &coerced) {
  nassertr(Dtool_Ptr_InternalName != NULL, false);
  nassertr(Dtool_Ptr_InternalName->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(InternalName) &))Dtool_Ptr_InternalName->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_InternalName(PyObject *args, PT(InternalName) &coerced) {
  nassertr(Dtool_Ptr_InternalName != NULL, false);
  nassertr(Dtool_Ptr_InternalName->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(InternalName) &))Dtool_Ptr_InternalName->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_InternalName;
static struct Dtool_PyTypedObject *const Dtool_Ptr_InternalName = &Dtool_InternalName;
extern bool Dtool_ConstCoerce_InternalName(PyObject *args, CPT(InternalName) &coerced);
extern bool Dtool_Coerce_InternalName(PyObject *args, PT(InternalName) &coerced);
#endif
// BitMask< uint32_t, 32 >
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_BitMask_uint32_t_32;
inline static BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced) {
  nassertr(Dtool_Ptr_BitMask_uint32_t_32 != NULL, NULL);
  nassertr(Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce != NULL, NULL);
  return ((BitMask< uint32_t, 32 > *(*)(PyObject *, BitMask< uint32_t, 32 > &))Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_BitMask_uint32_t_32;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitMask_uint32_t_32 = &Dtool_BitMask_uint32_t_32;
extern BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced);
#endif
// VertexTransform
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_VertexTransform;
#else
extern struct Dtool_PyTypedObject Dtool_VertexTransform;
static struct Dtool_PyTypedObject *const Dtool_Ptr_VertexTransform = &Dtool_VertexTransform;
#endif
// TextureStage
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TextureStage;
#else
extern struct Dtool_PyTypedObject Dtool_TextureStage;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureStage = &Dtool_TextureStage;
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PandaNode;
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// ClockObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ClockObject;
#else
extern struct Dtool_PyTypedObject Dtool_ClockObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ClockObject = &Dtool_ClockObject;
#endif
// TransformState
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TransformState;
#else
extern struct Dtool_PyTypedObject Dtool_TransformState;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TransformState = &Dtool_TransformState;
#endif
// GraphicsStateGuardianBase
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GraphicsStateGuardianBase;
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsStateGuardianBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsStateGuardianBase = &Dtool_GraphicsStateGuardianBase;
#endif
// RenderState
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_RenderState;
inline static bool Dtool_ConstCoerce_RenderState(PyObject *args, CPT(RenderState) &coerced) {
  nassertr(Dtool_Ptr_RenderState != NULL, false);
  nassertr(Dtool_Ptr_RenderState->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(RenderState) &))Dtool_Ptr_RenderState->_Dtool_ConstCoerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_RenderState;
static struct Dtool_PyTypedObject *const Dtool_Ptr_RenderState = &Dtool_RenderState;
extern bool Dtool_ConstCoerce_RenderState(PyObject *args, CPT(RenderState) &coerced);
#endif
// Texture
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Texture;
#else
extern struct Dtool_PyTypedObject Dtool_Texture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Texture = &Dtool_Texture;
#endif
// TextProperties
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TextProperties;
#else
extern struct Dtool_PyTypedObject Dtool_TextProperties;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextProperties = &Dtool_TextProperties;
#endif
// GeomNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GeomNode;
#else
extern struct Dtool_PyTypedObject Dtool_GeomNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomNode = &Dtool_GeomNode;
#endif
// TextNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TextNode;
inline static bool Dtool_ConstCoerce_TextNode(PyObject *args, CPT(TextNode) &coerced) {
  nassertr(Dtool_Ptr_TextNode != NULL, false);
  nassertr(Dtool_Ptr_TextNode->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(TextNode) &))Dtool_Ptr_TextNode->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_TextNode(PyObject *args, PT(TextNode) &coerced) {
  nassertr(Dtool_Ptr_TextNode != NULL, false);
  nassertr(Dtool_Ptr_TextNode->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(TextNode) &))Dtool_Ptr_TextNode->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TextNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextNode = &Dtool_TextNode;
extern bool Dtool_ConstCoerce_TextNode(PyObject *args, CPT(TextNode) &coerced);
extern bool Dtool_Coerce_TextNode(PyObject *args, PT(TextNode) &coerced);
#endif
// NodePath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePath;
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// SceneSetup
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_SceneSetup;
#else
extern struct Dtool_PyTypedObject Dtool_SceneSetup;
static struct Dtool_PyTypedObject *const Dtool_Ptr_SceneSetup = &Dtool_SceneSetup;
#endif
// CullTraverser
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_CullTraverser;
#else
extern struct Dtool_PyTypedObject Dtool_CullTraverser;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CullTraverser = &Dtool_CullTraverser;
#endif
// DisplayRegion
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_DisplayRegion;
#else
extern struct Dtool_PyTypedObject Dtool_DisplayRegion;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DisplayRegion = &Dtool_DisplayRegion;
#endif
// Lens
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Lens;
#else
extern struct Dtool_PyTypedObject Dtool_Lens;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Lens = &Dtool_Lens;
#endif
// GraphicsOutput
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GraphicsOutput;
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsOutput;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsOutput = &Dtool_GraphicsOutput;
#endif
// PNMImage
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PNMImage;
#else
extern struct Dtool_PyTypedObject Dtool_PNMImage;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMImage = &Dtool_PNMImage;
#endif
// MovieVideo
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_MovieVideo;
inline static bool Dtool_ConstCoerce_MovieVideo(PyObject *args, CPT(MovieVideo) &coerced) {
  nassertr(Dtool_Ptr_MovieVideo != NULL, false);
  nassertr(Dtool_Ptr_MovieVideo->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(MovieVideo) &))Dtool_Ptr_MovieVideo->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_MovieVideo(PyObject *args, PT(MovieVideo) &coerced) {
  nassertr(Dtool_Ptr_MovieVideo != NULL, false);
  nassertr(Dtool_Ptr_MovieVideo->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(MovieVideo) &))Dtool_Ptr_MovieVideo->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_MovieVideo;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovieVideo = &Dtool_MovieVideo;
extern bool Dtool_ConstCoerce_MovieVideo(PyObject *args, CPT(MovieVideo) &coerced);
extern bool Dtool_Coerce_MovieVideo(PyObject *args, PT(MovieVideo) &coerced);
#endif
// MovieVideoCursor
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_MovieVideoCursor;
#else
extern struct Dtool_PyTypedObject Dtool_MovieVideoCursor;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovieVideoCursor = &Dtool_MovieVideoCursor;
#endif
// AudioSound
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_AudioSound;
#else
extern struct Dtool_PyTypedObject Dtool_AudioSound;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AudioSound = &Dtool_AudioSound;
#endif
// PfmFile
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PfmFile;
#else
extern struct Dtool_PyTypedObject Dtool_PfmFile;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PfmFile = &Dtool_PfmFile;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class CardMaker
 */
/**
 * Python function wrapper for:
 * void CardMaker::reset(void)
 */
static PyObject *Dtool_CardMaker_reset_5(PyObject *self, PyObject *) {
  CardMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CardMaker, (void **)&local_this, "CardMaker.reset")) {
    return NULL;
  }
  // 1-void CardMaker::reset(void)
  (*local_this).reset();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CardMaker_reset_5_comment =
  "C++ Interface:\n"
  "reset(const CardMaker self)\n"
  "\n"
  "/**\n"
  " * Resets all the parameters to their initial defaults.\n"
  " */";
#else
static const char *Dtool_CardMaker_reset_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CardMaker::set_uv_range(LTexCoord const &ll, LTexCoord const &ur)
 * void CardMaker::set_uv_range(LTexCoord const &ll, LTexCoord const &lr, LTexCoord const &ur, LTexCoord const &ul)
 * void CardMaker::set_uv_range(LTexCoord3 const &ll, LTexCoord3 const &lr, LTexCoord3 const &ur, LTexCoord3 const &ul)
 * void CardMaker::set_uv_range(LVector4 const &x, LVector4 const &y, LVector4 const &z)
 * void CardMaker::set_uv_range(Texture const *tex)
 */
static PyObject *Dtool_CardMaker_set_uv_range_6(PyObject *self, PyObject *args, PyObject *kwds) {
  CardMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CardMaker, (void **)&local_this, "CardMaker.set_uv_range")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "tex");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'tex' (pos 1) not found");
      }
      // 1-void CardMaker::set_uv_range(Texture const *tex)
      Texture const *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "CardMaker.set_uv_range", true, true);
      if (arg_this != NULL) {
        (*local_this).set_uv_range(arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void CardMaker::set_uv_range(LTexCoord const &ll, LTexCoord const &ur)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"ll", "ur", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_uv_range", (char **)keyword_list, &param1, &param2)) {
        LPoint2f param1_local;
        LTexCoord const *param1_this = Dtool_Coerce_LPoint2f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "CardMaker.set_uv_range", "LPoint2f");
        }
        LPoint2f param2_local;
        LTexCoord const *param2_this = Dtool_Coerce_LPoint2f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "CardMaker.set_uv_range", "LPoint2f");
        }
        (*local_this).set_uv_range(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-void CardMaker::set_uv_range(LVector4 const &x, LVector4 const &y, LVector4 const &z)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_uv_range", (char **)keyword_list, &param1, &param2, &param3)) {
        LVector4f param1_local;
        LVector4 const *param1_this = Dtool_Coerce_LVector4f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "CardMaker.set_uv_range", "LVector4f");
        }
        LVector4f param2_local;
        LVector4 const *param2_this = Dtool_Coerce_LVector4f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "CardMaker.set_uv_range", "LVector4f");
        }
        LVector4f param3_local;
        LVector4 const *param3_this = Dtool_Coerce_LVector4f(param3, param3_local);
        if (!(param3_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "CardMaker.set_uv_range", "LVector4f");
        }
        (*local_this).set_uv_range(*param1_this, *param2_this, *param3_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      {
        // -2 void CardMaker::set_uv_range(LTexCoord const &ll, LTexCoord const &lr, LTexCoord const &ur, LTexCoord const &ul)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        static const char *keyword_list[] = {"ll", "lr", "ur", "ul", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:set_uv_range", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          LTexCoord const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint2f, (void **)&param1_this);
          LTexCoord const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LPoint2f, (void **)&param2_this);
          LTexCoord const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LPoint2f, (void **)&param3_this);
          LTexCoord const *param4_this;
          DTOOL_Call_ExtractThisPointerForType(param4, Dtool_Ptr_LPoint2f, (void **)&param4_this);
          if (param1_this != NULL && param2_this != NULL && param3_this != NULL && param4_this != NULL) {
            (*local_this).set_uv_range(*param1_this, *param2_this, *param3_this, *param4_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void CardMaker::set_uv_range(LTexCoord3 const &ll, LTexCoord3 const &lr, LTexCoord3 const &ur, LTexCoord3 const &ul)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        static const char *keyword_list[] = {"ll", "lr", "ur", "ul", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:set_uv_range", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          LTexCoord3 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
          LTexCoord3 const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LPoint3f, (void **)&param2_this);
          LTexCoord3 const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LPoint3f, (void **)&param3_this);
          LTexCoord3 const *param4_this;
          DTOOL_Call_ExtractThisPointerForType(param4, Dtool_Ptr_LPoint3f, (void **)&param4_this);
          if (param1_this != NULL && param2_this != NULL && param3_this != NULL && param4_this != NULL) {
            (*local_this).set_uv_range(*param1_this, *param2_this, *param3_this, *param4_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void CardMaker::set_uv_range(LTexCoord const &ll, LTexCoord const &lr, LTexCoord const &ur, LTexCoord const &ul)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        static const char *keyword_list[] = {"ll", "lr", "ur", "ul", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:set_uv_range", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          LPoint2f param1_local;
          LTexCoord const *param1_this = Dtool_Coerce_LPoint2f(param1, param1_local);
          LPoint2f param2_local;
          LTexCoord const *param2_this = Dtool_Coerce_LPoint2f(param2, param2_local);
          LPoint2f param3_local;
          LTexCoord const *param3_this = Dtool_Coerce_LPoint2f(param3, param3_local);
          LPoint2f param4_local;
          LTexCoord const *param4_this = Dtool_Coerce_LPoint2f(param4, param4_local);
          if ((param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL) && (param4_this != NULL)) {
            (*local_this).set_uv_range(*param1_this, *param2_this, *param3_this, *param4_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void CardMaker::set_uv_range(LTexCoord3 const &ll, LTexCoord3 const &lr, LTexCoord3 const &ur, LTexCoord3 const &ul)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        static const char *keyword_list[] = {"ll", "lr", "ur", "ul", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:set_uv_range", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          LPoint3f param1_local;
          LTexCoord3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
          LPoint3f param2_local;
          LTexCoord3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
          LPoint3f param3_local;
          LTexCoord3 const *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
          LPoint3f param4_local;
          LTexCoord3 const *param4_this = Dtool_Coerce_LPoint3f(param4, param4_local);
          if ((param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL) && (param4_this != NULL)) {
            (*local_this).set_uv_range(*param1_this, *param2_this, *param3_this, *param4_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_uv_range() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uv_range(const CardMaker self, const Texture tex)\n"
      "set_uv_range(const CardMaker self, const LPoint2f ll, const LPoint2f ur)\n"
      "set_uv_range(const CardMaker self, const LVector4f x, const LVector4f y, const LVector4f z)\n"
      "set_uv_range(const CardMaker self, const LPoint2f ll, const LPoint2f lr, const LPoint2f ur, const LPoint2f ul)\n"
      "set_uv_range(const CardMaker self, const LPoint3f ll, const LPoint3f lr, const LPoint3f ur, const LPoint3f ul)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CardMaker_set_uv_range_6_comment =
  "C++ Interface:\n"
  "set_uv_range(const CardMaker self, const Texture tex)\n"
  "set_uv_range(const CardMaker self, const LPoint2f ll, const LPoint2f ur)\n"
  "set_uv_range(const CardMaker self, const LVector4f x, const LVector4f y, const LVector4f z)\n"
  "set_uv_range(const CardMaker self, const LPoint2f ll, const LPoint2f lr, const LPoint2f ur, const LPoint2f ul)\n"
  "set_uv_range(const CardMaker self, const LPoint3f ll, const LPoint3f lr, const LPoint3f ur, const LPoint3f ul)\n"
  "\n"
  "/**\n"
  " * Sets the range of UV's that will be applied to the vertices.  If\n"
  " * set_has_uvs() is true (as it is by default), the vertices will be generated\n"
  " * with the indicated range of UV's, which will be useful if a texture is\n"
  " * applied.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the range of UV's that will be applied to the vertices.  If\n"
  " * set_has_uvs() is true (as it is by default), the vertices will be generated\n"
  " * with the indicated range of UV's, which will be useful if a texture is\n"
  " * applied.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the range of UV's that will be applied to the vertices.  If\n"
  " * set_has_uvs() is true (as it is by default), the vertices will be generated\n"
  " * with the indicated range of UV's, which will be useful if a texture is\n"
  " * applied.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the range of UV's that will be applied to the vertices.  If\n"
  " * set_has_uvs() is true (as it is by default), the vertices will be generated\n"
  " * with the indicated range of UV's, which will be useful if a texture is\n"
  " * applied.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the range of UV's that will be applied to the vertices appropriately\n"
  " * to show the non-pad region of the texture.\n"
  " */";
#else
static const char *Dtool_CardMaker_set_uv_range_6_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CardMaker::set_uv_range_cube(int face)
 */
static PyObject *Dtool_CardMaker_set_uv_range_cube_7(PyObject *self, PyObject *arg) {
  CardMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CardMaker, (void **)&local_this, "CardMaker.set_uv_range_cube")) {
    return NULL;
  }
  // 1-void CardMaker::set_uv_range_cube(int face)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_uv_range_cube((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uv_range_cube(const CardMaker self, int face)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CardMaker_set_uv_range_cube_7_comment =
  "C++ Interface:\n"
  "set_uv_range_cube(const CardMaker self, int face)\n"
  "\n"
  "/**\n"
  " * Sets the range of UV's that will be applied to the vertices appropriately\n"
  " * for a cube-map face.\n"
  " */";
#else
static const char *Dtool_CardMaker_set_uv_range_cube_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CardMaker::set_has_uvs(bool flag)
 */
static PyObject *Dtool_CardMaker_set_has_uvs_8(PyObject *self, PyObject *arg) {
  CardMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CardMaker, (void **)&local_this, "CardMaker.set_has_uvs")) {
    return NULL;
  }
  // 1-inline void CardMaker::set_has_uvs(bool flag)
  (*local_this).set_has_uvs((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_has_uvs(const CardMaker self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CardMaker_set_has_uvs_8_comment =
  "C++ Interface:\n"
  "set_has_uvs(const CardMaker self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the flag indicating whether vertices will be generated with UV's or\n"
  " * not.\n"
  " */";
#else
static const char *Dtool_CardMaker_set_has_uvs_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CardMaker::set_has_3d_uvs(bool flag)
 */
static PyObject *Dtool_CardMaker_set_has_3d_uvs_9(PyObject *self, PyObject *arg) {
  CardMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CardMaker, (void **)&local_this, "CardMaker.set_has_3d_uvs")) {
    return NULL;
  }
  // 1-inline void CardMaker::set_has_3d_uvs(bool flag)
  (*local_this).set_has_3d_uvs((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_has_3d_uvs(const CardMaker self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CardMaker_set_has_3d_uvs_9_comment =
  "C++ Interface:\n"
  "set_has_3d_uvs(const CardMaker self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the flag indicating whether vertices will be generated with\n"
  " * 3-component UVW's (true) or 2-component UV's (the default, false).\n"
  " * Normally, this will be implicitly set by setting the uv_range.\n"
  " */";
#else
static const char *Dtool_CardMaker_set_has_3d_uvs_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CardMaker::set_frame(LVecBase4 const &frame)
 * inline void CardMaker::set_frame(LVertex const &ll, LVertex const &lr, LVertex const &ur, LVertex const &ul)
 * inline void CardMaker::set_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 */
static PyObject *Dtool_CardMaker_set_frame_10(PyObject *self, PyObject *args, PyObject *kwds) {
  CardMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CardMaker, (void **)&local_this, "CardMaker.set_frame")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "frame");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'frame' (pos 1) not found");
      }
      // 1-inline void CardMaker::set_frame(LVecBase4 const &frame)
      LVecBase4f arg_local;
      LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "CardMaker.set_frame", "LVecBase4f");
      }
      (*local_this).set_frame(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      {
        // -2 inline void CardMaker::set_frame(LVertex const &ll, LVertex const &lr, LVertex const &ur, LVertex const &ul)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        static const char *keyword_list[] = {"ll", "lr", "ur", "ul", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:set_frame", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          LVertex const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
          LVertex const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LPoint3f, (void **)&param2_this);
          LVertex const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LPoint3f, (void **)&param3_this);
          LVertex const *param4_this;
          DTOOL_Call_ExtractThisPointerForType(param4, Dtool_Ptr_LPoint3f, (void **)&param4_this);
          if (param1_this != NULL && param2_this != NULL && param3_this != NULL && param4_this != NULL) {
            (*local_this).set_frame(*param1_this, *param2_this, *param3_this, *param4_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void CardMaker::set_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
        float param1;
        float param2;
        float param3;
        float param4;
        static const char *keyword_list[] = {"left", "right", "bottom", "top", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_frame", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          (*local_this).set_frame((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      {
        // -2 inline void CardMaker::set_frame(LVertex const &ll, LVertex const &lr, LVertex const &ur, LVertex const &ul)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        static const char *keyword_list[] = {"ll", "lr", "ur", "ul", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:set_frame", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          LPoint3f param1_local;
          LVertex const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
          LPoint3f param2_local;
          LVertex const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
          LPoint3f param3_local;
          LVertex const *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
          LPoint3f param4_local;
          LVertex const *param4_this = Dtool_Coerce_LPoint3f(param4, param4_local);
          if ((param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL) && (param4_this != NULL)) {
            (*local_this).set_frame(*param1_this, *param2_this, *param3_this, *param4_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void CardMaker::set_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_frame() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame(const CardMaker self, const LVecBase4f frame)\n"
      "set_frame(const CardMaker self, const LPoint3f ll, const LPoint3f lr, const LPoint3f ur, const LPoint3f ul)\n"
      "set_frame(const CardMaker self, float left, float right, float bottom, float top)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CardMaker_set_frame_10_comment =
  "C++ Interface:\n"
  "set_frame(const CardMaker self, const LVecBase4f frame)\n"
  "set_frame(const CardMaker self, const LPoint3f ll, const LPoint3f lr, const LPoint3f ur, const LPoint3f ul)\n"
  "set_frame(const CardMaker self, float left, float right, float bottom, float top)\n"
  "\n"
  "/**\n"
  " * Sets the size of the card.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the size of the card.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the size of the card.\n"
  " */";
#else
static const char *Dtool_CardMaker_set_frame_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CardMaker::set_frame_fullscreen_quad(void)
 */
static PyObject *Dtool_CardMaker_set_frame_fullscreen_quad_11(PyObject *self, PyObject *) {
  CardMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CardMaker, (void **)&local_this, "CardMaker.set_frame_fullscreen_quad")) {
    return NULL;
  }
  // 1-inline void CardMaker::set_frame_fullscreen_quad(void)
  (*local_this).set_frame_fullscreen_quad();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CardMaker_set_frame_fullscreen_quad_11_comment =
  "C++ Interface:\n"
  "set_frame_fullscreen_quad(const CardMaker self)\n"
  "\n"
  "/**\n"
  " * Sets the card to (-1,1,-1,1), which is appropriate if you plan to parent it\n"
  " * to render2d and use it as a fullscreen quad.\n"
  " */";
#else
static const char *Dtool_CardMaker_set_frame_fullscreen_quad_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CardMaker::set_color(LColor const &color)
 * inline void CardMaker::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
 */
static PyObject *Dtool_CardMaker_set_color_12(PyObject *self, PyObject *args, PyObject *kwds) {
  CardMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CardMaker, (void **)&local_this, "CardMaker.set_color")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "color");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'color' (pos 1) not found");
      }
      // 1-inline void CardMaker::set_color(LColor const &color)
      LVecBase4f arg_local;
      LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "CardMaker.set_color", "LVecBase4f");
      }
      (*local_this).set_color(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void CardMaker::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"r", "g", "b", "a", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_color", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_color((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_color() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color(const CardMaker self, const LVecBase4f color)\n"
      "set_color(const CardMaker self, float r, float g, float b, float a)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CardMaker_set_color_12_comment =
  "C++ Interface:\n"
  "set_color(const CardMaker self, const LVecBase4f color)\n"
  "set_color(const CardMaker self, float r, float g, float b, float a)\n"
  "\n"
  "/**\n"
  " * Sets the color of the card.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the color of the card.\n"
  " */";
#else
static const char *Dtool_CardMaker_set_color_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CardMaker::set_has_normals(bool flag)
 */
static PyObject *Dtool_CardMaker_set_has_normals_13(PyObject *self, PyObject *arg) {
  CardMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CardMaker, (void **)&local_this, "CardMaker.set_has_normals")) {
    return NULL;
  }
  // 1-inline void CardMaker::set_has_normals(bool flag)
  (*local_this).set_has_normals((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_has_normals(const CardMaker self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CardMaker_set_has_normals_13_comment =
  "C++ Interface:\n"
  "set_has_normals(const CardMaker self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the flag indicating whether vertices will be generated with normals or\n"
  " * not.  Normals are required if you intend to enable lighting on the card,\n"
  " * but are just wasted space and bandwidth otherwise, so there is a (slight)\n"
  " * optimization for disabling them.  If enabled, the normals will be generated\n"
  " * perpendicular to the card's face.\n"
  " */";
#else
static const char *Dtool_CardMaker_set_has_normals_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CardMaker::set_source_geometry(PandaNode *node, LVecBase4 const &frame)
 */
static PyObject *Dtool_CardMaker_set_source_geometry_14(PyObject *self, PyObject *args, PyObject *kwds) {
  CardMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CardMaker, (void **)&local_this, "CardMaker.set_source_geometry")) {
    return NULL;
  }
  // 1-inline void CardMaker::set_source_geometry(PandaNode *node, LVecBase4 const &frame)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"node", "frame", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_source_geometry", (char **)keyword_list, &param1, &param2)) {
    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "CardMaker.set_source_geometry", false, true);
    LVecBase4f param2_local;
    LVecBase4 const *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CardMaker.set_source_geometry", "LVecBase4f");
    }
    if (param1_this != NULL) {
      (*local_this).set_source_geometry(param1_this, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_source_geometry(const CardMaker self, PandaNode node, const LVecBase4f frame)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CardMaker_set_source_geometry_14_comment =
  "C++ Interface:\n"
  "set_source_geometry(const CardMaker self, PandaNode node, const LVecBase4f frame)\n"
  "\n"
  "/**\n"
  " * Sets a node that will be copied (and scaled and translated) to generate the\n"
  " * frame, instead of generating a new polygon.  The node may contain arbitrary\n"
  " * geometry that describes a flat polygon contained within the indicated left,\n"
  " * right, bottom, top frame.\n"
  " *\n"
  " * When generate() is called, the geometry in this node will be scaled and\n"
  " * translated appropriately to give it the size and aspect ratio specified by\n"
  " * set_frame().\n"
  " */";
#else
static const char *Dtool_CardMaker_set_source_geometry_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CardMaker::clear_source_geometry(void)
 */
static PyObject *Dtool_CardMaker_clear_source_geometry_15(PyObject *self, PyObject *) {
  CardMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CardMaker, (void **)&local_this, "CardMaker.clear_source_geometry")) {
    return NULL;
  }
  // 1-inline void CardMaker::clear_source_geometry(void)
  (*local_this).clear_source_geometry();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CardMaker_clear_source_geometry_15_comment =
  "C++ Interface:\n"
  "clear_source_geometry(const CardMaker self)\n"
  "\n"
  "/**\n"
  " * Removes the node specified by an earlier call to set_source_geometry().\n"
  " */";
#else
static const char *Dtool_CardMaker_clear_source_geometry_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< PandaNode > CardMaker::generate(void)
 */
static PyObject *Dtool_CardMaker_generate_16(PyObject *self, PyObject *) {
  CardMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CardMaker, (void **)&local_this, "CardMaker.generate")) {
    return NULL;
  }
  // 1-PointerTo< PandaNode > CardMaker::generate(void)
  PointerTo< PandaNode > return_value = (*local_this).generate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  PandaNode *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PandaNode, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CardMaker_generate_16_comment =
  "C++ Interface:\n"
  "generate(const CardMaker self)\n"
  "\n"
  "/**\n"
  " * Generates a GeomNode that renders the specified geometry.\n"
  " */";
#else
static const char *Dtool_CardMaker_generate_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CardMaker::CardMaker(CardMaker const &) = default
 * inline CardMaker::CardMaker(std::string const &name)
 */
static int Dtool_Init_CardMaker(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CardMaker() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline CardMaker::CardMaker(CardMaker const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:CardMaker", (char **)keyword_list, &param0)) {
      CardMaker const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_CardMaker, (void **)&param0_this);
      if (param0_this != NULL) {
        CardMaker *return_value = new CardMaker(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CardMaker, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline CardMaker::CardMaker(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:CardMaker", (char **)keyword_list, &param0_str, &param0_len)) {
      CardMaker *return_value = new CardMaker(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CardMaker, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline CardMaker::CardMaker(CardMaker const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:CardMaker", (char **)keyword_list, &param0)) {
      CardMaker const *param0_this;
      bool param0_manage = false;
      if (Dtool_ConstCoerce_CardMaker(param0, param0_this, param0_manage)) {
        CardMaker *return_value = new CardMaker(*param0_this);
        if (param0_manage) {
          delete param0_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CardMaker, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: inline CardMaker::CardMaker(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CardMaker(const CardMaker param0)\n"
      "CardMaker(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CardMaker(PyObject *args, CardMaker const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CardMaker, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline CardMaker::CardMaker(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      CardMaker *return_value = new CardMaker(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_CardMaker(PyObject *args, CardMaker *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CardMaker, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline CardMaker::CardMaker(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      CardMaker *return_value = new CardMaker(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_CardMaker(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CardMaker) {
    printf("CardMaker ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CardMaker *local_this = (CardMaker *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CardMaker) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CardMaker(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CardMaker) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (CardMaker*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class FisheyeMaker
 */
/**
 * Python function wrapper for:
 * void FisheyeMaker::reset(void)
 */
static PyObject *Dtool_FisheyeMaker_reset_20(PyObject *self, PyObject *) {
  FisheyeMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FisheyeMaker, (void **)&local_this, "FisheyeMaker.reset")) {
    return NULL;
  }
  // 1-void FisheyeMaker::reset(void)
  (*local_this).reset();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_FisheyeMaker_reset_20_comment =
  "C++ Interface:\n"
  "reset(const FisheyeMaker self)\n"
  "\n"
  "/**\n"
  " * Resets all the parameters to their initial defaults.\n"
  " */";
#else
static const char *Dtool_FisheyeMaker_reset_20_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void FisheyeMaker::set_fov(PN_stdfloat fov)
 */
static PyObject *Dtool_FisheyeMaker_set_fov_21(PyObject *self, PyObject *arg) {
  FisheyeMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FisheyeMaker, (void **)&local_this, "FisheyeMaker.set_fov")) {
    return NULL;
  }
  // 1-void FisheyeMaker::set_fov(PN_stdfloat fov)
  if (PyNumber_Check(arg)) {
    (*local_this).set_fov((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fov(const FisheyeMaker self, float fov)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FisheyeMaker_set_fov_21_comment =
  "C++ Interface:\n"
  "set_fov(const FisheyeMaker self, float fov)\n"
  "\n"
  "/**\n"
  " * Specifies the field of view of the fisheye projection.  A sphere map will\n"
  " * have a 360-degree field of view (and this is the default).\n"
  " */";
#else
static const char *Dtool_FisheyeMaker_set_fov_21_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void FisheyeMaker::set_num_vertices(int num_vertices)
 */
static PyObject *Dtool_FisheyeMaker_set_num_vertices_22(PyObject *self, PyObject *arg) {
  FisheyeMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FisheyeMaker, (void **)&local_this, "FisheyeMaker.set_num_vertices")) {
    return NULL;
  }
  // 1-inline void FisheyeMaker::set_num_vertices(int num_vertices)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_num_vertices((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_vertices(const FisheyeMaker self, int num_vertices)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FisheyeMaker_set_num_vertices_22_comment =
  "C++ Interface:\n"
  "set_num_vertices(const FisheyeMaker self, int num_vertices)\n"
  "\n"
  "/**\n"
  " * Specifies the approximate number of vertices to be used to generate the\n"
  " * rose.  This is the approximate number of vertices that will be located\n"
  " * within the rose's unit circle, not counting the inscribing square (if any).\n"
  " * The actual number of vertices used may be +/- 25% of this value.\n"
  " */";
#else
static const char *Dtool_FisheyeMaker_set_num_vertices_22_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void FisheyeMaker::set_square_inscribed(bool square_inscribed, PN_stdfloat square_radius)
 */
static PyObject *Dtool_FisheyeMaker_set_square_inscribed_23(PyObject *self, PyObject *args, PyObject *kwds) {
  FisheyeMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FisheyeMaker, (void **)&local_this, "FisheyeMaker.set_square_inscribed")) {
    return NULL;
  }
  // 1-inline void FisheyeMaker::set_square_inscribed(bool square_inscribed, PN_stdfloat square_radius)
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"square_inscribed", "square_radius", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_square_inscribed", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_square_inscribed((PyObject_IsTrue(param1) != 0), (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_square_inscribed(const FisheyeMaker self, bool square_inscribed, float square_radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FisheyeMaker_set_square_inscribed_23_comment =
  "C++ Interface:\n"
  "set_square_inscribed(const FisheyeMaker self, bool square_inscribed, float square_radius)\n"
  "\n"
  "/**\n"
  " * Sets the flag that indicates whether the rose should be inscribed within a\n"
  " * square.  When this is true, an additional square is generated to inscribed\n"
  " * the circular rose, with the indicated \"radius\" (the sides of the square\n"
  " * will be 2 * square_radius).  The texture coordinates of the square will\n"
  " * uniformly map to the back pole of the cube map.\n"
  " *\n"
  " * This is mainly useful to provide a good uniform background color for a\n"
  " * sphere map so that it does not have a sharp circular edge that might\n"
  " * produce artifacts due to numerical imprecision when mapping.\n"
  " */";
#else
static const char *Dtool_FisheyeMaker_set_square_inscribed_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void FisheyeMaker::set_reflection(bool reflection)
 */
static PyObject *Dtool_FisheyeMaker_set_reflection_24(PyObject *self, PyObject *arg) {
  FisheyeMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FisheyeMaker, (void **)&local_this, "FisheyeMaker.set_reflection")) {
    return NULL;
  }
  // 1-inline void FisheyeMaker::set_reflection(bool reflection)
  (*local_this).set_reflection((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_reflection(const FisheyeMaker self, bool reflection)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FisheyeMaker_set_reflection_24_comment =
  "C++ Interface:\n"
  "set_reflection(const FisheyeMaker self, bool reflection)\n"
  "\n"
  "/**\n"
  " * Sets the flag indicating whether the texture image should be mirrored\n"
  " * (true) or normal (false).  When this is true, the 3-D texture coordinates\n"
  " * will be reversed so that the image is appropriate for a reflection.  This\n"
  " * is the best choice for generating a sphere map from a cube map.  The\n"
  " * default is false.\n"
  " */";
#else
static const char *Dtool_FisheyeMaker_set_reflection_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< PandaNode > FisheyeMaker::generate(void)
 */
static PyObject *Dtool_FisheyeMaker_generate_25(PyObject *self, PyObject *) {
  FisheyeMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FisheyeMaker, (void **)&local_this, "FisheyeMaker.generate")) {
    return NULL;
  }
  // 1-PointerTo< PandaNode > FisheyeMaker::generate(void)
  PointerTo< PandaNode > return_value = (*local_this).generate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  PandaNode *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PandaNode, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_FisheyeMaker_generate_25_comment =
  "C++ Interface:\n"
  "generate(const FisheyeMaker self)\n"
  "\n"
  "/**\n"
  " * Generates a GeomNode that renders the specified geometry.\n"
  " */";
#else
static const char *Dtool_FisheyeMaker_generate_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline FisheyeMaker::FisheyeMaker(FisheyeMaker const &) = default
 * inline FisheyeMaker::FisheyeMaker(std::string const &name)
 */
static int Dtool_Init_FisheyeMaker(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "FisheyeMaker() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline FisheyeMaker::FisheyeMaker(FisheyeMaker const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:FisheyeMaker", (char **)keyword_list, &param0)) {
      FisheyeMaker const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_FisheyeMaker, (void **)&param0_this);
      if (param0_this != NULL) {
        FisheyeMaker *return_value = new FisheyeMaker(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FisheyeMaker, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline FisheyeMaker::FisheyeMaker(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:FisheyeMaker", (char **)keyword_list, &param0_str, &param0_len)) {
      FisheyeMaker *return_value = new FisheyeMaker(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FisheyeMaker, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline FisheyeMaker::FisheyeMaker(FisheyeMaker const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:FisheyeMaker", (char **)keyword_list, &param0)) {
      FisheyeMaker const *param0_this;
      bool param0_manage = false;
      if (Dtool_ConstCoerce_FisheyeMaker(param0, param0_this, param0_manage)) {
        FisheyeMaker *return_value = new FisheyeMaker(*param0_this);
        if (param0_manage) {
          delete param0_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FisheyeMaker, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: inline FisheyeMaker::FisheyeMaker(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "FisheyeMaker(const FisheyeMaker param0)\n"
      "FisheyeMaker(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_FisheyeMaker(PyObject *args, FisheyeMaker const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_FisheyeMaker, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline FisheyeMaker::FisheyeMaker(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      FisheyeMaker *return_value = new FisheyeMaker(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_FisheyeMaker(PyObject *args, FisheyeMaker *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_FisheyeMaker, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline FisheyeMaker::FisheyeMaker(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      FisheyeMaker *return_value = new FisheyeMaker(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_FisheyeMaker(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_FisheyeMaker) {
    printf("FisheyeMaker ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  FisheyeMaker *local_this = (FisheyeMaker *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_FisheyeMaker) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_FisheyeMaker(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_FisheyeMaker) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (FisheyeMaker*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class FrameRateMeter
 */
/**
 * Python function wrapper for:
 * void FrameRateMeter::setup_window(GraphicsOutput *window)
 */
static PyObject *Dtool_FrameRateMeter_setup_window_29(PyObject *self, PyObject *arg) {
  FrameRateMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameRateMeter, (void **)&local_this, "FrameRateMeter.setup_window")) {
    return NULL;
  }
  // 1-void FrameRateMeter::setup_window(GraphicsOutput *window)
  GraphicsOutput *arg_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsOutput, 1, "FrameRateMeter.setup_window", false, true);
  if (arg_this != NULL) {
    (*local_this).setup_window(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_window(const FrameRateMeter self, GraphicsOutput window)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FrameRateMeter_setup_window_29_comment =
  "C++ Interface:\n"
  "setup_window(const FrameRateMeter self, GraphicsOutput window)\n"
  "\n"
  "/**\n"
  " * Sets up the frame rate meter to create a DisplayRegion to render itself\n"
  " * into the indicated window.\n"
  " */";
#else
static const char *Dtool_FrameRateMeter_setup_window_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void FrameRateMeter::clear_window(void)
 */
static PyObject *Dtool_FrameRateMeter_clear_window_30(PyObject *self, PyObject *) {
  FrameRateMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameRateMeter, (void **)&local_this, "FrameRateMeter.clear_window")) {
    return NULL;
  }
  // 1-void FrameRateMeter::clear_window(void)
  (*local_this).clear_window();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_FrameRateMeter_clear_window_30_comment =
  "C++ Interface:\n"
  "clear_window(const FrameRateMeter self)\n"
  "\n"
  "/**\n"
  " * Undoes the effect of a previous call to setup_window().\n"
  " */";
#else
static const char *Dtool_FrameRateMeter_clear_window_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsOutput *FrameRateMeter::get_window(void) const
 */
static PyObject *Dtool_FrameRateMeter_get_window_31(PyObject *self, PyObject *) {
  FrameRateMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameRateMeter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline GraphicsOutput *FrameRateMeter::get_window(void) const
  GraphicsOutput *return_value = (*(const FrameRateMeter*)local_this).get_window();
  if (return_value != (GraphicsOutput *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (GraphicsOutput *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutput, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_FrameRateMeter_get_window_31_comment =
  "C++ Interface:\n"
  "get_window(FrameRateMeter self)\n"
  "\n"
  "/**\n"
  " * Returns the GraphicsOutput that was passed to setup_window(), or NULL if\n"
  " * setup_window() has not been called.\n"
  " */";
#else
static const char *Dtool_FrameRateMeter_get_window_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DisplayRegion *FrameRateMeter::get_display_region(void) const
 */
static PyObject *Dtool_FrameRateMeter_get_display_region_32(PyObject *self, PyObject *) {
  FrameRateMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameRateMeter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline DisplayRegion *FrameRateMeter::get_display_region(void) const
  DisplayRegion *return_value = (*(const FrameRateMeter*)local_this).get_display_region();
  if (return_value != (DisplayRegion *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (DisplayRegion *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DisplayRegion, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_FrameRateMeter_get_display_region_32_comment =
  "C++ Interface:\n"
  "get_display_region(FrameRateMeter self)\n"
  "\n"
  "/**\n"
  " * Returns the DisplayRegion that the meter has created to render itself into\n"
  " * the window to setup_window(), or NULL if setup_window() has not been\n"
  " * called.\n"
  " */";
#else
static const char *Dtool_FrameRateMeter_get_display_region_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void FrameRateMeter::set_update_interval(double update_interval)
 */
static PyObject *Dtool_FrameRateMeter_set_update_interval_33(PyObject *self, PyObject *arg) {
  FrameRateMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameRateMeter, (void **)&local_this, "FrameRateMeter.set_update_interval")) {
    return NULL;
  }
  // 1-inline void FrameRateMeter::set_update_interval(double update_interval)
  if (PyNumber_Check(arg)) {
    (*local_this).set_update_interval(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_update_interval(const FrameRateMeter self, double update_interval)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FrameRateMeter_set_update_interval_33_comment =
  "C++ Interface:\n"
  "set_update_interval(const FrameRateMeter self, double update_interval)\n"
  "\n"
  "/**\n"
  " * Specifies the number of seconds that should elapse between updates to the\n"
  " * frame rate indication.  This should be reasonably slow (e.g.  0.2 to 1.0)\n"
  " * so that the calculation of the frame rate text does not itself dominate the\n"
  " * frame rate.\n"
  " */";
#else
static const char *Dtool_FrameRateMeter_set_update_interval_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double FrameRateMeter::get_update_interval(void) const
 */
static PyObject *Dtool_FrameRateMeter_get_update_interval_34(PyObject *self, PyObject *) {
  FrameRateMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameRateMeter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double FrameRateMeter::get_update_interval(void) const
  double return_value = (*(const FrameRateMeter*)local_this).get_update_interval();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameRateMeter_get_update_interval_34_comment =
  "C++ Interface:\n"
  "get_update_interval(FrameRateMeter self)\n"
  "\n"
  "/**\n"
  " * Returns the number of seconds that will elapse between updates to the frame\n"
  " * rate indication.\n"
  " */";
#else
static const char *Dtool_FrameRateMeter_get_update_interval_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void FrameRateMeter::set_text_pattern(std::string const &text_pattern)
 */
static PyObject *Dtool_FrameRateMeter_set_text_pattern_35(PyObject *self, PyObject *arg) {
  FrameRateMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameRateMeter, (void **)&local_this, "FrameRateMeter.set_text_pattern")) {
    return NULL;
  }
  // 1-inline void FrameRateMeter::set_text_pattern(std::string const &text_pattern)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_text_pattern(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_text_pattern(const FrameRateMeter self, str text_pattern)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FrameRateMeter_set_text_pattern_35_comment =
  "C++ Interface:\n"
  "set_text_pattern(const FrameRateMeter self, str text_pattern)\n"
  "\n"
  "/**\n"
  " * Sets the sprintf() pattern that is used to format the text.  The string\n"
  " * \"%f\" or some variant will be replaced with the current frame rate in frames\n"
  " * per second.\n"
  " */";
#else
static const char *Dtool_FrameRateMeter_set_text_pattern_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &FrameRateMeter::get_text_pattern(void) const
 */
static PyObject *Dtool_FrameRateMeter_get_text_pattern_36(PyObject *self, PyObject *) {
  FrameRateMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameRateMeter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &FrameRateMeter::get_text_pattern(void) const
  std::string const &return_value = (*(const FrameRateMeter*)local_this).get_text_pattern();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameRateMeter_get_text_pattern_36_comment =
  "C++ Interface:\n"
  "get_text_pattern(FrameRateMeter self)\n"
  "\n"
  "/**\n"
  " * Returns the sprintf() pattern that is used to format the text.\n"
  " */";
#else
static const char *Dtool_FrameRateMeter_get_text_pattern_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void FrameRateMeter::set_clock_object(ClockObject *clock_object)
 */
static PyObject *Dtool_FrameRateMeter_set_clock_object_37(PyObject *self, PyObject *arg) {
  FrameRateMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameRateMeter, (void **)&local_this, "FrameRateMeter.set_clock_object")) {
    return NULL;
  }
  // 1-inline void FrameRateMeter::set_clock_object(ClockObject *clock_object)
  ClockObject *arg_this = (ClockObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ClockObject, 1, "FrameRateMeter.set_clock_object", false, true);
  if (arg_this != NULL) {
    (*local_this).set_clock_object(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clock_object(const FrameRateMeter self, ClockObject clock_object)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FrameRateMeter_set_clock_object_37_comment =
  "C++ Interface:\n"
  "set_clock_object(const FrameRateMeter self, ClockObject clock_object)\n"
  "\n"
  "/**\n"
  " * Sets the clock that is used to determine the frame rate.  The default is\n"
  " * the application's global clock (ClockObject::get_global_clock()).\n"
  " */";
#else
static const char *Dtool_FrameRateMeter_set_clock_object_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ClockObject *FrameRateMeter::get_clock_object(void) const
 */
static PyObject *Dtool_FrameRateMeter_get_clock_object_38(PyObject *self, PyObject *) {
  FrameRateMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameRateMeter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ClockObject *FrameRateMeter::get_clock_object(void) const
  ClockObject *return_value = (*(const FrameRateMeter*)local_this).get_clock_object();
  if (return_value != (ClockObject *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (ClockObject *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ClockObject, true, false);
}

#ifndef NDEBUG
static const char *Dtool_FrameRateMeter_get_clock_object_38_comment =
  "C++ Interface:\n"
  "get_clock_object(FrameRateMeter self)\n"
  "\n"
  "/**\n"
  " * Returns the clock that is used to determine the frame rate.\n"
  " */";
#else
static const char *Dtool_FrameRateMeter_get_clock_object_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void FrameRateMeter::update(void)
 */
static PyObject *Dtool_FrameRateMeter_update_39(PyObject *self, PyObject *) {
  FrameRateMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameRateMeter, (void **)&local_this, "FrameRateMeter.update")) {
    return NULL;
  }
  // 1-inline void FrameRateMeter::update(void)
  (*local_this).update();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_FrameRateMeter_update_39_comment =
  "C++ Interface:\n"
  "update(const FrameRateMeter self)\n"
  "\n"
  "/**\n"
  " * You can call this to explicitly force the FrameRateMeter to update itself\n"
  " * with the latest frame rate information.  Normally, it is not necessary to\n"
  " * call this explicitly.\n"
  " */";
#else
static const char *Dtool_FrameRateMeter_update_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle FrameRateMeter::get_class_type(void)
 */
static PyObject *Dtool_FrameRateMeter_get_class_type_40(PyObject *, PyObject *) {
  // 1-static TypeHandle FrameRateMeter::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(FrameRateMeter::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_FrameRateMeter_get_class_type_40_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_FrameRateMeter_get_class_type_40_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline FrameRateMeter::FrameRateMeter(FrameRateMeter const &) = default
 * FrameRateMeter::FrameRateMeter(std::string const &name)
 */
static int Dtool_Init_FrameRateMeter(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "FrameRateMeter() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline FrameRateMeter::FrameRateMeter(FrameRateMeter const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:FrameRateMeter", (char **)keyword_list, &param0)) {
      FrameRateMeter const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_FrameRateMeter, (void **)&param0_this);
      if (param0_this != NULL) {
        FrameRateMeter *return_value = new FrameRateMeter(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FrameRateMeter, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 FrameRateMeter::FrameRateMeter(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:FrameRateMeter", (char **)keyword_list, &param0_str, &param0_len)) {
      FrameRateMeter *return_value = new FrameRateMeter(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FrameRateMeter, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline FrameRateMeter::FrameRateMeter(FrameRateMeter const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:FrameRateMeter", (char **)keyword_list, &param0)) {
      CPT(FrameRateMeter) param0_this;
      if (Dtool_ConstCoerce_FrameRateMeter(param0, param0_this)) {
        FrameRateMeter *return_value = new FrameRateMeter(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FrameRateMeter, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: FrameRateMeter::FrameRateMeter(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "FrameRateMeter(const FrameRateMeter param0)\n"
      "FrameRateMeter(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_FrameRateMeter(PyObject *args, CPT(FrameRateMeter) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_FrameRateMeter, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-FrameRateMeter::FrameRateMeter(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      FrameRateMeter *return_value = new FrameRateMeter(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_FrameRateMeter(PyObject *args, PT(FrameRateMeter) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_FrameRateMeter, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-FrameRateMeter::FrameRateMeter(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      FrameRateMeter *return_value = new FrameRateMeter(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_FrameRateMeter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_FrameRateMeter) {
    printf("FrameRateMeter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  FrameRateMeter *local_this = (FrameRateMeter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_FrameRateMeter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(TextNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(TextNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(TextNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TextEncoder) {
    return (TextEncoder *)(TextNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TextNode) {
    return (TextNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TextProperties) {
    return (TextProperties *)(TextNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(TextNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(TextNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(TextNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_FrameRateMeter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_FrameRateMeter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (FrameRateMeter*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (FrameRateMeter*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (FrameRateMeter*)other_this;
  }
  if (from_type == Dtool_Ptr_TextEncoder) {
    TextEncoder* other_this = (TextEncoder*)from_this;
    return (FrameRateMeter*)other_this;
  }
  if (from_type == Dtool_Ptr_TextNode) {
    TextNode* other_this = (TextNode*)from_this;
    return (FrameRateMeter*)other_this;
  }
  if (from_type == Dtool_Ptr_TextProperties) {
    TextProperties* other_this = (TextProperties*)from_this;
    return (FrameRateMeter*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (FrameRateMeter*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (FrameRateMeter*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (FrameRateMeter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class GeoMipTerrain
 */
/**
 * Python function wrapper for:
 * inline PNMImage &GeoMipTerrain::heightfield(void)
 */
static PyObject *Dtool_GeoMipTerrain_heightfield_44(PyObject *self, PyObject *) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.heightfield")) {
    return NULL;
  }
  // 1-inline PNMImage &GeoMipTerrain::heightfield(void)
  PNMImage *return_value = &((*local_this).heightfield());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, false, false);
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_heightfield_44_comment =
  "C++ Interface:\n"
  "heightfield(const GeoMipTerrain self)\n"
  "\n"
  "/**\n"
  " * Returns a reference to the heightfield (a PNMImage) contained inside\n"
  " * GeoMipTerrain.  You can use the reference to alter the heightfield.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_heightfield_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool GeoMipTerrain::set_heightfield(Filename const &filename, PNMFileType *type = 0)
 * inline bool GeoMipTerrain::set_heightfield(PNMImage const &image)
 */
static PyObject *Dtool_GeoMipTerrain_set_heightfield_45(PyObject *self, PyObject *args, PyObject *kwds) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.set_heightfield")) {
    return NULL;
  }
  {
    // -2 bool GeoMipTerrain::set_heightfield(Filename const &filename, PNMFileType *type = 0)
    PyObject *param1;
    static const char *keyword_list[] = {"filename", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_heightfield", (char **)keyword_list, &param1)) {
      Filename const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
      if (param1_this != NULL) {
        bool return_value = (*local_this).set_heightfield(*param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool GeoMipTerrain::set_heightfield(PNMImage const &image)
    PyObject *param1;
    static const char *keyword_list[] = {"image", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_heightfield", (char **)keyword_list, &param1)) {
      PNMImage const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_PNMImage, (void **)&param1_this);
      if (param1_this != NULL) {
        bool return_value = (*local_this).set_heightfield(*param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool GeoMipTerrain::set_heightfield(Filename const &filename, PNMFileType *type = 0)
    PyObject *param1;
    static const char *keyword_list[] = {"filename", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_heightfield", (char **)keyword_list, &param1)) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != NULL)) {
        bool return_value = (*local_this).set_heightfield(*param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: inline bool GeoMipTerrain::set_heightfield(PNMImage const &image)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_heightfield(const GeoMipTerrain self, const Filename filename)\n"
      "set_heightfield(const GeoMipTerrain self, const PNMImage image)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_set_heightfield_45_comment =
  "C++ Interface:\n"
  "set_heightfield(const GeoMipTerrain self, const Filename filename)\n"
  "set_heightfield(const GeoMipTerrain self, const PNMImage image)\n"
  "\n"
  "/**\n"
  " * Loads the specified heightmap image file into the heightfield.  Returns\n"
  " * true if succeeded, or false if an error has occured.  If the heightmap is\n"
  " * not a power of two plus one, it is scaled up using a gaussian filter.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Loads the specified heightmap image file into the heightfield.  Returns\n"
  " * true if succeeded, or false if an error has occured.  If the heightmap is\n"
  " * not a power of two plus one, it is scaled up using a gaussian filter.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_set_heightfield_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PNMImage &GeoMipTerrain::color_map(void)
 */
static PyObject *Dtool_GeoMipTerrain_color_map_46(PyObject *self, PyObject *) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.color_map")) {
    return NULL;
  }
  // 1-inline PNMImage &GeoMipTerrain::color_map(void)
  PNMImage *return_value = &((*local_this).color_map());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, false, false);
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_color_map_46_comment =
  "C++ Interface:\n"
  "color_map(const GeoMipTerrain self)\n"
  "\n"
  "/**\n"
  " * Returns a reference to the color map (a PNMImage) contained inside\n"
  " * GeoMipTerrain.  You can use the reference to alter the color map.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_color_map_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool GeoMipTerrain::set_color_map(Filename const &filename, PNMFileType *type = 0)
 * inline bool GeoMipTerrain::set_color_map(PNMImage const &image)
 * inline bool GeoMipTerrain::set_color_map(Texture const *image)
 * inline bool GeoMipTerrain::set_color_map(std::string const &path)
 */
static PyObject *Dtool_GeoMipTerrain_set_color_map_47(PyObject *self, PyObject *args, PyObject *kwds) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.set_color_map")) {
    return NULL;
  }
  {
    // -2 inline bool GeoMipTerrain::set_color_map(Filename const &filename, PNMFileType *type = 0)
    PyObject *param1;
    static const char *keyword_list[] = {"filename", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_color_map", (char **)keyword_list, &param1)) {
      Filename const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
      if (param1_this != NULL) {
        bool return_value = (*local_this).set_color_map(*param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool GeoMipTerrain::set_color_map(PNMImage const &image)
    PyObject *param1;
    static const char *keyword_list[] = {"image", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_color_map", (char **)keyword_list, &param1)) {
      PNMImage const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_PNMImage, (void **)&param1_this);
      if (param1_this != NULL) {
        bool return_value = (*local_this).set_color_map(*param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool GeoMipTerrain::set_color_map(Texture const *image)
    PyObject *param1;
    static const char *keyword_list[] = {"image", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_color_map", (char **)keyword_list, &param1)) {
      Texture const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Texture, (void **)&param1_this);
      if (param1_this != NULL) {
        bool return_value = (*local_this).set_color_map(param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool GeoMipTerrain::set_color_map(std::string const &path)
    char *param1_str = NULL;
    Py_ssize_t param1_len;
    static const char *keyword_list[] = {"path", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:set_color_map", (char **)keyword_list, &param1_str, &param1_len)) {
      bool return_value = (*local_this).set_color_map(std::string(param1_str, param1_len));
      return Dtool_Return_Bool(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool GeoMipTerrain::set_color_map(Filename const &filename, PNMFileType *type = 0)
    PyObject *param1;
    static const char *keyword_list[] = {"filename", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_color_map", (char **)keyword_list, &param1)) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != NULL)) {
        bool return_value = (*local_this).set_color_map(*param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: inline bool GeoMipTerrain::set_color_map(PNMImage const &image)
  // No coercion possible: inline bool GeoMipTerrain::set_color_map(Texture const *image)
  // No coercion possible: inline bool GeoMipTerrain::set_color_map(std::string const &path)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color_map(const GeoMipTerrain self, const Filename filename)\n"
      "set_color_map(const GeoMipTerrain self, const PNMImage image)\n"
      "set_color_map(const GeoMipTerrain self, const Texture image)\n"
      "set_color_map(const GeoMipTerrain self, str path)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_set_color_map_47_comment =
  "C++ Interface:\n"
  "set_color_map(const GeoMipTerrain self, const Filename filename)\n"
  "set_color_map(const GeoMipTerrain self, const PNMImage image)\n"
  "set_color_map(const GeoMipTerrain self, const Texture image)\n"
  "set_color_map(const GeoMipTerrain self, str path)\n"
  "\n"
  "/**\n"
  " * Loads the specified image as color map.  The next time generate() is\n"
  " * called, the terrain is painted with this color map using the vertex color\n"
  " * column.  Returns a boolean indicating whether the operation has succeeded.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_set_color_map_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool GeoMipTerrain::has_color_map(void) const
 */
static PyObject *Dtool_GeoMipTerrain_has_color_map_48(PyObject *self, PyObject *) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeoMipTerrain, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool GeoMipTerrain::has_color_map(void) const
  bool return_value = (*(const GeoMipTerrain*)local_this).has_color_map();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_has_color_map_48_comment =
  "C++ Interface:\n"
  "has_color_map(GeoMipTerrain self)\n"
  "\n"
  "/**\n"
  " * Returns whether a color map has been set.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_has_color_map_48_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeoMipTerrain::clear_color_map(void)
 */
static PyObject *Dtool_GeoMipTerrain_clear_color_map_49(PyObject *self, PyObject *) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.clear_color_map")) {
    return NULL;
  }
  // 1-inline void GeoMipTerrain::clear_color_map(void)
  (*local_this).clear_color_map();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_clear_color_map_49_comment =
  "C++ Interface:\n"
  "clear_color_map(const GeoMipTerrain self)\n"
  "\n"
  "/**\n"
  " * Clears the color map.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_clear_color_map_49_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void GeoMipTerrain::calc_ambient_occlusion(PN_stdfloat radius = 32, PN_stdfloat contrast = 2.0, PN_stdfloat brightness = 0.7500000000000001)
 */
static PyObject *Dtool_GeoMipTerrain_calc_ambient_occlusion_50(PyObject *self, PyObject *args, PyObject *kwds) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.calc_ambient_occlusion")) {
    return NULL;
  }
  // 1-void GeoMipTerrain::calc_ambient_occlusion(PN_stdfloat radius = 32, PN_stdfloat contrast = 2.0, PN_stdfloat brightness = 0.7500000000000001)
  float param1 = 32;
  float param2 = 2.0;
  float param3 = 0.7500000000000001;
  static const char *keyword_list[] = {"radius", "contrast", "brightness", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|fff:calc_ambient_occlusion", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).calc_ambient_occlusion((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_ambient_occlusion(const GeoMipTerrain self, float radius, float contrast, float brightness)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_calc_ambient_occlusion_50_comment =
  "C++ Interface:\n"
  "calc_ambient_occlusion(const GeoMipTerrain self, float radius, float contrast, float brightness)\n"
  "\n"
  "/**\n"
  " * Calculates an approximate for the ambient occlusion and stores it in the\n"
  " * color map, so that it will be written to the vertex colors.  Any existing\n"
  " * color map will be discarded.  You need to call this before generating the\n"
  " * geometry.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_calc_ambient_occlusion_50_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double GeoMipTerrain::get_elevation(double x, double y)
 */
static PyObject *Dtool_GeoMipTerrain_get_elevation_51(PyObject *self, PyObject *args, PyObject *kwds) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.get_elevation")) {
    return NULL;
  }
  // 1-double GeoMipTerrain::get_elevation(double x, double y)
  double param1;
  double param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:get_elevation", (char **)keyword_list, &param1, &param2)) {
    double return_value = (*local_this).get_elevation((double)param1, (double)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_elevation(const GeoMipTerrain self, double x, double y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_get_elevation_51_comment =
  "C++ Interface:\n"
  "get_elevation(const GeoMipTerrain self, double x, double y)\n"
  "\n"
  "/**\n"
  " * Fetches the elevation at (x, y), where the input coordinate is specified in\n"
  " * pixels.  This ignores the current LOD level and instead provides an\n"
  " * accurate number.  Linear blending is used for non-integral coordinates.\n"
  " * Terrain scale is NOT taken into account!  To get accurate normals, please\n"
  " * multiply this with the terrain Z scale!\n"
  " *\n"
  " * trueElev = terr.get_elevation(x,y) * terr.get_sz();\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_get_elevation_51_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVector3 GeoMipTerrain::get_normal(int x, int y)
 * inline LVector3 GeoMipTerrain::get_normal(unsigned short int mx, unsigned short int my, int x, int y)
 */
static PyObject *Dtool_GeoMipTerrain_get_normal_52(PyObject *self, PyObject *args, PyObject *kwds) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.get_normal")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-LVector3 GeoMipTerrain::get_normal(int x, int y)
      int param1;
      int param2;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_normal", (char **)keyword_list, &param1, &param2)) {
        LVector3 *return_value = new LVector3((*local_this).get_normal((int)param1, (int)param2));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LVector3 GeoMipTerrain::get_normal(unsigned short int mx, unsigned short int my, int x, int y)
      long param1;
      long param2;
      int param3;
      int param4;
      static const char *keyword_list[] = {"mx", "my", "x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "llii:get_normal", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
#ifndef NDEBUG
        if (param1 < 0 || param1 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param1);
        }
#endif
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param2);
        }
#endif
        LVector3 *return_value = new LVector3((*local_this).get_normal((unsigned short int)param1, (unsigned short int)param2, (int)param3, (int)param4));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_normal() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_normal(const GeoMipTerrain self, int x, int y)\n"
      "get_normal(const GeoMipTerrain self, int mx, int my, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_get_normal_52_comment =
  "C++ Interface:\n"
  "get_normal(const GeoMipTerrain self, int x, int y)\n"
  "get_normal(const GeoMipTerrain self, int mx, int my, int x, int y)\n"
  "\n"
  "/**\n"
  " * Fetches the terrain normal at (x,y), where the input coordinate is\n"
  " * specified in pixels.  This ignores the current LOD level and instead\n"
  " * provides an accurate number.  Terrain scale is NOT taken into account!  To\n"
  " * get accurate normals, please divide it by the terrain scale and normalize\n"
  " * it again!\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fetches the terrain normal at (x, y), where the input coordinate is\n"
  " * specified in pixels.  This ignores the current LOD level and instead\n"
  " * provides an accurate number.  Terrain scale is NOT taken into account!  To\n"
  " * get accurate normals, please divide it by the terrain scale and normalize\n"
  " * it again, like this:\n"
  " *\n"
  " * LVector3 normal (terr.get_normal(x, y)); normal.set(normal.get_x() /\n"
  " * root.get_sx(), normal.get_y() / root.get_sy(), normal.get_z() /\n"
  " * root.get_sz()); normal.normalize();\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_get_normal_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeoMipTerrain::set_bruteforce(bool bf)
 */
static PyObject *Dtool_GeoMipTerrain_set_bruteforce_53(PyObject *self, PyObject *arg) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.set_bruteforce")) {
    return NULL;
  }
  // 1-inline void GeoMipTerrain::set_bruteforce(bool bf)
  (*local_this).set_bruteforce((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bruteforce(const GeoMipTerrain self, bool bf)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_set_bruteforce_53_comment =
  "C++ Interface:\n"
  "set_bruteforce(const GeoMipTerrain self, bool bf)\n"
  "\n"
  "/**\n"
  " * Sets a boolean specifying whether the terrain will be rendered bruteforce.\n"
  " * If the terrain is rendered bruteforce, there will be no Level of Detail,\n"
  " * and the update() call will only update the terrain if it is marked dirty.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_set_bruteforce_53_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool GeoMipTerrain::get_bruteforce(void)
 */
static PyObject *Dtool_GeoMipTerrain_get_bruteforce_54(PyObject *self, PyObject *) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.get_bruteforce")) {
    return NULL;
  }
  // 1-inline bool GeoMipTerrain::get_bruteforce(void)
  bool return_value = (*local_this).get_bruteforce();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_get_bruteforce_54_comment =
  "C++ Interface:\n"
  "get_bruteforce(const GeoMipTerrain self)\n"
  "\n"
  "/**\n"
  " * Returns a boolean whether the terrain is rendered bruteforce or not.  See\n"
  " * set_bruteforce for more information.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_get_bruteforce_54_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeoMipTerrain::set_auto_flatten(int mode)
 */
static PyObject *Dtool_GeoMipTerrain_set_auto_flatten_56(PyObject *self, PyObject *arg) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.set_auto_flatten")) {
    return NULL;
  }
  // 1-inline void GeoMipTerrain::set_auto_flatten(int mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_auto_flatten((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_flatten(const GeoMipTerrain self, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_set_auto_flatten_56_comment =
  "C++ Interface:\n"
  "set_auto_flatten(const GeoMipTerrain self, int mode)\n"
  "\n"
  "/**\n"
  " * The terrain can be automatically flattened (using flatten_light,\n"
  " * flatten_medium, or flatten_strong) after each update.  This only affects\n"
  " * future updates, it doesn't flatten the current terrain.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_set_auto_flatten_56_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeoMipTerrain::set_focal_point(LPoint2d const &fp)
 * inline void GeoMipTerrain::set_focal_point(LPoint2f const &fp)
 * inline void GeoMipTerrain::set_focal_point(LPoint3d const &fp)
 * inline void GeoMipTerrain::set_focal_point(LPoint3f const &fp)
 * inline void GeoMipTerrain::set_focal_point(NodePath fnp)
 * inline void GeoMipTerrain::set_focal_point(double x, double y)
 */
static PyObject *Dtool_GeoMipTerrain_set_focal_point_57(PyObject *self, PyObject *args, PyObject *kwds) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.set_focal_point")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline void GeoMipTerrain::set_focal_point(LPoint3f const &fp)
        PyObject *param1;
        static const char *keyword_list[] = {"fp", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_focal_point", (char **)keyword_list, &param1)) {
          LPoint3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
          if (param1_this != NULL) {
            (*local_this).set_focal_point(*param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void GeoMipTerrain::set_focal_point(LPoint2f const &fp)
        PyObject *param1;
        static const char *keyword_list[] = {"fp", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_focal_point", (char **)keyword_list, &param1)) {
          LPoint2f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint2f, (void **)&param1_this);
          if (param1_this != NULL) {
            (*local_this).set_focal_point(*param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void GeoMipTerrain::set_focal_point(NodePath fnp)
        PyObject *param1;
        static const char *keyword_list[] = {"fnp", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_focal_point", (char **)keyword_list, &param1)) {
          NodePath *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_NodePath, (void **)&param1_this);
          if (param1_this != NULL) {
            (*local_this).set_focal_point(*param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void GeoMipTerrain::set_focal_point(LPoint2d const &fp)
        PyObject *param1;
        static const char *keyword_list[] = {"fp", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_focal_point", (char **)keyword_list, &param1)) {
          LPoint2d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint2d, (void **)&param1_this);
          if (param1_this != NULL) {
            (*local_this).set_focal_point(*param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void GeoMipTerrain::set_focal_point(LPoint3d const &fp)
        PyObject *param1;
        static const char *keyword_list[] = {"fp", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_focal_point", (char **)keyword_list, &param1)) {
          LPoint3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3d, (void **)&param1_this);
          if (param1_this != NULL) {
            (*local_this).set_focal_point(*param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void GeoMipTerrain::set_focal_point(LPoint3f const &fp)
        PyObject *param1;
        static const char *keyword_list[] = {"fp", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_focal_point", (char **)keyword_list, &param1)) {
          LPoint3f param1_local;
          LPoint3f const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
          if ((param1_this != NULL)) {
            (*local_this).set_focal_point(*param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void GeoMipTerrain::set_focal_point(LPoint2f const &fp)
        PyObject *param1;
        static const char *keyword_list[] = {"fp", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_focal_point", (char **)keyword_list, &param1)) {
          LPoint2f param1_local;
          LPoint2f const *param1_this = Dtool_Coerce_LPoint2f(param1, param1_local);
          if ((param1_this != NULL)) {
            (*local_this).set_focal_point(*param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void GeoMipTerrain::set_focal_point(NodePath fnp)
      {
        // -2 inline void GeoMipTerrain::set_focal_point(LPoint2d const &fp)
        PyObject *param1;
        static const char *keyword_list[] = {"fp", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_focal_point", (char **)keyword_list, &param1)) {
          LPoint2d param1_local;
          LPoint2d const *param1_this = Dtool_Coerce_LPoint2d(param1, param1_local);
          if ((param1_this != NULL)) {
            (*local_this).set_focal_point(*param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void GeoMipTerrain::set_focal_point(LPoint3d const &fp)
        PyObject *param1;
        static const char *keyword_list[] = {"fp", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_focal_point", (char **)keyword_list, &param1)) {
          LPoint3d param1_local;
          LPoint3d const *param1_this = Dtool_Coerce_LPoint3d(param1, param1_local);
          if ((param1_this != NULL)) {
            (*local_this).set_focal_point(*param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-inline void GeoMipTerrain::set_focal_point(double x, double y)
      double param1;
      double param2;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:set_focal_point", (char **)keyword_list, &param1, &param2)) {
        (*local_this).set_focal_point((double)param1, (double)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_focal_point() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_focal_point(const GeoMipTerrain self, const LPoint3f fp)\n"
      "set_focal_point(const GeoMipTerrain self, const LPoint2f fp)\n"
      "set_focal_point(const GeoMipTerrain self, NodePath fnp)\n"
      "set_focal_point(const GeoMipTerrain self, const LPoint2d fp)\n"
      "set_focal_point(const GeoMipTerrain self, const LPoint3d fp)\n"
      "set_focal_point(const GeoMipTerrain self, double x, double y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_set_focal_point_57_comment =
  "C++ Interface:\n"
  "set_focal_point(const GeoMipTerrain self, const LPoint3f fp)\n"
  "set_focal_point(const GeoMipTerrain self, const LPoint2f fp)\n"
  "set_focal_point(const GeoMipTerrain self, NodePath fnp)\n"
  "set_focal_point(const GeoMipTerrain self, const LPoint2d fp)\n"
  "set_focal_point(const GeoMipTerrain self, const LPoint3d fp)\n"
  "set_focal_point(const GeoMipTerrain self, double x, double y)\n"
  "\n"
  "// The focal point is the point at which the terrain will have the highest\n"
  "// quality (lowest level of detail). Parts farther away from the focal point\n"
  "// will have a lower quality (higher level of detail). The focal point is\n"
  "// not taken in respect if bruteforce is set true.\n"
  "\n"
  "/**\n"
  " * Sets the focal point.  GeoMipTerrain generates high-resolution terrain\n"
  " * around the focal point, and progressively lower and lower resolution\n"
  " * terrain as you get farther away.  If a point is supplied and not a\n"
  " * NodePath, make sure it's relative to the terrain.  Only the x and y\n"
  " * coordinates of the focal point are taken in respect.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_set_focal_point_57_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath GeoMipTerrain::get_focal_point(void) const
 */
static PyObject *Dtool_GeoMipTerrain_get_focal_point_58(PyObject *self, PyObject *) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeoMipTerrain, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath GeoMipTerrain::get_focal_point(void) const
  NodePath *return_value = new NodePath((*(const GeoMipTerrain*)local_this).get_focal_point());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_get_focal_point_58_comment =
  "C++ Interface:\n"
  "get_focal_point(GeoMipTerrain self)\n"
  "\n"
  "/**\n"
  " * Returns the focal point, as a NodePath.  If you have set it to be just a\n"
  " * point, it will return an empty node at the focal position.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_get_focal_point_58_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath GeoMipTerrain::get_root(void) const
 */
static PyObject *Dtool_GeoMipTerrain_get_root_59(PyObject *self, PyObject *) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeoMipTerrain, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath GeoMipTerrain::get_root(void) const
  NodePath *return_value = new NodePath((*(const GeoMipTerrain*)local_this).get_root());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_get_root_59_comment =
  "C++ Interface:\n"
  "get_root(GeoMipTerrain self)\n"
  "\n"
  "/**\n"
  " * Returns the root of the terrain.  This is a single PandaNode to which all\n"
  " * the rest of the terrain is parented.  The generate and update operations\n"
  " * replace the nodes which are parented to this root, but they don't replace\n"
  " * this root itself.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_get_root_59_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeoMipTerrain::set_block_size(unsigned short int newbs)
 */
static PyObject *Dtool_GeoMipTerrain_set_block_size_60(PyObject *self, PyObject *arg) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.set_block_size")) {
    return NULL;
  }
  // 1-inline void GeoMipTerrain::set_block_size(unsigned short int newbs)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    (*local_this).set_block_size((unsigned short int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_block_size(const GeoMipTerrain self, int newbs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_set_block_size_60_comment =
  "C++ Interface:\n"
  "set_block_size(const GeoMipTerrain self, int newbs)\n"
  "\n"
  "/**\n"
  " * Sets the block size.  If it is not a power of two, the closest power of two\n"
  " * is used.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_set_block_size_60_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline unsigned short int GeoMipTerrain::get_block_size(void)
 */
static PyObject *Dtool_GeoMipTerrain_get_block_size_61(PyObject *self, PyObject *) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.get_block_size")) {
    return NULL;
  }
  // 1-inline unsigned short int GeoMipTerrain::get_block_size(void)
  unsigned short int return_value = (*local_this).get_block_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_get_block_size_61_comment =
  "C++ Interface:\n"
  "get_block_size(const GeoMipTerrain self)\n"
  "\n"
  "/**\n"
  " * Gets the block size.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_get_block_size_61_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline unsigned short int GeoMipTerrain::get_max_level(void)
 */
static PyObject *Dtool_GeoMipTerrain_get_max_level_62(PyObject *self, PyObject *) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.get_max_level")) {
    return NULL;
  }
  // 1-inline unsigned short int GeoMipTerrain::get_max_level(void)
  unsigned short int return_value = (*local_this).get_max_level();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_get_max_level_62_comment =
  "C++ Interface:\n"
  "get_max_level(const GeoMipTerrain self)\n"
  "\n"
  "/**\n"
  " * Returns the highest level possible for this block size.  When a block is at\n"
  " * this level, it will be the worst quality possible.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_get_max_level_62_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeoMipTerrain::set_min_level(unsigned short int minlevel)
 */
static PyObject *Dtool_GeoMipTerrain_set_min_level_63(PyObject *self, PyObject *arg) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.set_min_level")) {
    return NULL;
  }
  // 1-inline void GeoMipTerrain::set_min_level(unsigned short int minlevel)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    (*local_this).set_min_level((unsigned short int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_min_level(const GeoMipTerrain self, int minlevel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_set_min_level_63_comment =
  "C++ Interface:\n"
  "set_min_level(const GeoMipTerrain self, int minlevel)\n"
  "\n"
  "/**\n"
  " * Sets the minimum level of detail at which blocks may be generated by\n"
  " * generate() or update(). The default value is 0, which is the highest\n"
  " * quality.  This value is also taken in respect when generating the terrain\n"
  " * bruteforce.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_set_min_level_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline unsigned short int GeoMipTerrain::get_min_level(void)
 */
static PyObject *Dtool_GeoMipTerrain_get_min_level_64(PyObject *self, PyObject *) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.get_min_level")) {
    return NULL;
  }
  // 1-inline unsigned short int GeoMipTerrain::get_min_level(void)
  unsigned short int return_value = (*local_this).get_min_level();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_get_min_level_64_comment =
  "C++ Interface:\n"
  "get_min_level(const GeoMipTerrain self)\n"
  "\n"
  "/**\n"
  " * Gets the minimum level of detail at which blocks may be generated by\n"
  " * generate() or update(). The default value is 0, which is the highest\n"
  " * quality.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_get_min_level_64_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool GeoMipTerrain::is_dirty(void)
 */
static PyObject *Dtool_GeoMipTerrain_is_dirty_65(PyObject *self, PyObject *) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.is_dirty")) {
    return NULL;
  }
  // 1-inline bool GeoMipTerrain::is_dirty(void)
  bool return_value = (*local_this).is_dirty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_is_dirty_65_comment =
  "C++ Interface:\n"
  "is_dirty(const GeoMipTerrain self)\n"
  "\n"
  "/**\n"
  " * Returns a bool indicating whether the terrain is marked 'dirty', that means\n"
  " * the terrain has to be regenerated on the next update() call, because for\n"
  " * instance the heightfield has changed.  Once the terrain has been\n"
  " * regenerated, the dirty flag automatically gets reset internally.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_is_dirty_65_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeoMipTerrain::set_factor(PN_stdfloat factor)
 */
static PyObject *Dtool_GeoMipTerrain_set_factor_66(PyObject *self, PyObject *arg) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.set_factor")) {
    return NULL;
  }
  // 1-inline void GeoMipTerrain::set_factor(PN_stdfloat factor)
  if (PyNumber_Check(arg)) {
    (*local_this).set_factor((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_factor(const GeoMipTerrain self, float factor)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_set_factor_66_comment =
  "C++ Interface:\n"
  "set_factor(const GeoMipTerrain self, float factor)\n"
  "\n"
  "/**\n"
  " * DEPRECATED method.  Use set_near/far instead.  Sets the quality factor at\n"
  " * which blocks must be generated.  The higher this level, the better quality\n"
  " * the terrain will be, but more expensive to render.  A value of 0 makes the\n"
  " * terrain the lowest quality possible, depending on blocksize.  The default\n"
  " * value is 100.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_set_factor_66_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeoMipTerrain::set_near_far(double input_near, double input_far)
 */
static PyObject *Dtool_GeoMipTerrain_set_near_far_67(PyObject *self, PyObject *args, PyObject *kwds) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.set_near_far")) {
    return NULL;
  }
  // 1-inline void GeoMipTerrain::set_near_far(double input_near, double input_far)
  double param1;
  double param2;
  static const char *keyword_list[] = {"input_near", "input_far", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:set_near_far", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_near_far((double)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_near_far(const GeoMipTerrain self, double input_near, double input_far)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_set_near_far_67_comment =
  "C++ Interface:\n"
  "set_near_far(const GeoMipTerrain self, double input_near, double input_far)\n"
  "\n"
  "/**\n"
  " * Sets the near and far LOD distances in one call.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_set_near_far_67_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeoMipTerrain::set_near(double input_near)
 */
static PyObject *Dtool_GeoMipTerrain_set_near_68(PyObject *self, PyObject *arg) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.set_near")) {
    return NULL;
  }
  // 1-inline void GeoMipTerrain::set_near(double input_near)
  if (PyNumber_Check(arg)) {
    (*local_this).set_near(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_near(const GeoMipTerrain self, double input_near)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_set_near_68_comment =
  "C++ Interface:\n"
  "set_near(const GeoMipTerrain self, double input_near)\n"
  "\n"
  "/**\n"
  " * Sets the near LOD distance, at which the terrain will be rendered at\n"
  " * highest quality.  This distance is in the terrain's coordinate space!\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_set_near_68_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeoMipTerrain::set_far(double input_far)
 */
static PyObject *Dtool_GeoMipTerrain_set_far_69(PyObject *self, PyObject *arg) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.set_far")) {
    return NULL;
  }
  // 1-inline void GeoMipTerrain::set_far(double input_far)
  if (PyNumber_Check(arg)) {
    (*local_this).set_far(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_far(const GeoMipTerrain self, double input_far)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_set_far_69_comment =
  "C++ Interface:\n"
  "set_far(const GeoMipTerrain self, double input_far)\n"
  "\n"
  "/**\n"
  " * Sets the far LOD distance, at which the terrain will be rendered at lowest\n"
  " * quality.  This distance is in the terrain's coordinate space!\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_set_far_69_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const GeoMipTerrain::get_block_node_path(unsigned short int mx, unsigned short int my)
 */
static PyObject *Dtool_GeoMipTerrain_get_block_node_path_70(PyObject *self, PyObject *args, PyObject *kwds) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.get_block_node_path")) {
    return NULL;
  }
  // 1-inline NodePath const GeoMipTerrain::get_block_node_path(unsigned short int mx, unsigned short int my)
  long param1;
  long param2;
  static const char *keyword_list[] = {"mx", "my", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ll:get_block_node_path", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
#ifndef NDEBUG
    if (param2 < 0 || param2 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param2);
    }
#endif
    NodePath const *return_value = new NodePath const((*local_this).get_block_node_path((unsigned short int)param1, (unsigned short int)param2));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_block_node_path(const GeoMipTerrain self, int mx, int my)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_get_block_node_path_70_comment =
  "C++ Interface:\n"
  "get_block_node_path(const GeoMipTerrain self, int mx, int my)\n"
  "\n"
  "/**\n"
  " * Returns the NodePath of the specified block.  If auto-flatten is enabled\n"
  " * and the node is getting removed during the flattening process, it will\n"
  " * still return a NodePath with the appropriate terrain chunk, but it will be\n"
  " * in a temporary scenegraph.  Please note that this returns a const object\n"
  " * and you can not modify the node.  Modify the heightfield instead.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_get_block_node_path_70_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2 GeoMipTerrain::get_block_from_pos(double x, double y)
 */
static PyObject *Dtool_GeoMipTerrain_get_block_from_pos_71(PyObject *self, PyObject *args, PyObject *kwds) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.get_block_from_pos")) {
    return NULL;
  }
  // 1-inline LVecBase2 GeoMipTerrain::get_block_from_pos(double x, double y)
  double param1;
  double param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:get_block_from_pos", (char **)keyword_list, &param1, &param2)) {
    LVecBase2 *return_value = new LVecBase2((*local_this).get_block_from_pos((double)param1, (double)param2));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_block_from_pos(const GeoMipTerrain self, double x, double y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_get_block_from_pos_71_comment =
  "C++ Interface:\n"
  "get_block_from_pos(const GeoMipTerrain self, double x, double y)\n"
  "\n"
  "/**\n"
  " * Gets the coordinates of the block at the specified position.  This position\n"
  " * must be relative to the terrain, not to render.  Returns an array\n"
  " * containing two values: the block x and the block y coords.  If the\n"
  " * positions are out of range, the closest block is taken.  Note that the\n"
  " * VecBase returned does not represent a vector, position, or rotation, but it\n"
  " * contains the block index of the block which you can use in\n"
  " * GeoMipTerrain::get_block_node_path.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_get_block_from_pos_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeoMipTerrain::set_border_stitching(bool stitching)
 */
static PyObject *Dtool_GeoMipTerrain_set_border_stitching_72(PyObject *self, PyObject *arg) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.set_border_stitching")) {
    return NULL;
  }
  // 1-inline void GeoMipTerrain::set_border_stitching(bool stitching)
  (*local_this).set_border_stitching((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_border_stitching(const GeoMipTerrain self, bool stitching)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_set_border_stitching_72_comment =
  "C++ Interface:\n"
  "set_border_stitching(const GeoMipTerrain self, bool stitching)\n"
  "\n"
  "/**\n"
  " * If this value is true, the LOD level at the borders of the terrain will be\n"
  " * 0. This is useful if you have multiple terrains attached and you want to\n"
  " * stitch them together, to fix seams.  This setting also has effect when\n"
  " * bruteforce is enabled, although in that case you are probably better off\n"
  " * with setting the minlevels to the same value.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_set_border_stitching_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool GeoMipTerrain::get_border_stitching(void)
 */
static PyObject *Dtool_GeoMipTerrain_get_border_stitching_73(PyObject *self, PyObject *) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.get_border_stitching")) {
    return NULL;
  }
  // 1-inline bool GeoMipTerrain::get_border_stitching(void)
  bool return_value = (*local_this).get_border_stitching();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_get_border_stitching_73_comment =
  "C++ Interface:\n"
  "get_border_stitching(const GeoMipTerrain self)\n"
  "\n"
  "/**\n"
  " * Returns the current stitching setting.  False by default, unless\n"
  " * set_stitching has been set.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_get_border_stitching_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double GeoMipTerrain::get_far(void)
 */
static PyObject *Dtool_GeoMipTerrain_get_far_74(PyObject *self, PyObject *) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.get_far")) {
    return NULL;
  }
  // 1-inline double GeoMipTerrain::get_far(void)
  double return_value = (*local_this).get_far();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_get_far_74_comment =
  "C++ Interface:\n"
  "get_far(const GeoMipTerrain self)\n"
  "\n"
  "/**\n"
  " * Returns the far LOD distance in the terrain coordinate space\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_get_far_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double GeoMipTerrain::get_near(void)
 */
static PyObject *Dtool_GeoMipTerrain_get_near_75(PyObject *self, PyObject *) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.get_near")) {
    return NULL;
  }
  // 1-inline double GeoMipTerrain::get_near(void)
  double return_value = (*local_this).get_near();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_get_near_75_comment =
  "C++ Interface:\n"
  "get_near(const GeoMipTerrain self)\n"
  "\n"
  "/**\n"
  " * Returns the near LOD distance in the terrain coordinate space\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_get_near_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int GeoMipTerrain::get_flatten_mode(void)
 */
static PyObject *Dtool_GeoMipTerrain_get_flatten_mode_76(PyObject *self, PyObject *) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.get_flatten_mode")) {
    return NULL;
  }
  // 1-inline int GeoMipTerrain::get_flatten_mode(void)
  int return_value = (*local_this).get_flatten_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_get_flatten_mode_76_comment =
  "C++ Interface:\n"
  "get_flatten_mode(const GeoMipTerrain self)\n"
  "\n"
  "/**\n"
  " * Returns the automatic-flatten mode (e.g., off, flatten_light,\n"
  " * flatten_medium, or flatten_strong)\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_get_flatten_mode_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PNMImage GeoMipTerrain::make_slope_image(void)
 */
static PyObject *Dtool_GeoMipTerrain_make_slope_image_77(PyObject *self, PyObject *) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.make_slope_image")) {
    return NULL;
  }
  // 1-PNMImage GeoMipTerrain::make_slope_image(void)
  PNMImage *return_value = new PNMImage((*local_this).make_slope_image());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_make_slope_image_77_comment =
  "C++ Interface:\n"
  "make_slope_image(const GeoMipTerrain self)\n"
  "\n"
  "/**\n"
  " * Returns a new grayscale image containing the slope angles.  A white pixel\n"
  " * value means a vertical slope, while a black pixel will mean that the\n"
  " * terrain is entirely flat at that pixel.  You can translate it to degrees by\n"
  " * mapping the greyscale values from 0 to 90 degrees.  The resulting image\n"
  " * will have the same size as the heightfield image.  The scale will be taken\n"
  " * into respect -- meaning, if you change the terrain scale, the slope image\n"
  " * will need to be regenerated in order to be correct.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_make_slope_image_77_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void GeoMipTerrain::generate(void)
 */
static PyObject *Dtool_GeoMipTerrain_generate_78(PyObject *self, PyObject *) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.generate")) {
    return NULL;
  }
  // 1-void GeoMipTerrain::generate(void)
  (*local_this).generate();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_generate_78_comment =
  "C++ Interface:\n"
  "generate(const GeoMipTerrain self)\n"
  "\n"
  "/**\n"
  " * (Re)generates the entire terrain, erasing the current.  This call un-\n"
  " * flattens the terrain, so make sure you have set auto-flatten if you want to\n"
  " * keep your terrain flattened.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_generate_78_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool GeoMipTerrain::update(void)
 */
static PyObject *Dtool_GeoMipTerrain_update_79(PyObject *self, PyObject *) {
  GeoMipTerrain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeoMipTerrain, (void **)&local_this, "GeoMipTerrain.update")) {
    return NULL;
  }
  // 1-bool GeoMipTerrain::update(void)
  bool return_value = (*local_this).update();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_update_79_comment =
  "C++ Interface:\n"
  "update(const GeoMipTerrain self)\n"
  "\n"
  "/**\n"
  " * Loops through all of the terrain blocks, and checks whether they need to be\n"
  " * updated.  If that is indeed the case, it regenerates the mipmap.  Returns a\n"
  " * true when the terrain has changed.  Returns false when the terrain isn't\n"
  " * updated at all.  If there is no terrain yet, it generates the entire\n"
  " * terrain.  This call un-flattens the terrain, so make sure you have set\n"
  " * auto-flatten if you want to keep your terrain flattened.\n"
  " */";
#else
static const char *Dtool_GeoMipTerrain_update_79_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GeoMipTerrain::get_class_type(void)
 */
static PyObject *Dtool_GeoMipTerrain_get_class_type_80(PyObject *, PyObject *) {
  // 1-static TypeHandle GeoMipTerrain::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(GeoMipTerrain::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeoMipTerrain_get_class_type_80_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeoMipTerrain_get_class_type_80_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline GeoMipTerrain::GeoMipTerrain(GeoMipTerrain const &) = default
 * inline GeoMipTerrain::GeoMipTerrain(std::string const &name)
 */
static int Dtool_Init_GeoMipTerrain(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "GeoMipTerrain() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline GeoMipTerrain::GeoMipTerrain(GeoMipTerrain const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:GeoMipTerrain", (char **)keyword_list, &param0)) {
      GeoMipTerrain const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_GeoMipTerrain, (void **)&param0_this);
      if (param0_this != NULL) {
        GeoMipTerrain *return_value = new GeoMipTerrain(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeoMipTerrain, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline GeoMipTerrain::GeoMipTerrain(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:GeoMipTerrain", (char **)keyword_list, &param0_str, &param0_len)) {
      GeoMipTerrain *return_value = new GeoMipTerrain(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeoMipTerrain, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline GeoMipTerrain::GeoMipTerrain(GeoMipTerrain const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:GeoMipTerrain", (char **)keyword_list, &param0)) {
      GeoMipTerrain const *param0_this;
      bool param0_manage = false;
      if (Dtool_ConstCoerce_GeoMipTerrain(param0, param0_this, param0_manage)) {
        GeoMipTerrain *return_value = new GeoMipTerrain(*param0_this);
        if (param0_manage) {
          delete param0_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeoMipTerrain, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: inline GeoMipTerrain::GeoMipTerrain(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeoMipTerrain(const GeoMipTerrain param0)\n"
      "GeoMipTerrain(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_GeoMipTerrain(PyObject *args, GeoMipTerrain const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_GeoMipTerrain, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline GeoMipTerrain::GeoMipTerrain(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      GeoMipTerrain *return_value = new GeoMipTerrain(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_GeoMipTerrain(PyObject *args, GeoMipTerrain *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_GeoMipTerrain, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline GeoMipTerrain::GeoMipTerrain(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      GeoMipTerrain *return_value = new GeoMipTerrain(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_GeoMipTerrain(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_GeoMipTerrain) {
    printf("GeoMipTerrain ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  GeoMipTerrain *local_this = (GeoMipTerrain *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_GeoMipTerrain) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_GeoMipTerrain(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_GeoMipTerrain) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeoMipTerrain*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class HeightfieldTesselator
 */
/**
 * Python function wrapper for:
 * inline PNMImage &HeightfieldTesselator::heightfield(void)
 */
static PyObject *Dtool_HeightfieldTesselator_heightfield_84(PyObject *self, PyObject *) {
  HeightfieldTesselator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HeightfieldTesselator, (void **)&local_this, "HeightfieldTesselator.heightfield")) {
    return NULL;
  }
  // 1-inline PNMImage &HeightfieldTesselator::heightfield(void)
  PNMImage *return_value = &((*local_this).heightfield());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, false, false);
}

#ifndef NDEBUG
static const char *Dtool_HeightfieldTesselator_heightfield_84_comment =
  "C++ Interface:\n"
  "heightfield(const HeightfieldTesselator self)\n"
  "\n"
  "/**\n"
  " * Returns a reference to the heightfield (a PNMImage) contained inside the\n"
  " * HeightfieldTesselator.  You can use the reference to alter the heightfield.\n"
  " */";
#else
static const char *Dtool_HeightfieldTesselator_heightfield_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HeightfieldTesselator::set_heightfield(Filename const &filename, PNMFileType *type = 0)
 */
static PyObject *Dtool_HeightfieldTesselator_set_heightfield_85(PyObject *self, PyObject *args, PyObject *kwds) {
  HeightfieldTesselator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HeightfieldTesselator, (void **)&local_this, "HeightfieldTesselator.set_heightfield")) {
    return NULL;
  }
  // 1-inline bool HeightfieldTesselator::set_heightfield(Filename const &filename, PNMFileType *type = 0)
  PyObject *param1;
  static const char *keyword_list[] = {"filename", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_heightfield", (char **)keyword_list, &param1)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "HeightfieldTesselator.set_heightfield", "Filename");
    }
    bool return_value = (*local_this).set_heightfield(*param1_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_heightfield(const HeightfieldTesselator self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HeightfieldTesselator_set_heightfield_85_comment =
  "C++ Interface:\n"
  "set_heightfield(const HeightfieldTesselator self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Loads the specified greyscale image file into the heightfield.\n"
  " */";
#else
static const char *Dtool_HeightfieldTesselator_set_heightfield_85_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HeightfieldTesselator::set_poly_count(int n)
 */
static PyObject *Dtool_HeightfieldTesselator_set_poly_count_86(PyObject *self, PyObject *arg) {
  HeightfieldTesselator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HeightfieldTesselator, (void **)&local_this, "HeightfieldTesselator.set_poly_count")) {
    return NULL;
  }
  // 1-inline void HeightfieldTesselator::set_poly_count(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_poly_count((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_poly_count(const HeightfieldTesselator self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HeightfieldTesselator_set_poly_count_86_comment =
  "C++ Interface:\n"
  "set_poly_count(const HeightfieldTesselator self, int n)\n"
  "\n"
  "/**\n"
  " * Sets the polygon-count target.  The tesselator usually manages to come\n"
  " * within about 20% of the target, plus or minus.\n"
  " */";
#else
static const char *Dtool_HeightfieldTesselator_set_poly_count_86_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HeightfieldTesselator::set_visibility_radius(int r)
 */
static PyObject *Dtool_HeightfieldTesselator_set_visibility_radius_87(PyObject *self, PyObject *arg) {
  HeightfieldTesselator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HeightfieldTesselator, (void **)&local_this, "HeightfieldTesselator.set_visibility_radius")) {
    return NULL;
  }
  // 1-inline void HeightfieldTesselator::set_visibility_radius(int r)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_visibility_radius((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_visibility_radius(const HeightfieldTesselator self, int r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HeightfieldTesselator_set_visibility_radius_87_comment =
  "C++ Interface:\n"
  "set_visibility_radius(const HeightfieldTesselator self, int r)\n"
  "\n"
  "/**\n"
  " * Sets the visibility radius.  Polygons that are completely outside the\n"
  " * radius (relative to the focal point) are cropped away.  The cropping is\n"
  " * imperfect (all approximations are conservative), so this should be used in\n"
  " * conjunction with a far clipping plane, fog, or some other visibility\n"
  " * limiting mechanism.  The units are in pixels.\n"
  " */";
#else
static const char *Dtool_HeightfieldTesselator_set_visibility_radius_87_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HeightfieldTesselator::set_focal_point(int x, int y)
 */
static PyObject *Dtool_HeightfieldTesselator_set_focal_point_88(PyObject *self, PyObject *args, PyObject *kwds) {
  HeightfieldTesselator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HeightfieldTesselator, (void **)&local_this, "HeightfieldTesselator.set_focal_point")) {
    return NULL;
  }
  // 1-inline void HeightfieldTesselator::set_focal_point(int x, int y)
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_focal_point", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_focal_point((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_focal_point(const HeightfieldTesselator self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HeightfieldTesselator_set_focal_point_88_comment =
  "C++ Interface:\n"
  "set_focal_point(const HeightfieldTesselator self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Sets the focal point.  The tesselator generates high-resolution terrain\n"
  " * around the focal point, and progressively lower and lower resolution\n"
  " * terrain as you get farther away.  The units are in pixels.\n"
  " */";
#else
static const char *Dtool_HeightfieldTesselator_set_focal_point_88_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HeightfieldTesselator::set_horizontal_scale(double h)
 */
static PyObject *Dtool_HeightfieldTesselator_set_horizontal_scale_89(PyObject *self, PyObject *arg) {
  HeightfieldTesselator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HeightfieldTesselator, (void **)&local_this, "HeightfieldTesselator.set_horizontal_scale")) {
    return NULL;
  }
  // 1-inline void HeightfieldTesselator::set_horizontal_scale(double h)
  if (PyNumber_Check(arg)) {
    (*local_this).set_horizontal_scale(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_horizontal_scale(const HeightfieldTesselator self, double h)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HeightfieldTesselator_set_horizontal_scale_89_comment =
  "C++ Interface:\n"
  "set_horizontal_scale(const HeightfieldTesselator self, double h)\n"
  "\n"
  "/**\n"
  " * Sets the horizontal scale.  The default scale is 1.0, meaning that each\n"
  " * pixel in the heightfield is 1x1 panda units wide.\n"
  " */";
#else
static const char *Dtool_HeightfieldTesselator_set_horizontal_scale_89_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HeightfieldTesselator::set_vertical_scale(double v)
 */
static PyObject *Dtool_HeightfieldTesselator_set_vertical_scale_90(PyObject *self, PyObject *arg) {
  HeightfieldTesselator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HeightfieldTesselator, (void **)&local_this, "HeightfieldTesselator.set_vertical_scale")) {
    return NULL;
  }
  // 1-inline void HeightfieldTesselator::set_vertical_scale(double v)
  if (PyNumber_Check(arg)) {
    (*local_this).set_vertical_scale(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertical_scale(const HeightfieldTesselator self, double v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HeightfieldTesselator_set_vertical_scale_90_comment =
  "C++ Interface:\n"
  "set_vertical_scale(const HeightfieldTesselator self, double v)\n"
  "\n"
  "/**\n"
  " * Sets the vertical scale.  The default scale is 255.0, meaning that each as\n"
  " * the gray value ranges from (0-1), the elevation ranges from (0-255) feet.\n"
  " */";
#else
static const char *Dtool_HeightfieldTesselator_set_vertical_scale_90_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HeightfieldTesselator::set_max_triangles(int n)
 */
static PyObject *Dtool_HeightfieldTesselator_set_max_triangles_91(PyObject *self, PyObject *arg) {
  HeightfieldTesselator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HeightfieldTesselator, (void **)&local_this, "HeightfieldTesselator.set_max_triangles")) {
    return NULL;
  }
  // 1-inline void HeightfieldTesselator::set_max_triangles(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_max_triangles((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_triangles(const HeightfieldTesselator self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HeightfieldTesselator_set_max_triangles_91_comment =
  "C++ Interface:\n"
  "set_max_triangles(const HeightfieldTesselator self, int n)\n"
  "\n"
  "/**\n"
  " * Sets the max triangles per geom.\n"
  " */";
#else
static const char *Dtool_HeightfieldTesselator_set_max_triangles_91_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double HeightfieldTesselator::get_elevation(double x, double y)
 */
static PyObject *Dtool_HeightfieldTesselator_get_elevation_92(PyObject *self, PyObject *args, PyObject *kwds) {
  HeightfieldTesselator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HeightfieldTesselator, (void **)&local_this, "HeightfieldTesselator.get_elevation")) {
    return NULL;
  }
  // 1-double HeightfieldTesselator::get_elevation(double x, double y)
  double param1;
  double param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:get_elevation", (char **)keyword_list, &param1, &param2)) {
    double return_value = (*local_this).get_elevation((double)param1, (double)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_elevation(const HeightfieldTesselator self, double x, double y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HeightfieldTesselator_get_elevation_92_comment =
  "C++ Interface:\n"
  "get_elevation(const HeightfieldTesselator self, double x, double y)\n"
  "\n"
  "/**\n"
  " * Fetches the elevation at (x,y), where the input coordinate is specified in\n"
  " * pixels.  This ignores the current tesselation level and instead provides an\n"
  " * accurate number.  Linear blending is used for non-integral coordinates.\n"
  " */";
#else
static const char *Dtool_HeightfieldTesselator_get_elevation_92_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePath HeightfieldTesselator::generate(void)
 */
static PyObject *Dtool_HeightfieldTesselator_generate_93(PyObject *self, PyObject *) {
  HeightfieldTesselator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HeightfieldTesselator, (void **)&local_this, "HeightfieldTesselator.generate")) {
    return NULL;
  }
  // 1-NodePath HeightfieldTesselator::generate(void)
  NodePath *return_value = new NodePath((*local_this).generate());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_HeightfieldTesselator_generate_93_comment =
  "C++ Interface:\n"
  "generate(const HeightfieldTesselator self)\n"
  "\n"
  "/**\n"
  " * Generates a tree of nodes that represents the heightfield.  This can be\n"
  " * reparented into the scene.\n"
  " */";
#else
static const char *Dtool_HeightfieldTesselator_generate_93_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline HeightfieldTesselator::HeightfieldTesselator(std::string const &name)
 */
static int Dtool_Init_HeightfieldTesselator(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "HeightfieldTesselator() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-inline HeightfieldTesselator::HeightfieldTesselator(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    HeightfieldTesselator *return_value = new HeightfieldTesselator(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HeightfieldTesselator, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "HeightfieldTesselator(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_HeightfieldTesselator(PyObject *args, HeightfieldTesselator const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_HeightfieldTesselator, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline HeightfieldTesselator::HeightfieldTesselator(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      HeightfieldTesselator *return_value = new HeightfieldTesselator(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_HeightfieldTesselator(PyObject *args, HeightfieldTesselator *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_HeightfieldTesselator, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline HeightfieldTesselator::HeightfieldTesselator(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      HeightfieldTesselator *return_value = new HeightfieldTesselator(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_HeightfieldTesselator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_HeightfieldTesselator) {
    printf("HeightfieldTesselator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  HeightfieldTesselator *local_this = (HeightfieldTesselator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_HeightfieldTesselator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_HeightfieldTesselator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_HeightfieldTesselator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (HeightfieldTesselator*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LineSegs
 */
/**
 * Python function wrapper for:
 * void LineSegs::reset(void)
 */
static PyObject *Dtool_LineSegs_reset_97(PyObject *self, PyObject *) {
  LineSegs *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LineSegs, (void **)&local_this, "LineSegs.reset")) {
    return NULL;
  }
  // 1-void LineSegs::reset(void)
  (*local_this).reset();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LineSegs_reset_97_comment =
  "C++ Interface:\n"
  "reset(const LineSegs self)\n"
  "\n"
  "/**\n"
  " * Removes any lines in progress and resets to the initial empty state.\n"
  " */";
#else
static const char *Dtool_LineSegs_reset_97_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LineSegs::set_color(LColor const &color)
 * inline void LineSegs::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a = 1.0)
 */
static PyObject *Dtool_LineSegs_set_color_98(PyObject *self, PyObject *args, PyObject *kwds) {
  LineSegs *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LineSegs, (void **)&local_this, "LineSegs.set_color")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "color");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'color' (pos 1) not found");
      }
      // 1-inline void LineSegs::set_color(LColor const &color)
      LVecBase4f arg_local;
      LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LineSegs.set_color", "LVecBase4f");
      }
      (*local_this).set_color(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
  case 4:
    {
      // 1-inline void LineSegs::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a = 1.0)
      float param1;
      float param2;
      float param3;
      float param4 = 1.0;
      static const char *keyword_list[] = {"r", "g", "b", "a", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff|f:set_color", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_color((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_color() takes 2, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color(const LineSegs self, const LVecBase4f color)\n"
      "set_color(const LineSegs self, float r, float g, float b, float a)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LineSegs_set_color_98_comment =
  "C++ Interface:\n"
  "set_color(const LineSegs self, const LVecBase4f color)\n"
  "set_color(const LineSegs self, float r, float g, float b, float a)\n"
  "\n"
  "/**\n"
  " * Establishes the color that will be assigned to all vertices created by\n"
  " * future calls to move_to() and draw_to().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Establishes the color that will be assigned to all vertices created by\n"
  " * future calls to move_to() and draw_to().\n"
  " */";
#else
static const char *Dtool_LineSegs_set_color_98_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LineSegs::set_thickness(PN_stdfloat thick)
 */
static PyObject *Dtool_LineSegs_set_thickness_99(PyObject *self, PyObject *arg) {
  LineSegs *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LineSegs, (void **)&local_this, "LineSegs.set_thickness")) {
    return NULL;
  }
  // 1-inline void LineSegs::set_thickness(PN_stdfloat thick)
  if (PyNumber_Check(arg)) {
    (*local_this).set_thickness((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_thickness(const LineSegs self, float thick)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LineSegs_set_thickness_99_comment =
  "C++ Interface:\n"
  "set_thickness(const LineSegs self, float thick)\n"
  "\n"
  "/**\n"
  " * Establishes the line thickness or point size in pixels that will be\n"
  " * assigned to all lines and points created by future calls to create().\n"
  " */";
#else
static const char *Dtool_LineSegs_set_thickness_99_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LineSegs::move_to(LVecBase3 const &v)
 * inline void LineSegs::move_to(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_LineSegs_move_to_100(PyObject *self, PyObject *args, PyObject *kwds) {
  LineSegs *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LineSegs, (void **)&local_this, "LineSegs.move_to")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "v");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'v' (pos 1) not found");
      }
      // 1-void LineSegs::move_to(LVecBase3 const &v)
      LVecBase3f arg_local;
      LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LineSegs.move_to", "LVecBase3f");
      }
      (*local_this).move_to(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void LineSegs::move_to(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:move_to", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).move_to((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "move_to() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "move_to(const LineSegs self, const LVecBase3f v)\n"
      "move_to(const LineSegs self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LineSegs_move_to_100_comment =
  "C++ Interface:\n"
  "move_to(const LineSegs self, const LVecBase3f v)\n"
  "move_to(const LineSegs self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Moves the pen to the given point without drawing a line.  When followed by\n"
  " * draw_to(), this marks the first point of a line segment; when followed by\n"
  " * move_to() or create(), this creates a single point.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Moves the pen to the given point without drawing a line.  When followed by\n"
  " * draw_to(), this marks the first point of a line segment; when followed by\n"
  " * move_to() or create(), this creates a single point.\n"
  " */";
#else
static const char *Dtool_LineSegs_move_to_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LineSegs::draw_to(LVecBase3 const &v)
 * inline void LineSegs::draw_to(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_LineSegs_draw_to_101(PyObject *self, PyObject *args, PyObject *kwds) {
  LineSegs *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LineSegs, (void **)&local_this, "LineSegs.draw_to")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "v");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'v' (pos 1) not found");
      }
      // 1-void LineSegs::draw_to(LVecBase3 const &v)
      LVecBase3f arg_local;
      LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LineSegs.draw_to", "LVecBase3f");
      }
      (*local_this).draw_to(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void LineSegs::draw_to(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:draw_to", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).draw_to((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "draw_to() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "draw_to(const LineSegs self, const LVecBase3f v)\n"
      "draw_to(const LineSegs self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LineSegs_draw_to_101_comment =
  "C++ Interface:\n"
  "draw_to(const LineSegs self, const LVecBase3f v)\n"
  "draw_to(const LineSegs self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Draws a line segment from the pen's last position (the last call to move_to\n"
  " * or draw_to) to the indicated point.  move_to() and draw_to() only update\n"
  " * tables; the actual drawing is performed when create() is called.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Draws a line segment from the pen's last position (the last call to move_to\n"
  " * or draw_to) to the indicated point.  move_to() and draw_to() only update\n"
  " * tables; the actual drawing is performed when create() is called.\n"
  " */";
#else
static const char *Dtool_LineSegs_draw_to_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVertex const &LineSegs::get_current_position(void)
 */
static PyObject *Dtool_LineSegs_get_current_position_102(PyObject *self, PyObject *) {
  LineSegs *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LineSegs, (void **)&local_this, "LineSegs.get_current_position")) {
    return NULL;
  }
  // 1-LVertex const &LineSegs::get_current_position(void)
  LVertex const *return_value = &((*local_this).get_current_position());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LineSegs_get_current_position_102_comment =
  "C++ Interface:\n"
  "get_current_position(const LineSegs self)\n"
  "\n"
  "/**\n"
  " * Returns the pen's current position.  The next call to draw_to() will draw a\n"
  " * line segment from this point.\n"
  " */";
#else
static const char *Dtool_LineSegs_get_current_position_102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool LineSegs::is_empty(void)
 */
static PyObject *Dtool_LineSegs_is_empty_103(PyObject *self, PyObject *) {
  LineSegs *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LineSegs, (void **)&local_this, "LineSegs.is_empty")) {
    return NULL;
  }
  // 1-bool LineSegs::is_empty(void)
  bool return_value = (*local_this).is_empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LineSegs_is_empty_103_comment =
  "C++ Interface:\n"
  "is_empty(const LineSegs self)\n"
  "\n"
  "/**\n"
  " * Returns true if move_to() or draw_to() have not been called since the last\n"
  " * reset() or create(), false otherwise.\n"
  " */";
#else
static const char *Dtool_LineSegs_is_empty_103_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * GeomNode *LineSegs::create(GeomNode *previous, bool dynamic = false)
 * inline GeomNode *LineSegs::create(bool dynamic = false)
 */
static PyObject *Dtool_LineSegs_create_104(PyObject *self, PyObject *args, PyObject *kwds) {
  LineSegs *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LineSegs, (void **)&local_this, "LineSegs.create")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline GeomNode *LineSegs::create(bool dynamic)
      GeomNode *return_value = (*local_this).create();
      if (return_value != (GeomNode *)NULL) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != (GeomNode *)NULL) {
          unref_delete(return_value);
        }
        return NULL;
      }
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomNode, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 GeomNode *LineSegs::create(GeomNode *previous, bool dynamic = false)
        PyObject *param1;
        PyObject *param2 = Py_False;
        static const char *keyword_list[] = {"previous", "dynamic", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:create", (char **)keyword_list, &param1, &param2)) {
          GeomNode *param1_this = (GeomNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GeomNode, 1, "LineSegs.create", false, false);
          if (param1_this != NULL) {
            GeomNode *return_value = (*local_this).create(param1_this, (PyObject_IsTrue(param2) != 0));
            if (return_value != (GeomNode *)NULL) {
              return_value->ref();
            }
            if (Dtool_CheckErrorOccurred()) {
              if (return_value != (GeomNode *)NULL) {
                unref_delete(return_value);
              }
              return NULL;
            }
            if (return_value == NULL) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomNode, true, false, return_value->as_typed_object()->get_type_index());
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GeomNode *LineSegs::create(bool dynamic = false)
        PyObject *param1;
        static const char *keyword_list[] = {"dynamic", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:create", (char **)keyword_list, &param1)) {
          GeomNode *return_value = (*local_this).create((PyObject_IsTrue(param1) != 0));
          if (return_value != (GeomNode *)NULL) {
            return_value->ref();
          }
          if (Dtool_CheckErrorOccurred()) {
            if (return_value != (GeomNode *)NULL) {
              unref_delete(return_value);
            }
            return NULL;
          }
          if (return_value == NULL) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomNode, true, false, return_value->as_typed_object()->get_type_index());
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: GeomNode *LineSegs::create(GeomNode *previous, bool dynamic = false)
      // No coercion possible: inline GeomNode *LineSegs::create(bool dynamic = false)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "create() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "create(const LineSegs self)\n"
      "create(const LineSegs self, GeomNode previous, bool dynamic)\n"
      "create(const LineSegs self, bool dynamic)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LineSegs_create_104_comment =
  "C++ Interface:\n"
  "create(const LineSegs self)\n"
  "create(const LineSegs self, GeomNode previous, bool dynamic)\n"
  "create(const LineSegs self, bool dynamic)\n"
  "\n"
  "/**\n"
  " * Creates a new GeomNode that will render the series of line segments and\n"
  " * points described via calls to move_to() and draw_to().  The lines and\n"
  " * points are created with the color and thickness established by calls to\n"
  " * set_color() and set_thick().\n"
  " *\n"
  " * If dynamic is true, the line segments will be created with the dynamic Geom\n"
  " * setting, optimizing them for runtime vertex animation.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Appends to an existing GeomNode a new Geom that will render the series of\n"
  " * line segments and points described via calls to move_to() and draw_to().\n"
  " * The lines and points are created with the color and thickness established\n"
  " * by calls to set_color() and set_thick().\n"
  " *\n"
  " * If dynamic is true, the line segments will be created with the dynamic Geom\n"
  " * setting, optimizing them for runtime vertex animation.\n"
  " */";
#else
static const char *Dtool_LineSegs_create_104_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LineSegs::get_num_vertices(void) const
 */
static PyObject *Dtool_LineSegs_get_num_vertices_105(PyObject *self, PyObject *) {
  LineSegs *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LineSegs, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LineSegs::get_num_vertices(void) const
  int return_value = (*(const LineSegs*)local_this).get_num_vertices();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LineSegs_get_num_vertices_105_comment =
  "C++ Interface:\n"
  "get_num_vertices(LineSegs self)\n"
  "\n"
  "// Functions to move the line vertices after they have been created.\n"
  "\n"
  "// Functions to move the line vertices after they have been created.\n"
  "\n"
  "// Functions to move the line vertices after they have been created.\n"
  "\n"
  "/**\n"
  " * Returns the total number of line segment and point vertices generated by\n"
  " * the last call to create().  The positions of these vertices may be read and\n"
  " * adjusted through get_vertex() and set_vertex().\n"
  " */";
#else
static const char *Dtool_LineSegs_get_num_vertices_105_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVertex LineSegs::get_vertex(int n) const
 */
static PyObject *Dtool_LineSegs_get_vertex_106(PyObject *self, PyObject *arg) {
  LineSegs *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LineSegs, (void **)&local_this)) {
    return NULL;
  }
  // 1-LVertex LineSegs::get_vertex(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVertex *return_value = new LVertex((*(const LineSegs*)local_this).get_vertex((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(LineSegs self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LineSegs_get_vertex_106_comment =
  "C++ Interface:\n"
  "get_vertex(LineSegs self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth point or vertex of the line segment sequence generated by\n"
  " * the last call to create().  The first move_to() generates vertex 0;\n"
  " * subsequent move_to() and draw_to() calls generate consecutively higher\n"
  " * vertex numbers.\n"
  " */";
#else
static const char *Dtool_LineSegs_get_vertex_106_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LineSegs::set_vertex(int n, LVertex const &vert)
 * inline void LineSegs::set_vertex(int vertex, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_LineSegs_set_vertex_108(PyObject *self, PyObject *args, PyObject *kwds) {
  LineSegs *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LineSegs, (void **)&local_this, "LineSegs.set_vertex")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-void LineSegs::set_vertex(int n, LVertex const &vert)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"n", "vert", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_vertex", (char **)keyword_list, &param1, &param2)) {
        LPoint3f param2_local;
        LVertex const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "LineSegs.set_vertex", "LPoint3f");
        }
        (*local_this).set_vertex((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void LineSegs::set_vertex(int vertex, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      int param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"vertex", "x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ifff:set_vertex", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_vertex((int)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_vertex() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertex(const LineSegs self, int n, const LPoint3f vert)\n"
      "set_vertex(const LineSegs self, int vertex, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LineSegs_set_vertex_108_comment =
  "C++ Interface:\n"
  "set_vertex(const LineSegs self, int n, const LPoint3f vert)\n"
  "set_vertex(const LineSegs self, int vertex, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Moves the nth point or vertex of the line segment sequence generated by the\n"
  " * last call to create().  The first move_to() generates vertex 0; subsequent\n"
  " * move_to() and draw_to() calls generate consecutively higher vertex numbers.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Moves the nth point or vertex of the line segment sequence generated by the\n"
  " * last call to create().  The first move_to() generates vertex 0; subsequent\n"
  " * move_to() and draw_to() calls generate consecutively higher vertex numbers.\n"
  " */";
#else
static const char *Dtool_LineSegs_set_vertex_108_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LColor LineSegs::get_vertex_color(int vertex) const
 */
static PyObject *Dtool_LineSegs_get_vertex_color_109(PyObject *self, PyObject *arg) {
  LineSegs *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LineSegs, (void **)&local_this)) {
    return NULL;
  }
  // 1-LColor LineSegs::get_vertex_color(int vertex) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LColor *return_value = new LColor((*(const LineSegs*)local_this).get_vertex_color((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex_color(LineSegs self, int vertex)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LineSegs_get_vertex_color_109_comment =
  "C++ Interface:\n"
  "get_vertex_color(LineSegs self, int vertex)\n"
  "\n"
  "/**\n"
  " * Returns the color of the nth point or vertex.\n"
  " */";
#else
static const char *Dtool_LineSegs_get_vertex_color_109_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LineSegs::set_vertex_color(int vertex, LColor const &c)
 * inline void LineSegs::set_vertex_color(int vertex, PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a = 1.0)
 */
static PyObject *Dtool_LineSegs_set_vertex_color_111(PyObject *self, PyObject *args, PyObject *kwds) {
  LineSegs *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LineSegs, (void **)&local_this, "LineSegs.set_vertex_color")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-void LineSegs::set_vertex_color(int vertex, LColor const &c)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"vertex", "c", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_vertex_color", (char **)keyword_list, &param1, &param2)) {
        LVecBase4f param2_local;
        LColor const *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "LineSegs.set_vertex_color", "LVecBase4f");
        }
        (*local_this).set_vertex_color((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
  case 5:
    {
      // 1-inline void LineSegs::set_vertex_color(int vertex, PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a = 1.0)
      int param1;
      float param2;
      float param3;
      float param4;
      float param5 = 1.0;
      static const char *keyword_list[] = {"vertex", "r", "g", "b", "a", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ifff|f:set_vertex_color", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        (*local_this).set_vertex_color((int)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_vertex_color() takes 3, 5 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertex_color(const LineSegs self, int vertex, const LVecBase4f c)\n"
      "set_vertex_color(const LineSegs self, int vertex, float r, float g, float b, float a)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LineSegs_set_vertex_color_111_comment =
  "C++ Interface:\n"
  "set_vertex_color(const LineSegs self, int vertex, const LVecBase4f c)\n"
  "set_vertex_color(const LineSegs self, int vertex, float r, float g, float b, float a)\n"
  "\n"
  "/**\n"
  " * Changes the vertex color of the nth point or vertex.  See set_vertex().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the vertex color of the nth point or vertex.  See set_vertex().\n"
  " */";
#else
static const char *Dtool_LineSegs_set_vertex_color_111_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LineSegs::LineSegs(LineSegs const &) = default
 * LineSegs::LineSegs(std::string const &name = "lines")
 */
static int Dtool_Init_LineSegs(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-LineSegs::LineSegs(std::string const &name)
      LineSegs *return_value = new LineSegs();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LineSegs, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LineSegs::LineSegs(LineSegs const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LineSegs", (char **)keyword_list, &param0)) {
          LineSegs const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LineSegs, (void **)&param0_this);
          if (param0_this != NULL) {
            LineSegs *return_value = new LineSegs(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LineSegs, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 LineSegs::LineSegs(std::string const &name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:LineSegs", (char **)keyword_list, &param0_str, &param0_len)) {
          LineSegs *return_value = new LineSegs(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LineSegs, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LineSegs::LineSegs(LineSegs const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LineSegs", (char **)keyword_list, &param0)) {
          LineSegs const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_LineSegs(param0, param0_this, param0_manage)) {
            LineSegs *return_value = new LineSegs(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LineSegs, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: LineSegs::LineSegs(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LineSegs() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LineSegs()\n"
      "LineSegs(const LineSegs param0)\n"
      "LineSegs(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LineSegs(PyObject *args, LineSegs const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LineSegs, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LineSegs::LineSegs(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      LineSegs *return_value = new LineSegs(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_LineSegs(PyObject *args, LineSegs *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LineSegs, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LineSegs::LineSegs(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      LineSegs *return_value = new LineSegs(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LineSegs_get_vertices(PyObject *self, PyObject *) {
  LineSegs *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LineSegs, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_vertices();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_LineSegs_get_vertex_106(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LineSegs_get_vertex_colors(PyObject *self, PyObject *) {
  LineSegs *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LineSegs, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_vertices();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_LineSegs_get_vertex_color_109(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_LineSegs(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LineSegs) {
    printf("LineSegs ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LineSegs *local_this = (LineSegs *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LineSegs) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LineSegs(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LineSegs) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (LineSegs*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MeshDrawer
 */
/**
 * Python function wrapper for:
 * inline void MeshDrawer::set_budget(int budget)
 */
static PyObject *Dtool_MeshDrawer_set_budget_114(PyObject *self, PyObject *arg) {
  MeshDrawer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer, (void **)&local_this, "MeshDrawer.set_budget")) {
    return NULL;
  }
  // 1-inline void MeshDrawer::set_budget(int budget)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_budget((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_budget(const MeshDrawer self, int budget)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer_set_budget_114_comment =
  "C++ Interface:\n"
  "set_budget(const MeshDrawer self, int budget)\n"
  "\n"
  "/**\n"
  " * Sets the total triangle budget of the drawer.  This will not be exceeded.\n"
  " * Don't set some thing too large because it will be slow\n"
  " */";
#else
static const char *Dtool_MeshDrawer_set_budget_114_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int MeshDrawer::get_budget(void)
 */
static PyObject *Dtool_MeshDrawer_get_budget_115(PyObject *self, PyObject *) {
  MeshDrawer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer, (void **)&local_this, "MeshDrawer.get_budget")) {
    return NULL;
  }
  // 1-inline int MeshDrawer::get_budget(void)
  int return_value = (*local_this).get_budget();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer_get_budget_115_comment =
  "C++ Interface:\n"
  "get_budget(const MeshDrawer self)\n"
  "\n"
  "/**\n"
  " * Gets the total triangle budget of the drawer\n"
  " */";
#else
static const char *Dtool_MeshDrawer_get_budget_115_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath MeshDrawer::get_root(void)
 */
static PyObject *Dtool_MeshDrawer_get_root_116(PyObject *self, PyObject *) {
  MeshDrawer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer, (void **)&local_this, "MeshDrawer.get_root")) {
    return NULL;
  }
  // 1-inline NodePath MeshDrawer::get_root(void)
  NodePath *return_value = new NodePath((*local_this).get_root());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer_get_root_116_comment =
  "C++ Interface:\n"
  "get_root(const MeshDrawer self)\n"
  "\n"
  "/**\n"
  " * Returns the root NodePath.  You should use this node to reparent mesh\n"
  " * drawer onto the scene might also want to disable depth draw or enable\n"
  " * transparency.\n"
  " */";
#else
static const char *Dtool_MeshDrawer_get_root_116_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MeshDrawer::begin(NodePath camera, NodePath render)
 */
static PyObject *Dtool_MeshDrawer_begin_117(PyObject *self, PyObject *args, PyObject *kwds) {
  MeshDrawer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer, (void **)&local_this, "MeshDrawer.begin")) {
    return NULL;
  }
  // 1-void MeshDrawer::begin(NodePath camera, NodePath render)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"camera", "render", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:begin", (char **)keyword_list, &param1, &param2)) {
    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "MeshDrawer.begin", true, true);
    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "MeshDrawer.begin", true, true);
    if (param1_this != NULL && param2_this != NULL) {
      (*local_this).begin(*param1_this, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "begin(const MeshDrawer self, NodePath camera, NodePath render)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer_begin_117_comment =
  "C++ Interface:\n"
  "begin(const MeshDrawer self, NodePath camera, NodePath render)\n"
  "\n"
  "/**\n"
  " * Pass the current camera node and the root node.  Passing the camera is\n"
  " * required to generate bill boards that face it.\n"
  " */";
#else
static const char *Dtool_MeshDrawer_begin_117_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MeshDrawer::tri(LVector3 const &v1, LVector4 const &c1, LVector2 const &uv1, LVector3 const &v2, LVector4 const &c2, LVector2 const &uv2, LVector3 const &v3, LVector4 const &c3, LVector2 const &uv3)
 */
static PyObject *Dtool_MeshDrawer_tri_118(PyObject *self, PyObject *args, PyObject *kwds) {
  MeshDrawer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer, (void **)&local_this, "MeshDrawer.tri")) {
    return NULL;
  }
  // 1-inline void MeshDrawer::tri(LVector3 const &v1, LVector4 const &c1, LVector2 const &uv1, LVector3 const &v2, LVector4 const &c2, LVector2 const &uv2, LVector3 const &v3, LVector4 const &c3, LVector2 const &uv3)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  PyObject *param4;
  PyObject *param5;
  PyObject *param6;
  PyObject *param7;
  PyObject *param8;
  PyObject *param9;
  static const char *keyword_list[] = {"v1", "c1", "uv1", "v2", "c2", "uv2", "v3", "c3", "uv3", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOOO:tri", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9)) {
    LVector3f param1_local;
    LVector3 const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "MeshDrawer.tri", "LVector3f");
    }
    LVector4f param2_local;
    LVector4 const *param2_this = Dtool_Coerce_LVector4f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "MeshDrawer.tri", "LVector4f");
    }
    LVector2f param3_local;
    LVector2 const *param3_this = Dtool_Coerce_LVector2f(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "MeshDrawer.tri", "LVector2f");
    }
    LVector3f param4_local;
    LVector3 const *param4_this = Dtool_Coerce_LVector3f(param4, param4_local);
    if (!(param4_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param4, 4, "MeshDrawer.tri", "LVector3f");
    }
    LVector4f param5_local;
    LVector4 const *param5_this = Dtool_Coerce_LVector4f(param5, param5_local);
    if (!(param5_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param5, 5, "MeshDrawer.tri", "LVector4f");
    }
    LVector2f param6_local;
    LVector2 const *param6_this = Dtool_Coerce_LVector2f(param6, param6_local);
    if (!(param6_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param6, 6, "MeshDrawer.tri", "LVector2f");
    }
    LVector3f param7_local;
    LVector3 const *param7_this = Dtool_Coerce_LVector3f(param7, param7_local);
    if (!(param7_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param7, 7, "MeshDrawer.tri", "LVector3f");
    }
    LVector4f param8_local;
    LVector4 const *param8_this = Dtool_Coerce_LVector4f(param8, param8_local);
    if (!(param8_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param8, 8, "MeshDrawer.tri", "LVector4f");
    }
    LVector2f param9_local;
    LVector2 const *param9_this = Dtool_Coerce_LVector2f(param9, param9_local);
    if (!(param9_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param9, 9, "MeshDrawer.tri", "LVector2f");
    }
    (*local_this).tri(*param1_this, *param2_this, *param3_this, *param4_this, *param5_this, *param6_this, *param7_this, *param8_this, *param9_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "tri(const MeshDrawer self, const LVector3f v1, const LVector4f c1, const LVector2f uv1, const LVector3f v2, const LVector4f c2, const LVector2f uv2, const LVector3f v3, const LVector4f c3, const LVector2f uv3)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer_tri_118_comment =
  "C++ Interface:\n"
  "tri(const MeshDrawer self, const LVector3f v1, const LVector4f c1, const LVector2f uv1, const LVector3f v2, const LVector4f c2, const LVector2f uv2, const LVector3f v3, const LVector4f c3, const LVector2f uv3)\n"
  "\n"
  "/**\n"
  " * Draws a triangle with the given parameters.\n"
  " */";
#else
static const char *Dtool_MeshDrawer_tri_118_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MeshDrawer::particle(LVector3 const &pos, LVector4 const &frame, PN_stdfloat size, LVector4 const &color, PN_stdfloat rotation)
 */
static PyObject *Dtool_MeshDrawer_particle_119(PyObject *self, PyObject *args, PyObject *kwds) {
  MeshDrawer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer, (void **)&local_this, "MeshDrawer.particle")) {
    return NULL;
  }
  // 1-void MeshDrawer::particle(LVector3 const &pos, LVector4 const &frame, PN_stdfloat size, LVector4 const &color, PN_stdfloat rotation)
  PyObject *param1;
  PyObject *param2;
  float param3;
  PyObject *param4;
  float param5;
  static const char *keyword_list[] = {"pos", "frame", "size", "color", "rotation", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOfOf:particle", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    LVector3f param1_local;
    LVector3 const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "MeshDrawer.particle", "LVector3f");
    }
    LVector4f param2_local;
    LVector4 const *param2_this = Dtool_Coerce_LVector4f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "MeshDrawer.particle", "LVector4f");
    }
    LVector4f param4_local;
    LVector4 const *param4_this = Dtool_Coerce_LVector4f(param4, param4_local);
    if (!(param4_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param4, 4, "MeshDrawer.particle", "LVector4f");
    }
    (*local_this).particle(*param1_this, *param2_this, (PN_stdfloat)param3, *param4_this, (PN_stdfloat)param5);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "particle(const MeshDrawer self, const LVector3f pos, const LVector4f frame, float size, const LVector4f color, float rotation)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer_particle_119_comment =
  "C++ Interface:\n"
  "particle(const MeshDrawer self, const LVector3f pos, const LVector4f frame, float size, const LVector4f color, float rotation)\n"
  "\n"
  "/**\n"
  " * Draws a particle that is sort of like a bill board but has an extra\n"
  " * rotation component.  Frame contains u,v,u-size,v-size quadruple.\n"
  " */";
#else
static const char *Dtool_MeshDrawer_particle_119_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MeshDrawer::blended_particle(LVector3 const &pos, LVector4 const &frame1, LVector4 const &frame2, PN_stdfloat blend, PN_stdfloat size, LVector4 const &color, PN_stdfloat rotation)
 */
static PyObject *Dtool_MeshDrawer_blended_particle_120(PyObject *self, PyObject *args, PyObject *kwds) {
  MeshDrawer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer, (void **)&local_this, "MeshDrawer.blended_particle")) {
    return NULL;
  }
  // 1-void MeshDrawer::blended_particle(LVector3 const &pos, LVector4 const &frame1, LVector4 const &frame2, PN_stdfloat blend, PN_stdfloat size, LVector4 const &color, PN_stdfloat rotation)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  float param4;
  float param5;
  PyObject *param6;
  float param7;
  static const char *keyword_list[] = {"pos", "frame1", "frame2", "blend", "size", "color", "rotation", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOffOf:blended_particle", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
    LVector3f param1_local;
    LVector3 const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "MeshDrawer.blended_particle", "LVector3f");
    }
    LVector4f param2_local;
    LVector4 const *param2_this = Dtool_Coerce_LVector4f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "MeshDrawer.blended_particle", "LVector4f");
    }
    LVector4f param3_local;
    LVector4 const *param3_this = Dtool_Coerce_LVector4f(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "MeshDrawer.blended_particle", "LVector4f");
    }
    LVector4f param6_local;
    LVector4 const *param6_this = Dtool_Coerce_LVector4f(param6, param6_local);
    if (!(param6_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param6, 6, "MeshDrawer.blended_particle", "LVector4f");
    }
    (*local_this).blended_particle(*param1_this, *param2_this, *param3_this, (PN_stdfloat)param4, (PN_stdfloat)param5, *param6_this, (PN_stdfloat)param7);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "blended_particle(const MeshDrawer self, const LVector3f pos, const LVector4f frame1, const LVector4f frame2, float blend, float size, const LVector4f color, float rotation)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer_blended_particle_120_comment =
  "C++ Interface:\n"
  "blended_particle(const MeshDrawer self, const LVector3f pos, const LVector4f frame1, const LVector4f frame2, float blend, float size, const LVector4f color, float rotation)\n"
  "\n"
  "/**\n"
  " * Works just like particle but accepts 2 frames and a blend (from 0 to 1)\n"
  " * component between them Frame contains u,v,u-size,v-size quadruple.\n"
  " */";
#else
static const char *Dtool_MeshDrawer_blended_particle_120_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MeshDrawer::billboard(LVector3 const &pos, LVector4 const &frame, PN_stdfloat size, LVector4 const &color)
 */
static PyObject *Dtool_MeshDrawer_billboard_121(PyObject *self, PyObject *args, PyObject *kwds) {
  MeshDrawer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer, (void **)&local_this, "MeshDrawer.billboard")) {
    return NULL;
  }
  // 1-void MeshDrawer::billboard(LVector3 const &pos, LVector4 const &frame, PN_stdfloat size, LVector4 const &color)
  PyObject *param1;
  PyObject *param2;
  float param3;
  PyObject *param4;
  static const char *keyword_list[] = {"pos", "frame", "size", "color", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOfO:billboard", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    LVector3f param1_local;
    LVector3 const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "MeshDrawer.billboard", "LVector3f");
    }
    LVector4f param2_local;
    LVector4 const *param2_this = Dtool_Coerce_LVector4f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "MeshDrawer.billboard", "LVector4f");
    }
    LVector4f param4_local;
    LVector4 const *param4_this = Dtool_Coerce_LVector4f(param4, param4_local);
    if (!(param4_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param4, 4, "MeshDrawer.billboard", "LVector4f");
    }
    (*local_this).billboard(*param1_this, *param2_this, (PN_stdfloat)param3, *param4_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "billboard(const MeshDrawer self, const LVector3f pos, const LVector4f frame, float size, const LVector4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer_billboard_121_comment =
  "C++ Interface:\n"
  "billboard(const MeshDrawer self, const LVector3f pos, const LVector4f frame, float size, const LVector4f color)\n"
  "\n"
  "/**\n"
  " * Draws a billboard - particle with no rotation.  Billboards always face the\n"
  " * camera.  Frame contains u,v,u-size,v-size quadruple.\n"
  " */";
#else
static const char *Dtool_MeshDrawer_billboard_121_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MeshDrawer::segment(LVector3 const &start, LVector3 const &stop, LVector4 const &frame, PN_stdfloat thickness, LVector4 const &color)
 */
static PyObject *Dtool_MeshDrawer_segment_122(PyObject *self, PyObject *args, PyObject *kwds) {
  MeshDrawer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer, (void **)&local_this, "MeshDrawer.segment")) {
    return NULL;
  }
  // 1-void MeshDrawer::segment(LVector3 const &start, LVector3 const &stop, LVector4 const &frame, PN_stdfloat thickness, LVector4 const &color)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  float param4;
  PyObject *param5;
  static const char *keyword_list[] = {"start", "stop", "frame", "thickness", "color", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOfO:segment", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    LVector3f param1_local;
    LVector3 const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "MeshDrawer.segment", "LVector3f");
    }
    LVector3f param2_local;
    LVector3 const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "MeshDrawer.segment", "LVector3f");
    }
    LVector4f param3_local;
    LVector4 const *param3_this = Dtool_Coerce_LVector4f(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "MeshDrawer.segment", "LVector4f");
    }
    LVector4f param5_local;
    LVector4 const *param5_this = Dtool_Coerce_LVector4f(param5, param5_local);
    if (!(param5_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param5, 5, "MeshDrawer.segment", "LVector4f");
    }
    (*local_this).segment(*param1_this, *param2_this, *param3_this, (PN_stdfloat)param4, *param5_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "segment(const MeshDrawer self, const LVector3f start, const LVector3f stop, const LVector4f frame, float thickness, const LVector4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer_segment_122_comment =
  "C++ Interface:\n"
  "segment(const MeshDrawer self, const LVector3f start, const LVector3f stop, const LVector4f frame, float thickness, const LVector4f color)\n"
  "\n"
  "/**\n"
  " * Draws a segment a line with a thickness.  That has billboarding effect.\n"
  " * Frame contains u,v,u-size,v-size quadruple.\n"
  " */";
#else
static const char *Dtool_MeshDrawer_segment_122_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MeshDrawer::cross_segment(LVector3 const &start, LVector3 const &stop, LVector4 const &frame, PN_stdfloat thickness, LVector4 const &color)
 */
static PyObject *Dtool_MeshDrawer_cross_segment_123(PyObject *self, PyObject *args, PyObject *kwds) {
  MeshDrawer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer, (void **)&local_this, "MeshDrawer.cross_segment")) {
    return NULL;
  }
  // 1-void MeshDrawer::cross_segment(LVector3 const &start, LVector3 const &stop, LVector4 const &frame, PN_stdfloat thickness, LVector4 const &color)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  float param4;
  PyObject *param5;
  static const char *keyword_list[] = {"start", "stop", "frame", "thickness", "color", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOfO:cross_segment", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    LVector3f param1_local;
    LVector3 const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "MeshDrawer.cross_segment", "LVector3f");
    }
    LVector3f param2_local;
    LVector3 const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "MeshDrawer.cross_segment", "LVector3f");
    }
    LVector4f param3_local;
    LVector4 const *param3_this = Dtool_Coerce_LVector4f(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "MeshDrawer.cross_segment", "LVector4f");
    }
    LVector4f param5_local;
    LVector4 const *param5_this = Dtool_Coerce_LVector4f(param5, param5_local);
    if (!(param5_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param5, 5, "MeshDrawer.cross_segment", "LVector4f");
    }
    (*local_this).cross_segment(*param1_this, *param2_this, *param3_this, (PN_stdfloat)param4, *param5_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "cross_segment(const MeshDrawer self, const LVector3f start, const LVector3f stop, const LVector4f frame, float thickness, const LVector4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer_cross_segment_123_comment =
  "C++ Interface:\n"
  "cross_segment(const MeshDrawer self, const LVector3f start, const LVector3f stop, const LVector4f frame, float thickness, const LVector4f color)\n"
  "\n"
  "/**\n"
  " * Draws a segment a line with a thickness.  This segment does not use the\n"
  " * bill boarding behavior and instead draws 2 planes in a cross.  Stars at\n"
  " * start and ends at stop.  Frame contains u,v,u-size,v-size quadruple.\n"
  " */";
#else
static const char *Dtool_MeshDrawer_cross_segment_123_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MeshDrawer::uneven_segment(LVector3 const &start, LVector3 const &stop, LVector4 const &frame, PN_stdfloat thickness_start, LVector4 const &color_start, PN_stdfloat thickness_stop, LVector4 const &color_stop)
 */
static PyObject *Dtool_MeshDrawer_uneven_segment_124(PyObject *self, PyObject *args, PyObject *kwds) {
  MeshDrawer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer, (void **)&local_this, "MeshDrawer.uneven_segment")) {
    return NULL;
  }
  // 1-void MeshDrawer::uneven_segment(LVector3 const &start, LVector3 const &stop, LVector4 const &frame, PN_stdfloat thickness_start, LVector4 const &color_start, PN_stdfloat thickness_stop, LVector4 const &color_stop)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  float param4;
  PyObject *param5;
  float param6;
  PyObject *param7;
  static const char *keyword_list[] = {"start", "stop", "frame", "thickness_start", "color_start", "thickness_stop", "color_stop", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOfOfO:uneven_segment", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
    LVector3f param1_local;
    LVector3 const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "MeshDrawer.uneven_segment", "LVector3f");
    }
    LVector3f param2_local;
    LVector3 const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "MeshDrawer.uneven_segment", "LVector3f");
    }
    LVector4f param3_local;
    LVector4 const *param3_this = Dtool_Coerce_LVector4f(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "MeshDrawer.uneven_segment", "LVector4f");
    }
    LVector4f param5_local;
    LVector4 const *param5_this = Dtool_Coerce_LVector4f(param5, param5_local);
    if (!(param5_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param5, 5, "MeshDrawer.uneven_segment", "LVector4f");
    }
    LVector4f param7_local;
    LVector4 const *param7_this = Dtool_Coerce_LVector4f(param7, param7_local);
    if (!(param7_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param7, 7, "MeshDrawer.uneven_segment", "LVector4f");
    }
    (*local_this).uneven_segment(*param1_this, *param2_this, *param3_this, (PN_stdfloat)param4, *param5_this, (PN_stdfloat)param6, *param7_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "uneven_segment(const MeshDrawer self, const LVector3f start, const LVector3f stop, const LVector4f frame, float thickness_start, const LVector4f color_start, float thickness_stop, const LVector4f color_stop)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer_uneven_segment_124_comment =
  "C++ Interface:\n"
  "uneven_segment(const MeshDrawer self, const LVector3f start, const LVector3f stop, const LVector4f frame, float thickness_start, const LVector4f color_start, float thickness_stop, const LVector4f color_stop)\n"
  "\n"
  "/**\n"
  " * Draws a segment a line with different thickness and color on both sides.\n"
  " * Stars at start and ends at stop.  Frame contains u,v,u-size,v-size\n"
  " * quadruple.\n"
  " */";
#else
static const char *Dtool_MeshDrawer_uneven_segment_124_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MeshDrawer::link_segment(LVector3 const &pos, LVector4 const &frame, PN_stdfloat thickness, LVector4 const &color)
 */
static PyObject *Dtool_MeshDrawer_link_segment_125(PyObject *self, PyObject *args, PyObject *kwds) {
  MeshDrawer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer, (void **)&local_this, "MeshDrawer.link_segment")) {
    return NULL;
  }
  // 1-void MeshDrawer::link_segment(LVector3 const &pos, LVector4 const &frame, PN_stdfloat thickness, LVector4 const &color)
  PyObject *param1;
  PyObject *param2;
  float param3;
  PyObject *param4;
  static const char *keyword_list[] = {"pos", "frame", "thickness", "color", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOfO:link_segment", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    LVector3f param1_local;
    LVector3 const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "MeshDrawer.link_segment", "LVector3f");
    }
    LVector4f param2_local;
    LVector4 const *param2_this = Dtool_Coerce_LVector4f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "MeshDrawer.link_segment", "LVector4f");
    }
    LVector4f param4_local;
    LVector4 const *param4_this = Dtool_Coerce_LVector4f(param4, param4_local);
    if (!(param4_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param4, 4, "MeshDrawer.link_segment", "LVector4f");
    }
    (*local_this).link_segment(*param1_this, *param2_this, (PN_stdfloat)param3, *param4_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "link_segment(const MeshDrawer self, const LVector3f pos, const LVector4f frame, float thickness, const LVector4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer_link_segment_125_comment =
  "C++ Interface:\n"
  "link_segment(const MeshDrawer self, const LVector3f pos, const LVector4f frame, float thickness, const LVector4f color)\n"
  "\n"
  "/**\n"
  " * Stars or continues linked segment.  Control position, frame, thickness and\n"
  " * color with parameters.  Frame contains u,v,u-size,v-size quadruple.\n"
  " */";
#else
static const char *Dtool_MeshDrawer_link_segment_125_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MeshDrawer::link_segment_end(LVector4 const &frame, LVector4 const &color)
 */
static PyObject *Dtool_MeshDrawer_link_segment_end_126(PyObject *self, PyObject *args, PyObject *kwds) {
  MeshDrawer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer, (void **)&local_this, "MeshDrawer.link_segment_end")) {
    return NULL;
  }
  // 1-void MeshDrawer::link_segment_end(LVector4 const &frame, LVector4 const &color)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "color", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:link_segment_end", (char **)keyword_list, &param1, &param2)) {
    LVector4f param1_local;
    LVector4 const *param1_this = Dtool_Coerce_LVector4f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "MeshDrawer.link_segment_end", "LVector4f");
    }
    LVector4f param2_local;
    LVector4 const *param2_this = Dtool_Coerce_LVector4f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "MeshDrawer.link_segment_end", "LVector4f");
    }
    (*local_this).link_segment_end(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "link_segment_end(const MeshDrawer self, const LVector4f frame, const LVector4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer_link_segment_end_126_comment =
  "C++ Interface:\n"
  "link_segment_end(const MeshDrawer self, const LVector4f frame, const LVector4f color)\n"
  "\n"
  "/**\n"
  " * Finish drawing linked segments, needs at least two calls to link_segment\n"
  " * before it can end the linked segment.  Frame contains u,v,u-size,v-size\n"
  " * quadruple.\n"
  " */";
#else
static const char *Dtool_MeshDrawer_link_segment_end_126_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MeshDrawer::explosion(LVector3 const &pos, LVector4 const &frame, PN_stdfloat size, LVector4 const &color, int seed, int number, PN_stdfloat distance)
 */
static PyObject *Dtool_MeshDrawer_explosion_127(PyObject *self, PyObject *args, PyObject *kwds) {
  MeshDrawer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer, (void **)&local_this, "MeshDrawer.explosion")) {
    return NULL;
  }
  // 1-void MeshDrawer::explosion(LVector3 const &pos, LVector4 const &frame, PN_stdfloat size, LVector4 const &color, int seed, int number, PN_stdfloat distance)
  PyObject *param1;
  PyObject *param2;
  float param3;
  PyObject *param4;
  int param5;
  int param6;
  float param7;
  static const char *keyword_list[] = {"pos", "frame", "size", "color", "seed", "number", "distance", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOfOiif:explosion", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
    LVector3f param1_local;
    LVector3 const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "MeshDrawer.explosion", "LVector3f");
    }
    LVector4f param2_local;
    LVector4 const *param2_this = Dtool_Coerce_LVector4f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "MeshDrawer.explosion", "LVector4f");
    }
    LVector4f param4_local;
    LVector4 const *param4_this = Dtool_Coerce_LVector4f(param4, param4_local);
    if (!(param4_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param4, 4, "MeshDrawer.explosion", "LVector4f");
    }
    (*local_this).explosion(*param1_this, *param2_this, (PN_stdfloat)param3, *param4_this, (int)param5, (int)param6, (PN_stdfloat)param7);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "explosion(const MeshDrawer self, const LVector3f pos, const LVector4f frame, float size, const LVector4f color, int seed, int number, float distance)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer_explosion_127_comment =
  "C++ Interface:\n"
  "explosion(const MeshDrawer self, const LVector3f pos, const LVector4f frame, float size, const LVector4f color, int seed, int number, float distance)\n"
  "\n"
  "/**\n"
  " * Draws number of particles in a sphere like emitter.  Frame contains\n"
  " * u,v,u-size,v-size quadruple.\n"
  " */";
#else
static const char *Dtool_MeshDrawer_explosion_127_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MeshDrawer::stream(LVector3 const &start, LVector3 const &stop, LVector4 const &frame, PN_stdfloat size, LVector4 const &color, int number, PN_stdfloat offset)
 */
static PyObject *Dtool_MeshDrawer_stream_128(PyObject *self, PyObject *args, PyObject *kwds) {
  MeshDrawer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer, (void **)&local_this, "MeshDrawer.stream")) {
    return NULL;
  }
  // 1-void MeshDrawer::stream(LVector3 const &start, LVector3 const &stop, LVector4 const &frame, PN_stdfloat size, LVector4 const &color, int number, PN_stdfloat offset)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  float param4;
  PyObject *param5;
  int param6;
  float param7;
  static const char *keyword_list[] = {"start", "stop", "frame", "size", "color", "number", "offset", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOfOif:stream", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
    LVector3f param1_local;
    LVector3 const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "MeshDrawer.stream", "LVector3f");
    }
    LVector3f param2_local;
    LVector3 const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "MeshDrawer.stream", "LVector3f");
    }
    LVector4f param3_local;
    LVector4 const *param3_this = Dtool_Coerce_LVector4f(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "MeshDrawer.stream", "LVector4f");
    }
    LVector4f param5_local;
    LVector4 const *param5_this = Dtool_Coerce_LVector4f(param5, param5_local);
    if (!(param5_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param5, 5, "MeshDrawer.stream", "LVector4f");
    }
    (*local_this).stream(*param1_this, *param2_this, *param3_this, (PN_stdfloat)param4, *param5_this, (int)param6, (PN_stdfloat)param7);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "stream(const MeshDrawer self, const LVector3f start, const LVector3f stop, const LVector4f frame, float size, const LVector4f color, int number, float offset)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer_stream_128_comment =
  "C++ Interface:\n"
  "stream(const MeshDrawer self, const LVector3f start, const LVector3f stop, const LVector4f frame, float size, const LVector4f color, int number, float offset)\n"
  "\n"
  "/**\n"
  " * Draws a number of particles in a big line with a shift dictated by the\n"
  " * offset.  Frame contains u,v,u-size,v-size quadruple.\n"
  " */";
#else
static const char *Dtool_MeshDrawer_stream_128_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MeshDrawer::geometry(NodePath node)
 */
static PyObject *Dtool_MeshDrawer_geometry_129(PyObject *self, PyObject *arg) {
  MeshDrawer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer, (void **)&local_this, "MeshDrawer.geometry")) {
    return NULL;
  }
  // 1-void MeshDrawer::geometry(NodePath node)
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "MeshDrawer.geometry", true, true);
  if (arg_this != NULL) {
    (*local_this).geometry(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "geometry(const MeshDrawer self, NodePath node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer_geometry_129_comment =
  "C++ Interface:\n"
  "geometry(const MeshDrawer self, NodePath node)\n"
  "\n"
  "/**\n"
  " * Draws the geometry that is inside this node path into the MeshDrawer\n"
  " * object.  This performs a similar functions as RigidBodyCombiner but for\n"
  " * very dynamic situations that share the same texture like physcal chunks of\n"
  " * explosions.  It can be a little slow\n"
  " */";
#else
static const char *Dtool_MeshDrawer_geometry_129_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MeshDrawer::end(void)
 */
static PyObject *Dtool_MeshDrawer_end_130(PyObject *self, PyObject *) {
  MeshDrawer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer, (void **)&local_this, "MeshDrawer.end")) {
    return NULL;
  }
  // 1-void MeshDrawer::end(void)
  (*local_this).end();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer_end_130_comment =
  "C++ Interface:\n"
  "end(const MeshDrawer self)\n"
  "\n"
  "/**\n"
  " * Finish the drawing and clearing off the remaining vertexes.\n"
  " */";
#else
static const char *Dtool_MeshDrawer_end_130_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MeshDrawer::get_class_type(void)
 */
static PyObject *Dtool_MeshDrawer_get_class_type_131(PyObject *, PyObject *) {
  // 1-static TypeHandle MeshDrawer::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(MeshDrawer::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer_get_class_type_131_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MeshDrawer_get_class_type_131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline MeshDrawer::MeshDrawer(void)
 * inline MeshDrawer::MeshDrawer(MeshDrawer const &) = default
 */
static int Dtool_Init_MeshDrawer(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline MeshDrawer::MeshDrawer(void)
      MeshDrawer *return_value = new MeshDrawer();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MeshDrawer, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline MeshDrawer::MeshDrawer(MeshDrawer const &) = default
      MeshDrawer const *arg_this = (MeshDrawer *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MeshDrawer, 0, "MeshDrawer.MeshDrawer", true, true);
      if (arg_this != NULL) {
        MeshDrawer *return_value = new MeshDrawer(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MeshDrawer, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "MeshDrawer() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MeshDrawer()\n"
      "MeshDrawer(const MeshDrawer param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_MeshDrawer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MeshDrawer) {
    printf("MeshDrawer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MeshDrawer *local_this = (MeshDrawer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MeshDrawer) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MeshDrawer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MeshDrawer) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MeshDrawer*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MeshDrawer2D
 */
/**
 * Python function wrapper for:
 * inline void MeshDrawer2D::set_budget(int budget)
 */
static PyObject *Dtool_MeshDrawer2D_set_budget_134(PyObject *self, PyObject *arg) {
  MeshDrawer2D *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer2D, (void **)&local_this, "MeshDrawer2D.set_budget")) {
    return NULL;
  }
  // 1-inline void MeshDrawer2D::set_budget(int budget)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_budget((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_budget(const MeshDrawer2D self, int budget)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer2D_set_budget_134_comment =
  "C++ Interface:\n"
  "set_budget(const MeshDrawer2D self, int budget)\n"
  "\n"
  "/**\n"
  " * Sets the total triangle budget of the drawer.\n"
  " */";
#else
static const char *Dtool_MeshDrawer2D_set_budget_134_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int MeshDrawer2D::get_budget(void)
 */
static PyObject *Dtool_MeshDrawer2D_get_budget_135(PyObject *self, PyObject *) {
  MeshDrawer2D *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer2D, (void **)&local_this, "MeshDrawer2D.get_budget")) {
    return NULL;
  }
  // 1-inline int MeshDrawer2D::get_budget(void)
  int return_value = (*local_this).get_budget();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer2D_get_budget_135_comment =
  "C++ Interface:\n"
  "get_budget(const MeshDrawer2D self)\n"
  "\n"
  "/**\n"
  " * Gets the total triangle budget of the drawer\n"
  " */";
#else
static const char *Dtool_MeshDrawer2D_get_budget_135_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath MeshDrawer2D::get_root(void)
 */
static PyObject *Dtool_MeshDrawer2D_get_root_136(PyObject *self, PyObject *) {
  MeshDrawer2D *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer2D, (void **)&local_this, "MeshDrawer2D.get_root")) {
    return NULL;
  }
  // 1-inline NodePath MeshDrawer2D::get_root(void)
  NodePath *return_value = new NodePath((*local_this).get_root());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer2D_get_root_136_comment =
  "C++ Interface:\n"
  "get_root(const MeshDrawer2D self)\n"
  "\n"
  "/**\n"
  " * Returns the root NodePath.\n"
  " */";
#else
static const char *Dtool_MeshDrawer2D_get_root_136_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MeshDrawer2D::quad_raw(LVector3 const &v1, LVector4 const &c1, LVector2 const &uv1, LVector3 const &v2, LVector4 const &c2, LVector2 const &uv2, LVector3 const &v3, LVector4 const &c3, LVector2 const &uv3, LVector3 const &v4, LVector4 const &c4, LVector2 const &uv4)
 */
static PyObject *Dtool_MeshDrawer2D_quad_raw_137(PyObject *self, PyObject *args, PyObject *kwds) {
  MeshDrawer2D *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer2D, (void **)&local_this, "MeshDrawer2D.quad_raw")) {
    return NULL;
  }
  // 1-inline void MeshDrawer2D::quad_raw(LVector3 const &v1, LVector4 const &c1, LVector2 const &uv1, LVector3 const &v2, LVector4 const &c2, LVector2 const &uv2, LVector3 const &v3, LVector4 const &c3, LVector2 const &uv3, LVector3 const &v4, LVector4 const &c4, LVector2 const &uv4)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  PyObject *param4;
  PyObject *param5;
  PyObject *param6;
  PyObject *param7;
  PyObject *param8;
  PyObject *param9;
  PyObject *param10;
  PyObject *param11;
  PyObject *param12;
  static const char *keyword_list[] = {"v1", "c1", "uv1", "v2", "c2", "uv2", "v3", "c3", "uv3", "v4", "c4", "uv4", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOOOOOO:quad_raw", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12)) {
    LVector3f param1_local;
    LVector3 const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "MeshDrawer2D.quad_raw", "LVector3f");
    }
    LVector4f param2_local;
    LVector4 const *param2_this = Dtool_Coerce_LVector4f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "MeshDrawer2D.quad_raw", "LVector4f");
    }
    LVector2f param3_local;
    LVector2 const *param3_this = Dtool_Coerce_LVector2f(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "MeshDrawer2D.quad_raw", "LVector2f");
    }
    LVector3f param4_local;
    LVector3 const *param4_this = Dtool_Coerce_LVector3f(param4, param4_local);
    if (!(param4_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param4, 4, "MeshDrawer2D.quad_raw", "LVector3f");
    }
    LVector4f param5_local;
    LVector4 const *param5_this = Dtool_Coerce_LVector4f(param5, param5_local);
    if (!(param5_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param5, 5, "MeshDrawer2D.quad_raw", "LVector4f");
    }
    LVector2f param6_local;
    LVector2 const *param6_this = Dtool_Coerce_LVector2f(param6, param6_local);
    if (!(param6_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param6, 6, "MeshDrawer2D.quad_raw", "LVector2f");
    }
    LVector3f param7_local;
    LVector3 const *param7_this = Dtool_Coerce_LVector3f(param7, param7_local);
    if (!(param7_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param7, 7, "MeshDrawer2D.quad_raw", "LVector3f");
    }
    LVector4f param8_local;
    LVector4 const *param8_this = Dtool_Coerce_LVector4f(param8, param8_local);
    if (!(param8_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param8, 8, "MeshDrawer2D.quad_raw", "LVector4f");
    }
    LVector2f param9_local;
    LVector2 const *param9_this = Dtool_Coerce_LVector2f(param9, param9_local);
    if (!(param9_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param9, 9, "MeshDrawer2D.quad_raw", "LVector2f");
    }
    LVector3f param10_local;
    LVector3 const *param10_this = Dtool_Coerce_LVector3f(param10, param10_local);
    if (!(param10_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param10, 10, "MeshDrawer2D.quad_raw", "LVector3f");
    }
    LVector4f param11_local;
    LVector4 const *param11_this = Dtool_Coerce_LVector4f(param11, param11_local);
    if (!(param11_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param11, 11, "MeshDrawer2D.quad_raw", "LVector4f");
    }
    LVector2f param12_local;
    LVector2 const *param12_this = Dtool_Coerce_LVector2f(param12, param12_local);
    if (!(param12_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param12, 12, "MeshDrawer2D.quad_raw", "LVector2f");
    }
    (*local_this).quad_raw(*param1_this, *param2_this, *param3_this, *param4_this, *param5_this, *param6_this, *param7_this, *param8_this, *param9_this, *param10_this, *param11_this, *param12_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "quad_raw(const MeshDrawer2D self, const LVector3f v1, const LVector4f c1, const LVector2f uv1, const LVector3f v2, const LVector4f c2, const LVector2f uv2, const LVector3f v3, const LVector4f c3, const LVector2f uv3, const LVector3f v4, const LVector4f c4, const LVector2f uv4)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer2D_quad_raw_137_comment =
  "C++ Interface:\n"
  "quad_raw(const MeshDrawer2D self, const LVector3f v1, const LVector4f c1, const LVector2f uv1, const LVector3f v2, const LVector4f c2, const LVector2f uv2, const LVector3f v3, const LVector4f c3, const LVector2f uv3, const LVector3f v4, const LVector4f c4, const LVector2f uv4)\n"
  "\n"
  "/**\n"
  " * Draws a 2d rectangle.  Ignores the cliping rectangle\n"
  " */";
#else
static const char *Dtool_MeshDrawer2D_quad_raw_137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MeshDrawer2D::rectangle_raw(PN_stdfloat x, PN_stdfloat y, PN_stdfloat w, PN_stdfloat h, PN_stdfloat u, PN_stdfloat v, PN_stdfloat us, PN_stdfloat vs, LVector4 const &color)
 */
static PyObject *Dtool_MeshDrawer2D_rectangle_raw_138(PyObject *self, PyObject *args, PyObject *kwds) {
  MeshDrawer2D *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer2D, (void **)&local_this, "MeshDrawer2D.rectangle_raw")) {
    return NULL;
  }
  // 1-inline void MeshDrawer2D::rectangle_raw(PN_stdfloat x, PN_stdfloat y, PN_stdfloat w, PN_stdfloat h, PN_stdfloat u, PN_stdfloat v, PN_stdfloat us, PN_stdfloat vs, LVector4 const &color)
  float param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  float param7;
  float param8;
  PyObject *param9;
  static const char *keyword_list[] = {"x", "y", "w", "h", "u", "v", "us", "vs", "color", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffffffO:rectangle_raw", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9)) {
    LVector4f param9_local;
    LVector4 const *param9_this = Dtool_Coerce_LVector4f(param9, param9_local);
    if (!(param9_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param9, 9, "MeshDrawer2D.rectangle_raw", "LVector4f");
    }
    (*local_this).rectangle_raw((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7, (PN_stdfloat)param8, *param9_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rectangle_raw(const MeshDrawer2D self, float x, float y, float w, float h, float u, float v, float us, float vs, const LVector4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer2D_rectangle_raw_138_comment =
  "C++ Interface:\n"
  "rectangle_raw(const MeshDrawer2D self, float x, float y, float w, float h, float u, float v, float us, float vs, const LVector4f color)\n";
#else
static const char *Dtool_MeshDrawer2D_rectangle_raw_138_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MeshDrawer2D::set_clip(PN_stdfloat x, PN_stdfloat y, PN_stdfloat w, PN_stdfloat h)
 */
static PyObject *Dtool_MeshDrawer2D_set_clip_139(PyObject *self, PyObject *args, PyObject *kwds) {
  MeshDrawer2D *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer2D, (void **)&local_this, "MeshDrawer2D.set_clip")) {
    return NULL;
  }
  // 1-inline void MeshDrawer2D::set_clip(PN_stdfloat x, PN_stdfloat y, PN_stdfloat w, PN_stdfloat h)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"x", "y", "w", "h", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_clip", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).set_clip((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clip(const MeshDrawer2D self, float x, float y, float w, float h)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer2D_set_clip_139_comment =
  "C++ Interface:\n"
  "set_clip(const MeshDrawer2D self, float x, float y, float w, float h)\n"
  "\n"
  "/**\n"
  " * Sets clipping rectangle\n"
  " */";
#else
static const char *Dtool_MeshDrawer2D_set_clip_139_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MeshDrawer2D::rectangle(PN_stdfloat x, PN_stdfloat y, PN_stdfloat w, PN_stdfloat h, PN_stdfloat u, PN_stdfloat v, PN_stdfloat us, PN_stdfloat vs, LVector4 const &color)
 */
static PyObject *Dtool_MeshDrawer2D_rectangle_140(PyObject *self, PyObject *args, PyObject *kwds) {
  MeshDrawer2D *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer2D, (void **)&local_this, "MeshDrawer2D.rectangle")) {
    return NULL;
  }
  // 1-inline void MeshDrawer2D::rectangle(PN_stdfloat x, PN_stdfloat y, PN_stdfloat w, PN_stdfloat h, PN_stdfloat u, PN_stdfloat v, PN_stdfloat us, PN_stdfloat vs, LVector4 const &color)
  float param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  float param7;
  float param8;
  PyObject *param9;
  static const char *keyword_list[] = {"x", "y", "w", "h", "u", "v", "us", "vs", "color", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffffffO:rectangle", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9)) {
    LVector4f param9_local;
    LVector4 const *param9_this = Dtool_Coerce_LVector4f(param9, param9_local);
    if (!(param9_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param9, 9, "MeshDrawer2D.rectangle", "LVector4f");
    }
    (*local_this).rectangle((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7, (PN_stdfloat)param8, *param9_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rectangle(const MeshDrawer2D self, float x, float y, float w, float h, float u, float v, float us, float vs, const LVector4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer2D_rectangle_140_comment =
  "C++ Interface:\n"
  "rectangle(const MeshDrawer2D self, float x, float y, float w, float h, float u, float v, float us, float vs, const LVector4f color)\n"
  "\n"
  "/**\n"
  " * Draws a 2d rectangle, that can be cliped\n"
  " */";
#else
static const char *Dtool_MeshDrawer2D_rectangle_140_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MeshDrawer2D::rectangle_border(PN_stdfloat x, PN_stdfloat y, PN_stdfloat w, PN_stdfloat h, PN_stdfloat r, PN_stdfloat t, PN_stdfloat l, PN_stdfloat b, PN_stdfloat tr, PN_stdfloat tt, PN_stdfloat tl, PN_stdfloat tb, PN_stdfloat u, PN_stdfloat v, PN_stdfloat us, PN_stdfloat vs, LVector4 const &color)
 */
static PyObject *Dtool_MeshDrawer2D_rectangle_border_141(PyObject *self, PyObject *args, PyObject *kwds) {
  MeshDrawer2D *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer2D, (void **)&local_this, "MeshDrawer2D.rectangle_border")) {
    return NULL;
  }
  // 1-void MeshDrawer2D::rectangle_border(PN_stdfloat x, PN_stdfloat y, PN_stdfloat w, PN_stdfloat h, PN_stdfloat r, PN_stdfloat t, PN_stdfloat l, PN_stdfloat b, PN_stdfloat tr, PN_stdfloat tt, PN_stdfloat tl, PN_stdfloat tb, PN_stdfloat u, PN_stdfloat v, PN_stdfloat us, PN_stdfloat vs, LVector4 const &color)
  float param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  float param7;
  float param8;
  float param9;
  float param10;
  float param11;
  float param12;
  float param13;
  float param14;
  float param15;
  float param16;
  PyObject *param17;
  static const char *keyword_list[] = {"x", "y", "w", "h", "r", "t", "l", "b", "tr", "tt", "tl", "tb", "u", "v", "us", "vs", "color", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffffffffffffffO:rectangle_border", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, &param16, &param17)) {
    LVector4f param17_local;
    LVector4 const *param17_this = Dtool_Coerce_LVector4f(param17, param17_local);
    if (!(param17_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param17, 17, "MeshDrawer2D.rectangle_border", "LVector4f");
    }
    (*local_this).rectangle_border((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7, (PN_stdfloat)param8, (PN_stdfloat)param9, (PN_stdfloat)param10, (PN_stdfloat)param11, (PN_stdfloat)param12, (PN_stdfloat)param13, (PN_stdfloat)param14, (PN_stdfloat)param15, (PN_stdfloat)param16, *param17_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rectangle_border(const MeshDrawer2D self, float x, float y, float w, float h, float r, float t, float l, float b, float tr, float tt, float tl, float tb, float u, float v, float us, float vs, const LVector4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer2D_rectangle_border_141_comment =
  "C++ Interface:\n"
  "rectangle_border(const MeshDrawer2D self, float x, float y, float w, float h, float r, float t, float l, float b, float tr, float tt, float tl, float tb, float u, float v, float us, float vs, const LVector4f color)\n"
  "\n"
  "/**\n"
  " * Draws a 2d rectangle, with borders and corders, taken from the surrounding\n"
  " * texture\n"
  " */";
#else
static const char *Dtool_MeshDrawer2D_rectangle_border_141_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MeshDrawer2D::rectangle_border_tiled(PN_stdfloat x, PN_stdfloat y, PN_stdfloat w, PN_stdfloat h, PN_stdfloat r, PN_stdfloat t, PN_stdfloat l, PN_stdfloat b, PN_stdfloat tr, PN_stdfloat tt, PN_stdfloat tl, PN_stdfloat tb, PN_stdfloat u, PN_stdfloat v, PN_stdfloat us, PN_stdfloat vs, LVector4 const &color)
 */
static PyObject *Dtool_MeshDrawer2D_rectangle_border_tiled_142(PyObject *self, PyObject *args, PyObject *kwds) {
  MeshDrawer2D *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer2D, (void **)&local_this, "MeshDrawer2D.rectangle_border_tiled")) {
    return NULL;
  }
  // 1-void MeshDrawer2D::rectangle_border_tiled(PN_stdfloat x, PN_stdfloat y, PN_stdfloat w, PN_stdfloat h, PN_stdfloat r, PN_stdfloat t, PN_stdfloat l, PN_stdfloat b, PN_stdfloat tr, PN_stdfloat tt, PN_stdfloat tl, PN_stdfloat tb, PN_stdfloat u, PN_stdfloat v, PN_stdfloat us, PN_stdfloat vs, LVector4 const &color)
  float param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  float param7;
  float param8;
  float param9;
  float param10;
  float param11;
  float param12;
  float param13;
  float param14;
  float param15;
  float param16;
  PyObject *param17;
  static const char *keyword_list[] = {"x", "y", "w", "h", "r", "t", "l", "b", "tr", "tt", "tl", "tb", "u", "v", "us", "vs", "color", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffffffffffffffO:rectangle_border_tiled", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, &param16, &param17)) {
    LVector4f param17_local;
    LVector4 const *param17_this = Dtool_Coerce_LVector4f(param17, param17_local);
    if (!(param17_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param17, 17, "MeshDrawer2D.rectangle_border_tiled", "LVector4f");
    }
    (*local_this).rectangle_border_tiled((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7, (PN_stdfloat)param8, (PN_stdfloat)param9, (PN_stdfloat)param10, (PN_stdfloat)param11, (PN_stdfloat)param12, (PN_stdfloat)param13, (PN_stdfloat)param14, (PN_stdfloat)param15, (PN_stdfloat)param16, *param17_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rectangle_border_tiled(const MeshDrawer2D self, float x, float y, float w, float h, float r, float t, float l, float b, float tr, float tt, float tl, float tb, float u, float v, float us, float vs, const LVector4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer2D_rectangle_border_tiled_142_comment =
  "C++ Interface:\n"
  "rectangle_border_tiled(const MeshDrawer2D self, float x, float y, float w, float h, float r, float t, float l, float b, float tr, float tt, float tl, float tb, float u, float v, float us, float vs, const LVector4f color)\n"
  "\n"
  "/**\n"
  " * Draws a 2d rectangle, with borders and corders, taken from the surrounding\n"
  " * texture\n"
  " */";
#else
static const char *Dtool_MeshDrawer2D_rectangle_border_tiled_142_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MeshDrawer2D::rectangle_tiled(PN_stdfloat x, PN_stdfloat y, PN_stdfloat w, PN_stdfloat h, PN_stdfloat u, PN_stdfloat v, PN_stdfloat us, PN_stdfloat vs, LVector4 const &color)
 */
static PyObject *Dtool_MeshDrawer2D_rectangle_tiled_143(PyObject *self, PyObject *args, PyObject *kwds) {
  MeshDrawer2D *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer2D, (void **)&local_this, "MeshDrawer2D.rectangle_tiled")) {
    return NULL;
  }
  // 1-void MeshDrawer2D::rectangle_tiled(PN_stdfloat x, PN_stdfloat y, PN_stdfloat w, PN_stdfloat h, PN_stdfloat u, PN_stdfloat v, PN_stdfloat us, PN_stdfloat vs, LVector4 const &color)
  float param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  float param7;
  float param8;
  PyObject *param9;
  static const char *keyword_list[] = {"x", "y", "w", "h", "u", "v", "us", "vs", "color", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffffffO:rectangle_tiled", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9)) {
    LVector4f param9_local;
    LVector4 const *param9_this = Dtool_Coerce_LVector4f(param9, param9_local);
    if (!(param9_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param9, 9, "MeshDrawer2D.rectangle_tiled", "LVector4f");
    }
    (*local_this).rectangle_tiled((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7, (PN_stdfloat)param8, *param9_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rectangle_tiled(const MeshDrawer2D self, float x, float y, float w, float h, float u, float v, float us, float vs, const LVector4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer2D_rectangle_tiled_143_comment =
  "C++ Interface:\n"
  "rectangle_tiled(const MeshDrawer2D self, float x, float y, float w, float h, float u, float v, float us, float vs, const LVector4f color)\n"
  "\n"
  "/**\n"
  " * Draws a tiled rectangle, size of tiles is in us and vs\n"
  " */";
#else
static const char *Dtool_MeshDrawer2D_rectangle_tiled_143_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MeshDrawer2D::begin(void)
 */
static PyObject *Dtool_MeshDrawer2D_begin_144(PyObject *self, PyObject *) {
  MeshDrawer2D *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer2D, (void **)&local_this, "MeshDrawer2D.begin")) {
    return NULL;
  }
  // 1-void MeshDrawer2D::begin(void)
  (*local_this).begin();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer2D_begin_144_comment =
  "C++ Interface:\n"
  "begin(const MeshDrawer2D self)\n"
  "\n"
  "/**\n"
  " * Opens up the geom for drawing, don't forget to call MeshDrawer2D::end()\n"
  " */";
#else
static const char *Dtool_MeshDrawer2D_begin_144_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MeshDrawer2D::end(void)
 */
static PyObject *Dtool_MeshDrawer2D_end_145(PyObject *self, PyObject *) {
  MeshDrawer2D *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshDrawer2D, (void **)&local_this, "MeshDrawer2D.end")) {
    return NULL;
  }
  // 1-void MeshDrawer2D::end(void)
  (*local_this).end();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer2D_end_145_comment =
  "C++ Interface:\n"
  "end(const MeshDrawer2D self)\n"
  "\n"
  "/**\n"
  " * Finish the drawing and clearing off the remaining vertexes.\n"
  " */";
#else
static const char *Dtool_MeshDrawer2D_end_145_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MeshDrawer2D::get_class_type(void)
 */
static PyObject *Dtool_MeshDrawer2D_get_class_type_146(PyObject *, PyObject *) {
  // 1-static TypeHandle MeshDrawer2D::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(MeshDrawer2D::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MeshDrawer2D_get_class_type_146_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MeshDrawer2D_get_class_type_146_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline MeshDrawer2D::MeshDrawer2D(void)
 * inline MeshDrawer2D::MeshDrawer2D(MeshDrawer2D const &) = default
 */
static int Dtool_Init_MeshDrawer2D(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline MeshDrawer2D::MeshDrawer2D(void)
      MeshDrawer2D *return_value = new MeshDrawer2D();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MeshDrawer2D, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline MeshDrawer2D::MeshDrawer2D(MeshDrawer2D const &) = default
      MeshDrawer2D const *arg_this = (MeshDrawer2D *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MeshDrawer2D, 0, "MeshDrawer2D.MeshDrawer2D", true, true);
      if (arg_this != NULL) {
        MeshDrawer2D *return_value = new MeshDrawer2D(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MeshDrawer2D, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "MeshDrawer2D() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MeshDrawer2D()\n"
      "MeshDrawer2D(const MeshDrawer2D param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_MeshDrawer2D(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MeshDrawer2D) {
    printf("MeshDrawer2D ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MeshDrawer2D *local_this = (MeshDrawer2D *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MeshDrawer2D) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MeshDrawer2D(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MeshDrawer2D) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MeshDrawer2D*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MovieTexture
 */
/**
 * Python function wrapper for:
 * inline double MovieTexture::get_video_length(void) const
 */
static PyObject *Dtool_MovieTexture_get_video_length_150(PyObject *self, PyObject *) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovieTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double MovieTexture::get_video_length(void) const
  double return_value = (*(const MovieTexture*)local_this).get_video_length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_get_video_length_150_comment =
  "C++ Interface:\n"
  "get_video_length(MovieTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the length of the video.\n"
  " */";
#else
static const char *Dtool_MovieTexture_get_video_length_150_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int MovieTexture::get_video_width(void) const
 */
static PyObject *Dtool_MovieTexture_get_video_width_151(PyObject *self, PyObject *) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovieTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int MovieTexture::get_video_width(void) const
  int return_value = (*(const MovieTexture*)local_this).get_video_width();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_get_video_width_151_comment =
  "C++ Interface:\n"
  "get_video_width(MovieTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the width in texels of the source video stream.  This is not\n"
  " * necessarily the width of the actual texture, since the texture may have\n"
  " * been expanded to raise it to a power of 2.\n"
  " */";
#else
static const char *Dtool_MovieTexture_get_video_width_151_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int MovieTexture::get_video_height(void) const
 */
static PyObject *Dtool_MovieTexture_get_video_height_152(PyObject *self, PyObject *) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovieTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int MovieTexture::get_video_height(void) const
  int return_value = (*(const MovieTexture*)local_this).get_video_height();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_get_video_height_152_comment =
  "C++ Interface:\n"
  "get_video_height(MovieTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the height in texels of the source video stream.  This is not\n"
  " * necessarily the height of the actual texture, since the texture may have\n"
  " * been expanded to raise it to a power of 2.\n"
  " */";
#else
static const char *Dtool_MovieTexture_get_video_height_152_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline MovieVideoCursor *MovieTexture::get_color_cursor(int page)
 */
static PyObject *Dtool_MovieTexture_get_color_cursor_153(PyObject *self, PyObject *arg) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieTexture, (void **)&local_this, "MovieTexture.get_color_cursor")) {
    return NULL;
  }
  // 1-inline MovieVideoCursor *MovieTexture::get_color_cursor(int page)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    MovieVideoCursor *return_value = (*local_this).get_color_cursor((int)arg_val);
    if (return_value != (MovieVideoCursor *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (MovieVideoCursor *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_MovieVideoCursor, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_color_cursor(const MovieTexture self, int page)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_get_color_cursor_153_comment =
  "C++ Interface:\n"
  "get_color_cursor(const MovieTexture self, int page)\n"
  "\n"
  "/**\n"
  " * Returns the MovieVideoCursor that is feeding the color channels for the\n"
  " * indicated page, where 0 <= page < get_num_pages().\n"
  " */";
#else
static const char *Dtool_MovieTexture_get_color_cursor_153_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline MovieVideoCursor *MovieTexture::get_alpha_cursor(int page)
 */
static PyObject *Dtool_MovieTexture_get_alpha_cursor_154(PyObject *self, PyObject *arg) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieTexture, (void **)&local_this, "MovieTexture.get_alpha_cursor")) {
    return NULL;
  }
  // 1-inline MovieVideoCursor *MovieTexture::get_alpha_cursor(int page)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    MovieVideoCursor *return_value = (*local_this).get_alpha_cursor((int)arg_val);
    if (return_value != (MovieVideoCursor *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (MovieVideoCursor *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_MovieVideoCursor, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_alpha_cursor(const MovieTexture self, int page)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_get_alpha_cursor_154_comment =
  "C++ Interface:\n"
  "get_alpha_cursor(const MovieTexture self, int page)\n"
  "\n"
  "/**\n"
  " * Returns the MovieVideoCursor that is feeding the alpha channel for the\n"
  " * indicated page, where 0 <= page < get_num_pages().\n"
  " */";
#else
static const char *Dtool_MovieTexture_get_alpha_cursor_154_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MovieTexture::restart(void)
 */
static PyObject *Dtool_MovieTexture_restart_155(PyObject *self, PyObject *) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieTexture, (void **)&local_this, "MovieTexture.restart")) {
    return NULL;
  }
  // 1-void MovieTexture::restart(void)
  (*local_this).restart();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_restart_155_comment =
  "C++ Interface:\n"
  "restart(const MovieTexture self)\n"
  "\n"
  "/**\n"
  " * Start playing the movie from where it was last paused.  Has no effect if\n"
  " * the movie is not paused, or if the movie's cursor is already at the end.\n"
  " */";
#else
static const char *Dtool_MovieTexture_restart_155_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MovieTexture::stop(void)
 */
static PyObject *Dtool_MovieTexture_stop_156(PyObject *self, PyObject *) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieTexture, (void **)&local_this, "MovieTexture.stop")) {
    return NULL;
  }
  // 1-void MovieTexture::stop(void)
  (*local_this).stop();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_stop_156_comment =
  "C++ Interface:\n"
  "stop(const MovieTexture self)\n"
  "\n"
  "/**\n"
  " * Stops a currently playing or looping movie right where it is.  The movie's\n"
  " * cursor remains frozen at the point where it was stopped.\n"
  " */";
#else
static const char *Dtool_MovieTexture_stop_156_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MovieTexture::play(void)
 */
static PyObject *Dtool_MovieTexture_play_157(PyObject *self, PyObject *) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieTexture, (void **)&local_this, "MovieTexture.play")) {
    return NULL;
  }
  // 1-void MovieTexture::play(void)
  (*local_this).play();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_play_157_comment =
  "C++ Interface:\n"
  "play(const MovieTexture self)\n"
  "\n"
  "/**\n"
  " * Plays the movie from the beginning.\n"
  " */";
#else
static const char *Dtool_MovieTexture_play_157_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MovieTexture::set_time(double t)
 */
static PyObject *Dtool_MovieTexture_set_time_158(PyObject *self, PyObject *arg) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieTexture, (void **)&local_this, "MovieTexture.set_time")) {
    return NULL;
  }
  // 1-void MovieTexture::set_time(double t)
  if (PyNumber_Check(arg)) {
    (*local_this).set_time(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_time(const MovieTexture self, double t)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_set_time_158_comment =
  "C++ Interface:\n"
  "set_time(const MovieTexture self, double t)\n"
  "\n"
  "/**\n"
  " * Sets the movie's cursor.\n"
  " */";
#else
static const char *Dtool_MovieTexture_set_time_158_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double MovieTexture::get_time(void) const
 */
static PyObject *Dtool_MovieTexture_get_time_159(PyObject *self, PyObject *) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovieTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-double MovieTexture::get_time(void) const
  double return_value = (*(const MovieTexture*)local_this).get_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_get_time_159_comment =
  "C++ Interface:\n"
  "get_time(MovieTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the current value of the movie's cursor.  If the movie's loop count\n"
  " * is greater than one, then its length is effectively multiplied for the\n"
  " * purposes of this function.  In other words, the return value will be in the\n"
  " * range 0.0 to (length * loopcount).\n"
  " */";
#else
static const char *Dtool_MovieTexture_get_time_159_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MovieTexture::set_loop(bool enable)
 */
static PyObject *Dtool_MovieTexture_set_loop_160(PyObject *self, PyObject *arg) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieTexture, (void **)&local_this, "MovieTexture.set_loop")) {
    return NULL;
  }
  // 1-void MovieTexture::set_loop(bool enable)
  (*local_this).set_loop((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_loop(const MovieTexture self, bool enable)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_set_loop_160_comment =
  "C++ Interface:\n"
  "set_loop(const MovieTexture self, bool enable)\n"
  "\n"
  "/**\n"
  " * If true, sets the movie's loop count to 1 billion.  If false, sets the\n"
  " * movie's loop count to one.\n"
  " */";
#else
static const char *Dtool_MovieTexture_set_loop_160_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool MovieTexture::get_loop(void) const
 */
static PyObject *Dtool_MovieTexture_get_loop_161(PyObject *self, PyObject *) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovieTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool MovieTexture::get_loop(void) const
  bool return_value = (*(const MovieTexture*)local_this).get_loop();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_get_loop_161_comment =
  "C++ Interface:\n"
  "get_loop(MovieTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if the movie's loop count is not equal to one.\n"
  " */";
#else
static const char *Dtool_MovieTexture_get_loop_161_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MovieTexture::set_loop_count(int count)
 */
static PyObject *Dtool_MovieTexture_set_loop_count_162(PyObject *self, PyObject *arg) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieTexture, (void **)&local_this, "MovieTexture.set_loop_count")) {
    return NULL;
  }
  // 1-void MovieTexture::set_loop_count(int count)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_loop_count((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_loop_count(const MovieTexture self, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_set_loop_count_162_comment =
  "C++ Interface:\n"
  "set_loop_count(const MovieTexture self, int count)\n"
  "\n"
  "/**\n"
  " * Sets the movie's loop count to the desired value.\n"
  " */";
#else
static const char *Dtool_MovieTexture_set_loop_count_162_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int MovieTexture::get_loop_count(void) const
 */
static PyObject *Dtool_MovieTexture_get_loop_count_163(PyObject *self, PyObject *) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovieTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-int MovieTexture::get_loop_count(void) const
  int return_value = (*(const MovieTexture*)local_this).get_loop_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_get_loop_count_163_comment =
  "C++ Interface:\n"
  "get_loop_count(MovieTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the movie's loop count.\n"
  " */";
#else
static const char *Dtool_MovieTexture_get_loop_count_163_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MovieTexture::set_play_rate(double play_rate)
 */
static PyObject *Dtool_MovieTexture_set_play_rate_164(PyObject *self, PyObject *arg) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieTexture, (void **)&local_this, "MovieTexture.set_play_rate")) {
    return NULL;
  }
  // 1-void MovieTexture::set_play_rate(double play_rate)
  if (PyNumber_Check(arg)) {
    (*local_this).set_play_rate(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_play_rate(const MovieTexture self, double play_rate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_set_play_rate_164_comment =
  "C++ Interface:\n"
  "set_play_rate(const MovieTexture self, double play_rate)\n"
  "\n"
  "/**\n"
  " * Sets the movie's play-rate.  This is the speed at which the movie's cursor\n"
  " * advances.  The default is to advance 1.0 movie-seconds per real-time\n"
  " * second.\n"
  " */";
#else
static const char *Dtool_MovieTexture_set_play_rate_164_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double MovieTexture::get_play_rate(void) const
 */
static PyObject *Dtool_MovieTexture_get_play_rate_165(PyObject *self, PyObject *) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovieTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-double MovieTexture::get_play_rate(void) const
  double return_value = (*(const MovieTexture*)local_this).get_play_rate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_get_play_rate_165_comment =
  "C++ Interface:\n"
  "get_play_rate(MovieTexture self)\n"
  "\n"
  "/**\n"
  " * Gets the movie's play-rate.\n"
  " */";
#else
static const char *Dtool_MovieTexture_get_play_rate_165_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool MovieTexture::is_playing(void) const
 */
static PyObject *Dtool_MovieTexture_is_playing_166(PyObject *self, PyObject *) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovieTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool MovieTexture::is_playing(void) const
  bool return_value = (*(const MovieTexture*)local_this).is_playing();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_is_playing_166_comment =
  "C++ Interface:\n"
  "is_playing(MovieTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if the movie's cursor is advancing.\n"
  " */";
#else
static const char *Dtool_MovieTexture_is_playing_166_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MovieTexture::synchronize_to(AudioSound *sound)
 */
static PyObject *Dtool_MovieTexture_synchronize_to_167(PyObject *self, PyObject *arg) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieTexture, (void **)&local_this, "MovieTexture.synchronize_to")) {
    return NULL;
  }
  // 1-void MovieTexture::synchronize_to(AudioSound *sound)
  AudioSound *arg_this = (AudioSound *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AudioSound, 1, "MovieTexture.synchronize_to", false, true);
  if (arg_this != NULL) {
    (*local_this).synchronize_to(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "synchronize_to(const MovieTexture self, AudioSound sound)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_synchronize_to_167_comment =
  "C++ Interface:\n"
  "synchronize_to(const MovieTexture self, AudioSound sound)\n"
  "\n"
  "/**\n"
  " * Synchronize this texture to a sound.  Typically, you would load the texture\n"
  " * and the sound from the same AVI file.\n"
  " */";
#else
static const char *Dtool_MovieTexture_synchronize_to_167_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MovieTexture::unsynchronize(void)
 */
static PyObject *Dtool_MovieTexture_unsynchronize_168(PyObject *self, PyObject *) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieTexture, (void **)&local_this, "MovieTexture.unsynchronize")) {
    return NULL;
  }
  // 1-void MovieTexture::unsynchronize(void)
  (*local_this).unsynchronize();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_unsynchronize_168_comment =
  "C++ Interface:\n"
  "unsynchronize(const MovieTexture self)\n"
  "\n"
  "/**\n"
  " * Stop synchronizing with a sound.\n"
  " */";
#else
static const char *Dtool_MovieTexture_unsynchronize_168_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MovieTexture::get_class_type(void)
 */
static PyObject *Dtool_MovieTexture_get_class_type_180(PyObject *, PyObject *) {
  // 1-static TypeHandle MovieTexture::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(MovieTexture::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovieTexture_get_class_type_180_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MovieTexture_get_class_type_180_comment = NULL;
#endif

static PyObject *Dtool_MovieTexture_video_length_Getter(PyObject *self, void *) {
  const MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovieTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double MovieTexture::get_video_length(void) const
  double return_value = (*(const MovieTexture*)local_this).get_video_length();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_MovieTexture_video_width_Getter(PyObject *self, void *) {
  const MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovieTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int MovieTexture::get_video_width(void) const
  int return_value = (*(const MovieTexture*)local_this).get_video_width();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_MovieTexture_video_height_Getter(PyObject *self, void *) {
  const MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovieTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int MovieTexture::get_video_height(void) const
  int return_value = (*(const MovieTexture*)local_this).get_video_height();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_MovieTexture_time_Getter(PyObject *self, void *) {
  const MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovieTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-double MovieTexture::get_time(void) const
  double return_value = (*(const MovieTexture*)local_this).get_time();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_MovieTexture_time_Setter(PyObject *self, PyObject *arg, void *) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieTexture, (void **)&local_this, "MovieTexture.time")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete time attribute");
    return -1;
  }
  // 1-void MovieTexture::set_time(double t)
  if (PyNumber_Check(arg)) {
    (*local_this).set_time(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_time(const MovieTexture self, double t)\n");
  }
  return -1;
}

static PyObject *Dtool_MovieTexture_loop_Getter(PyObject *self, void *) {
  const MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovieTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-bool MovieTexture::get_loop(void) const
  bool return_value = (*(const MovieTexture*)local_this).get_loop();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_MovieTexture_loop_Setter(PyObject *self, PyObject *arg, void *) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieTexture, (void **)&local_this, "MovieTexture.loop")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete loop attribute");
    return -1;
  }
  // 1-void MovieTexture::set_loop(bool enable)
  (*local_this).set_loop((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_loop(const MovieTexture self, bool enable)\n");
  }
  return -1;
}

static PyObject *Dtool_MovieTexture_loop_count_Getter(PyObject *self, void *) {
  const MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovieTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-int MovieTexture::get_loop_count(void) const
  int return_value = (*(const MovieTexture*)local_this).get_loop_count();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_MovieTexture_loop_count_Setter(PyObject *self, PyObject *arg, void *) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieTexture, (void **)&local_this, "MovieTexture.loop_count")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete loop_count attribute");
    return -1;
  }
  // 1-void MovieTexture::set_loop_count(int count)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_loop_count((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_loop_count(const MovieTexture self, int count)\n");
  }
  return -1;
}

static PyObject *Dtool_MovieTexture_play_rate_Getter(PyObject *self, void *) {
  const MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovieTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-double MovieTexture::get_play_rate(void) const
  double return_value = (*(const MovieTexture*)local_this).get_play_rate();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_MovieTexture_play_rate_Setter(PyObject *self, PyObject *arg, void *) {
  MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MovieTexture, (void **)&local_this, "MovieTexture.play_rate")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete play_rate attribute");
    return -1;
  }
  // 1-void MovieTexture::set_play_rate(double play_rate)
  if (PyNumber_Check(arg)) {
    (*local_this).set_play_rate(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_play_rate(const MovieTexture self, double play_rate)\n");
  }
  return -1;
}

static PyObject *Dtool_MovieTexture_playing_Getter(PyObject *self, void *) {
  const MovieTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovieTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-bool MovieTexture::is_playing(void) const
  bool return_value = (*(const MovieTexture*)local_this).is_playing();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * MovieTexture::MovieTexture(MovieVideo *video)
 * MovieTexture::MovieTexture(std::string const &name)
 */
static int Dtool_Init_MovieTexture(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "MovieTexture() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 MovieTexture::MovieTexture(MovieVideo *video)
    PyObject *param0;
    static const char *keyword_list[] = {"video", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:MovieTexture", (char **)keyword_list, &param0)) {
      MovieVideo *param0_this = (MovieVideo *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_MovieVideo, 0, "MovieTexture.MovieTexture", false, false);
      if (param0_this != NULL) {
        MovieTexture *return_value = new MovieTexture(param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MovieTexture, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 MovieTexture::MovieTexture(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:MovieTexture", (char **)keyword_list, &param0_str, &param0_len)) {
      MovieTexture *return_value = new MovieTexture(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MovieTexture, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 MovieTexture::MovieTexture(MovieVideo *video)
    PyObject *param0;
    static const char *keyword_list[] = {"video", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:MovieTexture", (char **)keyword_list, &param0)) {
      PT(MovieVideo) param0_this;
      if (Dtool_Coerce_MovieVideo(param0, param0_this)) {
        MovieTexture *return_value = new MovieTexture(MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MovieTexture, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: MovieTexture::MovieTexture(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MovieTexture(MovieVideo video)\n"
      "MovieTexture(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_MovieTexture(PyObject *args, CPT(MovieTexture) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_MovieTexture, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 MovieTexture::MovieTexture(MovieVideo *video)
      MovieVideo *arg_this = (MovieVideo *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MovieVideo, 0, "MovieTexture.MovieTexture", false, false);
      if (arg_this != NULL) {
        MovieTexture *return_value = new MovieTexture(arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
    }

    {
      // -2 MovieTexture::MovieTexture(std::string const &name)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        MovieTexture *return_value = new MovieTexture(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }

  }
  return false;
}

bool Dtool_Coerce_MovieTexture(PyObject *args, PT(MovieTexture) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_MovieTexture, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 MovieTexture::MovieTexture(MovieVideo *video)
      MovieVideo *arg_this = (MovieVideo *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MovieVideo, 0, "MovieTexture.MovieTexture", false, false);
      if (arg_this != NULL) {
        MovieTexture *return_value = new MovieTexture(arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
    }

    {
      // -2 MovieTexture::MovieTexture(std::string const &name)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        MovieTexture *return_value = new MovieTexture(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }

  }
  return false;
}

static void *Dtool_UpcastInterface_MovieTexture(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MovieTexture) {
    printf("MovieTexture ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MovieTexture *local_this = (MovieTexture *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MovieTexture) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_Texture) {
    return (Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(Texture *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MovieTexture(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MovieTexture) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MovieTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MovieTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_Texture) {
    Texture* other_this = (Texture*)from_this;
    return (MovieTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MovieTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MovieTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MovieTexture*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MultitexReducer
 */
/**
 * Python function wrapper for:
 * void MultitexReducer::clear(void)
 */
static PyObject *Dtool_MultitexReducer_clear_184(PyObject *self, PyObject *) {
  MultitexReducer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MultitexReducer, (void **)&local_this, "MultitexReducer.clear")) {
    return NULL;
  }
  // 1-void MultitexReducer::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MultitexReducer_clear_184_comment =
  "C++ Interface:\n"
  "clear(const MultitexReducer self)\n";
#else
static const char *Dtool_MultitexReducer_clear_184_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MultitexReducer::scan(NodePath const &node)
 * inline void MultitexReducer::scan(NodePath const &node, NodePath const &state_from)
 * void MultitexReducer::scan(PandaNode *node, RenderState const *state, TransformState const *transform)
 */
static PyObject *Dtool_MultitexReducer_scan_185(PyObject *self, PyObject *args, PyObject *kwds) {
  MultitexReducer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MultitexReducer, (void **)&local_this, "MultitexReducer.scan")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "node");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'node' (pos 1) not found");
      }
      // 1-inline void MultitexReducer::scan(NodePath const &node)
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "MultitexReducer.scan", true, true);
      if (arg_this != NULL) {
        (*local_this).scan(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void MultitexReducer::scan(NodePath const &node, NodePath const &state_from)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"node", "state_from", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:scan", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "MultitexReducer.scan", true, true);
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "MultitexReducer.scan", true, true);
        if (param1_this != NULL && param2_this != NULL) {
          (*local_this).scan(*param1_this, *param2_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 3:
    {
      // 1-void MultitexReducer::scan(PandaNode *node, RenderState const *state, TransformState const *transform)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"node", "state", "transform", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:scan", (char **)keyword_list, &param1, &param2, &param3)) {
        PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "MultitexReducer.scan", false, true);
        CPT(RenderState) param2_this;
        if (!Dtool_ConstCoerce_RenderState(param2, param2_this)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "MultitexReducer.scan", "RenderState");
        }
        TransformState const *param3_this = (TransformState *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_TransformState, 3, "MultitexReducer.scan", true, true);
        if (param1_this != NULL && param3_this != NULL) {
          (*local_this).scan(param1_this, MOVE(param2_this), param3_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "scan() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "scan(const MultitexReducer self, const NodePath node)\n"
      "scan(const MultitexReducer self, const NodePath node, const NodePath state_from)\n"
      "scan(const MultitexReducer self, PandaNode node, const RenderState state, const TransformState transform)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MultitexReducer_scan_185_comment =
  "C++ Interface:\n"
  "scan(const MultitexReducer self, const NodePath node)\n"
  "scan(const MultitexReducer self, const NodePath node, const NodePath state_from)\n"
  "scan(const MultitexReducer self, PandaNode node, const RenderState state, const TransformState transform)\n"
  "\n"
  "/**\n"
  " * Starts scanning the hierarchy beginning at the indicated node.  Any\n"
  " * GeomNodes discovered in the hierarchy with multitexture will be added to\n"
  " * internal structures in the MultitexReducer so that a future call to\n"
  " * flatten() will operate on all of these at once.\n"
  " *\n"
  " * This version of this method does not accumulate state from the parents of\n"
  " * the indicated node; thus, only multitexture effects that have been applied\n"
  " * at node and below will be considered.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Starts scanning the hierarchy beginning at the indicated node.  Any\n"
  " * GeomNodes discovered in the hierarchy with multitexture will be added to\n"
  " * internal structures in the MultitexReducer so that a future call to\n"
  " * flatten() will operate on all of these at once.\n"
  " *\n"
  " * The second parameter represents the NodePath from which to accumulate the\n"
  " * state that is considered for the multitexture.  Pass an empty NodePath to\n"
  " * accumulate all the state from the root of the graph, or you may specify\n"
  " * some other node here in order to not consider nodes above that as\n"
  " * contributing to the state to be flattened.  This is particularly useful if\n"
  " * you have some texture stage which is applied globally to a scene (for\n"
  " * instance, a caustics effect), which you don't want to be considered for\n"
  " * flattening by the MultitexReducer.\n"
  " */";
#else
static const char *Dtool_MultitexReducer_scan_185_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MultitexReducer::set_target(TextureStage *stage)
 */
static PyObject *Dtool_MultitexReducer_set_target_186(PyObject *self, PyObject *arg) {
  MultitexReducer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MultitexReducer, (void **)&local_this, "MultitexReducer.set_target")) {
    return NULL;
  }
  // 1-void MultitexReducer::set_target(TextureStage *stage)
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "MultitexReducer.set_target", false, true);
  if (arg_this != NULL) {
    (*local_this).set_target(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_target(const MultitexReducer self, TextureStage stage)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MultitexReducer_set_target_186_comment =
  "C++ Interface:\n"
  "set_target(const MultitexReducer self, TextureStage stage)\n";
#else
static const char *Dtool_MultitexReducer_set_target_186_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MultitexReducer::set_use_geom(bool use_geom)
 */
static PyObject *Dtool_MultitexReducer_set_use_geom_187(PyObject *self, PyObject *arg) {
  MultitexReducer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MultitexReducer, (void **)&local_this, "MultitexReducer.set_use_geom")) {
    return NULL;
  }
  // 1-void MultitexReducer::set_use_geom(bool use_geom)
  (*local_this).set_use_geom((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_use_geom(const MultitexReducer self, bool use_geom)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MultitexReducer_set_use_geom_187_comment =
  "C++ Interface:\n"
  "set_use_geom(const MultitexReducer self, bool use_geom)\n";
#else
static const char *Dtool_MultitexReducer_set_use_geom_187_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MultitexReducer::set_allow_tex_mat(bool allow_tex_mat)
 */
static PyObject *Dtool_MultitexReducer_set_allow_tex_mat_188(PyObject *self, PyObject *arg) {
  MultitexReducer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MultitexReducer, (void **)&local_this, "MultitexReducer.set_allow_tex_mat")) {
    return NULL;
  }
  // 1-void MultitexReducer::set_allow_tex_mat(bool allow_tex_mat)
  (*local_this).set_allow_tex_mat((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_allow_tex_mat(const MultitexReducer self, bool allow_tex_mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MultitexReducer_set_allow_tex_mat_188_comment =
  "C++ Interface:\n"
  "set_allow_tex_mat(const MultitexReducer self, bool allow_tex_mat)\n";
#else
static const char *Dtool_MultitexReducer_set_allow_tex_mat_188_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MultitexReducer::flatten(GraphicsOutput *window)
 */
static PyObject *Dtool_MultitexReducer_flatten_189(PyObject *self, PyObject *arg) {
  MultitexReducer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MultitexReducer, (void **)&local_this, "MultitexReducer.flatten")) {
    return NULL;
  }
  // 1-void MultitexReducer::flatten(GraphicsOutput *window)
  GraphicsOutput *arg_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsOutput, 1, "MultitexReducer.flatten", false, true);
  if (arg_this != NULL) {
    (*local_this).flatten(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "flatten(const MultitexReducer self, GraphicsOutput window)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MultitexReducer_flatten_189_comment =
  "C++ Interface:\n"
  "flatten(const MultitexReducer self, GraphicsOutput window)\n";
#else
static const char *Dtool_MultitexReducer_flatten_189_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * MultitexReducer::MultitexReducer(void)
 * inline MultitexReducer::MultitexReducer(MultitexReducer const &) = default
 */
static int Dtool_Init_MultitexReducer(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-MultitexReducer::MultitexReducer(void)
      MultitexReducer *return_value = new MultitexReducer();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MultitexReducer, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline MultitexReducer::MultitexReducer(MultitexReducer const &) = default
      MultitexReducer const *arg_this = (MultitexReducer *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MultitexReducer, 0, "MultitexReducer.MultitexReducer", true, true);
      if (arg_this != NULL) {
        MultitexReducer *return_value = new MultitexReducer(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MultitexReducer, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "MultitexReducer() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MultitexReducer()\n"
      "MultitexReducer(const MultitexReducer param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_MultitexReducer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MultitexReducer) {
    printf("MultitexReducer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MultitexReducer *local_this = (MultitexReducer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MultitexReducer) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MultitexReducer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MultitexReducer) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class NodeVertexTransform
 */
/**
 * Python function wrapper for:
 * inline PandaNode const *NodeVertexTransform::get_node(void) const
 */
static PyObject *Dtool_NodeVertexTransform_get_node_193(PyObject *self, PyObject *) {
  NodeVertexTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodeVertexTransform, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PandaNode const *NodeVertexTransform::get_node(void) const
  PandaNode const *return_value = (*(const NodeVertexTransform*)local_this).get_node();
  if (return_value != (PandaNode const *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PandaNode const *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_NodeVertexTransform_get_node_193_comment =
  "C++ Interface:\n"
  "get_node(NodeVertexTransform self)\n"
  "\n"
  "/**\n"
  " * Returns the PandaNode whose transform supplies this object.\n"
  " */";
#else
static const char *Dtool_NodeVertexTransform_get_node_193_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline VertexTransform const *NodeVertexTransform::get_prev(void) const
 */
static PyObject *Dtool_NodeVertexTransform_get_prev_194(PyObject *self, PyObject *) {
  NodeVertexTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodeVertexTransform, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline VertexTransform const *NodeVertexTransform::get_prev(void) const
  VertexTransform const *return_value = (*(const NodeVertexTransform*)local_this).get_prev();
  if (return_value != (VertexTransform const *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (VertexTransform const *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VertexTransform, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_NodeVertexTransform_get_prev_194_comment =
  "C++ Interface:\n"
  "get_prev(NodeVertexTransform self)\n"
  "\n"
  "/**\n"
  " * Returns the VertexTransform object whose matrix will be composed with the\n"
  " * result of this node's transform.\n"
  " */";
#else
static const char *Dtool_NodeVertexTransform_get_prev_194_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle NodeVertexTransform::get_class_type(void)
 */
static PyObject *Dtool_NodeVertexTransform_get_class_type_202(PyObject *, PyObject *) {
  // 1-static TypeHandle NodeVertexTransform::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(NodeVertexTransform::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NodeVertexTransform_get_class_type_202_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_NodeVertexTransform_get_class_type_202_comment = NULL;
#endif

static PyObject *Dtool_NodeVertexTransform_node_Getter(PyObject *self, void *) {
  const NodeVertexTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodeVertexTransform, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PandaNode const *NodeVertexTransform::get_node(void) const
  PandaNode const *return_value = (*(const NodeVertexTransform*)local_this).get_node();
  if (return_value != (PandaNode const *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (PandaNode const *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, true, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_NodeVertexTransform_prev_Getter(PyObject *self, void *) {
  const NodeVertexTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodeVertexTransform, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline VertexTransform const *NodeVertexTransform::get_prev(void) const
  VertexTransform const *return_value = (*(const NodeVertexTransform*)local_this).get_prev();
  if (return_value != (VertexTransform const *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (VertexTransform const *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VertexTransform, true, true, return_value->as_typed_object()->get_type_index());
  }
}

/**
 * Python function wrapper for:
 * NodeVertexTransform::NodeVertexTransform(PandaNode const *node, VertexTransform const *prev = 0)
 */
static int Dtool_Init_NodeVertexTransform(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-NodeVertexTransform::NodeVertexTransform(PandaNode const *node, VertexTransform const *prev = 0)
  PyObject *param0;
  PyObject *param1 = NULL;
  static const char *keyword_list[] = {"node", "prev", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:NodeVertexTransform", (char **)keyword_list, &param0, &param1)) {
    PandaNode const *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PandaNode, 0, "NodeVertexTransform.NodeVertexTransform", true, true);
    VertexTransform const *param1_this = 0;
    if (param1 != (PyObject *)NULL) {
      param1_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_VertexTransform, 1, "NodeVertexTransform.NodeVertexTransform", true, true);
    }
    if (param0_this != NULL && (param1 == NULL || param1_this != NULL)) {
      NodeVertexTransform *return_value = new NodeVertexTransform(param0_this, param1_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NodeVertexTransform, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NodeVertexTransform(const PandaNode node, const VertexTransform prev)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_NodeVertexTransform(PyObject *args, CPT(NodeVertexTransform) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_NodeVertexTransform, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-NodeVertexTransform::NodeVertexTransform(PandaNode const *node, VertexTransform const *prev)
    PandaNode const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PandaNode, (void **)&arg_this);
    if (arg_this != NULL) {
      NodeVertexTransform *return_value = new NodeVertexTransform(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-NodeVertexTransform::NodeVertexTransform(PandaNode const *node, VertexTransform const *prev)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "NodeVertexTransform", 2, 2, &param0, &param1)) {
        PandaNode const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PandaNode, (void **)&param0_this);
        VertexTransform const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_VertexTransform, (void **)&param1_this);
        if (param0_this != NULL && param1_this != NULL) {
          NodeVertexTransform *return_value = new NodeVertexTransform(param0_this, param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_NodeVertexTransform(PyObject *args, PT(NodeVertexTransform) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_NodeVertexTransform, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-NodeVertexTransform::NodeVertexTransform(PandaNode const *node, VertexTransform const *prev)
    PandaNode const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PandaNode, (void **)&arg_this);
    if (arg_this != NULL) {
      NodeVertexTransform *return_value = new NodeVertexTransform(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-NodeVertexTransform::NodeVertexTransform(PandaNode const *node, VertexTransform const *prev)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "NodeVertexTransform", 2, 2, &param0, &param1)) {
        PandaNode const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PandaNode, (void **)&param0_this);
        VertexTransform const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_VertexTransform, (void **)&param1_this);
        if (param0_this != NULL && param1_this != NULL) {
          NodeVertexTransform *return_value = new NodeVertexTransform(param0_this, param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_NodeVertexTransform(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_NodeVertexTransform) {
    printf("NodeVertexTransform ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  NodeVertexTransform *local_this = (NodeVertexTransform *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_NodeVertexTransform) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(VertexTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(VertexTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(VertexTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(VertexTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_VertexTransform) {
    return (VertexTransform *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_NodeVertexTransform(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_NodeVertexTransform) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (NodeVertexTransform*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (NodeVertexTransform*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (NodeVertexTransform*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (NodeVertexTransform*)other_this;
  }
  if (from_type == Dtool_Ptr_VertexTransform) {
    VertexTransform* other_this = (VertexTransform*)from_this;
    return (NodeVertexTransform*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ShaderTerrainMesh
 */
/**
 * Python function wrapper for:
 * inline void ShaderTerrainMesh::set_heightfield(Texture *heightfield)
 */
static PyObject *Dtool_ShaderTerrainMesh_set_heightfield_206(PyObject *self, PyObject *arg) {
  ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderTerrainMesh, (void **)&local_this, "ShaderTerrainMesh.set_heightfield")) {
    return NULL;
  }
  // 1-inline void ShaderTerrainMesh::set_heightfield(Texture *heightfield)
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "ShaderTerrainMesh.set_heightfield", false, true);
  if (arg_this != NULL) {
    (*local_this).set_heightfield(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_heightfield(const ShaderTerrainMesh self, Texture heightfield)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ShaderTerrainMesh_set_heightfield_206_comment =
  "C++ Interface:\n"
  "set_heightfield(const ShaderTerrainMesh self, Texture heightfield)\n"
  "\n"
  "/**\n"
  " * @brief Sets the heightfield texture\n"
  " * @details This sets the heightfield texture. It should be 16bit\n"
  " *   single channel, and have a power-of-two resolution greater than 32.\n"
  " *   Common sizes are 2048x2048 or 4096x4096.\n"
  " *\n"
  " *   You should call generate() after setting the heightfield.\n"
  " *\n"
  " * @param filename Heightfield texture\n"
  " */";
#else
static const char *Dtool_ShaderTerrainMesh_set_heightfield_206_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Texture *ShaderTerrainMesh::get_heightfield(void) const
 */
static PyObject *Dtool_ShaderTerrainMesh_get_heightfield_207(PyObject *self, PyObject *) {
  ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderTerrainMesh, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Texture *ShaderTerrainMesh::get_heightfield(void) const
  Texture *return_value = (*(const ShaderTerrainMesh*)local_this).get_heightfield();
  if (return_value != (Texture *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (Texture *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ShaderTerrainMesh_get_heightfield_207_comment =
  "C++ Interface:\n"
  "get_heightfield(ShaderTerrainMesh self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the heightfield\n"
  " * @details This returns the terrain heightfield, previously set with\n"
  " *   set_heightfield()\n"
  " *\n"
  " * @return Path to the heightfield\n"
  " */";
#else
static const char *Dtool_ShaderTerrainMesh_get_heightfield_207_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ShaderTerrainMesh::set_chunk_size(std::size_t chunk_size)
 */
static PyObject *Dtool_ShaderTerrainMesh_set_chunk_size_210(PyObject *self, PyObject *arg) {
  ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderTerrainMesh, (void **)&local_this, "ShaderTerrainMesh.set_chunk_size")) {
    return NULL;
  }
  // 1-inline void ShaderTerrainMesh::set_chunk_size(std::size_t chunk_size)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:set_chunk_size", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).set_chunk_size((std::size_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_chunk_size(const ShaderTerrainMesh self, int chunk_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ShaderTerrainMesh_set_chunk_size_210_comment =
  "C++ Interface:\n"
  "set_chunk_size(const ShaderTerrainMesh self, int chunk_size)\n"
  "\n"
  "/**\n"
  " * @brief Sets the chunk size\n"
  " * @details This sets the chunk size of the terrain. A chunk is basically the\n"
  " *   smallest unit in LOD. If the chunk size is too small, the terrain will\n"
  " *   perform bad, since there will be way too many chunks. If the chunk size\n"
  " *   is too big, you will not get proper LOD, and might also get bad performance.\n"
  " *\n"
  " *   For terrains of the size 4096x4096 or 8192x8192, a chunk size of 32 seems\n"
  " *   to produce good results. For smaller resolutions, you should try out a\n"
  " *   size of 16 or even 8 for very small terrains.\n"
  " *\n"
  " *   The amount of chunks generated for the last level equals to\n"
  " *   (heightfield_size / chunk_size) ** 2. The chunk size has to be a power\n"
  " *   of two.\n"
  " *\n"
  " * @param chunk_size Size of the chunks, has to be a power of two\n"
  " */";
#else
static const char *Dtool_ShaderTerrainMesh_set_chunk_size_210_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ShaderTerrainMesh::get_chunk_size(void) const
 */
static PyObject *Dtool_ShaderTerrainMesh_get_chunk_size_211(PyObject *self, PyObject *) {
  ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderTerrainMesh, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ShaderTerrainMesh::get_chunk_size(void) const
  std::size_t return_value = (*(const ShaderTerrainMesh*)local_this).get_chunk_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderTerrainMesh_get_chunk_size_211_comment =
  "C++ Interface:\n"
  "get_chunk_size(ShaderTerrainMesh self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the chunk size\n"
  " * @details This returns the chunk size, previously set with set_chunk_size()\n"
  " * @return Chunk size\n"
  " */";
#else
static const char *Dtool_ShaderTerrainMesh_get_chunk_size_211_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ShaderTerrainMesh::set_generate_patches(bool generate_patches)
 */
static PyObject *Dtool_ShaderTerrainMesh_set_generate_patches_215(PyObject *self, PyObject *arg) {
  ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderTerrainMesh, (void **)&local_this, "ShaderTerrainMesh.set_generate_patches")) {
    return NULL;
  }
  // 1-inline void ShaderTerrainMesh::set_generate_patches(bool generate_patches)
  (*local_this).set_generate_patches((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_generate_patches(const ShaderTerrainMesh self, bool generate_patches)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ShaderTerrainMesh_set_generate_patches_215_comment =
  "C++ Interface:\n"
  "set_generate_patches(const ShaderTerrainMesh self, bool generate_patches)\n"
  "\n"
  "/**\n"
  " * @brief Sets whether to generate patches\n"
  " * @details If this option is set to true, GeomPatches will be used instead of\n"
  " *   GeomTriangles. This is required when the terrain is used with tesselation\n"
  " *   shaders, since patches are required for tesselation, whereas triangles\n"
  " *   are required for regular rendering.\n"
  " *\n"
  " *   If this option is set to true while not using a tesselation shader, the\n"
  " *   terrain will not get rendered, or even produce errors. The same applies\n"
  " *   when this is option is not set, but the terrain is used with tesselation\n"
  " *   shaders.\n"
  " *\n"
  " * @param generate_patches [description]\n"
  " */";
#else
static const char *Dtool_ShaderTerrainMesh_set_generate_patches_215_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ShaderTerrainMesh::get_generate_patches(void) const
 */
static PyObject *Dtool_ShaderTerrainMesh_get_generate_patches_216(PyObject *self, PyObject *) {
  ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderTerrainMesh, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ShaderTerrainMesh::get_generate_patches(void) const
  bool return_value = (*(const ShaderTerrainMesh*)local_this).get_generate_patches();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderTerrainMesh_get_generate_patches_216_comment =
  "C++ Interface:\n"
  "get_generate_patches(ShaderTerrainMesh self)\n"
  "\n"
  "/**\n"
  " * @brief Returns whether to generate patches\n"
  " * @details This returns whether patches are generated, previously set with\n"
  " *   set_generate_patches()\n"
  " *\n"
  " * @return Whether to generate patches\n"
  " */";
#else
static const char *Dtool_ShaderTerrainMesh_get_generate_patches_216_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ShaderTerrainMesh::set_update_enabled(bool update_enabled)
 */
static PyObject *Dtool_ShaderTerrainMesh_set_update_enabled_218(PyObject *self, PyObject *arg) {
  ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderTerrainMesh, (void **)&local_this, "ShaderTerrainMesh.set_update_enabled")) {
    return NULL;
  }
  // 1-inline void ShaderTerrainMesh::set_update_enabled(bool update_enabled)
  (*local_this).set_update_enabled((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_update_enabled(const ShaderTerrainMesh self, bool update_enabled)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ShaderTerrainMesh_set_update_enabled_218_comment =
  "C++ Interface:\n"
  "set_update_enabled(const ShaderTerrainMesh self, bool update_enabled)\n"
  "\n"
  "/**\n"
  " * @brief Sets whether to enable terrain updates\n"
  " * @details This flag controls whether the terrain should be updated. If this value\n"
  " *   is set to false, no updating of the terrain will happen. This can be useful\n"
  " *   to debug the culling algorithm used by the terrain.\n"
  " *\n"
  " * @param update_enabled Whether to update the terrain\n"
  " */";
#else
static const char *Dtool_ShaderTerrainMesh_set_update_enabled_218_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ShaderTerrainMesh::get_update_enabled(void) const
 */
static PyObject *Dtool_ShaderTerrainMesh_get_update_enabled_219(PyObject *self, PyObject *) {
  ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderTerrainMesh, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ShaderTerrainMesh::get_update_enabled(void) const
  bool return_value = (*(const ShaderTerrainMesh*)local_this).get_update_enabled();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderTerrainMesh_get_update_enabled_219_comment =
  "C++ Interface:\n"
  "get_update_enabled(ShaderTerrainMesh self)\n"
  "\n"
  "/**\n"
  " * @brief Returns whether the terrain is getting updated\n"
  " * @details This returns whether the terrain is getting updates, previously set with\n"
  " *   set_update_enabled()\n"
  " *\n"
  " * @return Whether to update the terrain\n"
  " */";
#else
static const char *Dtool_ShaderTerrainMesh_get_update_enabled_219_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ShaderTerrainMesh::set_target_triangle_width(PN_stdfloat target_triangle_width)
 */
static PyObject *Dtool_ShaderTerrainMesh_set_target_triangle_width_221(PyObject *self, PyObject *arg) {
  ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderTerrainMesh, (void **)&local_this, "ShaderTerrainMesh.set_target_triangle_width")) {
    return NULL;
  }
  // 1-inline void ShaderTerrainMesh::set_target_triangle_width(PN_stdfloat target_triangle_width)
  if (PyNumber_Check(arg)) {
    (*local_this).set_target_triangle_width((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_target_triangle_width(const ShaderTerrainMesh self, float target_triangle_width)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ShaderTerrainMesh_set_target_triangle_width_221_comment =
  "C++ Interface:\n"
  "set_target_triangle_width(const ShaderTerrainMesh self, float target_triangle_width)\n"
  "\n"
  "/**\n"
  " * @brief Sets the desired triangle width\n"
  " * @details This sets the desired width a triangle should have in pixels.\n"
  " *   A value of 10.0 for example will make the terrain tesselate everything\n"
  " *   in a way that each triangle edge roughly is 10 pixels wide.\n"
  " *   Of course this will not always accurately match, however you can use this\n"
  " *   setting to control the LOD algorithm of the terrain.\n"
  " *\n"
  " * @param target_triangle_width Desired triangle width in pixels\n"
  " */";
#else
static const char *Dtool_ShaderTerrainMesh_set_target_triangle_width_221_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat ShaderTerrainMesh::get_target_triangle_width(void) const
 */
static PyObject *Dtool_ShaderTerrainMesh_get_target_triangle_width_222(PyObject *self, PyObject *) {
  ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderTerrainMesh, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat ShaderTerrainMesh::get_target_triangle_width(void) const
  PN_stdfloat return_value = (*(const ShaderTerrainMesh*)local_this).get_target_triangle_width();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderTerrainMesh_get_target_triangle_width_222_comment =
  "C++ Interface:\n"
  "get_target_triangle_width(ShaderTerrainMesh self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the target triangle width\n"
  " * @details This returns the target triangle width, previously set with\n"
  " *   ShaderTerrainMesh::set_target_triangle_width()\n"
  " *\n"
  " * @return Target triangle width\n"
  " */";
#else
static const char *Dtool_ShaderTerrainMesh_get_target_triangle_width_222_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LPoint3 ShaderTerrainMesh::uv_to_world(LTexCoord const &coord) const
 * inline LPoint3 ShaderTerrainMesh::uv_to_world(PN_stdfloat u, PN_stdfloat v) const
 */
static PyObject *Dtool_ShaderTerrainMesh_uv_to_world_226(PyObject *self, PyObject *args, PyObject *kwds) {
  ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderTerrainMesh, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "coord");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'coord' (pos 1) not found");
      }
      // 1-LPoint3 ShaderTerrainMesh::uv_to_world(LTexCoord const &coord) const
      LPoint2f arg_local;
      LTexCoord const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "ShaderTerrainMesh.uv_to_world", "LPoint2f");
      }
      LPoint3 *return_value = new LPoint3((*(const ShaderTerrainMesh*)local_this).uv_to_world(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
    }
    break;
  case 2:
    {
      // 1-inline LPoint3 ShaderTerrainMesh::uv_to_world(PN_stdfloat u, PN_stdfloat v) const
      float param1;
      float param2;
      static const char *keyword_list[] = {"u", "v", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:uv_to_world", (char **)keyword_list, &param1, &param2)) {
        LPoint3 *return_value = new LPoint3((*(const ShaderTerrainMesh*)local_this).uv_to_world((PN_stdfloat)param1, (PN_stdfloat)param2));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "uv_to_world() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "uv_to_world(ShaderTerrainMesh self, const LPoint2f coord)\n"
      "uv_to_world(ShaderTerrainMesh self, float u, float v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ShaderTerrainMesh_uv_to_world_226_comment =
  "C++ Interface:\n"
  "uv_to_world(ShaderTerrainMesh self, const LPoint2f coord)\n"
  "uv_to_world(ShaderTerrainMesh self, float u, float v)\n"
  "\n"
  "/**\n"
  " * @see ShaderTerrainMesh::uv_to_world(LTexCoord)\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Transforms a texture coordinate to world space\n"
  " * @details This transforms a texture coordinatefrom uv-space (0 to 1) to world\n"
  " *   space. This takes the terrains transform into account, and also samples the\n"
  " *   heightmap. This method should be called after generate().\n"
  " *\n"
  " * @param coord Coordinate in uv-space from 0, 0 to 1, 1\n"
  " * @return World-Space point\n"
  " */";
#else
static const char *Dtool_ShaderTerrainMesh_uv_to_world_226_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ShaderTerrainMesh::generate(void)
 */
static PyObject *Dtool_ShaderTerrainMesh_generate_227(PyObject *self, PyObject *) {
  ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderTerrainMesh, (void **)&local_this, "ShaderTerrainMesh.generate")) {
    return NULL;
  }
  // 1-bool ShaderTerrainMesh::generate(void)
  bool return_value = (*local_this).generate();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderTerrainMesh_generate_227_comment =
  "C++ Interface:\n"
  "generate(const ShaderTerrainMesh self)\n"
  "\n"
  "/**\n"
  " * @brief Generates the terrain mesh\n"
  " * @details This generates the terrain mesh, initializing all chunks of the\n"
  " *   internal used quadtree. At this point, a heightfield and a chunk size should\n"
  " *   have been set, otherwise an error is thrown.\n"
  " *\n"
  " *   If anything goes wrong, like a missing heightfield, then an error is printed\n"
  " *   and false is returned.\n"
  " *\n"
  " * @return true if the terrain was initialized, false if an error occured\n"
  " */";
#else
static const char *Dtool_ShaderTerrainMesh_generate_227_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ShaderTerrainMesh::get_class_type(void)
 */
static PyObject *Dtool_ShaderTerrainMesh_get_class_type_228(PyObject *, PyObject *) {
  // 1-static TypeHandle ShaderTerrainMesh::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ShaderTerrainMesh::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ShaderTerrainMesh_get_class_type_228_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ShaderTerrainMesh_get_class_type_228_comment = NULL;
#endif

static PyObject *Dtool_ShaderTerrainMesh_heightfield_Getter(PyObject *self, void *) {
  const ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderTerrainMesh, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline Texture *ShaderTerrainMesh::get_heightfield(void) const
  Texture *return_value = (*(const ShaderTerrainMesh*)local_this).get_heightfield();
  if (return_value != (Texture *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (Texture *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_ShaderTerrainMesh_heightfield_Setter(PyObject *self, PyObject *arg, void *) {
  ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderTerrainMesh, (void **)&local_this, "ShaderTerrainMesh.heightfield")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete heightfield attribute");
    return -1;
  }
  // 1-inline void ShaderTerrainMesh::set_heightfield(Texture *heightfield)
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "ShaderTerrainMesh.set_heightfield", false, true);
  if (arg_this != NULL) {
    (*local_this).set_heightfield(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_heightfield(const ShaderTerrainMesh self, Texture heightfield)\n");
  }
  return -1;
}

static PyObject *Dtool_ShaderTerrainMesh_chunk_size_Getter(PyObject *self, void *) {
  const ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderTerrainMesh, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::size_t ShaderTerrainMesh::get_chunk_size(void) const
  std::size_t return_value = (*(const ShaderTerrainMesh*)local_this).get_chunk_size();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ShaderTerrainMesh_chunk_size_Setter(PyObject *self, PyObject *arg, void *) {
  ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderTerrainMesh, (void **)&local_this, "ShaderTerrainMesh.chunk_size")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete chunk_size attribute");
    return -1;
  }
  // 1-inline void ShaderTerrainMesh::set_chunk_size(std::size_t chunk_size)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:set_chunk_size", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      PyErr_Format(PyExc_OverflowError,
                   "can't convert negative value %zd to size_t",
                   param1);
      return -1;
    }
#endif
    (*local_this).set_chunk_size((std::size_t)param1);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_chunk_size(const ShaderTerrainMesh self, int chunk_size)\n");
  }
  return -1;
}

static PyObject *Dtool_ShaderTerrainMesh_generate_patches_Getter(PyObject *self, void *) {
  const ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderTerrainMesh, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool ShaderTerrainMesh::get_generate_patches(void) const
  bool return_value = (*(const ShaderTerrainMesh*)local_this).get_generate_patches();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ShaderTerrainMesh_generate_patches_Setter(PyObject *self, PyObject *arg, void *) {
  ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderTerrainMesh, (void **)&local_this, "ShaderTerrainMesh.generate_patches")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete generate_patches attribute");
    return -1;
  }
  // 1-inline void ShaderTerrainMesh::set_generate_patches(bool generate_patches)
  (*local_this).set_generate_patches((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_generate_patches(const ShaderTerrainMesh self, bool generate_patches)\n");
  }
  return -1;
}

static PyObject *Dtool_ShaderTerrainMesh_update_enabled_Getter(PyObject *self, void *) {
  const ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderTerrainMesh, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool ShaderTerrainMesh::get_update_enabled(void) const
  bool return_value = (*(const ShaderTerrainMesh*)local_this).get_update_enabled();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ShaderTerrainMesh_update_enabled_Setter(PyObject *self, PyObject *arg, void *) {
  ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderTerrainMesh, (void **)&local_this, "ShaderTerrainMesh.update_enabled")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete update_enabled attribute");
    return -1;
  }
  // 1-inline void ShaderTerrainMesh::set_update_enabled(bool update_enabled)
  (*local_this).set_update_enabled((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_update_enabled(const ShaderTerrainMesh self, bool update_enabled)\n");
  }
  return -1;
}

static PyObject *Dtool_ShaderTerrainMesh_target_triangle_width_Getter(PyObject *self, void *) {
  const ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderTerrainMesh, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat ShaderTerrainMesh::get_target_triangle_width(void) const
  PN_stdfloat return_value = (*(const ShaderTerrainMesh*)local_this).get_target_triangle_width();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ShaderTerrainMesh_target_triangle_width_Setter(PyObject *self, PyObject *arg, void *) {
  ShaderTerrainMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderTerrainMesh, (void **)&local_this, "ShaderTerrainMesh.target_triangle_width")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete target_triangle_width attribute");
    return -1;
  }
  // 1-inline void ShaderTerrainMesh::set_target_triangle_width(PN_stdfloat target_triangle_width)
  if (PyNumber_Check(arg)) {
    (*local_this).set_target_triangle_width((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_target_triangle_width(const ShaderTerrainMesh self, float target_triangle_width)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * ShaderTerrainMesh::ShaderTerrainMesh(void)
 */
static int Dtool_Init_ShaderTerrainMesh(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ShaderTerrainMesh() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-ShaderTerrainMesh::ShaderTerrainMesh(void)
  ShaderTerrainMesh *return_value = new ShaderTerrainMesh();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderTerrainMesh, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ShaderTerrainMesh()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ShaderTerrainMesh(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ShaderTerrainMesh) {
    printf("ShaderTerrainMesh ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ShaderTerrainMesh *local_this = (ShaderTerrainMesh *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ShaderTerrainMesh) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ShaderTerrainMesh(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ShaderTerrainMesh) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ShaderTerrainMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (ShaderTerrainMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ShaderTerrainMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ShaderTerrainMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ShaderTerrainMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ShaderTerrainMesh*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class SceneGraphAnalyzerMeter
 */
/**
 * Python function wrapper for:
 * void SceneGraphAnalyzerMeter::setup_window(GraphicsOutput *window)
 */
static PyObject *Dtool_SceneGraphAnalyzerMeter_setup_window_232(PyObject *self, PyObject *arg) {
  SceneGraphAnalyzerMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphAnalyzerMeter, (void **)&local_this, "SceneGraphAnalyzerMeter.setup_window")) {
    return NULL;
  }
  // 1-void SceneGraphAnalyzerMeter::setup_window(GraphicsOutput *window)
  GraphicsOutput *arg_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsOutput, 1, "SceneGraphAnalyzerMeter.setup_window", false, true);
  if (arg_this != NULL) {
    (*local_this).setup_window(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_window(const SceneGraphAnalyzerMeter self, GraphicsOutput window)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzerMeter_setup_window_232_comment =
  "C++ Interface:\n"
  "setup_window(const SceneGraphAnalyzerMeter self, GraphicsOutput window)\n"
  "\n"
  "/**\n"
  " * Sets up the frame rate meter to create a DisplayRegion to render itself\n"
  " * into the indicated window.\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzerMeter_setup_window_232_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void SceneGraphAnalyzerMeter::clear_window(void)
 */
static PyObject *Dtool_SceneGraphAnalyzerMeter_clear_window_233(PyObject *self, PyObject *) {
  SceneGraphAnalyzerMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphAnalyzerMeter, (void **)&local_this, "SceneGraphAnalyzerMeter.clear_window")) {
    return NULL;
  }
  // 1-void SceneGraphAnalyzerMeter::clear_window(void)
  (*local_this).clear_window();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzerMeter_clear_window_233_comment =
  "C++ Interface:\n"
  "clear_window(const SceneGraphAnalyzerMeter self)\n"
  "\n"
  "/**\n"
  " * Undoes the effect of a previous call to setup_window().\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzerMeter_clear_window_233_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsOutput *SceneGraphAnalyzerMeter::get_window(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzerMeter_get_window_234(PyObject *self, PyObject *) {
  SceneGraphAnalyzerMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzerMeter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline GraphicsOutput *SceneGraphAnalyzerMeter::get_window(void) const
  GraphicsOutput *return_value = (*(const SceneGraphAnalyzerMeter*)local_this).get_window();
  if (return_value != (GraphicsOutput *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (GraphicsOutput *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutput, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzerMeter_get_window_234_comment =
  "C++ Interface:\n"
  "get_window(SceneGraphAnalyzerMeter self)\n"
  "\n"
  "/**\n"
  " * Returns the GraphicsOutput that was passed to setup_window(), or NULL if\n"
  " * setup_window() has not been called.\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzerMeter_get_window_234_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DisplayRegion *SceneGraphAnalyzerMeter::get_display_region(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzerMeter_get_display_region_235(PyObject *self, PyObject *) {
  SceneGraphAnalyzerMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzerMeter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline DisplayRegion *SceneGraphAnalyzerMeter::get_display_region(void) const
  DisplayRegion *return_value = (*(const SceneGraphAnalyzerMeter*)local_this).get_display_region();
  if (return_value != (DisplayRegion *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (DisplayRegion *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DisplayRegion, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzerMeter_get_display_region_235_comment =
  "C++ Interface:\n"
  "get_display_region(SceneGraphAnalyzerMeter self)\n"
  "\n"
  "/**\n"
  " * Returns the DisplayRegion that the meter has created to render itself into\n"
  " * the window to setup_window(), or NULL if setup_window() has not been\n"
  " * called.\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzerMeter_get_display_region_235_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SceneGraphAnalyzerMeter::set_update_interval(double update_interval)
 */
static PyObject *Dtool_SceneGraphAnalyzerMeter_set_update_interval_236(PyObject *self, PyObject *arg) {
  SceneGraphAnalyzerMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphAnalyzerMeter, (void **)&local_this, "SceneGraphAnalyzerMeter.set_update_interval")) {
    return NULL;
  }
  // 1-inline void SceneGraphAnalyzerMeter::set_update_interval(double update_interval)
  if (PyNumber_Check(arg)) {
    (*local_this).set_update_interval(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_update_interval(const SceneGraphAnalyzerMeter self, double update_interval)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzerMeter_set_update_interval_236_comment =
  "C++ Interface:\n"
  "set_update_interval(const SceneGraphAnalyzerMeter self, double update_interval)\n"
  "\n"
  "/**\n"
  " * Specifies the number of seconds that should elapse between updates to the\n"
  " * meter.  This should be reasonably slow (e.g.  0.5 to 2.0) so that the\n"
  " * calculation of the scene graph analysis does not itself dominate the frame\n"
  " * rate.\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzerMeter_set_update_interval_236_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double SceneGraphAnalyzerMeter::get_update_interval(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzerMeter_get_update_interval_237(PyObject *self, PyObject *) {
  SceneGraphAnalyzerMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzerMeter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double SceneGraphAnalyzerMeter::get_update_interval(void) const
  double return_value = (*(const SceneGraphAnalyzerMeter*)local_this).get_update_interval();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzerMeter_get_update_interval_237_comment =
  "C++ Interface:\n"
  "get_update_interval(SceneGraphAnalyzerMeter self)\n"
  "\n"
  "/**\n"
  " * Returns the number of seconds that will elapse between updates to the frame\n"
  " * rate indication.\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzerMeter_get_update_interval_237_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SceneGraphAnalyzerMeter::set_node(PandaNode *node)
 */
static PyObject *Dtool_SceneGraphAnalyzerMeter_set_node_238(PyObject *self, PyObject *arg) {
  SceneGraphAnalyzerMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphAnalyzerMeter, (void **)&local_this, "SceneGraphAnalyzerMeter.set_node")) {
    return NULL;
  }
  // 1-inline void SceneGraphAnalyzerMeter::set_node(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "SceneGraphAnalyzerMeter.set_node", false, true);
  if (arg_this != NULL) {
    (*local_this).set_node(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_node(const SceneGraphAnalyzerMeter self, PandaNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzerMeter_set_node_238_comment =
  "C++ Interface:\n"
  "set_node(const SceneGraphAnalyzerMeter self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Sets the node to be analyzed.\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzerMeter_set_node_238_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode *SceneGraphAnalyzerMeter::get_node(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzerMeter_get_node_239(PyObject *self, PyObject *) {
  SceneGraphAnalyzerMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzerMeter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PandaNode *SceneGraphAnalyzerMeter::get_node(void) const
  PandaNode *return_value = (*(const SceneGraphAnalyzerMeter*)local_this).get_node();
  if (return_value != (PandaNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PandaNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzerMeter_get_node_239_comment =
  "C++ Interface:\n"
  "get_node(SceneGraphAnalyzerMeter self)\n"
  "\n"
  "/**\n"
  " * Returns the node to be analyzed.\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzerMeter_get_node_239_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SceneGraphAnalyzerMeter::update(void)
 */
static PyObject *Dtool_SceneGraphAnalyzerMeter_update_240(PyObject *self, PyObject *) {
  SceneGraphAnalyzerMeter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphAnalyzerMeter, (void **)&local_this, "SceneGraphAnalyzerMeter.update")) {
    return NULL;
  }
  // 1-inline void SceneGraphAnalyzerMeter::update(void)
  (*local_this).update();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzerMeter_update_240_comment =
  "C++ Interface:\n"
  "update(const SceneGraphAnalyzerMeter self)\n"
  "\n"
  "/**\n"
  " * You can call this to explicitly force the SceneGraphAnalyzerMeter to update\n"
  " * itself with the latest scene graph analysis information.  Normally, it is\n"
  " * not necessary to call this explicitly.\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzerMeter_update_240_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle SceneGraphAnalyzerMeter::get_class_type(void)
 */
static PyObject *Dtool_SceneGraphAnalyzerMeter_get_class_type_241(PyObject *, PyObject *) {
  // 1-static TypeHandle SceneGraphAnalyzerMeter::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(SceneGraphAnalyzerMeter::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzerMeter_get_class_type_241_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SceneGraphAnalyzerMeter_get_class_type_241_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline SceneGraphAnalyzerMeter::SceneGraphAnalyzerMeter(SceneGraphAnalyzerMeter const &) = default
 * SceneGraphAnalyzerMeter::SceneGraphAnalyzerMeter(std::string const &name, PandaNode *node)
 */
static int Dtool_Init_SceneGraphAnalyzerMeter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline SceneGraphAnalyzerMeter::SceneGraphAnalyzerMeter(SceneGraphAnalyzerMeter const &) = default
      CPT(SceneGraphAnalyzerMeter) arg_this;
      if (!Dtool_ConstCoerce_SceneGraphAnalyzerMeter(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "SceneGraphAnalyzerMeter.SceneGraphAnalyzerMeter", "SceneGraphAnalyzerMeter");
        return -1;
      }
      SceneGraphAnalyzerMeter *return_value = new SceneGraphAnalyzerMeter(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SceneGraphAnalyzerMeter, true, false);
    }
    break;
  case 2:
    {
      // 1-SceneGraphAnalyzerMeter::SceneGraphAnalyzerMeter(std::string const &name, PandaNode *node)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      static const char *keyword_list[] = {"name", "node", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:SceneGraphAnalyzerMeter", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
        PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "SceneGraphAnalyzerMeter.SceneGraphAnalyzerMeter", false, true);
        if (param1_this != NULL) {
          SceneGraphAnalyzerMeter *return_value = new SceneGraphAnalyzerMeter(std::string(param0_str, param0_len), param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SceneGraphAnalyzerMeter, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SceneGraphAnalyzerMeter() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SceneGraphAnalyzerMeter(const SceneGraphAnalyzerMeter param0)\n"
      "SceneGraphAnalyzerMeter(str name, PandaNode node)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_SceneGraphAnalyzerMeter(PyObject *args, CPT(SceneGraphAnalyzerMeter) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SceneGraphAnalyzerMeter, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-SceneGraphAnalyzerMeter::SceneGraphAnalyzerMeter(std::string const &name, PandaNode *node)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "s#O:SceneGraphAnalyzerMeter", &param0_str, &param0_len, &param1)) {
        PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "SceneGraphAnalyzerMeter.SceneGraphAnalyzerMeter", false, false);
        if (param1_this != NULL) {
          SceneGraphAnalyzerMeter *return_value = new SceneGraphAnalyzerMeter(std::string(param0_str, param0_len), param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_SceneGraphAnalyzerMeter(PyObject *args, PT(SceneGraphAnalyzerMeter) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SceneGraphAnalyzerMeter, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-SceneGraphAnalyzerMeter::SceneGraphAnalyzerMeter(std::string const &name, PandaNode *node)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "s#O:SceneGraphAnalyzerMeter", &param0_str, &param0_len, &param1)) {
        PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "SceneGraphAnalyzerMeter.SceneGraphAnalyzerMeter", false, false);
        if (param1_this != NULL) {
          SceneGraphAnalyzerMeter *return_value = new SceneGraphAnalyzerMeter(std::string(param0_str, param0_len), param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_SceneGraphAnalyzerMeter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SceneGraphAnalyzerMeter) {
    printf("SceneGraphAnalyzerMeter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SceneGraphAnalyzerMeter *local_this = (SceneGraphAnalyzerMeter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SceneGraphAnalyzerMeter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(TextNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(TextNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(TextNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TextEncoder) {
    return (TextEncoder *)(TextNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TextNode) {
    return (TextNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TextProperties) {
    return (TextProperties *)(TextNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(TextNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(TextNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(TextNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SceneGraphAnalyzerMeter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SceneGraphAnalyzerMeter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (SceneGraphAnalyzerMeter*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (SceneGraphAnalyzerMeter*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SceneGraphAnalyzerMeter*)other_this;
  }
  if (from_type == Dtool_Ptr_TextEncoder) {
    TextEncoder* other_this = (TextEncoder*)from_this;
    return (SceneGraphAnalyzerMeter*)other_this;
  }
  if (from_type == Dtool_Ptr_TextNode) {
    TextNode* other_this = (TextNode*)from_this;
    return (SceneGraphAnalyzerMeter*)other_this;
  }
  if (from_type == Dtool_Ptr_TextProperties) {
    TextProperties* other_this = (TextProperties*)from_this;
    return (SceneGraphAnalyzerMeter*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (SceneGraphAnalyzerMeter*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (SceneGraphAnalyzerMeter*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (SceneGraphAnalyzerMeter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class RigidBodyCombiner
 */
/**
 * Python function wrapper for:
 * void RigidBodyCombiner::collect(void)
 */
static PyObject *Dtool_RigidBodyCombiner_collect_244(PyObject *self, PyObject *) {
  RigidBodyCombiner *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RigidBodyCombiner, (void **)&local_this, "RigidBodyCombiner.collect")) {
    return NULL;
  }
  // 1-void RigidBodyCombiner::collect(void)
  (*local_this).collect();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RigidBodyCombiner_collect_244_comment =
  "C++ Interface:\n"
  "collect(const RigidBodyCombiner self)\n"
  "\n"
  "/**\n"
  " * Walks through the entire subgraph of nodes rooted at this node, accumulates\n"
  " * all of the RenderAttribs and Geoms below this node, flattening them into\n"
  " * just one Geom (or as few as possible, if there are multiple different\n"
  " * states).\n"
  " *\n"
  " * Nodes that have transforms on them at the time of collect(), or any\n"
  " * ModelNodes with the preserve_transform flag, will be identified as \"moving\"\n"
  " * nodes, and their transforms will be monitored as they change in future\n"
  " * frames and each new transform directly applied to the vertices.\n"
  " *\n"
  " * This call must be made after adding any nodes to or removing any nodes from\n"
  " * the subgraph rooted at this node.  It should not be made too often, as it\n"
  " * is a relatively expensive call.  If you need to hide children of this node,\n"
  " * consider scaling them to zero (or very near zero), or moving them behind\n"
  " * the camera, instead.\n"
  " */";
#else
static const char *Dtool_RigidBodyCombiner_collect_244_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePath RigidBodyCombiner::get_internal_scene(void)
 */
static PyObject *Dtool_RigidBodyCombiner_get_internal_scene_245(PyObject *self, PyObject *) {
  RigidBodyCombiner *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RigidBodyCombiner, (void **)&local_this, "RigidBodyCombiner.get_internal_scene")) {
    return NULL;
  }
  // 1-NodePath RigidBodyCombiner::get_internal_scene(void)
  NodePath *return_value = new NodePath((*local_this).get_internal_scene());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RigidBodyCombiner_get_internal_scene_245_comment =
  "C++ Interface:\n"
  "get_internal_scene(const RigidBodyCombiner self)\n"
  "\n"
  "/**\n"
  " * Returns a special NodePath that represents the internal node of this\n"
  " * object.  This is the node that is actually sent to the graphics card for\n"
  " * rendering; it contains the collection of the children of this node into as\n"
  " * few Geoms as possible.\n"
  " *\n"
  " * This node is filled up by the last call to collect().\n"
  " */";
#else
static const char *Dtool_RigidBodyCombiner_get_internal_scene_245_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle RigidBodyCombiner::get_class_type(void)
 */
static PyObject *Dtool_RigidBodyCombiner_get_class_type_248(PyObject *, PyObject *) {
  // 1-static TypeHandle RigidBodyCombiner::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(RigidBodyCombiner::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RigidBodyCombiner_get_class_type_248_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_RigidBodyCombiner_get_class_type_248_comment = NULL;
#endif

static PyObject *Dtool_RigidBodyCombiner_internal_scene_Getter(PyObject *self, void *) {
  RigidBodyCombiner *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RigidBodyCombiner, (void **)&local_this, "RigidBodyCombiner.internal_scene")) {
    return NULL;
  }

  // 1-NodePath RigidBodyCombiner::get_internal_scene(void)
  NodePath *return_value = new NodePath((*local_this).get_internal_scene());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

/**
 * Python function wrapper for:
 * RigidBodyCombiner::RigidBodyCombiner(std::string const &name)
 */
static int Dtool_Init_RigidBodyCombiner(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "RigidBodyCombiner() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-RigidBodyCombiner::RigidBodyCombiner(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    RigidBodyCombiner *return_value = new RigidBodyCombiner(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RigidBodyCombiner, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "RigidBodyCombiner(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_RigidBodyCombiner(PyObject *args, CPT(RigidBodyCombiner) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_RigidBodyCombiner, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-RigidBodyCombiner::RigidBodyCombiner(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      RigidBodyCombiner *return_value = new RigidBodyCombiner(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_RigidBodyCombiner(PyObject *args, PT(RigidBodyCombiner) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_RigidBodyCombiner, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-RigidBodyCombiner::RigidBodyCombiner(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      RigidBodyCombiner *return_value = new RigidBodyCombiner(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_RigidBodyCombiner(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_RigidBodyCombiner) {
    printf("RigidBodyCombiner ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  RigidBodyCombiner *local_this = (RigidBodyCombiner *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_RigidBodyCombiner) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_RigidBodyCombiner(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_RigidBodyCombiner) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (RigidBodyCombiner*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (RigidBodyCombiner*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RigidBodyCombiner*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (RigidBodyCombiner*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (RigidBodyCombiner*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (RigidBodyCombiner*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PipeOcclusionCullTraverser
 */
/**
 * Python function wrapper for:
 * virtual void PipeOcclusionCullTraverser::set_scene(SceneSetup *scene_setup, GraphicsStateGuardianBase *gsg, bool dr_incomplete_render)
 */
static PyObject *Dtool_PipeOcclusionCullTraverser_set_scene_258(PyObject *self, PyObject *args, PyObject *kwds) {
  PipeOcclusionCullTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PipeOcclusionCullTraverser, (void **)&local_this, "PipeOcclusionCullTraverser.set_scene")) {
    return NULL;
  }
  // 1-virtual void PipeOcclusionCullTraverser::set_scene(SceneSetup *scene_setup, GraphicsStateGuardianBase *gsg, bool dr_incomplete_render)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"scene_setup", "gsg", "dr_incomplete_render", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_scene", (char **)keyword_list, &param1, &param2, &param3)) {
    SceneSetup *param1_this = (SceneSetup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_SceneSetup, 1, "PipeOcclusionCullTraverser.set_scene", false, true);
    GraphicsStateGuardianBase *param2_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GraphicsStateGuardianBase, 2, "PipeOcclusionCullTraverser.set_scene", false, true);
    if (param1_this != NULL && param2_this != NULL) {
      (*local_this).set_scene(param1_this, param2_this, (PyObject_IsTrue(param3) != 0));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scene(const PipeOcclusionCullTraverser self, SceneSetup scene_setup, GraphicsStateGuardianBase gsg, bool dr_incomplete_render)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PipeOcclusionCullTraverser_set_scene_258_comment =
  "C++ Interface:\n"
  "set_scene(const PipeOcclusionCullTraverser self, SceneSetup scene_setup, GraphicsStateGuardianBase gsg, bool dr_incomplete_render)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PipeOcclusionCullTraverser_set_scene_258_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void PipeOcclusionCullTraverser::end_traverse(void)
 */
static PyObject *Dtool_PipeOcclusionCullTraverser_end_traverse_259(PyObject *self, PyObject *) {
  PipeOcclusionCullTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PipeOcclusionCullTraverser, (void **)&local_this, "PipeOcclusionCullTraverser.end_traverse")) {
    return NULL;
  }
  // 1-virtual void PipeOcclusionCullTraverser::end_traverse(void)
  (*local_this).end_traverse();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PipeOcclusionCullTraverser_end_traverse_259_comment =
  "C++ Interface:\n"
  "end_traverse(const PipeOcclusionCullTraverser self)\n"
  "\n"
  "/**\n"
  " * Should be called when the traverser has finished traversing its scene, this\n"
  " * gives it a chance to do any necessary finalization.\n"
  " */";
#else
static const char *Dtool_PipeOcclusionCullTraverser_end_traverse_259_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsOutput *PipeOcclusionCullTraverser::get_buffer(void) const
 */
static PyObject *Dtool_PipeOcclusionCullTraverser_get_buffer_260(PyObject *self, PyObject *) {
  PipeOcclusionCullTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PipeOcclusionCullTraverser, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline GraphicsOutput *PipeOcclusionCullTraverser::get_buffer(void) const
  GraphicsOutput *return_value = (*(const PipeOcclusionCullTraverser*)local_this).get_buffer();
  if (return_value != (GraphicsOutput *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (GraphicsOutput *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutput, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PipeOcclusionCullTraverser_get_buffer_260_comment =
  "C++ Interface:\n"
  "get_buffer(PipeOcclusionCullTraverser self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PipeOcclusionCullTraverser_get_buffer_260_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Texture *PipeOcclusionCullTraverser::get_texture(void)
 */
static PyObject *Dtool_PipeOcclusionCullTraverser_get_texture_261(PyObject *self, PyObject *) {
  PipeOcclusionCullTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PipeOcclusionCullTraverser, (void **)&local_this, "PipeOcclusionCullTraverser.get_texture")) {
    return NULL;
  }
  // 1-Texture *PipeOcclusionCullTraverser::get_texture(void)
  Texture *return_value = (*local_this).get_texture();
  if (return_value != (Texture *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (Texture *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PipeOcclusionCullTraverser_get_texture_261_comment =
  "C++ Interface:\n"
  "get_texture(const PipeOcclusionCullTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns a Texture that can be used to visualize the efforts of the\n"
  " * occlusion cull.\n"
  " */";
#else
static const char *Dtool_PipeOcclusionCullTraverser_get_texture_261_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PipeOcclusionCullTraverser::set_occlusion_mask(DrawMask const &occlusion_mask)
 */
static PyObject *Dtool_PipeOcclusionCullTraverser_set_occlusion_mask_262(PyObject *self, PyObject *arg) {
  PipeOcclusionCullTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PipeOcclusionCullTraverser, (void **)&local_this, "PipeOcclusionCullTraverser.set_occlusion_mask")) {
    return NULL;
  }
  // 1-inline void PipeOcclusionCullTraverser::set_occlusion_mask(DrawMask const &occlusion_mask)
  BitMask< uint32_t, 32 > arg_local;
  DrawMask const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PipeOcclusionCullTraverser.set_occlusion_mask", "BitMask");
  }
  (*local_this).set_occlusion_mask(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_occlusion_mask(const PipeOcclusionCullTraverser self, const BitMask occlusion_mask)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PipeOcclusionCullTraverser_set_occlusion_mask_262_comment =
  "C++ Interface:\n"
  "set_occlusion_mask(const PipeOcclusionCullTraverser self, const BitMask occlusion_mask)\n"
  "\n"
  "/**\n"
  " * Specifies the DrawMask that should be set on occlusion polygons for this\n"
  " * scene.  This identifies the polygons that are to be treated as occluders.\n"
  " * Polygons that do not have this draw mask set will not be considered\n"
  " * occluders.\n"
  " */";
#else
static const char *Dtool_PipeOcclusionCullTraverser_set_occlusion_mask_262_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DrawMask const &PipeOcclusionCullTraverser::get_occlusion_mask(void) const
 */
static PyObject *Dtool_PipeOcclusionCullTraverser_get_occlusion_mask_263(PyObject *self, PyObject *) {
  PipeOcclusionCullTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PipeOcclusionCullTraverser, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline DrawMask const &PipeOcclusionCullTraverser::get_occlusion_mask(void) const
  DrawMask const *return_value = &((*(const PipeOcclusionCullTraverser*)local_this).get_occlusion_mask());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PipeOcclusionCullTraverser_get_occlusion_mask_263_comment =
  "C++ Interface:\n"
  "get_occlusion_mask(PipeOcclusionCullTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns the DrawMask for occlusion polygons.  See set_occlusion_mask().\n"
  " */";
#else
static const char *Dtool_PipeOcclusionCullTraverser_get_occlusion_mask_263_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PipeOcclusionCullTraverser::get_class_type(void)
 */
static PyObject *Dtool_PipeOcclusionCullTraverser_get_class_type_264(PyObject *, PyObject *) {
  // 1-static TypeHandle PipeOcclusionCullTraverser::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PipeOcclusionCullTraverser::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PipeOcclusionCullTraverser_get_class_type_264_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PipeOcclusionCullTraverser_get_class_type_264_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CullTraverser *PipeOcclusionCullTraverser::upcast_to_CullTraverser(void)
 */
static PyObject *Dtool_PipeOcclusionCullTraverser_upcast_to_CullTraverser_252(PyObject *self, PyObject *) {
  PipeOcclusionCullTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PipeOcclusionCullTraverser, (void **)&local_this, "PipeOcclusionCullTraverser.upcast_to_CullTraverser")) {
    return NULL;
  }
  // 1-CullTraverser *PipeOcclusionCullTraverser::upcast_to_CullTraverser(void)
  CullTraverser *return_value = (CullTraverser *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CullTraverser, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PipeOcclusionCullTraverser_upcast_to_CullTraverser_252_comment =
  "C++ Interface:\n"
  "upcast_to_CullTraverser(const PipeOcclusionCullTraverser self)\n"
  "\n"
  "upcast from PipeOcclusionCullTraverser to CullTraverser";
#else
static const char *Dtool_PipeOcclusionCullTraverser_upcast_to_CullTraverser_252_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PipeOcclusionCullTraverser::PipeOcclusionCullTraverser(GraphicsOutput *host)
 * PipeOcclusionCullTraverser::PipeOcclusionCullTraverser(PipeOcclusionCullTraverser const &copy)
 */
static int Dtool_Init_PipeOcclusionCullTraverser(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PipeOcclusionCullTraverser() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 PipeOcclusionCullTraverser::PipeOcclusionCullTraverser(PipeOcclusionCullTraverser const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PipeOcclusionCullTraverser", (char **)keyword_list, &param0)) {
      PipeOcclusionCullTraverser const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PipeOcclusionCullTraverser, (void **)&param0_this);
      if (param0_this != NULL) {
        PipeOcclusionCullTraverser *return_value = new PipeOcclusionCullTraverser(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PipeOcclusionCullTraverser, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 PipeOcclusionCullTraverser::PipeOcclusionCullTraverser(GraphicsOutput *host)
    PyObject *param0;
    static const char *keyword_list[] = {"host", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PipeOcclusionCullTraverser", (char **)keyword_list, &param0)) {
      GraphicsOutput *param0_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GraphicsOutput, 0, "PipeOcclusionCullTraverser.PipeOcclusionCullTraverser", false, false);
      if (param0_this != NULL) {
        PipeOcclusionCullTraverser *return_value = new PipeOcclusionCullTraverser(param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PipeOcclusionCullTraverser, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 PipeOcclusionCullTraverser::PipeOcclusionCullTraverser(PipeOcclusionCullTraverser const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PipeOcclusionCullTraverser", (char **)keyword_list, &param0)) {
      CPT(PipeOcclusionCullTraverser) param0_this;
      if (Dtool_ConstCoerce_PipeOcclusionCullTraverser(param0, param0_this)) {
        PipeOcclusionCullTraverser *return_value = new PipeOcclusionCullTraverser(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PipeOcclusionCullTraverser, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: PipeOcclusionCullTraverser::PipeOcclusionCullTraverser(GraphicsOutput *host)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PipeOcclusionCullTraverser(const PipeOcclusionCullTraverser copy)\n"
      "PipeOcclusionCullTraverser(GraphicsOutput host)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PipeOcclusionCullTraverser(PyObject *args, CPT(PipeOcclusionCullTraverser) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PipeOcclusionCullTraverser, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PipeOcclusionCullTraverser::PipeOcclusionCullTraverser(GraphicsOutput *host)
    GraphicsOutput *arg_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsOutput, 0, "PipeOcclusionCullTraverser.PipeOcclusionCullTraverser", false, false);
    if (arg_this != NULL) {
      PipeOcclusionCullTraverser *return_value = new PipeOcclusionCullTraverser(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_PipeOcclusionCullTraverser(PyObject *args, PT(PipeOcclusionCullTraverser) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PipeOcclusionCullTraverser, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PipeOcclusionCullTraverser::PipeOcclusionCullTraverser(GraphicsOutput *host)
    GraphicsOutput *arg_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsOutput, 0, "PipeOcclusionCullTraverser.PipeOcclusionCullTraverser", false, false);
    if (arg_this != NULL) {
      PipeOcclusionCullTraverser *return_value = new PipeOcclusionCullTraverser(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_PipeOcclusionCullTraverser(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PipeOcclusionCullTraverser) {
    printf("PipeOcclusionCullTraverser ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PipeOcclusionCullTraverser *local_this = (PipeOcclusionCullTraverser *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PipeOcclusionCullTraverser) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CullTraverser) {
    return (CullTraverser *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CullTraverser *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CullTraverser *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CullTraverser *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PipeOcclusionCullTraverser(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PipeOcclusionCullTraverser) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CullTraverser) {
    CullTraverser* other_this = (CullTraverser*)from_this;
    return (PipeOcclusionCullTraverser*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PipeOcclusionCullTraverser*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PipeOcclusionCullTraverser*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (PipeOcclusionCullTraverser*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PfmVizzer
 */
/**
 * Python function wrapper for:
 * inline PfmFile &PfmVizzer::get_pfm(void)
 * inline PfmFile const &PfmVizzer::get_pfm(void) const
 */
static PyObject *Dtool_PfmVizzer_get_pfm_268(PyObject *self, PyObject *) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmVizzer, (void **)&local_this)) {
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 inline PfmFile &PfmVizzer::get_pfm(void)
    PfmFile *return_value = &((*local_this).get_pfm());
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PfmFile, false, false);
  }

  {
    // -2 inline PfmFile const &PfmVizzer::get_pfm(void) const
    PfmFile const *return_value = &((*(const PfmVizzer*)local_this).get_pfm());
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PfmFile, false, true);
  }

  // No coercion possible: inline PfmFile &PfmVizzer::get_pfm(void)
  // No coercion possible: inline PfmFile const &PfmVizzer::get_pfm(void) const
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_get_pfm_268_comment =
  "C++ Interface:\n"
  "get_pfm(const PfmVizzer self)\n"
  "get_pfm(PfmVizzer self)\n"
  "\n"
  "/**\n"
  " * Returns the reference to the PfmFile manipulated by this PfmVizzer.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the reference to the PfmFile manipulated by this PfmVizzer.\n"
  " */";
#else
static const char *Dtool_PfmVizzer_get_pfm_268_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmVizzer::project(Lens const *lens, PfmFile const *undist_lut = 0)
 */
static PyObject *Dtool_PfmVizzer_project_269(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmVizzer, (void **)&local_this, "PfmVizzer.project")) {
    return NULL;
  }
  // 1-void PfmVizzer::project(Lens const *lens, PfmFile const *undist_lut = 0)
  PyObject *param1;
  PyObject *param2 = NULL;
  static const char *keyword_list[] = {"lens", "undist_lut", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:project", (char **)keyword_list, &param1, &param2)) {
    Lens const *param1_this = (Lens *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Lens, 1, "PfmVizzer.project", true, true);
    PfmFile const *param2_this = 0;
    if (param2 != (PyObject *)NULL) {
      param2_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PfmFile, 2, "PfmVizzer.project", true, true);
    }
    if (param1_this != NULL && (param2 == NULL || param2_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*local_this).project(param1_this, param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(const PfmVizzer self, const Lens lens, const PfmFile undist_lut)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_project_269_comment =
  "C++ Interface:\n"
  "project(const PfmVizzer self, const Lens lens, const PfmFile undist_lut)\n"
  "\n"
  "/**\n"
  " * Adjusts each (x, y, z) point of the Pfm file by projecting it through the\n"
  " * indicated lens, converting each point to a (u, v, w) texture coordinate.\n"
  " * The resulting file can be generated to a mesh (with set_vis_inverse(true)\n"
  " * and generate_vis_mesh()) that will apply the lens distortion to an\n"
  " * arbitrary texture image.\n"
  " */";
#else
static const char *Dtool_PfmVizzer_project_269_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmVizzer::extrude(Lens const *lens)
 */
static PyObject *Dtool_PfmVizzer_extrude_270(PyObject *self, PyObject *arg) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmVizzer, (void **)&local_this, "PfmVizzer.extrude")) {
    return NULL;
  }
  // 1-void PfmVizzer::extrude(Lens const *lens)
  Lens const *arg_this = (Lens *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Lens, 1, "PfmVizzer.extrude", true, true);
  if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).extrude(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extrude(const PfmVizzer self, const Lens lens)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_extrude_270_comment =
  "C++ Interface:\n"
  "extrude(const PfmVizzer self, const Lens lens)\n"
  "\n"
  "/**\n"
  " * Converts each (u, v, depth) point of the Pfm file to an (x, y, z) point, by\n"
  " * reversing project().  If the original file is only a 1-d file, assumes that\n"
  " * it is a depth map with implicit (u, v) coordinates.\n"
  " *\n"
  " * This method is only valid for a linear lens (e.g.  a PerspectiveLens or\n"
  " * OrthographicLens).  Non-linear lenses don't necessarily compute a sensible\n"
  " * depth coordinate.\n"
  " */";
#else
static const char *Dtool_PfmVizzer_extrude_270_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmVizzer::set_vis_inverse(bool vis_inverse)
 */
static PyObject *Dtool_PfmVizzer_set_vis_inverse_271(PyObject *self, PyObject *arg) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmVizzer, (void **)&local_this, "PfmVizzer.set_vis_inverse")) {
    return NULL;
  }
  // 1-inline void PfmVizzer::set_vis_inverse(bool vis_inverse)
  (*local_this).set_vis_inverse((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vis_inverse(const PfmVizzer self, bool vis_inverse)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_set_vis_inverse_271_comment =
  "C++ Interface:\n"
  "set_vis_inverse(const PfmVizzer self, bool vis_inverse)\n"
  "\n"
  "/**\n"
  " * Sets the vis_inverse flag.  When this flag is true, vis meshes and point\n"
  " * clouds are generated with the 3-d depth value in the texture coordinates,\n"
  " * and the 2-d index value in the vertex position.  When it is false, meshes\n"
  " * are generated normally, with the 3-d depth value in the vertex position and\n"
  " * the 2-d index value in the texture coordinates.\n"
  " *\n"
  " * This may be used in lieu of the lower-level add_vis_column().\n"
  " */";
#else
static const char *Dtool_PfmVizzer_set_vis_inverse_271_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PfmVizzer::get_vis_inverse(void) const
 */
static PyObject *Dtool_PfmVizzer_get_vis_inverse_272(PyObject *self, PyObject *) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmVizzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PfmVizzer::get_vis_inverse(void) const
  bool return_value = (*(const PfmVizzer*)local_this).get_vis_inverse();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_get_vis_inverse_272_comment =
  "C++ Interface:\n"
  "get_vis_inverse(PfmVizzer self)\n"
  "\n"
  "/**\n"
  " * Returns the vis_inverse flag.  See set_vis_inverse().\n"
  " */";
#else
static const char *Dtool_PfmVizzer_get_vis_inverse_272_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmVizzer::set_flat_texcoord_name(InternalName *flat_texcoord_name)
 */
static PyObject *Dtool_PfmVizzer_set_flat_texcoord_name_273(PyObject *self, PyObject *arg) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmVizzer, (void **)&local_this, "PfmVizzer.set_flat_texcoord_name")) {
    return NULL;
  }
  // 1-inline void PfmVizzer::set_flat_texcoord_name(InternalName *flat_texcoord_name)
  PT(InternalName) arg_this;
  if (!Dtool_Coerce_InternalName(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PfmVizzer.set_flat_texcoord_name", "InternalName");
  }
  (*local_this).set_flat_texcoord_name(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_flat_texcoord_name(const PfmVizzer self, InternalName flat_texcoord_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_set_flat_texcoord_name_273_comment =
  "C++ Interface:\n"
  "set_flat_texcoord_name(const PfmVizzer self, InternalName flat_texcoord_name)\n"
  "\n"
  "/**\n"
  " * If the flat_texcoord_name is specified, it is the name of an additional\n"
  " * vertex column that will be created for the \"flat\" texture coordinates, i.e.\n"
  " * the original 0..1 values that correspond to the 2-D index position of each\n"
  " * point in the original pfm file.\n"
  " *\n"
  " * These are the same values that will be assigned to the default texture\n"
  " * coordinates if the vis_inverse flag is *not* true.\n"
  " *\n"
  " * This may be used in lieu of the lower-level add_vis_column().\n"
  " */";
#else
static const char *Dtool_PfmVizzer_set_flat_texcoord_name_273_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmVizzer::clear_flat_texcoord_name(void)
 */
static PyObject *Dtool_PfmVizzer_clear_flat_texcoord_name_274(PyObject *self, PyObject *) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmVizzer, (void **)&local_this, "PfmVizzer.clear_flat_texcoord_name")) {
    return NULL;
  }
  // 1-inline void PfmVizzer::clear_flat_texcoord_name(void)
  (*local_this).clear_flat_texcoord_name();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_clear_flat_texcoord_name_274_comment =
  "C++ Interface:\n"
  "clear_flat_texcoord_name(const PfmVizzer self)\n"
  "\n"
  "/**\n"
  " * Resets the flat_texcoord_name to empty, so that additional texture\n"
  " * coordinates are not created.\n"
  " *\n"
  " * This may be used in lieu of the lower-level add_vis_column().\n"
  " */";
#else
static const char *Dtool_PfmVizzer_clear_flat_texcoord_name_274_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline InternalName *PfmVizzer::get_flat_texcoord_name(void) const
 */
static PyObject *Dtool_PfmVizzer_get_flat_texcoord_name_275(PyObject *self, PyObject *) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmVizzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline InternalName *PfmVizzer::get_flat_texcoord_name(void) const
  InternalName *return_value = (*(const PfmVizzer*)local_this).get_flat_texcoord_name();
  if (return_value != (InternalName *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (InternalName *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_InternalName, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_get_flat_texcoord_name_275_comment =
  "C++ Interface:\n"
  "get_flat_texcoord_name(PfmVizzer self)\n"
  "\n"
  "/**\n"
  " * Returns the flat_texcoord_name.  See set_flat_texcoord_name().\n"
  " */";
#else
static const char *Dtool_PfmVizzer_get_flat_texcoord_name_275_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmVizzer::set_vis_2d(bool vis_2d)
 */
static PyObject *Dtool_PfmVizzer_set_vis_2d_276(PyObject *self, PyObject *arg) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmVizzer, (void **)&local_this, "PfmVizzer.set_vis_2d")) {
    return NULL;
  }
  // 1-inline void PfmVizzer::set_vis_2d(bool vis_2d)
  (*local_this).set_vis_2d((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vis_2d(const PfmVizzer self, bool vis_2d)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_set_vis_2d_276_comment =
  "C++ Interface:\n"
  "set_vis_2d(const PfmVizzer self, bool vis_2d)\n"
  "\n"
  "/**\n"
  " * Sets the vis_2d flag.  When this flag is true, only the first two (x, y)\n"
  " * value of each depth point is considered meaningful; the z component is\n"
  " * ignored.  This is only relevant for generating visualizations.\n"
  " *\n"
  " * This may be used in lieu of the lower-level add_vis_column().\n"
  " */";
#else
static const char *Dtool_PfmVizzer_set_vis_2d_276_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PfmVizzer::get_vis_2d(void) const
 */
static PyObject *Dtool_PfmVizzer_get_vis_2d_277(PyObject *self, PyObject *) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmVizzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PfmVizzer::get_vis_2d(void) const
  bool return_value = (*(const PfmVizzer*)local_this).get_vis_2d();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_get_vis_2d_277_comment =
  "C++ Interface:\n"
  "get_vis_2d(PfmVizzer self)\n"
  "\n"
  "/**\n"
  " * Returns the vis_2d flag.  See set_vis_2d().\n"
  " */";
#else
static const char *Dtool_PfmVizzer_get_vis_2d_277_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmVizzer::set_keep_beyond_lens(bool keep_beyond_lens)
 */
static PyObject *Dtool_PfmVizzer_set_keep_beyond_lens_278(PyObject *self, PyObject *arg) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmVizzer, (void **)&local_this, "PfmVizzer.set_keep_beyond_lens")) {
    return NULL;
  }
  // 1-inline void PfmVizzer::set_keep_beyond_lens(bool keep_beyond_lens)
  (*local_this).set_keep_beyond_lens((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_keep_beyond_lens(const PfmVizzer self, bool keep_beyond_lens)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_set_keep_beyond_lens_278_comment =
  "C++ Interface:\n"
  "set_keep_beyond_lens(const PfmVizzer self, bool keep_beyond_lens)\n"
  "\n"
  "/**\n"
  " * Sets the keep_beyond_lens flag.  When this flag is true, points that fall\n"
  " * outside of the normal lens range in project() or in add_vis_column() will\n"
  " * be retained anyway; when it is false, these points will be discarded.\n"
  " */";
#else
static const char *Dtool_PfmVizzer_set_keep_beyond_lens_278_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PfmVizzer::get_keep_beyond_lens(void) const
 */
static PyObject *Dtool_PfmVizzer_get_keep_beyond_lens_279(PyObject *self, PyObject *) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmVizzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PfmVizzer::get_keep_beyond_lens(void) const
  bool return_value = (*(const PfmVizzer*)local_this).get_keep_beyond_lens();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_get_keep_beyond_lens_279_comment =
  "C++ Interface:\n"
  "get_keep_beyond_lens(PfmVizzer self)\n"
  "\n"
  "/**\n"
  " * Returns the keep_beyond_lens flag.  See set_keep_beyond_lens().\n"
  " */";
#else
static const char *Dtool_PfmVizzer_get_keep_beyond_lens_279_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmVizzer::set_vis_blend(PNMImage const *vis_blend)
 */
static PyObject *Dtool_PfmVizzer_set_vis_blend_280(PyObject *self, PyObject *arg) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmVizzer, (void **)&local_this, "PfmVizzer.set_vis_blend")) {
    return NULL;
  }
  // 1-inline void PfmVizzer::set_vis_blend(PNMImage const *vis_blend)
  PNMImage const *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 1, "PfmVizzer.set_vis_blend", true, true);
  if (arg_this != NULL) {
    (*local_this).set_vis_blend(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vis_blend(const PfmVizzer self, const PNMImage vis_blend)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_set_vis_blend_280_comment =
  "C++ Interface:\n"
  "set_vis_blend(const PfmVizzer self, const PNMImage vis_blend)\n"
  "\n"
  "/**\n"
  " * Specifies a blending map--a grayscale image--that will be applied to the\n"
  " * vertex color during generate_vis_mesh() and generate_vis_points().  The\n"
  " * image size must exactly match the mesh size of the PfmVizzer.\n"
  " *\n"
  " * Ownership of the pointer is not kept by the PfmVizzer; it is your\n"
  " * responsibility to ensure it does not destruct during the lifetime of the\n"
  " * PfmVizzer (or at least not before your subsequent call to\n"
  " * generate_vis_mesh()).\n"
  " */";
#else
static const char *Dtool_PfmVizzer_set_vis_blend_280_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmVizzer::clear_vis_blend(void)
 */
static PyObject *Dtool_PfmVizzer_clear_vis_blend_281(PyObject *self, PyObject *) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmVizzer, (void **)&local_this, "PfmVizzer.clear_vis_blend")) {
    return NULL;
  }
  // 1-inline void PfmVizzer::clear_vis_blend(void)
  (*local_this).clear_vis_blend();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_clear_vis_blend_281_comment =
  "C++ Interface:\n"
  "clear_vis_blend(const PfmVizzer self)\n"
  "\n"
  "/**\n"
  " * Removes the blending map set by a prior call to set_vis_blend().\n"
  " */";
#else
static const char *Dtool_PfmVizzer_clear_vis_blend_281_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PNMImage const *PfmVizzer::get_vis_blend(void) const
 */
static PyObject *Dtool_PfmVizzer_get_vis_blend_282(PyObject *self, PyObject *) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmVizzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PNMImage const *PfmVizzer::get_vis_blend(void) const
  PNMImage const *return_value = (*(const PfmVizzer*)local_this).get_vis_blend();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_get_vis_blend_282_comment =
  "C++ Interface:\n"
  "get_vis_blend(PfmVizzer self)\n"
  "\n"
  "/**\n"
  " * Returns the blending map set by the most recent call to set_vis_blend(), or\n"
  " * NULL if there is no blending map in effect.\n"
  " */";
#else
static const char *Dtool_PfmVizzer_get_vis_blend_282_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmVizzer::set_aux_pfm(PfmFile const *pfm)
 */
static PyObject *Dtool_PfmVizzer_set_aux_pfm_283(PyObject *self, PyObject *arg) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmVizzer, (void **)&local_this, "PfmVizzer.set_aux_pfm")) {
    return NULL;
  }
  // 1-inline void PfmVizzer::set_aux_pfm(PfmFile const *pfm)
  PfmFile const *arg_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PfmFile, 1, "PfmVizzer.set_aux_pfm", true, true);
  if (arg_this != NULL) {
    (*local_this).set_aux_pfm(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_aux_pfm(const PfmVizzer self, const PfmFile pfm)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_set_aux_pfm_283_comment =
  "C++ Interface:\n"
  "set_aux_pfm(const PfmVizzer self, const PfmFile pfm)\n"
  "\n"
  "/**\n"
  " * Assigns an auxiliary PfmFile to this PfmVizzer.  This file will be queried\n"
  " * by column types CT_aux_vertex1/2/3, but has no other meaning to the vizzer.\n"
  " * This size of this PfmFile should exactly match the base PfmFile.  No\n"
  " * reference count is held and no copy is made; the caller is responsible for\n"
  " * ensuring that the auxiliary PfmFile will persist throughout the lifetime of\n"
  " * the PfmVizzer it is assigned to.\n"
  " */";
#else
static const char *Dtool_PfmVizzer_set_aux_pfm_283_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PfmVizzer::clear_aux_pfm(void)
 */
static PyObject *Dtool_PfmVizzer_clear_aux_pfm_284(PyObject *self, PyObject *) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmVizzer, (void **)&local_this, "PfmVizzer.clear_aux_pfm")) {
    return NULL;
  }
  // 1-inline void PfmVizzer::clear_aux_pfm(void)
  (*local_this).clear_aux_pfm();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_clear_aux_pfm_284_comment =
  "C++ Interface:\n"
  "clear_aux_pfm(const PfmVizzer self)\n"
  "\n"
  "/**\n"
  " * Removes the auxiliary PfmFile from this PfmVizzer.\n"
  " */";
#else
static const char *Dtool_PfmVizzer_clear_aux_pfm_284_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PfmFile const *PfmVizzer::get_aux_pfm(void) const
 */
static PyObject *Dtool_PfmVizzer_get_aux_pfm_285(PyObject *self, PyObject *) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmVizzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PfmFile const *PfmVizzer::get_aux_pfm(void) const
  PfmFile const *return_value = (*(const PfmVizzer*)local_this).get_aux_pfm();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PfmFile, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_get_aux_pfm_285_comment =
  "C++ Interface:\n"
  "get_aux_pfm(PfmVizzer self)\n"
  "\n"
  "/**\n"
  " * Returns the reference to the auxiliary PfmFile queried by this PfmVizzer.\n"
  " * This contains the values that will be reflected in CT_aux_vertex3 etc.  See\n"
  " * set_aux_pfm().\n"
  " */";
#else
static const char *Dtool_PfmVizzer_get_aux_pfm_285_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmVizzer::clear_vis_columns(void)
 */
static PyObject *Dtool_PfmVizzer_clear_vis_columns_287(PyObject *self, PyObject *) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmVizzer, (void **)&local_this, "PfmVizzer.clear_vis_columns")) {
    return NULL;
  }
  // 1-void PfmVizzer::clear_vis_columns(void)
  (*local_this).clear_vis_columns();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_clear_vis_columns_287_comment =
  "C++ Interface:\n"
  "clear_vis_columns(const PfmVizzer self)\n"
  "\n"
  "/**\n"
  " * Removes all of the previously-added vis columns in preparation for building\n"
  " * a new list.  See add_vis_column().\n"
  " */";
#else
static const char *Dtool_PfmVizzer_clear_vis_columns_287_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmVizzer::add_vis_column(PfmVizzer::ColumnType source, PfmVizzer::ColumnType target, InternalName *name, TransformState const *transform = 0, Lens const *lens = 0, PfmFile const *undist_lut = 0)
 */
static PyObject *Dtool_PfmVizzer_add_vis_column_288(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmVizzer, (void **)&local_this, "PfmVizzer.add_vis_column")) {
    return NULL;
  }
  // 1-void PfmVizzer::add_vis_column(PfmVizzer::ColumnType source, PfmVizzer::ColumnType target, InternalName *name, TransformState const *transform = 0, Lens const *lens = 0, PfmFile const *undist_lut = 0)
  int param1;
  int param2;
  PyObject *param3;
  PyObject *param4 = NULL;
  PyObject *param5 = NULL;
  PyObject *param6 = NULL;
  static const char *keyword_list[] = {"source", "target", "name", "transform", "lens", "undist_lut", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO|OOO:add_vis_column", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
    PT(InternalName) param3_this;
    if (!Dtool_Coerce_InternalName(param3, param3_this)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "PfmVizzer.add_vis_column", "InternalName");
    }
    TransformState const *param4_this = 0;
    if (param4 != (PyObject *)NULL) {
      param4_this = (TransformState *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_TransformState, 4, "PfmVizzer.add_vis_column", true, true);
    }
    Lens const *param5_this = 0;
    if (param5 != (PyObject *)NULL) {
      param5_this = (Lens *)DTOOL_Call_GetPointerThisClass(param5, Dtool_Ptr_Lens, 5, "PfmVizzer.add_vis_column", true, true);
    }
    PfmFile const *param6_this = 0;
    if (param6 != (PyObject *)NULL) {
      param6_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param6, Dtool_Ptr_PfmFile, 6, "PfmVizzer.add_vis_column", true, true);
    }
    if ((param4 == NULL || param4_this != NULL) && (param5 == NULL || param5_this != NULL) && (param6 == NULL || param6_this != NULL)) {
      (*local_this).add_vis_column((PfmVizzer::ColumnType)param1, (PfmVizzer::ColumnType)param2, MOVE(param3_this), param4_this, param5_this, param6_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_vis_column(const PfmVizzer self, int source, int target, InternalName name, const TransformState transform, const Lens lens, const PfmFile undist_lut)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_add_vis_column_288_comment =
  "C++ Interface:\n"
  "add_vis_column(const PfmVizzer self, int source, int target, InternalName name, const TransformState transform, const Lens lens, const PfmFile undist_lut)\n"
  "\n"
  "/**\n"
  " * Adds a new vis column specification to the list of vertex data columns that\n"
  " * will be generated at the next call to generate_vis_points() or\n"
  " * generate_vis_mesh().  This advanced interface supercedes the higher-level\n"
  " * set_vis_inverse(), set_flat_texcoord_name(), and set_vis_2d().\n"
  " *\n"
  " * If you use this advanced interface, you must specify explicitly the\n"
  " * complete list of data columns to be created in the resulting\n"
  " * GeomVertexData, by calling add_vis_column() each time.  For each column,\n"
  " * you specify the source of the column in the PFMFile, the target column and\n"
  " * name in the GeomVertexData, and an optional transform matrix and/or lens to\n"
  " * transform and project the point before generating it.\n"
  " */\n"
  "\n"
  "/**\n"
  " * The private implementation of the public add_vis_column(), this adds the\n"
  " * column to the indicated specific vector.\n"
  " */";
#else
static const char *Dtool_PfmVizzer_add_vis_column_288_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePath PfmVizzer::generate_vis_points(void) const
 */
static PyObject *Dtool_PfmVizzer_generate_vis_points_289(PyObject *self, PyObject *) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmVizzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-NodePath PfmVizzer::generate_vis_points(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  NodePath *return_value = new NodePath((*(const PfmVizzer*)local_this).generate_vis_points());
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_generate_vis_points_289_comment =
  "C++ Interface:\n"
  "generate_vis_points(PfmVizzer self)\n"
  "\n"
  "/**\n"
  " * Creates a point cloud with the points of the pfm as 3-d coordinates in\n"
  " * space, and texture coordinates ranging from 0 .. 1 based on the position\n"
  " * within the pfm grid.\n"
  " */";
#else
static const char *Dtool_PfmVizzer_generate_vis_points_289_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePath PfmVizzer::generate_vis_mesh(PfmVizzer::MeshFace face = ::PfmVizzer::MF_front) const
 */
static PyObject *Dtool_PfmVizzer_generate_vis_mesh_291(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmVizzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-NodePath PfmVizzer::generate_vis_mesh(PfmVizzer::MeshFace face = ::PfmVizzer::MF_front) const
  int param1 = PfmVizzer::MF_front;
  static const char *keyword_list[] = {"face", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:generate_vis_mesh", (char **)keyword_list, &param1)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    NodePath *return_value = new NodePath((*(const PfmVizzer*)local_this).generate_vis_mesh((PfmVizzer::MeshFace)param1));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "generate_vis_mesh(PfmVizzer self, int face)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_generate_vis_mesh_291_comment =
  "C++ Interface:\n"
  "generate_vis_mesh(PfmVizzer self, int face)\n"
  "\n"
  "/**\n"
  " * Creates a triangle mesh with the points of the pfm as 3-d coordinates in\n"
  " * space, and texture coordinates ranging from 0 .. 1 based on the position\n"
  " * within the pfm grid.\n"
  " */";
#else
static const char *Dtool_PfmVizzer_generate_vis_mesh_291_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double PfmVizzer::calc_max_u_displacement(void) const
 */
static PyObject *Dtool_PfmVizzer_calc_max_u_displacement_292(PyObject *self, PyObject *) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmVizzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-double PfmVizzer::calc_max_u_displacement(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  double return_value = (*(const PfmVizzer*)local_this).calc_max_u_displacement();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_calc_max_u_displacement_292_comment =
  "C++ Interface:\n"
  "calc_max_u_displacement(PfmVizzer self)\n"
  "\n"
  "/**\n"
  " * Computes the maximum amount of shift, in pixels either left or right, of\n"
  " * any pixel in the distortion map.  This can be passed to\n"
  " * make_displacement(); see that function for more information.\n"
  " */";
#else
static const char *Dtool_PfmVizzer_calc_max_u_displacement_292_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double PfmVizzer::calc_max_v_displacement(void) const
 */
static PyObject *Dtool_PfmVizzer_calc_max_v_displacement_293(PyObject *self, PyObject *) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmVizzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-double PfmVizzer::calc_max_v_displacement(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  double return_value = (*(const PfmVizzer*)local_this).calc_max_v_displacement();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_calc_max_v_displacement_293_comment =
  "C++ Interface:\n"
  "calc_max_v_displacement(PfmVizzer self)\n"
  "\n"
  "/**\n"
  " * Computes the maximum amount of shift, in pixels either up or down, of any\n"
  " * pixel in the distortion map.  This can be passed to make_displacement();\n"
  " * see that function for more information.\n"
  " */";
#else
static const char *Dtool_PfmVizzer_calc_max_v_displacement_293_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PfmVizzer::make_displacement(PNMImage &result, double max_u, double max_v, bool for_32bit) const
 * void PfmVizzer::make_displacement(PfmFile &result, double max_u, double max_v, bool for_32bit) const
 */
static PyObject *Dtool_PfmVizzer_make_displacement_294(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmVizzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmVizzer, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 void PfmVizzer::make_displacement(PfmFile &result, double max_u, double max_v, bool for_32bit) const
    PyObject *param1;
    double param2;
    double param3;
    PyObject *param4;
    static const char *keyword_list[] = {"result", "max_u", "max_v", "for_32bit", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OddO:make_displacement", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      PfmFile *param1_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PfmFile, 1, "PfmVizzer.make_displacement", false, false);
      if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        (*(const PfmVizzer*)local_this).make_displacement(*param1_this, (double)param2, (double)param3, (PyObject_IsTrue(param4) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void PfmVizzer::make_displacement(PNMImage &result, double max_u, double max_v, bool for_32bit) const
    PyObject *param1;
    double param2;
    double param3;
    PyObject *param4;
    static const char *keyword_list[] = {"result", "max_u", "max_v", "for_32bit", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OddO:make_displacement", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PfmVizzer.make_displacement", false, false);
      if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        (*(const PfmVizzer*)local_this).make_displacement(*param1_this, (double)param2, (double)param3, (PyObject_IsTrue(param4) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: void PfmVizzer::make_displacement(PfmFile &result, double max_u, double max_v, bool for_32bit) const
  // No coercion possible: void PfmVizzer::make_displacement(PNMImage &result, double max_u, double max_v, bool for_32bit) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_displacement(PfmVizzer self, PfmFile result, double max_u, double max_v, bool for_32bit)\n"
      "make_displacement(PfmVizzer self, PNMImage result, double max_u, double max_v, bool for_32bit)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PfmVizzer_make_displacement_294_comment =
  "C++ Interface:\n"
  "make_displacement(PfmVizzer self, PfmFile result, double max_u, double max_v, bool for_32bit)\n"
  "make_displacement(PfmVizzer self, PNMImage result, double max_u, double max_v, bool for_32bit)\n"
  "\n"
  "/**\n"
  " * Assuming the underlying PfmFile is a 2-d distortion mesh, with the U and V\n"
  " * in the first two components and the third component unused, this computes\n"
  " * an AfterEffects-style displacement map that represents the same distortion.\n"
  " * The indicated PNMImage will be filled in with a displacement map image,\n"
  " * with horizontal shift in the red channel and vertical shift in the green\n"
  " * channel, where a fully bright (or fully black) pixel indicates a shift of\n"
  " * max_u or max_v pixels.\n"
  " *\n"
  " * Use calc_max_u_displacement() and calc_max_v_displacement() to compute\n"
  " * suitable values for max_u and max_v.\n"
  " *\n"
  " * This generates an integer 16-bit displacement image.  It is a good idea,\n"
  " * though not necessarily essential, to check \"Preserve RGB\" in the interpret\n"
  " * footage section for each displacement image.  Set for_32bit true if this is\n"
  " * meant to be used in a 32-bit project file, and false if it is meant to be\n"
  " * used in a 16-bit project file.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Assuming the underlying PfmFile is a 2-d distortion mesh, with the U and V\n"
  " * in the first two components and the third component unused, this computes\n"
  " * an AfterEffects-style displacement map that represents the same distortion.\n"
  " * The indicated PNMImage will be filled in with a displacement map image,\n"
  " * with horizontal shift in the red channel and vertical shift in the green\n"
  " * channel, where a fully bright (or fully black) pixel indicates a shift of\n"
  " * max_u or max_v pixels.\n"
  " *\n"
  " * Use calc_max_u_displacement() and calc_max_v_displacement() to compute\n"
  " * suitable values for max_u and max_v.\n"
  " *\n"
  " * This generates a 32-bit floating-point displacement image.  It is essential\n"
  " * to check \"Preserve RGB\" in the interpret footage section for each\n"
  " * displacement image.  Set for_32bit true if this is meant to be used in a\n"
  " * 32-bit project file, and false if it is meant to be used in a 16-bit\n"
  " * project file.\n"
  " */";
#else
static const char *Dtool_PfmVizzer_make_displacement_294_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PfmVizzer::PfmVizzer(PfmFile &pfm)
 * inline PfmVizzer::PfmVizzer(PfmVizzer const &) = default
 */
static int Dtool_Init_PfmVizzer(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PfmVizzer() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline PfmVizzer::PfmVizzer(PfmVizzer const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PfmVizzer", (char **)keyword_list, &param0)) {
      PfmVizzer const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PfmVizzer, (void **)&param0_this);
      if (param0_this != NULL) {
        PfmVizzer *return_value = new PfmVizzer(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PfmVizzer, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 PfmVizzer::PfmVizzer(PfmFile &pfm)
    PyObject *param0;
    static const char *keyword_list[] = {"pfm", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PfmVizzer", (char **)keyword_list, &param0)) {
      PfmFile *param0_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PfmFile, 0, "PfmVizzer.PfmVizzer", false, false);
      if (param0_this != NULL) {
        PfmVizzer *return_value = new PfmVizzer(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PfmVizzer, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline PfmVizzer::PfmVizzer(PfmVizzer const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PfmVizzer", (char **)keyword_list, &param0)) {
      PfmVizzer const *param0_this;
      bool param0_manage = false;
      if (Dtool_ConstCoerce_PfmVizzer(param0, param0_this, param0_manage)) {
        PfmVizzer *return_value = new PfmVizzer(*param0_this);
        if (param0_manage) {
          delete param0_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PfmVizzer, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: PfmVizzer::PfmVizzer(PfmFile &pfm)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PfmVizzer(const PfmVizzer param0)\n"
      "PfmVizzer(PfmFile pfm)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PfmVizzer(PyObject *args, PfmVizzer const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PfmVizzer, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PfmVizzer::PfmVizzer(PfmFile &pfm)
    PfmFile *arg_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PfmFile, 0, "PfmVizzer.PfmVizzer", false, false);
    if (arg_this != NULL) {
      PfmVizzer *return_value = new PfmVizzer(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_PfmVizzer(PyObject *args, PfmVizzer *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PfmVizzer, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PfmVizzer::PfmVizzer(PfmFile &pfm)
    PfmFile *arg_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PfmFile, 0, "PfmVizzer.PfmVizzer", false, false);
    if (arg_this != NULL) {
      PfmVizzer *return_value = new PfmVizzer(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_PfmVizzer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PfmVizzer) {
    printf("PfmVizzer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PfmVizzer *local_this = (PfmVizzer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PfmVizzer) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PfmVizzer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PfmVizzer) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for CardMaker (CardMaker)
 */
static PyMethodDef Dtool_Methods_CardMaker[] = {
  {"reset", &Dtool_CardMaker_reset_5, METH_NOARGS, (const char *)Dtool_CardMaker_reset_5_comment},
  {"set_uv_range", (PyCFunction) &Dtool_CardMaker_set_uv_range_6, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CardMaker_set_uv_range_6_comment},
  {"setUvRange", (PyCFunction) &Dtool_CardMaker_set_uv_range_6, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CardMaker_set_uv_range_6_comment},
  {"set_uv_range_cube", &Dtool_CardMaker_set_uv_range_cube_7, METH_O, (const char *)Dtool_CardMaker_set_uv_range_cube_7_comment},
  {"setUvRangeCube", &Dtool_CardMaker_set_uv_range_cube_7, METH_O, (const char *)Dtool_CardMaker_set_uv_range_cube_7_comment},
  {"set_has_uvs", &Dtool_CardMaker_set_has_uvs_8, METH_O, (const char *)Dtool_CardMaker_set_has_uvs_8_comment},
  {"setHasUvs", &Dtool_CardMaker_set_has_uvs_8, METH_O, (const char *)Dtool_CardMaker_set_has_uvs_8_comment},
  {"set_has_3d_uvs", &Dtool_CardMaker_set_has_3d_uvs_9, METH_O, (const char *)Dtool_CardMaker_set_has_3d_uvs_9_comment},
  {"setHas3dUvs", &Dtool_CardMaker_set_has_3d_uvs_9, METH_O, (const char *)Dtool_CardMaker_set_has_3d_uvs_9_comment},
  {"set_frame", (PyCFunction) &Dtool_CardMaker_set_frame_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CardMaker_set_frame_10_comment},
  {"setFrame", (PyCFunction) &Dtool_CardMaker_set_frame_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CardMaker_set_frame_10_comment},
  {"set_frame_fullscreen_quad", &Dtool_CardMaker_set_frame_fullscreen_quad_11, METH_NOARGS, (const char *)Dtool_CardMaker_set_frame_fullscreen_quad_11_comment},
  {"setFrameFullscreenQuad", &Dtool_CardMaker_set_frame_fullscreen_quad_11, METH_NOARGS, (const char *)Dtool_CardMaker_set_frame_fullscreen_quad_11_comment},
  {"set_color", (PyCFunction) &Dtool_CardMaker_set_color_12, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CardMaker_set_color_12_comment},
  {"setColor", (PyCFunction) &Dtool_CardMaker_set_color_12, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CardMaker_set_color_12_comment},
  {"set_has_normals", &Dtool_CardMaker_set_has_normals_13, METH_O, (const char *)Dtool_CardMaker_set_has_normals_13_comment},
  {"setHasNormals", &Dtool_CardMaker_set_has_normals_13, METH_O, (const char *)Dtool_CardMaker_set_has_normals_13_comment},
  {"set_source_geometry", (PyCFunction) &Dtool_CardMaker_set_source_geometry_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CardMaker_set_source_geometry_14_comment},
  {"setSourceGeometry", (PyCFunction) &Dtool_CardMaker_set_source_geometry_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CardMaker_set_source_geometry_14_comment},
  {"clear_source_geometry", &Dtool_CardMaker_clear_source_geometry_15, METH_NOARGS, (const char *)Dtool_CardMaker_clear_source_geometry_15_comment},
  {"clearSourceGeometry", &Dtool_CardMaker_clear_source_geometry_15, METH_NOARGS, (const char *)Dtool_CardMaker_clear_source_geometry_15_comment},
  {"generate", &Dtool_CardMaker_generate_16, METH_NOARGS, (const char *)Dtool_CardMaker_generate_16_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CardMaker = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CardMaker = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CardMaker = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CardMaker = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CardMaker = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CardMaker",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CardMaker,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CardMaker,
    &Dtool_SequenceMethods_CardMaker,
    &Dtool_MappingMethods_CardMaker,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CardMaker,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class generates 2-d \"cards\", that is, rectangular polygons,\n"
    " * particularly useful for showing textures etc.  in the 2-d scene graph.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CardMaker,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CardMaker,
    PyType_GenericAlloc,
    Dtool_new_CardMaker,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CardMaker,
  Dtool_UpcastInterface_CardMaker,
  Dtool_DowncastInterface_CardMaker,
  (CoerceFunction)Dtool_ConstCoerce_CardMaker,
  (CoerceFunction)Dtool_Coerce_CardMaker,
};

static void Dtool_PyModuleClassInit_CardMaker(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Namable != NULL);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(NULL);
    Dtool_CardMaker._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Namable);
    PyObject *dict = PyDict_New();
    Dtool_CardMaker._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CardMaker) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CardMaker)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CardMaker);
  }
}

/**
 * Python method tables for FisheyeMaker (FisheyeMaker)
 */
static PyMethodDef Dtool_Methods_FisheyeMaker[] = {
  {"reset", &Dtool_FisheyeMaker_reset_20, METH_NOARGS, (const char *)Dtool_FisheyeMaker_reset_20_comment},
  {"set_fov", &Dtool_FisheyeMaker_set_fov_21, METH_O, (const char *)Dtool_FisheyeMaker_set_fov_21_comment},
  {"setFov", &Dtool_FisheyeMaker_set_fov_21, METH_O, (const char *)Dtool_FisheyeMaker_set_fov_21_comment},
  {"set_num_vertices", &Dtool_FisheyeMaker_set_num_vertices_22, METH_O, (const char *)Dtool_FisheyeMaker_set_num_vertices_22_comment},
  {"setNumVertices", &Dtool_FisheyeMaker_set_num_vertices_22, METH_O, (const char *)Dtool_FisheyeMaker_set_num_vertices_22_comment},
  {"set_square_inscribed", (PyCFunction) &Dtool_FisheyeMaker_set_square_inscribed_23, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FisheyeMaker_set_square_inscribed_23_comment},
  {"setSquareInscribed", (PyCFunction) &Dtool_FisheyeMaker_set_square_inscribed_23, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FisheyeMaker_set_square_inscribed_23_comment},
  {"set_reflection", &Dtool_FisheyeMaker_set_reflection_24, METH_O, (const char *)Dtool_FisheyeMaker_set_reflection_24_comment},
  {"setReflection", &Dtool_FisheyeMaker_set_reflection_24, METH_O, (const char *)Dtool_FisheyeMaker_set_reflection_24_comment},
  {"generate", &Dtool_FisheyeMaker_generate_25, METH_NOARGS, (const char *)Dtool_FisheyeMaker_generate_25_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_FisheyeMaker = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_FisheyeMaker = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_FisheyeMaker = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_FisheyeMaker = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_FisheyeMaker = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.FisheyeMaker",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_FisheyeMaker,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_FisheyeMaker,
    &Dtool_SequenceMethods_FisheyeMaker,
    &Dtool_MappingMethods_FisheyeMaker,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_FisheyeMaker,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is similar to CardMaker, but instead of generating ordinary\n"
    " * cards, it generates a circular rose that represents the projection of a 3-D\n"
    " * scene through a fisheye lens.  The texture coordinates of the rose are\n"
    " * defined so that each 2-D vertex has a 3-D UVW that reflects the\n"
    " * corresponding position in 3-D space of that particular vertex.\n"
    " *\n"
    " * This class is particularly suited for converting cube maps to sphere maps.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_FisheyeMaker,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_FisheyeMaker,
    PyType_GenericAlloc,
    Dtool_new_FisheyeMaker,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FisheyeMaker,
  Dtool_UpcastInterface_FisheyeMaker,
  Dtool_DowncastInterface_FisheyeMaker,
  (CoerceFunction)Dtool_ConstCoerce_FisheyeMaker,
  (CoerceFunction)Dtool_Coerce_FisheyeMaker,
};

static void Dtool_PyModuleClassInit_FisheyeMaker(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Namable != NULL);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(NULL);
    Dtool_FisheyeMaker._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Namable);
    PyObject *dict = PyDict_New();
    Dtool_FisheyeMaker._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_FisheyeMaker) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FisheyeMaker)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FisheyeMaker);
  }
}

/**
 * Python method tables for FrameRateMeter (FrameRateMeter)
 */
static PyMethodDef Dtool_Methods_FrameRateMeter[] = {
  {"setup_window", &Dtool_FrameRateMeter_setup_window_29, METH_O, (const char *)Dtool_FrameRateMeter_setup_window_29_comment},
  {"setupWindow", &Dtool_FrameRateMeter_setup_window_29, METH_O, (const char *)Dtool_FrameRateMeter_setup_window_29_comment},
  {"clear_window", &Dtool_FrameRateMeter_clear_window_30, METH_NOARGS, (const char *)Dtool_FrameRateMeter_clear_window_30_comment},
  {"clearWindow", &Dtool_FrameRateMeter_clear_window_30, METH_NOARGS, (const char *)Dtool_FrameRateMeter_clear_window_30_comment},
  {"get_window", &Dtool_FrameRateMeter_get_window_31, METH_NOARGS, (const char *)Dtool_FrameRateMeter_get_window_31_comment},
  {"getWindow", &Dtool_FrameRateMeter_get_window_31, METH_NOARGS, (const char *)Dtool_FrameRateMeter_get_window_31_comment},
  {"get_display_region", &Dtool_FrameRateMeter_get_display_region_32, METH_NOARGS, (const char *)Dtool_FrameRateMeter_get_display_region_32_comment},
  {"getDisplayRegion", &Dtool_FrameRateMeter_get_display_region_32, METH_NOARGS, (const char *)Dtool_FrameRateMeter_get_display_region_32_comment},
  {"set_update_interval", &Dtool_FrameRateMeter_set_update_interval_33, METH_O, (const char *)Dtool_FrameRateMeter_set_update_interval_33_comment},
  {"setUpdateInterval", &Dtool_FrameRateMeter_set_update_interval_33, METH_O, (const char *)Dtool_FrameRateMeter_set_update_interval_33_comment},
  {"get_update_interval", &Dtool_FrameRateMeter_get_update_interval_34, METH_NOARGS, (const char *)Dtool_FrameRateMeter_get_update_interval_34_comment},
  {"getUpdateInterval", &Dtool_FrameRateMeter_get_update_interval_34, METH_NOARGS, (const char *)Dtool_FrameRateMeter_get_update_interval_34_comment},
  {"set_text_pattern", &Dtool_FrameRateMeter_set_text_pattern_35, METH_O, (const char *)Dtool_FrameRateMeter_set_text_pattern_35_comment},
  {"setTextPattern", &Dtool_FrameRateMeter_set_text_pattern_35, METH_O, (const char *)Dtool_FrameRateMeter_set_text_pattern_35_comment},
  {"get_text_pattern", &Dtool_FrameRateMeter_get_text_pattern_36, METH_NOARGS, (const char *)Dtool_FrameRateMeter_get_text_pattern_36_comment},
  {"getTextPattern", &Dtool_FrameRateMeter_get_text_pattern_36, METH_NOARGS, (const char *)Dtool_FrameRateMeter_get_text_pattern_36_comment},
  {"set_clock_object", &Dtool_FrameRateMeter_set_clock_object_37, METH_O, (const char *)Dtool_FrameRateMeter_set_clock_object_37_comment},
  {"setClockObject", &Dtool_FrameRateMeter_set_clock_object_37, METH_O, (const char *)Dtool_FrameRateMeter_set_clock_object_37_comment},
  {"get_clock_object", &Dtool_FrameRateMeter_get_clock_object_38, METH_NOARGS, (const char *)Dtool_FrameRateMeter_get_clock_object_38_comment},
  {"getClockObject", &Dtool_FrameRateMeter_get_clock_object_38, METH_NOARGS, (const char *)Dtool_FrameRateMeter_get_clock_object_38_comment},
  {"update", &Dtool_FrameRateMeter_update_39, METH_NOARGS, (const char *)Dtool_FrameRateMeter_update_39_comment},
  {"get_class_type", &Dtool_FrameRateMeter_get_class_type_40, METH_NOARGS | METH_STATIC, (const char *)Dtool_FrameRateMeter_get_class_type_40_comment},
  {"getClassType", &Dtool_FrameRateMeter_get_class_type_40, METH_NOARGS | METH_STATIC, (const char *)Dtool_FrameRateMeter_get_class_type_40_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_FrameRateMeter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_FrameRateMeter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_FrameRateMeter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_FrameRateMeter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_FrameRateMeter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.FrameRateMeter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_FrameRateMeter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_FrameRateMeter,
    &Dtool_SequenceMethods_FrameRateMeter,
    &Dtool_MappingMethods_FrameRateMeter,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_FrameRateMeter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special TextNode that automatically updates itself with the\n"
    " * current frame rate.  It can be placed anywhere in the world where you'd\n"
    " * like to see the frame rate.\n"
    " *\n"
    " * It also has a special mode in which it may be attached directly to a\n"
    " * channel or window.  If this is done, it creates a DisplayRegion for itself\n"
    " * and renders itself in the upper-right-hand corner.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_FrameRateMeter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_FrameRateMeter,
    PyType_GenericAlloc,
    Dtool_new_FrameRateMeter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FrameRateMeter,
  Dtool_UpcastInterface_FrameRateMeter,
  Dtool_DowncastInterface_FrameRateMeter,
  (CoerceFunction)Dtool_ConstCoerce_FrameRateMeter,
  (CoerceFunction)Dtool_Coerce_FrameRateMeter,
};

static void Dtool_PyModuleClassInit_FrameRateMeter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TextNode != NULL);
    assert(Dtool_Ptr_TextNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TextNode->_Dtool_ModuleClassInit(NULL);
    Dtool_FrameRateMeter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TextNode);
    PyObject *dict = PyDict_New();
    Dtool_FrameRateMeter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_FrameRateMeter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FrameRateMeter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FrameRateMeter);
  }
}

/**
 * Python method tables for GeoMipTerrain (GeoMipTerrain)
 */
static PyMethodDef Dtool_Methods_GeoMipTerrain[] = {
  {"heightfield", &Dtool_GeoMipTerrain_heightfield_44, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_heightfield_44_comment},
  {"set_heightfield", (PyCFunction) &Dtool_GeoMipTerrain_set_heightfield_45, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeoMipTerrain_set_heightfield_45_comment},
  {"setHeightfield", (PyCFunction) &Dtool_GeoMipTerrain_set_heightfield_45, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeoMipTerrain_set_heightfield_45_comment},
  {"color_map", &Dtool_GeoMipTerrain_color_map_46, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_color_map_46_comment},
  {"colorMap", &Dtool_GeoMipTerrain_color_map_46, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_color_map_46_comment},
  {"set_color_map", (PyCFunction) &Dtool_GeoMipTerrain_set_color_map_47, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeoMipTerrain_set_color_map_47_comment},
  {"setColorMap", (PyCFunction) &Dtool_GeoMipTerrain_set_color_map_47, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeoMipTerrain_set_color_map_47_comment},
  {"has_color_map", &Dtool_GeoMipTerrain_has_color_map_48, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_has_color_map_48_comment},
  {"hasColorMap", &Dtool_GeoMipTerrain_has_color_map_48, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_has_color_map_48_comment},
  {"clear_color_map", &Dtool_GeoMipTerrain_clear_color_map_49, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_clear_color_map_49_comment},
  {"clearColorMap", &Dtool_GeoMipTerrain_clear_color_map_49, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_clear_color_map_49_comment},
  {"calc_ambient_occlusion", (PyCFunction) &Dtool_GeoMipTerrain_calc_ambient_occlusion_50, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeoMipTerrain_calc_ambient_occlusion_50_comment},
  {"calcAmbientOcclusion", (PyCFunction) &Dtool_GeoMipTerrain_calc_ambient_occlusion_50, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeoMipTerrain_calc_ambient_occlusion_50_comment},
  {"get_elevation", (PyCFunction) &Dtool_GeoMipTerrain_get_elevation_51, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeoMipTerrain_get_elevation_51_comment},
  {"getElevation", (PyCFunction) &Dtool_GeoMipTerrain_get_elevation_51, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeoMipTerrain_get_elevation_51_comment},
  {"get_normal", (PyCFunction) &Dtool_GeoMipTerrain_get_normal_52, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeoMipTerrain_get_normal_52_comment},
  {"getNormal", (PyCFunction) &Dtool_GeoMipTerrain_get_normal_52, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeoMipTerrain_get_normal_52_comment},
  {"set_bruteforce", &Dtool_GeoMipTerrain_set_bruteforce_53, METH_O, (const char *)Dtool_GeoMipTerrain_set_bruteforce_53_comment},
  {"setBruteforce", &Dtool_GeoMipTerrain_set_bruteforce_53, METH_O, (const char *)Dtool_GeoMipTerrain_set_bruteforce_53_comment},
  {"get_bruteforce", &Dtool_GeoMipTerrain_get_bruteforce_54, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_bruteforce_54_comment},
  {"getBruteforce", &Dtool_GeoMipTerrain_get_bruteforce_54, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_bruteforce_54_comment},
  {"set_auto_flatten", &Dtool_GeoMipTerrain_set_auto_flatten_56, METH_O, (const char *)Dtool_GeoMipTerrain_set_auto_flatten_56_comment},
  {"setAutoFlatten", &Dtool_GeoMipTerrain_set_auto_flatten_56, METH_O, (const char *)Dtool_GeoMipTerrain_set_auto_flatten_56_comment},
  {"set_focal_point", (PyCFunction) &Dtool_GeoMipTerrain_set_focal_point_57, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeoMipTerrain_set_focal_point_57_comment},
  {"setFocalPoint", (PyCFunction) &Dtool_GeoMipTerrain_set_focal_point_57, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeoMipTerrain_set_focal_point_57_comment},
  {"get_focal_point", &Dtool_GeoMipTerrain_get_focal_point_58, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_focal_point_58_comment},
  {"getFocalPoint", &Dtool_GeoMipTerrain_get_focal_point_58, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_focal_point_58_comment},
  {"get_root", &Dtool_GeoMipTerrain_get_root_59, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_root_59_comment},
  {"getRoot", &Dtool_GeoMipTerrain_get_root_59, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_root_59_comment},
  {"set_block_size", &Dtool_GeoMipTerrain_set_block_size_60, METH_O, (const char *)Dtool_GeoMipTerrain_set_block_size_60_comment},
  {"setBlockSize", &Dtool_GeoMipTerrain_set_block_size_60, METH_O, (const char *)Dtool_GeoMipTerrain_set_block_size_60_comment},
  {"get_block_size", &Dtool_GeoMipTerrain_get_block_size_61, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_block_size_61_comment},
  {"getBlockSize", &Dtool_GeoMipTerrain_get_block_size_61, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_block_size_61_comment},
  {"get_max_level", &Dtool_GeoMipTerrain_get_max_level_62, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_max_level_62_comment},
  {"getMaxLevel", &Dtool_GeoMipTerrain_get_max_level_62, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_max_level_62_comment},
  {"set_min_level", &Dtool_GeoMipTerrain_set_min_level_63, METH_O, (const char *)Dtool_GeoMipTerrain_set_min_level_63_comment},
  {"setMinLevel", &Dtool_GeoMipTerrain_set_min_level_63, METH_O, (const char *)Dtool_GeoMipTerrain_set_min_level_63_comment},
  {"get_min_level", &Dtool_GeoMipTerrain_get_min_level_64, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_min_level_64_comment},
  {"getMinLevel", &Dtool_GeoMipTerrain_get_min_level_64, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_min_level_64_comment},
  {"is_dirty", &Dtool_GeoMipTerrain_is_dirty_65, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_is_dirty_65_comment},
  {"isDirty", &Dtool_GeoMipTerrain_is_dirty_65, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_is_dirty_65_comment},
  {"set_factor", &Dtool_GeoMipTerrain_set_factor_66, METH_O, (const char *)Dtool_GeoMipTerrain_set_factor_66_comment},
  {"setFactor", &Dtool_GeoMipTerrain_set_factor_66, METH_O, (const char *)Dtool_GeoMipTerrain_set_factor_66_comment},
  {"set_near_far", (PyCFunction) &Dtool_GeoMipTerrain_set_near_far_67, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeoMipTerrain_set_near_far_67_comment},
  {"setNearFar", (PyCFunction) &Dtool_GeoMipTerrain_set_near_far_67, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeoMipTerrain_set_near_far_67_comment},
  {"set_near", &Dtool_GeoMipTerrain_set_near_68, METH_O, (const char *)Dtool_GeoMipTerrain_set_near_68_comment},
  {"setNear", &Dtool_GeoMipTerrain_set_near_68, METH_O, (const char *)Dtool_GeoMipTerrain_set_near_68_comment},
  {"set_far", &Dtool_GeoMipTerrain_set_far_69, METH_O, (const char *)Dtool_GeoMipTerrain_set_far_69_comment},
  {"setFar", &Dtool_GeoMipTerrain_set_far_69, METH_O, (const char *)Dtool_GeoMipTerrain_set_far_69_comment},
  {"get_block_node_path", (PyCFunction) &Dtool_GeoMipTerrain_get_block_node_path_70, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeoMipTerrain_get_block_node_path_70_comment},
  {"getBlockNodePath", (PyCFunction) &Dtool_GeoMipTerrain_get_block_node_path_70, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeoMipTerrain_get_block_node_path_70_comment},
  {"get_block_from_pos", (PyCFunction) &Dtool_GeoMipTerrain_get_block_from_pos_71, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeoMipTerrain_get_block_from_pos_71_comment},
  {"getBlockFromPos", (PyCFunction) &Dtool_GeoMipTerrain_get_block_from_pos_71, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeoMipTerrain_get_block_from_pos_71_comment},
  {"set_border_stitching", &Dtool_GeoMipTerrain_set_border_stitching_72, METH_O, (const char *)Dtool_GeoMipTerrain_set_border_stitching_72_comment},
  {"setBorderStitching", &Dtool_GeoMipTerrain_set_border_stitching_72, METH_O, (const char *)Dtool_GeoMipTerrain_set_border_stitching_72_comment},
  {"get_border_stitching", &Dtool_GeoMipTerrain_get_border_stitching_73, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_border_stitching_73_comment},
  {"getBorderStitching", &Dtool_GeoMipTerrain_get_border_stitching_73, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_border_stitching_73_comment},
  {"get_far", &Dtool_GeoMipTerrain_get_far_74, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_far_74_comment},
  {"getFar", &Dtool_GeoMipTerrain_get_far_74, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_far_74_comment},
  {"get_near", &Dtool_GeoMipTerrain_get_near_75, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_near_75_comment},
  {"getNear", &Dtool_GeoMipTerrain_get_near_75, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_near_75_comment},
  {"get_flatten_mode", &Dtool_GeoMipTerrain_get_flatten_mode_76, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_flatten_mode_76_comment},
  {"getFlattenMode", &Dtool_GeoMipTerrain_get_flatten_mode_76, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_get_flatten_mode_76_comment},
  {"make_slope_image", &Dtool_GeoMipTerrain_make_slope_image_77, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_make_slope_image_77_comment},
  {"makeSlopeImage", &Dtool_GeoMipTerrain_make_slope_image_77, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_make_slope_image_77_comment},
  {"generate", &Dtool_GeoMipTerrain_generate_78, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_generate_78_comment},
  {"update", &Dtool_GeoMipTerrain_update_79, METH_NOARGS, (const char *)Dtool_GeoMipTerrain_update_79_comment},
  {"get_class_type", &Dtool_GeoMipTerrain_get_class_type_80, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeoMipTerrain_get_class_type_80_comment},
  {"getClassType", &Dtool_GeoMipTerrain_get_class_type_80, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeoMipTerrain_get_class_type_80_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_GeoMipTerrain = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeoMipTerrain = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_GeoMipTerrain = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_GeoMipTerrain = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_GeoMipTerrain = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.GeoMipTerrain",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_GeoMipTerrain,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_GeoMipTerrain,
    &Dtool_SequenceMethods_GeoMipTerrain,
    &Dtool_MappingMethods_GeoMipTerrain,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_GeoMipTerrain,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * GeoMipTerrain, meaning Panda3D GeoMipMapping, can convert a heightfield\n"
    " * image into a 3D terrain, consisting of several GeomNodes.  It uses the\n"
    " * GeoMipMapping algorithm, or Geometrical MipMapping, based on the LOD (Level\n"
    " * of Detail) algorithm.  For more information about the GeoMipMapping\n"
    " * algoritm, see this paper, written by Willem H. de Boer:\n"
    " * http://flipcode.com/articles/article_geomipmaps.pdf\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_GeoMipTerrain,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_GeoMipTerrain,
    PyType_GenericAlloc,
    Dtool_new_GeoMipTerrain,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeoMipTerrain,
  Dtool_UpcastInterface_GeoMipTerrain,
  Dtool_DowncastInterface_GeoMipTerrain,
  (CoerceFunction)Dtool_ConstCoerce_GeoMipTerrain,
  (CoerceFunction)Dtool_Coerce_GeoMipTerrain,
};

static void Dtool_PyModuleClassInit_GeoMipTerrain(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != NULL);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(NULL);
    Dtool_GeoMipTerrain._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_GeoMipTerrain._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum GeoMipTerrain::AutoFlattenMode;
    PyDict_SetItemString(dict, "AFM_off", Dtool_WrapValue(GeoMipTerrain::AFM_off));
    PyDict_SetItemString(dict, "AFMOff", Dtool_WrapValue(GeoMipTerrain::AFM_off));
    PyDict_SetItemString(dict, "AFM_light", Dtool_WrapValue(GeoMipTerrain::AFM_light));
    PyDict_SetItemString(dict, "AFMLight", Dtool_WrapValue(GeoMipTerrain::AFM_light));
    PyDict_SetItemString(dict, "AFM_medium", Dtool_WrapValue(GeoMipTerrain::AFM_medium));
    PyDict_SetItemString(dict, "AFMMedium", Dtool_WrapValue(GeoMipTerrain::AFM_medium));
    PyDict_SetItemString(dict, "AFM_strong", Dtool_WrapValue(GeoMipTerrain::AFM_strong));
    PyDict_SetItemString(dict, "AFMStrong", Dtool_WrapValue(GeoMipTerrain::AFM_strong));
    if (PyType_Ready((PyTypeObject *)&Dtool_GeoMipTerrain) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeoMipTerrain)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeoMipTerrain);
  }
}

/**
 * Python method tables for HeightfieldTesselator (HeightfieldTesselator)
 */
static PyMethodDef Dtool_Methods_HeightfieldTesselator[] = {
  {"heightfield", &Dtool_HeightfieldTesselator_heightfield_84, METH_NOARGS, (const char *)Dtool_HeightfieldTesselator_heightfield_84_comment},
  {"set_heightfield", (PyCFunction) &Dtool_HeightfieldTesselator_set_heightfield_85, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HeightfieldTesselator_set_heightfield_85_comment},
  {"setHeightfield", (PyCFunction) &Dtool_HeightfieldTesselator_set_heightfield_85, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HeightfieldTesselator_set_heightfield_85_comment},
  {"set_poly_count", &Dtool_HeightfieldTesselator_set_poly_count_86, METH_O, (const char *)Dtool_HeightfieldTesselator_set_poly_count_86_comment},
  {"setPolyCount", &Dtool_HeightfieldTesselator_set_poly_count_86, METH_O, (const char *)Dtool_HeightfieldTesselator_set_poly_count_86_comment},
  {"set_visibility_radius", &Dtool_HeightfieldTesselator_set_visibility_radius_87, METH_O, (const char *)Dtool_HeightfieldTesselator_set_visibility_radius_87_comment},
  {"setVisibilityRadius", &Dtool_HeightfieldTesselator_set_visibility_radius_87, METH_O, (const char *)Dtool_HeightfieldTesselator_set_visibility_radius_87_comment},
  {"set_focal_point", (PyCFunction) &Dtool_HeightfieldTesselator_set_focal_point_88, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HeightfieldTesselator_set_focal_point_88_comment},
  {"setFocalPoint", (PyCFunction) &Dtool_HeightfieldTesselator_set_focal_point_88, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HeightfieldTesselator_set_focal_point_88_comment},
  {"set_horizontal_scale", &Dtool_HeightfieldTesselator_set_horizontal_scale_89, METH_O, (const char *)Dtool_HeightfieldTesselator_set_horizontal_scale_89_comment},
  {"setHorizontalScale", &Dtool_HeightfieldTesselator_set_horizontal_scale_89, METH_O, (const char *)Dtool_HeightfieldTesselator_set_horizontal_scale_89_comment},
  {"set_vertical_scale", &Dtool_HeightfieldTesselator_set_vertical_scale_90, METH_O, (const char *)Dtool_HeightfieldTesselator_set_vertical_scale_90_comment},
  {"setVerticalScale", &Dtool_HeightfieldTesselator_set_vertical_scale_90, METH_O, (const char *)Dtool_HeightfieldTesselator_set_vertical_scale_90_comment},
  {"set_max_triangles", &Dtool_HeightfieldTesselator_set_max_triangles_91, METH_O, (const char *)Dtool_HeightfieldTesselator_set_max_triangles_91_comment},
  {"setMaxTriangles", &Dtool_HeightfieldTesselator_set_max_triangles_91, METH_O, (const char *)Dtool_HeightfieldTesselator_set_max_triangles_91_comment},
  {"get_elevation", (PyCFunction) &Dtool_HeightfieldTesselator_get_elevation_92, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HeightfieldTesselator_get_elevation_92_comment},
  {"getElevation", (PyCFunction) &Dtool_HeightfieldTesselator_get_elevation_92, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HeightfieldTesselator_get_elevation_92_comment},
  {"generate", &Dtool_HeightfieldTesselator_generate_93, METH_NOARGS, (const char *)Dtool_HeightfieldTesselator_generate_93_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_HeightfieldTesselator = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_HeightfieldTesselator = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_HeightfieldTesselator = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_HeightfieldTesselator = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_HeightfieldTesselator = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.HeightfieldTesselator",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_HeightfieldTesselator,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_HeightfieldTesselator,
    &Dtool_SequenceMethods_HeightfieldTesselator,
    &Dtool_MappingMethods_HeightfieldTesselator,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_HeightfieldTesselator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_HeightfieldTesselator,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_HeightfieldTesselator,
    PyType_GenericAlloc,
    Dtool_new_HeightfieldTesselator,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_HeightfieldTesselator,
  Dtool_UpcastInterface_HeightfieldTesselator,
  Dtool_DowncastInterface_HeightfieldTesselator,
  (CoerceFunction)Dtool_ConstCoerce_HeightfieldTesselator,
  (CoerceFunction)Dtool_Coerce_HeightfieldTesselator,
};

static void Dtool_PyModuleClassInit_HeightfieldTesselator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Namable != NULL);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(NULL);
    Dtool_HeightfieldTesselator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Namable);
    PyObject *dict = PyDict_New();
    Dtool_HeightfieldTesselator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_HeightfieldTesselator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(HeightfieldTesselator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_HeightfieldTesselator);
  }
}

/**
 * Python method tables for LineSegs (LineSegs)
 */
static PyMethodDef Dtool_Methods_LineSegs[] = {
  {"reset", &Dtool_LineSegs_reset_97, METH_NOARGS, (const char *)Dtool_LineSegs_reset_97_comment},
  {"set_color", (PyCFunction) &Dtool_LineSegs_set_color_98, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LineSegs_set_color_98_comment},
  {"setColor", (PyCFunction) &Dtool_LineSegs_set_color_98, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LineSegs_set_color_98_comment},
  {"set_thickness", &Dtool_LineSegs_set_thickness_99, METH_O, (const char *)Dtool_LineSegs_set_thickness_99_comment},
  {"setThickness", &Dtool_LineSegs_set_thickness_99, METH_O, (const char *)Dtool_LineSegs_set_thickness_99_comment},
  {"move_to", (PyCFunction) &Dtool_LineSegs_move_to_100, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LineSegs_move_to_100_comment},
  {"moveTo", (PyCFunction) &Dtool_LineSegs_move_to_100, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LineSegs_move_to_100_comment},
  {"draw_to", (PyCFunction) &Dtool_LineSegs_draw_to_101, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LineSegs_draw_to_101_comment},
  {"drawTo", (PyCFunction) &Dtool_LineSegs_draw_to_101, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LineSegs_draw_to_101_comment},
  {"get_current_position", &Dtool_LineSegs_get_current_position_102, METH_NOARGS, (const char *)Dtool_LineSegs_get_current_position_102_comment},
  {"getCurrentPosition", &Dtool_LineSegs_get_current_position_102, METH_NOARGS, (const char *)Dtool_LineSegs_get_current_position_102_comment},
  {"is_empty", &Dtool_LineSegs_is_empty_103, METH_NOARGS, (const char *)Dtool_LineSegs_is_empty_103_comment},
  {"isEmpty", &Dtool_LineSegs_is_empty_103, METH_NOARGS, (const char *)Dtool_LineSegs_is_empty_103_comment},
  {"create", (PyCFunction) &Dtool_LineSegs_create_104, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LineSegs_create_104_comment},
  {"get_num_vertices", &Dtool_LineSegs_get_num_vertices_105, METH_NOARGS, (const char *)Dtool_LineSegs_get_num_vertices_105_comment},
  {"getNumVertices", &Dtool_LineSegs_get_num_vertices_105, METH_NOARGS, (const char *)Dtool_LineSegs_get_num_vertices_105_comment},
  {"get_vertex", &Dtool_LineSegs_get_vertex_106, METH_O, (const char *)Dtool_LineSegs_get_vertex_106_comment},
  {"getVertex", &Dtool_LineSegs_get_vertex_106, METH_O, (const char *)Dtool_LineSegs_get_vertex_106_comment},
  {"set_vertex", (PyCFunction) &Dtool_LineSegs_set_vertex_108, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LineSegs_set_vertex_108_comment},
  {"setVertex", (PyCFunction) &Dtool_LineSegs_set_vertex_108, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LineSegs_set_vertex_108_comment},
  {"get_vertex_color", &Dtool_LineSegs_get_vertex_color_109, METH_O, (const char *)Dtool_LineSegs_get_vertex_color_109_comment},
  {"getVertexColor", &Dtool_LineSegs_get_vertex_color_109, METH_O, (const char *)Dtool_LineSegs_get_vertex_color_109_comment},
  {"set_vertex_color", (PyCFunction) &Dtool_LineSegs_set_vertex_color_111, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LineSegs_set_vertex_color_111_comment},
  {"setVertexColor", (PyCFunction) &Dtool_LineSegs_set_vertex_color_111, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LineSegs_set_vertex_color_111_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_vertices", (PyCFunction) &MakeSeq_LineSegs_get_vertices, METH_NOARGS, NULL},
  { "getVertices", (PyCFunction) &MakeSeq_LineSegs_get_vertices, METH_NOARGS, NULL},
  {"get_vertex_colors", (PyCFunction) &MakeSeq_LineSegs_get_vertex_colors, METH_NOARGS, NULL},
  { "getVertexColors", (PyCFunction) &MakeSeq_LineSegs_get_vertex_colors, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LineSegs = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LineSegs = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LineSegs = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LineSegs = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LineSegs = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LineSegs",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LineSegs,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LineSegs,
    &Dtool_SequenceMethods_LineSegs,
    &Dtool_MappingMethods_LineSegs,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LineSegs,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Encapsulates creation of a series of connected or disconnected line\n"
    " * segments or points, for drawing paths or rays.  This class doesn't attempt\n"
    " * to be the smartest it could possibly be; it's intended primarily as a\n"
    " * visualization and editing tool.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LineSegs,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LineSegs,
    PyType_GenericAlloc,
    Dtool_new_LineSegs,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LineSegs,
  Dtool_UpcastInterface_LineSegs,
  Dtool_DowncastInterface_LineSegs,
  (CoerceFunction)Dtool_ConstCoerce_LineSegs,
  (CoerceFunction)Dtool_Coerce_LineSegs,
};

static void Dtool_PyModuleClassInit_LineSegs(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Namable != NULL);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(NULL);
    Dtool_LineSegs._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Namable);
    PyObject *dict = PyDict_New();
    Dtool_LineSegs._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LineSegs) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LineSegs)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LineSegs);
  }
}

/**
 * Python method tables for MeshDrawer (MeshDrawer)
 */
static PyMethodDef Dtool_Methods_MeshDrawer[] = {
  {"set_budget", &Dtool_MeshDrawer_set_budget_114, METH_O, (const char *)Dtool_MeshDrawer_set_budget_114_comment},
  {"setBudget", &Dtool_MeshDrawer_set_budget_114, METH_O, (const char *)Dtool_MeshDrawer_set_budget_114_comment},
  {"get_budget", &Dtool_MeshDrawer_get_budget_115, METH_NOARGS, (const char *)Dtool_MeshDrawer_get_budget_115_comment},
  {"getBudget", &Dtool_MeshDrawer_get_budget_115, METH_NOARGS, (const char *)Dtool_MeshDrawer_get_budget_115_comment},
  {"get_root", &Dtool_MeshDrawer_get_root_116, METH_NOARGS, (const char *)Dtool_MeshDrawer_get_root_116_comment},
  {"getRoot", &Dtool_MeshDrawer_get_root_116, METH_NOARGS, (const char *)Dtool_MeshDrawer_get_root_116_comment},
  {"begin", (PyCFunction) &Dtool_MeshDrawer_begin_117, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer_begin_117_comment},
  {"tri", (PyCFunction) &Dtool_MeshDrawer_tri_118, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer_tri_118_comment},
  {"particle", (PyCFunction) &Dtool_MeshDrawer_particle_119, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer_particle_119_comment},
  {"blended_particle", (PyCFunction) &Dtool_MeshDrawer_blended_particle_120, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer_blended_particle_120_comment},
  {"blendedParticle", (PyCFunction) &Dtool_MeshDrawer_blended_particle_120, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer_blended_particle_120_comment},
  {"billboard", (PyCFunction) &Dtool_MeshDrawer_billboard_121, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer_billboard_121_comment},
  {"segment", (PyCFunction) &Dtool_MeshDrawer_segment_122, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer_segment_122_comment},
  {"cross_segment", (PyCFunction) &Dtool_MeshDrawer_cross_segment_123, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer_cross_segment_123_comment},
  {"crossSegment", (PyCFunction) &Dtool_MeshDrawer_cross_segment_123, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer_cross_segment_123_comment},
  {"uneven_segment", (PyCFunction) &Dtool_MeshDrawer_uneven_segment_124, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer_uneven_segment_124_comment},
  {"unevenSegment", (PyCFunction) &Dtool_MeshDrawer_uneven_segment_124, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer_uneven_segment_124_comment},
  {"link_segment", (PyCFunction) &Dtool_MeshDrawer_link_segment_125, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer_link_segment_125_comment},
  {"linkSegment", (PyCFunction) &Dtool_MeshDrawer_link_segment_125, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer_link_segment_125_comment},
  {"link_segment_end", (PyCFunction) &Dtool_MeshDrawer_link_segment_end_126, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer_link_segment_end_126_comment},
  {"linkSegmentEnd", (PyCFunction) &Dtool_MeshDrawer_link_segment_end_126, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer_link_segment_end_126_comment},
  {"explosion", (PyCFunction) &Dtool_MeshDrawer_explosion_127, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer_explosion_127_comment},
  {"stream", (PyCFunction) &Dtool_MeshDrawer_stream_128, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer_stream_128_comment},
  {"geometry", &Dtool_MeshDrawer_geometry_129, METH_O, (const char *)Dtool_MeshDrawer_geometry_129_comment},
  {"end", &Dtool_MeshDrawer_end_130, METH_NOARGS, (const char *)Dtool_MeshDrawer_end_130_comment},
  {"get_class_type", &Dtool_MeshDrawer_get_class_type_131, METH_NOARGS | METH_STATIC, (const char *)Dtool_MeshDrawer_get_class_type_131_comment},
  {"getClassType", &Dtool_MeshDrawer_get_class_type_131, METH_NOARGS | METH_STATIC, (const char *)Dtool_MeshDrawer_get_class_type_131_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MeshDrawer = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MeshDrawer = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_MeshDrawer = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_MeshDrawer = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_MeshDrawer = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MeshDrawer",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MeshDrawer,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MeshDrawer,
    &Dtool_SequenceMethods_MeshDrawer,
    &Dtool_MappingMethods_MeshDrawer,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_MeshDrawer,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Mesh drawer creates a single geom object that can be shaped with different\n"
    " * draw commands.  This is an efficient way to render bunch of billboards,\n"
    " * particles, fast changing triangles.  Its implemented by recycling same geom\n"
    " * over and over again.  Max budget specifies how many triangles are allowed.\n"
    " * Some uses of this class can be : particle system, radar icons, health bars,\n"
    " * 2d icons, 2d ui, bullets, missile trails.  Any that can be drawn with\n"
    " * triangles can be drawn with this class.  At the low level this uses the\n"
    " * GeomVertexRewriter's.  The internal geom consists of vertex, normal, uv and\n"
    " * color channels.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MeshDrawer,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MeshDrawer,
    PyType_GenericAlloc,
    Dtool_new_MeshDrawer,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MeshDrawer,
  Dtool_UpcastInterface_MeshDrawer,
  Dtool_DowncastInterface_MeshDrawer,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MeshDrawer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != NULL);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(NULL);
    Dtool_MeshDrawer._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    PyObject *dict = PyDict_New();
    Dtool_MeshDrawer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MeshDrawer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MeshDrawer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MeshDrawer);
  }
}

/**
 * Python method tables for MeshDrawer2D (MeshDrawer2D)
 */
static PyMethodDef Dtool_Methods_MeshDrawer2D[] = {
  {"set_budget", &Dtool_MeshDrawer2D_set_budget_134, METH_O, (const char *)Dtool_MeshDrawer2D_set_budget_134_comment},
  {"setBudget", &Dtool_MeshDrawer2D_set_budget_134, METH_O, (const char *)Dtool_MeshDrawer2D_set_budget_134_comment},
  {"get_budget", &Dtool_MeshDrawer2D_get_budget_135, METH_NOARGS, (const char *)Dtool_MeshDrawer2D_get_budget_135_comment},
  {"getBudget", &Dtool_MeshDrawer2D_get_budget_135, METH_NOARGS, (const char *)Dtool_MeshDrawer2D_get_budget_135_comment},
  {"get_root", &Dtool_MeshDrawer2D_get_root_136, METH_NOARGS, (const char *)Dtool_MeshDrawer2D_get_root_136_comment},
  {"getRoot", &Dtool_MeshDrawer2D_get_root_136, METH_NOARGS, (const char *)Dtool_MeshDrawer2D_get_root_136_comment},
  {"quad_raw", (PyCFunction) &Dtool_MeshDrawer2D_quad_raw_137, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer2D_quad_raw_137_comment},
  {"quadRaw", (PyCFunction) &Dtool_MeshDrawer2D_quad_raw_137, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer2D_quad_raw_137_comment},
  {"rectangle_raw", (PyCFunction) &Dtool_MeshDrawer2D_rectangle_raw_138, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer2D_rectangle_raw_138_comment},
  {"rectangleRaw", (PyCFunction) &Dtool_MeshDrawer2D_rectangle_raw_138, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer2D_rectangle_raw_138_comment},
  {"set_clip", (PyCFunction) &Dtool_MeshDrawer2D_set_clip_139, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer2D_set_clip_139_comment},
  {"setClip", (PyCFunction) &Dtool_MeshDrawer2D_set_clip_139, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer2D_set_clip_139_comment},
  {"rectangle", (PyCFunction) &Dtool_MeshDrawer2D_rectangle_140, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer2D_rectangle_140_comment},
  {"rectangle_border", (PyCFunction) &Dtool_MeshDrawer2D_rectangle_border_141, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer2D_rectangle_border_141_comment},
  {"rectangleBorder", (PyCFunction) &Dtool_MeshDrawer2D_rectangle_border_141, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer2D_rectangle_border_141_comment},
  {"rectangle_border_tiled", (PyCFunction) &Dtool_MeshDrawer2D_rectangle_border_tiled_142, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer2D_rectangle_border_tiled_142_comment},
  {"rectangleBorderTiled", (PyCFunction) &Dtool_MeshDrawer2D_rectangle_border_tiled_142, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer2D_rectangle_border_tiled_142_comment},
  {"rectangle_tiled", (PyCFunction) &Dtool_MeshDrawer2D_rectangle_tiled_143, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer2D_rectangle_tiled_143_comment},
  {"rectangleTiled", (PyCFunction) &Dtool_MeshDrawer2D_rectangle_tiled_143, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MeshDrawer2D_rectangle_tiled_143_comment},
  {"begin", &Dtool_MeshDrawer2D_begin_144, METH_NOARGS, (const char *)Dtool_MeshDrawer2D_begin_144_comment},
  {"end", &Dtool_MeshDrawer2D_end_145, METH_NOARGS, (const char *)Dtool_MeshDrawer2D_end_145_comment},
  {"get_class_type", &Dtool_MeshDrawer2D_get_class_type_146, METH_NOARGS | METH_STATIC, (const char *)Dtool_MeshDrawer2D_get_class_type_146_comment},
  {"getClassType", &Dtool_MeshDrawer2D_get_class_type_146, METH_NOARGS | METH_STATIC, (const char *)Dtool_MeshDrawer2D_get_class_type_146_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MeshDrawer2D = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MeshDrawer2D = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_MeshDrawer2D = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_MeshDrawer2D = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_MeshDrawer2D = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MeshDrawer2D",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MeshDrawer2D,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MeshDrawer2D,
    &Dtool_SequenceMethods_MeshDrawer2D,
    &Dtool_MappingMethods_MeshDrawer2D,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_MeshDrawer2D,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class allows the drawing of 2d objects - mainly based on quads and\n"
    " * rectangles.  Allows clipping and serverl high level UI theme functions.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MeshDrawer2D,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MeshDrawer2D,
    PyType_GenericAlloc,
    Dtool_new_MeshDrawer2D,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MeshDrawer2D,
  Dtool_UpcastInterface_MeshDrawer2D,
  Dtool_DowncastInterface_MeshDrawer2D,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MeshDrawer2D(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != NULL);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(NULL);
    Dtool_MeshDrawer2D._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    PyObject *dict = PyDict_New();
    Dtool_MeshDrawer2D._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MeshDrawer2D) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MeshDrawer2D)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MeshDrawer2D);
  }
}

/**
 * Python method tables for MovieTexture (MovieTexture)
 */
static PyMethodDef Dtool_Methods_MovieTexture[] = {
  {"get_video_length", &Dtool_MovieTexture_get_video_length_150, METH_NOARGS, (const char *)Dtool_MovieTexture_get_video_length_150_comment},
  {"getVideoLength", &Dtool_MovieTexture_get_video_length_150, METH_NOARGS, (const char *)Dtool_MovieTexture_get_video_length_150_comment},
  {"get_video_width", &Dtool_MovieTexture_get_video_width_151, METH_NOARGS, (const char *)Dtool_MovieTexture_get_video_width_151_comment},
  {"getVideoWidth", &Dtool_MovieTexture_get_video_width_151, METH_NOARGS, (const char *)Dtool_MovieTexture_get_video_width_151_comment},
  {"get_video_height", &Dtool_MovieTexture_get_video_height_152, METH_NOARGS, (const char *)Dtool_MovieTexture_get_video_height_152_comment},
  {"getVideoHeight", &Dtool_MovieTexture_get_video_height_152, METH_NOARGS, (const char *)Dtool_MovieTexture_get_video_height_152_comment},
  {"get_color_cursor", &Dtool_MovieTexture_get_color_cursor_153, METH_O, (const char *)Dtool_MovieTexture_get_color_cursor_153_comment},
  {"getColorCursor", &Dtool_MovieTexture_get_color_cursor_153, METH_O, (const char *)Dtool_MovieTexture_get_color_cursor_153_comment},
  {"get_alpha_cursor", &Dtool_MovieTexture_get_alpha_cursor_154, METH_O, (const char *)Dtool_MovieTexture_get_alpha_cursor_154_comment},
  {"getAlphaCursor", &Dtool_MovieTexture_get_alpha_cursor_154, METH_O, (const char *)Dtool_MovieTexture_get_alpha_cursor_154_comment},
  {"restart", &Dtool_MovieTexture_restart_155, METH_NOARGS, (const char *)Dtool_MovieTexture_restart_155_comment},
  {"stop", &Dtool_MovieTexture_stop_156, METH_NOARGS, (const char *)Dtool_MovieTexture_stop_156_comment},
  {"play", &Dtool_MovieTexture_play_157, METH_NOARGS, (const char *)Dtool_MovieTexture_play_157_comment},
  {"set_time", &Dtool_MovieTexture_set_time_158, METH_O, (const char *)Dtool_MovieTexture_set_time_158_comment},
  {"setTime", &Dtool_MovieTexture_set_time_158, METH_O, (const char *)Dtool_MovieTexture_set_time_158_comment},
  {"get_time", &Dtool_MovieTexture_get_time_159, METH_NOARGS, (const char *)Dtool_MovieTexture_get_time_159_comment},
  {"getTime", &Dtool_MovieTexture_get_time_159, METH_NOARGS, (const char *)Dtool_MovieTexture_get_time_159_comment},
  {"set_loop", &Dtool_MovieTexture_set_loop_160, METH_O, (const char *)Dtool_MovieTexture_set_loop_160_comment},
  {"setLoop", &Dtool_MovieTexture_set_loop_160, METH_O, (const char *)Dtool_MovieTexture_set_loop_160_comment},
  {"get_loop", &Dtool_MovieTexture_get_loop_161, METH_NOARGS, (const char *)Dtool_MovieTexture_get_loop_161_comment},
  {"getLoop", &Dtool_MovieTexture_get_loop_161, METH_NOARGS, (const char *)Dtool_MovieTexture_get_loop_161_comment},
  {"set_loop_count", &Dtool_MovieTexture_set_loop_count_162, METH_O, (const char *)Dtool_MovieTexture_set_loop_count_162_comment},
  {"setLoopCount", &Dtool_MovieTexture_set_loop_count_162, METH_O, (const char *)Dtool_MovieTexture_set_loop_count_162_comment},
  {"get_loop_count", &Dtool_MovieTexture_get_loop_count_163, METH_NOARGS, (const char *)Dtool_MovieTexture_get_loop_count_163_comment},
  {"getLoopCount", &Dtool_MovieTexture_get_loop_count_163, METH_NOARGS, (const char *)Dtool_MovieTexture_get_loop_count_163_comment},
  {"set_play_rate", &Dtool_MovieTexture_set_play_rate_164, METH_O, (const char *)Dtool_MovieTexture_set_play_rate_164_comment},
  {"setPlayRate", &Dtool_MovieTexture_set_play_rate_164, METH_O, (const char *)Dtool_MovieTexture_set_play_rate_164_comment},
  {"get_play_rate", &Dtool_MovieTexture_get_play_rate_165, METH_NOARGS, (const char *)Dtool_MovieTexture_get_play_rate_165_comment},
  {"getPlayRate", &Dtool_MovieTexture_get_play_rate_165, METH_NOARGS, (const char *)Dtool_MovieTexture_get_play_rate_165_comment},
  {"is_playing", &Dtool_MovieTexture_is_playing_166, METH_NOARGS, (const char *)Dtool_MovieTexture_is_playing_166_comment},
  {"isPlaying", &Dtool_MovieTexture_is_playing_166, METH_NOARGS, (const char *)Dtool_MovieTexture_is_playing_166_comment},
  {"synchronize_to", &Dtool_MovieTexture_synchronize_to_167, METH_O, (const char *)Dtool_MovieTexture_synchronize_to_167_comment},
  {"synchronizeTo", &Dtool_MovieTexture_synchronize_to_167, METH_O, (const char *)Dtool_MovieTexture_synchronize_to_167_comment},
  {"unsynchronize", &Dtool_MovieTexture_unsynchronize_168, METH_NOARGS, (const char *)Dtool_MovieTexture_unsynchronize_168_comment},
  {"get_class_type", &Dtool_MovieTexture_get_class_type_180, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovieTexture_get_class_type_180_comment},
  {"getClassType", &Dtool_MovieTexture_get_class_type_180, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovieTexture_get_class_type_180_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_MovieTexture[] = {
  {(char *)"video_length", &Dtool_MovieTexture_video_length_Getter, NULL, NULL, NULL},
  {(char *)"video_width", &Dtool_MovieTexture_video_width_Getter, NULL, NULL, NULL},
  {(char *)"video_height", &Dtool_MovieTexture_video_height_Getter, NULL, NULL, NULL},
  {(char *)"time", &Dtool_MovieTexture_time_Getter, &Dtool_MovieTexture_time_Setter, NULL, NULL},
  {(char *)"loop", &Dtool_MovieTexture_loop_Getter, &Dtool_MovieTexture_loop_Setter, NULL, NULL},
  {(char *)"loop_count", &Dtool_MovieTexture_loop_count_Getter, &Dtool_MovieTexture_loop_count_Setter, NULL, NULL},
  {(char *)"play_rate", &Dtool_MovieTexture_play_rate_Getter, &Dtool_MovieTexture_play_rate_Setter, NULL, NULL},
  {(char *)"playing", &Dtool_MovieTexture_playing_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_MovieTexture = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MovieTexture = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_MovieTexture = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_MovieTexture = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_MovieTexture = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MovieTexture",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MovieTexture,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MovieTexture,
    &Dtool_SequenceMethods_MovieTexture,
    &Dtool_MappingMethods_MovieTexture,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_MovieTexture,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A texture that fetches video frames from an underlying object of class\n"
    " * Movie.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MovieTexture,
    0, // tp_members
    Dtool_Properties_MovieTexture,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MovieTexture,
    PyType_GenericAlloc,
    Dtool_new_MovieTexture,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MovieTexture,
  Dtool_UpcastInterface_MovieTexture,
  Dtool_DowncastInterface_MovieTexture,
  (CoerceFunction)Dtool_ConstCoerce_MovieTexture,
  (CoerceFunction)Dtool_Coerce_MovieTexture,
};

static void Dtool_PyModuleClassInit_MovieTexture(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Texture != NULL);
    assert(Dtool_Ptr_Texture->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Texture->_Dtool_ModuleClassInit(NULL);
    Dtool_MovieTexture._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Texture);
    PyObject *dict = PyDict_New();
    Dtool_MovieTexture._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MovieTexture) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MovieTexture)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MovieTexture);
  }
}

/**
 * Python method tables for MultitexReducer (MultitexReducer)
 */
static PyMethodDef Dtool_Methods_MultitexReducer[] = {
  {"clear", &Dtool_MultitexReducer_clear_184, METH_NOARGS, (const char *)Dtool_MultitexReducer_clear_184_comment},
  {"scan", (PyCFunction) &Dtool_MultitexReducer_scan_185, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MultitexReducer_scan_185_comment},
  {"set_target", &Dtool_MultitexReducer_set_target_186, METH_O, (const char *)Dtool_MultitexReducer_set_target_186_comment},
  {"setTarget", &Dtool_MultitexReducer_set_target_186, METH_O, (const char *)Dtool_MultitexReducer_set_target_186_comment},
  {"set_use_geom", &Dtool_MultitexReducer_set_use_geom_187, METH_O, (const char *)Dtool_MultitexReducer_set_use_geom_187_comment},
  {"setUseGeom", &Dtool_MultitexReducer_set_use_geom_187, METH_O, (const char *)Dtool_MultitexReducer_set_use_geom_187_comment},
  {"set_allow_tex_mat", &Dtool_MultitexReducer_set_allow_tex_mat_188, METH_O, (const char *)Dtool_MultitexReducer_set_allow_tex_mat_188_comment},
  {"setAllowTexMat", &Dtool_MultitexReducer_set_allow_tex_mat_188, METH_O, (const char *)Dtool_MultitexReducer_set_allow_tex_mat_188_comment},
  {"flatten", &Dtool_MultitexReducer_flatten_189, METH_O, (const char *)Dtool_MultitexReducer_flatten_189_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MultitexReducer = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_MultitexReducer = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MultitexReducer",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MultitexReducer,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MultitexReducer,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This object presents an interface for generating new texture images that\n"
    " * represent the combined images from one or more individual textures,\n"
    " * reproducing certain kinds of multitexture effects without depending on\n"
    " * multitexture support in the hardware.\n"
    " *\n"
    " * This also flattens out texture matrices and removes extra texture\n"
    " * coordinates from the Geoms.  It is thus not a complete substitute for true\n"
    " * multitexturing, because it does not lend itself well to dynamic animation\n"
    " * of the textures once they have been flattened.  It is, however, useful for\n"
    " * \"baking in\" a particular multitexture effect.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MultitexReducer,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MultitexReducer,
    PyType_GenericAlloc,
    Dtool_new_MultitexReducer,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MultitexReducer,
  Dtool_UpcastInterface_MultitexReducer,
  Dtool_DowncastInterface_MultitexReducer,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MultitexReducer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_MultitexReducer._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_MultitexReducer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MultitexReducer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MultitexReducer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MultitexReducer);
  }
}

/**
 * Python method tables for NodeVertexTransform (NodeVertexTransform)
 */
static PyMethodDef Dtool_Methods_NodeVertexTransform[] = {
  {"get_node", &Dtool_NodeVertexTransform_get_node_193, METH_NOARGS, (const char *)Dtool_NodeVertexTransform_get_node_193_comment},
  {"getNode", &Dtool_NodeVertexTransform_get_node_193, METH_NOARGS, (const char *)Dtool_NodeVertexTransform_get_node_193_comment},
  {"get_prev", &Dtool_NodeVertexTransform_get_prev_194, METH_NOARGS, (const char *)Dtool_NodeVertexTransform_get_prev_194_comment},
  {"getPrev", &Dtool_NodeVertexTransform_get_prev_194, METH_NOARGS, (const char *)Dtool_NodeVertexTransform_get_prev_194_comment},
  {"get_class_type", &Dtool_NodeVertexTransform_get_class_type_202, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodeVertexTransform_get_class_type_202_comment},
  {"getClassType", &Dtool_NodeVertexTransform_get_class_type_202, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodeVertexTransform_get_class_type_202_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_NodeVertexTransform[] = {
  {(char *)"node", &Dtool_NodeVertexTransform_node_Getter, NULL, NULL, NULL},
  {(char *)"prev", &Dtool_NodeVertexTransform_prev_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_NodeVertexTransform = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NodeVertexTransform = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_NodeVertexTransform = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_NodeVertexTransform = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_NodeVertexTransform = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.NodeVertexTransform",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_NodeVertexTransform,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_NodeVertexTransform,
    &Dtool_SequenceMethods_NodeVertexTransform,
    &Dtool_MappingMethods_NodeVertexTransform,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_NodeVertexTransform,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This VertexTransform gets its matrix from the Transform stored on a node.\n"
    " * It can also compose its node's transform with another VertexTransform,\n"
    " * allowing you to build up a chain of NodeVertexTransforms that represent a\n"
    " * list of composed matrices.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_NodeVertexTransform,
    0, // tp_members
    Dtool_Properties_NodeVertexTransform,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_NodeVertexTransform,
    PyType_GenericAlloc,
    Dtool_new_NodeVertexTransform,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NodeVertexTransform,
  Dtool_UpcastInterface_NodeVertexTransform,
  Dtool_DowncastInterface_NodeVertexTransform,
  (CoerceFunction)Dtool_ConstCoerce_NodeVertexTransform,
  (CoerceFunction)Dtool_Coerce_NodeVertexTransform,
};

static void Dtool_PyModuleClassInit_NodeVertexTransform(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_VertexTransform != NULL);
    assert(Dtool_Ptr_VertexTransform->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_VertexTransform->_Dtool_ModuleClassInit(NULL);
    Dtool_NodeVertexTransform._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_VertexTransform);
    PyObject *dict = PyDict_New();
    Dtool_NodeVertexTransform._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NodeVertexTransform) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NodeVertexTransform)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NodeVertexTransform);
  }
}

/**
 * Python method tables for ShaderTerrainMesh (ShaderTerrainMesh)
 */
static PyMethodDef Dtool_Methods_ShaderTerrainMesh[] = {
  {"set_heightfield", &Dtool_ShaderTerrainMesh_set_heightfield_206, METH_O, (const char *)Dtool_ShaderTerrainMesh_set_heightfield_206_comment},
  {"setHeightfield", &Dtool_ShaderTerrainMesh_set_heightfield_206, METH_O, (const char *)Dtool_ShaderTerrainMesh_set_heightfield_206_comment},
  {"get_heightfield", &Dtool_ShaderTerrainMesh_get_heightfield_207, METH_NOARGS, (const char *)Dtool_ShaderTerrainMesh_get_heightfield_207_comment},
  {"getHeightfield", &Dtool_ShaderTerrainMesh_get_heightfield_207, METH_NOARGS, (const char *)Dtool_ShaderTerrainMesh_get_heightfield_207_comment},
  {"set_chunk_size", &Dtool_ShaderTerrainMesh_set_chunk_size_210, METH_O, (const char *)Dtool_ShaderTerrainMesh_set_chunk_size_210_comment},
  {"setChunkSize", &Dtool_ShaderTerrainMesh_set_chunk_size_210, METH_O, (const char *)Dtool_ShaderTerrainMesh_set_chunk_size_210_comment},
  {"get_chunk_size", &Dtool_ShaderTerrainMesh_get_chunk_size_211, METH_NOARGS, (const char *)Dtool_ShaderTerrainMesh_get_chunk_size_211_comment},
  {"getChunkSize", &Dtool_ShaderTerrainMesh_get_chunk_size_211, METH_NOARGS, (const char *)Dtool_ShaderTerrainMesh_get_chunk_size_211_comment},
  {"set_generate_patches", &Dtool_ShaderTerrainMesh_set_generate_patches_215, METH_O, (const char *)Dtool_ShaderTerrainMesh_set_generate_patches_215_comment},
  {"setGeneratePatches", &Dtool_ShaderTerrainMesh_set_generate_patches_215, METH_O, (const char *)Dtool_ShaderTerrainMesh_set_generate_patches_215_comment},
  {"get_generate_patches", &Dtool_ShaderTerrainMesh_get_generate_patches_216, METH_NOARGS, (const char *)Dtool_ShaderTerrainMesh_get_generate_patches_216_comment},
  {"getGeneratePatches", &Dtool_ShaderTerrainMesh_get_generate_patches_216, METH_NOARGS, (const char *)Dtool_ShaderTerrainMesh_get_generate_patches_216_comment},
  {"set_update_enabled", &Dtool_ShaderTerrainMesh_set_update_enabled_218, METH_O, (const char *)Dtool_ShaderTerrainMesh_set_update_enabled_218_comment},
  {"setUpdateEnabled", &Dtool_ShaderTerrainMesh_set_update_enabled_218, METH_O, (const char *)Dtool_ShaderTerrainMesh_set_update_enabled_218_comment},
  {"get_update_enabled", &Dtool_ShaderTerrainMesh_get_update_enabled_219, METH_NOARGS, (const char *)Dtool_ShaderTerrainMesh_get_update_enabled_219_comment},
  {"getUpdateEnabled", &Dtool_ShaderTerrainMesh_get_update_enabled_219, METH_NOARGS, (const char *)Dtool_ShaderTerrainMesh_get_update_enabled_219_comment},
  {"set_target_triangle_width", &Dtool_ShaderTerrainMesh_set_target_triangle_width_221, METH_O, (const char *)Dtool_ShaderTerrainMesh_set_target_triangle_width_221_comment},
  {"setTargetTriangleWidth", &Dtool_ShaderTerrainMesh_set_target_triangle_width_221, METH_O, (const char *)Dtool_ShaderTerrainMesh_set_target_triangle_width_221_comment},
  {"get_target_triangle_width", &Dtool_ShaderTerrainMesh_get_target_triangle_width_222, METH_NOARGS, (const char *)Dtool_ShaderTerrainMesh_get_target_triangle_width_222_comment},
  {"getTargetTriangleWidth", &Dtool_ShaderTerrainMesh_get_target_triangle_width_222, METH_NOARGS, (const char *)Dtool_ShaderTerrainMesh_get_target_triangle_width_222_comment},
  {"uv_to_world", (PyCFunction) &Dtool_ShaderTerrainMesh_uv_to_world_226, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderTerrainMesh_uv_to_world_226_comment},
  {"uvToWorld", (PyCFunction) &Dtool_ShaderTerrainMesh_uv_to_world_226, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderTerrainMesh_uv_to_world_226_comment},
  {"generate", &Dtool_ShaderTerrainMesh_generate_227, METH_NOARGS, (const char *)Dtool_ShaderTerrainMesh_generate_227_comment},
  {"get_class_type", &Dtool_ShaderTerrainMesh_get_class_type_228, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderTerrainMesh_get_class_type_228_comment},
  {"getClassType", &Dtool_ShaderTerrainMesh_get_class_type_228, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderTerrainMesh_get_class_type_228_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ShaderTerrainMesh[] = {
  {(char *)"heightfield", &Dtool_ShaderTerrainMesh_heightfield_Getter, &Dtool_ShaderTerrainMesh_heightfield_Setter, NULL, NULL},
  {(char *)"chunk_size", &Dtool_ShaderTerrainMesh_chunk_size_Getter, &Dtool_ShaderTerrainMesh_chunk_size_Setter, NULL, NULL},
  {(char *)"generate_patches", &Dtool_ShaderTerrainMesh_generate_patches_Getter, &Dtool_ShaderTerrainMesh_generate_patches_Setter, NULL, NULL},
  {(char *)"update_enabled", &Dtool_ShaderTerrainMesh_update_enabled_Getter, &Dtool_ShaderTerrainMesh_update_enabled_Setter, NULL, NULL},
  {(char *)"target_triangle_width", &Dtool_ShaderTerrainMesh_target_triangle_width_Getter, &Dtool_ShaderTerrainMesh_target_triangle_width_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ShaderTerrainMesh = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ShaderTerrainMesh = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ShaderTerrainMesh = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ShaderTerrainMesh = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ShaderTerrainMesh = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ShaderTerrainMesh",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ShaderTerrainMesh,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ShaderTerrainMesh,
    &Dtool_SequenceMethods_ShaderTerrainMesh,
    &Dtool_MappingMethods_ShaderTerrainMesh,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ShaderTerrainMesh,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief Terrain Renderer class utilizing the GPU\n"
    " * @details This class provides functionality to render heightfields of large\n"
    " *   sizes utilizing the GPU. Internally a quadtree is used to generate the LODs.\n"
    " *   The final terrain is then rendered using instancing on the GPU. This makes\n"
    " *   it possible to use very large heightfields (8192+) with very reasonable\n"
    " *   performance. The terrain provides options to control the LOD using a\n"
    " *   target triangle width, see ShaderTerrainMesh::set_target_triangle_width().\n"
    " *\n"
    " *   Because the Terrain is rendered entirely on the GPU, it needs a special\n"
    " *   vertex shader. There is a default vertex shader available, which you can\n"
    " *   use in your own shaders. IMPORTANT: If you don't set an appropriate shader\n"
    " *   on the terrain, nothing will be visible.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ShaderTerrainMesh,
    0, // tp_members
    Dtool_Properties_ShaderTerrainMesh,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ShaderTerrainMesh,
    PyType_GenericAlloc,
    Dtool_new_ShaderTerrainMesh,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShaderTerrainMesh,
  Dtool_UpcastInterface_ShaderTerrainMesh,
  Dtool_DowncastInterface_ShaderTerrainMesh,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ShaderTerrainMesh(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_ShaderTerrainMesh._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_ShaderTerrainMesh._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ShaderTerrainMesh) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShaderTerrainMesh)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShaderTerrainMesh);
  }
}

/**
 * Python method tables for SceneGraphAnalyzerMeter (SceneGraphAnalyzerMeter)
 */
static PyMethodDef Dtool_Methods_SceneGraphAnalyzerMeter[] = {
  {"setup_window", &Dtool_SceneGraphAnalyzerMeter_setup_window_232, METH_O, (const char *)Dtool_SceneGraphAnalyzerMeter_setup_window_232_comment},
  {"setupWindow", &Dtool_SceneGraphAnalyzerMeter_setup_window_232, METH_O, (const char *)Dtool_SceneGraphAnalyzerMeter_setup_window_232_comment},
  {"clear_window", &Dtool_SceneGraphAnalyzerMeter_clear_window_233, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzerMeter_clear_window_233_comment},
  {"clearWindow", &Dtool_SceneGraphAnalyzerMeter_clear_window_233, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzerMeter_clear_window_233_comment},
  {"get_window", &Dtool_SceneGraphAnalyzerMeter_get_window_234, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzerMeter_get_window_234_comment},
  {"getWindow", &Dtool_SceneGraphAnalyzerMeter_get_window_234, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzerMeter_get_window_234_comment},
  {"get_display_region", &Dtool_SceneGraphAnalyzerMeter_get_display_region_235, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzerMeter_get_display_region_235_comment},
  {"getDisplayRegion", &Dtool_SceneGraphAnalyzerMeter_get_display_region_235, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzerMeter_get_display_region_235_comment},
  {"set_update_interval", &Dtool_SceneGraphAnalyzerMeter_set_update_interval_236, METH_O, (const char *)Dtool_SceneGraphAnalyzerMeter_set_update_interval_236_comment},
  {"setUpdateInterval", &Dtool_SceneGraphAnalyzerMeter_set_update_interval_236, METH_O, (const char *)Dtool_SceneGraphAnalyzerMeter_set_update_interval_236_comment},
  {"get_update_interval", &Dtool_SceneGraphAnalyzerMeter_get_update_interval_237, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzerMeter_get_update_interval_237_comment},
  {"getUpdateInterval", &Dtool_SceneGraphAnalyzerMeter_get_update_interval_237, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzerMeter_get_update_interval_237_comment},
  {"set_node", &Dtool_SceneGraphAnalyzerMeter_set_node_238, METH_O, (const char *)Dtool_SceneGraphAnalyzerMeter_set_node_238_comment},
  {"setNode", &Dtool_SceneGraphAnalyzerMeter_set_node_238, METH_O, (const char *)Dtool_SceneGraphAnalyzerMeter_set_node_238_comment},
  {"get_node", &Dtool_SceneGraphAnalyzerMeter_get_node_239, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzerMeter_get_node_239_comment},
  {"getNode", &Dtool_SceneGraphAnalyzerMeter_get_node_239, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzerMeter_get_node_239_comment},
  {"update", &Dtool_SceneGraphAnalyzerMeter_update_240, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzerMeter_update_240_comment},
  {"get_class_type", &Dtool_SceneGraphAnalyzerMeter_get_class_type_241, METH_NOARGS | METH_STATIC, (const char *)Dtool_SceneGraphAnalyzerMeter_get_class_type_241_comment},
  {"getClassType", &Dtool_SceneGraphAnalyzerMeter_get_class_type_241, METH_NOARGS | METH_STATIC, (const char *)Dtool_SceneGraphAnalyzerMeter_get_class_type_241_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_SceneGraphAnalyzerMeter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SceneGraphAnalyzerMeter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_SceneGraphAnalyzerMeter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_SceneGraphAnalyzerMeter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_SceneGraphAnalyzerMeter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.SceneGraphAnalyzerMeter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SceneGraphAnalyzerMeter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_SceneGraphAnalyzerMeter,
    &Dtool_SequenceMethods_SceneGraphAnalyzerMeter,
    &Dtool_MappingMethods_SceneGraphAnalyzerMeter,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_SceneGraphAnalyzerMeter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special TextNode that automatically updates itself with output\n"
    " * from a SceneGraphAnalyzer instance.  It can be placed anywhere in the world\n"
    " * where you'd like to see the output from SceneGraphAnalyzer.\n"
    " *\n"
    " * It also has a special mode in which it may be attached directly to a\n"
    " * channel or window.  If this is done, it creates a DisplayRegion for itself\n"
    " * and renders itself in the upper-right-hand corner.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SceneGraphAnalyzerMeter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SceneGraphAnalyzerMeter,
    PyType_GenericAlloc,
    Dtool_new_SceneGraphAnalyzerMeter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SceneGraphAnalyzerMeter,
  Dtool_UpcastInterface_SceneGraphAnalyzerMeter,
  Dtool_DowncastInterface_SceneGraphAnalyzerMeter,
  (CoerceFunction)Dtool_ConstCoerce_SceneGraphAnalyzerMeter,
  (CoerceFunction)Dtool_Coerce_SceneGraphAnalyzerMeter,
};

static void Dtool_PyModuleClassInit_SceneGraphAnalyzerMeter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TextNode != NULL);
    assert(Dtool_Ptr_TextNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TextNode->_Dtool_ModuleClassInit(NULL);
    Dtool_SceneGraphAnalyzerMeter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TextNode);
    PyObject *dict = PyDict_New();
    Dtool_SceneGraphAnalyzerMeter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SceneGraphAnalyzerMeter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SceneGraphAnalyzerMeter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SceneGraphAnalyzerMeter);
  }
}

/**
 * Python method tables for RigidBodyCombiner (RigidBodyCombiner)
 */
static PyMethodDef Dtool_Methods_RigidBodyCombiner[] = {
  {"collect", &Dtool_RigidBodyCombiner_collect_244, METH_NOARGS, (const char *)Dtool_RigidBodyCombiner_collect_244_comment},
  {"get_internal_scene", &Dtool_RigidBodyCombiner_get_internal_scene_245, METH_NOARGS, (const char *)Dtool_RigidBodyCombiner_get_internal_scene_245_comment},
  {"getInternalScene", &Dtool_RigidBodyCombiner_get_internal_scene_245, METH_NOARGS, (const char *)Dtool_RigidBodyCombiner_get_internal_scene_245_comment},
  {"get_class_type", &Dtool_RigidBodyCombiner_get_class_type_248, METH_NOARGS | METH_STATIC, (const char *)Dtool_RigidBodyCombiner_get_class_type_248_comment},
  {"getClassType", &Dtool_RigidBodyCombiner_get_class_type_248, METH_NOARGS | METH_STATIC, (const char *)Dtool_RigidBodyCombiner_get_class_type_248_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_RigidBodyCombiner[] = {
  {(char *)"internal_scene", &Dtool_RigidBodyCombiner_internal_scene_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_RigidBodyCombiner = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RigidBodyCombiner = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_RigidBodyCombiner = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_RigidBodyCombiner = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_RigidBodyCombiner = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.RigidBodyCombiner",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_RigidBodyCombiner,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_RigidBodyCombiner,
    &Dtool_SequenceMethods_RigidBodyCombiner,
    &Dtool_MappingMethods_RigidBodyCombiner,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_RigidBodyCombiner,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special node that combines multiple independently-moving rigid\n"
    " * nodes into one Geom internally (or as few Geoms as possible), for the\n"
    " * purposes of improving rendering performance.\n"
    " *\n"
    " * To use it, parent a number of moving objects to this node and call\n"
    " * collect().  A child node is identified as \"moving\" if (a) it has a non-\n"
    " * identity transform initially, or (b) it is a ModelNode with the\n"
    " * preserve_transform flag set.  Any other nodes will be considered static,\n"
    " * and later transforms applied to them will not be identified.\n"
    " *\n"
    " * You should call collect() only at startup or if you change the set of\n"
    " * children; it is a relatively expensive call.\n"
    " *\n"
    " * Once you call collect(), you may change the transforms on the child nodes\n"
    " * freely without having to call collect() again.\n"
    " *\n"
    " * RenderEffects such as Billboards are not supported below this node.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_RigidBodyCombiner,
    0, // tp_members
    Dtool_Properties_RigidBodyCombiner,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_RigidBodyCombiner,
    PyType_GenericAlloc,
    Dtool_new_RigidBodyCombiner,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RigidBodyCombiner,
  Dtool_UpcastInterface_RigidBodyCombiner,
  Dtool_DowncastInterface_RigidBodyCombiner,
  (CoerceFunction)Dtool_ConstCoerce_RigidBodyCombiner,
  (CoerceFunction)Dtool_Coerce_RigidBodyCombiner,
};

static void Dtool_PyModuleClassInit_RigidBodyCombiner(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_RigidBodyCombiner._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_RigidBodyCombiner._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RigidBodyCombiner) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RigidBodyCombiner)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RigidBodyCombiner);
  }
}

/**
 * Python method tables for PipeOcclusionCullTraverser (PipeOcclusionCullTraverser)
 */
static PyMethodDef Dtool_Methods_PipeOcclusionCullTraverser[] = {
  {"set_scene", (PyCFunction) &Dtool_PipeOcclusionCullTraverser_set_scene_258, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PipeOcclusionCullTraverser_set_scene_258_comment},
  {"setScene", (PyCFunction) &Dtool_PipeOcclusionCullTraverser_set_scene_258, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PipeOcclusionCullTraverser_set_scene_258_comment},
  {"end_traverse", &Dtool_PipeOcclusionCullTraverser_end_traverse_259, METH_NOARGS, (const char *)Dtool_PipeOcclusionCullTraverser_end_traverse_259_comment},
  {"endTraverse", &Dtool_PipeOcclusionCullTraverser_end_traverse_259, METH_NOARGS, (const char *)Dtool_PipeOcclusionCullTraverser_end_traverse_259_comment},
  {"get_buffer", &Dtool_PipeOcclusionCullTraverser_get_buffer_260, METH_NOARGS, (const char *)Dtool_PipeOcclusionCullTraverser_get_buffer_260_comment},
  {"getBuffer", &Dtool_PipeOcclusionCullTraverser_get_buffer_260, METH_NOARGS, (const char *)Dtool_PipeOcclusionCullTraverser_get_buffer_260_comment},
  {"get_texture", &Dtool_PipeOcclusionCullTraverser_get_texture_261, METH_NOARGS, (const char *)Dtool_PipeOcclusionCullTraverser_get_texture_261_comment},
  {"getTexture", &Dtool_PipeOcclusionCullTraverser_get_texture_261, METH_NOARGS, (const char *)Dtool_PipeOcclusionCullTraverser_get_texture_261_comment},
  {"set_occlusion_mask", &Dtool_PipeOcclusionCullTraverser_set_occlusion_mask_262, METH_O, (const char *)Dtool_PipeOcclusionCullTraverser_set_occlusion_mask_262_comment},
  {"setOcclusionMask", &Dtool_PipeOcclusionCullTraverser_set_occlusion_mask_262, METH_O, (const char *)Dtool_PipeOcclusionCullTraverser_set_occlusion_mask_262_comment},
  {"get_occlusion_mask", &Dtool_PipeOcclusionCullTraverser_get_occlusion_mask_263, METH_NOARGS, (const char *)Dtool_PipeOcclusionCullTraverser_get_occlusion_mask_263_comment},
  {"getOcclusionMask", &Dtool_PipeOcclusionCullTraverser_get_occlusion_mask_263, METH_NOARGS, (const char *)Dtool_PipeOcclusionCullTraverser_get_occlusion_mask_263_comment},
  {"get_class_type", &Dtool_PipeOcclusionCullTraverser_get_class_type_264, METH_NOARGS | METH_STATIC, (const char *)Dtool_PipeOcclusionCullTraverser_get_class_type_264_comment},
  {"getClassType", &Dtool_PipeOcclusionCullTraverser_get_class_type_264, METH_NOARGS | METH_STATIC, (const char *)Dtool_PipeOcclusionCullTraverser_get_class_type_264_comment},
  {"upcast_to_CullTraverser", &Dtool_PipeOcclusionCullTraverser_upcast_to_CullTraverser_252, METH_NOARGS, (const char *)Dtool_PipeOcclusionCullTraverser_upcast_to_CullTraverser_252_comment},
  {"upcastToCullTraverser", &Dtool_PipeOcclusionCullTraverser_upcast_to_CullTraverser_252, METH_NOARGS, (const char *)Dtool_PipeOcclusionCullTraverser_upcast_to_CullTraverser_252_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PipeOcclusionCullTraverser = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PipeOcclusionCullTraverser = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PipeOcclusionCullTraverser = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PipeOcclusionCullTraverser = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PipeOcclusionCullTraverser = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PipeOcclusionCullTraverser",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PipeOcclusionCullTraverser,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PipeOcclusionCullTraverser,
    &Dtool_SequenceMethods_PipeOcclusionCullTraverser,
    &Dtool_MappingMethods_PipeOcclusionCullTraverser,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PipeOcclusionCullTraverser,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This specialization of CullTraverser uses the graphics pipe itself to\n"
    " * perform occlusion culling.  As such, it's likely to be inefficient (since\n"
    " * it interferes with the pipe's normal mode of rendering), and is mainly\n"
    " * useful to test other, CPU-based occlusion algorithms.\n"
    " *\n"
    " * This cannot be used in a multithreaded pipeline environment where cull and\n"
    " * draw are operating simultaneously.\n"
    " *\n"
    " * It can't be defined in the cull subdirectory, because it needs access to\n"
    " * GraphicsPipe and DisplayRegion and other classes in display.  So we put it\n"
    " * in grutil instead, for lack of any better ideas.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PipeOcclusionCullTraverser,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PipeOcclusionCullTraverser,
    PyType_GenericAlloc,
    Dtool_new_PipeOcclusionCullTraverser,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PipeOcclusionCullTraverser,
  Dtool_UpcastInterface_PipeOcclusionCullTraverser,
  Dtool_DowncastInterface_PipeOcclusionCullTraverser,
  (CoerceFunction)Dtool_ConstCoerce_PipeOcclusionCullTraverser,
  (CoerceFunction)Dtool_Coerce_PipeOcclusionCullTraverser,
};

static void Dtool_PyModuleClassInit_PipeOcclusionCullTraverser(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CullTraverser != NULL);
    assert(Dtool_Ptr_CullTraverser->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_CullTraverser->_Dtool_ModuleClassInit(NULL);
    Dtool_PipeOcclusionCullTraverser._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_CullTraverser);
    PyObject *dict = PyDict_New();
    Dtool_PipeOcclusionCullTraverser._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PipeOcclusionCullTraverser) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PipeOcclusionCullTraverser)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PipeOcclusionCullTraverser);
  }
}

/**
 * Python method tables for PfmVizzer (PfmVizzer)
 */
static PyMethodDef Dtool_Methods_PfmVizzer[] = {
  {"get_pfm", &Dtool_PfmVizzer_get_pfm_268, METH_NOARGS, (const char *)Dtool_PfmVizzer_get_pfm_268_comment},
  {"getPfm", &Dtool_PfmVizzer_get_pfm_268, METH_NOARGS, (const char *)Dtool_PfmVizzer_get_pfm_268_comment},
  {"project", (PyCFunction) &Dtool_PfmVizzer_project_269, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmVizzer_project_269_comment},
  {"extrude", &Dtool_PfmVizzer_extrude_270, METH_O, (const char *)Dtool_PfmVizzer_extrude_270_comment},
  {"set_vis_inverse", &Dtool_PfmVizzer_set_vis_inverse_271, METH_O, (const char *)Dtool_PfmVizzer_set_vis_inverse_271_comment},
  {"setVisInverse", &Dtool_PfmVizzer_set_vis_inverse_271, METH_O, (const char *)Dtool_PfmVizzer_set_vis_inverse_271_comment},
  {"get_vis_inverse", &Dtool_PfmVizzer_get_vis_inverse_272, METH_NOARGS, (const char *)Dtool_PfmVizzer_get_vis_inverse_272_comment},
  {"getVisInverse", &Dtool_PfmVizzer_get_vis_inverse_272, METH_NOARGS, (const char *)Dtool_PfmVizzer_get_vis_inverse_272_comment},
  {"set_flat_texcoord_name", &Dtool_PfmVizzer_set_flat_texcoord_name_273, METH_O, (const char *)Dtool_PfmVizzer_set_flat_texcoord_name_273_comment},
  {"setFlatTexcoordName", &Dtool_PfmVizzer_set_flat_texcoord_name_273, METH_O, (const char *)Dtool_PfmVizzer_set_flat_texcoord_name_273_comment},
  {"clear_flat_texcoord_name", &Dtool_PfmVizzer_clear_flat_texcoord_name_274, METH_NOARGS, (const char *)Dtool_PfmVizzer_clear_flat_texcoord_name_274_comment},
  {"clearFlatTexcoordName", &Dtool_PfmVizzer_clear_flat_texcoord_name_274, METH_NOARGS, (const char *)Dtool_PfmVizzer_clear_flat_texcoord_name_274_comment},
  {"get_flat_texcoord_name", &Dtool_PfmVizzer_get_flat_texcoord_name_275, METH_NOARGS, (const char *)Dtool_PfmVizzer_get_flat_texcoord_name_275_comment},
  {"getFlatTexcoordName", &Dtool_PfmVizzer_get_flat_texcoord_name_275, METH_NOARGS, (const char *)Dtool_PfmVizzer_get_flat_texcoord_name_275_comment},
  {"set_vis_2d", &Dtool_PfmVizzer_set_vis_2d_276, METH_O, (const char *)Dtool_PfmVizzer_set_vis_2d_276_comment},
  {"setVis2d", &Dtool_PfmVizzer_set_vis_2d_276, METH_O, (const char *)Dtool_PfmVizzer_set_vis_2d_276_comment},
  {"get_vis_2d", &Dtool_PfmVizzer_get_vis_2d_277, METH_NOARGS, (const char *)Dtool_PfmVizzer_get_vis_2d_277_comment},
  {"getVis2d", &Dtool_PfmVizzer_get_vis_2d_277, METH_NOARGS, (const char *)Dtool_PfmVizzer_get_vis_2d_277_comment},
  {"set_keep_beyond_lens", &Dtool_PfmVizzer_set_keep_beyond_lens_278, METH_O, (const char *)Dtool_PfmVizzer_set_keep_beyond_lens_278_comment},
  {"setKeepBeyondLens", &Dtool_PfmVizzer_set_keep_beyond_lens_278, METH_O, (const char *)Dtool_PfmVizzer_set_keep_beyond_lens_278_comment},
  {"get_keep_beyond_lens", &Dtool_PfmVizzer_get_keep_beyond_lens_279, METH_NOARGS, (const char *)Dtool_PfmVizzer_get_keep_beyond_lens_279_comment},
  {"getKeepBeyondLens", &Dtool_PfmVizzer_get_keep_beyond_lens_279, METH_NOARGS, (const char *)Dtool_PfmVizzer_get_keep_beyond_lens_279_comment},
  {"set_vis_blend", &Dtool_PfmVizzer_set_vis_blend_280, METH_O, (const char *)Dtool_PfmVizzer_set_vis_blend_280_comment},
  {"setVisBlend", &Dtool_PfmVizzer_set_vis_blend_280, METH_O, (const char *)Dtool_PfmVizzer_set_vis_blend_280_comment},
  {"clear_vis_blend", &Dtool_PfmVizzer_clear_vis_blend_281, METH_NOARGS, (const char *)Dtool_PfmVizzer_clear_vis_blend_281_comment},
  {"clearVisBlend", &Dtool_PfmVizzer_clear_vis_blend_281, METH_NOARGS, (const char *)Dtool_PfmVizzer_clear_vis_blend_281_comment},
  {"get_vis_blend", &Dtool_PfmVizzer_get_vis_blend_282, METH_NOARGS, (const char *)Dtool_PfmVizzer_get_vis_blend_282_comment},
  {"getVisBlend", &Dtool_PfmVizzer_get_vis_blend_282, METH_NOARGS, (const char *)Dtool_PfmVizzer_get_vis_blend_282_comment},
  {"set_aux_pfm", &Dtool_PfmVizzer_set_aux_pfm_283, METH_O, (const char *)Dtool_PfmVizzer_set_aux_pfm_283_comment},
  {"setAuxPfm", &Dtool_PfmVizzer_set_aux_pfm_283, METH_O, (const char *)Dtool_PfmVizzer_set_aux_pfm_283_comment},
  {"clear_aux_pfm", &Dtool_PfmVizzer_clear_aux_pfm_284, METH_NOARGS, (const char *)Dtool_PfmVizzer_clear_aux_pfm_284_comment},
  {"clearAuxPfm", &Dtool_PfmVizzer_clear_aux_pfm_284, METH_NOARGS, (const char *)Dtool_PfmVizzer_clear_aux_pfm_284_comment},
  {"get_aux_pfm", &Dtool_PfmVizzer_get_aux_pfm_285, METH_NOARGS, (const char *)Dtool_PfmVizzer_get_aux_pfm_285_comment},
  {"getAuxPfm", &Dtool_PfmVizzer_get_aux_pfm_285, METH_NOARGS, (const char *)Dtool_PfmVizzer_get_aux_pfm_285_comment},
  {"clear_vis_columns", &Dtool_PfmVizzer_clear_vis_columns_287, METH_NOARGS, (const char *)Dtool_PfmVizzer_clear_vis_columns_287_comment},
  {"clearVisColumns", &Dtool_PfmVizzer_clear_vis_columns_287, METH_NOARGS, (const char *)Dtool_PfmVizzer_clear_vis_columns_287_comment},
  {"add_vis_column", (PyCFunction) &Dtool_PfmVizzer_add_vis_column_288, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmVizzer_add_vis_column_288_comment},
  {"addVisColumn", (PyCFunction) &Dtool_PfmVizzer_add_vis_column_288, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmVizzer_add_vis_column_288_comment},
  {"generate_vis_points", &Dtool_PfmVizzer_generate_vis_points_289, METH_NOARGS, (const char *)Dtool_PfmVizzer_generate_vis_points_289_comment},
  {"generateVisPoints", &Dtool_PfmVizzer_generate_vis_points_289, METH_NOARGS, (const char *)Dtool_PfmVizzer_generate_vis_points_289_comment},
  {"generate_vis_mesh", (PyCFunction) &Dtool_PfmVizzer_generate_vis_mesh_291, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmVizzer_generate_vis_mesh_291_comment},
  {"generateVisMesh", (PyCFunction) &Dtool_PfmVizzer_generate_vis_mesh_291, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmVizzer_generate_vis_mesh_291_comment},
  {"calc_max_u_displacement", &Dtool_PfmVizzer_calc_max_u_displacement_292, METH_NOARGS, (const char *)Dtool_PfmVizzer_calc_max_u_displacement_292_comment},
  {"calcMaxUDisplacement", &Dtool_PfmVizzer_calc_max_u_displacement_292, METH_NOARGS, (const char *)Dtool_PfmVizzer_calc_max_u_displacement_292_comment},
  {"calc_max_v_displacement", &Dtool_PfmVizzer_calc_max_v_displacement_293, METH_NOARGS, (const char *)Dtool_PfmVizzer_calc_max_v_displacement_293_comment},
  {"calcMaxVDisplacement", &Dtool_PfmVizzer_calc_max_v_displacement_293, METH_NOARGS, (const char *)Dtool_PfmVizzer_calc_max_v_displacement_293_comment},
  {"make_displacement", (PyCFunction) &Dtool_PfmVizzer_make_displacement_294, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmVizzer_make_displacement_294_comment},
  {"makeDisplacement", (PyCFunction) &Dtool_PfmVizzer_make_displacement_294, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmVizzer_make_displacement_294_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PfmVizzer = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_PfmVizzer = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PfmVizzer",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PfmVizzer,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PfmVizzer,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class aids in the visualization and manipulation of PfmFile objects.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PfmVizzer,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PfmVizzer,
    PyType_GenericAlloc,
    Dtool_new_PfmVizzer,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PfmVizzer,
  Dtool_UpcastInterface_PfmVizzer,
  Dtool_DowncastInterface_PfmVizzer,
  (CoerceFunction)Dtool_ConstCoerce_PfmVizzer,
  (CoerceFunction)Dtool_Coerce_PfmVizzer,
};

static void Dtool_PyModuleClassInit_PfmVizzer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PfmVizzer._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(27);
    Dtool_PfmVizzer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum PfmVizzer::ColumnType;
    PyDict_SetItemString(dict, "CT_texcoord2", Dtool_WrapValue(PfmVizzer::CT_texcoord2));
    PyDict_SetItemString(dict, "CTTexcoord2", Dtool_WrapValue(PfmVizzer::CT_texcoord2));
    PyDict_SetItemString(dict, "CT_texcoord3", Dtool_WrapValue(PfmVizzer::CT_texcoord3));
    PyDict_SetItemString(dict, "CTTexcoord3", Dtool_WrapValue(PfmVizzer::CT_texcoord3));
    PyDict_SetItemString(dict, "CT_vertex1", Dtool_WrapValue(PfmVizzer::CT_vertex1));
    PyDict_SetItemString(dict, "CTVertex1", Dtool_WrapValue(PfmVizzer::CT_vertex1));
    PyDict_SetItemString(dict, "CT_vertex2", Dtool_WrapValue(PfmVizzer::CT_vertex2));
    PyDict_SetItemString(dict, "CTVertex2", Dtool_WrapValue(PfmVizzer::CT_vertex2));
    PyDict_SetItemString(dict, "CT_vertex3", Dtool_WrapValue(PfmVizzer::CT_vertex3));
    PyDict_SetItemString(dict, "CTVertex3", Dtool_WrapValue(PfmVizzer::CT_vertex3));
    PyDict_SetItemString(dict, "CT_normal3", Dtool_WrapValue(PfmVizzer::CT_normal3));
    PyDict_SetItemString(dict, "CTNormal3", Dtool_WrapValue(PfmVizzer::CT_normal3));
    PyDict_SetItemString(dict, "CT_blend1", Dtool_WrapValue(PfmVizzer::CT_blend1));
    PyDict_SetItemString(dict, "CTBlend1", Dtool_WrapValue(PfmVizzer::CT_blend1));
    PyDict_SetItemString(dict, "CT_aux_vertex1", Dtool_WrapValue(PfmVizzer::CT_aux_vertex1));
    PyDict_SetItemString(dict, "CTAuxVertex1", Dtool_WrapValue(PfmVizzer::CT_aux_vertex1));
    PyDict_SetItemString(dict, "CT_aux_vertex2", Dtool_WrapValue(PfmVizzer::CT_aux_vertex2));
    PyDict_SetItemString(dict, "CTAuxVertex2", Dtool_WrapValue(PfmVizzer::CT_aux_vertex2));
    PyDict_SetItemString(dict, "CT_aux_vertex3", Dtool_WrapValue(PfmVizzer::CT_aux_vertex3));
    PyDict_SetItemString(dict, "CTAuxVertex3", Dtool_WrapValue(PfmVizzer::CT_aux_vertex3));
    // enum PfmVizzer::MeshFace;
    PyDict_SetItemString(dict, "MF_front", Dtool_WrapValue(PfmVizzer::MF_front));
    PyDict_SetItemString(dict, "MFFront", Dtool_WrapValue(PfmVizzer::MF_front));
    PyDict_SetItemString(dict, "MF_back", Dtool_WrapValue(PfmVizzer::MF_back));
    PyDict_SetItemString(dict, "MFBack", Dtool_WrapValue(PfmVizzer::MF_back));
    PyDict_SetItemString(dict, "MF_both", Dtool_WrapValue(PfmVizzer::MF_both));
    PyDict_SetItemString(dict, "MFBoth", Dtool_WrapValue(PfmVizzer::MF_both));
    if (PyType_Ready((PyTypeObject *)&Dtool_PfmVizzer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PfmVizzer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PfmVizzer);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3grutil_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("CardMaker", Dtool_CardMaker);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("FisheyeMaker", Dtool_FisheyeMaker);
#endif
  Dtool_FrameRateMeter._type = FrameRateMeter::get_class_type();
  RegisterRuntimeTypedClass(Dtool_FrameRateMeter);
  Dtool_GeoMipTerrain._type = GeoMipTerrain::get_class_type();
  RegisterRuntimeTypedClass(Dtool_GeoMipTerrain);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("HeightfieldTesselator", Dtool_HeightfieldTesselator);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LineSegs", Dtool_LineSegs);
#endif
  Dtool_MeshDrawer._type = MeshDrawer::get_class_type();
  RegisterRuntimeTypedClass(Dtool_MeshDrawer);
  Dtool_MeshDrawer2D._type = MeshDrawer2D::get_class_type();
  RegisterRuntimeTypedClass(Dtool_MeshDrawer2D);
  Dtool_MovieTexture._type = MovieTexture::get_class_type();
  RegisterRuntimeTypedClass(Dtool_MovieTexture);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("MultitexReducer", Dtool_MultitexReducer);
#endif
  Dtool_NodeVertexTransform._type = NodeVertexTransform::get_class_type();
  RegisterRuntimeTypedClass(Dtool_NodeVertexTransform);
  Dtool_ShaderTerrainMesh._type = ShaderTerrainMesh::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ShaderTerrainMesh);
  Dtool_SceneGraphAnalyzerMeter._type = SceneGraphAnalyzerMeter::get_class_type();
  RegisterRuntimeTypedClass(Dtool_SceneGraphAnalyzerMeter);
  Dtool_RigidBodyCombiner._type = RigidBodyCombiner::get_class_type();
  RegisterRuntimeTypedClass(Dtool_RigidBodyCombiner);
  Dtool_PipeOcclusionCullTraverser._type = PipeOcclusionCullTraverser::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PipeOcclusionCullTraverser);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PfmVizzer", Dtool_PfmVizzer);
#endif
}

void Dtool_libp3grutil_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_Filename = LookupRuntimeTypedClass(Filename::get_class_type());
  Dtool_Ptr_TextEncoder = LookupNamedClass("TextEncoder");
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_LVecBase2f = LookupRuntimeTypedClass(LVecBase2f::get_class_type());
  Dtool_Ptr_LVector2f = LookupRuntimeTypedClass(LVector2f::get_class_type());
  Dtool_Ptr_LPoint2f = LookupRuntimeTypedClass(LPoint2f::get_class_type());
  Dtool_Ptr_LPoint2d = LookupRuntimeTypedClass(LPoint2d::get_class_type());
  Dtool_Ptr_LVecBase3f = LookupRuntimeTypedClass(LVecBase3f::get_class_type());
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_LVector3f = LookupRuntimeTypedClass(LVector3f::get_class_type());
  Dtool_Ptr_LPoint3d = LookupRuntimeTypedClass(LPoint3d::get_class_type());
  Dtool_Ptr_LPoint3f = LookupRuntimeTypedClass(LPoint3f::get_class_type());
  Dtool_Ptr_LVector4f = LookupRuntimeTypedClass(LVector4f::get_class_type());
  Dtool_Ptr_LVecBase4f = LookupRuntimeTypedClass(LVecBase4f::get_class_type());
  Dtool_Ptr_TypedWritableReferenceCount = LookupRuntimeTypedClass(TypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_TypedWritable = LookupRuntimeTypedClass(TypedWritable::get_class_type());
  Dtool_Ptr_InternalName = LookupRuntimeTypedClass(InternalName::get_class_type());
  Dtool_Ptr_BitMask_uint32_t_32 = LookupRuntimeTypedClass(BitMask< uint32_t, 32 >::get_class_type());
  Dtool_Ptr_VertexTransform = LookupRuntimeTypedClass(VertexTransform::get_class_type());
  Dtool_Ptr_TextureStage = LookupRuntimeTypedClass(TextureStage::get_class_type());
  Dtool_Ptr_PandaNode = LookupRuntimeTypedClass(PandaNode::get_class_type());
  Dtool_Ptr_ClockObject = LookupRuntimeTypedClass(ClockObject::get_class_type());
  Dtool_Ptr_TransformState = LookupRuntimeTypedClass(TransformState::get_class_type());
  Dtool_Ptr_GraphicsStateGuardianBase = LookupRuntimeTypedClass(GraphicsStateGuardianBase::get_class_type());
  Dtool_Ptr_RenderState = LookupRuntimeTypedClass(RenderState::get_class_type());
  Dtool_Ptr_Texture = LookupRuntimeTypedClass(Texture::get_class_type());
  Dtool_Ptr_TextProperties = LookupRuntimeTypedClass(TextProperties::get_class_type());
  Dtool_Ptr_GeomNode = LookupRuntimeTypedClass(GeomNode::get_class_type());
  Dtool_Ptr_TextNode = LookupRuntimeTypedClass(TextNode::get_class_type());
  Dtool_Ptr_NodePath = LookupRuntimeTypedClass(NodePath::get_class_type());
  Dtool_Ptr_SceneSetup = LookupRuntimeTypedClass(SceneSetup::get_class_type());
  Dtool_Ptr_CullTraverser = LookupRuntimeTypedClass(CullTraverser::get_class_type());
  Dtool_Ptr_DisplayRegion = LookupRuntimeTypedClass(DisplayRegion::get_class_type());
  Dtool_Ptr_Lens = LookupRuntimeTypedClass(Lens::get_class_type());
  Dtool_Ptr_GraphicsOutput = LookupRuntimeTypedClass(GraphicsOutput::get_class_type());
  Dtool_Ptr_PNMImage = LookupNamedClass("PNMImage");
  Dtool_Ptr_MovieVideo = LookupRuntimeTypedClass(MovieVideo::get_class_type());
  Dtool_Ptr_MovieVideoCursor = LookupRuntimeTypedClass(MovieVideoCursor::get_class_type());
  Dtool_Ptr_AudioSound = LookupRuntimeTypedClass(AudioSound::get_class_type());
  Dtool_Ptr_PfmFile = LookupNamedClass("PfmFile");
#endif
}

void Dtool_libp3grutil_BuildInstants(PyObject *module) {
  (void) module;
  // CardMaker
  Dtool_PyModuleClassInit_CardMaker(module);
  PyModule_AddObject(module, "CardMaker", (PyObject *)&Dtool_CardMaker);
  // FisheyeMaker
  Dtool_PyModuleClassInit_FisheyeMaker(module);
  PyModule_AddObject(module, "FisheyeMaker", (PyObject *)&Dtool_FisheyeMaker);
  // FrameRateMeter
  Dtool_PyModuleClassInit_FrameRateMeter(module);
  PyModule_AddObject(module, "FrameRateMeter", (PyObject *)&Dtool_FrameRateMeter);
  // GeoMipTerrain
  Dtool_PyModuleClassInit_GeoMipTerrain(module);
  PyModule_AddObject(module, "GeoMipTerrain", (PyObject *)&Dtool_GeoMipTerrain);
  // HeightfieldTesselator
  Dtool_PyModuleClassInit_HeightfieldTesselator(module);
  PyModule_AddObject(module, "HeightfieldTesselator", (PyObject *)&Dtool_HeightfieldTesselator);
  // LineSegs
  Dtool_PyModuleClassInit_LineSegs(module);
  PyModule_AddObject(module, "LineSegs", (PyObject *)&Dtool_LineSegs);
  // MeshDrawer
  Dtool_PyModuleClassInit_MeshDrawer(module);
  PyModule_AddObject(module, "MeshDrawer", (PyObject *)&Dtool_MeshDrawer);
  // MeshDrawer2D
  Dtool_PyModuleClassInit_MeshDrawer2D(module);
  PyModule_AddObject(module, "MeshDrawer2D", (PyObject *)&Dtool_MeshDrawer2D);
  // MovieTexture
  Dtool_PyModuleClassInit_MovieTexture(module);
  PyModule_AddObject(module, "MovieTexture", (PyObject *)&Dtool_MovieTexture);
  // MultitexReducer
  Dtool_PyModuleClassInit_MultitexReducer(module);
  PyModule_AddObject(module, "MultitexReducer", (PyObject *)&Dtool_MultitexReducer);
  // NodeVertexTransform
  Dtool_PyModuleClassInit_NodeVertexTransform(module);
  PyModule_AddObject(module, "NodeVertexTransform", (PyObject *)&Dtool_NodeVertexTransform);
  // ShaderTerrainMesh
  Dtool_PyModuleClassInit_ShaderTerrainMesh(module);
  PyModule_AddObject(module, "ShaderTerrainMesh", (PyObject *)&Dtool_ShaderTerrainMesh);
  // SceneGraphAnalyzerMeter
  Dtool_PyModuleClassInit_SceneGraphAnalyzerMeter(module);
  PyModule_AddObject(module, "SceneGraphAnalyzerMeter", (PyObject *)&Dtool_SceneGraphAnalyzerMeter);
  // RigidBodyCombiner
  Dtool_PyModuleClassInit_RigidBodyCombiner(module);
  PyModule_AddObject(module, "RigidBodyCombiner", (PyObject *)&Dtool_RigidBodyCombiner);
  // PipeOcclusionCullTraverser
  Dtool_PyModuleClassInit_PipeOcclusionCullTraverser(module);
  PyModule_AddObject(module, "PipeOcclusionCullTraverser", (PyObject *)&Dtool_PipeOcclusionCullTraverser);
  // PfmVizzer
  Dtool_PyModuleClassInit_PfmVizzer(module);
  PyModule_AddObject(module, "PfmVizzer", (PyObject *)&Dtool_PfmVizzer);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3grutil_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478213226,  /* file_identifier */
  "libp3grutil",  /* library_name */
  "sM0l",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3grutil.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  725  /* next_index */
};

Configure(_in_configure_libp3grutil);
ConfigureFn(_in_configure_libp3grutil) {
  interrogate_request_module(&_in_module_def);
}

