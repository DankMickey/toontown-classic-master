/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/device -Ipanda/src/device -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3device_igate.cxx -od built/pandac/input/libp3device.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/device -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3device analogNode.h buttonNode.h clientAnalogDevice.h clientBase.h clientButtonDevice.h clientDevice.h clientDialDevice.h clientTrackerDevice.h config_device.h dialNode.h mouseAndKeyboard.h p3device_composite1.cxx p3device_composite2.cxx trackerData.h trackerNode.h virtualMouse.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3device
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "analogNode.h"
#include "buttonEventList.h"
#include "buttonNode.h"
#include "clientAnalogDevice.h"
#include "clientBase.h"
#include "clientButtonDevice.h"
#include "clientDevice.h"
#include "clientDialDevice.h"
#include "clientTrackerDevice.h"
#include "configVariableBool.h"
#include "config_device.h"
#include "dataNode.h"
#include "dialNode.h"
#include "graphicsWindow.h"
#include "linmath_events.h"
#include "mouseAndKeyboard.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "pointerEventList.h"
#include "pointerTo.h"
#include "trackerData.h"
#include "trackerNode.h"
#include "virtualMouse.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class ClientBase
 */
typedef ClientBase ClientBase_localtype;
Define_Module_ClassRef(panda3d.core, ClientBase, ClientBase_localtype, ClientBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ClientBase = &Dtool_ClientBase;
static void Dtool_PyModuleClassInit_ClientBase(PyObject *module);

/**
 * Forward declarations for top-level class AnalogNode
 */
typedef AnalogNode AnalogNode_localtype;
Define_Module_ClassRef(panda3d.core, AnalogNode, AnalogNode_localtype, AnalogNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnalogNode = &Dtool_AnalogNode;
static void Dtool_PyModuleClassInit_AnalogNode(PyObject *module);
bool Dtool_ConstCoerce_AnalogNode(PyObject *args, CPT(AnalogNode) &coerced);
bool Dtool_Coerce_AnalogNode(PyObject *args, PT(AnalogNode) &coerced);

/**
 * Forward declarations for top-level class ButtonNode
 */
typedef ButtonNode ButtonNode_localtype;
Define_Module_ClassRef(panda3d.core, ButtonNode, ButtonNode_localtype, ButtonNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ButtonNode = &Dtool_ButtonNode;
static void Dtool_PyModuleClassInit_ButtonNode(PyObject *module);
bool Dtool_ConstCoerce_ButtonNode(PyObject *args, CPT(ButtonNode) &coerced);
bool Dtool_Coerce_ButtonNode(PyObject *args, PT(ButtonNode) &coerced);

/**
 * Forward declarations for top-level class TrackerData
 */
typedef TrackerData TrackerData_localtype;
Define_Module_Class(panda3d.core, TrackerData, TrackerData_localtype, TrackerData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TrackerData = &Dtool_TrackerData;
static void Dtool_PyModuleClassInit_TrackerData(PyObject *module);

/**
 * Forward declarations for top-level class DialNode
 */
typedef DialNode DialNode_localtype;
Define_Module_ClassRef(panda3d.core, DialNode, DialNode_localtype, DialNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DialNode = &Dtool_DialNode;
static void Dtool_PyModuleClassInit_DialNode(PyObject *module);
bool Dtool_ConstCoerce_DialNode(PyObject *args, CPT(DialNode) &coerced);
bool Dtool_Coerce_DialNode(PyObject *args, PT(DialNode) &coerced);

/**
 * Forward declarations for top-level class MouseAndKeyboard
 */
typedef MouseAndKeyboard MouseAndKeyboard_localtype;
Define_Module_ClassRef(panda3d.core, MouseAndKeyboard, MouseAndKeyboard_localtype, MouseAndKeyboard);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MouseAndKeyboard = &Dtool_MouseAndKeyboard;
static void Dtool_PyModuleClassInit_MouseAndKeyboard(PyObject *module);
bool Dtool_ConstCoerce_MouseAndKeyboard(PyObject *args, CPT(MouseAndKeyboard) &coerced);
bool Dtool_Coerce_MouseAndKeyboard(PyObject *args, PT(MouseAndKeyboard) &coerced);

/**
 * Forward declarations for top-level class TrackerNode
 */
typedef TrackerNode TrackerNode_localtype;
Define_Module_ClassRef(panda3d.core, TrackerNode, TrackerNode_localtype, TrackerNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TrackerNode = &Dtool_TrackerNode;
static void Dtool_PyModuleClassInit_TrackerNode(PyObject *module);
bool Dtool_ConstCoerce_TrackerNode(PyObject *args, CPT(TrackerNode) &coerced);
bool Dtool_Coerce_TrackerNode(PyObject *args, PT(TrackerNode) &coerced);

/**
 * Forward declarations for top-level class VirtualMouse
 */
typedef VirtualMouse VirtualMouse_localtype;
Define_Module_ClassRef(panda3d.core, VirtualMouse, VirtualMouse_localtype, VirtualMouse);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualMouse = &Dtool_VirtualMouse;
static void Dtool_PyModuleClassInit_VirtualMouse(PyObject *module);
bool Dtool_ConstCoerce_VirtualMouse(PyObject *args, CPT(VirtualMouse) &coerced);
bool Dtool_Coerce_VirtualMouse(PyObject *args, PT(VirtualMouse) &coerced);

/**
 * Extern declarations for imported classes
 */
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint3f;
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != NULL, NULL);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix4f;
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// LOrientationf
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LOrientationf;
inline static LOrientationf *Dtool_Coerce_LOrientationf(PyObject *args, LOrientationf &coerced) {
  nassertr(Dtool_Ptr_LOrientationf != NULL, NULL);
  nassertr(Dtool_Ptr_LOrientationf->_Dtool_Coerce != NULL, NULL);
  return ((LOrientationf *(*)(PyObject *, LOrientationf &))Dtool_Ptr_LOrientationf->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LOrientationf;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LOrientationf = &Dtool_LOrientationf;
extern LOrientationf *Dtool_Coerce_LOrientationf(PyObject *args, LOrientationf &coerced);
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritable;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PandaNode;
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// DataNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_DataNode;
inline static bool Dtool_ConstCoerce_DataNode(PyObject *args, CPT(DataNode) &coerced) {
  nassertr(Dtool_Ptr_DataNode != NULL, false);
  nassertr(Dtool_Ptr_DataNode->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(DataNode) &))Dtool_Ptr_DataNode->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_DataNode(PyObject *args, PT(DataNode) &coerced) {
  nassertr(Dtool_Ptr_DataNode != NULL, false);
  nassertr(Dtool_Ptr_DataNode->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(DataNode) &))Dtool_Ptr_DataNode->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_DataNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DataNode = &Dtool_DataNode;
extern bool Dtool_ConstCoerce_DataNode(PyObject *args, CPT(DataNode) &coerced);
extern bool Dtool_Coerce_DataNode(PyObject *args, PT(DataNode) &coerced);
#endif
// ButtonHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ButtonHandle;
inline static ButtonHandle *Dtool_Coerce_ButtonHandle(PyObject *args, ButtonHandle &coerced) {
  nassertr(Dtool_Ptr_ButtonHandle != NULL, NULL);
  nassertr(Dtool_Ptr_ButtonHandle->_Dtool_Coerce != NULL, NULL);
  return ((ButtonHandle *(*)(PyObject *, ButtonHandle &))Dtool_Ptr_ButtonHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_ButtonHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ButtonHandle = &Dtool_ButtonHandle;
extern ButtonHandle *Dtool_Coerce_ButtonHandle(PyObject *args, ButtonHandle &coerced);
#endif
// GraphicsWindow
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GraphicsWindow;
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsWindow;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsWindow = &Dtool_GraphicsWindow;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class ClientBase
 */
/**
 * Python function wrapper for:
 * bool ClientBase::fork_asynchronous_thread(double poll_time)
 */
static PyObject *Dtool_ClientBase_fork_asynchronous_thread_3(PyObject *self, PyObject *arg) {
  ClientBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClientBase, (void **)&local_this, "ClientBase.fork_asynchronous_thread")) {
    return NULL;
  }
  // 1-bool ClientBase::fork_asynchronous_thread(double poll_time)
  if (PyNumber_Check(arg)) {
    bool return_value = (*local_this).fork_asynchronous_thread(PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fork_asynchronous_thread(const ClientBase self, double poll_time)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClientBase_fork_asynchronous_thread_3_comment =
  "C++ Interface:\n"
  "fork_asynchronous_thread(const ClientBase self, double poll_time)\n"
  "\n"
  "/**\n"
  " * Forks a separate thread to do all the polling of connected devices.  The\n"
  " * forked thread will poll after every poll_time seconds has elapsed.  Returns\n"
  " * true if the fork was successful, or false otherwise (for instance, because\n"
  " * we were already forked, or because asynchronous threads are disabled).\n"
  " */";
#else
static const char *Dtool_ClientBase_fork_asynchronous_thread_3_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ClientBase::is_forked(void) const
 */
static PyObject *Dtool_ClientBase_is_forked_4(PyObject *self, PyObject *) {
  ClientBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClientBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ClientBase::is_forked(void) const
  bool return_value = (*(const ClientBase*)local_this).is_forked();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClientBase_is_forked_4_comment =
  "C++ Interface:\n"
  "is_forked(ClientBase self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ClientBase has been forked (and, therefore, poll() does\n"
  " * not need to be called), false otherwise.\n"
  " */";
#else
static const char *Dtool_ClientBase_is_forked_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ClientBase::poll(void)
 */
static PyObject *Dtool_ClientBase_poll_5(PyObject *self, PyObject *) {
  ClientBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClientBase, (void **)&local_this, "ClientBase.poll")) {
    return NULL;
  }
  // 1-inline bool ClientBase::poll(void)
  bool return_value = (*local_this).poll();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClientBase_poll_5_comment =
  "C++ Interface:\n"
  "poll(const ClientBase self)\n"
  "\n"
  "/**\n"
  " * Initiates a poll of the client devices, if we are not forked and if we have\n"
  " * not already polled this frame.  Returns true if the poll occurred, or false\n"
  " * if it did not.\n"
  " */";
#else
static const char *Dtool_ClientBase_poll_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double ClientBase::get_last_poll_time(void) const
 */
static PyObject *Dtool_ClientBase_get_last_poll_time_6(PyObject *self, PyObject *) {
  ClientBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClientBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double ClientBase::get_last_poll_time(void) const
  double return_value = (*(const ClientBase*)local_this).get_last_poll_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClientBase_get_last_poll_time_6_comment =
  "C++ Interface:\n"
  "get_last_poll_time(ClientBase self)\n"
  "\n"
  "/**\n"
  " * Returns the time (according to the global ClockObject's get_real_time()\n"
  " * method) of the last device poll.\n"
  " */";
#else
static const char *Dtool_ClientBase_get_last_poll_time_6_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ClientBase::set_coordinate_system(CoordinateSystem cs)
 */
static PyObject *Dtool_ClientBase_set_coordinate_system_7(PyObject *self, PyObject *arg) {
  ClientBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClientBase, (void **)&local_this, "ClientBase.set_coordinate_system")) {
    return NULL;
  }
  // 1-inline void ClientBase::set_coordinate_system(CoordinateSystem cs)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_coordinate_system((CoordinateSystem)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_coordinate_system(const ClientBase self, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClientBase_set_coordinate_system_7_comment =
  "C++ Interface:\n"
  "set_coordinate_system(const ClientBase self, int cs)\n"
  "\n"
  "/**\n"
  " * Specifies the coordinate system that all devices associated with this\n"
  " * client will operate in.  Normally, this is CS_default.\n"
  " */";
#else
static const char *Dtool_ClientBase_set_coordinate_system_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CoordinateSystem ClientBase::get_coordinate_system(void) const
 */
static PyObject *Dtool_ClientBase_get_coordinate_system_8(PyObject *self, PyObject *) {
  ClientBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClientBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CoordinateSystem ClientBase::get_coordinate_system(void) const
  CoordinateSystem return_value = (*(const ClientBase*)local_this).get_coordinate_system();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClientBase_get_coordinate_system_8_comment =
  "C++ Interface:\n"
  "get_coordinate_system(ClientBase self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate system that all devices associated with this client\n"
  " * will operate in.  Normally, this is CS_default.\n"
  " */";
#else
static const char *Dtool_ClientBase_get_coordinate_system_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ClientBase::get_class_type(void)
 */
static PyObject *Dtool_ClientBase_get_class_type_9(PyObject *, PyObject *) {
  // 1-static TypeHandle ClientBase::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ClientBase::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ClientBase_get_class_type_9_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ClientBase_get_class_type_9_comment = NULL;
#endif

static int Dtool_Init_ClientBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ClientBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ClientBase) {
    printf("ClientBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ClientBase *local_this = (ClientBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ClientBase) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ClientBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ClientBase) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ClientBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ClientBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (ClientBase*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AnalogNode
 */
/**
 * Python function wrapper for:
 * inline bool AnalogNode::is_valid(void) const
 */
static PyObject *Dtool_AnalogNode_is_valid_13(PyObject *self, PyObject *) {
  AnalogNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnalogNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool AnalogNode::is_valid(void) const
  bool return_value = (*(const AnalogNode*)local_this).is_valid();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnalogNode_is_valid_13_comment =
  "C++ Interface:\n"
  "is_valid(AnalogNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the AnalogNode is valid and connected to a server, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_AnalogNode_is_valid_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int AnalogNode::get_num_controls(void) const
 */
static PyObject *Dtool_AnalogNode_get_num_controls_14(PyObject *self, PyObject *) {
  AnalogNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnalogNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int AnalogNode::get_num_controls(void) const
  int return_value = (*(const AnalogNode*)local_this).get_num_controls();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnalogNode_get_num_controls_14_comment =
  "C++ Interface:\n"
  "get_num_controls(AnalogNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of analog controls known to the AnalogNode.  This number\n"
  " * may change as more controls are discovered.\n"
  " */";
#else
static const char *Dtool_AnalogNode_get_num_controls_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double AnalogNode::get_control_state(int index) const
 */
static PyObject *Dtool_AnalogNode_get_control_state_15(PyObject *self, PyObject *arg) {
  AnalogNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnalogNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double AnalogNode::get_control_state(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = (*(const AnalogNode*)local_this).get_control_state((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_control_state(AnalogNode self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnalogNode_get_control_state_15_comment =
  "C++ Interface:\n"
  "get_control_state(AnalogNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the current position of indicated analog control identified by its\n"
  " * index number, or 0.0 if the control is unknown.  The normal range of a\n"
  " * single control is -1.0 to 1.0.\n"
  " */";
#else
static const char *Dtool_AnalogNode_get_control_state_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool AnalogNode::is_control_known(int index) const
 */
static PyObject *Dtool_AnalogNode_is_control_known_16(PyObject *self, PyObject *arg) {
  AnalogNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnalogNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool AnalogNode::is_control_known(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const AnalogNode*)local_this).is_control_known((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_control_known(AnalogNode self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnalogNode_is_control_known_16_comment =
  "C++ Interface:\n"
  "is_control_known(AnalogNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the state of the indicated analog control is known, or\n"
  " * false if we have never heard anything about this particular control.\n"
  " */";
#else
static const char *Dtool_AnalogNode_is_control_known_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void AnalogNode::set_output(int channel, int index, bool flip)
 */
static PyObject *Dtool_AnalogNode_set_output_17(PyObject *self, PyObject *args, PyObject *kwds) {
  AnalogNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnalogNode, (void **)&local_this, "AnalogNode.set_output")) {
    return NULL;
  }
  // 1-inline void AnalogNode::set_output(int channel, int index, bool flip)
  int param1;
  int param2;
  PyObject *param3;
  static const char *keyword_list[] = {"channel", "index", "flip", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_output", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_output((int)param1, (int)param2, (PyObject_IsTrue(param3) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_output(const AnalogNode self, int channel, int index, bool flip)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnalogNode_set_output_17_comment =
  "C++ Interface:\n"
  "set_output(const AnalogNode self, int channel, int index, bool flip)\n"
  "\n"
  "/**\n"
  " * Causes a particular analog control to be placed in the data graph for the\n"
  " * indicated channel.  Normally, a mouse uses channels 0 and 1 for the X and Y\n"
  " * information, respectively; channels 0, 1, and 2 are available.  If flip is\n"
  " * true, the analog control value will be reversed before outputting it.\n"
  " */";
#else
static const char *Dtool_AnalogNode_set_output_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void AnalogNode::clear_output(int channel)
 */
static PyObject *Dtool_AnalogNode_clear_output_18(PyObject *self, PyObject *arg) {
  AnalogNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnalogNode, (void **)&local_this, "AnalogNode.clear_output")) {
    return NULL;
  }
  // 1-inline void AnalogNode::clear_output(int channel)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).clear_output((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_output(const AnalogNode self, int channel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnalogNode_clear_output_18_comment =
  "C++ Interface:\n"
  "clear_output(const AnalogNode self, int channel)\n"
  "\n"
  "/**\n"
  " * Removes the output to the data graph associated with the indicated channel.\n"
  " * See set_output().\n"
  " */";
#else
static const char *Dtool_AnalogNode_clear_output_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int AnalogNode::get_output(int channel) const
 */
static PyObject *Dtool_AnalogNode_get_output_19(PyObject *self, PyObject *arg) {
  AnalogNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnalogNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int AnalogNode::get_output(int channel) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const AnalogNode*)local_this).get_output((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_output(AnalogNode self, int channel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnalogNode_get_output_19_comment =
  "C++ Interface:\n"
  "get_output(AnalogNode self, int channel)\n"
  "\n"
  "/**\n"
  " * Returns the analog control index that is output to the data graph on the\n"
  " * indicated channel, or -1 if no control is output on that channel.  See\n"
  " * set_output().\n"
  " */";
#else
static const char *Dtool_AnalogNode_get_output_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool AnalogNode::is_output_flipped(int channel) const
 */
static PyObject *Dtool_AnalogNode_is_output_flipped_20(PyObject *self, PyObject *arg) {
  AnalogNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnalogNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool AnalogNode::is_output_flipped(int channel) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const AnalogNode*)local_this).is_output_flipped((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_output_flipped(AnalogNode self, int channel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnalogNode_is_output_flipped_20_comment =
  "C++ Interface:\n"
  "is_output_flipped(AnalogNode self, int channel)\n"
  "\n"
  "/**\n"
  " * Returns true if the analog control index that is output to the data graph\n"
  " * on the indicated channel is flipped.  See set_output().\n"
  " */";
#else
static const char *Dtool_AnalogNode_is_output_flipped_20_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnalogNode::get_class_type(void)
 */
static PyObject *Dtool_AnalogNode_get_class_type_21(PyObject *, PyObject *) {
  // 1-static TypeHandle AnalogNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AnalogNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnalogNode_get_class_type_21_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnalogNode_get_class_type_21_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AnalogNode::AnalogNode(ClientBase *client, std::string const &device_name)
 */
static int Dtool_Init_AnalogNode(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-AnalogNode::AnalogNode(ClientBase *client, std::string const &device_name)
  PyObject *param0;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"client", "device_name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:AnalogNode", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
    ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ClientBase, 0, "AnalogNode.AnalogNode", false, true);
    if (param0_this != NULL) {
      AnalogNode *return_value = new AnalogNode(param0_this, std::string(param1_str, param1_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnalogNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AnalogNode(ClientBase client, str device_name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_AnalogNode(PyObject *args, CPT(AnalogNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AnalogNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-AnalogNode::AnalogNode(ClientBase *client, std::string const &device_name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:AnalogNode", &param0, &param1_str, &param1_len)) {
        ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ClientBase, 0, "AnalogNode.AnalogNode", false, false);
        if (param0_this != NULL) {
          AnalogNode *return_value = new AnalogNode(param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_AnalogNode(PyObject *args, PT(AnalogNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AnalogNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-AnalogNode::AnalogNode(ClientBase *client, std::string const &device_name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:AnalogNode", &param0, &param1_str, &param1_len)) {
        ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ClientBase, 0, "AnalogNode.AnalogNode", false, false);
        if (param0_this != NULL) {
          AnalogNode *return_value = new AnalogNode(param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_AnalogNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AnalogNode) {
    printf("AnalogNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AnalogNode *local_this = (AnalogNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AnalogNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AnalogNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AnalogNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (AnalogNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnalogNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (AnalogNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnalogNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnalogNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnalogNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnalogNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ButtonNode
 */
/**
 * Python function wrapper for:
 * inline bool ButtonNode::is_valid(void) const
 */
static PyObject *Dtool_ButtonNode_is_valid_24(PyObject *self, PyObject *) {
  ButtonNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ButtonNode::is_valid(void) const
  bool return_value = (*(const ButtonNode*)local_this).is_valid();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonNode_is_valid_24_comment =
  "C++ Interface:\n"
  "is_valid(ButtonNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ButtonNode is valid and connected to a server, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_ButtonNode_is_valid_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ButtonNode::get_num_buttons(void) const
 */
static PyObject *Dtool_ButtonNode_get_num_buttons_25(PyObject *self, PyObject *) {
  ButtonNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ButtonNode::get_num_buttons(void) const
  int return_value = (*(const ButtonNode*)local_this).get_num_buttons();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonNode_get_num_buttons_25_comment =
  "C++ Interface:\n"
  "get_num_buttons(ButtonNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of buttons known to the ButtonNode.  This includes those\n"
  " * buttons whose state has been seen, as well as buttons that have been\n"
  " * associated with a ButtonHandle even if their state is unknown.  This number\n"
  " * may change as more buttons are discovered.\n"
  " */";
#else
static const char *Dtool_ButtonNode_get_num_buttons_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ButtonNode::set_button_map(int index, ButtonHandle button)
 */
static PyObject *Dtool_ButtonNode_set_button_map_26(PyObject *self, PyObject *args, PyObject *kwds) {
  ButtonNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonNode, (void **)&local_this, "ButtonNode.set_button_map")) {
    return NULL;
  }
  // 1-inline void ButtonNode::set_button_map(int index, ButtonHandle button)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "button", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_button_map", (char **)keyword_list, &param1, &param2)) {
    ButtonHandle param2_local;
    ButtonHandle *param2_this = Dtool_Coerce_ButtonHandle(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ButtonNode.set_button_map", "ButtonHandle");
    }
    (*local_this).set_button_map((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_button_map(const ButtonNode self, int index, ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonNode_set_button_map_26_comment =
  "C++ Interface:\n"
  "set_button_map(const ButtonNode self, int index, ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Associates the indicated ButtonHandle with the button of the indicated\n"
  " * index number.  When the given button index changes state, a corresponding\n"
  " * ButtonEvent will be generated with the given ButtonHandle.  Pass\n"
  " * ButtonHandle::none() to turn off any association.\n"
  " *\n"
  " * It is not necessary to call this if you simply want to query the state of\n"
  " * the various buttons by index number; this is only necessary in order to\n"
  " * generate ButtonEvents when the buttons change state.\n"
  " */";
#else
static const char *Dtool_ButtonNode_set_button_map_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ButtonHandle ButtonNode::get_button_map(int index) const
 */
static PyObject *Dtool_ButtonNode_get_button_map_27(PyObject *self, PyObject *arg) {
  ButtonNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ButtonHandle ButtonNode::get_button_map(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ButtonHandle *return_value = new ButtonHandle((*(const ButtonNode*)local_this).get_button_map((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_button_map(ButtonNode self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonNode_get_button_map_27_comment =
  "C++ Interface:\n"
  "get_button_map(ButtonNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle that was previously associated with the given\n"
  " * index number by a call to set_button_map(), or ButtonHandle::none() if no\n"
  " * button was associated.\n"
  " */";
#else
static const char *Dtool_ButtonNode_get_button_map_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ButtonNode::get_button_state(int index) const
 */
static PyObject *Dtool_ButtonNode_get_button_state_28(PyObject *self, PyObject *arg) {
  ButtonNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ButtonNode::get_button_state(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const ButtonNode*)local_this).get_button_state((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_button_state(ButtonNode self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonNode_get_button_state_28_comment =
  "C++ Interface:\n"
  "get_button_state(ButtonNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated button (identified by its index number) is\n"
  " * currently known to be down, or false if it is up or unknown.\n"
  " */";
#else
static const char *Dtool_ButtonNode_get_button_state_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ButtonNode::is_button_known(int index) const
 */
static PyObject *Dtool_ButtonNode_is_button_known_29(PyObject *self, PyObject *arg) {
  ButtonNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ButtonNode::is_button_known(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const ButtonNode*)local_this).is_button_known((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_button_known(ButtonNode self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonNode_is_button_known_29_comment =
  "C++ Interface:\n"
  "is_button_known(ButtonNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the state of the indicated button is known, or false if we\n"
  " * have never heard anything about this particular button.\n"
  " */";
#else
static const char *Dtool_ButtonNode_is_button_known_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ButtonNode::get_class_type(void)
 */
static PyObject *Dtool_ButtonNode_get_class_type_30(PyObject *, PyObject *) {
  // 1-static TypeHandle ButtonNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ButtonNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ButtonNode_get_class_type_30_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ButtonNode_get_class_type_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ButtonNode::ButtonNode(ButtonNode const &) = default
 * ButtonNode::ButtonNode(ClientBase *client, std::string const &device_name)
 */
static int Dtool_Init_ButtonNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline ButtonNode::ButtonNode(ButtonNode const &) = default
      CPT(ButtonNode) arg_this;
      if (!Dtool_ConstCoerce_ButtonNode(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "ButtonNode.ButtonNode", "ButtonNode");
        return -1;
      }
      ButtonNode *return_value = new ButtonNode(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonNode, true, false);
    }
    break;
  case 2:
    {
      // 1-ButtonNode::ButtonNode(ClientBase *client, std::string const &device_name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      static const char *keyword_list[] = {"client", "device_name", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:ButtonNode", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
        ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ClientBase, 0, "ButtonNode.ButtonNode", false, true);
        if (param0_this != NULL) {
          ButtonNode *return_value = new ButtonNode(param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonNode, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ButtonNode() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ButtonNode(const ButtonNode param0)\n"
      "ButtonNode(ClientBase client, str device_name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ButtonNode(PyObject *args, CPT(ButtonNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ButtonNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-ButtonNode::ButtonNode(ClientBase *client, std::string const &device_name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:ButtonNode", &param0, &param1_str, &param1_len)) {
        ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ClientBase, 0, "ButtonNode.ButtonNode", false, false);
        if (param0_this != NULL) {
          ButtonNode *return_value = new ButtonNode(param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_ButtonNode(PyObject *args, PT(ButtonNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ButtonNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-ButtonNode::ButtonNode(ClientBase *client, std::string const &device_name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:ButtonNode", &param0, &param1_str, &param1_len)) {
        ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ClientBase, 0, "ButtonNode.ButtonNode", false, false);
        if (param0_this != NULL) {
          ButtonNode *return_value = new ButtonNode(param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ButtonNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ButtonNode) {
    printf("ButtonNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ButtonNode *local_this = (ButtonNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ButtonNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ButtonNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ButtonNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (ButtonNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ButtonNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (ButtonNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ButtonNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ButtonNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ButtonNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ButtonNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class TrackerData
 */
static PyObject *Dtool_TrackerData_time_Getter(PyObject *self, void *) {
  const TrackerData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrackerData, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double TrackerData::get_time(void) const
  double return_value = (*(const TrackerData*)local_this).get_time();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TrackerData_time_Setter(PyObject *self, PyObject *arg, void *) {
  TrackerData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrackerData, (void **)&local_this, "TrackerData.time")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete time attribute");
    return -1;
  }
  // 1-inline void TrackerData::set_time(double time)
  if (PyNumber_Check(arg)) {
    (*local_this).set_time(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_time(const TrackerData self, double time)\n");
  }
  return -1;
}

static PyObject *Dtool_TrackerData_pos_Getter(PyObject *self, void *) {
  const TrackerData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrackerData, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint3 const &TrackerData::get_pos(void) const
  LPoint3 const *return_value = &((*(const TrackerData*)local_this).get_pos());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_TrackerData_pos_Setter(PyObject *self, PyObject *arg, void *) {
  TrackerData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrackerData, (void **)&local_this, "TrackerData.pos")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete pos attribute");
    return -1;
  }
  // 1-inline void TrackerData::set_pos(LPoint3 const &pos)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TrackerData.set_pos", "LPoint3f");
    return -1;
  }
  (*local_this).set_pos(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_pos(const TrackerData self, const LPoint3f pos)\n");
  }
  return -1;
}

static PyObject *Dtool_TrackerData_orient_Getter(PyObject *self, void *) {
  const TrackerData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrackerData, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LOrientation const &TrackerData::get_orient(void) const
  LOrientation const *return_value = &((*(const TrackerData*)local_this).get_orient());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LOrientationf, false, true);
}

static int Dtool_TrackerData_orient_Setter(PyObject *self, PyObject *arg, void *) {
  TrackerData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrackerData, (void **)&local_this, "TrackerData.orient")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete orient attribute");
    return -1;
  }
  // 1-inline void TrackerData::set_orient(LOrientation const &orient)
  LOrientationf arg_local;
  LOrientation const *arg_this = Dtool_Coerce_LOrientationf(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TrackerData.set_orient", "LOrientationf");
    return -1;
  }
  (*local_this).set_orient(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_orient(const TrackerData self, const LOrientationf orient)\n");
  }
  return -1;
}

static PyObject *Dtool_TrackerData_dt_Getter(PyObject *self, void *) {
  const TrackerData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrackerData, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double TrackerData::get_dt(void) const
  double return_value = (*(const TrackerData*)local_this).get_dt();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TrackerData_dt_Setter(PyObject *self, PyObject *arg, void *) {
  TrackerData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrackerData, (void **)&local_this, "TrackerData.dt")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete dt attribute");
    return -1;
  }
  // 1-inline void TrackerData::set_dt(double dt)
  if (PyNumber_Check(arg)) {
    (*local_this).set_dt(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_dt(const TrackerData self, double dt)\n");
  }
  return -1;
}

static int Dtool_Init_TrackerData(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TrackerData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TrackerData) {
    printf("TrackerData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TrackerData *local_this = (TrackerData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TrackerData) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TrackerData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TrackerData) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DialNode
 */
/**
 * Python function wrapper for:
 * inline bool DialNode::is_valid(void) const
 */
static PyObject *Dtool_DialNode_is_valid_54(PyObject *self, PyObject *) {
  DialNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DialNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DialNode::is_valid(void) const
  bool return_value = (*(const DialNode*)local_this).is_valid();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DialNode_is_valid_54_comment =
  "C++ Interface:\n"
  "is_valid(DialNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the DialNode is valid and connected to a server, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_DialNode_is_valid_54_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DialNode::get_num_dials(void) const
 */
static PyObject *Dtool_DialNode_get_num_dials_55(PyObject *self, PyObject *) {
  DialNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DialNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DialNode::get_num_dials(void) const
  int return_value = (*(const DialNode*)local_this).get_num_dials();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DialNode_get_num_dials_55_comment =
  "C++ Interface:\n"
  "get_num_dials(DialNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of dial dials known to the DialNode.  This number may\n"
  " * change as more dials are discovered.\n"
  " */";
#else
static const char *Dtool_DialNode_get_num_dials_55_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double DialNode::read_dial(int index)
 */
static PyObject *Dtool_DialNode_read_dial_56(PyObject *self, PyObject *arg) {
  DialNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DialNode, (void **)&local_this, "DialNode.read_dial")) {
    return NULL;
  }
  // 1-inline double DialNode::read_dial(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = (*local_this).read_dial((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_dial(const DialNode self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DialNode_read_dial_56_comment =
  "C++ Interface:\n"
  "read_dial(const DialNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the number of complete revolutions of the dial since the last time\n"
  " * read_dial() was called.  This is a destructive operation; it is not\n"
  " * possible to read the dial without resetting the counter.\n"
  " */";
#else
static const char *Dtool_DialNode_read_dial_56_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DialNode::is_dial_known(int index) const
 */
static PyObject *Dtool_DialNode_is_dial_known_57(PyObject *self, PyObject *arg) {
  DialNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DialNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DialNode::is_dial_known(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const DialNode*)local_this).is_dial_known((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_dial_known(DialNode self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DialNode_is_dial_known_57_comment =
  "C++ Interface:\n"
  "is_dial_known(DialNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the state of the indicated dial dial is known, or false if\n"
  " * we have never heard anything about this particular dial.\n"
  " */";
#else
static const char *Dtool_DialNode_is_dial_known_57_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DialNode::get_class_type(void)
 */
static PyObject *Dtool_DialNode_get_class_type_58(PyObject *, PyObject *) {
  // 1-static TypeHandle DialNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(DialNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DialNode_get_class_type_58_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DialNode_get_class_type_58_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DialNode::DialNode(ClientBase *client, std::string const &device_name)
 * inline DialNode::DialNode(DialNode const &) = default
 */
static int Dtool_Init_DialNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline DialNode::DialNode(DialNode const &) = default
      CPT(DialNode) arg_this;
      if (!Dtool_ConstCoerce_DialNode(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "DialNode.DialNode", "DialNode");
        return -1;
      }
      DialNode *return_value = new DialNode(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DialNode, true, false);
    }
    break;
  case 2:
    {
      // 1-DialNode::DialNode(ClientBase *client, std::string const &device_name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      static const char *keyword_list[] = {"client", "device_name", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:DialNode", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
        ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ClientBase, 0, "DialNode.DialNode", false, true);
        if (param0_this != NULL) {
          DialNode *return_value = new DialNode(param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DialNode, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DialNode() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DialNode(const DialNode param0)\n"
      "DialNode(ClientBase client, str device_name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_DialNode(PyObject *args, CPT(DialNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_DialNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-DialNode::DialNode(ClientBase *client, std::string const &device_name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:DialNode", &param0, &param1_str, &param1_len)) {
        ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ClientBase, 0, "DialNode.DialNode", false, false);
        if (param0_this != NULL) {
          DialNode *return_value = new DialNode(param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_DialNode(PyObject *args, PT(DialNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_DialNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-DialNode::DialNode(ClientBase *client, std::string const &device_name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:DialNode", &param0, &param1_str, &param1_len)) {
        ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ClientBase, 0, "DialNode.DialNode", false, false);
        if (param0_this != NULL) {
          DialNode *return_value = new DialNode(param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_DialNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DialNode) {
    printf("DialNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DialNode *local_this = (DialNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DialNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DialNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DialNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (DialNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (DialNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (DialNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (DialNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DialNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (DialNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (DialNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MouseAndKeyboard
 */
/**
 * Python function wrapper for:
 * void MouseAndKeyboard::set_source(GraphicsWindow *window, int device)
 */
static PyObject *Dtool_MouseAndKeyboard_set_source_61(PyObject *self, PyObject *args, PyObject *kwds) {
  MouseAndKeyboard *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseAndKeyboard, (void **)&local_this, "MouseAndKeyboard.set_source")) {
    return NULL;
  }
  // 1-void MouseAndKeyboard::set_source(GraphicsWindow *window, int device)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"window", "device", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:set_source", (char **)keyword_list, &param1, &param2)) {
    GraphicsWindow *param1_this = (GraphicsWindow *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsWindow, 1, "MouseAndKeyboard.set_source", false, true);
    if (param1_this != NULL) {
      (*local_this).set_source(param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_source(const MouseAndKeyboard self, GraphicsWindow window, int device)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseAndKeyboard_set_source_61_comment =
  "C++ Interface:\n"
  "set_source(const MouseAndKeyboard self, GraphicsWindow window, int device)\n"
  "\n"
  "/**\n"
  " * Redirects the class to get the data from the mouse and keyboard associated\n"
  " * with a different window and/or device number.\n"
  " */";
#else
static const char *Dtool_MouseAndKeyboard_set_source_61_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< GraphicsWindow > MouseAndKeyboard::get_source_window(void) const
 */
static PyObject *Dtool_MouseAndKeyboard_get_source_window_62(PyObject *self, PyObject *) {
  MouseAndKeyboard *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseAndKeyboard, (void **)&local_this)) {
    return NULL;
  }
  // 1-PointerTo< GraphicsWindow > MouseAndKeyboard::get_source_window(void) const
  PointerTo< GraphicsWindow > return_value = (*(const MouseAndKeyboard*)local_this).get_source_window();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  GraphicsWindow *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GraphicsWindow, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MouseAndKeyboard_get_source_window_62_comment =
  "C++ Interface:\n"
  "get_source_window(MouseAndKeyboard self)\n"
  "\n"
  "/**\n"
  " * Returns the associated source window.\n"
  " */";
#else
static const char *Dtool_MouseAndKeyboard_get_source_window_62_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int MouseAndKeyboard::get_source_device(void) const
 */
static PyObject *Dtool_MouseAndKeyboard_get_source_device_63(PyObject *self, PyObject *) {
  MouseAndKeyboard *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseAndKeyboard, (void **)&local_this)) {
    return NULL;
  }
  // 1-int MouseAndKeyboard::get_source_device(void) const
  int return_value = (*(const MouseAndKeyboard*)local_this).get_source_device();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseAndKeyboard_get_source_device_63_comment =
  "C++ Interface:\n"
  "get_source_device(MouseAndKeyboard self)\n"
  "\n"
  "/**\n"
  " * Returns the associated source device.\n"
  " */";
#else
static const char *Dtool_MouseAndKeyboard_get_source_device_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MouseAndKeyboard::get_class_type(void)
 */
static PyObject *Dtool_MouseAndKeyboard_get_class_type_64(PyObject *, PyObject *) {
  // 1-static TypeHandle MouseAndKeyboard::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(MouseAndKeyboard::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseAndKeyboard_get_class_type_64_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MouseAndKeyboard_get_class_type_64_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * MouseAndKeyboard::MouseAndKeyboard(GraphicsWindow *window, int device, std::string const &name)
 * inline MouseAndKeyboard::MouseAndKeyboard(MouseAndKeyboard const &) = default
 */
static int Dtool_Init_MouseAndKeyboard(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline MouseAndKeyboard::MouseAndKeyboard(MouseAndKeyboard const &) = default
      CPT(MouseAndKeyboard) arg_this;
      if (!Dtool_ConstCoerce_MouseAndKeyboard(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "MouseAndKeyboard.MouseAndKeyboard", "MouseAndKeyboard");
        return -1;
      }
      MouseAndKeyboard *return_value = new MouseAndKeyboard(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MouseAndKeyboard, true, false);
    }
    break;
  case 3:
    {
      // 1-MouseAndKeyboard::MouseAndKeyboard(GraphicsWindow *window, int device, std::string const &name)
      PyObject *param0;
      int param1;
      char *param2_str = NULL;
      Py_ssize_t param2_len;
      static const char *keyword_list[] = {"window", "device", "name", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Ois#:MouseAndKeyboard", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len)) {
        GraphicsWindow *param0_this = (GraphicsWindow *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GraphicsWindow, 0, "MouseAndKeyboard.MouseAndKeyboard", false, true);
        if (param0_this != NULL) {
          MouseAndKeyboard *return_value = new MouseAndKeyboard(param0_this, (int)param1, std::string(param2_str, param2_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MouseAndKeyboard, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "MouseAndKeyboard() takes 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MouseAndKeyboard(const MouseAndKeyboard param0)\n"
      "MouseAndKeyboard(GraphicsWindow window, int device, str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_MouseAndKeyboard(PyObject *args, CPT(MouseAndKeyboard) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_MouseAndKeyboard, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-MouseAndKeyboard::MouseAndKeyboard(GraphicsWindow *window, int device, std::string const &name)
      PyObject *param0;
      int param1;
      char *param2_str = NULL;
      Py_ssize_t param2_len;
      if (PyArg_ParseTuple(args, "Ois#:MouseAndKeyboard", &param0, &param1, &param2_str, &param2_len)) {
        GraphicsWindow *param0_this = (GraphicsWindow *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GraphicsWindow, 0, "MouseAndKeyboard.MouseAndKeyboard", false, false);
        if (param0_this != NULL) {
          MouseAndKeyboard *return_value = new MouseAndKeyboard(param0_this, (int)param1, std::string(param2_str, param2_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_MouseAndKeyboard(PyObject *args, PT(MouseAndKeyboard) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_MouseAndKeyboard, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-MouseAndKeyboard::MouseAndKeyboard(GraphicsWindow *window, int device, std::string const &name)
      PyObject *param0;
      int param1;
      char *param2_str = NULL;
      Py_ssize_t param2_len;
      if (PyArg_ParseTuple(args, "Ois#:MouseAndKeyboard", &param0, &param1, &param2_str, &param2_len)) {
        GraphicsWindow *param0_this = (GraphicsWindow *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GraphicsWindow, 0, "MouseAndKeyboard.MouseAndKeyboard", false, false);
        if (param0_this != NULL) {
          MouseAndKeyboard *return_value = new MouseAndKeyboard(param0_this, (int)param1, std::string(param2_str, param2_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_MouseAndKeyboard(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MouseAndKeyboard) {
    printf("MouseAndKeyboard ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MouseAndKeyboard *local_this = (MouseAndKeyboard *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MouseAndKeyboard) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MouseAndKeyboard(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MouseAndKeyboard) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (MouseAndKeyboard*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MouseAndKeyboard*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (MouseAndKeyboard*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MouseAndKeyboard*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MouseAndKeyboard*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MouseAndKeyboard*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MouseAndKeyboard*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class TrackerNode
 */
/**
 * Python function wrapper for:
 * inline bool TrackerNode::is_valid(void) const
 */
static PyObject *Dtool_TrackerNode_is_valid_68(PyObject *self, PyObject *) {
  TrackerNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrackerNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TrackerNode::is_valid(void) const
  bool return_value = (*(const TrackerNode*)local_this).is_valid();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_is_valid_68_comment =
  "C++ Interface:\n"
  "is_valid(TrackerNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the TrackerNode is valid and connected to a server, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_TrackerNode_is_valid_68_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &TrackerNode::get_pos(void) const
 */
static PyObject *Dtool_TrackerNode_get_pos_69(PyObject *self, PyObject *) {
  TrackerNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrackerNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 const &TrackerNode::get_pos(void) const
  LPoint3 const *return_value = &((*(const TrackerNode*)local_this).get_pos());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_get_pos_69_comment =
  "C++ Interface:\n"
  "get_pos(TrackerNode self)\n"
  "\n"
  "/**\n"
  " * Returns the current position of the tracker, if it is available.\n"
  " */";
#else
static const char *Dtool_TrackerNode_get_pos_69_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LOrientation const &TrackerNode::get_orient(void) const
 */
static PyObject *Dtool_TrackerNode_get_orient_70(PyObject *self, PyObject *) {
  TrackerNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrackerNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LOrientation const &TrackerNode::get_orient(void) const
  LOrientation const *return_value = &((*(const TrackerNode*)local_this).get_orient());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LOrientationf, false, true);
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_get_orient_70_comment =
  "C++ Interface:\n"
  "get_orient(TrackerNode self)\n"
  "\n"
  "/**\n"
  " * Returns the current orientation of the tracker, if it is available.\n"
  " */";
#else
static const char *Dtool_TrackerNode_get_orient_70_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &TrackerNode::get_transform(void) const
 */
static PyObject *Dtool_TrackerNode_get_transform_71(PyObject *self, PyObject *) {
  TrackerNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrackerNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4 const &TrackerNode::get_transform(void) const
  LMatrix4 const *return_value = &((*(const TrackerNode*)local_this).get_transform());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_get_transform_71_comment =
  "C++ Interface:\n"
  "get_transform(TrackerNode self)\n"
  "\n"
  "/**\n"
  " * Returns the current position and orientation of the tracker, as a combined\n"
  " * matrix.\n"
  " */";
#else
static const char *Dtool_TrackerNode_get_transform_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double TrackerNode::get_time(void) const
 */
static PyObject *Dtool_TrackerNode_get_time_72(PyObject *self, PyObject *) {
  TrackerNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrackerNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double TrackerNode::get_time(void) const
  double return_value = (*(const TrackerNode*)local_this).get_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_get_time_72_comment =
  "C++ Interface:\n"
  "get_time(TrackerNode self)\n"
  "\n"
  "/**\n"
  " * Returns the time of the tracker's last update.\n"
  " */";
#else
static const char *Dtool_TrackerNode_get_time_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TrackerNode::has_time(void) const
 */
static PyObject *Dtool_TrackerNode_has_time_73(PyObject *self, PyObject *) {
  TrackerNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrackerNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TrackerNode::has_time(void) const
  bool return_value = (*(const TrackerNode*)local_this).has_time();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_has_time_73_comment =
  "C++ Interface:\n"
  "has_time(TrackerNode self)\n"
  "\n"
  "/**\n"
  " * True if this data comes with timestamps.\n"
  " */";
#else
static const char *Dtool_TrackerNode_has_time_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TrackerNode::set_tracker_coordinate_system(CoordinateSystem cs)
 */
static PyObject *Dtool_TrackerNode_set_tracker_coordinate_system_74(PyObject *self, PyObject *arg) {
  TrackerNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrackerNode, (void **)&local_this, "TrackerNode.set_tracker_coordinate_system")) {
    return NULL;
  }
  // 1-inline void TrackerNode::set_tracker_coordinate_system(CoordinateSystem cs)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_tracker_coordinate_system((CoordinateSystem)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tracker_coordinate_system(const TrackerNode self, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_set_tracker_coordinate_system_74_comment =
  "C++ Interface:\n"
  "set_tracker_coordinate_system(const TrackerNode self, int cs)\n"
  "\n"
  "/**\n"
  " * Specifies the coordinate system that the tracker associated with this node\n"
  " * will operate in.  Normally, this is set from the ClientBase that's used to\n"
  " * create the TrackerNode, so it should not need to be set on an individual\n"
  " * tracker basis.\n"
  " */";
#else
static const char *Dtool_TrackerNode_set_tracker_coordinate_system_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CoordinateSystem TrackerNode::get_tracker_coordinate_system(void) const
 */
static PyObject *Dtool_TrackerNode_get_tracker_coordinate_system_75(PyObject *self, PyObject *) {
  TrackerNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrackerNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CoordinateSystem TrackerNode::get_tracker_coordinate_system(void) const
  CoordinateSystem return_value = (*(const TrackerNode*)local_this).get_tracker_coordinate_system();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_get_tracker_coordinate_system_75_comment =
  "C++ Interface:\n"
  "get_tracker_coordinate_system(TrackerNode self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate system that the tracker associated with this node\n"
  " * will operate in.\n"
  " */";
#else
static const char *Dtool_TrackerNode_get_tracker_coordinate_system_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TrackerNode::set_graph_coordinate_system(CoordinateSystem cs)
 */
static PyObject *Dtool_TrackerNode_set_graph_coordinate_system_76(PyObject *self, PyObject *arg) {
  TrackerNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrackerNode, (void **)&local_this, "TrackerNode.set_graph_coordinate_system")) {
    return NULL;
  }
  // 1-inline void TrackerNode::set_graph_coordinate_system(CoordinateSystem cs)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_graph_coordinate_system((CoordinateSystem)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_graph_coordinate_system(const TrackerNode self, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_set_graph_coordinate_system_76_comment =
  "C++ Interface:\n"
  "set_graph_coordinate_system(const TrackerNode self, int cs)\n"
  "\n"
  "/**\n"
  " * Specifies the coordinate system that the TrackerNode will convert its\n"
  " * transform into for passing down the data graph.  Normally, this is\n"
  " * CS_default.\n"
  " */";
#else
static const char *Dtool_TrackerNode_set_graph_coordinate_system_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CoordinateSystem TrackerNode::get_graph_coordinate_system(void) const
 */
static PyObject *Dtool_TrackerNode_get_graph_coordinate_system_77(PyObject *self, PyObject *) {
  TrackerNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrackerNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CoordinateSystem TrackerNode::get_graph_coordinate_system(void) const
  CoordinateSystem return_value = (*(const TrackerNode*)local_this).get_graph_coordinate_system();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_get_graph_coordinate_system_77_comment =
  "C++ Interface:\n"
  "get_graph_coordinate_system(TrackerNode self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate system that the TrackerNode will convert its\n"
  " * transform into for passing down the data graph.  Normally, this is\n"
  " * CS_default.\n"
  " */";
#else
static const char *Dtool_TrackerNode_get_graph_coordinate_system_77_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TrackerNode::get_class_type(void)
 */
static PyObject *Dtool_TrackerNode_get_class_type_78(PyObject *, PyObject *) {
  // 1-static TypeHandle TrackerNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(TrackerNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_get_class_type_78_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TrackerNode_get_class_type_78_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TrackerNode::TrackerNode(ClientBase *client, std::string const &device_name)
 * Rejected Remap [TrackerNode::TrackerNode(ClientTrackerDevice *device)]
 * inline TrackerNode::TrackerNode(TrackerNode const &) = default
 */
static int Dtool_Init_TrackerNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline TrackerNode::TrackerNode(TrackerNode const &) = default
      CPT(TrackerNode) arg_this;
      if (!Dtool_ConstCoerce_TrackerNode(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "TrackerNode.TrackerNode", "TrackerNode");
        return -1;
      }
      TrackerNode *return_value = new TrackerNode(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TrackerNode, true, false);
    }
    break;
  case 2:
    {
      // 1-TrackerNode::TrackerNode(ClientBase *client, std::string const &device_name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      static const char *keyword_list[] = {"client", "device_name", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:TrackerNode", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
        ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ClientBase, 0, "TrackerNode.TrackerNode", false, true);
        if (param0_this != NULL) {
          TrackerNode *return_value = new TrackerNode(param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TrackerNode, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TrackerNode() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TrackerNode(const TrackerNode param0)\n"
      "TrackerNode(ClientBase client, str device_name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_TrackerNode(PyObject *args, CPT(TrackerNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_TrackerNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-TrackerNode::TrackerNode(ClientBase *client, std::string const &device_name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:TrackerNode", &param0, &param1_str, &param1_len)) {
        ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ClientBase, 0, "TrackerNode.TrackerNode", false, false);
        if (param0_this != NULL) {
          TrackerNode *return_value = new TrackerNode(param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_TrackerNode(PyObject *args, PT(TrackerNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_TrackerNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-TrackerNode::TrackerNode(ClientBase *client, std::string const &device_name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:TrackerNode", &param0, &param1_str, &param1_len)) {
        ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ClientBase, 0, "TrackerNode.TrackerNode", false, false);
        if (param0_this != NULL) {
          TrackerNode *return_value = new TrackerNode(param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_TrackerNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TrackerNode) {
    printf("TrackerNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TrackerNode *local_this = (TrackerNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TrackerNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TrackerNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TrackerNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (TrackerNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (TrackerNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (TrackerNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TrackerNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TrackerNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (TrackerNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (TrackerNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class VirtualMouse
 */
/**
 * Python function wrapper for:
 * void VirtualMouse::set_mouse_pos(int x, int y)
 */
static PyObject *Dtool_VirtualMouse_set_mouse_pos_81(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualMouse *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualMouse, (void **)&local_this, "VirtualMouse.set_mouse_pos")) {
    return NULL;
  }
  // 1-void VirtualMouse::set_mouse_pos(int x, int y)
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_mouse_pos", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_mouse_pos((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mouse_pos(const VirtualMouse self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualMouse_set_mouse_pos_81_comment =
  "C++ Interface:\n"
  "set_mouse_pos(const VirtualMouse self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Sets the current mouse pixel location, where (0,0) is the upper left, and\n"
  " * (width-1, height-1) is the lower right pixel of the virtual window.\n"
  " */";
#else
static const char *Dtool_VirtualMouse_set_mouse_pos_81_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void VirtualMouse::set_window_size(int width, int height)
 */
static PyObject *Dtool_VirtualMouse_set_window_size_82(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualMouse *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualMouse, (void **)&local_this, "VirtualMouse.set_window_size")) {
    return NULL;
  }
  // 1-void VirtualMouse::set_window_size(int width, int height)
  int param1;
  int param2;
  static const char *keyword_list[] = {"width", "height", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_window_size", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_window_size((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_window_size(const VirtualMouse self, int width, int height)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualMouse_set_window_size_82_comment =
  "C++ Interface:\n"
  "set_window_size(const VirtualMouse self, int width, int height)\n"
  "\n"
  "/**\n"
  " * Sets the size of the \"window\" in which the mouse rolls.  This changes the\n"
  " * meaning of the values passed to set_mouse_pos().\n"
  " */";
#else
static const char *Dtool_VirtualMouse_set_window_size_82_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void VirtualMouse::set_mouse_on(bool flag)
 */
static PyObject *Dtool_VirtualMouse_set_mouse_on_83(PyObject *self, PyObject *arg) {
  VirtualMouse *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualMouse, (void **)&local_this, "VirtualMouse.set_mouse_on")) {
    return NULL;
  }
  // 1-void VirtualMouse::set_mouse_on(bool flag)
  (*local_this).set_mouse_on((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mouse_on(const VirtualMouse self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualMouse_set_mouse_on_83_comment =
  "C++ Interface:\n"
  "set_mouse_on(const VirtualMouse self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets whether the mouse should appear to be within the window or not.  If\n"
  " * this is true, the mouse is within the window; if false, the mouse is not\n"
  " * within the window (and set_mouse_pos() means nothing).\n"
  " */";
#else
static const char *Dtool_VirtualMouse_set_mouse_on_83_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void VirtualMouse::press_button(ButtonHandle button)
 */
static PyObject *Dtool_VirtualMouse_press_button_84(PyObject *self, PyObject *arg) {
  VirtualMouse *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualMouse, (void **)&local_this, "VirtualMouse.press_button")) {
    return NULL;
  }
  // 1-void VirtualMouse::press_button(ButtonHandle button)
  ButtonHandle arg_local;
  ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualMouse.press_button", "ButtonHandle");
  }
  (*local_this).press_button(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "press_button(const VirtualMouse self, ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualMouse_press_button_84_comment =
  "C++ Interface:\n"
  "press_button(const VirtualMouse self, ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Simulates a mouse or keyboard button being depressed.  This should be\n"
  " * followed up by a call to release_button() sometime later (possibly\n"
  " * immediately).\n"
  " */";
#else
static const char *Dtool_VirtualMouse_press_button_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void VirtualMouse::release_button(ButtonHandle button)
 */
static PyObject *Dtool_VirtualMouse_release_button_85(PyObject *self, PyObject *arg) {
  VirtualMouse *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualMouse, (void **)&local_this, "VirtualMouse.release_button")) {
    return NULL;
  }
  // 1-void VirtualMouse::release_button(ButtonHandle button)
  ButtonHandle arg_local;
  ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualMouse.release_button", "ButtonHandle");
  }
  (*local_this).release_button(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release_button(const VirtualMouse self, ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualMouse_release_button_85_comment =
  "C++ Interface:\n"
  "release_button(const VirtualMouse self, ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Simulates the button being released.  This should follow a previous call to\n"
  " * press_button().\n"
  " */";
#else
static const char *Dtool_VirtualMouse_release_button_85_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle VirtualMouse::get_class_type(void)
 */
static PyObject *Dtool_VirtualMouse_get_class_type_86(PyObject *, PyObject *) {
  // 1-static TypeHandle VirtualMouse::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(VirtualMouse::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualMouse_get_class_type_86_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VirtualMouse_get_class_type_86_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline VirtualMouse::VirtualMouse(VirtualMouse const &) = default
 * VirtualMouse::VirtualMouse(std::string const &name)
 */
static int Dtool_Init_VirtualMouse(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "VirtualMouse() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline VirtualMouse::VirtualMouse(VirtualMouse const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:VirtualMouse", (char **)keyword_list, &param0)) {
      VirtualMouse const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_VirtualMouse, (void **)&param0_this);
      if (param0_this != NULL) {
        VirtualMouse *return_value = new VirtualMouse(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VirtualMouse, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 VirtualMouse::VirtualMouse(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:VirtualMouse", (char **)keyword_list, &param0_str, &param0_len)) {
      VirtualMouse *return_value = new VirtualMouse(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VirtualMouse, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline VirtualMouse::VirtualMouse(VirtualMouse const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:VirtualMouse", (char **)keyword_list, &param0)) {
      CPT(VirtualMouse) param0_this;
      if (Dtool_ConstCoerce_VirtualMouse(param0, param0_this)) {
        VirtualMouse *return_value = new VirtualMouse(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VirtualMouse, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: VirtualMouse::VirtualMouse(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "VirtualMouse(const VirtualMouse param0)\n"
      "VirtualMouse(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_VirtualMouse(PyObject *args, CPT(VirtualMouse) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_VirtualMouse, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-VirtualMouse::VirtualMouse(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      VirtualMouse *return_value = new VirtualMouse(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_VirtualMouse(PyObject *args, PT(VirtualMouse) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_VirtualMouse, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-VirtualMouse::VirtualMouse(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      VirtualMouse *return_value = new VirtualMouse(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_VirtualMouse(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_VirtualMouse) {
    printf("VirtualMouse ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  VirtualMouse *local_this = (VirtualMouse *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_VirtualMouse) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_VirtualMouse(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_VirtualMouse) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (VirtualMouse*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (VirtualMouse*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (VirtualMouse*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualMouse*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VirtualMouse*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (VirtualMouse*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (VirtualMouse*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for ClientBase (ClientBase)
 */
static PyMethodDef Dtool_Methods_ClientBase[] = {
  {"fork_asynchronous_thread", &Dtool_ClientBase_fork_asynchronous_thread_3, METH_O, (const char *)Dtool_ClientBase_fork_asynchronous_thread_3_comment},
  {"forkAsynchronousThread", &Dtool_ClientBase_fork_asynchronous_thread_3, METH_O, (const char *)Dtool_ClientBase_fork_asynchronous_thread_3_comment},
  {"is_forked", &Dtool_ClientBase_is_forked_4, METH_NOARGS, (const char *)Dtool_ClientBase_is_forked_4_comment},
  {"isForked", &Dtool_ClientBase_is_forked_4, METH_NOARGS, (const char *)Dtool_ClientBase_is_forked_4_comment},
  {"poll", &Dtool_ClientBase_poll_5, METH_NOARGS, (const char *)Dtool_ClientBase_poll_5_comment},
  {"get_last_poll_time", &Dtool_ClientBase_get_last_poll_time_6, METH_NOARGS, (const char *)Dtool_ClientBase_get_last_poll_time_6_comment},
  {"getLastPollTime", &Dtool_ClientBase_get_last_poll_time_6, METH_NOARGS, (const char *)Dtool_ClientBase_get_last_poll_time_6_comment},
  {"set_coordinate_system", &Dtool_ClientBase_set_coordinate_system_7, METH_O, (const char *)Dtool_ClientBase_set_coordinate_system_7_comment},
  {"setCoordinateSystem", &Dtool_ClientBase_set_coordinate_system_7, METH_O, (const char *)Dtool_ClientBase_set_coordinate_system_7_comment},
  {"get_coordinate_system", &Dtool_ClientBase_get_coordinate_system_8, METH_NOARGS, (const char *)Dtool_ClientBase_get_coordinate_system_8_comment},
  {"getCoordinateSystem", &Dtool_ClientBase_get_coordinate_system_8, METH_NOARGS, (const char *)Dtool_ClientBase_get_coordinate_system_8_comment},
  {"get_class_type", &Dtool_ClientBase_get_class_type_9, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClientBase_get_class_type_9_comment},
  {"getClassType", &Dtool_ClientBase_get_class_type_9, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClientBase_get_class_type_9_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ClientBase = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ClientBase = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ClientBase = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ClientBase = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ClientBase = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ClientBase",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ClientBase,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ClientBase,
    &Dtool_SequenceMethods_ClientBase,
    &Dtool_MappingMethods_ClientBase,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ClientBase,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An abstract base class for a family of client device interfaces--including\n"
    " * trackers, buttons, dials, and other analog inputs.\n"
    " *\n"
    " * This provides a common interface to connect to such devices and extract\n"
    " * their data; it is used by TrackerNode etc.  to put these devices in the\n"
    " * data graph.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ClientBase,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ClientBase,
    PyType_GenericAlloc,
    Dtool_new_ClientBase,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ClientBase,
  Dtool_UpcastInterface_ClientBase,
  Dtool_DowncastInterface_ClientBase,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ClientBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_ClientBase._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_ClientBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ClientBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ClientBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ClientBase);
  }
}

/**
 * Python method tables for AnalogNode (AnalogNode)
 */
static PyMethodDef Dtool_Methods_AnalogNode[] = {
  {"is_valid", &Dtool_AnalogNode_is_valid_13, METH_NOARGS, (const char *)Dtool_AnalogNode_is_valid_13_comment},
  {"isValid", &Dtool_AnalogNode_is_valid_13, METH_NOARGS, (const char *)Dtool_AnalogNode_is_valid_13_comment},
  {"get_num_controls", &Dtool_AnalogNode_get_num_controls_14, METH_NOARGS, (const char *)Dtool_AnalogNode_get_num_controls_14_comment},
  {"getNumControls", &Dtool_AnalogNode_get_num_controls_14, METH_NOARGS, (const char *)Dtool_AnalogNode_get_num_controls_14_comment},
  {"get_control_state", &Dtool_AnalogNode_get_control_state_15, METH_O, (const char *)Dtool_AnalogNode_get_control_state_15_comment},
  {"getControlState", &Dtool_AnalogNode_get_control_state_15, METH_O, (const char *)Dtool_AnalogNode_get_control_state_15_comment},
  {"is_control_known", &Dtool_AnalogNode_is_control_known_16, METH_O, (const char *)Dtool_AnalogNode_is_control_known_16_comment},
  {"isControlKnown", &Dtool_AnalogNode_is_control_known_16, METH_O, (const char *)Dtool_AnalogNode_is_control_known_16_comment},
  {"set_output", (PyCFunction) &Dtool_AnalogNode_set_output_17, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnalogNode_set_output_17_comment},
  {"setOutput", (PyCFunction) &Dtool_AnalogNode_set_output_17, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnalogNode_set_output_17_comment},
  {"clear_output", &Dtool_AnalogNode_clear_output_18, METH_O, (const char *)Dtool_AnalogNode_clear_output_18_comment},
  {"clearOutput", &Dtool_AnalogNode_clear_output_18, METH_O, (const char *)Dtool_AnalogNode_clear_output_18_comment},
  {"get_output", &Dtool_AnalogNode_get_output_19, METH_O, (const char *)Dtool_AnalogNode_get_output_19_comment},
  {"getOutput", &Dtool_AnalogNode_get_output_19, METH_O, (const char *)Dtool_AnalogNode_get_output_19_comment},
  {"is_output_flipped", &Dtool_AnalogNode_is_output_flipped_20, METH_O, (const char *)Dtool_AnalogNode_is_output_flipped_20_comment},
  {"isOutputFlipped", &Dtool_AnalogNode_is_output_flipped_20, METH_O, (const char *)Dtool_AnalogNode_is_output_flipped_20_comment},
  {"get_class_type", &Dtool_AnalogNode_get_class_type_21, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnalogNode_get_class_type_21_comment},
  {"getClassType", &Dtool_AnalogNode_get_class_type_21, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnalogNode_get_class_type_21_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AnalogNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnalogNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AnalogNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AnalogNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AnalogNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AnalogNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AnalogNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AnalogNode,
    &Dtool_SequenceMethods_AnalogNode,
    &Dtool_MappingMethods_AnalogNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AnalogNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the primary interface to analog controls like sliders and joysticks\n"
    " * associated with a ClientBase.  This creates a node that connects to the\n"
    " * named analog device, if it exists, and provides hooks to the user to read\n"
    " * the state of any of the sequentially numbered controls associated with that\n"
    " * device.\n"
    " *\n"
    " * Each control can return a value ranging from -1 to 1, reflecting the\n"
    " * current position of the control within its total range of motion.\n"
    " *\n"
    " * The user may choose up to two analog controls to place on the data graph as\n"
    " * the two channels of an xy datagram, similarly to the way a mouse places its\n"
    " * position data.  In this way, an AnalogNode may be used in place of a mouse.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AnalogNode,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AnalogNode,
    PyType_GenericAlloc,
    Dtool_new_AnalogNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnalogNode,
  Dtool_UpcastInterface_AnalogNode,
  Dtool_DowncastInterface_AnalogNode,
  (CoerceFunction)Dtool_ConstCoerce_AnalogNode,
  (CoerceFunction)Dtool_Coerce_AnalogNode,
};

static void Dtool_PyModuleClassInit_AnalogNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != NULL);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(NULL);
    Dtool_AnalogNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DataNode);
    PyObject *dict = PyDict_New();
    Dtool_AnalogNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnalogNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnalogNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnalogNode);
  }
}

/**
 * Python method tables for ButtonNode (ButtonNode)
 */
static PyMethodDef Dtool_Methods_ButtonNode[] = {
  {"is_valid", &Dtool_ButtonNode_is_valid_24, METH_NOARGS, (const char *)Dtool_ButtonNode_is_valid_24_comment},
  {"isValid", &Dtool_ButtonNode_is_valid_24, METH_NOARGS, (const char *)Dtool_ButtonNode_is_valid_24_comment},
  {"get_num_buttons", &Dtool_ButtonNode_get_num_buttons_25, METH_NOARGS, (const char *)Dtool_ButtonNode_get_num_buttons_25_comment},
  {"getNumButtons", &Dtool_ButtonNode_get_num_buttons_25, METH_NOARGS, (const char *)Dtool_ButtonNode_get_num_buttons_25_comment},
  {"set_button_map", (PyCFunction) &Dtool_ButtonNode_set_button_map_26, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ButtonNode_set_button_map_26_comment},
  {"setButtonMap", (PyCFunction) &Dtool_ButtonNode_set_button_map_26, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ButtonNode_set_button_map_26_comment},
  {"get_button_map", &Dtool_ButtonNode_get_button_map_27, METH_O, (const char *)Dtool_ButtonNode_get_button_map_27_comment},
  {"getButtonMap", &Dtool_ButtonNode_get_button_map_27, METH_O, (const char *)Dtool_ButtonNode_get_button_map_27_comment},
  {"get_button_state", &Dtool_ButtonNode_get_button_state_28, METH_O, (const char *)Dtool_ButtonNode_get_button_state_28_comment},
  {"getButtonState", &Dtool_ButtonNode_get_button_state_28, METH_O, (const char *)Dtool_ButtonNode_get_button_state_28_comment},
  {"is_button_known", &Dtool_ButtonNode_is_button_known_29, METH_O, (const char *)Dtool_ButtonNode_is_button_known_29_comment},
  {"isButtonKnown", &Dtool_ButtonNode_is_button_known_29, METH_O, (const char *)Dtool_ButtonNode_is_button_known_29_comment},
  {"get_class_type", &Dtool_ButtonNode_get_class_type_30, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonNode_get_class_type_30_comment},
  {"getClassType", &Dtool_ButtonNode_get_class_type_30, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonNode_get_class_type_30_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ButtonNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ButtonNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ButtonNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ButtonNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ButtonNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ButtonNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ButtonNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ButtonNode,
    &Dtool_SequenceMethods_ButtonNode,
    &Dtool_MappingMethods_ButtonNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ButtonNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the primary interface to on/off button devices associated with a\n"
    " * ClientBase.  This creates a node that connects to the named button device,\n"
    " * if it exists, and provides hooks to the user to read the state of any of\n"
    " * the sequentially numbered buttons associated with that device.\n"
    " *\n"
    " * It also can associate an arbitrary ButtonHandle with each button; when\n"
    " * buttons are associated with ButtonHandles, this node will put appropriate\n"
    " * up and down events on the data graph for each button state change.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ButtonNode,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ButtonNode,
    PyType_GenericAlloc,
    Dtool_new_ButtonNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ButtonNode,
  Dtool_UpcastInterface_ButtonNode,
  Dtool_DowncastInterface_ButtonNode,
  (CoerceFunction)Dtool_ConstCoerce_ButtonNode,
  (CoerceFunction)Dtool_Coerce_ButtonNode,
};

static void Dtool_PyModuleClassInit_ButtonNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != NULL);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(NULL);
    Dtool_ButtonNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DataNode);
    PyObject *dict = PyDict_New();
    Dtool_ButtonNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ButtonNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ButtonNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ButtonNode);
  }
}

/**
 * Python method tables for TrackerData (TrackerData)
 */
static PyMethodDef Dtool_Methods_TrackerData[] = {
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_TrackerData[] = {
  {(char *)"time", &Dtool_TrackerData_time_Getter, &Dtool_TrackerData_time_Setter, NULL, NULL},
  {(char *)"pos", &Dtool_TrackerData_pos_Getter, &Dtool_TrackerData_pos_Setter, NULL, NULL},
  {(char *)"orient", &Dtool_TrackerData_orient_Getter, &Dtool_TrackerData_orient_Setter, NULL, NULL},
  {(char *)"dt", &Dtool_TrackerData_dt_Getter, &Dtool_TrackerData_dt_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_TrackerData = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_TrackerData = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.TrackerData",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TrackerData,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TrackerData,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Stores the kinds of data that a tracker might output.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TrackerData,
    0, // tp_members
    Dtool_Properties_TrackerData,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TrackerData,
    PyType_GenericAlloc,
    Dtool_new_TrackerData,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TrackerData,
  Dtool_UpcastInterface_TrackerData,
  Dtool_DowncastInterface_TrackerData,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_TrackerData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TrackerData._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_TrackerData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TrackerData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TrackerData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TrackerData);
  }
}

/**
 * Python method tables for DialNode (DialNode)
 */
static PyMethodDef Dtool_Methods_DialNode[] = {
  {"is_valid", &Dtool_DialNode_is_valid_54, METH_NOARGS, (const char *)Dtool_DialNode_is_valid_54_comment},
  {"isValid", &Dtool_DialNode_is_valid_54, METH_NOARGS, (const char *)Dtool_DialNode_is_valid_54_comment},
  {"get_num_dials", &Dtool_DialNode_get_num_dials_55, METH_NOARGS, (const char *)Dtool_DialNode_get_num_dials_55_comment},
  {"getNumDials", &Dtool_DialNode_get_num_dials_55, METH_NOARGS, (const char *)Dtool_DialNode_get_num_dials_55_comment},
  {"read_dial", &Dtool_DialNode_read_dial_56, METH_O, (const char *)Dtool_DialNode_read_dial_56_comment},
  {"readDial", &Dtool_DialNode_read_dial_56, METH_O, (const char *)Dtool_DialNode_read_dial_56_comment},
  {"is_dial_known", &Dtool_DialNode_is_dial_known_57, METH_O, (const char *)Dtool_DialNode_is_dial_known_57_comment},
  {"isDialKnown", &Dtool_DialNode_is_dial_known_57, METH_O, (const char *)Dtool_DialNode_is_dial_known_57_comment},
  {"get_class_type", &Dtool_DialNode_get_class_type_58, METH_NOARGS | METH_STATIC, (const char *)Dtool_DialNode_get_class_type_58_comment},
  {"getClassType", &Dtool_DialNode_get_class_type_58, METH_NOARGS | METH_STATIC, (const char *)Dtool_DialNode_get_class_type_58_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DialNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DialNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DialNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DialNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DialNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.DialNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DialNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DialNode,
    &Dtool_SequenceMethods_DialNode,
    &Dtool_MappingMethods_DialNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DialNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the primary interface to infinite dial type devices associated with\n"
    " * a ClientBase.  This creates a node that connects to the named dial device,\n"
    " * if it exists, and provides hooks to the user to read the state of any of\n"
    " * the sequentially numbered dial controls associated with that device.\n"
    " *\n"
    " * A dial is a rotating device that does not have stops--it can keep rotating\n"
    " * any number of times.  Therefore it does not have a specific position at any\n"
    " * given time, unlike an AnalogDevice.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DialNode,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DialNode,
    PyType_GenericAlloc,
    Dtool_new_DialNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DialNode,
  Dtool_UpcastInterface_DialNode,
  Dtool_DowncastInterface_DialNode,
  (CoerceFunction)Dtool_ConstCoerce_DialNode,
  (CoerceFunction)Dtool_Coerce_DialNode,
};

static void Dtool_PyModuleClassInit_DialNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != NULL);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(NULL);
    Dtool_DialNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DataNode);
    PyObject *dict = PyDict_New();
    Dtool_DialNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DialNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DialNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DialNode);
  }
}

/**
 * Python method tables for MouseAndKeyboard (MouseAndKeyboard)
 */
static PyMethodDef Dtool_Methods_MouseAndKeyboard[] = {
  {"set_source", (PyCFunction) &Dtool_MouseAndKeyboard_set_source_61, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseAndKeyboard_set_source_61_comment},
  {"setSource", (PyCFunction) &Dtool_MouseAndKeyboard_set_source_61, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseAndKeyboard_set_source_61_comment},
  {"get_source_window", &Dtool_MouseAndKeyboard_get_source_window_62, METH_NOARGS, (const char *)Dtool_MouseAndKeyboard_get_source_window_62_comment},
  {"getSourceWindow", &Dtool_MouseAndKeyboard_get_source_window_62, METH_NOARGS, (const char *)Dtool_MouseAndKeyboard_get_source_window_62_comment},
  {"get_source_device", &Dtool_MouseAndKeyboard_get_source_device_63, METH_NOARGS, (const char *)Dtool_MouseAndKeyboard_get_source_device_63_comment},
  {"getSourceDevice", &Dtool_MouseAndKeyboard_get_source_device_63, METH_NOARGS, (const char *)Dtool_MouseAndKeyboard_get_source_device_63_comment},
  {"get_class_type", &Dtool_MouseAndKeyboard_get_class_type_64, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseAndKeyboard_get_class_type_64_comment},
  {"getClassType", &Dtool_MouseAndKeyboard_get_class_type_64, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseAndKeyboard_get_class_type_64_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MouseAndKeyboard = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MouseAndKeyboard = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_MouseAndKeyboard = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_MouseAndKeyboard = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_MouseAndKeyboard = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MouseAndKeyboard",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MouseAndKeyboard,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MouseAndKeyboard,
    &Dtool_SequenceMethods_MouseAndKeyboard,
    &Dtool_MappingMethods_MouseAndKeyboard,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_MouseAndKeyboard,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Reads the mouse and/or keyboard data sent from a GraphicsWindow, and\n"
    " * transmits it down the data graph.\n"
    " *\n"
    " * The mouse and keyboard devices are bundled together into one device here,\n"
    " * because they interrelate so much.  A mouse might be constrained by the\n"
    " * holding down of the shift key, for instance, or the clicking of the mouse\n"
    " * button might be handled in much the same way as a keyboard key.\n"
    " *\n"
    " * Mouse data is sent down the data graph as an x,y position as well as the\n"
    " * set of buttons currently being held down; keyboard data is sent down as a\n"
    " * set of keypress events in an EventDataTransition.  To throw these events to\n"
    " * the system, you must attach an EventThrower to the MouseAndKeyboard object;\n"
    " * otherwise, the events will be discarded.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MouseAndKeyboard,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MouseAndKeyboard,
    PyType_GenericAlloc,
    Dtool_new_MouseAndKeyboard,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MouseAndKeyboard,
  Dtool_UpcastInterface_MouseAndKeyboard,
  Dtool_DowncastInterface_MouseAndKeyboard,
  (CoerceFunction)Dtool_ConstCoerce_MouseAndKeyboard,
  (CoerceFunction)Dtool_Coerce_MouseAndKeyboard,
};

static void Dtool_PyModuleClassInit_MouseAndKeyboard(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != NULL);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(NULL);
    Dtool_MouseAndKeyboard._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DataNode);
    PyObject *dict = PyDict_New();
    Dtool_MouseAndKeyboard._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MouseAndKeyboard) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MouseAndKeyboard)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MouseAndKeyboard);
  }
}

/**
 * Python method tables for TrackerNode (TrackerNode)
 */
static PyMethodDef Dtool_Methods_TrackerNode[] = {
  {"is_valid", &Dtool_TrackerNode_is_valid_68, METH_NOARGS, (const char *)Dtool_TrackerNode_is_valid_68_comment},
  {"isValid", &Dtool_TrackerNode_is_valid_68, METH_NOARGS, (const char *)Dtool_TrackerNode_is_valid_68_comment},
  {"get_pos", &Dtool_TrackerNode_get_pos_69, METH_NOARGS, (const char *)Dtool_TrackerNode_get_pos_69_comment},
  {"getPos", &Dtool_TrackerNode_get_pos_69, METH_NOARGS, (const char *)Dtool_TrackerNode_get_pos_69_comment},
  {"get_orient", &Dtool_TrackerNode_get_orient_70, METH_NOARGS, (const char *)Dtool_TrackerNode_get_orient_70_comment},
  {"getOrient", &Dtool_TrackerNode_get_orient_70, METH_NOARGS, (const char *)Dtool_TrackerNode_get_orient_70_comment},
  {"get_transform", &Dtool_TrackerNode_get_transform_71, METH_NOARGS, (const char *)Dtool_TrackerNode_get_transform_71_comment},
  {"getTransform", &Dtool_TrackerNode_get_transform_71, METH_NOARGS, (const char *)Dtool_TrackerNode_get_transform_71_comment},
  {"get_time", &Dtool_TrackerNode_get_time_72, METH_NOARGS, (const char *)Dtool_TrackerNode_get_time_72_comment},
  {"getTime", &Dtool_TrackerNode_get_time_72, METH_NOARGS, (const char *)Dtool_TrackerNode_get_time_72_comment},
  {"has_time", &Dtool_TrackerNode_has_time_73, METH_NOARGS, (const char *)Dtool_TrackerNode_has_time_73_comment},
  {"hasTime", &Dtool_TrackerNode_has_time_73, METH_NOARGS, (const char *)Dtool_TrackerNode_has_time_73_comment},
  {"set_tracker_coordinate_system", &Dtool_TrackerNode_set_tracker_coordinate_system_74, METH_O, (const char *)Dtool_TrackerNode_set_tracker_coordinate_system_74_comment},
  {"setTrackerCoordinateSystem", &Dtool_TrackerNode_set_tracker_coordinate_system_74, METH_O, (const char *)Dtool_TrackerNode_set_tracker_coordinate_system_74_comment},
  {"get_tracker_coordinate_system", &Dtool_TrackerNode_get_tracker_coordinate_system_75, METH_NOARGS, (const char *)Dtool_TrackerNode_get_tracker_coordinate_system_75_comment},
  {"getTrackerCoordinateSystem", &Dtool_TrackerNode_get_tracker_coordinate_system_75, METH_NOARGS, (const char *)Dtool_TrackerNode_get_tracker_coordinate_system_75_comment},
  {"set_graph_coordinate_system", &Dtool_TrackerNode_set_graph_coordinate_system_76, METH_O, (const char *)Dtool_TrackerNode_set_graph_coordinate_system_76_comment},
  {"setGraphCoordinateSystem", &Dtool_TrackerNode_set_graph_coordinate_system_76, METH_O, (const char *)Dtool_TrackerNode_set_graph_coordinate_system_76_comment},
  {"get_graph_coordinate_system", &Dtool_TrackerNode_get_graph_coordinate_system_77, METH_NOARGS, (const char *)Dtool_TrackerNode_get_graph_coordinate_system_77_comment},
  {"getGraphCoordinateSystem", &Dtool_TrackerNode_get_graph_coordinate_system_77, METH_NOARGS, (const char *)Dtool_TrackerNode_get_graph_coordinate_system_77_comment},
  {"get_class_type", &Dtool_TrackerNode_get_class_type_78, METH_NOARGS | METH_STATIC, (const char *)Dtool_TrackerNode_get_class_type_78_comment},
  {"getClassType", &Dtool_TrackerNode_get_class_type_78, METH_NOARGS | METH_STATIC, (const char *)Dtool_TrackerNode_get_class_type_78_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_TrackerNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TrackerNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_TrackerNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_TrackerNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_TrackerNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.TrackerNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TrackerNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TrackerNode,
    &Dtool_SequenceMethods_TrackerNode,
    &Dtool_MappingMethods_TrackerNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_TrackerNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the primary interface to a Tracker object associated with a\n"
    " * ClientBase.  It reads the position and orientation information from the\n"
    " * tracker and makes it available as a transformation on the data graph.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TrackerNode,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TrackerNode,
    PyType_GenericAlloc,
    Dtool_new_TrackerNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TrackerNode,
  Dtool_UpcastInterface_TrackerNode,
  Dtool_DowncastInterface_TrackerNode,
  (CoerceFunction)Dtool_ConstCoerce_TrackerNode,
  (CoerceFunction)Dtool_Coerce_TrackerNode,
};

static void Dtool_PyModuleClassInit_TrackerNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != NULL);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(NULL);
    Dtool_TrackerNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DataNode);
    PyObject *dict = PyDict_New();
    Dtool_TrackerNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TrackerNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TrackerNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TrackerNode);
  }
}

/**
 * Python method tables for VirtualMouse (VirtualMouse)
 */
static PyMethodDef Dtool_Methods_VirtualMouse[] = {
  {"set_mouse_pos", (PyCFunction) &Dtool_VirtualMouse_set_mouse_pos_81, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualMouse_set_mouse_pos_81_comment},
  {"setMousePos", (PyCFunction) &Dtool_VirtualMouse_set_mouse_pos_81, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualMouse_set_mouse_pos_81_comment},
  {"set_window_size", (PyCFunction) &Dtool_VirtualMouse_set_window_size_82, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualMouse_set_window_size_82_comment},
  {"setWindowSize", (PyCFunction) &Dtool_VirtualMouse_set_window_size_82, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualMouse_set_window_size_82_comment},
  {"set_mouse_on", &Dtool_VirtualMouse_set_mouse_on_83, METH_O, (const char *)Dtool_VirtualMouse_set_mouse_on_83_comment},
  {"setMouseOn", &Dtool_VirtualMouse_set_mouse_on_83, METH_O, (const char *)Dtool_VirtualMouse_set_mouse_on_83_comment},
  {"press_button", &Dtool_VirtualMouse_press_button_84, METH_O, (const char *)Dtool_VirtualMouse_press_button_84_comment},
  {"pressButton", &Dtool_VirtualMouse_press_button_84, METH_O, (const char *)Dtool_VirtualMouse_press_button_84_comment},
  {"release_button", &Dtool_VirtualMouse_release_button_85, METH_O, (const char *)Dtool_VirtualMouse_release_button_85_comment},
  {"releaseButton", &Dtool_VirtualMouse_release_button_85, METH_O, (const char *)Dtool_VirtualMouse_release_button_85_comment},
  {"get_class_type", &Dtool_VirtualMouse_get_class_type_86, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualMouse_get_class_type_86_comment},
  {"getClassType", &Dtool_VirtualMouse_get_class_type_86, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualMouse_get_class_type_86_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_VirtualMouse = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualMouse = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_VirtualMouse = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_VirtualMouse = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_VirtualMouse = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.VirtualMouse",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualMouse,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_VirtualMouse,
    &Dtool_SequenceMethods_VirtualMouse,
    &Dtool_MappingMethods_VirtualMouse,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_VirtualMouse,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Poses as a MouseAndKeyboard object in the datagraph, but accepts input from\n"
    " * user calls, rather than reading the actual mouse and keyboard from an input\n"
    " * device.  The user can write high-level code to put the mouse wherever\n"
    " * he/she wants, and to insert keypresses on demand.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_VirtualMouse,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_VirtualMouse,
    PyType_GenericAlloc,
    Dtool_new_VirtualMouse,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualMouse,
  Dtool_UpcastInterface_VirtualMouse,
  Dtool_DowncastInterface_VirtualMouse,
  (CoerceFunction)Dtool_ConstCoerce_VirtualMouse,
  (CoerceFunction)Dtool_Coerce_VirtualMouse,
};

static void Dtool_PyModuleClassInit_VirtualMouse(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != NULL);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(NULL);
    Dtool_VirtualMouse._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DataNode);
    PyObject *dict = PyDict_New();
    Dtool_VirtualMouse._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualMouse) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualMouse)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualMouse);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3device_RegisterTypes() {
  Dtool_ClientBase._type = ClientBase::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ClientBase);
  Dtool_AnalogNode._type = AnalogNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AnalogNode);
  Dtool_ButtonNode._type = ButtonNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ButtonNode);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("TrackerData", Dtool_TrackerData);
#endif
  Dtool_DialNode._type = DialNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_DialNode);
  Dtool_MouseAndKeyboard._type = MouseAndKeyboard::get_class_type();
  RegisterRuntimeTypedClass(Dtool_MouseAndKeyboard);
  Dtool_TrackerNode._type = TrackerNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_TrackerNode);
  Dtool_VirtualMouse._type = VirtualMouse::get_class_type();
  RegisterRuntimeTypedClass(Dtool_VirtualMouse);
}

void Dtool_libp3device_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_LPoint3f = LookupRuntimeTypedClass(LPoint3f::get_class_type());
  Dtool_Ptr_LMatrix4f = LookupRuntimeTypedClass(LMatrix4f::get_class_type());
  Dtool_Ptr_LOrientationf = LookupRuntimeTypedClass(LOrientationf::get_class_type());
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_TypedWritable = LookupRuntimeTypedClass(TypedWritable::get_class_type());
  Dtool_Ptr_TypedWritableReferenceCount = LookupRuntimeTypedClass(TypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_PandaNode = LookupRuntimeTypedClass(PandaNode::get_class_type());
  Dtool_Ptr_DataNode = LookupRuntimeTypedClass(DataNode::get_class_type());
  Dtool_Ptr_ButtonHandle = LookupRuntimeTypedClass(ButtonHandle::get_class_type());
  Dtool_Ptr_GraphicsWindow = LookupRuntimeTypedClass(GraphicsWindow::get_class_type());
#endif
}

void Dtool_libp3device_BuildInstants(PyObject *module) {
  (void) module;
  // ClientBase
  Dtool_PyModuleClassInit_ClientBase(module);
  PyModule_AddObject(module, "ClientBase", (PyObject *)&Dtool_ClientBase);
  // AnalogNode
  Dtool_PyModuleClassInit_AnalogNode(module);
  PyModule_AddObject(module, "AnalogNode", (PyObject *)&Dtool_AnalogNode);
  // ButtonNode
  Dtool_PyModuleClassInit_ButtonNode(module);
  PyModule_AddObject(module, "ButtonNode", (PyObject *)&Dtool_ButtonNode);
  // TrackerData
  Dtool_PyModuleClassInit_TrackerData(module);
  PyModule_AddObject(module, "TrackerData", (PyObject *)&Dtool_TrackerData);
  // DialNode
  Dtool_PyModuleClassInit_DialNode(module);
  PyModule_AddObject(module, "DialNode", (PyObject *)&Dtool_DialNode);
  // MouseAndKeyboard
  Dtool_PyModuleClassInit_MouseAndKeyboard(module);
  PyModule_AddObject(module, "MouseAndKeyboard", (PyObject *)&Dtool_MouseAndKeyboard);
  // TrackerNode
  Dtool_PyModuleClassInit_TrackerNode(module);
  PyModule_AddObject(module, "TrackerNode", (PyObject *)&Dtool_TrackerNode);
  // VirtualMouse
  Dtool_PyModuleClassInit_VirtualMouse(module);
  PyModule_AddObject(module, "VirtualMouse", (PyObject *)&Dtool_VirtualMouse);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3device_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478212941,  /* file_identifier */
  "libp3device",  /* library_name */
  "k0F5",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3device.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  200  /* next_index */
};

Configure(_in_configure_libp3device);
ConfigureFn(_in_configure_libp3device) {
  interrogate_request_module(&_in_module_def);
}

