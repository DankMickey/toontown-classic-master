/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/putil -Ipanda/src/putil -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3putil_igate.cxx -od built/pandac/input/libp3putil.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/putil -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/zlib/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3putil animInterface.h autoTextureScale.h bam.h bamCache.h bamCacheIndex.h bamCacheRecord.h bamEnums.h bamReader.h bamReaderParam.h bamReader_ext.h bamWriter.h bitArray.h bitMask.h buttonHandle.h buttonMap.h buttonRegistry.h cPointerCallbackObject.h cachedTypedWritableReferenceCount.h callbackData.h callbackObject.h callbackObject_ext.h clockObject.h collideMask.h colorSpace.h compareTo.h config_util.h configurable.h copyOnWriteObject.h copyOnWritePointer.h datagramInputFile.h datagramOutputFile.h doubleBitMask.h drawMask.h factory.h factoryBase.h factoryParam.h factoryParams.h firstOfPairCompare.h firstOfPairLess.h globalPointerRegistry.h indirectCompareNames.h indirectCompareSort.h indirectCompareTo.h ioPtaDatagramFloat.h ioPtaDatagramInt.h ioPtaDatagramShort.h iterator_types.h keyboardButton.h linkedListNode.h load_prc_file.h loaderOptions.h modifierButtons.h mouseButton.h mouseData.h nameUniquifier.h nodeCachedReferenceCount.h p3putil_composite1.cxx p3putil_composite2.cxx p3putil_ext_composite.cxx paramValue.h pbitops.h portalMask.h pta_ushort.h pythonCallbackObject.h simpleHashMap.h sparseArray.h timedCycle.h typedWritable.h typedWritableReferenceCount.h typedWritable_ext.h uniqueIdAllocator.h updateSeq.h vector_typedWritable.h vector_ulong.h vector_ushort.h vector_writable.h weakKeyHashMap.h writableConfigurable.h writableParam.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3putil
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include <algorithm>
#include "animInterface.h"
#include "autoTextureScale.h"
#include "bam.h"
#include "bamCache.h"
#include "bamCacheIndex.h"
#include "bamCacheRecord.h"
#include "bamEnums.h"
#include "bamReader.h"
#include "bamReaderParam.h"
#include "bamReader_ext.h"
#include "bamWriter.h"
#include "bitArray.h"
#include "bitMask.h"
#include "buttonHandle.h"
#include "buttonMap.h"
#include "buttonRegistry.h"
#include "cPointerCallbackObject.h"
#include "cachedTypedWritableReferenceCount.h"
#include "callbackData.h"
#include "callbackObject.h"
#include "callbackObject_ext.h"
#include "checksumHashGenerator.h"
#include "clockObject.h"
#include "collideMask.h"
#include "colorSpace.h"
#include "compareTo.h"
#include "conditionVar.h"
#include "configVariableDouble.h"
#include "configVariableEnum.h"
#include "configVariableSearchPath.h"
#include "config_util.h"
#include "configurable.h"
#include "copyOnWriteObject.h"
#include "copyOnWritePointer.h"
#include "cycleData.h"
#include "cycleDataReader.h"
#include "cycleDataStageReader.h"
#include "cycleDataWriter.h"
#include "datagramGenerator.h"
#include "datagramInputFile.h"
#include "datagramIterator.h"
#include "datagramOutputFile.h"
#include "datagramSink.h"
#include "dcast.h"
#include "dconfig.h"
#include "doubleBitMask.h"
#include "drawMask.h"
#include "dtoolbase.h"
#include "extension.h"
#include "factory.h"
#include "factoryBase.h"
#include "factoryParam.h"
#include "factoryParams.h"
#include "fileReference.h"
#include "filename.h"
#include "firstOfPairCompare.h"
#include "firstOfPairLess.h"
#include "globalPointerRegistry.h"
#include "indent.h"
#include "indirectCompareNames.h"
#include "indirectCompareSort.h"
#include "indirectCompareTo.h"
#include "ioPtaDatagramFloat.h"
#include "ioPtaDatagramInt.h"
#include "ioPtaDatagramShort.h"
#include "iterator_types.h"
#include "keyboardButton.h"
#include "linkedListNode.h"
#include "load_prc_file.h"
#include "loaderOptions.h"
#include "modifierButtons.h"
#include "mouseButton.h"
#include "mouseData.h"
#include "mutexHolder.h"
#include "nameUniquifier.h"
#include "nodeCachedReferenceCount.h"
#include "nodeReferenceCount.h"
#include "notifyCategoryProxy.h"
#include "numeric_types.h"
#include "pandabase.h"
#include "paramValue.h"
#include "pbitops.h"
#include "pdeque.h"
#include "pipelineCycler.h"
#include "pipelineCyclerBase.h"
#include "pmap.h"
#include "pmutex.h"
#include "pnotify.h"
#include "pointerTo.h"
#include "pointerToArray.h"
#include "pointerToArray_ext.h"
#include "portalMask.h"
#include "pset.h"
#include "pta_int.h"
#include "pta_stdfloat.h"
#include "pta_ushort.h"
#include "pvector.h"
#include "py_panda.h"
#include "pythonCallbackObject.h"
#include "reMutex.h"
#include "reMutexHolder.h"
#include "referenceCount.h"
#include "register_type.h"
#include "simpleHashMap.h"
#include "sparseArray.h"
#include <string>
#include "subfileInfo.h"
#include "thread.h"
#include <time.h>
#include "timedCycle.h"
#include "trueClock.h"
#include "typeHandle.h"
#include "typedObject.h"
#include "typedReferenceCount.h"
#include "typedWritable.h"
#include "typedWritableReferenceCount.h"
#include "typedWritable_ext.h"
#include "typedef.h"
#include "uniqueIdAllocator.h"
#include "updateSeq.h"
#include "vector_double.h"
#include "vector_int.h"
#include "vector_typedWritable.h"
#include "vector_ulong.h"
#include "vector_ushort.h"
#include "vector_writable.h"
#include "virtualFile.h"
#include "virtualFileSystem.h"
#include "weakKeyHashMap.h"
#include "writableConfigurable.h"
#include "writableParam.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class ConstPointerToArray_ushort
 */
typedef ConstPointerToArray< ushort > ConstPointerToArray_ushort_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_ushort, ConstPointerToArray_ushort_localtype, ConstPointerToArray_ushort);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_ushort = &Dtool_ConstPointerToArray_ushort;
static void Dtool_PyModuleClassInit_ConstPointerToArray_ushort(PyObject *module);
ConstPointerToArray< ushort > *Dtool_Coerce_ConstPointerToArray_ushort(PyObject *args, ConstPointerToArray< ushort > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_ushort
 */
typedef PointerToArrayBase< ushort > PointerToArrayBase_ushort_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_ushort, PointerToArrayBase_ushort_localtype, PointerToArrayBase_ushort);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_ushort = &Dtool_PointerToArrayBase_ushort;
static void Dtool_PyModuleClassInit_PointerToArrayBase_ushort(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_ushort
 */
typedef PointerToBase< ReferenceCountedVector< ushort > > PointerToBase_ReferenceCountedVector_ushort_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_ushort, PointerToBase_ReferenceCountedVector_ushort_localtype, PointerToBase_ReferenceCountedVector_ushort);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort = &Dtool_PointerToBase_ReferenceCountedVector_ushort;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_ushort(PyObject *module);

/**
 * Forward declarations for top-level class PointerToArray_ushort
 */
typedef PointerToArray< ushort > PointerToArray_ushort_localtype;
Define_Module_Class(panda3d.core, PointerToArray_ushort, PointerToArray_ushort_localtype, PointerToArray_ushort);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_ushort = &Dtool_PointerToArray_ushort;
static void Dtool_PyModuleClassInit_PointerToArray_ushort(PyObject *module);
PointerToArray< ushort > *Dtool_Coerce_PointerToArray_ushort(PyObject *args, PointerToArray< ushort > &coerced);

/**
 * Forward declarations for top-level class AnimInterface
 */
typedef AnimInterface AnimInterface_localtype;
Define_Module_Class(panda3d.core, AnimInterface, AnimInterface_localtype, AnimInterface);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimInterface = &Dtool_AnimInterface;
static void Dtool_PyModuleClassInit_AnimInterface(PyObject *module);

/**
 * Forward declarations for top-level class UpdateSeq
 */
typedef UpdateSeq UpdateSeq_localtype;
Define_Module_Class(panda3d.core, UpdateSeq, UpdateSeq_localtype, UpdateSeq);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UpdateSeq = &Dtool_UpdateSeq;
static void Dtool_PyModuleClassInit_UpdateSeq(PyObject *module);

/**
 * Forward declarations for top-level class TypedWritable
 */
typedef TypedWritable TypedWritable_localtype;
Define_Module_Class(panda3d.core, TypedWritable, TypedWritable_localtype, TypedWritable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
static void Dtool_PyModuleClassInit_TypedWritable(PyObject *module);

/**
 * Forward declarations for top-level class TypedWritableReferenceCount
 */
typedef TypedWritableReferenceCount TypedWritableReferenceCount_localtype;
Define_Module_ClassRef(panda3d.core, TypedWritableReferenceCount, TypedWritableReferenceCount_localtype, TypedWritableReferenceCount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
static void Dtool_PyModuleClassInit_TypedWritableReferenceCount(PyObject *module);

/**
 * Forward declarations for top-level class BamCacheRecord
 */
typedef BamCacheRecord BamCacheRecord_localtype;
Define_Module_ClassRef(panda3d.core, BamCacheRecord, BamCacheRecord_localtype, BamCacheRecord);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BamCacheRecord = &Dtool_BamCacheRecord;
static void Dtool_PyModuleClassInit_BamCacheRecord(PyObject *module);

/**
 * Forward declarations for top-level class BamCache
 */
typedef BamCache BamCache_localtype;
Define_Module_Class(panda3d.core, BamCache, BamCache_localtype, BamCache);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BamCache = &Dtool_BamCache;
static void Dtool_PyModuleClassInit_BamCache(PyObject *module);

/**
 * Forward declarations for top-level class BamEnums
 */
typedef BamEnums BamEnums_localtype;
Define_Module_Class(panda3d.core, BamEnums, BamEnums_localtype, BamEnums);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BamEnums = &Dtool_BamEnums;
static void Dtool_PyModuleClassInit_BamEnums(PyObject *module);

/**
 * Forward declarations for top-level class LoaderOptions
 */
typedef LoaderOptions LoaderOptions_localtype;
Define_Module_Class(panda3d.core, LoaderOptions, LoaderOptions_localtype, LoaderOptions);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LoaderOptions = &Dtool_LoaderOptions;
static void Dtool_PyModuleClassInit_LoaderOptions(PyObject *module);
LoaderOptions *Dtool_Coerce_LoaderOptions(PyObject *args, LoaderOptions &coerced);

/**
 * Forward declarations for top-level class BamReader
 */
typedef BamReader BamReader_localtype;
Define_Module_Class(panda3d.core, BamReader, BamReader_localtype, BamReader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BamReader = &Dtool_BamReader;
static void Dtool_PyModuleClassInit_BamReader(PyObject *module);
bool Dtool_ConstCoerce_BamReader(PyObject *args, BamReader const *&coerced, bool &manage);
bool Dtool_Coerce_BamReader(PyObject *args, BamReader *&coerced, bool &manage);

/**
 * Forward declarations for top-level class BamWriter
 */
typedef BamWriter BamWriter_localtype;
Define_Module_Class(panda3d.core, BamWriter, BamWriter_localtype, BamWriter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BamWriter = &Dtool_BamWriter;
static void Dtool_PyModuleClassInit_BamWriter(PyObject *module);
bool Dtool_ConstCoerce_BamWriter(PyObject *args, BamWriter const *&coerced, bool &manage);
bool Dtool_Coerce_BamWriter(PyObject *args, BamWriter *&coerced, bool &manage);

/**
 * Forward declarations for top-level class BitMask_uint16_t_16
 */
typedef BitMask< uint16_t, 16 > BitMask_uint16_t_16_localtype;
Define_Module_Class(panda3d.core, BitMask_uint16_t_16, BitMask_uint16_t_16_localtype, BitMask_uint16_t_16);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitMask_uint16_t_16 = &Dtool_BitMask_uint16_t_16;
static void Dtool_PyModuleClassInit_BitMask_uint16_t_16(PyObject *module);
BitMask< uint16_t, 16 > *Dtool_Coerce_BitMask_uint16_t_16(PyObject *args, BitMask< uint16_t, 16 > &coerced);

/**
 * Forward declarations for top-level class BitMask_uint32_t_32
 */
typedef BitMask< uint32_t, 32 > BitMask_uint32_t_32_localtype;
Define_Module_Class(panda3d.core, BitMask_uint32_t_32, BitMask_uint32_t_32_localtype, BitMask_uint32_t_32);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitMask_uint32_t_32 = &Dtool_BitMask_uint32_t_32;
static void Dtool_PyModuleClassInit_BitMask_uint32_t_32(PyObject *module);
BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced);

/**
 * Forward declarations for top-level class BitMask_uint64_t_64
 */
typedef BitMask< uint64_t, 64 > BitMask_uint64_t_64_localtype;
Define_Module_Class(panda3d.core, BitMask_uint64_t_64, BitMask_uint64_t_64_localtype, BitMask_uint64_t_64);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitMask_uint64_t_64 = &Dtool_BitMask_uint64_t_64;
static void Dtool_PyModuleClassInit_BitMask_uint64_t_64(PyObject *module);
BitMask< uint64_t, 64 > *Dtool_Coerce_BitMask_uint64_t_64(PyObject *args, BitMask< uint64_t, 64 > &coerced);

/**
 * Forward declarations for top-level class BitArray
 */
typedef BitArray BitArray_localtype;
Define_Module_Class(panda3d.core, BitArray, BitArray_localtype, BitArray);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitArray = &Dtool_BitArray;
static void Dtool_PyModuleClassInit_BitArray(PyObject *module);
bool Dtool_ConstCoerce_BitArray(PyObject *args, BitArray const *&coerced, bool &manage);
bool Dtool_Coerce_BitArray(PyObject *args, BitArray *&coerced, bool &manage);

/**
 * Forward declarations for top-level class ButtonHandle
 */
typedef ButtonHandle ButtonHandle_localtype;
Define_Module_Class(panda3d.core, ButtonHandle, ButtonHandle_localtype, ButtonHandle);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ButtonHandle = &Dtool_ButtonHandle;
static void Dtool_PyModuleClassInit_ButtonHandle(PyObject *module);
ButtonHandle *Dtool_Coerce_ButtonHandle(PyObject *args, ButtonHandle &coerced);

/**
 * Forward declarations for top-level class ButtonRegistry
 */
typedef ButtonRegistry ButtonRegistry_localtype;
Define_Module_Class(panda3d.core, ButtonRegistry, ButtonRegistry_localtype, ButtonRegistry);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ButtonRegistry = &Dtool_ButtonRegistry;
static void Dtool_PyModuleClassInit_ButtonRegistry(PyObject *module);

/**
 * Forward declarations for top-level class ButtonMap
 */
typedef ButtonMap ButtonMap_localtype;
Define_Module_ClassRef(panda3d.core, ButtonMap, ButtonMap_localtype, ButtonMap);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ButtonMap = &Dtool_ButtonMap;
static void Dtool_PyModuleClassInit_ButtonMap(PyObject *module);

/**
 * Forward declarations for top-level class CallbackObject
 */
typedef CallbackObject CallbackObject_localtype;
Define_Module_ClassRef(panda3d.core, CallbackObject, CallbackObject_localtype, CallbackObject);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackObject = &Dtool_CallbackObject;
static void Dtool_PyModuleClassInit_CallbackObject(PyObject *module);
bool Dtool_ConstCoerce_CallbackObject(PyObject *args, CPT(CallbackObject) &coerced);
bool Dtool_Coerce_CallbackObject(PyObject *args, PT(CallbackObject) &coerced);

/**
 * Forward declarations for top-level class CachedTypedWritableReferenceCount
 */
typedef CachedTypedWritableReferenceCount CachedTypedWritableReferenceCount_localtype;
Define_Module_ClassRef_Private(panda3d.core, CachedTypedWritableReferenceCount, CachedTypedWritableReferenceCount_localtype, CachedTypedWritableReferenceCount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CachedTypedWritableReferenceCount = &Dtool_CachedTypedWritableReferenceCount;
static void Dtool_PyModuleClassInit_CachedTypedWritableReferenceCount(PyObject *module);

/**
 * Forward declarations for top-level class CallbackData
 */
typedef CallbackData CallbackData_localtype;
Define_Module_Class(panda3d.core, CallbackData, CallbackData_localtype, CallbackData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackData = &Dtool_CallbackData;
static void Dtool_PyModuleClassInit_CallbackData(PyObject *module);

/**
 * Forward declarations for top-level class PythonCallbackObject
 */
typedef PythonCallbackObject PythonCallbackObject_localtype;
Define_Module_ClassRef(panda3d.core, PythonCallbackObject, PythonCallbackObject_localtype, PythonCallbackObject);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PythonCallbackObject = &Dtool_PythonCallbackObject;
static void Dtool_PyModuleClassInit_PythonCallbackObject(PyObject *module);
bool Dtool_ConstCoerce_PythonCallbackObject(PyObject *args, CPT(PythonCallbackObject) &coerced);
bool Dtool_Coerce_PythonCallbackObject(PyObject *args, PT(PythonCallbackObject) &coerced);

/**
 * Forward declarations for top-level class TimeVal
 */
typedef TimeVal TimeVal_localtype;
Define_Module_Class(panda3d.core, TimeVal, TimeVal_localtype, TimeVal);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TimeVal = &Dtool_TimeVal;
static void Dtool_PyModuleClassInit_TimeVal(PyObject *module);

/**
 * Forward declarations for top-level class ClockObject
 */
typedef ClockObject ClockObject_localtype;
Define_Module_ClassRef(panda3d.core, ClockObject, ClockObject_localtype, ClockObject);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ClockObject = &Dtool_ClockObject;
static void Dtool_PyModuleClassInit_ClockObject(PyObject *module);

/**
 * Forward declarations for top-level class CopyOnWriteObject
 */
typedef CopyOnWriteObject CopyOnWriteObject_localtype;
Define_Module_ClassRef(panda3d.core, CopyOnWriteObject, CopyOnWriteObject_localtype, CopyOnWriteObject);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CopyOnWriteObject = &Dtool_CopyOnWriteObject;
static void Dtool_PyModuleClassInit_CopyOnWriteObject(PyObject *module);

/**
 * Forward declarations for top-level class DatagramInputFile
 */
typedef DatagramInputFile DatagramInputFile_localtype;
Define_Module_Class(panda3d.core, DatagramInputFile, DatagramInputFile_localtype, DatagramInputFile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramInputFile = &Dtool_DatagramInputFile;
static void Dtool_PyModuleClassInit_DatagramInputFile(PyObject *module);

/**
 * Forward declarations for top-level class DoubleBitMask_BitMaskNative
 */
typedef DoubleBitMask< BitMaskNative > DoubleBitMask_BitMaskNative_localtype;
Define_Module_Class(panda3d.core, DoubleBitMask_BitMaskNative, DoubleBitMask_BitMaskNative_localtype, DoubleBitMask_BitMaskNative);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DoubleBitMask_BitMaskNative = &Dtool_DoubleBitMask_BitMaskNative;
static void Dtool_PyModuleClassInit_DoubleBitMask_BitMaskNative(PyObject *module);

/**
 * Forward declarations for top-level class DoubleBitMask_DoubleBitMaskNative
 */
typedef DoubleBitMask< DoubleBitMaskNative > DoubleBitMask_DoubleBitMaskNative_localtype;
Define_Module_Class(panda3d.core, DoubleBitMask_DoubleBitMaskNative, DoubleBitMask_DoubleBitMaskNative_localtype, DoubleBitMask_DoubleBitMaskNative);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative = &Dtool_DoubleBitMask_DoubleBitMaskNative;
static void Dtool_PyModuleClassInit_DoubleBitMask_DoubleBitMaskNative(PyObject *module);

/**
 * Forward declarations for top-level class KeyboardButton
 */
typedef KeyboardButton KeyboardButton_localtype;
Define_Module_Class(panda3d.core, KeyboardButton, KeyboardButton_localtype, KeyboardButton);
static struct Dtool_PyTypedObject *const Dtool_Ptr_KeyboardButton = &Dtool_KeyboardButton;
static void Dtool_PyModuleClassInit_KeyboardButton(PyObject *module);

/**
 * Forward declarations for top-level class ModifierButtons
 */
typedef ModifierButtons ModifierButtons_localtype;
Define_Module_Class(panda3d.core, ModifierButtons, ModifierButtons_localtype, ModifierButtons);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ModifierButtons = &Dtool_ModifierButtons;
static void Dtool_PyModuleClassInit_ModifierButtons(PyObject *module);

/**
 * Forward declarations for top-level class MouseButton
 */
typedef MouseButton MouseButton_localtype;
Define_Module_Class(panda3d.core, MouseButton, MouseButton_localtype, MouseButton);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MouseButton = &Dtool_MouseButton;
static void Dtool_PyModuleClassInit_MouseButton(PyObject *module);

/**
 * Forward declarations for top-level class MouseData
 */
typedef MouseData MouseData_localtype;
Define_Module_Class(panda3d.core, MouseData, MouseData_localtype, MouseData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MouseData = &Dtool_MouseData;
static void Dtool_PyModuleClassInit_MouseData(PyObject *module);

/**
 * Forward declarations for top-level class NodeCachedReferenceCount
 */
typedef NodeCachedReferenceCount NodeCachedReferenceCount_localtype;
Define_Module_ClassRef_Private(panda3d.core, NodeCachedReferenceCount, NodeCachedReferenceCount_localtype, NodeCachedReferenceCount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodeCachedReferenceCount = &Dtool_NodeCachedReferenceCount;
static void Dtool_PyModuleClassInit_NodeCachedReferenceCount(PyObject *module);

/**
 * Forward declarations for top-level class SparseArray
 */
typedef SparseArray SparseArray_localtype;
Define_Module_Class(panda3d.core, SparseArray, SparseArray_localtype, SparseArray);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SparseArray = &Dtool_SparseArray;
static void Dtool_PyModuleClassInit_SparseArray(PyObject *module);
bool Dtool_ConstCoerce_SparseArray(PyObject *args, SparseArray const *&coerced, bool &manage);
bool Dtool_Coerce_SparseArray(PyObject *args, SparseArray *&coerced, bool &manage);

/**
 * Forward declarations for top-level class ParamValueBase
 */
typedef ParamValueBase ParamValueBase_localtype;
Define_Module_ClassRef(panda3d.core, ParamValueBase, ParamValueBase_localtype, ParamValueBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValueBase = &Dtool_ParamValueBase;
static void Dtool_PyModuleClassInit_ParamValueBase(PyObject *module);

/**
 * Forward declarations for top-level class ParamTypedRefCount
 */
typedef ParamTypedRefCount ParamTypedRefCount_localtype;
Define_Module_ClassRef(panda3d.core, ParamTypedRefCount, ParamTypedRefCount_localtype, ParamTypedRefCount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamTypedRefCount = &Dtool_ParamTypedRefCount;
static void Dtool_PyModuleClassInit_ParamTypedRefCount(PyObject *module);
bool Dtool_ConstCoerce_ParamTypedRefCount(PyObject *args, CPT(ParamTypedRefCount) &coerced);
bool Dtool_Coerce_ParamTypedRefCount(PyObject *args, PT(ParamTypedRefCount) &coerced);

/**
 * Forward declarations for top-level class ParamValue_std_string
 */
typedef ParamValue< std::string > ParamValue_std_string_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_std_string, ParamValue_std_string_localtype, ParamValue_string);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_std_string = &Dtool_ParamValue_std_string;
static void Dtool_PyModuleClassInit_ParamValue_std_string(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_std_string(PyObject *args, CPT(ParamValue< std::string >) &coerced);
bool Dtool_Coerce_ParamValue_std_string(PyObject *args, PT(ParamValue< std::string >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_std_wstring
 */
typedef ParamValue< std::wstring > ParamValue_std_wstring_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_std_wstring, ParamValue_std_wstring_localtype, ParamValue_wstring);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_std_wstring = &Dtool_ParamValue_std_wstring;
static void Dtool_PyModuleClassInit_ParamValue_std_wstring(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_std_wstring(PyObject *args, CPT(ParamValue< std::wstring >) &coerced);
bool Dtool_Coerce_ParamValue_std_wstring(PyObject *args, PT(ParamValue< std::wstring >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LVecBase2d
 */
typedef ParamValue< LVecBase2d > ParamValue_LVecBase2d_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LVecBase2d, ParamValue_LVecBase2d_localtype, ParamValue_LVecBase2d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LVecBase2d = &Dtool_ParamValue_LVecBase2d;
static void Dtool_PyModuleClassInit_ParamValue_LVecBase2d(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LVecBase2d(PyObject *args, CPT(ParamValue< LVecBase2d >) &coerced);
bool Dtool_Coerce_ParamValue_LVecBase2d(PyObject *args, PT(ParamValue< LVecBase2d >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LVecBase2f
 */
typedef ParamValue< LVecBase2f > ParamValue_LVecBase2f_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LVecBase2f, ParamValue_LVecBase2f_localtype, ParamValue_LVecBase2f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LVecBase2f = &Dtool_ParamValue_LVecBase2f;
static void Dtool_PyModuleClassInit_ParamValue_LVecBase2f(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LVecBase2f(PyObject *args, CPT(ParamValue< LVecBase2f >) &coerced);
bool Dtool_Coerce_ParamValue_LVecBase2f(PyObject *args, PT(ParamValue< LVecBase2f >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LVecBase2i
 */
typedef ParamValue< LVecBase2i > ParamValue_LVecBase2i_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LVecBase2i, ParamValue_LVecBase2i_localtype, ParamValue_LVecBase2i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LVecBase2i = &Dtool_ParamValue_LVecBase2i;
static void Dtool_PyModuleClassInit_ParamValue_LVecBase2i(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LVecBase2i(PyObject *args, CPT(ParamValue< LVecBase2i >) &coerced);
bool Dtool_Coerce_ParamValue_LVecBase2i(PyObject *args, PT(ParamValue< LVecBase2i >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LVecBase3d
 */
typedef ParamValue< LVecBase3d > ParamValue_LVecBase3d_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LVecBase3d, ParamValue_LVecBase3d_localtype, ParamValue_LVecBase3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LVecBase3d = &Dtool_ParamValue_LVecBase3d;
static void Dtool_PyModuleClassInit_ParamValue_LVecBase3d(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LVecBase3d(PyObject *args, CPT(ParamValue< LVecBase3d >) &coerced);
bool Dtool_Coerce_ParamValue_LVecBase3d(PyObject *args, PT(ParamValue< LVecBase3d >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LVecBase3f
 */
typedef ParamValue< LVecBase3f > ParamValue_LVecBase3f_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LVecBase3f, ParamValue_LVecBase3f_localtype, ParamValue_LVecBase3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LVecBase3f = &Dtool_ParamValue_LVecBase3f;
static void Dtool_PyModuleClassInit_ParamValue_LVecBase3f(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LVecBase3f(PyObject *args, CPT(ParamValue< LVecBase3f >) &coerced);
bool Dtool_Coerce_ParamValue_LVecBase3f(PyObject *args, PT(ParamValue< LVecBase3f >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LVecBase3i
 */
typedef ParamValue< LVecBase3i > ParamValue_LVecBase3i_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LVecBase3i, ParamValue_LVecBase3i_localtype, ParamValue_LVecBase3i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LVecBase3i = &Dtool_ParamValue_LVecBase3i;
static void Dtool_PyModuleClassInit_ParamValue_LVecBase3i(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LVecBase3i(PyObject *args, CPT(ParamValue< LVecBase3i >) &coerced);
bool Dtool_Coerce_ParamValue_LVecBase3i(PyObject *args, PT(ParamValue< LVecBase3i >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LVecBase4d
 */
typedef ParamValue< LVecBase4d > ParamValue_LVecBase4d_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LVecBase4d, ParamValue_LVecBase4d_localtype, ParamValue_LVecBase4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LVecBase4d = &Dtool_ParamValue_LVecBase4d;
static void Dtool_PyModuleClassInit_ParamValue_LVecBase4d(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LVecBase4d(PyObject *args, CPT(ParamValue< LVecBase4d >) &coerced);
bool Dtool_Coerce_ParamValue_LVecBase4d(PyObject *args, PT(ParamValue< LVecBase4d >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LVecBase4f
 */
typedef ParamValue< LVecBase4f > ParamValue_LVecBase4f_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LVecBase4f, ParamValue_LVecBase4f_localtype, ParamValue_LVecBase4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LVecBase4f = &Dtool_ParamValue_LVecBase4f;
static void Dtool_PyModuleClassInit_ParamValue_LVecBase4f(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LVecBase4f(PyObject *args, CPT(ParamValue< LVecBase4f >) &coerced);
bool Dtool_Coerce_ParamValue_LVecBase4f(PyObject *args, PT(ParamValue< LVecBase4f >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LVecBase4i
 */
typedef ParamValue< LVecBase4i > ParamValue_LVecBase4i_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LVecBase4i, ParamValue_LVecBase4i_localtype, ParamValue_LVecBase4i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LVecBase4i = &Dtool_ParamValue_LVecBase4i;
static void Dtool_PyModuleClassInit_ParamValue_LVecBase4i(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LVecBase4i(PyObject *args, CPT(ParamValue< LVecBase4i >) &coerced);
bool Dtool_Coerce_ParamValue_LVecBase4i(PyObject *args, PT(ParamValue< LVecBase4i >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LMatrix3d
 */
typedef ParamValue< LMatrix3d > ParamValue_LMatrix3d_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LMatrix3d, ParamValue_LMatrix3d_localtype, ParamValue_LMatrix3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LMatrix3d = &Dtool_ParamValue_LMatrix3d;
static void Dtool_PyModuleClassInit_ParamValue_LMatrix3d(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LMatrix3d(PyObject *args, CPT(ParamValue< LMatrix3d >) &coerced);
bool Dtool_Coerce_ParamValue_LMatrix3d(PyObject *args, PT(ParamValue< LMatrix3d >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LMatrix3f
 */
typedef ParamValue< LMatrix3f > ParamValue_LMatrix3f_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LMatrix3f, ParamValue_LMatrix3f_localtype, ParamValue_LMatrix3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LMatrix3f = &Dtool_ParamValue_LMatrix3f;
static void Dtool_PyModuleClassInit_ParamValue_LMatrix3f(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LMatrix3f(PyObject *args, CPT(ParamValue< LMatrix3f >) &coerced);
bool Dtool_Coerce_ParamValue_LMatrix3f(PyObject *args, PT(ParamValue< LMatrix3f >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LMatrix4d
 */
typedef ParamValue< LMatrix4d > ParamValue_LMatrix4d_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LMatrix4d, ParamValue_LMatrix4d_localtype, ParamValue_LMatrix4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LMatrix4d = &Dtool_ParamValue_LMatrix4d;
static void Dtool_PyModuleClassInit_ParamValue_LMatrix4d(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LMatrix4d(PyObject *args, CPT(ParamValue< LMatrix4d >) &coerced);
bool Dtool_Coerce_ParamValue_LMatrix4d(PyObject *args, PT(ParamValue< LMatrix4d >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LMatrix4f
 */
typedef ParamValue< LMatrix4f > ParamValue_LMatrix4f_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LMatrix4f, ParamValue_LMatrix4f_localtype, ParamValue_LMatrix4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LMatrix4f = &Dtool_ParamValue_LMatrix4f;
static void Dtool_PyModuleClassInit_ParamValue_LMatrix4f(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LMatrix4f(PyObject *args, CPT(ParamValue< LMatrix4f >) &coerced);
bool Dtool_Coerce_ParamValue_LMatrix4f(PyObject *args, PT(ParamValue< LMatrix4f >) &coerced);

/**
 * Forward declarations for top-level class WritableConfigurable
 */
typedef WritableConfigurable WritableConfigurable_localtype;
Define_Module_Class(panda3d.core, WritableConfigurable, WritableConfigurable_localtype, WritableConfigurable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_WritableConfigurable = &Dtool_WritableConfigurable;
static void Dtool_PyModuleClassInit_WritableConfigurable(PyObject *module);

/**
 * Forward declarations for top-level class UniqueIdAllocator
 */
typedef UniqueIdAllocator UniqueIdAllocator_localtype;
Define_Module_Class(panda3d.core, UniqueIdAllocator, UniqueIdAllocator_localtype, UniqueIdAllocator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UniqueIdAllocator = &Dtool_UniqueIdAllocator;
static void Dtool_PyModuleClassInit_UniqueIdAllocator(PyObject *module);
bool Dtool_ConstCoerce_UniqueIdAllocator(PyObject *args, UniqueIdAllocator const *&coerced, bool &manage);
bool Dtool_Coerce_UniqueIdAllocator(PyObject *args, UniqueIdAllocator *&coerced, bool &manage);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// istream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_istream;
#else
extern struct Dtool_PyTypedObject Dtool_istream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_istream = &Dtool_istream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Filename
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Filename;
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != NULL, NULL);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != NULL, NULL);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// ConfigPage
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ConfigPage;
#else
extern struct Dtool_PyTypedObject Dtool_ConfigPage;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigPage = &Dtool_ConfigPage;
#endif
// PointerToVoid
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PointerToVoid;
#else
extern struct Dtool_PyTypedObject Dtool_PointerToVoid;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToVoid = &Dtool_PointerToVoid;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// Thread
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Thread;
#else
extern struct Dtool_PyTypedObject Dtool_Thread;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Thread = &Dtool_Thread;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// DatagramIterator
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_DatagramIterator;
inline static DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced) {
  nassertr(Dtool_Ptr_DatagramIterator != NULL, NULL);
  nassertr(Dtool_Ptr_DatagramIterator->_Dtool_Coerce != NULL, NULL);
  return ((DatagramIterator *(*)(PyObject *, DatagramIterator &))Dtool_Ptr_DatagramIterator->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_DatagramIterator;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramIterator = &Dtool_DatagramIterator;
extern DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced);
#endif
// DatagramGenerator
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_DatagramGenerator;
#else
extern struct Dtool_PyTypedObject Dtool_DatagramGenerator;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramGenerator = &Dtool_DatagramGenerator;
#endif
// FileReference
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_FileReference;
inline static bool Dtool_ConstCoerce_FileReference(PyObject *args, CPT(FileReference) &coerced) {
  nassertr(Dtool_Ptr_FileReference != NULL, false);
  nassertr(Dtool_Ptr_FileReference->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(FileReference) &))Dtool_Ptr_FileReference->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_FileReference(PyObject *args, PT(FileReference) &coerced) {
  nassertr(Dtool_Ptr_FileReference != NULL, false);
  nassertr(Dtool_Ptr_FileReference->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(FileReference) &))Dtool_Ptr_FileReference->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_FileReference;
static struct Dtool_PyTypedObject *const Dtool_Ptr_FileReference = &Dtool_FileReference;
extern bool Dtool_ConstCoerce_FileReference(PyObject *args, CPT(FileReference) &coerced);
extern bool Dtool_Coerce_FileReference(PyObject *args, PT(FileReference) &coerced);
#endif
// DatagramSink
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_DatagramSink;
#else
extern struct Dtool_PyTypedObject Dtool_DatagramSink;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramSink = &Dtool_DatagramSink;
#endif
// ConfigVariableSearchPath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ConfigVariableSearchPath;
inline static bool Dtool_ConstCoerce_ConfigVariableSearchPath(PyObject *args, ConfigVariableSearchPath const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_ConfigVariableSearchPath != NULL, false);
  nassertr(Dtool_Ptr_ConfigVariableSearchPath->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, ConfigVariableSearchPath const *&, bool&))Dtool_Ptr_ConfigVariableSearchPath->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_ConfigVariableSearchPath(PyObject *args, ConfigVariableSearchPath *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_ConfigVariableSearchPath != NULL, false);
  nassertr(Dtool_Ptr_ConfigVariableSearchPath->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, ConfigVariableSearchPath *&, bool&))Dtool_Ptr_ConfigVariableSearchPath->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_ConfigVariableSearchPath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableSearchPath = &Dtool_ConfigVariableSearchPath;
extern bool Dtool_ConstCoerce_ConfigVariableSearchPath(PyObject *args, ConfigVariableSearchPath const *&coerced, bool &manage);
extern bool Dtool_Coerce_ConfigVariableSearchPath(PyObject *args, ConfigVariableSearchPath *&coerced, bool &manage);
#endif
// VirtualFile
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_VirtualFile;
#else
extern struct Dtool_PyTypedObject Dtool_VirtualFile;
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFile = &Dtool_VirtualFile;
#endif
// HashVal
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_HashVal;
#else
extern struct Dtool_PyTypedObject Dtool_HashVal;
static struct Dtool_PyTypedObject *const Dtool_Ptr_HashVal = &Dtool_HashVal;
#endif
// LVecBase2f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase2f;
inline static LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced) {
  nassertr(Dtool_Ptr_LVecBase2f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase2f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase2f *(*)(PyObject *, LVecBase2f &))Dtool_Ptr_LVecBase2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2f = &Dtool_LVecBase2f;
extern LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced);
#endif
// LVecBase3i
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3i;
inline static LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced) {
  nassertr(Dtool_Ptr_LVecBase3i != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3i->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3i *(*)(PyObject *, LVecBase3i &))Dtool_Ptr_LVecBase3i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3i = &Dtool_LVecBase3i;
extern LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced);
#endif
// LVecBase2i
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase2i;
inline static LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced) {
  nassertr(Dtool_Ptr_LVecBase2i != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase2i->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase2i *(*)(PyObject *, LVecBase2i &))Dtool_Ptr_LVecBase2i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2i = &Dtool_LVecBase2i;
extern LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced);
#endif
// LVecBase2d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase2d;
inline static LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced) {
  nassertr(Dtool_Ptr_LVecBase2d != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase2d->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase2d *(*)(PyObject *, LVecBase2d &))Dtool_Ptr_LVecBase2d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2d = &Dtool_LVecBase2d;
extern LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3f;
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LVecBase3d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3d;
inline static LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced) {
  nassertr(Dtool_Ptr_LVecBase3d != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3d->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3d *(*)(PyObject *, LVecBase3d &))Dtool_Ptr_LVecBase3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3d = &Dtool_LVecBase3d;
extern LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix4f;
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// LVecBase4i
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4i;
inline static LVecBase4i *Dtool_Coerce_LVecBase4i(PyObject *args, LVecBase4i &coerced) {
  nassertr(Dtool_Ptr_LVecBase4i != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4i->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4i *(*)(PyObject *, LVecBase4i &))Dtool_Ptr_LVecBase4i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4i = &Dtool_LVecBase4i;
extern LVecBase4i *Dtool_Coerce_LVecBase4i(PyObject *args, LVecBase4i &coerced);
#endif
// LVecBase4d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4d;
inline static LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced) {
  nassertr(Dtool_Ptr_LVecBase4d != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4d->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4d *(*)(PyObject *, LVecBase4d &))Dtool_Ptr_LVecBase4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4d = &Dtool_LVecBase4d;
extern LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced);
#endif
// LMatrix3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix3f;
inline static LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced) {
  nassertr(Dtool_Ptr_LMatrix3f != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix3f->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix3f *(*)(PyObject *, LMatrix3f &))Dtool_Ptr_LMatrix3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3f = &Dtool_LMatrix3f;
extern LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4f;
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LMatrix3d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix3d;
inline static LMatrix3d *Dtool_Coerce_LMatrix3d(PyObject *args, LMatrix3d &coerced) {
  nassertr(Dtool_Ptr_LMatrix3d != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix3d->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix3d *(*)(PyObject *, LMatrix3d &))Dtool_Ptr_LMatrix3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3d = &Dtool_LMatrix3d;
extern LMatrix3d *Dtool_Coerce_LMatrix3d(PyObject *args, LMatrix3d &coerced);
#endif
// LMatrix4d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix4d;
inline static LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced) {
  nassertr(Dtool_Ptr_LMatrix4d != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix4d->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix4d *(*)(PyObject *, LMatrix4d &))Dtool_Ptr_LMatrix4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4d = &Dtool_LMatrix4d;
extern LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python function wrapper for:
 * ColorSpace parse_color_space_string(std::string const &str)
 */
static PyObject *Dtool_parse_color_space_string_665(PyObject *, PyObject *arg) {
  // 1-ColorSpace parse_color_space_string(std::string const &str)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    ColorSpace return_value = parse_color_space_string(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "parse_color_space_string(str str)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_parse_color_space_string_665_comment =
  "C++ Interface:\n"
  "parse_color_space_string(str str)\n";
#else
static const char *Dtool_parse_color_space_string_665_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string format_color_space(ColorSpace cs)
 */
static PyObject *Dtool_format_color_space_666(PyObject *, PyObject *arg) {
  // 1-std::string format_color_space(ColorSpace cs)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = format_color_space((ColorSpace)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "format_color_space(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_format_color_space_666_comment =
  "C++ Interface:\n"
  "format_color_space(int cs)\n";
#else
static const char *Dtool_format_color_space_666_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConfigVariableSearchPath &get_model_path(void)
 */
static PyObject *Dtool_get_model_path_667(PyObject *, PyObject *) {
  // 1-ConfigVariableSearchPath &get_model_path(void)
  ConfigVariableSearchPath *return_value = &(get_model_path());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableSearchPath, false, false);
}

#ifndef NDEBUG
static const char *Dtool_get_model_path_667_comment =
  "C++ Interface:\n"
  "get_model_path()\n";
#else
static const char *Dtool_get_model_path_667_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConfigVariableSearchPath &get_plugin_path(void)
 */
static PyObject *Dtool_get_plugin_path_668(PyObject *, PyObject *) {
  // 1-ConfigVariableSearchPath &get_plugin_path(void)
  ConfigVariableSearchPath *return_value = &(get_plugin_path());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableSearchPath, false, false);
}

#ifndef NDEBUG
static const char *Dtool_get_plugin_path_668_comment =
  "C++ Interface:\n"
  "get_plugin_path()\n";
#else
static const char *Dtool_get_plugin_path_668_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConfigPage *load_prc_file(Filename const &filename)
 */
static PyObject *Dtool_load_prc_file_847(PyObject *, PyObject *arg) {
  // 1-ConfigPage *load_prc_file(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "load_prc_file", "Filename");
  }
  ConfigPage *return_value = load_prc_file(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPage, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_prc_file(const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_load_prc_file_847_comment =
  "C++ Interface:\n"
  "load_prc_file(const Filename filename)\n"
  "\n"
  "/**\n"
  " * A convenience function for loading explicit prc files from a disk file or\n"
  " * from within a multifile (via the virtual file system).  Save the return\n"
  " * value and pass it to unload_prc_file() if you ever want to unload this file\n"
  " * later.\n"
  " *\n"
  " * The filename is first searched along the default prc search path, and then\n"
  " * also along the model path, for convenience.\n"
  " *\n"
  " * This function is defined in putil instead of in dtool with the read of the\n"
  " * prc stuff, so that it can take advantage of the virtual file system (which\n"
  " * is defined in express), and the model path (which is in putil).\n"
  " */\n"
  "\n"
  "/**\n"
  " * A convenience function for loading explicit prc files from a disk file or\n"
  " * from within a multifile (via the virtual file system).  Save the return\n"
  " * value and pass it to unload_prc_file() if you ever want to unload this file\n"
  " * later.\n"
  " *\n"
  " * The filename is first searched along the default prc search path, and then\n"
  " * also along the model path, for convenience.\n"
  " *\n"
  " * This function is defined in putil instead of in dtool with the read of the\n"
  " * prc stuff, so that it can take advantage of the virtual file system (which\n"
  " * is defined in express), and the model path (which is in putil).\n"
  " */";
#else
static const char *Dtool_load_prc_file_847_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConfigPage *load_prc_file_data(std::string const &name, std::string const &data)
 */
static PyObject *Dtool_load_prc_file_data_848(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-ConfigPage *load_prc_file_data(std::string const &name, std::string const &data)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"name", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:load_prc_file_data", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
    ConfigPage *return_value = load_prc_file_data(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPage, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_prc_file_data(str name, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_load_prc_file_data_848_comment =
  "C++ Interface:\n"
  "load_prc_file_data(str name, str data)\n"
  "\n"
  "/**\n"
  " * Another convenience function to load a prc file from an explicit string,\n"
  " * which represents the contents of the prc file.\n"
  " *\n"
  " * The first parameter is an arbitrary name to assign to this in-memory prc\n"
  " * file.  Supply a filename if the data was read from a file, or use any other\n"
  " * name that is meaningful to you.  The name is only used when the set of\n"
  " * loaded prc files is listed.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Another convenience function to load a prc file from an explicit string,\n"
  " * which represents the contents of the prc file.\n"
  " *\n"
  " * The first parameter is an arbitrary name to assign to this in-memory prc\n"
  " * file.  Supply a filename if the data was read from a file, or use any other\n"
  " * name that is meaningful to you.  The name is only used when the set of\n"
  " * loaded prc files is listed.\n"
  " */";
#else
static const char *Dtool_load_prc_file_data_848_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool unload_prc_file(ConfigPage *page)
 */
static PyObject *Dtool_unload_prc_file_849(PyObject *, PyObject *arg) {
  // 1-bool unload_prc_file(ConfigPage *page)
  ConfigPage *arg_this = (ConfigPage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ConfigPage, 0, "unload_prc_file", false, true);
  if (arg_this != NULL) {
    bool return_value = unload_prc_file(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unload_prc_file(ConfigPage page)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_unload_prc_file_849_comment =
  "C++ Interface:\n"
  "unload_prc_file(ConfigPage page)\n";
#else
static const char *Dtool_unload_prc_file_849_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void hash_prc_variables(HashVal &hash)
 */
static PyObject *Dtool_hash_prc_variables_850(PyObject *, PyObject *arg) {
  // 1-void hash_prc_variables(HashVal &hash)
  HashVal *arg_this = (HashVal *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_HashVal, 0, "hash_prc_variables", false, true);
  if (arg_this != NULL) {
    hash_prc_variables(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "hash_prc_variables(HashVal hash)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_hash_prc_variables_850_comment =
  "C++ Interface:\n"
  "hash_prc_variables(HashVal hash)\n";
#else
static const char *Dtool_hash_prc_variables_850_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *py_decode_TypedWritable_from_bam_stream(PyObject *this_class, std::string const &data)
 */
static PyObject *Dtool_py_decode_TypedWritable_from_bam_stream_1101(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-PyObject *py_decode_TypedWritable_from_bam_stream(PyObject *this_class, std::string const &data)
  PyObject *param0;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"this_class", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:py_decode_TypedWritable_from_bam_stream", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
    PyObject *return_value = py_decode_TypedWritable_from_bam_stream(param0, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "py_decode_TypedWritable_from_bam_stream(object this_class, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_py_decode_TypedWritable_from_bam_stream_1101_comment =
  "C++ Interface:\n"
  "py_decode_TypedWritable_from_bam_stream(object this_class, str data)\n"
  "\n"
  "/**\n"
  " * This wrapper is defined as a global function to suit pickle's needs.\n"
  " *\n"
  " * This hooks into the native pickle and cPickle modules, but it cannot\n"
  " * properly handle self-referential BAM objects.\n"
  " */";
#else
static const char *Dtool_py_decode_TypedWritable_from_bam_stream_1101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *py_decode_TypedWritable_from_bam_stream_persist(PyObject *unpickler, PyObject *this_class, std::string const &data)
 */
static PyObject *Dtool_py_decode_TypedWritable_from_bam_stream_persist_1102(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-PyObject *py_decode_TypedWritable_from_bam_stream_persist(PyObject *unpickler, PyObject *this_class, std::string const &data)
  PyObject *param0;
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"unpickler", "this_class", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#:py_decode_TypedWritable_from_bam_stream_persist", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len)) {
    PyObject *return_value = py_decode_TypedWritable_from_bam_stream_persist(param0, param1, std::string(param2_str, param2_len));
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "py_decode_TypedWritable_from_bam_stream_persist(object unpickler, object this_class, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_py_decode_TypedWritable_from_bam_stream_persist_1102_comment =
  "C++ Interface:\n"
  "py_decode_TypedWritable_from_bam_stream_persist(object unpickler, object this_class, str data)\n"
  "\n"
  "/**\n"
  " * This wrapper is defined as a global function to suit pickle's needs.\n"
  " *\n"
  " * This is similar to py_decode_TypedWritable_from_bam_stream, but it provides\n"
  " * additional support for the missing persistent-state object needed to\n"
  " * properly support self-referential BAM objects written to the pickle stream.\n"
  " * This hooks into the pickle and cPickle modules implemented in\n"
  " * direct/src/stdpy.\n"
  " */";
#else
static const char *Dtool_py_decode_TypedWritable_from_bam_stream_persist_1102_comment = NULL;
#endif

/**
 * Python wrappers for functions of class ConstPointerToArray< ushort >
 */
/**
 * Python function wrapper for:
 * inline ushort const &ConstPointerToArray< ushort >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_ushort_get_element_10(PyObject *self, PyObject *arg) {
  ConstPointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_ushort, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ushort const &ConstPointerToArray< ushort >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    ushort return_value = (*(const ConstPointerToArray< ushort >*)local_this).get_element((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_ushort_get_element_10_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_ushort_get_element_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< ushort >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_ushort_get_data_12(PyObject *self, PyObject *) {
  ConstPointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_ushort, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< ushort >::get_data(void) const
  std::basic_string< char > return_value = (*(const ConstPointerToArray< ushort >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_ushort_get_data_12_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_ushort_get_data_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< ushort >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_ushort_get_subdata_13(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_ushort, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< ushort >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const ConstPointerToArray< ushort >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_ushort_get_subdata_13_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_ushort_get_subdata_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< ushort >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_ushort_get_ref_count_14(PyObject *self, PyObject *) {
  ConstPointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_ushort, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< ushort >::get_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< ushort >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_ushort_get_ref_count_14_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_ushort_get_ref_count_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< ushort >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_ushort_get_node_ref_count_15(PyObject *self, PyObject *) {
  ConstPointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_ushort, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< ushort >::get_node_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< ushort >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_ushort_get_node_ref_count_15_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_ushort_get_node_ref_count_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< ushort >::ConstPointerToArray(ConstPointerToArray< ushort > const &copy)
 * inline ConstPointerToArray< ushort >::ConstPointerToArray(PointerToArray< ushort > const &copy)
 * ConstPointerToArray< ushort >::ConstPointerToArray(PyObject *self, PyObject *source)
 */
static int Dtool_Init_ConstPointerToArray_ushort(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConstPointerToArray< ushort >::ConstPointerToArray(ConstPointerToArray< ushort > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< ushort > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConstPointerToArray_ushort, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< ushort > *return_value = new ConstPointerToArray< ushort >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_ushort, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< ushort >::ConstPointerToArray(PointerToArray< ushort > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< ushort > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_ushort, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< ushort > *return_value = new ConstPointerToArray< ushort >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_ushort, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConstPointerToArray< ushort >::ConstPointerToArray(PyObject *self, PyObject *source)
    PyObject *param0;
    static const char *keyword_list[] = {"source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      // Pre-initialize self for the constructor
      DTool_PyInit_Finalize(self, NULL, &Dtool_ConstPointerToArray_ushort, false, false);
      ConstPointerToArray< ushort > *result = new ConstPointerToArray< ushort >;
      invoke_extension(result).__init__(self, param0);
      ConstPointerToArray< ushort > *return_value = result;
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        delete return_value;
        return -1;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          delete return_value;
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_ushort, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< ushort >::ConstPointerToArray(ConstPointerToArray< ushort > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< ushort > param0_local;
      ConstPointerToArray< ushort > const *param0_this = Dtool_Coerce_ConstPointerToArray_ushort(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< ushort > *return_value = new ConstPointerToArray< ushort >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_ushort, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< ushort >::ConstPointerToArray(PointerToArray< ushort > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< ushort > param0_local;
      PointerToArray< ushort > const *param0_this = Dtool_Coerce_PointerToArray_ushort(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< ushort > *return_value = new ConstPointerToArray< ushort >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_ushort, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ConstPointerToArray< ushort >::ConstPointerToArray(PyObject *self, PyObject *source)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n"
      "ConstPointerToArray(object source)\n");
  }
  return -1;
}

ConstPointerToArray< ushort > *Dtool_Coerce_ConstPointerToArray_ushort(PyObject *args, ConstPointerToArray< ushort > &coerced) {
  ConstPointerToArray< ushort > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConstPointerToArray_ushort, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< ushort > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline ConstPointerToArray< ushort >::ConstPointerToArray(PointerToArray< ushort > const &copy)
      PointerToArray< ushort > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PointerToArray_ushort, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = ConstPointerToArray< ushort >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 ConstPointerToArray< ushort >::ConstPointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_ConstPointerToArray_ushort(&Dtool_ConstPointerToArray_ushort._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_ushort(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConstPointerToArray_ushort) {
    printf("ConstPointerToArray_ushort ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConstPointerToArray< ushort > *local_this = (ConstPointerToArray< ushort > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConstPointerToArray_ushort) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_ushort) {
    return (PointerToArrayBase< ushort > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort) {
    return (PointerToBase< ReferenceCountedVector< ushort > > *)(PointerToArrayBase< ushort > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< ushort > > *)(PointerToArrayBase< ushort > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_ushort(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_ushort) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_ushort) {
    PointerToArrayBase< ushort >* other_this = (PointerToArrayBase< ushort >*)from_this;
    return (ConstPointerToArray< ushort >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort) {
    PointerToBase< ReferenceCountedVector< ushort > >* other_this = (PointerToBase< ReferenceCountedVector< ushort > >*)from_this;
    return (ConstPointerToArray< ushort >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< ushort >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< ushort >
 */
static int Dtool_Init_PointerToArrayBase_ushort(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_ushort(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArrayBase_ushort) {
    printf("PointerToArrayBase_ushort ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArrayBase< ushort > *local_this = (PointerToArrayBase< ushort > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArrayBase_ushort) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort) {
    return (PointerToBase< ReferenceCountedVector< ushort > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< ushort > > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_ushort(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_ushort) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort) {
    PointerToBase< ReferenceCountedVector< ushort > >* other_this = (PointerToBase< ReferenceCountedVector< ushort > >*)from_this;
    return (PointerToArrayBase< ushort >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< ushort >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< ushort > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< ushort > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_ushort_clear_5(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< ushort > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_ushort, (void **)&local_this, "PointerToBase_ReferenceCountedVector_ushort.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< ushort > >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_ushort_clear_5_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_ushort_clear_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< ushort > >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_ushort_output_6(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< ushort > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_ushort, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< ReferenceCountedVector< ushort > >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< ReferenceCountedVector< ushort > >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_ushort_output_6_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_ushort_output_6_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_ushort(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_ushort(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort) {
    printf("PointerToBase_ReferenceCountedVector_ushort ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< ReferenceCountedVector< ushort > > *local_this = (PointerToBase< ReferenceCountedVector< ushort > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_ushort(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< ushort > >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArray< ushort >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< ushort > PointerToArray< ushort >::empty_array(unsigned long int n, TypeHandle type_handle = (_get_type_handle((ushort const *)(0))))
 */
static PyObject *Dtool_PointerToArray_ushort_empty_array_21(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-static inline PointerToArray< ushort > PointerToArray< ushort >::empty_array(unsigned long int n, TypeHandle type_handle)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
        PointerToArray< ushort > *return_value = new PointerToArray< ushort >(PointerToArray< ushort >::empty_array((unsigned long int)param0));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_ushort, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-static inline PointerToArray< ushort > PointerToArray< ushort >::empty_array(unsigned long int n, TypeHandle type_handle)
      unsigned long param0;
      PyObject *param1;
      static const char *keyword_list[] = {"n", "type_handle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:empty_array", (char **)keyword_list, &param0, &param1)) {
        TypeHandle param1_local;
        TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
        }
        PointerToArray< ushort > *return_value = new PointerToArray< ushort >(PointerToArray< ushort >::empty_array((unsigned long int)param0, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_ushort, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "empty_array() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n)\n"
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_empty_array_21_comment =
  "C++ Interface:\n"
  "empty_array(int n)\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_ushort_empty_array_21_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< ushort >::push_back(ushort const &x)
 */
static PyObject *Dtool_PointerToArray_ushort_push_back_23(PyObject *self, PyObject *arg) {
  PointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_ushort, (void **)&local_this, "PointerToArray_ushort.push_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< ushort >::push_back(ushort const &x)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    (*local_this).push_back((ushort)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, int x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_push_back_23_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, int x)\n";
#else
static const char *Dtool_PointerToArray_ushort_push_back_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< ushort >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_ushort_pop_back_24(PyObject *self, PyObject *) {
  PointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_ushort, (void **)&local_this, "PointerToArray_ushort.pop_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< ushort >::pop_back(void)
  (*local_this).pop_back();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_pop_back_24_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_ushort_pop_back_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ushort const &PointerToArray< ushort >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_ushort_get_element_25(PyObject *self, PyObject *arg) {
  PointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_ushort, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ushort const &PointerToArray< ushort >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    ushort return_value = (*(const PointerToArray< ushort >*)local_this).get_element((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_get_element_25_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_ushort_get_element_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< ushort >::set_element(unsigned long int n, ushort const &value)
 */
static PyObject *Dtool_PointerToArray_ushort_set_element_26(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_ushort, (void **)&local_this, "PointerToArray_ushort.set_element")) {
    return NULL;
  }
  // 1-inline void PointerToArray< ushort >::set_element(unsigned long int n, ushort const &value)
  unsigned long param1;
  long param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kl:set_element", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param2 < 0 || param2 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param2);
    }
#endif
    (*local_this).set_element((unsigned long int)param1, (ushort const &)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_set_element_26_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, int value)\n";
#else
static const char *Dtool_PointerToArray_ushort_set_element_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< ushort >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_ushort_get_data_29(PyObject *self, PyObject *) {
  PointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_ushort, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< ushort >::get_data(void) const
  std::basic_string< char > return_value = (*(const PointerToArray< ushort >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_get_data_29_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_ushort_get_data_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< ushort >::set_data(std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_ushort_set_data_30(PyObject *self, PyObject *arg) {
  PointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_ushort, (void **)&local_this, "PointerToArray_ushort.set_data")) {
    return NULL;
  }
  // 1-inline void PointerToArray< ushort >::set_data(std::basic_string< char > const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_set_data_30_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, str data)\n";
#else
static const char *Dtool_PointerToArray_ushort_set_data_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< ushort >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_ushort_get_subdata_31(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_ushort, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< ushort >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const PointerToArray< ushort >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_get_subdata_31_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_ushort_get_subdata_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< ushort >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_ushort_set_subdata_32(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_ushort, (void **)&local_this, "PointerToArray_ushort.set_subdata")) {
    return NULL;
  }
  // 1-inline void PointerToArray< ushort >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    (*local_this).set_subdata((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_set_subdata_32_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_ushort_set_subdata_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< ushort >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_ushort_get_ref_count_33(PyObject *self, PyObject *) {
  PointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_ushort, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< ushort >::get_ref_count(void) const
  int return_value = (*(const PointerToArray< ushort >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_get_ref_count_33_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_ushort_get_ref_count_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< ushort >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_ushort_get_node_ref_count_34(PyObject *self, PyObject *) {
  PointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_ushort, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< ushort >::get_node_ref_count(void) const
  int return_value = (*(const PointerToArray< ushort >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_get_node_ref_count_34_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_ushort_get_node_ref_count_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< ushort >::PointerToArray(PointerToArray< ushort > const &copy)
 * PointerToArray< ushort >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< ushort >::PointerToArray(TypeHandle type_handle = (_get_type_handle((ushort const *)(0))))
 */
static int Dtool_Init_PointerToArray_ushort(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< ushort >::PointerToArray(TypeHandle type_handle)
      PointerToArray< ushort > *return_value = new PointerToArray< ushort >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_ushort, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< ushort >::PointerToArray(PointerToArray< ushort > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< ushort > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_ushort, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< ushort > *return_value = new PointerToArray< ushort >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_ushort, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< ushort >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypeHandle, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< ushort > *return_value = new PointerToArray< ushort >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_ushort, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerToArray< ushort >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        static const char *keyword_list[] = {"source", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_ushort, false, false);
          PointerToArray< ushort > *result = new PointerToArray< ushort >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< ushort > *return_value = result;
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_ushort, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< ushort >::PointerToArray(PointerToArray< ushort > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< ushort > param0_local;
          PointerToArray< ushort > const *param0_this = Dtool_Coerce_PointerToArray_ushort(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< ushort > *return_value = new PointerToArray< ushort >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_ushort, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< ushort >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< ushort > *return_value = new PointerToArray< ushort >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_ushort, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerToArray< ushort >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< ushort > *Dtool_Coerce_PointerToArray_ushort(PyObject *args, PointerToArray< ushort > &coerced) {
  PointerToArray< ushort > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerToArray_ushort, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< ushort > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< ushort >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypeHandle, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = PointerToArray< ushort >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< ushort >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_ushort(&Dtool_PointerToArray_ushort._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_PointerToArray_ushort(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArray_ushort) {
    printf("PointerToArray_ushort ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArray< ushort > *local_this = (PointerToArray< ushort > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArray_ushort) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_ushort) {
    return (PointerToArrayBase< ushort > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort) {
    return (PointerToBase< ReferenceCountedVector< ushort > > *)(PointerToArrayBase< ushort > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< ushort > > *)(PointerToArrayBase< ushort > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArray_ushort(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArray_ushort) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_ushort) {
    PointerToArrayBase< ushort >* other_this = (PointerToArrayBase< ushort >*)from_this;
    return (PointerToArray< ushort >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort) {
    PointerToBase< ReferenceCountedVector< ushort > >* other_this = (PointerToBase< ReferenceCountedVector< ushort > >*)from_this;
    return (PointerToArray< ushort >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< ushort >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AnimInterface
 */
/**
 * Python function wrapper for:
 * inline void AnimInterface::play(void)
 * inline void AnimInterface::play(double from, double to)
 */
static PyObject *Dtool_AnimInterface_play_40(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimInterface, (void **)&local_this, "AnimInterface.play")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void AnimInterface::play(void)
      (*local_this).play();
      return Dtool_Return_None();
    }
    break;
  case 2:
    {
      // 1-inline void AnimInterface::play(double from, double to)
      double param1;
      double param2;
      static const char *keyword_list[] = {"from", "to", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:play", (char **)keyword_list, &param1, &param2)) {
        (*local_this).play((double)param1, (double)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "play() takes 1 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "play(const AnimInterface self)\n"
      "play(const AnimInterface self, double from, double to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_play_40_comment =
  "C++ Interface:\n"
  "play(const AnimInterface self)\n"
  "play(const AnimInterface self, double from, double to)\n"
  "\n"
  "/**\n"
  " * Runs the entire animation from beginning to end and stops.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Runs the animation from the frame \"from\" to and including the frame \"to\",\n"
  " * at which point the animation is stopped.  Both \"from\" and \"to\" frame\n"
  " * numbers may be outside the range (0, get_num_frames()) and the animation\n"
  " * will follow the range correctly, reporting numbers modulo get_num_frames().\n"
  " * For instance, play(0, get_num_frames() * 2) will play the animation twice\n"
  " * and then stop.\n"
  " */";
#else
static const char *Dtool_AnimInterface_play_40_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void AnimInterface::loop(bool restart)
 * inline void AnimInterface::loop(bool restart, double from, double to)
 */
static PyObject *Dtool_AnimInterface_loop_41(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimInterface, (void **)&local_this, "AnimInterface.loop")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "restart");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'restart' (pos 1) not found");
      }
      // 1-inline void AnimInterface::loop(bool restart)
      (*local_this).loop((PyObject_IsTrue(arg) != 0));
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void AnimInterface::loop(bool restart, double from, double to)
      PyObject *param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"restart", "from", "to", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Odd:loop", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).loop((PyObject_IsTrue(param1) != 0), (double)param2, (double)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "loop() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "loop(const AnimInterface self, bool restart)\n"
      "loop(const AnimInterface self, bool restart, double from, double to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_loop_41_comment =
  "C++ Interface:\n"
  "loop(const AnimInterface self, bool restart)\n"
  "loop(const AnimInterface self, bool restart, double from, double to)\n"
  "\n"
  "/**\n"
  " * Starts the entire animation looping.  If restart is true, the animation is\n"
  " * restarted from the beginning; otherwise, it continues from the current\n"
  " * frame.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Loops the animation from the frame \"from\" to and including the frame \"to\",\n"
  " * indefinitely.  If restart is true, the animation is restarted from the\n"
  " * beginning; otherwise, it continues from the current frame.\n"
  " */";
#else
static const char *Dtool_AnimInterface_loop_41_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void AnimInterface::pingpong(bool restart)
 * inline void AnimInterface::pingpong(bool restart, double from, double to)
 */
static PyObject *Dtool_AnimInterface_pingpong_42(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimInterface, (void **)&local_this, "AnimInterface.pingpong")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "restart");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'restart' (pos 1) not found");
      }
      // 1-inline void AnimInterface::pingpong(bool restart)
      (*local_this).pingpong((PyObject_IsTrue(arg) != 0));
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void AnimInterface::pingpong(bool restart, double from, double to)
      PyObject *param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"restart", "from", "to", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Odd:pingpong", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).pingpong((PyObject_IsTrue(param1) != 0), (double)param2, (double)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "pingpong() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pingpong(const AnimInterface self, bool restart)\n"
      "pingpong(const AnimInterface self, bool restart, double from, double to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_pingpong_42_comment =
  "C++ Interface:\n"
  "pingpong(const AnimInterface self, bool restart)\n"
  "pingpong(const AnimInterface self, bool restart, double from, double to)\n"
  "\n"
  "/**\n"
  " * Starts the entire animation bouncing back and forth between its first frame\n"
  " * and last frame.  If restart is true, the animation is restarted from the\n"
  " * beginning; otherwise, it continues from the current frame.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Loops the animation from the frame \"from\" to and including the frame \"to\",\n"
  " * and then back in the opposite direction, indefinitely.\n"
  " */";
#else
static const char *Dtool_AnimInterface_pingpong_42_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void AnimInterface::stop(void)
 */
static PyObject *Dtool_AnimInterface_stop_43(PyObject *self, PyObject *) {
  AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimInterface, (void **)&local_this, "AnimInterface.stop")) {
    return NULL;
  }
  // 1-inline void AnimInterface::stop(void)
  (*local_this).stop();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_stop_43_comment =
  "C++ Interface:\n"
  "stop(const AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Stops a currently playing or looping animation right where it is.  The\n"
  " * animation remains posed at the current frame.\n"
  " */";
#else
static const char *Dtool_AnimInterface_stop_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void AnimInterface::pose(double frame)
 */
static PyObject *Dtool_AnimInterface_pose_44(PyObject *self, PyObject *arg) {
  AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimInterface, (void **)&local_this, "AnimInterface.pose")) {
    return NULL;
  }
  // 1-inline void AnimInterface::pose(double frame)
  if (PyNumber_Check(arg)) {
    (*local_this).pose(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pose(const AnimInterface self, double frame)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_pose_44_comment =
  "C++ Interface:\n"
  "pose(const AnimInterface self, double frame)\n"
  "\n"
  "/**\n"
  " * Sets the animation to the indicated frame and holds it there.\n"
  " */";
#else
static const char *Dtool_AnimInterface_pose_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void AnimInterface::set_play_rate(double play_rate)
 */
static PyObject *Dtool_AnimInterface_set_play_rate_45(PyObject *self, PyObject *arg) {
  AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimInterface, (void **)&local_this, "AnimInterface.set_play_rate")) {
    return NULL;
  }
  // 1-inline void AnimInterface::set_play_rate(double play_rate)
  if (PyNumber_Check(arg)) {
    (*local_this).set_play_rate(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_play_rate(const AnimInterface self, double play_rate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_set_play_rate_45_comment =
  "C++ Interface:\n"
  "set_play_rate(const AnimInterface self, double play_rate)\n"
  "\n"
  "/**\n"
  " * Changes the rate at which the animation plays.  1.0 is the normal speed,\n"
  " * 2.0 is twice normal speed, and 0.5 is half normal speed.  0.0 is legal to\n"
  " * pause the animation, and a negative value will play the animation\n"
  " * backwards.\n"
  " */";
#else
static const char *Dtool_AnimInterface_set_play_rate_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double AnimInterface::get_play_rate(void) const
 */
static PyObject *Dtool_AnimInterface_get_play_rate_46(PyObject *self, PyObject *) {
  AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double AnimInterface::get_play_rate(void) const
  double return_value = (*(const AnimInterface*)local_this).get_play_rate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_get_play_rate_46_comment =
  "C++ Interface:\n"
  "get_play_rate(AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the rate at which the animation plays.  See set_play_rate().\n"
  " */";
#else
static const char *Dtool_AnimInterface_get_play_rate_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double AnimInterface::get_frame_rate(void) const
 */
static PyObject *Dtool_AnimInterface_get_frame_rate_47(PyObject *self, PyObject *) {
  AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double AnimInterface::get_frame_rate(void) const
  double return_value = (*(const AnimInterface*)local_this).get_frame_rate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_get_frame_rate_47_comment =
  "C++ Interface:\n"
  "get_frame_rate(AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the native frame rate of the animation.  This is the number of\n"
  " * frames per second that will elapse when the play_rate is set to 1.0.  It is\n"
  " * a fixed property of the animation and may not be adjusted by the user.\n"
  " */";
#else
static const char *Dtool_AnimInterface_get_frame_rate_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual int AnimInterface::get_num_frames(void) const
 */
static PyObject *Dtool_AnimInterface_get_num_frames_48(PyObject *self, PyObject *) {
  AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual int AnimInterface::get_num_frames(void) const
  int return_value = (*(const AnimInterface*)local_this).get_num_frames();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_get_num_frames_48_comment =
  "C++ Interface:\n"
  "get_num_frames(AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the number of frames in the animation.  This is a property of the\n"
  " * animation and may not be directly adjusted by the user (although it may\n"
  " * change without warning with certain kinds of animations, since this is a\n"
  " * virtual method that may be overridden).\n"
  " */";
#else
static const char *Dtool_AnimInterface_get_num_frames_48_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int AnimInterface::get_frame(void) const
 */
static PyObject *Dtool_AnimInterface_get_frame_49(PyObject *self, PyObject *) {
  AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int AnimInterface::get_frame(void) const
  int return_value = (*(const AnimInterface*)local_this).get_frame();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_get_frame_49_comment =
  "C++ Interface:\n"
  "get_frame(AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the current integer frame number.  This number will be in the range\n"
  " * 0 <= f < get_num_frames().\n"
  " */";
#else
static const char *Dtool_AnimInterface_get_frame_49_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int AnimInterface::get_next_frame(void) const
 */
static PyObject *Dtool_AnimInterface_get_next_frame_50(PyObject *self, PyObject *) {
  AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int AnimInterface::get_next_frame(void) const
  int return_value = (*(const AnimInterface*)local_this).get_next_frame();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_get_next_frame_50_comment =
  "C++ Interface:\n"
  "get_next_frame(AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the current integer frame number + 1, constrained to the range 0 <=\n"
  " * f < get_num_frames().\n"
  " *\n"
  " * If the play mode is PM_play, this will clamp to the same value as\n"
  " * get_frame() at the end of the animation.  If the play mode is any other\n"
  " * value, this will wrap around to frame 0 at the end of the animation.\n"
  " */";
#else
static const char *Dtool_AnimInterface_get_next_frame_50_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double AnimInterface::get_frac(void) const
 */
static PyObject *Dtool_AnimInterface_get_frac_51(PyObject *self, PyObject *) {
  AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double AnimInterface::get_frac(void) const
  double return_value = (*(const AnimInterface*)local_this).get_frac();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_get_frac_51_comment =
  "C++ Interface:\n"
  "get_frac(AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the fractional part of the current frame.  Normally, this is in the\n"
  " * range 0.0 <= f < 1.0, but in the one special case of an animation playing\n"
  " * to its end frame and stopping, it might exactly equal 1.0.\n"
  " *\n"
  " * It will always be true that get_full_frame() + get_frac() ==\n"
  " * get_full_fframe().\n"
  " */";
#else
static const char *Dtool_AnimInterface_get_frac_51_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int AnimInterface::get_full_frame(void) const
 */
static PyObject *Dtool_AnimInterface_get_full_frame_52(PyObject *self, PyObject *) {
  AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int AnimInterface::get_full_frame(void) const
  int return_value = (*(const AnimInterface*)local_this).get_full_frame();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_get_full_frame_52_comment =
  "C++ Interface:\n"
  "get_full_frame(AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the current integer frame number.\n"
  " *\n"
  " * Unlike the value returned by get_frame(), this frame number may extend\n"
  " * beyond the range of get_num_frames() if the frame range passed to play(),\n"
  " * loop(), etc.  did.\n"
  " *\n"
  " * Unlike the value returned by get_full_fframe(), this return value will\n"
  " * never exceed the value passed to to_frame in the play() method.\n"
  " */";
#else
static const char *Dtool_AnimInterface_get_full_frame_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double AnimInterface::get_full_fframe(void) const
 */
static PyObject *Dtool_AnimInterface_get_full_fframe_53(PyObject *self, PyObject *) {
  AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double AnimInterface::get_full_fframe(void) const
  double return_value = (*(const AnimInterface*)local_this).get_full_fframe();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_get_full_fframe_53_comment =
  "C++ Interface:\n"
  "get_full_fframe(AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the current floating-point frame number.\n"
  " *\n"
  " * Unlike the value returned by get_frame(), this frame number may extend\n"
  " * beyond the range of get_num_frames() if the frame range passed to play(),\n"
  " * loop(), etc.  did.\n"
  " *\n"
  " * Unlike the value returned by get_full_frame(), this return value may equal\n"
  " * (to_frame + 1.0), when the animation has played to its natural end.\n"
  " * However, in this case the return value of get_full_frame() will be\n"
  " * to_frame, not (to_frame + 1).\n"
  " */";
#else
static const char *Dtool_AnimInterface_get_full_fframe_53_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool AnimInterface::is_playing(void) const
 */
static PyObject *Dtool_AnimInterface_is_playing_54(PyObject *self, PyObject *) {
  AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool AnimInterface::is_playing(void) const
  bool return_value = (*(const AnimInterface*)local_this).is_playing();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_is_playing_54_comment =
  "C++ Interface:\n"
  "is_playing(AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Returns true if the animation is currently playing, false if it is stopped\n"
  " * (e.g.  because stop() or pose() was called, or because it reached the end\n"
  " * of the animation after play() was called).\n"
  " */";
#else
static const char *Dtool_AnimInterface_is_playing_54_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimInterface::output(ostream &out) const
 */
static PyObject *Dtool_AnimInterface_output_55(PyObject *self, PyObject *arg) {
  AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void AnimInterface::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "AnimInterface.output", false, true);
  if (arg_this != NULL) {
    (*(const AnimInterface*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AnimInterface self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_output_55_comment =
  "C++ Interface:\n"
  "output(AnimInterface self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AnimInterface_output_55_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimInterface::get_class_type(void)
 */
static PyObject *Dtool_AnimInterface_get_class_type_68(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimInterface::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AnimInterface::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_get_class_type_68_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimInterface_get_class_type_68_comment = NULL;
#endif

static PyObject *Dtool_AnimInterface_play_rate_Getter(PyObject *self, void *) {
  const AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double AnimInterface::get_play_rate(void) const
  double return_value = (*(const AnimInterface*)local_this).get_play_rate();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_AnimInterface_play_rate_Setter(PyObject *self, PyObject *arg, void *) {
  AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimInterface, (void **)&local_this, "AnimInterface.play_rate")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete play_rate attribute");
    return -1;
  }
  // 1-inline void AnimInterface::set_play_rate(double play_rate)
  if (PyNumber_Check(arg)) {
    (*local_this).set_play_rate(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_play_rate(const AnimInterface self, double play_rate)\n");
  }
  return -1;
}

static PyObject *Dtool_AnimInterface_frame_rate_Getter(PyObject *self, void *) {
  const AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double AnimInterface::get_frame_rate(void) const
  double return_value = (*(const AnimInterface*)local_this).get_frame_rate();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AnimInterface_num_frames_Getter(PyObject *self, void *) {
  const AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }

  // 1-virtual int AnimInterface::get_num_frames(void) const
  int return_value = (*(const AnimInterface*)local_this).get_num_frames();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AnimInterface_frame_Getter(PyObject *self, void *) {
  const AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int AnimInterface::get_frame(void) const
  int return_value = (*(const AnimInterface*)local_this).get_frame();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AnimInterface_next_frame_Getter(PyObject *self, void *) {
  const AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int AnimInterface::get_next_frame(void) const
  int return_value = (*(const AnimInterface*)local_this).get_next_frame();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AnimInterface_frac_Getter(PyObject *self, void *) {
  const AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double AnimInterface::get_frac(void) const
  double return_value = (*(const AnimInterface*)local_this).get_frac();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AnimInterface_full_frame_Getter(PyObject *self, void *) {
  const AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int AnimInterface::get_full_frame(void) const
  int return_value = (*(const AnimInterface*)local_this).get_full_frame();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AnimInterface_full_fframe_Getter(PyObject *self, void *) {
  const AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double AnimInterface::get_full_fframe(void) const
  double return_value = (*(const AnimInterface*)local_this).get_full_fframe();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AnimInterface_playing_Getter(PyObject *self, void *) {
  const AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool AnimInterface::is_playing(void) const
  bool return_value = (*(const AnimInterface*)local_this).is_playing();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_AnimInterface(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AnimInterface(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AnimInterface) {
    printf("AnimInterface ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AnimInterface *local_this = (AnimInterface *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AnimInterface) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AnimInterface(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AnimInterface) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class UpdateSeq
 */
/**
 * Python function wrapper for:
 * static inline UpdateSeq UpdateSeq::initial(void)
 */
static PyObject *Dtool_UpdateSeq_initial_72(PyObject *, PyObject *) {
  // 1-static inline UpdateSeq UpdateSeq::initial(void)
  UpdateSeq *return_value = new UpdateSeq(UpdateSeq::initial());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_initial_72_comment =
  "C++ Interface:\n"
  "initial()\n"
  "\n"
  "/**\n"
  " * Returns an UpdateSeq in the 'initial' state.\n"
  " */";
#else
static const char *Dtool_UpdateSeq_initial_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline UpdateSeq UpdateSeq::old(void)
 */
static PyObject *Dtool_UpdateSeq_old_73(PyObject *, PyObject *) {
  // 1-static inline UpdateSeq UpdateSeq::old(void)
  UpdateSeq *return_value = new UpdateSeq(UpdateSeq::old());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_old_73_comment =
  "C++ Interface:\n"
  "old()\n"
  "\n"
  "/**\n"
  " * Returns an UpdateSeq in the 'old' state.\n"
  " */";
#else
static const char *Dtool_UpdateSeq_old_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline UpdateSeq UpdateSeq::fresh(void)
 */
static PyObject *Dtool_UpdateSeq_fresh_74(PyObject *, PyObject *) {
  // 1-static inline UpdateSeq UpdateSeq::fresh(void)
  UpdateSeq *return_value = new UpdateSeq(UpdateSeq::fresh());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_fresh_74_comment =
  "C++ Interface:\n"
  "fresh()\n"
  "\n"
  "/**\n"
  " * Returns an UpdateSeq in the 'fresh' state.\n"
  " */";
#else
static const char *Dtool_UpdateSeq_fresh_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq &UpdateSeq::operator =(UpdateSeq const &copy)
 */
static PyObject *Dtool_UpdateSeq_operator_75(PyObject *self, PyObject *arg) {
  UpdateSeq *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UpdateSeq, (void **)&local_this, "UpdateSeq.assign")) {
    return NULL;
  }
  // 1-inline UpdateSeq &UpdateSeq::operator =(UpdateSeq const &copy)
  UpdateSeq const *arg_this = (UpdateSeq *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_UpdateSeq, 1, "UpdateSeq.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    UpdateSeq *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const UpdateSeq self, const UpdateSeq copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_operator_75_comment =
  "C++ Interface:\n"
  "assign(const UpdateSeq self, const UpdateSeq copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UpdateSeq_operator_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void UpdateSeq::clear(void)
 */
static PyObject *Dtool_UpdateSeq_clear_76(PyObject *self, PyObject *) {
  UpdateSeq *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UpdateSeq, (void **)&local_this, "UpdateSeq.clear")) {
    return NULL;
  }
  // 1-inline void UpdateSeq::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_clear_76_comment =
  "C++ Interface:\n"
  "clear(const UpdateSeq self)\n"
  "\n"
  "/**\n"
  " * Resets the UpdateSeq to the 'initial' state.\n"
  " */";
#else
static const char *Dtool_UpdateSeq_clear_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool UpdateSeq::is_initial(void) const
 */
static PyObject *Dtool_UpdateSeq_is_initial_77(PyObject *self, PyObject *) {
  UpdateSeq *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UpdateSeq, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool UpdateSeq::is_initial(void) const
  bool return_value = (*(const UpdateSeq*)local_this).is_initial();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_is_initial_77_comment =
  "C++ Interface:\n"
  "is_initial(UpdateSeq self)\n"
  "\n"
  "/**\n"
  " * Returns true if the UpdateSeq is in the 'initial' state.\n"
  " */";
#else
static const char *Dtool_UpdateSeq_is_initial_77_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool UpdateSeq::is_old(void) const
 */
static PyObject *Dtool_UpdateSeq_is_old_78(PyObject *self, PyObject *) {
  UpdateSeq *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UpdateSeq, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool UpdateSeq::is_old(void) const
  bool return_value = (*(const UpdateSeq*)local_this).is_old();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_is_old_78_comment =
  "C++ Interface:\n"
  "is_old(UpdateSeq self)\n"
  "\n"
  "/**\n"
  " * Returns true if the UpdateSeq is in the 'old' state.\n"
  " */";
#else
static const char *Dtool_UpdateSeq_is_old_78_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool UpdateSeq::is_fresh(void) const
 */
static PyObject *Dtool_UpdateSeq_is_fresh_79(PyObject *self, PyObject *) {
  UpdateSeq *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UpdateSeq, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool UpdateSeq::is_fresh(void) const
  bool return_value = (*(const UpdateSeq*)local_this).is_fresh();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_is_fresh_79_comment =
  "C++ Interface:\n"
  "is_fresh(UpdateSeq self)\n"
  "\n"
  "/**\n"
  " * Returns true if the UpdateSeq is in the 'fresh' state.\n"
  " */";
#else
static const char *Dtool_UpdateSeq_is_fresh_79_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool UpdateSeq::is_special(void) const
 */
static PyObject *Dtool_UpdateSeq_is_special_80(PyObject *self, PyObject *) {
  UpdateSeq *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UpdateSeq, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool UpdateSeq::is_special(void) const
  bool return_value = (*(const UpdateSeq*)local_this).is_special();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_is_special_80_comment =
  "C++ Interface:\n"
  "is_special(UpdateSeq self)\n"
  "\n"
  "/**\n"
  " * Returns true if the UpdateSeq is in any special states, i.e.  'initial',\n"
  " * 'old', or 'fresh'.\n"
  " */";
#else
static const char *Dtool_UpdateSeq_is_special_80_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq UpdateSeq::operator ++(void)
 */
static PyObject *Dtool_UpdateSeq_operator_87(PyObject *self, PyObject *) {
  UpdateSeq *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UpdateSeq, (void **)&local_this, "UpdateSeq.increment")) {
    return NULL;
  }
  // 1-inline UpdateSeq UpdateSeq::operator ++(void)
  UpdateSeq *return_value = new UpdateSeq((*local_this).operator ++());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_operator_87_comment =
  "C++ Interface:\n"
  "increment(const UpdateSeq self)\n";
#else
static const char *Dtool_UpdateSeq_operator_87_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq UpdateSeq::operator ++(int )
 */
static PyObject *Dtool_UpdateSeq_operator_88(PyObject *self, PyObject *arg) {
  UpdateSeq *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UpdateSeq, (void **)&local_this, "UpdateSeq.increment")) {
    return NULL;
  }
  // 1-inline UpdateSeq UpdateSeq::operator ++(int )
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    UpdateSeq *return_value = new UpdateSeq((*local_this).operator ++((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "increment(const UpdateSeq self, int param0)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_operator_88_comment =
  "C++ Interface:\n"
  "increment(const UpdateSeq self, int param0)\n";
#else
static const char *Dtool_UpdateSeq_operator_88_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline AtomicAdjust::Integer UpdateSeq::get_seq(void) const
 */
static PyObject *Dtool_UpdateSeq_get_seq_89(PyObject *self, PyObject *) {
  UpdateSeq *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UpdateSeq, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline AtomicAdjust::Integer UpdateSeq::get_seq(void) const
  AtomicAdjust::Integer return_value = (*(const UpdateSeq*)local_this).get_seq();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_get_seq_89_comment =
  "C++ Interface:\n"
  "get_seq(UpdateSeq self)\n"
  "\n"
  "/**\n"
  " * Returns the internal integer value associated with the UpdateSeq.  Useful\n"
  " * for debugging only.\n"
  " */";
#else
static const char *Dtool_UpdateSeq_get_seq_89_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void UpdateSeq::output(ostream &out) const
 */
static PyObject *Dtool_UpdateSeq_output_94(PyObject *self, PyObject *arg) {
  UpdateSeq *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UpdateSeq, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void UpdateSeq::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "UpdateSeq.output", false, true);
  if (arg_this != NULL) {
    (*(const UpdateSeq*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(UpdateSeq self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_output_94_comment =
  "C++ Interface:\n"
  "output(UpdateSeq self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UpdateSeq_output_94_comment = NULL;
#endif

static PyObject *Dtool_UpdateSeq_seq_Getter(PyObject *self, void *) {
  const UpdateSeq *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UpdateSeq, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline AtomicAdjust::Integer UpdateSeq::get_seq(void) const
  AtomicAdjust::Integer return_value = (*(const UpdateSeq*)local_this).get_seq();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline UpdateSeq::UpdateSeq(void)
 * inline UpdateSeq::UpdateSeq(UpdateSeq const &copy)
 */
static int Dtool_Init_UpdateSeq(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline UpdateSeq::UpdateSeq(void)
      UpdateSeq *return_value = new UpdateSeq();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UpdateSeq, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-inline UpdateSeq::UpdateSeq(UpdateSeq const &copy)
      UpdateSeq const *arg_this = (UpdateSeq *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_UpdateSeq, 0, "UpdateSeq.UpdateSeq", true, true);
      if (arg_this != NULL) {
        UpdateSeq *return_value = new UpdateSeq(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UpdateSeq, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "UpdateSeq() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UpdateSeq()\n"
      "UpdateSeq(const UpdateSeq copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_UpdateSeq(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_UpdateSeq) {
    printf("UpdateSeq ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  UpdateSeq *local_this = (UpdateSeq *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_UpdateSeq) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_UpdateSeq(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_UpdateSeq) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class TypedWritable
 */
/**
 * Python function wrapper for:
 * virtual void TypedWritable::fillin(DatagramIterator &scan, BamReader *manager)
 */
static PyObject *Dtool_TypedWritable_fillin_98(PyObject *self, PyObject *args, PyObject *kwds) {
  TypedWritable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypedWritable, (void **)&local_this, "TypedWritable.fillin")) {
    return NULL;
  }
  // 1-virtual void TypedWritable::fillin(DatagramIterator &scan, BamReader *manager)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"scan", "manager", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:fillin", (char **)keyword_list, &param1, &param2)) {
    DatagramIterator param1_local;
    DatagramIterator *param1_this = Dtool_Coerce_DatagramIterator(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypedWritable.fillin", "DatagramIterator");
    }
    BamReader *param2_this;
    bool param2_manage = false;
    if (!Dtool_Coerce_BamReader(param2, param2_this, param2_manage)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TypedWritable.fillin", "BamReader");
    }
    (*local_this).fillin(*param1_this, param2_this);
    if (param2_manage) {
      delete param2_this;
    }
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fillin(const TypedWritable self, DatagramIterator scan, BamReader manager)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypedWritable_fillin_98_comment =
  "C++ Interface:\n"
  "fillin(const TypedWritable self, DatagramIterator scan, BamReader manager)\n"
  "\n"
  "/**\n"
  " * This internal function is intended to be called by each class's\n"
  " * make_from_bam() method to read in all of the relevant data from the BamFile\n"
  " * for the new object.  It is also called directly by the BamReader to re-read\n"
  " * the data for an object that has been placed on the stream for an update.\n"
  " */";
#else
static const char *Dtool_TypedWritable_fillin_98_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TypedWritable::mark_bam_modified(void)
 */
static PyObject *Dtool_TypedWritable_mark_bam_modified_99(PyObject *self, PyObject *) {
  TypedWritable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypedWritable, (void **)&local_this, "TypedWritable.mark_bam_modified")) {
    return NULL;
  }
  // 1-inline void TypedWritable::mark_bam_modified(void)
  (*local_this).mark_bam_modified();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TypedWritable_mark_bam_modified_99_comment =
  "C++ Interface:\n"
  "mark_bam_modified(const TypedWritable self)\n"
  "\n"
  "/**\n"
  " * Increments the bam_modified counter, so that this object will be\n"
  " * invalidated and retransmitted on any open bam streams.  This should\n"
  " * normally not need to be called by user code; it should be called internally\n"
  " * when the object has been changed in a way that legitimately requires its\n"
  " * retransmission to any connected clients.\n"
  " */";
#else
static const char *Dtool_TypedWritable_mark_bam_modified_99_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq TypedWritable::get_bam_modified(void) const
 */
static PyObject *Dtool_TypedWritable_get_bam_modified_100(PyObject *self, PyObject *) {
  TypedWritable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypedWritable, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline UpdateSeq TypedWritable::get_bam_modified(void) const
  UpdateSeq *return_value = new UpdateSeq((*(const TypedWritable*)local_this).get_bam_modified());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TypedWritable_get_bam_modified_100_comment =
  "C++ Interface:\n"
  "get_bam_modified(TypedWritable self)\n"
  "\n"
  "/**\n"
  " * Returns the current bam_modified counter.  This counter is normally\n"
  " * incremented automatically whenever the object is modified.\n"
  " */";
#else
static const char *Dtool_TypedWritable_get_bam_modified_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *TypedWritable::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_TypedWritable_reduce_101(PyObject *self, PyObject *) {
  TypedWritable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypedWritable, (void **)&local_this)) {
    return NULL;
  }
  // 1-PyObject *TypedWritable::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const TypedWritable*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TypedWritable_reduce_101_comment =
  "C++ Interface:\n"
  "__reduce__(TypedWritable self)\n";
#else
static const char *Dtool_TypedWritable_reduce_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *TypedWritable::__reduce_persist__(PyObject *self, PyObject *pickler) const
 */
static PyObject *Dtool_TypedWritable_reduce_persist_102(PyObject *self, PyObject *arg) {
  TypedWritable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypedWritable, (void **)&local_this)) {
    return NULL;
  }
  // 1-PyObject *TypedWritable::__reduce_persist__(PyObject *self, PyObject *pickler) const
  PyObject *return_value = invoke_extension((const TypedWritable*)local_this).__reduce_persist__(self, arg);
  return Dtool_Return(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__reduce_persist__(TypedWritable self, object pickler)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypedWritable_reduce_persist_102_comment =
  "C++ Interface:\n"
  "__reduce_persist__(TypedWritable self, object pickler)\n";
#else
static const char *Dtool_TypedWritable_reduce_persist_102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string TypedWritable::encode_to_bam_stream(void) const
 */
static PyObject *Dtool_TypedWritable_encode_to_bam_stream_103(PyObject *self, PyObject *) {
  TypedWritable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypedWritable, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string TypedWritable::encode_to_bam_stream(void) const
  std::string return_value = (*(const TypedWritable*)local_this).encode_to_bam_stream();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TypedWritable_encode_to_bam_stream_103_comment =
  "C++ Interface:\n"
  "encode_to_bam_stream(TypedWritable self)\n"
  "\n"
  "/**\n"
  " * Converts the TypedWritable object into a single stream of data using a\n"
  " * BamWriter, and returns that data as a string string.  Returns empty string\n"
  " * on failure.\n"
  " *\n"
  " * This is a convenience method particularly useful for cases when you are\n"
  " * only serializing a single object.  If you have many objects to process, it\n"
  " * is more efficient to use the same BamWriter to serialize all of them\n"
  " * together.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Converts the TypedWritable object into a single stream of data using a\n"
  " * BamWriter, and stores that data in the indicated string.  Returns true on\n"
  " * success, false on failure.\n"
  " *\n"
  " * This is a convenience method particularly useful for cases when you are\n"
  " * only serializing a single object.  If you have many objects to process, it\n"
  " * is more efficient to use the same BamWriter to serialize all of them\n"
  " * together.\n"
  " */";
#else
static const char *Dtool_TypedWritable_encode_to_bam_stream_103_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TypedWritable::get_class_type(void)
 */
static PyObject *Dtool_TypedWritable_get_class_type_105(PyObject *, PyObject *) {
  // 1-static TypeHandle TypedWritable::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(TypedWritable::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TypedWritable_get_class_type_105_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TypedWritable_get_class_type_105_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypedWritableReferenceCount *TypedWritable::downcast_to_TypedWritableReferenceCount(void)
 */
static PyObject *Dtool_TypedWritable_downcast_to_TypedWritableReferenceCount_108(PyObject *self, PyObject *) {
  TypedWritable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypedWritable, (void **)&local_this, "TypedWritable.downcast_to_TypedWritableReferenceCount")) {
    return NULL;
  }
  // 1-TypedWritableReferenceCount *TypedWritable::downcast_to_TypedWritableReferenceCount(void)
  TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TypedWritable_downcast_to_TypedWritableReferenceCount_108_comment =
  "C++ Interface:\n"
  "downcast_to_TypedWritableReferenceCount(const TypedWritable self)\n"
  "\n"
  "downcast from TypedWritable to TypedWritableReferenceCount";
#else
static const char *Dtool_TypedWritable_downcast_to_TypedWritableReferenceCount_108_comment = NULL;
#endif

static int Dtool_Init_TypedWritable(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TypedWritable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TypedWritable) {
    printf("TypedWritable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TypedWritable *local_this = (TypedWritable *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TypedWritable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TypedWritable*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class TypedWritableReferenceCount
 */
/**
 * Python function wrapper for:
 * static PointerTo< TypedWritableReferenceCount > TypedWritableReferenceCount::decode_from_bam_stream(std::string const &data, BamReader *reader = 0)
 */
static PyObject *Dtool_TypedWritableReferenceCount_decode_from_bam_stream_112(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< TypedWritableReferenceCount > TypedWritableReferenceCount::decode_from_bam_stream(std::string const &data, BamReader *reader = 0)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  PyObject *param1 = NULL;
  static const char *keyword_list[] = {"data", "reader", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|O:decode_from_bam_stream", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    BamReader *param1_this = 0;
    bool param1_manage = false;
    if (param1 != NULL && !Dtool_Coerce_BamReader(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypedWritableReferenceCount.decode_from_bam_stream", "BamReader");
    }
    PointerTo< TypedWritableReferenceCount > return_value = TypedWritableReferenceCount::decode_from_bam_stream(std::string(param0_str, param0_len), param1_this);
    if (param1_manage) {
      delete param1_this;
    }
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    TypedWritableReferenceCount *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decode_from_bam_stream(str data, BamReader reader)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypedWritableReferenceCount_decode_from_bam_stream_112_comment =
  "C++ Interface:\n"
  "decode_from_bam_stream(str data, BamReader reader)\n"
  "\n"
  "/**\n"
  " * Reads the string created by a previous call to encode_to_bam_stream(), and\n"
  " * extracts and returns the single object on that string.  Returns NULL on\n"
  " * error.\n"
  " *\n"
  " * This method is intended to replace decode_raw_from_bam_stream() when you\n"
  " * know the stream in question returns an object of type\n"
  " * TypedWritableReferenceCount, allowing for easier reference count\n"
  " * management.  Note that the caller is still responsible for maintaining the\n"
  " * reference count on the return value.\n"
  " */";
#else
static const char *Dtool_TypedWritableReferenceCount_decode_from_bam_stream_112_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TypedWritableReferenceCount::get_class_type(void)
 */
static PyObject *Dtool_TypedWritableReferenceCount_get_class_type_113(PyObject *, PyObject *) {
  // 1-static TypeHandle TypedWritableReferenceCount::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(TypedWritableReferenceCount::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TypedWritableReferenceCount_get_class_type_113_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TypedWritableReferenceCount_get_class_type_113_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypedWritable *TypedWritableReferenceCount::upcast_to_TypedWritable(void)
 */
static PyObject *Dtool_TypedWritableReferenceCount_upcast_to_TypedWritable_107(PyObject *self, PyObject *) {
  TypedWritableReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypedWritableReferenceCount, (void **)&local_this, "TypedWritableReferenceCount.upcast_to_TypedWritable")) {
    return NULL;
  }
  // 1-TypedWritable *TypedWritableReferenceCount::upcast_to_TypedWritable(void)
  TypedWritable *return_value = (TypedWritable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritable, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TypedWritableReferenceCount_upcast_to_TypedWritable_107_comment =
  "C++ Interface:\n"
  "upcast_to_TypedWritable(const TypedWritableReferenceCount self)\n"
  "\n"
  "upcast from TypedWritableReferenceCount to TypedWritable";
#else
static const char *Dtool_TypedWritableReferenceCount_upcast_to_TypedWritable_107_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ReferenceCount *TypedWritableReferenceCount::upcast_to_ReferenceCount(void)
 */
static PyObject *Dtool_TypedWritableReferenceCount_upcast_to_ReferenceCount_110(PyObject *self, PyObject *) {
  TypedWritableReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypedWritableReferenceCount, (void **)&local_this, "TypedWritableReferenceCount.upcast_to_ReferenceCount")) {
    return NULL;
  }
  // 1-ReferenceCount *TypedWritableReferenceCount::upcast_to_ReferenceCount(void)
  ReferenceCount *return_value = (ReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ReferenceCount, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TypedWritableReferenceCount_upcast_to_ReferenceCount_110_comment =
  "C++ Interface:\n"
  "upcast_to_ReferenceCount(const TypedWritableReferenceCount self)\n"
  "\n"
  "upcast from TypedWritableReferenceCount to ReferenceCount";
#else
static const char *Dtool_TypedWritableReferenceCount_upcast_to_ReferenceCount_110_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * BamCacheRecord *TypedWritableReferenceCount::downcast_to_BamCacheRecord(void)
 */
static PyObject *Dtool_TypedWritableReferenceCount_downcast_to_BamCacheRecord_117(PyObject *self, PyObject *) {
  TypedWritableReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypedWritableReferenceCount, (void **)&local_this, "TypedWritableReferenceCount.downcast_to_BamCacheRecord")) {
    return NULL;
  }
  // 1-BamCacheRecord *TypedWritableReferenceCount::downcast_to_BamCacheRecord(void)
  BamCacheRecord *return_value = (BamCacheRecord *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BamCacheRecord, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TypedWritableReferenceCount_downcast_to_BamCacheRecord_117_comment =
  "C++ Interface:\n"
  "downcast_to_BamCacheRecord(const TypedWritableReferenceCount self)\n"
  "\n"
  "downcast from TypedWritableReferenceCount to BamCacheRecord";
#else
static const char *Dtool_TypedWritableReferenceCount_downcast_to_BamCacheRecord_117_comment = NULL;
#endif

static int Dtool_Init_TypedWritableReferenceCount(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TypedWritableReferenceCount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TypedWritableReferenceCount) {
    printf("TypedWritableReferenceCount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TypedWritableReferenceCount *local_this = (TypedWritableReferenceCount *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TypedWritableReferenceCount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TypedWritableReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TypedWritableReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (TypedWritableReferenceCount*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BamCacheRecord
 */
/**
 * Python function wrapper for:
 * inline PointerTo< BamCacheRecord > BamCacheRecord::make_copy(void) const
 */
static PyObject *Dtool_BamCacheRecord_make_copy_122(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PointerTo< BamCacheRecord > BamCacheRecord::make_copy(void) const
  PointerTo< BamCacheRecord > return_value = (*(const BamCacheRecord*)local_this).make_copy();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  BamCacheRecord *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BamCacheRecord, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_make_copy_122_comment =
  "C++ Interface:\n"
  "make_copy(BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Returns a duplicate of the BamCacheRecord.  The duplicate will not have a\n"
  " * data pointer set, even though one may have been assigned to the original\n"
  " * via set_data().\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_make_copy_122_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &BamCacheRecord::get_source_pathname(void) const
 */
static PyObject *Dtool_BamCacheRecord_get_source_pathname_124(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename const &BamCacheRecord::get_source_pathname(void) const
  Filename const *return_value = &((*(const BamCacheRecord*)local_this).get_source_pathname());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_get_source_pathname_124_comment =
  "C++ Interface:\n"
  "get_source_pathname(BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Returns the full pathname to the source file that originally generated this\n"
  " * cache request.  In some cases, for instance in the case of a of a multipage\n"
  " * texture like \"cube_#.png\", this may not not a true filename on disk.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_get_source_pathname_124_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &BamCacheRecord::get_cache_filename(void) const
 */
static PyObject *Dtool_BamCacheRecord_get_cache_filename_125(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename const &BamCacheRecord::get_cache_filename(void) const
  Filename const *return_value = &((*(const BamCacheRecord*)local_this).get_cache_filename());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_get_cache_filename_125_comment =
  "C++ Interface:\n"
  "get_cache_filename(BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the cache file as hashed from the source_pathname.\n"
  " * This will be relative to the root of the cache directory, and it will not\n"
  " * include any suffixes that may be appended to resolve hash conflicts.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_get_cache_filename_125_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline time_t BamCacheRecord::get_source_timestamp(void) const
 */
static PyObject *Dtool_BamCacheRecord_get_source_timestamp_126(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline time_t BamCacheRecord::get_source_timestamp(void) const
  time_t return_value = (*(const BamCacheRecord*)local_this).get_source_timestamp();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_get_source_timestamp_126_comment =
  "C++ Interface:\n"
  "get_source_timestamp(BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Returns the file timestamp of the original source file that generated this\n"
  " * cache record, if available.  In some cases the original file timestamp is\n"
  " * not available, and this will return 0.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_get_source_timestamp_126_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline time_t BamCacheRecord::get_recorded_time(void) const
 */
static PyObject *Dtool_BamCacheRecord_get_recorded_time_127(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline time_t BamCacheRecord::get_recorded_time(void) const
  time_t return_value = (*(const BamCacheRecord*)local_this).get_recorded_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_get_recorded_time_127_comment =
  "C++ Interface:\n"
  "get_recorded_time(BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Returns the time at which this particular record was recorded or updated.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_get_recorded_time_127_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BamCacheRecord::get_num_dependent_files(void) const
 */
static PyObject *Dtool_BamCacheRecord_get_num_dependent_files_135(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BamCacheRecord::get_num_dependent_files(void) const
  int return_value = (*(const BamCacheRecord*)local_this).get_num_dependent_files();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_get_num_dependent_files_135_comment =
  "C++ Interface:\n"
  "get_num_dependent_files(BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Returns the number of source files that contribute to the cache.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_get_num_dependent_files_135_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &BamCacheRecord::get_dependent_pathname(int n) const
 */
static PyObject *Dtool_BamCacheRecord_get_dependent_pathname_136(PyObject *self, PyObject *arg) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename const &BamCacheRecord::get_dependent_pathname(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    Filename const *return_value = &((*(const BamCacheRecord*)local_this).get_dependent_pathname((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_dependent_pathname(BamCacheRecord self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_get_dependent_pathname_136_comment =
  "C++ Interface:\n"
  "get_dependent_pathname(BamCacheRecord self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the full pathname of the nth source files that contributes to the\n"
  " * cache.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_get_dependent_pathname_136_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool BamCacheRecord::dependents_unchanged(void) const
 */
static PyObject *Dtool_BamCacheRecord_dependents_unchanged_137(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool BamCacheRecord::dependents_unchanged(void) const
  bool return_value = (*(const BamCacheRecord*)local_this).dependents_unchanged();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_dependents_unchanged_137_comment =
  "C++ Interface:\n"
  "dependents_unchanged(BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Returns true if all of the dependent files are still the same as when the\n"
  " * cache was recorded, false otherwise.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_dependents_unchanged_137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BamCacheRecord::clear_dependent_files(void)
 */
static PyObject *Dtool_BamCacheRecord_clear_dependent_files_138(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCacheRecord, (void **)&local_this, "BamCacheRecord.clear_dependent_files")) {
    return NULL;
  }
  // 1-void BamCacheRecord::clear_dependent_files(void)
  (*local_this).clear_dependent_files();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_clear_dependent_files_138_comment =
  "C++ Interface:\n"
  "clear_dependent_files(const BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Empties the list of files that contribute to the data in this record.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_clear_dependent_files_138_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BamCacheRecord::add_dependent_file(Filename const &pathname)
 * void BamCacheRecord::add_dependent_file(VirtualFile const *file)
 */
static PyObject *Dtool_BamCacheRecord_add_dependent_file_139(PyObject *self, PyObject *arg) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCacheRecord, (void **)&local_this, "BamCacheRecord.add_dependent_file")) {
    return NULL;
  }
  {
    // -2 void BamCacheRecord::add_dependent_file(Filename const &pathname)
    Filename const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Filename, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).add_dependent_file(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void BamCacheRecord::add_dependent_file(VirtualFile const *file)
    VirtualFile const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_VirtualFile, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).add_dependent_file(arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void BamCacheRecord::add_dependent_file(Filename const &pathname)
    Filename arg_local;
    Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).add_dependent_file(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: void BamCacheRecord::add_dependent_file(VirtualFile const *file)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_dependent_file(const BamCacheRecord self, const Filename pathname)\n"
      "add_dependent_file(const BamCacheRecord self, const VirtualFile file)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_add_dependent_file_139_comment =
  "C++ Interface:\n"
  "add_dependent_file(const BamCacheRecord self, const Filename pathname)\n"
  "add_dependent_file(const BamCacheRecord self, const VirtualFile file)\n"
  "\n"
  "/**\n"
  " * Adds the indicated file to the list of files that will be loaded to\n"
  " * generate the data in this record.  This should be called once for the\n"
  " * primary source file, and again for each secondary source file, if any.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Variant of add_dependent_file that takes an already opened VirtualFile.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_add_dependent_file_139_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BamCacheRecord::has_data(void) const
 */
static PyObject *Dtool_BamCacheRecord_has_data_140(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BamCacheRecord::has_data(void) const
  bool return_value = (*(const BamCacheRecord*)local_this).has_data();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_has_data_140_comment =
  "C++ Interface:\n"
  "has_data(BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Returns true if this cache record has an in-memory data object associated--\n"
  " * that is, the object stored in the cache.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_has_data_140_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BamCacheRecord::clear_data(void)
 */
static PyObject *Dtool_BamCacheRecord_clear_data_141(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCacheRecord, (void **)&local_this, "BamCacheRecord.clear_data")) {
    return NULL;
  }
  // 1-inline void BamCacheRecord::clear_data(void)
  (*local_this).clear_data();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_clear_data_141_comment =
  "C++ Interface:\n"
  "clear_data(const BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Removes the in-memory data object associated with this record, if any.\n"
  " * This does not affect the on-disk representation of the record.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_clear_data_141_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TypedWritable *BamCacheRecord::get_data(void) const
 */
static PyObject *Dtool_BamCacheRecord_get_data_142(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline TypedWritable *BamCacheRecord::get_data(void) const
  TypedWritable *return_value = (*(const BamCacheRecord*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritable, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_get_data_142_comment =
  "C++ Interface:\n"
  "get_data(BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the data stored in the record, or NULL if there is no\n"
  " * data.  The pointer is not removed from the record.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_get_data_142_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BamCacheRecord::set_data(TypedWritable *ptr)
 * inline void BamCacheRecord::set_data(TypedWritable *ptr, ReferenceCount *ref_ptr)
 * inline void BamCacheRecord::set_data(TypedWritable *ptr, int dummy)
 * inline void BamCacheRecord::set_data(TypedWritableReferenceCount *ptr)
 */
static PyObject *Dtool_BamCacheRecord_set_data_144(PyObject *self, PyObject *args, PyObject *kwds) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCacheRecord, (void **)&local_this, "BamCacheRecord.set_data")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "ptr");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'ptr' (pos 1) not found");
      }
      {
        // -2 inline void BamCacheRecord::set_data(TypedWritableReferenceCount *ptr)
        TypedWritableReferenceCount *arg_this = (TypedWritableReferenceCount *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedWritableReferenceCount, 1, "BamCacheRecord.set_data", false, false);
        if (arg_this != NULL) {
          (*local_this).set_data(arg_this);
          return Dtool_Return_None();
        }
      }

      {
        // -2 inline void BamCacheRecord::set_data(TypedWritable *ptr)
        TypedWritable *arg_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedWritable, 1, "BamCacheRecord.set_data", false, false);
        if (arg_this != NULL) {
          (*local_this).set_data(arg_this);
          return Dtool_Return_None();
        }
      }

      // No coercion possible: inline void BamCacheRecord::set_data(TypedWritableReferenceCount *ptr)
      // No coercion possible: inline void BamCacheRecord::set_data(TypedWritable *ptr)
    }
    break;
  case 2:
    {
      {
        // -2 inline void BamCacheRecord::set_data(TypedWritable *ptr, ReferenceCount *ref_ptr)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"ptr", "ref_ptr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_data", (char **)keyword_list, &param1, &param2)) {
          TypedWritable *param1_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TypedWritable, 1, "BamCacheRecord.set_data", false, false);
          ReferenceCount *param2_this = (ReferenceCount *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_ReferenceCount, 2, "BamCacheRecord.set_data", false, false);
          if (param1_this != NULL && param2_this != NULL) {
            (*local_this).set_data(param1_this, param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void BamCacheRecord::set_data(TypedWritable *ptr, int dummy)
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"ptr", "dummy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:set_data", (char **)keyword_list, &param1, &param2)) {
          TypedWritable *param1_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TypedWritable, 1, "BamCacheRecord.set_data", false, false);
          if (param1_this != NULL) {
            (*local_this).set_data(param1_this, (int)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void BamCacheRecord::set_data(TypedWritable *ptr, ReferenceCount *ref_ptr)
      // No coercion possible: inline void BamCacheRecord::set_data(TypedWritable *ptr, int dummy)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_data() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const BamCacheRecord self, TypedWritableReferenceCount ptr)\n"
      "set_data(const BamCacheRecord self, TypedWritable ptr)\n"
      "set_data(const BamCacheRecord self, TypedWritable ptr, ReferenceCount ref_ptr)\n"
      "set_data(const BamCacheRecord self, TypedWritable ptr, int dummy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_set_data_144_comment =
  "C++ Interface:\n"
  "set_data(const BamCacheRecord self, TypedWritableReferenceCount ptr)\n"
  "set_data(const BamCacheRecord self, TypedWritable ptr)\n"
  "set_data(const BamCacheRecord self, TypedWritable ptr, ReferenceCount ref_ptr)\n"
  "set_data(const BamCacheRecord self, TypedWritable ptr, int dummy)\n"
  "\n"
  "/**\n"
  " * Stores a new data object on the record.  You should pass the same pointer\n"
  " * twice, to both parameters; this allows the C++ typecasting to automatically\n"
  " * convert the pointer into both a TypedWritable and a ReferenceCount pointer,\n"
  " * so that the BamCacheRecord object can reliably manage the reference counts.\n"
  " *\n"
  " * You may pass 0 or NULL as the second parameter.  If you do this, the\n"
  " * BamCacheRecord will not manage the object's reference count; it will be up\n"
  " * to you to ensure the object is not deleted during the lifetime of the\n"
  " * BamCacheRecord object.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This variant on set_data() is provided to easily pass objects deriving from\n"
  " * TypedWritable.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This variant on set_data() is provided to easily pass objects deriving from\n"
  " * TypedWritableReferenceCount.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This variant on set_data() is provided just to allow Python code to pass a\n"
  " * 0 as the second parameter.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_set_data_144_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BamCacheRecord::output(ostream &out) const
 */
static PyObject *Dtool_BamCacheRecord_output_147(PyObject *self, PyObject *arg) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }
  // 1-void BamCacheRecord::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "BamCacheRecord.output", false, true);
  if (arg_this != NULL) {
    (*(const BamCacheRecord*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(BamCacheRecord self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_output_147_comment =
  "C++ Interface:\n"
  "output(BamCacheRecord self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_output_147_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BamCacheRecord::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_BamCacheRecord_write_148(PyObject *self, PyObject *args, PyObject *kwds) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }
  // 1-void BamCacheRecord::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BamCacheRecord.write", false, true);
    if (param1_this != NULL) {
      (*(const BamCacheRecord*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(BamCacheRecord self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_write_148_comment =
  "C++ Interface:\n"
  "write(BamCacheRecord self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_write_148_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BamCacheRecord::get_class_type(void)
 */
static PyObject *Dtool_BamCacheRecord_get_class_type_149(PyObject *, PyObject *) {
  // 1-static TypeHandle BamCacheRecord::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BamCacheRecord::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_get_class_type_149_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BamCacheRecord_get_class_type_149_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypedWritableReferenceCount *BamCacheRecord::upcast_to_TypedWritableReferenceCount(void)
 */
static PyObject *Dtool_BamCacheRecord_upcast_to_TypedWritableReferenceCount_116(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCacheRecord, (void **)&local_this, "BamCacheRecord.upcast_to_TypedWritableReferenceCount")) {
    return NULL;
  }
  // 1-TypedWritableReferenceCount *BamCacheRecord::upcast_to_TypedWritableReferenceCount(void)
  TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_upcast_to_TypedWritableReferenceCount_116_comment =
  "C++ Interface:\n"
  "upcast_to_TypedWritableReferenceCount(const BamCacheRecord self)\n"
  "\n"
  "upcast from BamCacheRecord to TypedWritableReferenceCount";
#else
static const char *Dtool_BamCacheRecord_upcast_to_TypedWritableReferenceCount_116_comment = NULL;
#endif

static PyObject *Dtool_BamCacheRecord_source_pathname_Getter(PyObject *self, void *) {
  const BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline Filename const &BamCacheRecord::get_source_pathname(void) const
  Filename const *return_value = &((*(const BamCacheRecord*)local_this).get_source_pathname());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static PyObject *Dtool_BamCacheRecord_cache_filename_Getter(PyObject *self, void *) {
  const BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline Filename const &BamCacheRecord::get_cache_filename(void) const
  Filename const *return_value = &((*(const BamCacheRecord*)local_this).get_cache_filename());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static PyObject *Dtool_BamCacheRecord_source_timestamp_Getter(PyObject *self, void *) {
  const BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline time_t BamCacheRecord::get_source_timestamp(void) const
  time_t return_value = (*(const BamCacheRecord*)local_this).get_source_timestamp();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_BamCacheRecord_recorded_time_Getter(PyObject *self, void *) {
  const BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline time_t BamCacheRecord::get_recorded_time(void) const
  time_t return_value = (*(const BamCacheRecord*)local_this).get_recorded_time();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_BamCacheRecord_data_Getter(PyObject *self, void *) {
  const BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_data()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline TypedWritable *BamCacheRecord::get_data(void) const
  TypedWritable *return_value = (*(const BamCacheRecord*)local_this).get_data();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritable, false, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_BamCacheRecord_data_Setter(PyObject *self, PyObject *arg, void *) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCacheRecord, (void **)&local_this, "BamCacheRecord.data")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete data attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_data();
    return 0;
  }
  {
    // -2 inline void BamCacheRecord::set_data(TypedWritableReferenceCount *ptr)
    TypedWritableReferenceCount *arg_this = (TypedWritableReferenceCount *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedWritableReferenceCount, 1, "BamCacheRecord.set_data", false, false);
    if (arg_this != NULL) {
      (*local_this).set_data(arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  {
    // -2 inline void BamCacheRecord::set_data(TypedWritable *ptr)
    TypedWritable *arg_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedWritable, 1, "BamCacheRecord.set_data", false, false);
    if (arg_this != NULL) {
      (*local_this).set_data(arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  // No coercion possible: inline void BamCacheRecord::set_data(TypedWritableReferenceCount *ptr)
  // No coercion possible: inline void BamCacheRecord::set_data(TypedWritable *ptr)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_data(const BamCacheRecord self, TypedWritableReferenceCount ptr)\n"
      "set_data(const BamCacheRecord self, TypedWritable ptr)\n");
  }
  return -1;
}

static int Dtool_Init_BamCacheRecord(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_BamCacheRecord(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BamCacheRecord) {
    printf("BamCacheRecord ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BamCacheRecord *local_this = (BamCacheRecord *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BamCacheRecord) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BamCacheRecord(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BamCacheRecord) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BamCacheRecord*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BamCacheRecord*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (BamCacheRecord*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (BamCacheRecord*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BamCache
 */
/**
 * Python function wrapper for:
 * inline void BamCache::set_active(bool flag)
 */
static PyObject *Dtool_BamCache_set_active_153(PyObject *self, PyObject *arg) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.set_active")) {
    return NULL;
  }
  // 1-inline void BamCache::set_active(bool flag)
  (*local_this).set_active((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_active(const BamCache self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_set_active_153_comment =
  "C++ Interface:\n"
  "set_active(const BamCache self, bool flag)\n"
  "\n"
  "/**\n"
  " * Changes the state of the active flag.  \"active\" means that the cache should\n"
  " * be consulted automatically on loads, \"not active\" means that objects should\n"
  " * be loaded directly without consulting the cache.\n"
  " *\n"
  " * This represents the global flag.  Also see the individual cache_models,\n"
  " * cache_textures, cache_compressed_textures flags.\n"
  " */";
#else
static const char *Dtool_BamCache_set_active_153_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BamCache::get_active(void) const
 */
static PyObject *Dtool_BamCache_get_active_154(PyObject *self, PyObject *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BamCache::get_active(void) const
  bool return_value = (*(const BamCache*)local_this).get_active();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_active_154_comment =
  "C++ Interface:\n"
  "get_active(BamCache self)\n"
  "\n"
  "/**\n"
  " * Returns true if the BamCache is currently active, false if it is not.\n"
  " * \"active\" means that the cache should be consulted automatically on loads,\n"
  " * \"not active\" means that objects should be loaded directly without\n"
  " * consulting the cache.\n"
  " *\n"
  " * This represents the global flag.  Also see the individual cache_models,\n"
  " * cache_textures, cache_compressed_textures flags.\n"
  " */";
#else
static const char *Dtool_BamCache_get_active_154_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BamCache::set_cache_models(bool flag)
 */
static PyObject *Dtool_BamCache_set_cache_models_155(PyObject *self, PyObject *arg) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.set_cache_models")) {
    return NULL;
  }
  // 1-inline void BamCache::set_cache_models(bool flag)
  (*local_this).set_cache_models((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cache_models(const BamCache self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_set_cache_models_155_comment =
  "C++ Interface:\n"
  "set_cache_models(const BamCache self, bool flag)\n"
  "\n"
  "/**\n"
  " * Indicates whether model files (e.g.  egg files and bam files) will be\n"
  " * stored in the cache, as bam files.\n"
  " */";
#else
static const char *Dtool_BamCache_set_cache_models_155_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BamCache::get_cache_models(void) const
 */
static PyObject *Dtool_BamCache_get_cache_models_156(PyObject *self, PyObject *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BamCache::get_cache_models(void) const
  bool return_value = (*(const BamCache*)local_this).get_cache_models();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_cache_models_156_comment =
  "C++ Interface:\n"
  "get_cache_models(BamCache self)\n"
  "\n"
  "/**\n"
  " * Returns whether model files (e.g.  egg files and bam files) will be stored\n"
  " * in the cache, as bam files.\n"
  " *\n"
  " * This also returns false if get_active() is false.\n"
  " */";
#else
static const char *Dtool_BamCache_get_cache_models_156_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BamCache::set_cache_textures(bool flag)
 */
static PyObject *Dtool_BamCache_set_cache_textures_157(PyObject *self, PyObject *arg) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.set_cache_textures")) {
    return NULL;
  }
  // 1-inline void BamCache::set_cache_textures(bool flag)
  (*local_this).set_cache_textures((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cache_textures(const BamCache self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_set_cache_textures_157_comment =
  "C++ Interface:\n"
  "set_cache_textures(const BamCache self, bool flag)\n"
  "\n"
  "/**\n"
  " * Indicates whether texture files will be stored in the cache, as\n"
  " * uncompressed txo files.\n"
  " */";
#else
static const char *Dtool_BamCache_set_cache_textures_157_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BamCache::get_cache_textures(void) const
 */
static PyObject *Dtool_BamCache_get_cache_textures_158(PyObject *self, PyObject *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BamCache::get_cache_textures(void) const
  bool return_value = (*(const BamCache*)local_this).get_cache_textures();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_cache_textures_158_comment =
  "C++ Interface:\n"
  "get_cache_textures(BamCache self)\n"
  "\n"
  "/**\n"
  " * Returns whether texture files (e.g.  egg files and bam files) will be\n"
  " * stored in the cache, as txo files.\n"
  " *\n"
  " * This also returns false if get_active() is false.\n"
  " */";
#else
static const char *Dtool_BamCache_get_cache_textures_158_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BamCache::set_cache_compressed_textures(bool flag)
 */
static PyObject *Dtool_BamCache_set_cache_compressed_textures_159(PyObject *self, PyObject *arg) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.set_cache_compressed_textures")) {
    return NULL;
  }
  // 1-inline void BamCache::set_cache_compressed_textures(bool flag)
  (*local_this).set_cache_compressed_textures((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cache_compressed_textures(const BamCache self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_set_cache_compressed_textures_159_comment =
  "C++ Interface:\n"
  "set_cache_compressed_textures(const BamCache self, bool flag)\n"
  "\n"
  "/**\n"
  " * Indicates whether compressed texture files will be stored in the cache, as\n"
  " * compressed txo files.  The compressed data may either be generated in-CPU,\n"
  " * via the squish library, or it may be extracted from the GSG after the\n"
  " * texture has been loaded.\n"
  " *\n"
  " * This may be set in conjunction with set_cache_textures(), or independently\n"
  " * of it.  If set_cache_textures() is true and this is false, all textures\n"
  " * will be cached in their uncompressed form.  If set_cache_textures() is\n"
  " * false and this is true, only compressed textures will be cached, and they\n"
  " * will be cached in their compressed form.  If both are true, all textures\n"
  " * will be cached, in their uncompressed or compressed form appropriately.\n"
  " */";
#else
static const char *Dtool_BamCache_set_cache_compressed_textures_159_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BamCache::get_cache_compressed_textures(void) const
 */
static PyObject *Dtool_BamCache_get_cache_compressed_textures_160(PyObject *self, PyObject *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BamCache::get_cache_compressed_textures(void) const
  bool return_value = (*(const BamCache*)local_this).get_cache_compressed_textures();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_cache_compressed_textures_160_comment =
  "C++ Interface:\n"
  "get_cache_compressed_textures(BamCache self)\n"
  "\n"
  "/**\n"
  " * Returns whether compressed texture files will be stored in the cache, as\n"
  " * compressed txo files.  See set_cache_compressed_textures().\n"
  " *\n"
  " * This also returns false if get_active() is false.\n"
  " */";
#else
static const char *Dtool_BamCache_get_cache_compressed_textures_160_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BamCache::set_cache_compiled_shaders(bool flag)
 */
static PyObject *Dtool_BamCache_set_cache_compiled_shaders_161(PyObject *self, PyObject *arg) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.set_cache_compiled_shaders")) {
    return NULL;
  }
  // 1-inline void BamCache::set_cache_compiled_shaders(bool flag)
  (*local_this).set_cache_compiled_shaders((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cache_compiled_shaders(const BamCache self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_set_cache_compiled_shaders_161_comment =
  "C++ Interface:\n"
  "set_cache_compiled_shaders(const BamCache self, bool flag)\n"
  "\n"
  "/**\n"
  " * Indicates whether compiled shader programs will be stored in the cache, as\n"
  " * binary .sho files.  This may not be supported by all shader languages or\n"
  " * graphics renderers.\n"
  " */";
#else
static const char *Dtool_BamCache_set_cache_compiled_shaders_161_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BamCache::get_cache_compiled_shaders(void) const
 */
static PyObject *Dtool_BamCache_get_cache_compiled_shaders_162(PyObject *self, PyObject *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BamCache::get_cache_compiled_shaders(void) const
  bool return_value = (*(const BamCache*)local_this).get_cache_compiled_shaders();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_cache_compiled_shaders_162_comment =
  "C++ Interface:\n"
  "get_cache_compiled_shaders(BamCache self)\n"
  "\n"
  "/**\n"
  " * Returns whether compiled shader programs will be stored in the cache, as\n"
  " * binary .txo files.  See set_cache_compiled_shaders().\n"
  " *\n"
  " * This also returns false if get_active() is false.\n"
  " */";
#else
static const char *Dtool_BamCache_get_cache_compiled_shaders_162_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BamCache::set_root(Filename const &root)
 */
static PyObject *Dtool_BamCache_set_root_163(PyObject *self, PyObject *arg) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.set_root")) {
    return NULL;
  }
  // 1-void BamCache::set_root(Filename const &root)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BamCache.set_root", "Filename");
  }
  (*local_this).set_root(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_root(const BamCache self, const Filename root)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_set_root_163_comment =
  "C++ Interface:\n"
  "set_root(const BamCache self, const Filename root)\n"
  "\n"
  "//               If the directory does not already exist, it will be\n"
  "//               created as a result of this call.\n"
  "////////////////////////////////////////////////////////////////////";
#else
static const char *Dtool_BamCache_set_root_163_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename BamCache::get_root(void) const
 */
static PyObject *Dtool_BamCache_get_root_164(PyObject *self, PyObject *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename BamCache::get_root(void) const
  Filename *return_value = new Filename((*(const BamCache*)local_this).get_root());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_root_164_comment =
  "C++ Interface:\n"
  "get_root(BamCache self)\n"
  "\n"
  "/**\n"
  " * Returns the current root pathname of the cache.  See set_root().\n"
  " */";
#else
static const char *Dtool_BamCache_get_root_164_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BamCache::set_flush_time(int flush_time)
 */
static PyObject *Dtool_BamCache_set_flush_time_165(PyObject *self, PyObject *arg) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.set_flush_time")) {
    return NULL;
  }
  // 1-inline void BamCache::set_flush_time(int flush_time)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_flush_time((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_flush_time(const BamCache self, int flush_time)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_set_flush_time_165_comment =
  "C++ Interface:\n"
  "set_flush_time(const BamCache self, int flush_time)\n"
  "\n"
  "/**\n"
  " * Specifies the time in seconds between automatic flushes of the cache index.\n"
  " */";
#else
static const char *Dtool_BamCache_set_flush_time_165_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BamCache::get_flush_time(void) const
 */
static PyObject *Dtool_BamCache_get_flush_time_166(PyObject *self, PyObject *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BamCache::get_flush_time(void) const
  int return_value = (*(const BamCache*)local_this).get_flush_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_flush_time_166_comment =
  "C++ Interface:\n"
  "get_flush_time(BamCache self)\n"
  "\n"
  "/**\n"
  " * Returns the time in seconds between automatic flushes of the cache index.\n"
  " */";
#else
static const char *Dtool_BamCache_get_flush_time_166_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BamCache::set_cache_max_kbytes(int max_kbytes)
 */
static PyObject *Dtool_BamCache_set_cache_max_kbytes_167(PyObject *self, PyObject *arg) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.set_cache_max_kbytes")) {
    return NULL;
  }
  // 1-inline void BamCache::set_cache_max_kbytes(int max_kbytes)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_cache_max_kbytes((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cache_max_kbytes(const BamCache self, int max_kbytes)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_set_cache_max_kbytes_167_comment =
  "C++ Interface:\n"
  "set_cache_max_kbytes(const BamCache self, int max_kbytes)\n"
  "\n"
  "/**\n"
  " * Specifies the maximum size, in kilobytes, which the cache is allowed to\n"
  " * grow to.  If a newly cached file would exceed this size, an older file is\n"
  " * removed from the cache.\n"
  " *\n"
  " * Note that in the case of multiple different processes simultaneously\n"
  " * operating on the same cache directory, the actual cache size may slightly\n"
  " * exceed this value from time to time due to latency in checking between the\n"
  " * processes.\n"
  " */";
#else
static const char *Dtool_BamCache_set_cache_max_kbytes_167_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BamCache::get_cache_max_kbytes(void) const
 */
static PyObject *Dtool_BamCache_get_cache_max_kbytes_168(PyObject *self, PyObject *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BamCache::get_cache_max_kbytes(void) const
  int return_value = (*(const BamCache*)local_this).get_cache_max_kbytes();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_cache_max_kbytes_168_comment =
  "C++ Interface:\n"
  "get_cache_max_kbytes(BamCache self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum size, in kilobytes, which the cache is allowed to grow\n"
  " * to.  See set_cache_max_kbytes().\n"
  " */";
#else
static const char *Dtool_BamCache_get_cache_max_kbytes_168_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BamCache::set_read_only(bool ro)
 */
static PyObject *Dtool_BamCache_set_read_only_169(PyObject *self, PyObject *arg) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.set_read_only")) {
    return NULL;
  }
  // 1-inline void BamCache::set_read_only(bool ro)
  (*local_this).set_read_only((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_read_only(const BamCache self, bool ro)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_set_read_only_169_comment =
  "C++ Interface:\n"
  "set_read_only(const BamCache self, bool ro)\n"
  "\n"
  "/**\n"
  " * Can be used to put the cache in read-only mode, or take it out of read-only\n"
  " * mode.  Note that if you put it into read-write mode, and it discovers that\n"
  " * it does not have write access, it will put itself right back into read-only\n"
  " * mode.\n"
  " */";
#else
static const char *Dtool_BamCache_set_read_only_169_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BamCache::get_read_only(void) const
 */
static PyObject *Dtool_BamCache_get_read_only_170(PyObject *self, PyObject *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BamCache::get_read_only(void) const
  bool return_value = (*(const BamCache*)local_this).get_read_only();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_read_only_170_comment =
  "C++ Interface:\n"
  "get_read_only(BamCache self)\n"
  "\n"
  "/**\n"
  " * Returns true if the cache is in read-only mode.  Normally, the cache starts\n"
  " * in read-write mode.  It can put itself into read-only mode automatically if\n"
  " * it discovers that it does not have write access to the cache.\n"
  " */";
#else
static const char *Dtool_BamCache_get_read_only_170_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< BamCacheRecord > BamCache::lookup(Filename const &source_filename, std::string const &cache_extension)
 */
static PyObject *Dtool_BamCache_lookup_171(PyObject *self, PyObject *args, PyObject *kwds) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.lookup")) {
    return NULL;
  }
  // 1-PointerTo< BamCacheRecord > BamCache::lookup(Filename const &source_filename, std::string const &cache_extension)
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"source_filename", "cache_extension", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:lookup", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "BamCache.lookup", "Filename");
    }
    PointerTo< BamCacheRecord > return_value = (*local_this).lookup(*param1_this, std::string(param2_str, param2_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    BamCacheRecord *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BamCacheRecord, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lookup(const BamCache self, const Filename source_filename, str cache_extension)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_lookup_171_comment =
  "C++ Interface:\n"
  "lookup(const BamCache self, const Filename source_filename, str cache_extension)\n"
  "\n"
  "//               If record->has_data() returns true, then the file was\n"
  "//               found in the cache, and you may call\n"
  "//               record->extract_data() to get the object.  If\n"
  "//               record->has_data() returns false, then the file was\n"
  "//               not found in the cache or the cache was stale; and\n"
  "//               you should reload the source file (calling\n"
  "//               record->add_dependent_file() for each file loaded,\n"
  "//               including the original source file), and then call\n"
  "//               record->set_data() to record the resulting loaded\n"
  "//               object; and finally, you should call store() to write\n"
  "//               the cached record to disk.\n"
  "////////////////////////////////////////////////////////////////////";
#else
static const char *Dtool_BamCache_lookup_171_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool BamCache::store(BamCacheRecord *record)
 */
static PyObject *Dtool_BamCache_store_172(PyObject *self, PyObject *arg) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.store")) {
    return NULL;
  }
  // 1-bool BamCache::store(BamCacheRecord *record)
  BamCacheRecord *arg_this = (BamCacheRecord *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BamCacheRecord, 1, "BamCache.store", false, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).store(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store(const BamCache self, BamCacheRecord record)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_store_172_comment =
  "C++ Interface:\n"
  "store(const BamCache self, BamCacheRecord record)\n"
  "\n"
  "////////////////////////////////////////////////////////////////////\n"
  "//     Function: BamCache::store\n"
  "//       Access: Published\n"
  "//  Description: Flushes a cache entry to disk.  You must have\n"
  "//               retrieved the cache record via a prior call to\n"
  "//               lookup(), and then stored the data via\n"
  "//               record->set_data().  Returns true on success, false\n"
  "//               on failure.\n"
  "////////////////////////////////////////////////////////////////////";
#else
static const char *Dtool_BamCache_store_172_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BamCache::consider_flush_index(void)
 */
static PyObject *Dtool_BamCache_consider_flush_index_173(PyObject *self, PyObject *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.consider_flush_index")) {
    return NULL;
  }
  // 1-void BamCache::consider_flush_index(void)
  (*local_this).consider_flush_index();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BamCache_consider_flush_index_173_comment =
  "C++ Interface:\n"
  "consider_flush_index(const BamCache self)\n"
  "\n"
  "////////////////////////////////////////////////////////////////////\n"
  "//     Function: BamCache::consider_flush_index\n"
  "//       Access: Published\n"
  "//  Description: Flushes the index if enough time has elapsed since\n"
  "//               the index was last flushed.\n"
  "////////////////////////////////////////////////////////////////////";
#else
static const char *Dtool_BamCache_consider_flush_index_173_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BamCache::flush_index(void)
 */
static PyObject *Dtool_BamCache_flush_index_174(PyObject *self, PyObject *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.flush_index")) {
    return NULL;
  }
  // 1-void BamCache::flush_index(void)
  (*local_this).flush_index();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BamCache_flush_index_174_comment =
  "C++ Interface:\n"
  "flush_index(const BamCache self)\n"
  "\n"
  "////////////////////////////////////////////////////////////////////\n"
  "//     Function: BamCache::flush_index\n"
  "//       Access: Published\n"
  "//  Description: Ensures the index is written to disk.\n"
  "////////////////////////////////////////////////////////////////////";
#else
static const char *Dtool_BamCache_flush_index_174_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BamCache::list_index(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_BamCache_list_index_175(PyObject *self, PyObject *args, PyObject *kwds) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return NULL;
  }
  // 1-void BamCache::list_index(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:list_index", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BamCache.list_index", false, true);
    if (param1_this != NULL) {
      (*(const BamCache*)local_this).list_index(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "list_index(BamCache self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_list_index_175_comment =
  "C++ Interface:\n"
  "list_index(BamCache self, ostream out, int indent_level)\n"
  "\n"
  "////////////////////////////////////////////////////////////////////\n"
  "//     Function: BamCache::list_index\n"
  "//       Access: Published\n"
  "//  Description: Writes the contents of the index to standard output.\n"
  "////////////////////////////////////////////////////////////////////";
#else
static const char *Dtool_BamCache_list_index_175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BamCache *BamCache::get_global_ptr(void)
 */
static PyObject *Dtool_BamCache_get_global_ptr_176(PyObject *, PyObject *) {
  // 1-static inline BamCache *BamCache::get_global_ptr(void)
  BamCache *return_value = BamCache::get_global_ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BamCache, false, false);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_global_ptr_176_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the global BamCache object, which is used\n"
  " * automatically by the ModelPool and TexturePool.\n"
  " */";
#else
static const char *Dtool_BamCache_get_global_ptr_176_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void BamCache::consider_flush_global_index(void)
 */
static PyObject *Dtool_BamCache_consider_flush_global_index_177(PyObject *, PyObject *) {
  // 1-static inline void BamCache::consider_flush_global_index(void)
  BamCache::consider_flush_global_index();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BamCache_consider_flush_global_index_177_comment =
  "C++ Interface:\n"
  "consider_flush_global_index()\n"
  "\n"
  "/**\n"
  " * If there is a global BamCache object, calls consider_flush_index() on it.\n"
  " */";
#else
static const char *Dtool_BamCache_consider_flush_global_index_177_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void BamCache::flush_global_index(void)
 */
static PyObject *Dtool_BamCache_flush_global_index_178(PyObject *, PyObject *) {
  // 1-static inline void BamCache::flush_global_index(void)
  BamCache::flush_global_index();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BamCache_flush_global_index_178_comment =
  "C++ Interface:\n"
  "flush_global_index()\n"
  "\n"
  "/**\n"
  " * If there is a global BamCache object, calls flush_index() on it.\n"
  " */";
#else
static const char *Dtool_BamCache_flush_global_index_178_comment = NULL;
#endif

static PyObject *Dtool_BamCache_active_Getter(PyObject *self, void *) {
  const BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool BamCache::get_active(void) const
  bool return_value = (*(const BamCache*)local_this).get_active();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_BamCache_active_Setter(PyObject *self, PyObject *arg, void *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.active")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete active attribute");
    return -1;
  }
  // 1-inline void BamCache::set_active(bool flag)
  (*local_this).set_active((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_active(const BamCache self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_BamCache_cache_models_Getter(PyObject *self, void *) {
  const BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool BamCache::get_cache_models(void) const
  bool return_value = (*(const BamCache*)local_this).get_cache_models();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_BamCache_cache_models_Setter(PyObject *self, PyObject *arg, void *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.cache_models")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete cache_models attribute");
    return -1;
  }
  // 1-inline void BamCache::set_cache_models(bool flag)
  (*local_this).set_cache_models((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cache_models(const BamCache self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_BamCache_cache_textures_Getter(PyObject *self, void *) {
  const BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool BamCache::get_cache_textures(void) const
  bool return_value = (*(const BamCache*)local_this).get_cache_textures();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_BamCache_cache_textures_Setter(PyObject *self, PyObject *arg, void *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.cache_textures")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete cache_textures attribute");
    return -1;
  }
  // 1-inline void BamCache::set_cache_textures(bool flag)
  (*local_this).set_cache_textures((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cache_textures(const BamCache self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_BamCache_cache_compressed_textures_Getter(PyObject *self, void *) {
  const BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool BamCache::get_cache_compressed_textures(void) const
  bool return_value = (*(const BamCache*)local_this).get_cache_compressed_textures();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_BamCache_cache_compressed_textures_Setter(PyObject *self, PyObject *arg, void *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.cache_compressed_textures")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete cache_compressed_textures attribute");
    return -1;
  }
  // 1-inline void BamCache::set_cache_compressed_textures(bool flag)
  (*local_this).set_cache_compressed_textures((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cache_compressed_textures(const BamCache self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_BamCache_cache_compiled_shaders_Getter(PyObject *self, void *) {
  const BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool BamCache::get_cache_compiled_shaders(void) const
  bool return_value = (*(const BamCache*)local_this).get_cache_compiled_shaders();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_BamCache_cache_compiled_shaders_Setter(PyObject *self, PyObject *arg, void *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.cache_compiled_shaders")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete cache_compiled_shaders attribute");
    return -1;
  }
  // 1-inline void BamCache::set_cache_compiled_shaders(bool flag)
  (*local_this).set_cache_compiled_shaders((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cache_compiled_shaders(const BamCache self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_BamCache_root_Getter(PyObject *self, void *) {
  const BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline Filename BamCache::get_root(void) const
  Filename *return_value = new Filename((*(const BamCache*)local_this).get_root());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

static int Dtool_BamCache_root_Setter(PyObject *self, PyObject *arg, void *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.root")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete root attribute");
    return -1;
  }
  // 1-void BamCache::set_root(Filename const &root)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BamCache.set_root", "Filename");
    return -1;
  }
  (*local_this).set_root(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_root(const BamCache self, const Filename root)\n");
  }
  return -1;
}

static PyObject *Dtool_BamCache_flush_time_Getter(PyObject *self, void *) {
  const BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int BamCache::get_flush_time(void) const
  int return_value = (*(const BamCache*)local_this).get_flush_time();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_BamCache_flush_time_Setter(PyObject *self, PyObject *arg, void *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.flush_time")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete flush_time attribute");
    return -1;
  }
  // 1-inline void BamCache::set_flush_time(int flush_time)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_flush_time((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_flush_time(const BamCache self, int flush_time)\n");
  }
  return -1;
}

static PyObject *Dtool_BamCache_cache_max_kbytes_Getter(PyObject *self, void *) {
  const BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int BamCache::get_cache_max_kbytes(void) const
  int return_value = (*(const BamCache*)local_this).get_cache_max_kbytes();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_BamCache_cache_max_kbytes_Setter(PyObject *self, PyObject *arg, void *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.cache_max_kbytes")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete cache_max_kbytes attribute");
    return -1;
  }
  // 1-inline void BamCache::set_cache_max_kbytes(int max_kbytes)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_cache_max_kbytes((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cache_max_kbytes(const BamCache self, int max_kbytes)\n");
  }
  return -1;
}

static PyObject *Dtool_BamCache_read_only_Getter(PyObject *self, void *) {
  const BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool BamCache::get_read_only(void) const
  bool return_value = (*(const BamCache*)local_this).get_read_only();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_BamCache_read_only_Setter(PyObject *self, PyObject *arg, void *) {
  BamCache *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.read_only")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete read_only attribute");
    return -1;
  }
  // 1-inline void BamCache::set_read_only(bool ro)
  (*local_this).set_read_only((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_read_only(const BamCache self, bool ro)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * BamCache::BamCache(void)
 */
static int Dtool_Init_BamCache(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "BamCache() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-BamCache::BamCache(void)
  BamCache *return_value = new BamCache();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BamCache, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BamCache()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BamCache(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BamCache) {
    printf("BamCache ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BamCache *local_this = (BamCache *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BamCache) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BamCache(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BamCache) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BamEnums
 */
/**
 * Python function wrapper for:
 * inline BamEnums::BamEnums(void) = default
 * inline BamEnums::BamEnums(BamEnums const &) = default
 */
static int Dtool_Init_BamEnums(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BamEnums::BamEnums(void) = default
      BamEnums *return_value = new BamEnums();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BamEnums, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline BamEnums::BamEnums(BamEnums const &) = default
      BamEnums const *arg_this = (BamEnums *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BamEnums, 0, "BamEnums.BamEnums", true, true);
      if (arg_this != NULL) {
        BamEnums *return_value = new BamEnums(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BamEnums, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BamEnums() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BamEnums()\n"
      "BamEnums(const BamEnums param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BamEnums(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BamEnums) {
    printf("BamEnums ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BamEnums *local_this = (BamEnums *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BamEnums) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BamEnums(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BamEnums) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LoaderOptions
 */
/**
 * Python function wrapper for:
 * inline void LoaderOptions::operator =(LoaderOptions const &copy)
 */
static PyObject *Dtool_LoaderOptions_operator_198(PyObject *self, PyObject *arg) {
  LoaderOptions *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderOptions, (void **)&local_this, "LoaderOptions.assign")) {
    return NULL;
  }
  // 1-inline void LoaderOptions::operator =(LoaderOptions const &copy)
  LoaderOptions arg_local;
  LoaderOptions const *arg_this = Dtool_Coerce_LoaderOptions(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LoaderOptions.assign", "LoaderOptions");
  }
  (*local_this).operator =(*arg_this);
  LoaderOptions *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LoaderOptions, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const LoaderOptions self, const LoaderOptions copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LoaderOptions_operator_198_comment =
  "C++ Interface:\n"
  "assign(const LoaderOptions self, const LoaderOptions copy)\n";
#else
static const char *Dtool_LoaderOptions_operator_198_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LoaderOptions::set_flags(int flags)
 */
static PyObject *Dtool_LoaderOptions_set_flags_199(PyObject *self, PyObject *arg) {
  LoaderOptions *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderOptions, (void **)&local_this, "LoaderOptions.set_flags")) {
    return NULL;
  }
  // 1-inline void LoaderOptions::set_flags(int flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_flags((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_flags(const LoaderOptions self, int flags)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LoaderOptions_set_flags_199_comment =
  "C++ Interface:\n"
  "set_flags(const LoaderOptions self, int flags)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LoaderOptions_set_flags_199_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LoaderOptions::get_flags(void) const
 */
static PyObject *Dtool_LoaderOptions_get_flags_200(PyObject *self, PyObject *) {
  LoaderOptions *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LoaderOptions, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LoaderOptions::get_flags(void) const
  int return_value = (*(const LoaderOptions*)local_this).get_flags();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LoaderOptions_get_flags_200_comment =
  "C++ Interface:\n"
  "get_flags(LoaderOptions self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LoaderOptions_get_flags_200_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LoaderOptions::set_texture_flags(int flags)
 */
static PyObject *Dtool_LoaderOptions_set_texture_flags_202(PyObject *self, PyObject *arg) {
  LoaderOptions *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderOptions, (void **)&local_this, "LoaderOptions.set_texture_flags")) {
    return NULL;
  }
  // 1-inline void LoaderOptions::set_texture_flags(int flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_texture_flags((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture_flags(const LoaderOptions self, int flags)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LoaderOptions_set_texture_flags_202_comment =
  "C++ Interface:\n"
  "set_texture_flags(const LoaderOptions self, int flags)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LoaderOptions_set_texture_flags_202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LoaderOptions::get_texture_flags(void) const
 */
static PyObject *Dtool_LoaderOptions_get_texture_flags_203(PyObject *self, PyObject *) {
  LoaderOptions *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LoaderOptions, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LoaderOptions::get_texture_flags(void) const
  int return_value = (*(const LoaderOptions*)local_this).get_texture_flags();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LoaderOptions_get_texture_flags_203_comment =
  "C++ Interface:\n"
  "get_texture_flags(LoaderOptions self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LoaderOptions_get_texture_flags_203_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LoaderOptions::set_texture_num_views(int num_views)
 */
static PyObject *Dtool_LoaderOptions_set_texture_num_views_204(PyObject *self, PyObject *arg) {
  LoaderOptions *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderOptions, (void **)&local_this, "LoaderOptions.set_texture_num_views")) {
    return NULL;
  }
  // 1-inline void LoaderOptions::set_texture_num_views(int num_views)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_texture_num_views((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture_num_views(const LoaderOptions self, int num_views)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LoaderOptions_set_texture_num_views_204_comment =
  "C++ Interface:\n"
  "set_texture_num_views(const LoaderOptions self, int num_views)\n"
  "\n"
  "/**\n"
  " * Specifies the expected number of views to load for the texture.  This is\n"
  " * ignored unless TF_multiview is included in texture_flags.  This must be\n"
  " * specified when loading a 3-d multiview texture, in which case it is used to\n"
  " * differentiate z levels from separate views; it may be zero in the case of\n"
  " * 2-d textures or cube maps, in which case the number of views can be\n"
  " * inferred from the number of images found on disk.\n"
  " */";
#else
static const char *Dtool_LoaderOptions_set_texture_num_views_204_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LoaderOptions::get_texture_num_views(void) const
 */
static PyObject *Dtool_LoaderOptions_get_texture_num_views_205(PyObject *self, PyObject *) {
  LoaderOptions *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LoaderOptions, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LoaderOptions::get_texture_num_views(void) const
  int return_value = (*(const LoaderOptions*)local_this).get_texture_num_views();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LoaderOptions_get_texture_num_views_205_comment =
  "C++ Interface:\n"
  "get_texture_num_views(LoaderOptions self)\n"
  "\n"
  "/**\n"
  " * See set_texture_num_views().\n"
  " */";
#else
static const char *Dtool_LoaderOptions_get_texture_num_views_205_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LoaderOptions::set_auto_texture_scale(AutoTextureScale scale)
 */
static PyObject *Dtool_LoaderOptions_set_auto_texture_scale_208(PyObject *self, PyObject *arg) {
  LoaderOptions *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderOptions, (void **)&local_this, "LoaderOptions.set_auto_texture_scale")) {
    return NULL;
  }
  // 1-inline void LoaderOptions::set_auto_texture_scale(AutoTextureScale scale)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_auto_texture_scale((AutoTextureScale)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_texture_scale(const LoaderOptions self, int scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LoaderOptions_set_auto_texture_scale_208_comment =
  "C++ Interface:\n"
  "set_auto_texture_scale(const LoaderOptions self, int scale)\n"
  "\n"
  "/**\n"
  " * Set this flag to ATS_none, ATS_up, ATS_down, or ATS_pad to control how a\n"
  " * texture is scaled from disk when it is subsequently loaded.  Set it to\n"
  " * ATS_unspecified to restore the default behavior.\n"
  " */";
#else
static const char *Dtool_LoaderOptions_set_auto_texture_scale_208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline AutoTextureScale LoaderOptions::get_auto_texture_scale(void) const
 */
static PyObject *Dtool_LoaderOptions_get_auto_texture_scale_209(PyObject *self, PyObject *) {
  LoaderOptions *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LoaderOptions, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline AutoTextureScale LoaderOptions::get_auto_texture_scale(void) const
  AutoTextureScale return_value = (*(const LoaderOptions*)local_this).get_auto_texture_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LoaderOptions_get_auto_texture_scale_209_comment =
  "C++ Interface:\n"
  "get_auto_texture_scale(LoaderOptions self)\n"
  "\n"
  "/**\n"
  " * See set_auto_texture_scale().\n"
  " */";
#else
static const char *Dtool_LoaderOptions_get_auto_texture_scale_209_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LoaderOptions::output(ostream &out) const
 */
static PyObject *Dtool_LoaderOptions_output_211(PyObject *self, PyObject *arg) {
  LoaderOptions *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LoaderOptions, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LoaderOptions::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LoaderOptions.output", false, true);
  if (arg_this != NULL) {
    (*(const LoaderOptions*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LoaderOptions self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LoaderOptions_output_211_comment =
  "C++ Interface:\n"
  "output(LoaderOptions self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LoaderOptions_output_211_comment = NULL;
#endif

static PyObject *Dtool_LoaderOptions_flags_Getter(PyObject *self, void *) {
  const LoaderOptions *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LoaderOptions, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int LoaderOptions::get_flags(void) const
  int return_value = (*(const LoaderOptions*)local_this).get_flags();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LoaderOptions_flags_Setter(PyObject *self, PyObject *arg, void *) {
  LoaderOptions *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderOptions, (void **)&local_this, "LoaderOptions.flags")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete flags attribute");
    return -1;
  }
  // 1-inline void LoaderOptions::set_flags(int flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_flags((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_flags(const LoaderOptions self, int flags)\n");
  }
  return -1;
}

static PyObject *Dtool_LoaderOptions_texture_flags_Getter(PyObject *self, void *) {
  const LoaderOptions *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LoaderOptions, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int LoaderOptions::get_texture_flags(void) const
  int return_value = (*(const LoaderOptions*)local_this).get_texture_flags();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LoaderOptions_texture_flags_Setter(PyObject *self, PyObject *arg, void *) {
  LoaderOptions *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderOptions, (void **)&local_this, "LoaderOptions.texture_flags")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete texture_flags attribute");
    return -1;
  }
  // 1-inline void LoaderOptions::set_texture_flags(int flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_texture_flags((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_texture_flags(const LoaderOptions self, int flags)\n");
  }
  return -1;
}

static PyObject *Dtool_LoaderOptions_texture_num_views_Getter(PyObject *self, void *) {
  const LoaderOptions *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LoaderOptions, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int LoaderOptions::get_texture_num_views(void) const
  int return_value = (*(const LoaderOptions*)local_this).get_texture_num_views();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LoaderOptions_texture_num_views_Setter(PyObject *self, PyObject *arg, void *) {
  LoaderOptions *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderOptions, (void **)&local_this, "LoaderOptions.texture_num_views")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete texture_num_views attribute");
    return -1;
  }
  // 1-inline void LoaderOptions::set_texture_num_views(int num_views)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_texture_num_views((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_texture_num_views(const LoaderOptions self, int num_views)\n");
  }
  return -1;
}

static PyObject *Dtool_LoaderOptions_auto_texture_scale_Getter(PyObject *self, void *) {
  const LoaderOptions *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LoaderOptions, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline AutoTextureScale LoaderOptions::get_auto_texture_scale(void) const
  AutoTextureScale return_value = (*(const LoaderOptions*)local_this).get_auto_texture_scale();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LoaderOptions_auto_texture_scale_Setter(PyObject *self, PyObject *arg, void *) {
  LoaderOptions *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderOptions, (void **)&local_this, "LoaderOptions.auto_texture_scale")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete auto_texture_scale attribute");
    return -1;
  }
  // 1-inline void LoaderOptions::set_auto_texture_scale(AutoTextureScale scale)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_auto_texture_scale((AutoTextureScale)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_auto_texture_scale(const LoaderOptions self, int scale)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline LoaderOptions::LoaderOptions(LoaderOptions const &copy)
 * LoaderOptions::LoaderOptions(int flags = (::LoaderOptions::LF_search | ::LoaderOptions::LF_report_errors))
 * inline LoaderOptions::LoaderOptions(int flags, int texture_flags)
 */
static int Dtool_Init_LoaderOptions(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-LoaderOptions::LoaderOptions(int flags)
      LoaderOptions *return_value = new LoaderOptions();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LoaderOptions, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LoaderOptions::LoaderOptions(LoaderOptions const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LoaderOptions", (char **)keyword_list, &param0)) {
          LoaderOptions const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LoaderOptions, (void **)&param0_this);
          if (param0_this != NULL) {
            LoaderOptions *return_value = new LoaderOptions(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LoaderOptions, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 LoaderOptions::LoaderOptions(int flags)
        int param0;
        static const char *keyword_list[] = {"flags", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:LoaderOptions", (char **)keyword_list, &param0)) {
          LoaderOptions *return_value = new LoaderOptions((int)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LoaderOptions, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LoaderOptions::LoaderOptions(LoaderOptions const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LoaderOptions", (char **)keyword_list, &param0)) {
          LoaderOptions param0_local;
          LoaderOptions const *param0_this = Dtool_Coerce_LoaderOptions(param0, param0_local);
          if ((param0_this != NULL)) {
            LoaderOptions *return_value = new LoaderOptions(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LoaderOptions, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: LoaderOptions::LoaderOptions(int flags)
    }
    break;
  case 2:
    {
      // 1-inline LoaderOptions::LoaderOptions(int flags, int texture_flags)
      int param0;
      int param1;
      static const char *keyword_list[] = {"flags", "texture_flags", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:LoaderOptions", (char **)keyword_list, &param0, &param1)) {
        LoaderOptions *return_value = new LoaderOptions((int)param0, (int)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LoaderOptions, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LoaderOptions() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LoaderOptions()\n"
      "LoaderOptions(const LoaderOptions copy)\n"
      "LoaderOptions(int flags)\n"
      "LoaderOptions(int flags, int texture_flags)\n");
  }
  return -1;
}

LoaderOptions *Dtool_Coerce_LoaderOptions(PyObject *args, LoaderOptions &coerced) {
  LoaderOptions *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LoaderOptions, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LoaderOptions *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LoaderOptions::LoaderOptions(int flags)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      coerced = LoaderOptions((int)arg_val);
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline LoaderOptions::LoaderOptions(int flags, int texture_flags)
      int param0;
      int param1;
      if (PyArg_ParseTuple(args, "ii:LoaderOptions", &param0, &param1)) {
        coerced = LoaderOptions((int)param0, (int)param1);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LoaderOptions(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LoaderOptions) {
    printf("LoaderOptions ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LoaderOptions *local_this = (LoaderOptions *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LoaderOptions) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LoaderOptions(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LoaderOptions) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BamReader
 */
/**
 * Python function wrapper for:
 * void BamReader::set_source(DatagramGenerator *source)
 */
static PyObject *Dtool_BamReader_set_source_216(PyObject *self, PyObject *arg) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.set_source")) {
    return NULL;
  }
  // 1-void BamReader::set_source(DatagramGenerator *source)
  DatagramGenerator *arg_this = (DatagramGenerator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DatagramGenerator, 1, "BamReader.set_source", false, true);
  if (arg_this != NULL) {
    (*local_this).set_source(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_source(const BamReader self, DatagramGenerator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamReader_set_source_216_comment =
  "C++ Interface:\n"
  "set_source(const BamReader self, DatagramGenerator source)\n"
  "\n"
  "/**\n"
  " * Changes the source of future datagrams for this BamReader.  This also\n"
  " * implicitly calls init() if it has not already been called.\n"
  " */";
#else
static const char *Dtool_BamReader_set_source_216_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DatagramGenerator *BamReader::get_source(void)
 */
static PyObject *Dtool_BamReader_get_source_217(PyObject *self, PyObject *) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.get_source")) {
    return NULL;
  }
  // 1-inline DatagramGenerator *BamReader::get_source(void)
  DatagramGenerator *return_value = (*local_this).get_source();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DatagramGenerator, false, false);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_source_217_comment =
  "C++ Interface:\n"
  "get_source(const BamReader self)\n"
  "\n"
  "/**\n"
  " * Returns the current source of the BamReader as set by set_source() or the\n"
  " * constructor.\n"
  " */";
#else
static const char *Dtool_BamReader_get_source_217_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool BamReader::init(void)
 */
static PyObject *Dtool_BamReader_init_218(PyObject *self, PyObject *) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.init")) {
    return NULL;
  }
  // 1-bool BamReader::init(void)
  bool return_value = (*local_this).init();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_init_218_comment =
  "C++ Interface:\n"
  "init(const BamReader self)\n"
  "\n"
  "/**\n"
  " * Initializes the BamReader prior to reading any objects from its source.\n"
  " * This includes reading the Bam header.\n"
  " *\n"
  " * This returns true if the BamReader successfully initialized, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_BamReader_init_218_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &BamReader::get_filename(void) const
 */
static PyObject *Dtool_BamReader_get_filename_221(PyObject *self, PyObject *) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename const &BamReader::get_filename(void) const
  Filename const *return_value = &((*(const BamReader*)local_this).get_filename());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_filename_221_comment =
  "C++ Interface:\n"
  "get_filename(BamReader self)\n"
  "\n"
  "/**\n"
  " * If a BAM is a file, then the BamReader should contain the name of the file.\n"
  " * This enables the reader to interpret pathnames in the BAM as relative to\n"
  " * the directory containing the BAM.\n"
  " */";
#else
static const char *Dtool_BamReader_get_filename_221_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LoaderOptions const &BamReader::get_loader_options(void) const
 */
static PyObject *Dtool_BamReader_get_loader_options_222(PyObject *self, PyObject *) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LoaderOptions const &BamReader::get_loader_options(void) const
  LoaderOptions const *return_value = &((*(const BamReader*)local_this).get_loader_options());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LoaderOptions, false, true);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_loader_options_222_comment =
  "C++ Interface:\n"
  "get_loader_options(BamReader self)\n"
  "\n"
  "/**\n"
  " * Returns the LoaderOptions passed to the loader when the model was\n"
  " * requested, if any.\n"
  " */";
#else
static const char *Dtool_BamReader_get_loader_options_222_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BamReader::set_loader_options(LoaderOptions const &options)
 */
static PyObject *Dtool_BamReader_set_loader_options_223(PyObject *self, PyObject *arg) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.set_loader_options")) {
    return NULL;
  }
  // 1-inline void BamReader::set_loader_options(LoaderOptions const &options)
  LoaderOptions arg_local;
  LoaderOptions const *arg_this = Dtool_Coerce_LoaderOptions(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BamReader.set_loader_options", "LoaderOptions");
  }
  (*local_this).set_loader_options(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_loader_options(const BamReader self, const LoaderOptions options)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamReader_set_loader_options_223_comment =
  "C++ Interface:\n"
  "set_loader_options(const BamReader self, const LoaderOptions options)\n"
  "\n"
  "/**\n"
  " * Specifies the LoaderOptions for this BamReader.\n"
  " */";
#else
static const char *Dtool_BamReader_set_loader_options_223_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypedWritable *BamReader::read_object(void)
 */
static PyObject *Dtool_BamReader_read_object_224(PyObject *self, PyObject *) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.read_object")) {
    return NULL;
  }
  // 1-TypedWritable *BamReader::read_object(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  TypedWritable *return_value = (*local_this).read_object();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritable, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BamReader_read_object_224_comment =
  "C++ Interface:\n"
  "read_object(const BamReader self)\n"
  "\n"
  "/**\n"
  " * Reads a single object from the Bam file.  If the object type is known, a\n"
  " * new object of the appropriate type is created and returned; otherwise, NULL\n"
  " * is returned.  NULL is also returned when the end of the file is reached.\n"
  " * is_eof() may be called to differentiate between these two cases.\n"
  " *\n"
  " * This may be called repeatedly to extract out all the objects in the Bam\n"
  " * file, but typically (especially for scene graph files, indicated with the\n"
  " * .bam extension), only one object is retrieved directly from the Bam file:\n"
  " * the root of the scene graph.  The remaining objects will all be retrieved\n"
  " * recursively by the first object.\n"
  " *\n"
  " * Note that the object returned may not yet be complete.  In particular, some\n"
  " * of its pointers may not be filled in; you must call resolve() to fill in\n"
  " * all the available pointers before you can safely use any objects returned\n"
  " * by read_object().\n"
  " *\n"
  " * This flavor of read_object() requires the caller to know what type of\n"
  " * object it has received in order to properly manage the reference counts.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Reads a single object from the Bam file.\n"
  " *\n"
  " * This flavor of read_object() returns both a TypedWritable and a\n"
  " * ReferenceCount pointer to the same object, so the reference count may be\n"
  " * tracked reliably, without having to know precisely what type of object we\n"
  " * have.\n"
  " * @return true on success, or false on failure.\n"
  " */";
#else
static const char *Dtool_BamReader_read_object_224_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BamReader::is_eof(void) const
 */
static PyObject *Dtool_BamReader_is_eof_225(PyObject *self, PyObject *) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BamReader::is_eof(void) const
  bool return_value = (*(const BamReader*)local_this).is_eof();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_is_eof_225_comment =
  "C++ Interface:\n"
  "is_eof(BamReader self)\n"
  "\n"
  "/**\n"
  " * Returns true if the reader has reached end-of-file, false otherwise.  This\n"
  " * call is only valid after a call to read_object().\n"
  " */";
#else
static const char *Dtool_BamReader_is_eof_225_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool BamReader::resolve(void)
 */
static PyObject *Dtool_BamReader_resolve_226(PyObject *self, PyObject *) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.resolve")) {
    return NULL;
  }
  // 1-bool BamReader::resolve(void)
  bool return_value = (*local_this).resolve();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_resolve_226_comment =
  "C++ Interface:\n"
  "resolve(const BamReader self)\n"
  "\n"
  "/**\n"
  " * This may be called at any time during processing of the Bam file to resolve\n"
  " * all the known pointers so far.  It is usually called at the end of the\n"
  " * processing, after all objects have been read, which is generally the best\n"
  " * time to call it.\n"
  " *\n"
  " * This must be called at least once after reading a particular object via\n"
  " * get_object() in order to validate that object.\n"
  " *\n"
  " * The return value is true if all objects have been resolved, or false if\n"
  " * some objects are still outstanding (in which case you will need to call\n"
  " * resolve() again later).\n"
  " */";
#else
static const char *Dtool_BamReader_resolve_226_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool BamReader::change_pointer(TypedWritable const *orig_pointer, TypedWritable const *new_pointer)
 */
static PyObject *Dtool_BamReader_change_pointer_227(PyObject *self, PyObject *args, PyObject *kwds) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.change_pointer")) {
    return NULL;
  }
  // 1-bool BamReader::change_pointer(TypedWritable const *orig_pointer, TypedWritable const *new_pointer)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"orig_pointer", "new_pointer", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:change_pointer", (char **)keyword_list, &param1, &param2)) {
    TypedWritable const *param1_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TypedWritable, 1, "BamReader.change_pointer", true, true);
    TypedWritable const *param2_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TypedWritable, 2, "BamReader.change_pointer", true, true);
    if (param1_this != NULL && param2_this != NULL) {
      bool return_value = (*local_this).change_pointer(param1_this, param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "change_pointer(const BamReader self, const TypedWritable orig_pointer, const TypedWritable new_pointer)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamReader_change_pointer_227_comment =
  "C++ Interface:\n"
  "change_pointer(const BamReader self, const TypedWritable orig_pointer, const TypedWritable new_pointer)\n"
  "\n"
  "/**\n"
  " * Indicates that an object recently read from the bam stream should be\n"
  " * replaced with a new object.  Any future occurrences of the original object\n"
  " * in the stream will henceforth return the new object instead.\n"
  " *\n"
  " * The return value is true if the replacement was successfully made, or false\n"
  " * if the object was not read from the stream (or if change_pointer had\n"
  " * already been called on it).\n"
  " */";
#else
static const char *Dtool_BamReader_change_pointer_227_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BamReader::get_file_major_ver(void) const
 */
static PyObject *Dtool_BamReader_get_file_major_ver_228(PyObject *self, PyObject *) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BamReader::get_file_major_ver(void) const
  int return_value = (*(const BamReader*)local_this).get_file_major_ver();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_file_major_ver_228_comment =
  "C++ Interface:\n"
  "get_file_major_ver(BamReader self)\n"
  "\n"
  "/**\n"
  " * Returns the major version number of the Bam file currently being read.\n"
  " */";
#else
static const char *Dtool_BamReader_get_file_major_ver_228_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BamReader::get_file_minor_ver(void) const
 */
static PyObject *Dtool_BamReader_get_file_minor_ver_229(PyObject *self, PyObject *) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BamReader::get_file_minor_ver(void) const
  int return_value = (*(const BamReader*)local_this).get_file_minor_ver();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_file_minor_ver_229_comment =
  "C++ Interface:\n"
  "get_file_minor_ver(BamReader self)\n"
  "\n"
  "/**\n"
  " * Returns the minor version number of the Bam file currently being read.\n"
  " */";
#else
static const char *Dtool_BamReader_get_file_minor_ver_229_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BamEnums::BamEndian BamReader::get_file_endian(void) const
 */
static PyObject *Dtool_BamReader_get_file_endian_230(PyObject *self, PyObject *) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BamEnums::BamEndian BamReader::get_file_endian(void) const
  BamEnums::BamEndian return_value = (*(const BamReader*)local_this).get_file_endian();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_file_endian_230_comment =
  "C++ Interface:\n"
  "get_file_endian(BamReader self)\n"
  "\n"
  "/**\n"
  " * Returns the endian preference indicated by the Bam file currently being\n"
  " * read.  This does not imply that every number is stored using the indicated\n"
  " * convention, but individual objects may choose to respect this flag when\n"
  " * recording data.\n"
  " */";
#else
static const char *Dtool_BamReader_get_file_endian_230_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BamReader::get_file_stdfloat_double(void) const
 */
static PyObject *Dtool_BamReader_get_file_stdfloat_double_231(PyObject *self, PyObject *) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BamReader::get_file_stdfloat_double(void) const
  bool return_value = (*(const BamReader*)local_this).get_file_stdfloat_double();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_file_stdfloat_double_231_comment =
  "C++ Interface:\n"
  "get_file_stdfloat_double(BamReader self)\n"
  "\n"
  "/**\n"
  " * Returns true if the file stores all \"standard\" floats as 64-bit doubles, or\n"
  " * false if they are 32-bit floats.  This is determined by the compilation\n"
  " * flags of the version of Panda that generated this file.\n"
  " */";
#else
static const char *Dtool_BamReader_get_file_stdfloat_double_231_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BamReader::get_current_major_ver(void) const
 */
static PyObject *Dtool_BamReader_get_current_major_ver_232(PyObject *self, PyObject *) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BamReader::get_current_major_ver(void) const
  int return_value = (*(const BamReader*)local_this).get_current_major_ver();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_current_major_ver_232_comment =
  "C++ Interface:\n"
  "get_current_major_ver(BamReader self)\n"
  "\n"
  "/**\n"
  " * Returns the major version number of Bam files supported by the current code\n"
  " * base.  This must match get_file_major_ver() in order to successfully read a\n"
  " * file.\n"
  " */";
#else
static const char *Dtool_BamReader_get_current_major_ver_232_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BamReader::get_current_minor_ver(void) const
 */
static PyObject *Dtool_BamReader_get_current_minor_ver_233(PyObject *self, PyObject *) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BamReader::get_current_minor_ver(void) const
  int return_value = (*(const BamReader*)local_this).get_current_minor_ver();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_current_minor_ver_233_comment =
  "C++ Interface:\n"
  "get_current_minor_ver(BamReader self)\n"
  "\n"
  "/**\n"
  " * Returns the minor version number of Bam files supported by the current code\n"
  " * base.  This must match or exceed get_file_minor_ver() in order to\n"
  " * successfully read a file.\n"
  " */";
#else
static const char *Dtool_BamReader_get_current_minor_ver_233_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *BamReader::get_file_version(void) const
 */
static PyObject *Dtool_BamReader_get_file_version_234(PyObject *self, PyObject *) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return NULL;
  }
  // 1-PyObject *BamReader::get_file_version(void) const
  PyObject *return_value = invoke_extension((const BamReader*)local_this).get_file_version();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_file_version_234_comment =
  "C++ Interface:\n"
  "get_file_version(BamReader self)\n";
#else
static const char *Dtool_BamReader_get_file_version_234_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static void BamReader::register_factory(TypeHandle handle, PyObject *func)
 */
static PyObject *Dtool_BamReader_register_factory_247(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static void BamReader::register_factory(TypeHandle handle, PyObject *func)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"handle", "func", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:register_factory", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param0_local;
    TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
    if (!(param0_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "BamReader.register_factory", "TypeHandle");
    }
    Extension<BamReader>::register_factory(*param0_this, param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "register_factory(TypeHandle handle, object func)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamReader_register_factory_247_comment =
  "C++ Interface:\n"
  "register_factory(TypeHandle handle, object func)\n"
  "\n"
  "/**\n"
  " * Registers a factory function that is called when an object of the given\n"
  " * type is encountered within the .bam stream.\n"
  " *\n"
  " * @param user_data an optional pointer to be passed along to the function.\n"
  " */";
#else
static const char *Dtool_BamReader_register_factory_247_comment = NULL;
#endif

static PyObject *Dtool_BamReader_source_Getter(PyObject *self, void *) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.source")) {
    return NULL;
  }

  // 1-inline DatagramGenerator *BamReader::get_source(void)
  DatagramGenerator *return_value = (*local_this).get_source();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DatagramGenerator, false, false);
}

static int Dtool_BamReader_source_Setter(PyObject *self, PyObject *arg, void *) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.source")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete source attribute");
    return -1;
  }
  // 1-void BamReader::set_source(DatagramGenerator *source)
  DatagramGenerator *arg_this = (DatagramGenerator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DatagramGenerator, 1, "BamReader.set_source", false, true);
  if (arg_this != NULL) {
    (*local_this).set_source(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_source(const BamReader self, DatagramGenerator source)\n");
  }
  return -1;
}

static PyObject *Dtool_BamReader_filename_Getter(PyObject *self, void *) {
  const BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline Filename const &BamReader::get_filename(void) const
  Filename const *return_value = &((*(const BamReader*)local_this).get_filename());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static PyObject *Dtool_BamReader_loader_options_Getter(PyObject *self, void *) {
  const BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LoaderOptions const &BamReader::get_loader_options(void) const
  LoaderOptions const *return_value = &((*(const BamReader*)local_this).get_loader_options());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LoaderOptions, false, true);
}

static int Dtool_BamReader_loader_options_Setter(PyObject *self, PyObject *arg, void *) {
  BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.loader_options")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete loader_options attribute");
    return -1;
  }
  // 1-inline void BamReader::set_loader_options(LoaderOptions const &options)
  LoaderOptions arg_local;
  LoaderOptions const *arg_this = Dtool_Coerce_LoaderOptions(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BamReader.set_loader_options", "LoaderOptions");
    return -1;
  }
  (*local_this).set_loader_options(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_loader_options(const BamReader self, const LoaderOptions options)\n");
  }
  return -1;
}

static PyObject *Dtool_BamReader_file_version_Getter(PyObject *self, void *) {
  const BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return NULL;
  }

  // 1-PyObject *BamReader::get_file_version(void) const
  PyObject *return_value = invoke_extension((const BamReader*)local_this).get_file_version();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_BamReader_file_endian_Getter(PyObject *self, void *) {
  const BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline BamEnums::BamEndian BamReader::get_file_endian(void) const
  BamEnums::BamEndian return_value = (*(const BamReader*)local_this).get_file_endian();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_BamReader_file_stdfloat_double_Getter(PyObject *self, void *) {
  const BamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool BamReader::get_file_stdfloat_double(void) const
  bool return_value = (*(const BamReader*)local_this).get_file_stdfloat_double();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * BamReader::BamReader(DatagramGenerator *source = 0)
 */
static int Dtool_Init_BamReader(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-BamReader::BamReader(DatagramGenerator *source = 0)
  PyObject *param0 = NULL;
  static const char *keyword_list[] = {"source", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|O:BamReader", (char **)keyword_list, &param0)) {
    DatagramGenerator *param0_this = 0;
    if (param0 != (PyObject *)NULL) {
      param0_this = (DatagramGenerator *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_DatagramGenerator, 0, "BamReader.BamReader", false, true);
    }
    if ((param0 == NULL || param0_this != NULL)) {
      BamReader *return_value = new BamReader(param0_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BamReader, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BamReader(DatagramGenerator source)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BamReader(PyObject *args, BamReader const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BamReader, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-BamReader::BamReader(DatagramGenerator *source)
    DatagramGenerator *arg_this = (DatagramGenerator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DatagramGenerator, 0, "BamReader.BamReader", false, false);
    if (arg_this != NULL) {
      BamReader *return_value = new BamReader(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_BamReader(PyObject *args, BamReader *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BamReader, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-BamReader::BamReader(DatagramGenerator *source)
    DatagramGenerator *arg_this = (DatagramGenerator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DatagramGenerator, 0, "BamReader.BamReader", false, false);
    if (arg_this != NULL) {
      BamReader *return_value = new BamReader(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_BamReader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BamReader) {
    printf("BamReader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BamReader *local_this = (BamReader *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BamReader) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BamEnums) {
    return (BamEnums *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BamReader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BamReader) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BamEnums) {
    BamEnums* other_this = (BamEnums*)from_this;
    return (BamReader*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BamWriter
 */
/**
 * Python function wrapper for:
 * void BamWriter::set_target(DatagramSink *target)
 */
static PyObject *Dtool_BamWriter_set_target_251(PyObject *self, PyObject *arg) {
  BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.set_target")) {
    return NULL;
  }
  // 1-void BamWriter::set_target(DatagramSink *target)
  DatagramSink *arg_this = (DatagramSink *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DatagramSink, 1, "BamWriter.set_target", false, true);
  if (arg_this != NULL) {
    (*local_this).set_target(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_target(const BamWriter self, DatagramSink target)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_set_target_251_comment =
  "C++ Interface:\n"
  "set_target(const BamWriter self, DatagramSink target)\n"
  "\n"
  "/**\n"
  " * Changes the destination of future datagrams written by the BamWriter.  This\n"
  " * also implicitly calls init() if it has not already been called.\n"
  " */";
#else
static const char *Dtool_BamWriter_set_target_251_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DatagramSink *BamWriter::get_target(void)
 */
static PyObject *Dtool_BamWriter_get_target_252(PyObject *self, PyObject *) {
  BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.get_target")) {
    return NULL;
  }
  // 1-inline DatagramSink *BamWriter::get_target(void)
  DatagramSink *return_value = (*local_this).get_target();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DatagramSink, false, false);
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_get_target_252_comment =
  "C++ Interface:\n"
  "get_target(const BamWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the current target of the BamWriter as set by set_target() or the\n"
  " * constructor.\n"
  " */";
#else
static const char *Dtool_BamWriter_get_target_252_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool BamWriter::init(void)
 */
static PyObject *Dtool_BamWriter_init_253(PyObject *self, PyObject *) {
  BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.init")) {
    return NULL;
  }
  // 1-bool BamWriter::init(void)
  bool return_value = (*local_this).init();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_init_253_comment =
  "C++ Interface:\n"
  "init(const BamWriter self)\n"
  "\n"
  "/**\n"
  " * Initializes the BamWriter prior to writing any objects to its output\n"
  " * stream.  This includes writing out the Bam header.\n"
  " *\n"
  " * This returns true if the BamWriter successfully initialized, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_BamWriter_init_253_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &BamWriter::get_filename(void) const
 */
static PyObject *Dtool_BamWriter_get_filename_254(PyObject *self, PyObject *) {
  BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename const &BamWriter::get_filename(void) const
  Filename const *return_value = &((*(const BamWriter*)local_this).get_filename());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_get_filename_254_comment =
  "C++ Interface:\n"
  "get_filename(BamWriter self)\n"
  "\n"
  "/**\n"
  " * If a BAM is a file, then the BamWriter should contain the name of the file.\n"
  " * This enables the writer to convert pathnames in the BAM to relative to the\n"
  " * directory containing the BAM.\n"
  " */";
#else
static const char *Dtool_BamWriter_get_filename_254_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool BamWriter::write_object(TypedWritable const *obj)
 */
static PyObject *Dtool_BamWriter_write_object_255(PyObject *self, PyObject *arg) {
  BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.write_object")) {
    return NULL;
  }
  // 1-bool BamWriter::write_object(TypedWritable const *obj)
  TypedWritable const *arg_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedWritable, 1, "BamWriter.write_object", true, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).write_object(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_object(const BamWriter self, const TypedWritable obj)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_write_object_255_comment =
  "C++ Interface:\n"
  "write_object(const BamWriter self, const TypedWritable obj)\n"
  "\n"
  "/**\n"
  " * Writes a single object to the Bam file, so that the\n"
  " * BamReader::read_object() can later correctly restore the object and all its\n"
  " * pointers.\n"
  " *\n"
  " * This implicitly also writes any additional objects this object references\n"
  " * (if they haven't already been written), so that pointers may be fully\n"
  " * resolved.\n"
  " *\n"
  " * This may be called repeatedly to write a sequence of objects to the Bam\n"
  " * file, but typically (especially for scene graph files, indicated with the\n"
  " * .bam extension), only one object is written directly from the Bam file: the\n"
  " * root of the scene graph.  The remaining objects will all be written\n"
  " * recursively by the first object.\n"
  " *\n"
  " * Returns true if the object is successfully written, false otherwise.\n"
  " */";
#else
static const char *Dtool_BamWriter_write_object_255_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool BamWriter::has_object(TypedWritable const *obj) const
 */
static PyObject *Dtool_BamWriter_has_object_256(PyObject *self, PyObject *arg) {
  BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool BamWriter::has_object(TypedWritable const *obj) const
  TypedWritable const *arg_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedWritable, 1, "BamWriter.has_object", true, true);
  if (arg_this != NULL) {
    bool return_value = (*(const BamWriter*)local_this).has_object(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_object(BamWriter self, const TypedWritable obj)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_has_object_256_comment =
  "C++ Interface:\n"
  "has_object(BamWriter self, const TypedWritable obj)\n"
  "\n"
  "/**\n"
  " * Returns true if the object has previously been written (or at least\n"
  " * requested to be written) to the bam file, or false if we've never heard of\n"
  " * it before.\n"
  " */";
#else
static const char *Dtool_BamWriter_has_object_256_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BamWriter::flush(void)
 */
static PyObject *Dtool_BamWriter_flush_257(PyObject *self, PyObject *) {
  BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.flush")) {
    return NULL;
  }
  // 1-void BamWriter::flush(void)
  (*local_this).flush();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_flush_257_comment =
  "C++ Interface:\n"
  "flush(const BamWriter self)\n"
  "\n"
  "/**\n"
  " * Ensures that all data written thus far is manifested on the output stream.\n"
  " */";
#else
static const char *Dtool_BamWriter_flush_257_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BamWriter::get_file_major_ver(void) const
 */
static PyObject *Dtool_BamWriter_get_file_major_ver_258(PyObject *self, PyObject *) {
  BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BamWriter::get_file_major_ver(void) const
  int return_value = (*(const BamWriter*)local_this).get_file_major_ver();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_get_file_major_ver_258_comment =
  "C++ Interface:\n"
  "get_file_major_ver(BamWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the major version number of the Bam file currently being written.\n"
  " */";
#else
static const char *Dtool_BamWriter_get_file_major_ver_258_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BamWriter::get_file_minor_ver(void) const
 */
static PyObject *Dtool_BamWriter_get_file_minor_ver_259(PyObject *self, PyObject *) {
  BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BamWriter::get_file_minor_ver(void) const
  int return_value = (*(const BamWriter*)local_this).get_file_minor_ver();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_get_file_minor_ver_259_comment =
  "C++ Interface:\n"
  "get_file_minor_ver(BamWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the minor version number of the Bam file currently being written.\n"
  " */";
#else
static const char *Dtool_BamWriter_get_file_minor_ver_259_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BamWriter::set_file_minor_ver(int minor_ver)
 */
static PyObject *Dtool_BamWriter_set_file_minor_ver_260(PyObject *self, PyObject *arg) {
  BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.set_file_minor_ver")) {
    return NULL;
  }
  // 1-inline void BamWriter::set_file_minor_ver(int minor_ver)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_file_minor_ver((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_file_minor_ver(const BamWriter self, int minor_ver)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_set_file_minor_ver_260_comment =
  "C++ Interface:\n"
  "set_file_minor_ver(const BamWriter self, int minor_ver)\n"
  "\n"
  "/**\n"
  " * Changes the minor .bam version to write.  This should be called before\n"
  " * init().  Each Panda version has only a fairly narrow range of versions it\n"
  " * is able to write; consult the .bam documentation for more information.\n"
  " */";
#else
static const char *Dtool_BamWriter_set_file_minor_ver_260_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BamEnums::BamEndian BamWriter::get_file_endian(void) const
 */
static PyObject *Dtool_BamWriter_get_file_endian_261(PyObject *self, PyObject *) {
  BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BamEnums::BamEndian BamWriter::get_file_endian(void) const
  BamEnums::BamEndian return_value = (*(const BamWriter*)local_this).get_file_endian();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_get_file_endian_261_comment =
  "C++ Interface:\n"
  "get_file_endian(BamWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the endian preference indicated by the Bam file currently being\n"
  " * written.  This does not imply that every number is stored using the\n"
  " * indicated convention, but individual objects may choose to respect this\n"
  " * flag when recording data.\n"
  " */";
#else
static const char *Dtool_BamWriter_get_file_endian_261_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BamWriter::get_file_stdfloat_double(void) const
 */
static PyObject *Dtool_BamWriter_get_file_stdfloat_double_262(PyObject *self, PyObject *) {
  BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BamWriter::get_file_stdfloat_double(void) const
  bool return_value = (*(const BamWriter*)local_this).get_file_stdfloat_double();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_get_file_stdfloat_double_262_comment =
  "C++ Interface:\n"
  "get_file_stdfloat_double(BamWriter self)\n"
  "\n"
  "/**\n"
  " * Returns true if the file will store all \"standard\" floats as 64-bit\n"
  " * doubles, or false if they are 32-bit floats.  This isn't runtime settable;\n"
  " * it's based on the compilation flags of the version of Panda that generated\n"
  " * this file.\n"
  " */";
#else
static const char *Dtool_BamWriter_get_file_stdfloat_double_262_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BamEnums::BamTextureMode BamWriter::get_file_texture_mode(void) const
 */
static PyObject *Dtool_BamWriter_get_file_texture_mode_263(PyObject *self, PyObject *) {
  BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BamEnums::BamTextureMode BamWriter::get_file_texture_mode(void) const
  BamEnums::BamTextureMode return_value = (*(const BamWriter*)local_this).get_file_texture_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_get_file_texture_mode_263_comment =
  "C++ Interface:\n"
  "get_file_texture_mode(BamWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the BamTextureMode preference indicated by the Bam file currently\n"
  " * being written.  Texture objects written to this Bam file will be encoded\n"
  " * according to the specified mode.\n"
  " */";
#else
static const char *Dtool_BamWriter_get_file_texture_mode_263_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BamWriter::set_file_texture_mode(BamEnums::BamTextureMode file_texture_mode)
 */
static PyObject *Dtool_BamWriter_set_file_texture_mode_264(PyObject *self, PyObject *arg) {
  BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.set_file_texture_mode")) {
    return NULL;
  }
  // 1-inline void BamWriter::set_file_texture_mode(BamEnums::BamTextureMode file_texture_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_file_texture_mode((BamEnums::BamTextureMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_file_texture_mode(const BamWriter self, int file_texture_mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_set_file_texture_mode_264_comment =
  "C++ Interface:\n"
  "set_file_texture_mode(const BamWriter self, int file_texture_mode)\n"
  "\n"
  "/**\n"
  " * Changes the BamTextureMode preference for the Bam file currently being\n"
  " * written.  Texture objects written to this Bam file will be encoded\n"
  " * according to the specified mode.\n"
  " */";
#else
static const char *Dtool_BamWriter_set_file_texture_mode_264_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TypedWritable *BamWriter::get_root_node(void) const
 */
static PyObject *Dtool_BamWriter_get_root_node_265(PyObject *self, PyObject *) {
  BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline TypedWritable *BamWriter::get_root_node(void) const
  TypedWritable *return_value = (*(const BamWriter*)local_this).get_root_node();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritable, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_get_root_node_265_comment =
  "C++ Interface:\n"
  "get_root_node(BamWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the root node of the part of the scene graph we are currently\n"
  " * writing out.  This is used for determining what to make NodePaths relative\n"
  " * to.\n"
  " */";
#else
static const char *Dtool_BamWriter_get_root_node_265_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BamWriter::set_root_node(TypedWritable *root_node)
 */
static PyObject *Dtool_BamWriter_set_root_node_266(PyObject *self, PyObject *arg) {
  BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.set_root_node")) {
    return NULL;
  }
  // 1-inline void BamWriter::set_root_node(TypedWritable *root_node)
  TypedWritable *arg_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedWritable, 1, "BamWriter.set_root_node", false, true);
  if (arg_this != NULL) {
    (*local_this).set_root_node(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_root_node(const BamWriter self, TypedWritable root_node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_set_root_node_266_comment =
  "C++ Interface:\n"
  "set_root_node(const BamWriter self, TypedWritable root_node)\n"
  "\n"
  "/**\n"
  " * Sets the root node of the part of the scene graph we are currently writing\n"
  " * out.  NodePaths written to this bam file will be relative to this node.\n"
  " */";
#else
static const char *Dtool_BamWriter_set_root_node_266_comment = NULL;
#endif

static PyObject *Dtool_BamWriter_target_Getter(PyObject *self, void *) {
  BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.target")) {
    return NULL;
  }

  // 1-inline DatagramSink *BamWriter::get_target(void)
  DatagramSink *return_value = (*local_this).get_target();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DatagramSink, false, false);
}

static int Dtool_BamWriter_target_Setter(PyObject *self, PyObject *arg, void *) {
  BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.target")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete target attribute");
    return -1;
  }
  // 1-void BamWriter::set_target(DatagramSink *target)
  DatagramSink *arg_this = (DatagramSink *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DatagramSink, 1, "BamWriter.set_target", false, true);
  if (arg_this != NULL) {
    (*local_this).set_target(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_target(const BamWriter self, DatagramSink target)\n");
  }
  return -1;
}

static PyObject *Dtool_BamWriter_filename_Getter(PyObject *self, void *) {
  const BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamWriter, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline Filename const &BamWriter::get_filename(void) const
  Filename const *return_value = &((*(const BamWriter*)local_this).get_filename());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static PyObject *Dtool_BamWriter_file_endian_Getter(PyObject *self, void *) {
  const BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamWriter, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline BamEnums::BamEndian BamWriter::get_file_endian(void) const
  BamEnums::BamEndian return_value = (*(const BamWriter*)local_this).get_file_endian();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_BamWriter_file_stdfloat_double_Getter(PyObject *self, void *) {
  const BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamWriter, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool BamWriter::get_file_stdfloat_double(void) const
  bool return_value = (*(const BamWriter*)local_this).get_file_stdfloat_double();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_BamWriter_file_texture_mode_Getter(PyObject *self, void *) {
  const BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamWriter, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline BamEnums::BamTextureMode BamWriter::get_file_texture_mode(void) const
  BamEnums::BamTextureMode return_value = (*(const BamWriter*)local_this).get_file_texture_mode();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_BamWriter_root_node_Getter(PyObject *self, void *) {
  const BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamWriter, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline TypedWritable *BamWriter::get_root_node(void) const
  TypedWritable *return_value = (*(const BamWriter*)local_this).get_root_node();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritable, false, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_BamWriter_root_node_Setter(PyObject *self, PyObject *arg, void *) {
  BamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.root_node")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete root_node attribute");
    return -1;
  }
  // 1-inline void BamWriter::set_root_node(TypedWritable *root_node)
  TypedWritable *arg_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedWritable, 1, "BamWriter.set_root_node", false, true);
  if (arg_this != NULL) {
    (*local_this).set_root_node(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_root_node(const BamWriter self, TypedWritable root_node)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline BamWriter::BamWriter(BamWriter const &) = default
 * BamWriter::BamWriter(DatagramSink *target = 0)
 */
static int Dtool_Init_BamWriter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-BamWriter::BamWriter(DatagramSink *target)
      BamWriter *return_value = new BamWriter();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BamWriter, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline BamWriter::BamWriter(BamWriter const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:BamWriter", (char **)keyword_list, &param0)) {
          BamWriter const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_BamWriter, (void **)&param0_this);
          if (param0_this != NULL) {
            BamWriter *return_value = new BamWriter(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BamWriter, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 BamWriter::BamWriter(DatagramSink *target)
        PyObject *param0;
        static const char *keyword_list[] = {"target", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:BamWriter", (char **)keyword_list, &param0)) {
          DatagramSink *param0_this = (DatagramSink *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_DatagramSink, 0, "BamWriter.BamWriter", false, false);
          if (param0_this != NULL) {
            BamWriter *return_value = new BamWriter(param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BamWriter, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline BamWriter::BamWriter(BamWriter const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:BamWriter", (char **)keyword_list, &param0)) {
          BamWriter const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_BamWriter(param0, param0_this, param0_manage)) {
            BamWriter *return_value = new BamWriter(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BamWriter, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: BamWriter::BamWriter(DatagramSink *target)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BamWriter() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BamWriter()\n"
      "BamWriter(const BamWriter param0)\n"
      "BamWriter(DatagramSink target)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BamWriter(PyObject *args, BamWriter const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BamWriter, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-BamWriter::BamWriter(DatagramSink *target)
    DatagramSink *arg_this = (DatagramSink *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DatagramSink, 0, "BamWriter.BamWriter", false, false);
    if (arg_this != NULL) {
      BamWriter *return_value = new BamWriter(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_BamWriter(PyObject *args, BamWriter *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BamWriter, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-BamWriter::BamWriter(DatagramSink *target)
    DatagramSink *arg_this = (DatagramSink *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DatagramSink, 0, "BamWriter.BamWriter", false, false);
    if (arg_this != NULL) {
      BamWriter *return_value = new BamWriter(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_BamWriter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BamWriter) {
    printf("BamWriter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BamWriter *local_this = (BamWriter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BamWriter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BamEnums) {
    return (BamEnums *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BamWriter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BamWriter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BamEnums) {
    BamEnums* other_this = (BamEnums*)from_this;
    return (BamWriter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BitMask< uint16_t, 16 >
 */
/**
 * Python function wrapper for:
 * inline BitMask< uint16_t, 16 > &BitMask< uint16_t, 16 >::operator =(BitMask< uint16_t, 16 > const &copy)
 */
static PyObject *Dtool_BitMask_uint16_t_16_operator_277(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.assign")) {
    return NULL;
  }
  // 1-inline BitMask< uint16_t, 16 > &BitMask< uint16_t, 16 >::operator =(BitMask< uint16_t, 16 > const &copy)
  BitMask< uint16_t, 16 > arg_local;
  BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.assign", "BitMask");
  }
  (*local_this).operator =(*arg_this);
  BitMask< uint16_t, 16 > *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const BitMask self, const BitMask copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_operator_277_comment =
  "C++ Interface:\n"
  "assign(const BitMask self, const BitMask copy)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_operator_277_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::all_on(void)
 */
static PyObject *Dtool_BitMask_uint16_t_16_all_on_278(PyObject *, PyObject *) {
  // 1-static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::all_on(void)
  BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(BitMask< uint16_t, 16 >::all_on());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_all_on_278_comment =
  "C++ Interface:\n"
  "all_on()\n";
#else
static const char *Dtool_BitMask_uint16_t_16_all_on_278_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::all_off(void)
 */
static PyObject *Dtool_BitMask_uint16_t_16_all_off_279(PyObject *, PyObject *) {
  // 1-static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::all_off(void)
  BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(BitMask< uint16_t, 16 >::all_off());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_all_off_279_comment =
  "C++ Interface:\n"
  "all_off()\n";
#else
static const char *Dtool_BitMask_uint16_t_16_all_off_279_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::lower_on(int on_bits)
 */
static PyObject *Dtool_BitMask_uint16_t_16_lower_on_280(PyObject *, PyObject *arg) {
  // 1-static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::lower_on(int on_bits)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(BitMask< uint16_t, 16 >::lower_on((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lower_on(int on_bits)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_lower_on_280_comment =
  "C++ Interface:\n"
  "lower_on(int on_bits)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_lower_on_280_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::bit(int index)
 */
static PyObject *Dtool_BitMask_uint16_t_16_bit_281(PyObject *, PyObject *arg) {
  // 1-static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(BitMask< uint16_t, 16 >::bit((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bit(int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_bit_281_comment =
  "C++ Interface:\n"
  "bit(int index)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_bit_281_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::range(int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint16_t_16_range_282(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::range(int low_bit, int size)
  int param0;
  int param1;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:range", (char **)keyword_list, &param0, &param1)) {
    BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(BitMask< uint16_t, 16 >::range((int)param0, (int)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "range(int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_range_282_comment =
  "C++ Interface:\n"
  "range(int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_range_282_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr bool BitMask< uint16_t, 16 >::has_max_num_bits(void)
 */
static PyObject *Dtool_BitMask_uint16_t_16_has_max_num_bits_284(PyObject *, PyObject *) {
  // 1-static constexpr bool BitMask< uint16_t, 16 >::has_max_num_bits(void)
  bool return_value = BitMask< uint16_t, 16 >::has_max_num_bits();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_has_max_num_bits_284_comment =
  "C++ Interface:\n"
  "has_max_num_bits()\n";
#else
static const char *Dtool_BitMask_uint16_t_16_has_max_num_bits_284_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int BitMask< uint16_t, 16 >::get_max_num_bits(void)
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_max_num_bits_285(PyObject *, PyObject *) {
  // 1-static constexpr int BitMask< uint16_t, 16 >::get_max_num_bits(void)
  int return_value = BitMask< uint16_t, 16 >::get_max_num_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_max_num_bits_285_comment =
  "C++ Interface:\n"
  "get_max_num_bits()\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_max_num_bits_285_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int BitMask< uint16_t, 16 >::get_num_bits(void)
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_num_bits_286(PyObject *, PyObject *) {
  // 1-static constexpr int BitMask< uint16_t, 16 >::get_num_bits(void)
  int return_value = BitMask< uint16_t, 16 >::get_num_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_num_bits_286_comment =
  "C++ Interface:\n"
  "get_num_bits()\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_num_bits_286_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint16_t, 16 >::get_bit(int index) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_bit_287(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitMask< uint16_t, 16 >::get_bit(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const BitMask< uint16_t, 16 >*)local_this).get_bit((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bit(BitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_bit_287_comment =
  "C++ Interface:\n"
  "get_bit(BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_bit_287_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::set_bit(int index)
 */
static PyObject *Dtool_BitMask_uint16_t_16_set_bit_288(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.set_bit")) {
    return NULL;
  }
  // 1-inline void BitMask< uint16_t, 16 >::set_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_bit((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit(const BitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_set_bit_288_comment =
  "C++ Interface:\n"
  "set_bit(const BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_set_bit_288_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::clear_bit(int index)
 */
static PyObject *Dtool_BitMask_uint16_t_16_clear_bit_289(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.clear_bit")) {
    return NULL;
  }
  // 1-inline void BitMask< uint16_t, 16 >::clear_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).clear_bit((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_bit(const BitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_clear_bit_289_comment =
  "C++ Interface:\n"
  "clear_bit(const BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_clear_bit_289_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::set_bit_to(int index, bool value)
 */
static PyObject *Dtool_BitMask_uint16_t_16_set_bit_to_290(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.set_bit_to")) {
    return NULL;
  }
  // 1-inline void BitMask< uint16_t, 16 >::set_bit_to(int index, bool value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_bit_to", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_bit_to((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit_to(const BitMask self, int index, bool value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_set_bit_to_290_comment =
  "C++ Interface:\n"
  "set_bit_to(const BitMask self, int index, bool value)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_set_bit_to_290_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint16_t, 16 >::is_zero(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_is_zero_291(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitMask< uint16_t, 16 >::is_zero(void) const
  bool return_value = (*(const BitMask< uint16_t, 16 >*)local_this).is_zero();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_is_zero_291_comment =
  "C++ Interface:\n"
  "is_zero(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_is_zero_291_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint16_t, 16 >::is_all_on(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_is_all_on_292(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitMask< uint16_t, 16 >::is_all_on(void) const
  bool return_value = (*(const BitMask< uint16_t, 16 >*)local_this).is_all_on();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_is_all_on_292_comment =
  "C++ Interface:\n"
  "is_all_on(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_is_all_on_292_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint16_t BitMask< uint16_t, 16 >::extract(int low_bit, int size) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_extract_293(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline uint16_t BitMask< uint16_t, 16 >::extract(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:extract", (char **)keyword_list, &param1, &param2)) {
    uint16_t return_value = (*(const BitMask< uint16_t, 16 >*)local_this).extract((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract(BitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_extract_293_comment =
  "C++ Interface:\n"
  "extract(BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_extract_293_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::store(uint16_t value, int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint16_t_16_store_294(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.store")) {
    return NULL;
  }
  // 1-inline void BitMask< uint16_t, 16 >::store(uint16_t value, int low_bit, int size)
  long param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "lii:store", (char **)keyword_list, &param1, &param2, &param3)) {
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    (*local_this).store((uint16_t)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store(const BitMask self, int value, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_store_294_comment =
  "C++ Interface:\n"
  "store(const BitMask self, int value, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_store_294_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint16_t, 16 >::has_any_of(int low_bit, int size) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_has_any_of_295(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitMask< uint16_t, 16 >::has_any_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_any_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*(const BitMask< uint16_t, 16 >*)local_this).has_any_of((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_any_of(BitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_has_any_of_295_comment =
  "C++ Interface:\n"
  "has_any_of(BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_has_any_of_295_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint16_t, 16 >::has_all_of(int low_bit, int size) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_has_all_of_296(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitMask< uint16_t, 16 >::has_all_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_all_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*(const BitMask< uint16_t, 16 >*)local_this).has_all_of((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_all_of(BitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_has_all_of_296_comment =
  "C++ Interface:\n"
  "has_all_of(BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_has_all_of_296_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::set_range(int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint16_t_16_set_range_297(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.set_range")) {
    return NULL;
  }
  // 1-inline void BitMask< uint16_t, 16 >::set_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_range", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_range((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range(const BitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_set_range_297_comment =
  "C++ Interface:\n"
  "set_range(const BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_set_range_297_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::clear_range(int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint16_t_16_clear_range_298(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.clear_range")) {
    return NULL;
  }
  // 1-inline void BitMask< uint16_t, 16 >::clear_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:clear_range", (char **)keyword_list, &param1, &param2)) {
    (*local_this).clear_range((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_range(const BitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_clear_range_298_comment =
  "C++ Interface:\n"
  "clear_range(const BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_clear_range_298_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::set_range_to(bool value, int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint16_t_16_set_range_to_299(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.set_range_to")) {
    return NULL;
  }
  // 1-inline void BitMask< uint16_t, 16 >::set_range_to(bool value, int low_bit, int size)
  PyObject *param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_range_to", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_range_to((PyObject_IsTrue(param1) != 0), (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range_to(const BitMask self, bool value, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_set_range_to_299_comment =
  "C++ Interface:\n"
  "set_range_to(const BitMask self, bool value, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_set_range_to_299_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint16_t BitMask< uint16_t, 16 >::get_word(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_word_300(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline uint16_t BitMask< uint16_t, 16 >::get_word(void) const
  uint16_t return_value = (*(const BitMask< uint16_t, 16 >*)local_this).get_word();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_word_300_comment =
  "C++ Interface:\n"
  "get_word(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_word_300_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::set_word(uint16_t value)
 */
static PyObject *Dtool_BitMask_uint16_t_16_set_word_301(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.set_word")) {
    return NULL;
  }
  // 1-inline void BitMask< uint16_t, 16 >::set_word(uint16_t value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    (*local_this).set_word((uint16_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const BitMask self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_set_word_301_comment =
  "C++ Interface:\n"
  "set_word(const BitMask self, int value)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_set_word_301_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint16_t, 16 >::get_num_on_bits(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_num_on_bits_302(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint16_t, 16 >::get_num_on_bits(void) const
  int return_value = (*(const BitMask< uint16_t, 16 >*)local_this).get_num_on_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_num_on_bits_302_comment =
  "C++ Interface:\n"
  "get_num_on_bits(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_num_on_bits_302_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint16_t, 16 >::get_num_off_bits(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_num_off_bits_303(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint16_t, 16 >::get_num_off_bits(void) const
  int return_value = (*(const BitMask< uint16_t, 16 >*)local_this).get_num_off_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_num_off_bits_303_comment =
  "C++ Interface:\n"
  "get_num_off_bits(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_num_off_bits_303_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint16_t, 16 >::get_lowest_on_bit(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_lowest_on_bit_304(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint16_t, 16 >::get_lowest_on_bit(void) const
  int return_value = (*(const BitMask< uint16_t, 16 >*)local_this).get_lowest_on_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_lowest_on_bit_304_comment =
  "C++ Interface:\n"
  "get_lowest_on_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_lowest_on_bit_304_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint16_t, 16 >::get_lowest_off_bit(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_lowest_off_bit_305(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint16_t, 16 >::get_lowest_off_bit(void) const
  int return_value = (*(const BitMask< uint16_t, 16 >*)local_this).get_lowest_off_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_lowest_off_bit_305_comment =
  "C++ Interface:\n"
  "get_lowest_off_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_lowest_off_bit_305_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint16_t, 16 >::get_highest_on_bit(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_highest_on_bit_306(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint16_t, 16 >::get_highest_on_bit(void) const
  int return_value = (*(const BitMask< uint16_t, 16 >*)local_this).get_highest_on_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_highest_on_bit_306_comment =
  "C++ Interface:\n"
  "get_highest_on_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_highest_on_bit_306_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint16_t, 16 >::get_highest_off_bit(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_highest_off_bit_307(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint16_t, 16 >::get_highest_off_bit(void) const
  int return_value = (*(const BitMask< uint16_t, 16 >*)local_this).get_highest_off_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_highest_off_bit_307_comment =
  "C++ Interface:\n"
  "get_highest_off_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_highest_off_bit_307_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint16_t, 16 >::get_next_higher_different_bit(int low_bit) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_next_higher_different_bit_308(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint16_t, 16 >::get_next_higher_different_bit(int low_bit) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const BitMask< uint16_t, 16 >*)local_this).get_next_higher_different_bit((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_next_higher_different_bit(BitMask self, int low_bit)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_next_higher_different_bit_308_comment =
  "C++ Interface:\n"
  "get_next_higher_different_bit(BitMask self, int low_bit)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_next_higher_different_bit_308_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::invert_in_place(void)
 */
static PyObject *Dtool_BitMask_uint16_t_16_invert_in_place_309(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.invert_in_place")) {
    return NULL;
  }
  // 1-inline void BitMask< uint16_t, 16 >::invert_in_place(void)
  (*local_this).invert_in_place();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_invert_in_place_309_comment =
  "C++ Interface:\n"
  "invert_in_place(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_invert_in_place_309_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint16_t, 16 >::has_bits_in_common(BitMask< uint16_t, 16 > const &other) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_has_bits_in_common_310(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitMask< uint16_t, 16 >::has_bits_in_common(BitMask< uint16_t, 16 > const &other) const
  BitMask< uint16_t, 16 > arg_local;
  BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.has_bits_in_common", "BitMask");
  }
  bool return_value = (*(const BitMask< uint16_t, 16 >*)local_this).has_bits_in_common(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_bits_in_common(BitMask self, const BitMask other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_has_bits_in_common_310_comment =
  "C++ Interface:\n"
  "has_bits_in_common(BitMask self, const BitMask other)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_has_bits_in_common_310_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::clear(void)
 */
static PyObject *Dtool_BitMask_uint16_t_16_clear_311(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.clear")) {
    return NULL;
  }
  // 1-inline void BitMask< uint16_t, 16 >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_clear_311_comment =
  "C++ Interface:\n"
  "clear(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_clear_311_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint16_t, 16 >::output(ostream &out) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_output_312(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-void BitMask< uint16_t, 16 >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "BitMask.output", false, true);
  if (arg_this != NULL) {
    (*(const BitMask< uint16_t, 16 >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(BitMask self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_output_312_comment =
  "C++ Interface:\n"
  "output(BitMask self, ostream out)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_output_312_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint16_t, 16 >::output_binary(ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_output_binary_313(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-void BitMask< uint16_t, 16 >::output_binary(ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_binary", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BitMask.output_binary", false, true);
    if (param1_this != NULL) {
      (*(const BitMask< uint16_t, 16 >*)local_this).output_binary(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_binary(BitMask self, ostream out, int spaces_every)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_output_binary_313_comment =
  "C++ Interface:\n"
  "output_binary(BitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_output_binary_313_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint16_t, 16 >::output_hex(ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_output_hex_314(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-void BitMask< uint16_t, 16 >::output_hex(ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_hex", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BitMask.output_hex", false, true);
    if (param1_this != NULL) {
      (*(const BitMask< uint16_t, 16 >*)local_this).output_hex(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_hex(BitMask self, ostream out, int spaces_every)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_output_hex_314_comment =
  "C++ Interface:\n"
  "output_hex(BitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_output_hex_314_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint16_t, 16 >::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_write_315(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-void BitMask< uint16_t, 16 >::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BitMask.write", false, true);
    if (param1_this != NULL) {
      (*(const BitMask< uint16_t, 16 >*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(BitMask self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_write_315_comment =
  "C++ Interface:\n"
  "write(BitMask self, ostream out, int indent_level)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_write_315_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint16_t, 16 >::compare_to(BitMask< uint16_t, 16 > const &other) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_compare_to_319(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint16_t, 16 >::compare_to(BitMask< uint16_t, 16 > const &other) const
  BitMask< uint16_t, 16 > arg_local;
  BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.compare_to", "BitMask");
  }
  int return_value = (*(const BitMask< uint16_t, 16 >*)local_this).compare_to(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(BitMask self, const BitMask other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_compare_to_319_comment =
  "C++ Interface:\n"
  "compare_to(BitMask self, const BitMask other)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_compare_to_319_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::operator |=(BitMask< uint16_t, 16 > const &other)
 */
static PyObject *Dtool_BitMask_uint16_t_16_operator_327(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.__ior__")) {
    return NULL;
  }
  // 1-inline void BitMask< uint16_t, 16 >::operator |=(BitMask< uint16_t, 16 > const &other)
  BitMask< uint16_t, 16 > arg_local;
  BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__ior__", "BitMask");
  }
  (*local_this).operator |=(*arg_this);
  BitMask< uint16_t, 16 > *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__ior__(const BitMask self, const BitMask other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_operator_327_comment =
  "C++ Interface:\n"
  "__ior__(const BitMask self, const BitMask other)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_operator_327_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::flood_down_in_place(void)
 */
static PyObject *Dtool_BitMask_uint16_t_16_flood_down_in_place_331(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.flood_down_in_place")) {
    return NULL;
  }
  // 1-inline void BitMask< uint16_t, 16 >::flood_down_in_place(void)
  (*local_this).flood_down_in_place();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_flood_down_in_place_331_comment =
  "C++ Interface:\n"
  "flood_down_in_place(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_flood_down_in_place_331_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::flood_up_in_place(void)
 */
static PyObject *Dtool_BitMask_uint16_t_16_flood_up_in_place_332(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.flood_up_in_place")) {
    return NULL;
  }
  // 1-inline void BitMask< uint16_t, 16 >::flood_up_in_place(void)
  (*local_this).flood_up_in_place();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_flood_up_in_place_332_comment =
  "C++ Interface:\n"
  "flood_up_in_place(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_flood_up_in_place_332_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::flood_bits_down(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_flood_bits_down_333(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::flood_bits_down(void) const
  BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((*(const BitMask< uint16_t, 16 >*)local_this).flood_bits_down());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_flood_bits_down_333_comment =
  "C++ Interface:\n"
  "flood_bits_down(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_flood_bits_down_333_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::flood_bits_up(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_flood_bits_up_334(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::flood_bits_up(void) const
  BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((*(const BitMask< uint16_t, 16 >*)local_this).flood_bits_up());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_flood_bits_up_334_comment =
  "C++ Interface:\n"
  "flood_bits_up(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_flood_bits_up_334_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(void) const
 * inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(BitMask< uint16_t, 16 > const &other) const
 * inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(int index) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_keep_next_highest_bit_335(PyObject *self, PyObject *args) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(void) const
      BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((*(const BitMask< uint16_t, 16 >*)local_this).keep_next_highest_bit());
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      {
        // -2 inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(BitMask< uint16_t, 16 > const &other) const
        BitMask< uint16_t, 16 > const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_BitMask_uint16_t_16, (void **)&arg_this);
        if (arg_this != NULL) {
          BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((*(const BitMask< uint16_t, 16 >*)local_this).keep_next_highest_bit(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
        }
      }

      {
        // -2 inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(int index) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((*(const BitMask< uint16_t, 16 >*)local_this).keep_next_highest_bit((int)arg_val));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
        }
      }

      {
        // -2 inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(BitMask< uint16_t, 16 > const &other) const
        BitMask< uint16_t, 16 > arg_local;
        BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
        if ((arg_this != NULL)) {
          BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((*(const BitMask< uint16_t, 16 >*)local_this).keep_next_highest_bit(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
        }
      }

      // No coercion possible: inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(int index) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "keep_next_highest_bit() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "keep_next_highest_bit(BitMask self)\n"
      "keep_next_highest_bit(BitMask self, const BitMask other)\n"
      "keep_next_highest_bit(BitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_keep_next_highest_bit_335_comment =
  "C++ Interface:\n"
  "keep_next_highest_bit(BitMask self)\n"
  "keep_next_highest_bit(BitMask self, const BitMask other)\n"
  "keep_next_highest_bit(BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_keep_next_highest_bit_335_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(void) const
 * inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(BitMask< uint16_t, 16 > const &other) const
 * inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(int index) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_keep_next_lowest_bit_336(PyObject *self, PyObject *args) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(void) const
      BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((*(const BitMask< uint16_t, 16 >*)local_this).keep_next_lowest_bit());
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      {
        // -2 inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(BitMask< uint16_t, 16 > const &other) const
        BitMask< uint16_t, 16 > const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_BitMask_uint16_t_16, (void **)&arg_this);
        if (arg_this != NULL) {
          BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((*(const BitMask< uint16_t, 16 >*)local_this).keep_next_lowest_bit(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
        }
      }

      {
        // -2 inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(int index) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((*(const BitMask< uint16_t, 16 >*)local_this).keep_next_lowest_bit((int)arg_val));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
        }
      }

      {
        // -2 inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(BitMask< uint16_t, 16 > const &other) const
        BitMask< uint16_t, 16 > arg_local;
        BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
        if ((arg_this != NULL)) {
          BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((*(const BitMask< uint16_t, 16 >*)local_this).keep_next_lowest_bit(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
        }
      }

      // No coercion possible: inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(int index) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "keep_next_lowest_bit() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "keep_next_lowest_bit(BitMask self)\n"
      "keep_next_lowest_bit(BitMask self, const BitMask other)\n"
      "keep_next_lowest_bit(BitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_keep_next_lowest_bit_336_comment =
  "C++ Interface:\n"
  "keep_next_lowest_bit(BitMask self)\n"
  "keep_next_lowest_bit(BitMask self, const BitMask other)\n"
  "keep_next_lowest_bit(BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_keep_next_lowest_bit_336_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint16_t, 16 >::get_key(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_key_337(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint16_t, 16 >::get_key(void) const
  int return_value = (*(const BitMask< uint16_t, 16 >*)local_this).get_key();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_key_337_comment =
  "C++ Interface:\n"
  "get_key(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_key_337_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BitMask< uint16_t, 16 >::get_class_type(void)
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_class_type_339(PyObject *, PyObject *) {
  // 1-static TypeHandle BitMask< uint16_t, 16 >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BitMask< uint16_t, 16 >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_class_type_339_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_class_type_339_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint16_t, 16 >::BitMask(void)
 * inline BitMask< uint16_t, 16 >::BitMask(BitMask< uint16_t, 16 > const &copy)
 * inline BitMask< uint16_t, 16 >::BitMask(uint16_t init_value)
 */
static int Dtool_Init_BitMask_uint16_t_16(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BitMask< uint16_t, 16 >::BitMask(void)
      BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint16_t_16, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline BitMask< uint16_t, 16 >::BitMask(BitMask< uint16_t, 16 > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:BitMask", (char **)keyword_list, &param0)) {
          BitMask< uint16_t, 16 > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_BitMask_uint16_t_16, (void **)&param0_this);
          if (param0_this != NULL) {
            BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint16_t_16, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline BitMask< uint16_t, 16 >::BitMask(uint16_t init_value)
        long param0;
        static const char *keyword_list[] = {"init_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "l:BitMask", (char **)keyword_list, &param0)) {
#ifndef NDEBUG
          if (param0 < 0 || param0 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param0);
            return -1;
          }
#endif
          BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((uint16_t)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint16_t_16, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline BitMask< uint16_t, 16 >::BitMask(BitMask< uint16_t, 16 > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:BitMask", (char **)keyword_list, &param0)) {
          BitMask< uint16_t, 16 > param0_local;
          BitMask< uint16_t, 16 > const *param0_this = Dtool_Coerce_BitMask_uint16_t_16(param0, param0_local);
          if ((param0_this != NULL)) {
            BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint16_t_16, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline BitMask< uint16_t, 16 >::BitMask(uint16_t init_value)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BitMask() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BitMask()\n"
      "BitMask(const BitMask copy)\n"
      "BitMask(int init_value)\n");
  }
  return -1;
}

BitMask< uint16_t, 16 > *Dtool_Coerce_BitMask_uint16_t_16(PyObject *args, BitMask< uint16_t, 16 > &coerced) {
  BitMask< uint16_t, 16 > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BitMask_uint16_t_16, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const BitMask< uint16_t, 16 > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline BitMask< uint16_t, 16 >::BitMask(uint16_t init_value)
    if (PyLongOrInt_Check(arg)) {
      long param0 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param0 < 0 || param0 > USHRT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for unsigned short integer",
                     param0);
        return NULL;
      }
#endif
      coerced = BitMask< uint16_t, 16 >((uint16_t)param0);
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  }
  return NULL;
}

static void *Dtool_UpcastInterface_BitMask_uint16_t_16(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BitMask_uint16_t_16) {
    printf("BitMask_uint16_t_16 ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BitMask< uint16_t, 16 > *local_this = (BitMask< uint16_t, 16 > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BitMask_uint16_t_16) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BitMask_uint16_t_16(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BitMask_uint16_t_16) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BitMask< uint32_t, 32 >
 */
/**
 * Python function wrapper for:
 * inline BitMask< uint32_t, 32 > &BitMask< uint32_t, 32 >::operator =(BitMask< uint32_t, 32 > const &copy)
 */
static PyObject *Dtool_BitMask_uint32_t_32_operator_343(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.assign")) {
    return NULL;
  }
  // 1-inline BitMask< uint32_t, 32 > &BitMask< uint32_t, 32 >::operator =(BitMask< uint32_t, 32 > const &copy)
  BitMask< uint32_t, 32 > arg_local;
  BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.assign", "BitMask");
  }
  (*local_this).operator =(*arg_this);
  BitMask< uint32_t, 32 > *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const BitMask self, const BitMask copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_operator_343_comment =
  "C++ Interface:\n"
  "assign(const BitMask self, const BitMask copy)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_operator_343_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::all_on(void)
 */
static PyObject *Dtool_BitMask_uint32_t_32_all_on_344(PyObject *, PyObject *) {
  // 1-static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::all_on(void)
  BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(BitMask< uint32_t, 32 >::all_on());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_all_on_344_comment =
  "C++ Interface:\n"
  "all_on()\n";
#else
static const char *Dtool_BitMask_uint32_t_32_all_on_344_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::all_off(void)
 */
static PyObject *Dtool_BitMask_uint32_t_32_all_off_345(PyObject *, PyObject *) {
  // 1-static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::all_off(void)
  BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(BitMask< uint32_t, 32 >::all_off());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_all_off_345_comment =
  "C++ Interface:\n"
  "all_off()\n";
#else
static const char *Dtool_BitMask_uint32_t_32_all_off_345_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::lower_on(int on_bits)
 */
static PyObject *Dtool_BitMask_uint32_t_32_lower_on_346(PyObject *, PyObject *arg) {
  // 1-static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::lower_on(int on_bits)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(BitMask< uint32_t, 32 >::lower_on((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lower_on(int on_bits)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_lower_on_346_comment =
  "C++ Interface:\n"
  "lower_on(int on_bits)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_lower_on_346_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::bit(int index)
 */
static PyObject *Dtool_BitMask_uint32_t_32_bit_347(PyObject *, PyObject *arg) {
  // 1-static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(BitMask< uint32_t, 32 >::bit((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bit(int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_bit_347_comment =
  "C++ Interface:\n"
  "bit(int index)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_bit_347_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::range(int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint32_t_32_range_348(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::range(int low_bit, int size)
  int param0;
  int param1;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:range", (char **)keyword_list, &param0, &param1)) {
    BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(BitMask< uint32_t, 32 >::range((int)param0, (int)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "range(int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_range_348_comment =
  "C++ Interface:\n"
  "range(int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_range_348_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr bool BitMask< uint32_t, 32 >::has_max_num_bits(void)
 */
static PyObject *Dtool_BitMask_uint32_t_32_has_max_num_bits_350(PyObject *, PyObject *) {
  // 1-static constexpr bool BitMask< uint32_t, 32 >::has_max_num_bits(void)
  bool return_value = BitMask< uint32_t, 32 >::has_max_num_bits();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_has_max_num_bits_350_comment =
  "C++ Interface:\n"
  "has_max_num_bits()\n";
#else
static const char *Dtool_BitMask_uint32_t_32_has_max_num_bits_350_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int BitMask< uint32_t, 32 >::get_max_num_bits(void)
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_max_num_bits_351(PyObject *, PyObject *) {
  // 1-static constexpr int BitMask< uint32_t, 32 >::get_max_num_bits(void)
  int return_value = BitMask< uint32_t, 32 >::get_max_num_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_max_num_bits_351_comment =
  "C++ Interface:\n"
  "get_max_num_bits()\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_max_num_bits_351_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int BitMask< uint32_t, 32 >::get_num_bits(void)
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_num_bits_352(PyObject *, PyObject *) {
  // 1-static constexpr int BitMask< uint32_t, 32 >::get_num_bits(void)
  int return_value = BitMask< uint32_t, 32 >::get_num_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_num_bits_352_comment =
  "C++ Interface:\n"
  "get_num_bits()\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_num_bits_352_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint32_t, 32 >::get_bit(int index) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_bit_353(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitMask< uint32_t, 32 >::get_bit(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const BitMask< uint32_t, 32 >*)local_this).get_bit((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bit(BitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_bit_353_comment =
  "C++ Interface:\n"
  "get_bit(BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_bit_353_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::set_bit(int index)
 */
static PyObject *Dtool_BitMask_uint32_t_32_set_bit_354(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.set_bit")) {
    return NULL;
  }
  // 1-inline void BitMask< uint32_t, 32 >::set_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_bit((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit(const BitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_set_bit_354_comment =
  "C++ Interface:\n"
  "set_bit(const BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_set_bit_354_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::clear_bit(int index)
 */
static PyObject *Dtool_BitMask_uint32_t_32_clear_bit_355(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.clear_bit")) {
    return NULL;
  }
  // 1-inline void BitMask< uint32_t, 32 >::clear_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).clear_bit((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_bit(const BitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_clear_bit_355_comment =
  "C++ Interface:\n"
  "clear_bit(const BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_clear_bit_355_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::set_bit_to(int index, bool value)
 */
static PyObject *Dtool_BitMask_uint32_t_32_set_bit_to_356(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.set_bit_to")) {
    return NULL;
  }
  // 1-inline void BitMask< uint32_t, 32 >::set_bit_to(int index, bool value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_bit_to", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_bit_to((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit_to(const BitMask self, int index, bool value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_set_bit_to_356_comment =
  "C++ Interface:\n"
  "set_bit_to(const BitMask self, int index, bool value)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_set_bit_to_356_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint32_t, 32 >::is_zero(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_is_zero_357(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitMask< uint32_t, 32 >::is_zero(void) const
  bool return_value = (*(const BitMask< uint32_t, 32 >*)local_this).is_zero();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_is_zero_357_comment =
  "C++ Interface:\n"
  "is_zero(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_is_zero_357_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint32_t, 32 >::is_all_on(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_is_all_on_358(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitMask< uint32_t, 32 >::is_all_on(void) const
  bool return_value = (*(const BitMask< uint32_t, 32 >*)local_this).is_all_on();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_is_all_on_358_comment =
  "C++ Interface:\n"
  "is_all_on(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_is_all_on_358_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint32_t BitMask< uint32_t, 32 >::extract(int low_bit, int size) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_extract_359(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline uint32_t BitMask< uint32_t, 32 >::extract(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:extract", (char **)keyword_list, &param1, &param2)) {
    uint32_t return_value = (*(const BitMask< uint32_t, 32 >*)local_this).extract((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract(BitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_extract_359_comment =
  "C++ Interface:\n"
  "extract(BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_extract_359_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::store(uint32_t value, int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint32_t_32_store_360(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.store")) {
    return NULL;
  }
  // 1-inline void BitMask< uint32_t, 32 >::store(uint32_t value, int low_bit, int size)
  unsigned long param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kii:store", (char **)keyword_list, &param1, &param2, &param3)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    (*local_this).store((uint32_t)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store(const BitMask self, int value, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_store_360_comment =
  "C++ Interface:\n"
  "store(const BitMask self, int value, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_store_360_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint32_t, 32 >::has_any_of(int low_bit, int size) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_has_any_of_361(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitMask< uint32_t, 32 >::has_any_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_any_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*(const BitMask< uint32_t, 32 >*)local_this).has_any_of((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_any_of(BitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_has_any_of_361_comment =
  "C++ Interface:\n"
  "has_any_of(BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_has_any_of_361_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint32_t, 32 >::has_all_of(int low_bit, int size) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_has_all_of_362(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitMask< uint32_t, 32 >::has_all_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_all_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*(const BitMask< uint32_t, 32 >*)local_this).has_all_of((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_all_of(BitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_has_all_of_362_comment =
  "C++ Interface:\n"
  "has_all_of(BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_has_all_of_362_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::set_range(int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint32_t_32_set_range_363(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.set_range")) {
    return NULL;
  }
  // 1-inline void BitMask< uint32_t, 32 >::set_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_range", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_range((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range(const BitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_set_range_363_comment =
  "C++ Interface:\n"
  "set_range(const BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_set_range_363_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::clear_range(int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint32_t_32_clear_range_364(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.clear_range")) {
    return NULL;
  }
  // 1-inline void BitMask< uint32_t, 32 >::clear_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:clear_range", (char **)keyword_list, &param1, &param2)) {
    (*local_this).clear_range((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_range(const BitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_clear_range_364_comment =
  "C++ Interface:\n"
  "clear_range(const BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_clear_range_364_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::set_range_to(bool value, int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint32_t_32_set_range_to_365(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.set_range_to")) {
    return NULL;
  }
  // 1-inline void BitMask< uint32_t, 32 >::set_range_to(bool value, int low_bit, int size)
  PyObject *param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_range_to", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_range_to((PyObject_IsTrue(param1) != 0), (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range_to(const BitMask self, bool value, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_set_range_to_365_comment =
  "C++ Interface:\n"
  "set_range_to(const BitMask self, bool value, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_set_range_to_365_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint32_t BitMask< uint32_t, 32 >::get_word(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_word_366(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline uint32_t BitMask< uint32_t, 32 >::get_word(void) const
  uint32_t return_value = (*(const BitMask< uint32_t, 32 >*)local_this).get_word();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_word_366_comment =
  "C++ Interface:\n"
  "get_word(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_word_366_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::set_word(uint32_t value)
 */
static PyObject *Dtool_BitMask_uint32_t_32_set_word_367(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.set_word")) {
    return NULL;
  }
  // 1-inline void BitMask< uint32_t, 32 >::set_word(uint32_t value)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    (*local_this).set_word((uint32_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const BitMask self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_set_word_367_comment =
  "C++ Interface:\n"
  "set_word(const BitMask self, int value)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_set_word_367_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint32_t, 32 >::get_num_on_bits(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_num_on_bits_368(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint32_t, 32 >::get_num_on_bits(void) const
  int return_value = (*(const BitMask< uint32_t, 32 >*)local_this).get_num_on_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_num_on_bits_368_comment =
  "C++ Interface:\n"
  "get_num_on_bits(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_num_on_bits_368_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint32_t, 32 >::get_num_off_bits(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_num_off_bits_369(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint32_t, 32 >::get_num_off_bits(void) const
  int return_value = (*(const BitMask< uint32_t, 32 >*)local_this).get_num_off_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_num_off_bits_369_comment =
  "C++ Interface:\n"
  "get_num_off_bits(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_num_off_bits_369_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint32_t, 32 >::get_lowest_on_bit(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_lowest_on_bit_370(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint32_t, 32 >::get_lowest_on_bit(void) const
  int return_value = (*(const BitMask< uint32_t, 32 >*)local_this).get_lowest_on_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_lowest_on_bit_370_comment =
  "C++ Interface:\n"
  "get_lowest_on_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_lowest_on_bit_370_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint32_t, 32 >::get_lowest_off_bit(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_lowest_off_bit_371(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint32_t, 32 >::get_lowest_off_bit(void) const
  int return_value = (*(const BitMask< uint32_t, 32 >*)local_this).get_lowest_off_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_lowest_off_bit_371_comment =
  "C++ Interface:\n"
  "get_lowest_off_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_lowest_off_bit_371_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint32_t, 32 >::get_highest_on_bit(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_highest_on_bit_372(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint32_t, 32 >::get_highest_on_bit(void) const
  int return_value = (*(const BitMask< uint32_t, 32 >*)local_this).get_highest_on_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_highest_on_bit_372_comment =
  "C++ Interface:\n"
  "get_highest_on_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_highest_on_bit_372_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint32_t, 32 >::get_highest_off_bit(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_highest_off_bit_373(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint32_t, 32 >::get_highest_off_bit(void) const
  int return_value = (*(const BitMask< uint32_t, 32 >*)local_this).get_highest_off_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_highest_off_bit_373_comment =
  "C++ Interface:\n"
  "get_highest_off_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_highest_off_bit_373_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint32_t, 32 >::get_next_higher_different_bit(int low_bit) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_next_higher_different_bit_374(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint32_t, 32 >::get_next_higher_different_bit(int low_bit) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const BitMask< uint32_t, 32 >*)local_this).get_next_higher_different_bit((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_next_higher_different_bit(BitMask self, int low_bit)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_next_higher_different_bit_374_comment =
  "C++ Interface:\n"
  "get_next_higher_different_bit(BitMask self, int low_bit)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_next_higher_different_bit_374_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::invert_in_place(void)
 */
static PyObject *Dtool_BitMask_uint32_t_32_invert_in_place_375(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.invert_in_place")) {
    return NULL;
  }
  // 1-inline void BitMask< uint32_t, 32 >::invert_in_place(void)
  (*local_this).invert_in_place();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_invert_in_place_375_comment =
  "C++ Interface:\n"
  "invert_in_place(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_invert_in_place_375_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint32_t, 32 >::has_bits_in_common(BitMask< uint32_t, 32 > const &other) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_has_bits_in_common_376(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitMask< uint32_t, 32 >::has_bits_in_common(BitMask< uint32_t, 32 > const &other) const
  BitMask< uint32_t, 32 > arg_local;
  BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.has_bits_in_common", "BitMask");
  }
  bool return_value = (*(const BitMask< uint32_t, 32 >*)local_this).has_bits_in_common(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_bits_in_common(BitMask self, const BitMask other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_has_bits_in_common_376_comment =
  "C++ Interface:\n"
  "has_bits_in_common(BitMask self, const BitMask other)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_has_bits_in_common_376_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::clear(void)
 */
static PyObject *Dtool_BitMask_uint32_t_32_clear_377(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.clear")) {
    return NULL;
  }
  // 1-inline void BitMask< uint32_t, 32 >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_clear_377_comment =
  "C++ Interface:\n"
  "clear(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_clear_377_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint32_t, 32 >::output(ostream &out) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_output_378(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-void BitMask< uint32_t, 32 >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "BitMask.output", false, true);
  if (arg_this != NULL) {
    (*(const BitMask< uint32_t, 32 >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(BitMask self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_output_378_comment =
  "C++ Interface:\n"
  "output(BitMask self, ostream out)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_output_378_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint32_t, 32 >::output_binary(ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_output_binary_379(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-void BitMask< uint32_t, 32 >::output_binary(ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_binary", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BitMask.output_binary", false, true);
    if (param1_this != NULL) {
      (*(const BitMask< uint32_t, 32 >*)local_this).output_binary(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_binary(BitMask self, ostream out, int spaces_every)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_output_binary_379_comment =
  "C++ Interface:\n"
  "output_binary(BitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_output_binary_379_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint32_t, 32 >::output_hex(ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_output_hex_380(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-void BitMask< uint32_t, 32 >::output_hex(ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_hex", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BitMask.output_hex", false, true);
    if (param1_this != NULL) {
      (*(const BitMask< uint32_t, 32 >*)local_this).output_hex(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_hex(BitMask self, ostream out, int spaces_every)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_output_hex_380_comment =
  "C++ Interface:\n"
  "output_hex(BitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_output_hex_380_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint32_t, 32 >::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_write_381(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-void BitMask< uint32_t, 32 >::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BitMask.write", false, true);
    if (param1_this != NULL) {
      (*(const BitMask< uint32_t, 32 >*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(BitMask self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_write_381_comment =
  "C++ Interface:\n"
  "write(BitMask self, ostream out, int indent_level)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_write_381_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint32_t, 32 >::compare_to(BitMask< uint32_t, 32 > const &other) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_compare_to_385(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint32_t, 32 >::compare_to(BitMask< uint32_t, 32 > const &other) const
  BitMask< uint32_t, 32 > arg_local;
  BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.compare_to", "BitMask");
  }
  int return_value = (*(const BitMask< uint32_t, 32 >*)local_this).compare_to(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(BitMask self, const BitMask other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_compare_to_385_comment =
  "C++ Interface:\n"
  "compare_to(BitMask self, const BitMask other)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_compare_to_385_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::operator |=(BitMask< uint32_t, 32 > const &other)
 */
static PyObject *Dtool_BitMask_uint32_t_32_operator_393(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.__ior__")) {
    return NULL;
  }
  // 1-inline void BitMask< uint32_t, 32 >::operator |=(BitMask< uint32_t, 32 > const &other)
  BitMask< uint32_t, 32 > arg_local;
  BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__ior__", "BitMask");
  }
  (*local_this).operator |=(*arg_this);
  BitMask< uint32_t, 32 > *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__ior__(const BitMask self, const BitMask other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_operator_393_comment =
  "C++ Interface:\n"
  "__ior__(const BitMask self, const BitMask other)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_operator_393_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::flood_down_in_place(void)
 */
static PyObject *Dtool_BitMask_uint32_t_32_flood_down_in_place_397(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.flood_down_in_place")) {
    return NULL;
  }
  // 1-inline void BitMask< uint32_t, 32 >::flood_down_in_place(void)
  (*local_this).flood_down_in_place();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_flood_down_in_place_397_comment =
  "C++ Interface:\n"
  "flood_down_in_place(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_flood_down_in_place_397_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::flood_up_in_place(void)
 */
static PyObject *Dtool_BitMask_uint32_t_32_flood_up_in_place_398(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.flood_up_in_place")) {
    return NULL;
  }
  // 1-inline void BitMask< uint32_t, 32 >::flood_up_in_place(void)
  (*local_this).flood_up_in_place();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_flood_up_in_place_398_comment =
  "C++ Interface:\n"
  "flood_up_in_place(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_flood_up_in_place_398_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::flood_bits_down(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_flood_bits_down_399(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::flood_bits_down(void) const
  BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((*(const BitMask< uint32_t, 32 >*)local_this).flood_bits_down());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_flood_bits_down_399_comment =
  "C++ Interface:\n"
  "flood_bits_down(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_flood_bits_down_399_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::flood_bits_up(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_flood_bits_up_400(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::flood_bits_up(void) const
  BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((*(const BitMask< uint32_t, 32 >*)local_this).flood_bits_up());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_flood_bits_up_400_comment =
  "C++ Interface:\n"
  "flood_bits_up(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_flood_bits_up_400_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(void) const
 * inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(BitMask< uint32_t, 32 > const &other) const
 * inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(int index) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_keep_next_highest_bit_401(PyObject *self, PyObject *args) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(void) const
      BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((*(const BitMask< uint32_t, 32 >*)local_this).keep_next_highest_bit());
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      {
        // -2 inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(BitMask< uint32_t, 32 > const &other) const
        BitMask< uint32_t, 32 > const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_BitMask_uint32_t_32, (void **)&arg_this);
        if (arg_this != NULL) {
          BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((*(const BitMask< uint32_t, 32 >*)local_this).keep_next_highest_bit(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
        }
      }

      {
        // -2 inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(int index) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((*(const BitMask< uint32_t, 32 >*)local_this).keep_next_highest_bit((int)arg_val));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
        }
      }

      {
        // -2 inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(BitMask< uint32_t, 32 > const &other) const
        BitMask< uint32_t, 32 > arg_local;
        BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
        if ((arg_this != NULL)) {
          BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((*(const BitMask< uint32_t, 32 >*)local_this).keep_next_highest_bit(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
        }
      }

      // No coercion possible: inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(int index) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "keep_next_highest_bit() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "keep_next_highest_bit(BitMask self)\n"
      "keep_next_highest_bit(BitMask self, const BitMask other)\n"
      "keep_next_highest_bit(BitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_keep_next_highest_bit_401_comment =
  "C++ Interface:\n"
  "keep_next_highest_bit(BitMask self)\n"
  "keep_next_highest_bit(BitMask self, const BitMask other)\n"
  "keep_next_highest_bit(BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_keep_next_highest_bit_401_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(void) const
 * inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(BitMask< uint32_t, 32 > const &other) const
 * inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(int index) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_keep_next_lowest_bit_402(PyObject *self, PyObject *args) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(void) const
      BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((*(const BitMask< uint32_t, 32 >*)local_this).keep_next_lowest_bit());
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      {
        // -2 inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(BitMask< uint32_t, 32 > const &other) const
        BitMask< uint32_t, 32 > const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_BitMask_uint32_t_32, (void **)&arg_this);
        if (arg_this != NULL) {
          BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((*(const BitMask< uint32_t, 32 >*)local_this).keep_next_lowest_bit(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
        }
      }

      {
        // -2 inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(int index) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((*(const BitMask< uint32_t, 32 >*)local_this).keep_next_lowest_bit((int)arg_val));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
        }
      }

      {
        // -2 inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(BitMask< uint32_t, 32 > const &other) const
        BitMask< uint32_t, 32 > arg_local;
        BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
        if ((arg_this != NULL)) {
          BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((*(const BitMask< uint32_t, 32 >*)local_this).keep_next_lowest_bit(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
        }
      }

      // No coercion possible: inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(int index) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "keep_next_lowest_bit() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "keep_next_lowest_bit(BitMask self)\n"
      "keep_next_lowest_bit(BitMask self, const BitMask other)\n"
      "keep_next_lowest_bit(BitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_keep_next_lowest_bit_402_comment =
  "C++ Interface:\n"
  "keep_next_lowest_bit(BitMask self)\n"
  "keep_next_lowest_bit(BitMask self, const BitMask other)\n"
  "keep_next_lowest_bit(BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_keep_next_lowest_bit_402_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint32_t, 32 >::get_key(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_key_403(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint32_t, 32 >::get_key(void) const
  int return_value = (*(const BitMask< uint32_t, 32 >*)local_this).get_key();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_key_403_comment =
  "C++ Interface:\n"
  "get_key(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_key_403_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BitMask< uint32_t, 32 >::get_class_type(void)
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_class_type_405(PyObject *, PyObject *) {
  // 1-static TypeHandle BitMask< uint32_t, 32 >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BitMask< uint32_t, 32 >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_class_type_405_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_class_type_405_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint32_t, 32 >::BitMask(void)
 * inline BitMask< uint32_t, 32 >::BitMask(BitMask< uint32_t, 32 > const &copy)
 * inline BitMask< uint32_t, 32 >::BitMask(uint32_t init_value)
 */
static int Dtool_Init_BitMask_uint32_t_32(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BitMask< uint32_t, 32 >::BitMask(void)
      BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint32_t_32, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline BitMask< uint32_t, 32 >::BitMask(BitMask< uint32_t, 32 > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:BitMask", (char **)keyword_list, &param0)) {
          BitMask< uint32_t, 32 > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_BitMask_uint32_t_32, (void **)&param0_this);
          if (param0_this != NULL) {
            BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint32_t_32, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline BitMask< uint32_t, 32 >::BitMask(uint32_t init_value)
        unsigned long param0;
        static const char *keyword_list[] = {"init_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "k:BitMask", (char **)keyword_list, &param0)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (param0 > UINT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %lu out of range for unsigned integer",
                         param0);
            return -1;
          }
#endif
          BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((uint32_t)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint32_t_32, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline BitMask< uint32_t, 32 >::BitMask(BitMask< uint32_t, 32 > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:BitMask", (char **)keyword_list, &param0)) {
          BitMask< uint32_t, 32 > param0_local;
          BitMask< uint32_t, 32 > const *param0_this = Dtool_Coerce_BitMask_uint32_t_32(param0, param0_local);
          if ((param0_this != NULL)) {
            BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint32_t_32, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline BitMask< uint32_t, 32 >::BitMask(uint32_t init_value)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BitMask() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BitMask()\n"
      "BitMask(const BitMask copy)\n"
      "BitMask(int init_value)\n");
  }
  return -1;
}

BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced) {
  BitMask< uint32_t, 32 > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BitMask_uint32_t_32, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const BitMask< uint32_t, 32 > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline BitMask< uint32_t, 32 >::BitMask(uint32_t init_value)
    if (PyLongOrInt_Check(arg)) {
      unsigned long param0 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (param0 > UINT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %lu out of range for unsigned integer",
                     param0);
        return NULL;
      }
#endif
      coerced = BitMask< uint32_t, 32 >((uint32_t)param0);
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  }
  return NULL;
}

static void *Dtool_UpcastInterface_BitMask_uint32_t_32(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BitMask_uint32_t_32) {
    printf("BitMask_uint32_t_32 ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BitMask< uint32_t, 32 > *local_this = (BitMask< uint32_t, 32 > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BitMask_uint32_t_32) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BitMask_uint32_t_32(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BitMask_uint32_t_32) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BitMask< uint64_t, 64 >
 */
/**
 * Python function wrapper for:
 * inline BitMask< uint64_t, 64 > &BitMask< uint64_t, 64 >::operator =(BitMask< uint64_t, 64 > const &copy)
 */
static PyObject *Dtool_BitMask_uint64_t_64_operator_409(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.assign")) {
    return NULL;
  }
  // 1-inline BitMask< uint64_t, 64 > &BitMask< uint64_t, 64 >::operator =(BitMask< uint64_t, 64 > const &copy)
  BitMask< uint64_t, 64 > arg_local;
  BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.assign", "BitMask");
  }
  (*local_this).operator =(*arg_this);
  BitMask< uint64_t, 64 > *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const BitMask self, const BitMask copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_operator_409_comment =
  "C++ Interface:\n"
  "assign(const BitMask self, const BitMask copy)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_operator_409_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::all_on(void)
 */
static PyObject *Dtool_BitMask_uint64_t_64_all_on_410(PyObject *, PyObject *) {
  // 1-static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::all_on(void)
  BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(BitMask< uint64_t, 64 >::all_on());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_all_on_410_comment =
  "C++ Interface:\n"
  "all_on()\n";
#else
static const char *Dtool_BitMask_uint64_t_64_all_on_410_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::all_off(void)
 */
static PyObject *Dtool_BitMask_uint64_t_64_all_off_411(PyObject *, PyObject *) {
  // 1-static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::all_off(void)
  BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(BitMask< uint64_t, 64 >::all_off());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_all_off_411_comment =
  "C++ Interface:\n"
  "all_off()\n";
#else
static const char *Dtool_BitMask_uint64_t_64_all_off_411_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::lower_on(int on_bits)
 */
static PyObject *Dtool_BitMask_uint64_t_64_lower_on_412(PyObject *, PyObject *arg) {
  // 1-static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::lower_on(int on_bits)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(BitMask< uint64_t, 64 >::lower_on((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lower_on(int on_bits)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_lower_on_412_comment =
  "C++ Interface:\n"
  "lower_on(int on_bits)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_lower_on_412_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::bit(int index)
 */
static PyObject *Dtool_BitMask_uint64_t_64_bit_413(PyObject *, PyObject *arg) {
  // 1-static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(BitMask< uint64_t, 64 >::bit((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bit(int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_bit_413_comment =
  "C++ Interface:\n"
  "bit(int index)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_bit_413_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::range(int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint64_t_64_range_414(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::range(int low_bit, int size)
  int param0;
  int param1;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:range", (char **)keyword_list, &param0, &param1)) {
    BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(BitMask< uint64_t, 64 >::range((int)param0, (int)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "range(int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_range_414_comment =
  "C++ Interface:\n"
  "range(int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_range_414_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr bool BitMask< uint64_t, 64 >::has_max_num_bits(void)
 */
static PyObject *Dtool_BitMask_uint64_t_64_has_max_num_bits_416(PyObject *, PyObject *) {
  // 1-static constexpr bool BitMask< uint64_t, 64 >::has_max_num_bits(void)
  bool return_value = BitMask< uint64_t, 64 >::has_max_num_bits();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_has_max_num_bits_416_comment =
  "C++ Interface:\n"
  "has_max_num_bits()\n";
#else
static const char *Dtool_BitMask_uint64_t_64_has_max_num_bits_416_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int BitMask< uint64_t, 64 >::get_max_num_bits(void)
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_max_num_bits_417(PyObject *, PyObject *) {
  // 1-static constexpr int BitMask< uint64_t, 64 >::get_max_num_bits(void)
  int return_value = BitMask< uint64_t, 64 >::get_max_num_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_max_num_bits_417_comment =
  "C++ Interface:\n"
  "get_max_num_bits()\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_max_num_bits_417_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int BitMask< uint64_t, 64 >::get_num_bits(void)
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_num_bits_418(PyObject *, PyObject *) {
  // 1-static constexpr int BitMask< uint64_t, 64 >::get_num_bits(void)
  int return_value = BitMask< uint64_t, 64 >::get_num_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_num_bits_418_comment =
  "C++ Interface:\n"
  "get_num_bits()\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_num_bits_418_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint64_t, 64 >::get_bit(int index) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_bit_419(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitMask< uint64_t, 64 >::get_bit(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const BitMask< uint64_t, 64 >*)local_this).get_bit((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bit(BitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_bit_419_comment =
  "C++ Interface:\n"
  "get_bit(BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_bit_419_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::set_bit(int index)
 */
static PyObject *Dtool_BitMask_uint64_t_64_set_bit_420(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.set_bit")) {
    return NULL;
  }
  // 1-inline void BitMask< uint64_t, 64 >::set_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_bit((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit(const BitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_set_bit_420_comment =
  "C++ Interface:\n"
  "set_bit(const BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_set_bit_420_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::clear_bit(int index)
 */
static PyObject *Dtool_BitMask_uint64_t_64_clear_bit_421(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.clear_bit")) {
    return NULL;
  }
  // 1-inline void BitMask< uint64_t, 64 >::clear_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).clear_bit((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_bit(const BitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_clear_bit_421_comment =
  "C++ Interface:\n"
  "clear_bit(const BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_clear_bit_421_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::set_bit_to(int index, bool value)
 */
static PyObject *Dtool_BitMask_uint64_t_64_set_bit_to_422(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.set_bit_to")) {
    return NULL;
  }
  // 1-inline void BitMask< uint64_t, 64 >::set_bit_to(int index, bool value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_bit_to", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_bit_to((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit_to(const BitMask self, int index, bool value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_set_bit_to_422_comment =
  "C++ Interface:\n"
  "set_bit_to(const BitMask self, int index, bool value)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_set_bit_to_422_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint64_t, 64 >::is_zero(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_is_zero_423(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitMask< uint64_t, 64 >::is_zero(void) const
  bool return_value = (*(const BitMask< uint64_t, 64 >*)local_this).is_zero();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_is_zero_423_comment =
  "C++ Interface:\n"
  "is_zero(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_is_zero_423_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint64_t, 64 >::is_all_on(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_is_all_on_424(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitMask< uint64_t, 64 >::is_all_on(void) const
  bool return_value = (*(const BitMask< uint64_t, 64 >*)local_this).is_all_on();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_is_all_on_424_comment =
  "C++ Interface:\n"
  "is_all_on(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_is_all_on_424_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint64_t BitMask< uint64_t, 64 >::extract(int low_bit, int size) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_extract_425(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline uint64_t BitMask< uint64_t, 64 >::extract(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:extract", (char **)keyword_list, &param1, &param2)) {
    uint64_t return_value = (*(const BitMask< uint64_t, 64 >*)local_this).extract((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract(BitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_extract_425_comment =
  "C++ Interface:\n"
  "extract(BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_extract_425_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::store(uint64_t value, int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint64_t_64_store_426(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.store")) {
    return NULL;
  }
  // 1-inline void BitMask< uint64_t, 64 >::store(uint64_t value, int low_bit, int size)
  unsigned PY_LONG_LONG param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Kii:store", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).store((uint64_t)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store(const BitMask self, long value, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_store_426_comment =
  "C++ Interface:\n"
  "store(const BitMask self, long value, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_store_426_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint64_t, 64 >::has_any_of(int low_bit, int size) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_has_any_of_427(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitMask< uint64_t, 64 >::has_any_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_any_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*(const BitMask< uint64_t, 64 >*)local_this).has_any_of((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_any_of(BitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_has_any_of_427_comment =
  "C++ Interface:\n"
  "has_any_of(BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_has_any_of_427_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint64_t, 64 >::has_all_of(int low_bit, int size) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_has_all_of_428(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitMask< uint64_t, 64 >::has_all_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_all_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*(const BitMask< uint64_t, 64 >*)local_this).has_all_of((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_all_of(BitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_has_all_of_428_comment =
  "C++ Interface:\n"
  "has_all_of(BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_has_all_of_428_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::set_range(int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint64_t_64_set_range_429(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.set_range")) {
    return NULL;
  }
  // 1-inline void BitMask< uint64_t, 64 >::set_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_range", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_range((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range(const BitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_set_range_429_comment =
  "C++ Interface:\n"
  "set_range(const BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_set_range_429_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::clear_range(int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint64_t_64_clear_range_430(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.clear_range")) {
    return NULL;
  }
  // 1-inline void BitMask< uint64_t, 64 >::clear_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:clear_range", (char **)keyword_list, &param1, &param2)) {
    (*local_this).clear_range((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_range(const BitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_clear_range_430_comment =
  "C++ Interface:\n"
  "clear_range(const BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_clear_range_430_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::set_range_to(bool value, int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint64_t_64_set_range_to_431(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.set_range_to")) {
    return NULL;
  }
  // 1-inline void BitMask< uint64_t, 64 >::set_range_to(bool value, int low_bit, int size)
  PyObject *param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_range_to", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_range_to((PyObject_IsTrue(param1) != 0), (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range_to(const BitMask self, bool value, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_set_range_to_431_comment =
  "C++ Interface:\n"
  "set_range_to(const BitMask self, bool value, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_set_range_to_431_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint64_t BitMask< uint64_t, 64 >::get_word(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_word_432(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline uint64_t BitMask< uint64_t, 64 >::get_word(void) const
  uint64_t return_value = (*(const BitMask< uint64_t, 64 >*)local_this).get_word();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_word_432_comment =
  "C++ Interface:\n"
  "get_word(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_word_432_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::set_word(uint64_t value)
 */
static PyObject *Dtool_BitMask_uint64_t_64_set_word_433(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.set_word")) {
    return NULL;
  }
  // 1-inline void BitMask< uint64_t, 64 >::set_word(uint64_t value)
  unsigned PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "K:set_word", &param1)) {
    (*local_this).set_word((uint64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const BitMask self, long value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_set_word_433_comment =
  "C++ Interface:\n"
  "set_word(const BitMask self, long value)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_set_word_433_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint64_t, 64 >::get_num_on_bits(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_num_on_bits_434(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint64_t, 64 >::get_num_on_bits(void) const
  int return_value = (*(const BitMask< uint64_t, 64 >*)local_this).get_num_on_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_num_on_bits_434_comment =
  "C++ Interface:\n"
  "get_num_on_bits(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_num_on_bits_434_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint64_t, 64 >::get_num_off_bits(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_num_off_bits_435(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint64_t, 64 >::get_num_off_bits(void) const
  int return_value = (*(const BitMask< uint64_t, 64 >*)local_this).get_num_off_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_num_off_bits_435_comment =
  "C++ Interface:\n"
  "get_num_off_bits(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_num_off_bits_435_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint64_t, 64 >::get_lowest_on_bit(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_lowest_on_bit_436(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint64_t, 64 >::get_lowest_on_bit(void) const
  int return_value = (*(const BitMask< uint64_t, 64 >*)local_this).get_lowest_on_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_lowest_on_bit_436_comment =
  "C++ Interface:\n"
  "get_lowest_on_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_lowest_on_bit_436_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint64_t, 64 >::get_lowest_off_bit(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_lowest_off_bit_437(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint64_t, 64 >::get_lowest_off_bit(void) const
  int return_value = (*(const BitMask< uint64_t, 64 >*)local_this).get_lowest_off_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_lowest_off_bit_437_comment =
  "C++ Interface:\n"
  "get_lowest_off_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_lowest_off_bit_437_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint64_t, 64 >::get_highest_on_bit(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_highest_on_bit_438(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint64_t, 64 >::get_highest_on_bit(void) const
  int return_value = (*(const BitMask< uint64_t, 64 >*)local_this).get_highest_on_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_highest_on_bit_438_comment =
  "C++ Interface:\n"
  "get_highest_on_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_highest_on_bit_438_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint64_t, 64 >::get_highest_off_bit(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_highest_off_bit_439(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint64_t, 64 >::get_highest_off_bit(void) const
  int return_value = (*(const BitMask< uint64_t, 64 >*)local_this).get_highest_off_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_highest_off_bit_439_comment =
  "C++ Interface:\n"
  "get_highest_off_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_highest_off_bit_439_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint64_t, 64 >::get_next_higher_different_bit(int low_bit) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_next_higher_different_bit_440(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint64_t, 64 >::get_next_higher_different_bit(int low_bit) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const BitMask< uint64_t, 64 >*)local_this).get_next_higher_different_bit((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_next_higher_different_bit(BitMask self, int low_bit)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_next_higher_different_bit_440_comment =
  "C++ Interface:\n"
  "get_next_higher_different_bit(BitMask self, int low_bit)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_next_higher_different_bit_440_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::invert_in_place(void)
 */
static PyObject *Dtool_BitMask_uint64_t_64_invert_in_place_441(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.invert_in_place")) {
    return NULL;
  }
  // 1-inline void BitMask< uint64_t, 64 >::invert_in_place(void)
  (*local_this).invert_in_place();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_invert_in_place_441_comment =
  "C++ Interface:\n"
  "invert_in_place(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_invert_in_place_441_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint64_t, 64 >::has_bits_in_common(BitMask< uint64_t, 64 > const &other) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_has_bits_in_common_442(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitMask< uint64_t, 64 >::has_bits_in_common(BitMask< uint64_t, 64 > const &other) const
  BitMask< uint64_t, 64 > arg_local;
  BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.has_bits_in_common", "BitMask");
  }
  bool return_value = (*(const BitMask< uint64_t, 64 >*)local_this).has_bits_in_common(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_bits_in_common(BitMask self, const BitMask other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_has_bits_in_common_442_comment =
  "C++ Interface:\n"
  "has_bits_in_common(BitMask self, const BitMask other)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_has_bits_in_common_442_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::clear(void)
 */
static PyObject *Dtool_BitMask_uint64_t_64_clear_443(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.clear")) {
    return NULL;
  }
  // 1-inline void BitMask< uint64_t, 64 >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_clear_443_comment =
  "C++ Interface:\n"
  "clear(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_clear_443_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint64_t, 64 >::output(ostream &out) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_output_444(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-void BitMask< uint64_t, 64 >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "BitMask.output", false, true);
  if (arg_this != NULL) {
    (*(const BitMask< uint64_t, 64 >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(BitMask self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_output_444_comment =
  "C++ Interface:\n"
  "output(BitMask self, ostream out)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_output_444_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint64_t, 64 >::output_binary(ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_output_binary_445(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-void BitMask< uint64_t, 64 >::output_binary(ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_binary", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BitMask.output_binary", false, true);
    if (param1_this != NULL) {
      (*(const BitMask< uint64_t, 64 >*)local_this).output_binary(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_binary(BitMask self, ostream out, int spaces_every)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_output_binary_445_comment =
  "C++ Interface:\n"
  "output_binary(BitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_output_binary_445_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint64_t, 64 >::output_hex(ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_output_hex_446(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-void BitMask< uint64_t, 64 >::output_hex(ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_hex", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BitMask.output_hex", false, true);
    if (param1_this != NULL) {
      (*(const BitMask< uint64_t, 64 >*)local_this).output_hex(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_hex(BitMask self, ostream out, int spaces_every)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_output_hex_446_comment =
  "C++ Interface:\n"
  "output_hex(BitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_output_hex_446_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint64_t, 64 >::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_write_447(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-void BitMask< uint64_t, 64 >::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BitMask.write", false, true);
    if (param1_this != NULL) {
      (*(const BitMask< uint64_t, 64 >*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(BitMask self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_write_447_comment =
  "C++ Interface:\n"
  "write(BitMask self, ostream out, int indent_level)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_write_447_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint64_t, 64 >::compare_to(BitMask< uint64_t, 64 > const &other) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_compare_to_451(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint64_t, 64 >::compare_to(BitMask< uint64_t, 64 > const &other) const
  BitMask< uint64_t, 64 > arg_local;
  BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.compare_to", "BitMask");
  }
  int return_value = (*(const BitMask< uint64_t, 64 >*)local_this).compare_to(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(BitMask self, const BitMask other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_compare_to_451_comment =
  "C++ Interface:\n"
  "compare_to(BitMask self, const BitMask other)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_compare_to_451_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::operator |=(BitMask< uint64_t, 64 > const &other)
 */
static PyObject *Dtool_BitMask_uint64_t_64_operator_459(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.__ior__")) {
    return NULL;
  }
  // 1-inline void BitMask< uint64_t, 64 >::operator |=(BitMask< uint64_t, 64 > const &other)
  BitMask< uint64_t, 64 > arg_local;
  BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__ior__", "BitMask");
  }
  (*local_this).operator |=(*arg_this);
  BitMask< uint64_t, 64 > *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__ior__(const BitMask self, const BitMask other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_operator_459_comment =
  "C++ Interface:\n"
  "__ior__(const BitMask self, const BitMask other)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_operator_459_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::flood_down_in_place(void)
 */
static PyObject *Dtool_BitMask_uint64_t_64_flood_down_in_place_463(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.flood_down_in_place")) {
    return NULL;
  }
  // 1-inline void BitMask< uint64_t, 64 >::flood_down_in_place(void)
  (*local_this).flood_down_in_place();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_flood_down_in_place_463_comment =
  "C++ Interface:\n"
  "flood_down_in_place(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_flood_down_in_place_463_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::flood_up_in_place(void)
 */
static PyObject *Dtool_BitMask_uint64_t_64_flood_up_in_place_464(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.flood_up_in_place")) {
    return NULL;
  }
  // 1-inline void BitMask< uint64_t, 64 >::flood_up_in_place(void)
  (*local_this).flood_up_in_place();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_flood_up_in_place_464_comment =
  "C++ Interface:\n"
  "flood_up_in_place(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_flood_up_in_place_464_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::flood_bits_down(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_flood_bits_down_465(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::flood_bits_down(void) const
  BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((*(const BitMask< uint64_t, 64 >*)local_this).flood_bits_down());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_flood_bits_down_465_comment =
  "C++ Interface:\n"
  "flood_bits_down(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_flood_bits_down_465_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::flood_bits_up(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_flood_bits_up_466(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::flood_bits_up(void) const
  BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((*(const BitMask< uint64_t, 64 >*)local_this).flood_bits_up());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_flood_bits_up_466_comment =
  "C++ Interface:\n"
  "flood_bits_up(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_flood_bits_up_466_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(void) const
 * inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(BitMask< uint64_t, 64 > const &other) const
 * inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(int index) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_keep_next_highest_bit_467(PyObject *self, PyObject *args) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(void) const
      BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((*(const BitMask< uint64_t, 64 >*)local_this).keep_next_highest_bit());
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      {
        // -2 inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(BitMask< uint64_t, 64 > const &other) const
        BitMask< uint64_t, 64 > const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_BitMask_uint64_t_64, (void **)&arg_this);
        if (arg_this != NULL) {
          BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((*(const BitMask< uint64_t, 64 >*)local_this).keep_next_highest_bit(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
        }
      }

      {
        // -2 inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(int index) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((*(const BitMask< uint64_t, 64 >*)local_this).keep_next_highest_bit((int)arg_val));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
        }
      }

      {
        // -2 inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(BitMask< uint64_t, 64 > const &other) const
        BitMask< uint64_t, 64 > arg_local;
        BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
        if ((arg_this != NULL)) {
          BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((*(const BitMask< uint64_t, 64 >*)local_this).keep_next_highest_bit(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
        }
      }

      // No coercion possible: inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(int index) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "keep_next_highest_bit() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "keep_next_highest_bit(BitMask self)\n"
      "keep_next_highest_bit(BitMask self, const BitMask other)\n"
      "keep_next_highest_bit(BitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_keep_next_highest_bit_467_comment =
  "C++ Interface:\n"
  "keep_next_highest_bit(BitMask self)\n"
  "keep_next_highest_bit(BitMask self, const BitMask other)\n"
  "keep_next_highest_bit(BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_keep_next_highest_bit_467_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(void) const
 * inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(BitMask< uint64_t, 64 > const &other) const
 * inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(int index) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_keep_next_lowest_bit_468(PyObject *self, PyObject *args) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(void) const
      BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((*(const BitMask< uint64_t, 64 >*)local_this).keep_next_lowest_bit());
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      {
        // -2 inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(BitMask< uint64_t, 64 > const &other) const
        BitMask< uint64_t, 64 > const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_BitMask_uint64_t_64, (void **)&arg_this);
        if (arg_this != NULL) {
          BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((*(const BitMask< uint64_t, 64 >*)local_this).keep_next_lowest_bit(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
        }
      }

      {
        // -2 inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(int index) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((*(const BitMask< uint64_t, 64 >*)local_this).keep_next_lowest_bit((int)arg_val));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
        }
      }

      {
        // -2 inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(BitMask< uint64_t, 64 > const &other) const
        BitMask< uint64_t, 64 > arg_local;
        BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
        if ((arg_this != NULL)) {
          BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((*(const BitMask< uint64_t, 64 >*)local_this).keep_next_lowest_bit(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
        }
      }

      // No coercion possible: inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(int index) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "keep_next_lowest_bit() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "keep_next_lowest_bit(BitMask self)\n"
      "keep_next_lowest_bit(BitMask self, const BitMask other)\n"
      "keep_next_lowest_bit(BitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_keep_next_lowest_bit_468_comment =
  "C++ Interface:\n"
  "keep_next_lowest_bit(BitMask self)\n"
  "keep_next_lowest_bit(BitMask self, const BitMask other)\n"
  "keep_next_lowest_bit(BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_keep_next_lowest_bit_468_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint64_t, 64 >::get_key(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_key_469(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BitMask< uint64_t, 64 >::get_key(void) const
  int return_value = (*(const BitMask< uint64_t, 64 >*)local_this).get_key();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_key_469_comment =
  "C++ Interface:\n"
  "get_key(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_key_469_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BitMask< uint64_t, 64 >::get_class_type(void)
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_class_type_471(PyObject *, PyObject *) {
  // 1-static TypeHandle BitMask< uint64_t, 64 >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BitMask< uint64_t, 64 >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_class_type_471_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_class_type_471_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint64_t, 64 >::BitMask(void)
 * inline BitMask< uint64_t, 64 >::BitMask(BitMask< uint64_t, 64 > const &copy)
 * inline BitMask< uint64_t, 64 >::BitMask(uint64_t init_value)
 */
static int Dtool_Init_BitMask_uint64_t_64(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BitMask< uint64_t, 64 >::BitMask(void)
      BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint64_t_64, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline BitMask< uint64_t, 64 >::BitMask(BitMask< uint64_t, 64 > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:BitMask", (char **)keyword_list, &param0)) {
          BitMask< uint64_t, 64 > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_BitMask_uint64_t_64, (void **)&param0_this);
          if (param0_this != NULL) {
            BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint64_t_64, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline BitMask< uint64_t, 64 >::BitMask(uint64_t init_value)
        unsigned PY_LONG_LONG param0;
        static const char *keyword_list[] = {"init_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "K:BitMask", (char **)keyword_list, &param0)) {
          BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((uint64_t)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint64_t_64, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline BitMask< uint64_t, 64 >::BitMask(BitMask< uint64_t, 64 > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:BitMask", (char **)keyword_list, &param0)) {
          BitMask< uint64_t, 64 > param0_local;
          BitMask< uint64_t, 64 > const *param0_this = Dtool_Coerce_BitMask_uint64_t_64(param0, param0_local);
          if ((param0_this != NULL)) {
            BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint64_t_64, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline BitMask< uint64_t, 64 >::BitMask(uint64_t init_value)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BitMask() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BitMask()\n"
      "BitMask(const BitMask copy)\n"
      "BitMask(long init_value)\n");
  }
  return -1;
}

BitMask< uint64_t, 64 > *Dtool_Coerce_BitMask_uint64_t_64(PyObject *args, BitMask< uint64_t, 64 > &coerced) {
  BitMask< uint64_t, 64 > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BitMask_uint64_t_64, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const BitMask< uint64_t, 64 > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline BitMask< uint64_t, 64 >::BitMask(uint64_t init_value)
    unsigned PY_LONG_LONG param0;
    if (PyArg_Parse(arg, "K:BitMask", &param0)) {
      coerced = BitMask< uint64_t, 64 >((uint64_t)param0);
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
    PyErr_Clear();
  }
  return NULL;
}

static void *Dtool_UpcastInterface_BitMask_uint64_t_64(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BitMask_uint64_t_64) {
    printf("BitMask_uint64_t_64 ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BitMask< uint64_t, 64 > *local_this = (BitMask< uint64_t, 64 > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BitMask_uint64_t_64) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BitMask_uint64_t_64(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BitMask_uint64_t_64) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BitArray
 */
/**
 * Python function wrapper for:
 * inline BitArray &BitArray::operator =(BitArray const &copy)
 */
static PyObject *Dtool_BitArray_operator_477(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.assign")) {
    return NULL;
  }
  // 1-inline BitArray &BitArray::operator =(BitArray const &copy)
  BitArray const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_BitArray(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitArray.assign", "BitArray");
  }
  (*local_this).operator =(*arg_this);
  BitArray *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const BitArray self, const BitArray copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_operator_477_comment =
  "C++ Interface:\n"
  "assign(const BitArray self, const BitArray copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_BitArray_operator_477_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitArray BitArray::all_on(void)
 */
static PyObject *Dtool_BitArray_all_on_478(PyObject *, PyObject *) {
  // 1-static inline BitArray BitArray::all_on(void)
  BitArray *return_value = new BitArray(BitArray::all_on());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_all_on_478_comment =
  "C++ Interface:\n"
  "all_on()\n"
  "\n"
  "/**\n"
  " * Returns a BitArray with an infinite array of bits, all on.\n"
  " */";
#else
static const char *Dtool_BitArray_all_on_478_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitArray BitArray::all_off(void)
 */
static PyObject *Dtool_BitArray_all_off_479(PyObject *, PyObject *) {
  // 1-static inline BitArray BitArray::all_off(void)
  BitArray *return_value = new BitArray(BitArray::all_off());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_all_off_479_comment =
  "C++ Interface:\n"
  "all_off()\n"
  "\n"
  "/**\n"
  " * Returns a BitArray whose bits are all off.\n"
  " */";
#else
static const char *Dtool_BitArray_all_off_479_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitArray BitArray::lower_on(int on_bits)
 */
static PyObject *Dtool_BitArray_lower_on_480(PyObject *, PyObject *arg) {
  // 1-static inline BitArray BitArray::lower_on(int on_bits)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitArray *return_value = new BitArray(BitArray::lower_on((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lower_on(int on_bits)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_lower_on_480_comment =
  "C++ Interface:\n"
  "lower_on(int on_bits)\n"
  "\n"
  "/**\n"
  " * Returns a BitArray whose lower on_bits bits are on.\n"
  " */";
#else
static const char *Dtool_BitArray_lower_on_480_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitArray BitArray::bit(int index)
 */
static PyObject *Dtool_BitArray_bit_481(PyObject *, PyObject *arg) {
  // 1-static inline BitArray BitArray::bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitArray *return_value = new BitArray(BitArray::bit((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bit(int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_bit_481_comment =
  "C++ Interface:\n"
  "bit(int index)\n"
  "\n"
  "/**\n"
  " * Returns a BitArray with only the indicated bit on.\n"
  " */";
#else
static const char *Dtool_BitArray_bit_481_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline BitArray BitArray::range(int low_bit, int size)
 */
static PyObject *Dtool_BitArray_range_482(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline BitArray BitArray::range(int low_bit, int size)
  int param0;
  int param1;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:range", (char **)keyword_list, &param0, &param1)) {
    BitArray *return_value = new BitArray(BitArray::range((int)param0, (int)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "range(int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_range_482_comment =
  "C++ Interface:\n"
  "range(int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Returns a BitArray whose size bits, beginning at low_bit, are on.\n"
  " */";
#else
static const char *Dtool_BitArray_range_482_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr bool BitArray::has_max_num_bits(void)
 */
static PyObject *Dtool_BitArray_has_max_num_bits_484(PyObject *, PyObject *) {
  // 1-static constexpr bool BitArray::has_max_num_bits(void)
  bool return_value = BitArray::has_max_num_bits();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_has_max_num_bits_484_comment =
  "C++ Interface:\n"
  "has_max_num_bits()\n"
  "\n"
  "/**\n"
  " * Returns true if there is a maximum number of bits that may be stored in\n"
  " * this structure, false otherwise.  If this returns true, the number may be\n"
  " * queried in get_max_num_bits().\n"
  " *\n"
  " * This method always returns false.  The BitArray has no maximum number of\n"
  " * bits.  This method is defined so generic programming algorithms can use\n"
  " * BitMask or BitArray interchangeably.\n"
  " */";
#else
static const char *Dtool_BitArray_has_max_num_bits_484_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int BitArray::get_max_num_bits(void)
 */
static PyObject *Dtool_BitArray_get_max_num_bits_485(PyObject *, PyObject *) {
  // 1-static constexpr int BitArray::get_max_num_bits(void)
  int return_value = BitArray::get_max_num_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_max_num_bits_485_comment =
  "C++ Interface:\n"
  "get_max_num_bits()\n"
  "\n"
  "/**\n"
  " * If get_max_num_bits() returned true, this method may be called to return\n"
  " * the maximum number of bits that may be stored in this structure.  It is an\n"
  " * error to call this if get_max_num_bits() return false.\n"
  " *\n"
  " * It is always an error to call this method.  The BitArray has no maximum\n"
  " * number of bits.  This method is defined so generic programming algorithms\n"
  " * can use BitMask or BitArray interchangeably.\n"
  " */";
#else
static const char *Dtool_BitArray_get_max_num_bits_485_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int BitArray::get_num_bits_per_word(void)
 */
static PyObject *Dtool_BitArray_get_num_bits_per_word_486(PyObject *, PyObject *) {
  // 1-static constexpr int BitArray::get_num_bits_per_word(void)
  int return_value = BitArray::get_num_bits_per_word();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_num_bits_per_word_486_comment =
  "C++ Interface:\n"
  "get_num_bits_per_word()\n"
  "\n"
  "/**\n"
  " * Returns the number of bits stored per word internally.  This is of interest\n"
  " * only in that it limits the maximum number of bits that may be queried or\n"
  " * set at once by extract() and store().\n"
  " */";
#else
static const char *Dtool_BitArray_get_num_bits_per_word_486_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t BitArray::get_num_bits(void) const
 */
static PyObject *Dtool_BitArray_get_num_bits_487(PyObject *self, PyObject *) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t BitArray::get_num_bits(void) const
  std::size_t return_value = (*(const BitArray*)local_this).get_num_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_num_bits_487_comment =
  "C++ Interface:\n"
  "get_num_bits(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns the current number of possibly different bits in this array.  There\n"
  " * are actually an infinite number of bits, but every bit higher than this bit\n"
  " * will have the same value, either 0 or 1 (see get_highest_bits()).\n"
  " *\n"
  " * This number may grow and/or shrink automatically as needed.\n"
  " */";
#else
static const char *Dtool_BitArray_get_num_bits_487_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitArray::get_bit(int index) const
 */
static PyObject *Dtool_BitArray_get_bit_488(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitArray::get_bit(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const BitArray*)local_this).get_bit((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bit(BitArray self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_bit_488_comment =
  "C++ Interface:\n"
  "get_bit(BitArray self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the nth bit is set, false if it is cleared.  It is valid\n"
  " * for n to increase beyond get_num_bits(), but the return value\n"
  " * get_num_bits() will always be the same.\n"
  " */";
#else
static const char *Dtool_BitArray_get_bit_488_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitArray::set_bit(int index)
 */
static PyObject *Dtool_BitArray_set_bit_489(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.set_bit")) {
    return NULL;
  }
  // 1-inline void BitArray::set_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_bit((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit(const BitArray self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_set_bit_489_comment =
  "C++ Interface:\n"
  "set_bit(const BitArray self, int index)\n"
  "\n"
  "/**\n"
  " * Sets the nth bit on.  If n >= get_num_bits(), this automatically extends\n"
  " * the array.\n"
  " */";
#else
static const char *Dtool_BitArray_set_bit_489_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitArray::clear_bit(int index)
 */
static PyObject *Dtool_BitArray_clear_bit_490(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.clear_bit")) {
    return NULL;
  }
  // 1-inline void BitArray::clear_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).clear_bit((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_bit(const BitArray self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_clear_bit_490_comment =
  "C++ Interface:\n"
  "clear_bit(const BitArray self, int index)\n"
  "\n"
  "/**\n"
  " * Sets the nth bit off.  If n >= get_num_bits(), this automatically extends\n"
  " * the array.\n"
  " */";
#else
static const char *Dtool_BitArray_clear_bit_490_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitArray::set_bit_to(int index, bool value)
 */
static PyObject *Dtool_BitArray_set_bit_to_491(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.set_bit_to")) {
    return NULL;
  }
  // 1-inline void BitArray::set_bit_to(int index, bool value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_bit_to", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_bit_to((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit_to(const BitArray self, int index, bool value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_set_bit_to_491_comment =
  "C++ Interface:\n"
  "set_bit_to(const BitArray self, int index, bool value)\n"
  "\n"
  "/**\n"
  " * Sets the nth bit either on or off, according to the indicated bool value.\n"
  " */";
#else
static const char *Dtool_BitArray_set_bit_to_491_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BitArray::get_highest_bits(void) const
 */
static PyObject *Dtool_BitArray_get_highest_bits_492(PyObject *self, PyObject *) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BitArray::get_highest_bits(void) const
  bool return_value = (*(const BitArray*)local_this).get_highest_bits();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_highest_bits_492_comment =
  "C++ Interface:\n"
  "get_highest_bits(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns true if the infinite set of bits beyond get_num_bits() are all on,\n"
  " * or false of they are all off.\n"
  " */";
#else
static const char *Dtool_BitArray_get_highest_bits_492_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool BitArray::is_zero(void) const
 */
static PyObject *Dtool_BitArray_is_zero_493(PyObject *self, PyObject *) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool BitArray::is_zero(void) const
  bool return_value = (*(const BitArray*)local_this).is_zero();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_is_zero_493_comment =
  "C++ Interface:\n"
  "is_zero(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns true if the entire bitmask is zero, false otherwise.\n"
  " */";
#else
static const char *Dtool_BitArray_is_zero_493_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool BitArray::is_all_on(void) const
 */
static PyObject *Dtool_BitArray_is_all_on_494(PyObject *self, PyObject *) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool BitArray::is_all_on(void) const
  bool return_value = (*(const BitArray*)local_this).is_all_on();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_is_all_on_494_comment =
  "C++ Interface:\n"
  "is_all_on(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns true if the entire bitmask is one, false otherwise.\n"
  " */";
#else
static const char *Dtool_BitArray_is_all_on_494_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitArray::WordType BitArray::extract(int low_bit, int size) const
 */
static PyObject *Dtool_BitArray_extract_495(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BitArray::WordType BitArray::extract(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:extract", (char **)keyword_list, &param1, &param2)) {
    BitArray::WordType return_value = (*(const BitArray*)local_this).extract((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract(BitArray self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_extract_495_comment =
  "C++ Interface:\n"
  "extract(BitArray self, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Returns a word that represents only the indicated range of bits within this\n"
  " * BitArray, shifted to the least-significant position.  size must be <=\n"
  " * get_num_bits_per_word().\n"
  " */";
#else
static const char *Dtool_BitArray_extract_495_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitArray::store(BitArray::WordType value, int low_bit, int size)
 */
static PyObject *Dtool_BitArray_store_496(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.store")) {
    return NULL;
  }
  // 1-inline void BitArray::store(BitArray::WordType value, int low_bit, int size)
  unsigned long param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kii:store", (char **)keyword_list, &param1, &param2, &param3)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    (*local_this).store((BitArray::WordType)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store(const BitArray self, int value, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_store_496_comment =
  "C++ Interface:\n"
  "store(const BitArray self, int value, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Stores the indicated word into the indicated range of bits with this\n"
  " * BitArray.\n"
  " */";
#else
static const char *Dtool_BitArray_store_496_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool BitArray::has_any_of(int low_bit, int size) const
 */
static PyObject *Dtool_BitArray_has_any_of_497(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool BitArray::has_any_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_any_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*(const BitArray*)local_this).has_any_of((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_any_of(BitArray self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_has_any_of_497_comment =
  "C++ Interface:\n"
  "has_any_of(BitArray self, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Returns true if any bit in the indicated range is set, false otherwise.\n"
  " */";
#else
static const char *Dtool_BitArray_has_any_of_497_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool BitArray::has_all_of(int low_bit, int size) const
 */
static PyObject *Dtool_BitArray_has_all_of_498(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool BitArray::has_all_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_all_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*(const BitArray*)local_this).has_all_of((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_all_of(BitArray self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_has_all_of_498_comment =
  "C++ Interface:\n"
  "has_all_of(BitArray self, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Returns true if all bits in the indicated range are set, false otherwise.\n"
  " */";
#else
static const char *Dtool_BitArray_has_all_of_498_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitArray::set_range(int low_bit, int size)
 */
static PyObject *Dtool_BitArray_set_range_499(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.set_range")) {
    return NULL;
  }
  // 1-void BitArray::set_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_range", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_range((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range(const BitArray self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_set_range_499_comment =
  "C++ Interface:\n"
  "set_range(const BitArray self, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Sets the indicated range of bits on.\n"
  " */";
#else
static const char *Dtool_BitArray_set_range_499_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitArray::clear_range(int low_bit, int size)
 */
static PyObject *Dtool_BitArray_clear_range_500(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.clear_range")) {
    return NULL;
  }
  // 1-void BitArray::clear_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:clear_range", (char **)keyword_list, &param1, &param2)) {
    (*local_this).clear_range((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_range(const BitArray self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_clear_range_500_comment =
  "C++ Interface:\n"
  "clear_range(const BitArray self, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Sets the indicated range of bits off.\n"
  " */";
#else
static const char *Dtool_BitArray_clear_range_500_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitArray::set_range_to(bool value, int low_bit, int size)
 */
static PyObject *Dtool_BitArray_set_range_to_501(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.set_range_to")) {
    return NULL;
  }
  // 1-inline void BitArray::set_range_to(bool value, int low_bit, int size)
  PyObject *param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_range_to", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_range_to((PyObject_IsTrue(param1) != 0), (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range_to(const BitArray self, bool value, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_set_range_to_501_comment =
  "C++ Interface:\n"
  "set_range_to(const BitArray self, bool value, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Sets the indicated range of bits to either on or off.\n"
  " */";
#else
static const char *Dtool_BitArray_set_range_to_501_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int BitArray::get_num_on_bits(void) const
 */
static PyObject *Dtool_BitArray_get_num_on_bits_502(PyObject *self, PyObject *) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-int BitArray::get_num_on_bits(void) const
  int return_value = (*(const BitArray*)local_this).get_num_on_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_num_on_bits_502_comment =
  "C++ Interface:\n"
  "get_num_on_bits(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bits that are set to 1 in the array.  Returns -1 if\n"
  " * there are an infinite number of 1 bits.\n"
  " */";
#else
static const char *Dtool_BitArray_get_num_on_bits_502_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int BitArray::get_num_off_bits(void) const
 */
static PyObject *Dtool_BitArray_get_num_off_bits_503(PyObject *self, PyObject *) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-int BitArray::get_num_off_bits(void) const
  int return_value = (*(const BitArray*)local_this).get_num_off_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_num_off_bits_503_comment =
  "C++ Interface:\n"
  "get_num_off_bits(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bits that are set to 0 in the array.  Returns -1 if\n"
  " * there are an infinite number of 0 bits.\n"
  " */";
#else
static const char *Dtool_BitArray_get_num_off_bits_503_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int BitArray::get_lowest_on_bit(void) const
 */
static PyObject *Dtool_BitArray_get_lowest_on_bit_504(PyObject *self, PyObject *) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-int BitArray::get_lowest_on_bit(void) const
  int return_value = (*(const BitArray*)local_this).get_lowest_on_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_lowest_on_bit_504_comment =
  "C++ Interface:\n"
  "get_lowest_on_bit(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the lowest 1 bit in the array.  Returns -1 if there\n"
  " * are no 1 bits.\n"
  " */";
#else
static const char *Dtool_BitArray_get_lowest_on_bit_504_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int BitArray::get_lowest_off_bit(void) const
 */
static PyObject *Dtool_BitArray_get_lowest_off_bit_505(PyObject *self, PyObject *) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-int BitArray::get_lowest_off_bit(void) const
  int return_value = (*(const BitArray*)local_this).get_lowest_off_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_lowest_off_bit_505_comment =
  "C++ Interface:\n"
  "get_lowest_off_bit(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the lowest 0 bit in the array.  Returns -1 if there\n"
  " * are no 0 bits.\n"
  " */";
#else
static const char *Dtool_BitArray_get_lowest_off_bit_505_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int BitArray::get_highest_on_bit(void) const
 */
static PyObject *Dtool_BitArray_get_highest_on_bit_506(PyObject *self, PyObject *) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-int BitArray::get_highest_on_bit(void) const
  int return_value = (*(const BitArray*)local_this).get_highest_on_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_highest_on_bit_506_comment =
  "C++ Interface:\n"
  "get_highest_on_bit(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the highest 1 bit in the array.  Returns -1 if there\n"
  " * are no 1 bits or if there an infinite number of 1 bits.\n"
  " */";
#else
static const char *Dtool_BitArray_get_highest_on_bit_506_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int BitArray::get_highest_off_bit(void) const
 */
static PyObject *Dtool_BitArray_get_highest_off_bit_507(PyObject *self, PyObject *) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-int BitArray::get_highest_off_bit(void) const
  int return_value = (*(const BitArray*)local_this).get_highest_off_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_highest_off_bit_507_comment =
  "C++ Interface:\n"
  "get_highest_off_bit(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the highest 0 bit in the array.  Returns -1 if there\n"
  " * are no 0 bits or if there an infinite number of 1 bits.\n"
  " */";
#else
static const char *Dtool_BitArray_get_highest_off_bit_507_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int BitArray::get_next_higher_different_bit(int low_bit) const
 */
static PyObject *Dtool_BitArray_get_next_higher_different_bit_508(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-int BitArray::get_next_higher_different_bit(int low_bit) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const BitArray*)local_this).get_next_higher_different_bit((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_next_higher_different_bit(BitArray self, int low_bit)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_next_higher_different_bit_508_comment =
  "C++ Interface:\n"
  "get_next_higher_different_bit(BitArray self, int low_bit)\n"
  "\n"
  "/**\n"
  " * Returns the index of the next bit in the array, above low_bit, whose value\n"
  " * is different that the value of low_bit.  Returns low_bit again if all bits\n"
  " * higher than low_bit have the same value.\n"
  " *\n"
  " * This can be used to quickly iterate through all of the bits in the array.\n"
  " */";
#else
static const char *Dtool_BitArray_get_next_higher_different_bit_508_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t BitArray::get_num_words(void) const
 */
static PyObject *Dtool_BitArray_get_num_words_509(PyObject *self, PyObject *) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t BitArray::get_num_words(void) const
  std::size_t return_value = (*(const BitArray*)local_this).get_num_words();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_num_words_509_comment =
  "C++ Interface:\n"
  "get_num_words(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns the number of possibly-unique words stored in the array.\n"
  " */";
#else
static const char *Dtool_BitArray_get_num_words_509_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitArray::MaskType BitArray::get_word(std::size_t n) const
 */
static PyObject *Dtool_BitArray_get_word_510(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BitArray::MaskType BitArray::get_word(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_word", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    BitArray::MaskType *return_value = new BitArray::MaskType((*(const BitArray*)local_this).get_word((std::size_t)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_word(BitArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_word_510_comment =
  "C++ Interface:\n"
  "get_word(BitArray self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth word in the array.  It is valid for n to be greater than\n"
  " * get_num_words(), but the return value beyond get_num_words() will always be\n"
  " * the same.\n"
  " */";
#else
static const char *Dtool_BitArray_get_word_510_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitArray::set_word(std::size_t n, BitArray::WordType value)
 */
static PyObject *Dtool_BitArray_set_word_511(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.set_word")) {
    return NULL;
  }
  // 1-inline void BitArray::set_word(std::size_t n, BitArray::WordType value)
  Py_ssize_t param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nk:set_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    (*local_this).set_word((std::size_t)param1, (BitArray::WordType)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const BitArray self, int n, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_set_word_511_comment =
  "C++ Interface:\n"
  "set_word(const BitArray self, int n, int value)\n"
  "\n"
  "/**\n"
  " * Replaces the nth word in the array.  If n >= get_num_words(), this\n"
  " * automatically extends the array.\n"
  " */";
#else
static const char *Dtool_BitArray_set_word_511_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitArray::invert_in_place(void)
 */
static PyObject *Dtool_BitArray_invert_in_place_512(PyObject *self, PyObject *) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.invert_in_place")) {
    return NULL;
  }
  // 1-void BitArray::invert_in_place(void)
  (*local_this).invert_in_place();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitArray_invert_in_place_512_comment =
  "C++ Interface:\n"
  "invert_in_place(const BitArray self)\n"
  "\n"
  "/**\n"
  " * Inverts all the bits in the BitArray.  This is equivalent to array =\n"
  " * ~array.\n"
  " */";
#else
static const char *Dtool_BitArray_invert_in_place_512_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool BitArray::has_bits_in_common(BitArray const &other) const
 */
static PyObject *Dtool_BitArray_has_bits_in_common_513(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool BitArray::has_bits_in_common(BitArray const &other) const
  BitArray const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_BitArray(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitArray.has_bits_in_common", "BitArray");
  }
  bool return_value = (*(const BitArray*)local_this).has_bits_in_common(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_bits_in_common(BitArray self, const BitArray other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_has_bits_in_common_513_comment =
  "C++ Interface:\n"
  "has_bits_in_common(BitArray self, const BitArray other)\n"
  "\n"
  "/**\n"
  " * Returns true if this BitArray has any \"one\" bits in common with the other\n"
  " * one, false otherwise.\n"
  " *\n"
  " * This is equivalent to (array & other) != 0, but may be faster.\n"
  " */";
#else
static const char *Dtool_BitArray_has_bits_in_common_513_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BitArray::clear(void)
 */
static PyObject *Dtool_BitArray_clear_514(PyObject *self, PyObject *) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.clear")) {
    return NULL;
  }
  // 1-inline void BitArray::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitArray_clear_514_comment =
  "C++ Interface:\n"
  "clear(const BitArray self)\n"
  "\n"
  "/**\n"
  " * Sets all the bits in the BitArray off.\n"
  " */";
#else
static const char *Dtool_BitArray_clear_514_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitArray::output(ostream &out) const
 */
static PyObject *Dtool_BitArray_output_515(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-void BitArray::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "BitArray.output", false, true);
  if (arg_this != NULL) {
    (*(const BitArray*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(BitArray self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_output_515_comment =
  "C++ Interface:\n"
  "output(BitArray self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes the BitArray out as a hex number.  For a BitArray, this is always\n"
  " * the same as output_hex(); it's too confusing for the output format to\n"
  " * change back and forth at runtime.\n"
  " */";
#else
static const char *Dtool_BitArray_output_515_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitArray::output_binary(ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_BitArray_output_binary_516(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-void BitArray::output_binary(ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_binary", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BitArray.output_binary", false, true);
    if (param1_this != NULL) {
      (*(const BitArray*)local_this).output_binary(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_binary(BitArray self, ostream out, int spaces_every)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_output_binary_516_comment =
  "C++ Interface:\n"
  "output_binary(BitArray self, ostream out, int spaces_every)\n"
  "\n"
  "/**\n"
  " * Writes the BitArray out as a binary number, with spaces every four bits.\n"
  " */";
#else
static const char *Dtool_BitArray_output_binary_516_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitArray::output_hex(ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_BitArray_output_hex_517(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-void BitArray::output_hex(ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_hex", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BitArray.output_hex", false, true);
    if (param1_this != NULL) {
      (*(const BitArray*)local_this).output_hex(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_hex(BitArray self, ostream out, int spaces_every)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_output_hex_517_comment =
  "C++ Interface:\n"
  "output_hex(BitArray self, ostream out, int spaces_every)\n"
  "\n"
  "/**\n"
  " * Writes the BitArray out as a hexadecimal number, with spaces every four\n"
  " * digits.\n"
  " */";
#else
static const char *Dtool_BitArray_output_hex_517_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitArray::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_BitArray_write_518(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-void BitArray::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BitArray.write", false, true);
    if (param1_this != NULL) {
      (*(const BitArray*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(BitArray self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_write_518_comment =
  "C++ Interface:\n"
  "write(BitArray self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the BitArray out as a binary or a hex number, according to the\n"
  " * number of bits.\n"
  " */";
#else
static const char *Dtool_BitArray_write_518_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int BitArray::compare_to(BitArray const &other) const
 */
static PyObject *Dtool_BitArray_compare_to_522(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-int BitArray::compare_to(BitArray const &other) const
  BitArray const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_BitArray(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitArray.compare_to", "BitArray");
  }
  int return_value = (*(const BitArray*)local_this).compare_to(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(BitArray self, const BitArray other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_compare_to_522_comment =
  "C++ Interface:\n"
  "compare_to(BitArray self, const BitArray other)\n"
  "\n"
  "/**\n"
  " * Returns a number less than zero if this BitArray sorts before the indicated\n"
  " * other BitArray, greater than zero if it sorts after, or 0 if they are\n"
  " * equivalent.  This is based on the same ordering defined by operator <.\n"
  " */";
#else
static const char *Dtool_BitArray_compare_to_522_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BitArray::operator |=(BitArray const &other)
 */
static PyObject *Dtool_BitArray_operator_530(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.__ior__")) {
    return NULL;
  }
  // 1-void BitArray::operator |=(BitArray const &other)
  BitArray const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_BitArray(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitArray.__ior__", "BitArray");
  }
  (*local_this).operator |=(*arg_this);
  BitArray *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__ior__(const BitArray self, const BitArray other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_operator_530_comment =
  "C++ Interface:\n"
  "__ior__(const BitArray self, const BitArray other)\n";
#else
static const char *Dtool_BitArray_operator_530_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BitArray::get_class_type(void)
 */
static PyObject *Dtool_BitArray_get_class_type_534(PyObject *, PyObject *) {
  // 1-static TypeHandle BitArray::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BitArray::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_class_type_534_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BitArray_get_class_type_534_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitArray::BitArray(void)
 * inline BitArray::BitArray(BitArray const &copy)
 * inline BitArray::BitArray(BitArray::WordType init_value)
 * BitArray::BitArray(SparseArray const &from)
 */
static int Dtool_Init_BitArray(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BitArray::BitArray(void)
      BitArray *return_value = new BitArray();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitArray, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline BitArray::BitArray(BitArray const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:BitArray", (char **)keyword_list, &param0)) {
          BitArray const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_BitArray, (void **)&param0_this);
          if (param0_this != NULL) {
            BitArray *return_value = new BitArray(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitArray, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 BitArray::BitArray(SparseArray const &from)
        PyObject *param0;
        static const char *keyword_list[] = {"from", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:BitArray", (char **)keyword_list, &param0)) {
          SparseArray const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_SparseArray, (void **)&param0_this);
          if (param0_this != NULL) {
            BitArray *return_value = new BitArray(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitArray, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline BitArray::BitArray(BitArray::WordType init_value)
        unsigned long param0;
        static const char *keyword_list[] = {"init_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "k:BitArray", (char **)keyword_list, &param0)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (param0 > UINT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %lu out of range for unsigned integer",
                         param0);
            return -1;
          }
#endif
          BitArray *return_value = new BitArray((BitArray::WordType)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitArray, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline BitArray::BitArray(BitArray const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:BitArray", (char **)keyword_list, &param0)) {
          BitArray const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_BitArray(param0, param0_this, param0_manage)) {
            BitArray *return_value = new BitArray(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitArray, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 BitArray::BitArray(SparseArray const &from)
        PyObject *param0;
        static const char *keyword_list[] = {"from", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:BitArray", (char **)keyword_list, &param0)) {
          SparseArray const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_SparseArray(param0, param0_this, param0_manage)) {
            BitArray *return_value = new BitArray(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitArray, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline BitArray::BitArray(BitArray::WordType init_value)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BitArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BitArray()\n"
      "BitArray(const BitArray copy)\n"
      "BitArray(const SparseArray from)\n"
      "BitArray(int init_value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BitArray(PyObject *args, BitArray const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BitArray, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 BitArray::BitArray(SparseArray const &from)
      SparseArray const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_SparseArray, (void **)&arg_this);
      if (arg_this != NULL) {
        BitArray *return_value = new BitArray(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

    {
      // -2 inline BitArray::BitArray(BitArray::WordType init_value)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param0 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param0);
          return false;
        }
#endif
        BitArray *return_value = new BitArray((BitArray::WordType)param0);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

  }
  return false;
}

bool Dtool_Coerce_BitArray(PyObject *args, BitArray *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BitArray, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 BitArray::BitArray(SparseArray const &from)
      SparseArray const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_SparseArray, (void **)&arg_this);
      if (arg_this != NULL) {
        BitArray *return_value = new BitArray(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

    {
      // -2 inline BitArray::BitArray(BitArray::WordType init_value)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param0 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param0);
          return false;
        }
#endif
        BitArray *return_value = new BitArray((BitArray::WordType)param0);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

  }
  return false;
}

static void *Dtool_UpcastInterface_BitArray(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BitArray) {
    printf("BitArray ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BitArray *local_this = (BitArray *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BitArray) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BitArray(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BitArray) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ButtonHandle
 */
/**
 * Python function wrapper for:
 * inline int ButtonHandle::compare_to(ButtonHandle const &other) const
 */
static PyObject *Dtool_ButtonHandle_compare_to_543(PyObject *self, PyObject *arg) {
  ButtonHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ButtonHandle::compare_to(ButtonHandle const &other) const
  ButtonHandle arg_local;
  ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ButtonHandle.compare_to", "ButtonHandle");
  }
  int return_value = (*(const ButtonHandle*)local_this).compare_to(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(ButtonHandle self, const ButtonHandle other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_compare_to_543_comment =
  "C++ Interface:\n"
  "compare_to(ButtonHandle self, const ButtonHandle other)\n"
  "\n"
  "/**\n"
  " * Sorts ButtonHandles arbitrarily (according to <, >, etc.).  Returns a\n"
  " * number less than 0 if this type sorts before the other one, greater than\n"
  " * zero if it sorts after, 0 if they are equivalent.\n"
  " */";
#else
static const char *Dtool_ButtonHandle_compare_to_543_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ButtonHandle::get_hash(void) const
 */
static PyObject *Dtool_ButtonHandle_get_hash_544(PyObject *self, PyObject *) {
  ButtonHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ButtonHandle::get_hash(void) const
  std::size_t return_value = (*(const ButtonHandle*)local_this).get_hash();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_get_hash_544_comment =
  "C++ Interface:\n"
  "get_hash(ButtonHandle self)\n"
  "\n"
  "/**\n"
  " * Returns a hash code suitable for phash_map.\n"
  " */";
#else
static const char *Dtool_ButtonHandle_get_hash_544_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string ButtonHandle::get_name(void) const
 */
static PyObject *Dtool_ButtonHandle_get_name_545(PyObject *self, PyObject *) {
  ButtonHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string ButtonHandle::get_name(void) const
  std::string return_value = (*(const ButtonHandle*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_get_name_545_comment =
  "C++ Interface:\n"
  "get_name(ButtonHandle self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the button.\n"
  " */";
#else
static const char *Dtool_ButtonHandle_get_name_545_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ButtonHandle::has_ascii_equivalent(void) const
 */
static PyObject *Dtool_ButtonHandle_has_ascii_equivalent_546(PyObject *self, PyObject *) {
  ButtonHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ButtonHandle::has_ascii_equivalent(void) const
  bool return_value = (*(const ButtonHandle*)local_this).has_ascii_equivalent();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_has_ascii_equivalent_546_comment =
  "C++ Interface:\n"
  "has_ascii_equivalent(ButtonHandle self)\n"
  "\n"
  "/**\n"
  " * Returns true if the button was created with an ASCII equivalent code (e.g.\n"
  " * for a standard keyboard button).\n"
  " */";
#else
static const char *Dtool_ButtonHandle_has_ascii_equivalent_546_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline char ButtonHandle::get_ascii_equivalent(void) const
 */
static PyObject *Dtool_ButtonHandle_get_ascii_equivalent_547(PyObject *self, PyObject *) {
  ButtonHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline char ButtonHandle::get_ascii_equivalent(void) const
  char return_value = (*(const ButtonHandle*)local_this).get_ascii_equivalent();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_get_ascii_equivalent_547_comment =
  "C++ Interface:\n"
  "get_ascii_equivalent(ButtonHandle self)\n"
  "\n"
  "/**\n"
  " * Returns the character code associated with the button, or '\\0' if no ASCII\n"
  " * code was associated.\n"
  " */";
#else
static const char *Dtool_ButtonHandle_get_ascii_equivalent_547_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ButtonHandle ButtonHandle::get_alias(void) const
 */
static PyObject *Dtool_ButtonHandle_get_alias_548(PyObject *self, PyObject *) {
  ButtonHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-ButtonHandle ButtonHandle::get_alias(void) const
  ButtonHandle *return_value = new ButtonHandle((*(const ButtonHandle*)local_this).get_alias());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_get_alias_548_comment =
  "C++ Interface:\n"
  "get_alias(ButtonHandle self)\n"
  "\n"
  "/**\n"
  " * Returns the alias (alternate name) associated with the button, if any, or\n"
  " * ButtonHandle::none() if the button has no alias.\n"
  " *\n"
  " * Each button is allowed to have one alias, and multiple different buttons\n"
  " * can refer to the same alias.  The alias should be the more general name for\n"
  " * the button, for instance, shift is an alias for lshift, but not vice-versa.\n"
  " */";
#else
static const char *Dtool_ButtonHandle_get_alias_548_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ButtonHandle::matches(ButtonHandle const &other) const
 */
static PyObject *Dtool_ButtonHandle_matches_549(PyObject *self, PyObject *arg) {
  ButtonHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ButtonHandle::matches(ButtonHandle const &other) const
  ButtonHandle arg_local;
  ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ButtonHandle.matches", "ButtonHandle");
  }
  bool return_value = (*(const ButtonHandle*)local_this).matches(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "matches(ButtonHandle self, const ButtonHandle other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_matches_549_comment =
  "C++ Interface:\n"
  "matches(ButtonHandle self, const ButtonHandle other)\n"
  "\n"
  "/**\n"
  " * Returns true if this ButtonHandle is the same as the other one, or if the\n"
  " * other one is an alias for this one.  (Does not return true if this button\n"
  " * is an alias for the other one, however.)\n"
  " *\n"
  " * This is a more general comparison than operator ==.\n"
  " */";
#else
static const char *Dtool_ButtonHandle_matches_549_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * constexpr int ButtonHandle::get_index(void) const
 */
static PyObject *Dtool_ButtonHandle_get_index_550(PyObject *self, PyObject *) {
  ButtonHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-constexpr int ButtonHandle::get_index(void) const
  int return_value = (*(const ButtonHandle*)local_this).get_index();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_get_index_550_comment =
  "C++ Interface:\n"
  "get_index(ButtonHandle self)\n"
  "\n"
  "/**\n"
  " * Returns the integer index associated with this ButtonHandle.  Each\n"
  " * different ButtonHandle will have a different index.  However, you probably\n"
  " * shouldn't be using this method; you should just treat the ButtonHandles as\n"
  " * opaque classes.  This is provided for the convenience of non-C++ scripting\n"
  " * languages to build a hashtable of ButtonHandles.\n"
  " */";
#else
static const char *Dtool_ButtonHandle_get_index_550_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ButtonHandle::output(ostream &out) const
 */
static PyObject *Dtool_ButtonHandle_output_551(PyObject *self, PyObject *arg) {
  ButtonHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void ButtonHandle::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ButtonHandle.output", false, true);
  if (arg_this != NULL) {
    (*(const ButtonHandle*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ButtonHandle self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_output_551_comment =
  "C++ Interface:\n"
  "output(ButtonHandle self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ButtonHandle_output_551_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline ButtonHandle ButtonHandle::none(void)
 */
static PyObject *Dtool_ButtonHandle_none_552(PyObject *, PyObject *) {
  // 1-static inline ButtonHandle ButtonHandle::none(void)
  ButtonHandle *return_value = new ButtonHandle(ButtonHandle::none());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_none_552_comment =
  "C++ Interface:\n"
  "none()\n"
  "\n"
  "/**\n"
  " * Returns a special zero-valued ButtonHandle that is used to indicate no\n"
  " * button.\n"
  " */";
#else
static const char *Dtool_ButtonHandle_none_552_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ButtonHandle::get_class_type(void)
 */
static PyObject *Dtool_ButtonHandle_get_class_type_561(PyObject *, PyObject *) {
  // 1-static TypeHandle ButtonHandle::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ButtonHandle::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_get_class_type_561_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ButtonHandle_get_class_type_561_comment = NULL;
#endif

static PyObject *Dtool_ButtonHandle_index_Getter(PyObject *self, void *) {
  const ButtonHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return NULL;
  }

  // 1-constexpr int ButtonHandle::get_index(void) const
  int return_value = (*(const ButtonHandle*)local_this).get_index();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ButtonHandle_name_Getter(PyObject *self, void *) {
  const ButtonHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return NULL;
  }

  // 1-std::string ButtonHandle::get_name(void) const
  std::string return_value = (*(const ButtonHandle*)local_this).get_name();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ButtonHandle_ascii_equivalent_Getter(PyObject *self, void *) {
  const ButtonHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_ascii_equivalent()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline char ButtonHandle::get_ascii_equivalent(void) const
  char return_value = (*(const ButtonHandle*)local_this).get_ascii_equivalent();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ButtonHandle_alias_Getter(PyObject *self, void *) {
  const ButtonHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return NULL;
  }

  // 1-ButtonHandle ButtonHandle::get_alias(void) const
  ButtonHandle *return_value = new ButtonHandle((*(const ButtonHandle*)local_this).get_alias());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

/**
 * Python function wrapper for:
 * inline ButtonHandle::ButtonHandle(void) = default
 * inline ButtonHandle::ButtonHandle(ButtonHandle const &copy)
 * constexpr ButtonHandle::ButtonHandle(int index)
 * ButtonHandle::ButtonHandle(std::string const &name)
 */
static int Dtool_Init_ButtonHandle(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline ButtonHandle::ButtonHandle(void) = default
      ButtonHandle *return_value = new ButtonHandle(0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonHandle, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline ButtonHandle::ButtonHandle(ButtonHandle const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ButtonHandle", (char **)keyword_list, &param0)) {
          ButtonHandle const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ButtonHandle, (void **)&param0_this);
          if (param0_this != NULL) {
            ButtonHandle *return_value = new ButtonHandle(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonHandle, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 ButtonHandle::ButtonHandle(std::string const &name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ButtonHandle", (char **)keyword_list, &param0_str, &param0_len)) {
          ButtonHandle *return_value = new ButtonHandle(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonHandle, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 constexpr ButtonHandle::ButtonHandle(int index)
        int param0;
        static const char *keyword_list[] = {"index", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:ButtonHandle", (char **)keyword_list, &param0)) {
          ButtonHandle *return_value = new ButtonHandle((int)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonHandle, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ButtonHandle::ButtonHandle(ButtonHandle const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ButtonHandle", (char **)keyword_list, &param0)) {
          ButtonHandle param0_local;
          ButtonHandle const *param0_this = Dtool_Coerce_ButtonHandle(param0, param0_local);
          if ((param0_this != NULL)) {
            ButtonHandle *return_value = new ButtonHandle(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonHandle, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: ButtonHandle::ButtonHandle(std::string const &name)
      // No coercion possible: constexpr ButtonHandle::ButtonHandle(int index)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ButtonHandle() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ButtonHandle()\n"
      "ButtonHandle(const ButtonHandle copy)\n"
      "ButtonHandle(str name)\n"
      "ButtonHandle(int index)\n");
  }
  return -1;
}

ButtonHandle *Dtool_Coerce_ButtonHandle(PyObject *args, ButtonHandle &coerced) {
  ButtonHandle *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ButtonHandle, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const ButtonHandle *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 ButtonHandle::ButtonHandle(std::string const &name)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        coerced = ButtonHandle(std::string(param0_str, param0_len));
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }

    {
      // -2 constexpr ButtonHandle::ButtonHandle(int index)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for signed integer",
                       arg_val);
          return NULL;
        }
#endif
        coerced = ButtonHandle((int)arg_val);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_ButtonHandle(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ButtonHandle) {
    printf("ButtonHandle ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ButtonHandle *local_this = (ButtonHandle *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ButtonHandle) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ButtonHandle(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ButtonHandle) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ButtonRegistry
 */
/**
 * Python function wrapper for:
 * ButtonHandle ButtonRegistry::get_button(std::string const &name)
 */
static PyObject *Dtool_ButtonRegistry_get_button_564(PyObject *self, PyObject *arg) {
  ButtonRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonRegistry, (void **)&local_this, "ButtonRegistry.get_button")) {
    return NULL;
  }
  // 1-ButtonHandle ButtonRegistry::get_button(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    ButtonHandle *return_value = new ButtonHandle((*local_this).get_button(std::string(param1_str, param1_len)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_button(const ButtonRegistry self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonRegistry_get_button_564_comment =
  "C++ Interface:\n"
  "get_button(const ButtonRegistry self, str name)\n"
  "\n"
  "/**\n"
  " * Finds a ButtonHandle in the registry matching the indicated name.  If there\n"
  " * is no such ButtonHandle, registers a new one and returns it.\n"
  " */";
#else
static const char *Dtool_ButtonRegistry_get_button_564_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ButtonHandle ButtonRegistry::find_button(std::string const &name)
 */
static PyObject *Dtool_ButtonRegistry_find_button_565(PyObject *self, PyObject *arg) {
  ButtonRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonRegistry, (void **)&local_this, "ButtonRegistry.find_button")) {
    return NULL;
  }
  // 1-ButtonHandle ButtonRegistry::find_button(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    ButtonHandle *return_value = new ButtonHandle((*local_this).find_button(std::string(param1_str, param1_len)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_button(const ButtonRegistry self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonRegistry_find_button_565_comment =
  "C++ Interface:\n"
  "find_button(const ButtonRegistry self, str name)\n"
  "\n"
  "/**\n"
  " * Finds a ButtonHandle in the registry matching the indicated name.  If there\n"
  " * is no such ButtonHandle, returns ButtonHandle::none().\n"
  " */";
#else
static const char *Dtool_ButtonRegistry_find_button_565_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ButtonHandle ButtonRegistry::find_ascii_button(char ascii_equivalent) const
 */
static PyObject *Dtool_ButtonRegistry_find_ascii_button_566(PyObject *self, PyObject *arg) {
  ButtonRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonRegistry, (void **)&local_this)) {
    return NULL;
  }
  // 1-ButtonHandle ButtonRegistry::find_ascii_button(char ascii_equivalent) const
  char param1;
  if (PyArg_Parse(arg, "c:find_ascii_button", &param1)) {
    ButtonHandle *return_value = new ButtonHandle((*(const ButtonRegistry*)local_this).find_ascii_button((char) param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_ascii_button(ButtonRegistry self, char ascii_equivalent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonRegistry_find_ascii_button_566_comment =
  "C++ Interface:\n"
  "find_ascii_button(ButtonRegistry self, char ascii_equivalent)\n"
  "\n"
  "/**\n"
  " * Finds a ButtonHandle in the registry matching the indicated ASCII\n"
  " * equivalent character.  If there is no such ButtonHandle, returns\n"
  " * ButtonHandle::none().\n"
  " */";
#else
static const char *Dtool_ButtonRegistry_find_ascii_button_566_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ButtonRegistry::write(ostream &out) const
 */
static PyObject *Dtool_ButtonRegistry_write_567(PyObject *self, PyObject *arg) {
  ButtonRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonRegistry, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ButtonRegistry::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ButtonRegistry.write", false, true);
  if (arg_this != NULL) {
    (*(const ButtonRegistry*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ButtonRegistry self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonRegistry_write_567_comment =
  "C++ Interface:\n"
  "write(ButtonRegistry self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ButtonRegistry_write_567_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline ButtonRegistry *ButtonRegistry::ptr(void)
 */
static PyObject *Dtool_ButtonRegistry_ptr_568(PyObject *, PyObject *) {
  // 1-static inline ButtonRegistry *ButtonRegistry::ptr(void)
  ButtonRegistry *return_value = ButtonRegistry::ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonRegistry, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ButtonRegistry_ptr_568_comment =
  "C++ Interface:\n"
  "ptr()\n"
  "\n"
  "// ptr() returns the pointer to the global ButtonRegistry object.\n"
  "\n"
  "/**\n"
  " * Returns the pointer to the global ButtonRegistry object.\n"
  " */";
#else
static const char *Dtool_ButtonRegistry_ptr_568_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ButtonRegistry::ButtonRegistry(ButtonRegistry const &) = default
 */
static int Dtool_Init_ButtonRegistry(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ButtonRegistry() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline ButtonRegistry::ButtonRegistry(ButtonRegistry const &) = default
  ButtonRegistry const *arg_this = (ButtonRegistry *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ButtonRegistry, 0, "ButtonRegistry.ButtonRegistry", true, true);
  if (arg_this != NULL) {
    ButtonRegistry *return_value = new ButtonRegistry(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonRegistry, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ButtonRegistry(const ButtonRegistry param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ButtonRegistry(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ButtonRegistry) {
    printf("ButtonRegistry ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ButtonRegistry *local_this = (ButtonRegistry *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ButtonRegistry) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ButtonRegistry(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ButtonRegistry) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ButtonMap
 */
/**
 * Python function wrapper for:
 * inline std::size_t ButtonMap::get_num_buttons(void) const
 */
static PyObject *Dtool_ButtonMap_get_num_buttons_573(PyObject *self, PyObject *) {
  ButtonMap *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonMap, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ButtonMap::get_num_buttons(void) const
  std::size_t return_value = (*(const ButtonMap*)local_this).get_num_buttons();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonMap_get_num_buttons_573_comment =
  "C++ Interface:\n"
  "get_num_buttons(ButtonMap self)\n"
  "\n"
  "/**\n"
  " * Returns the number of buttons that this button mapping specifies.\n"
  " */";
#else
static const char *Dtool_ButtonMap_get_num_buttons_573_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ButtonHandle ButtonMap::get_raw_button(std::size_t i) const
 */
static PyObject *Dtool_ButtonMap_get_raw_button_574(PyObject *self, PyObject *arg) {
  ButtonMap *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonMap, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ButtonHandle ButtonMap::get_raw_button(std::size_t i) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_raw_button", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ButtonHandle *return_value = new ButtonHandle((*(const ButtonMap*)local_this).get_raw_button((std::size_t)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_raw_button(ButtonMap self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonMap_get_raw_button_574_comment =
  "C++ Interface:\n"
  "get_raw_button(ButtonMap self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the underlying raw button associated with the nth button.\n"
  " */";
#else
static const char *Dtool_ButtonMap_get_raw_button_574_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ButtonHandle ButtonMap::get_mapped_button(ButtonHandle raw) const
 * inline ButtonHandle ButtonMap::get_mapped_button(std::size_t i) const
 * inline ButtonHandle ButtonMap::get_mapped_button(std::string const &raw_name) const
 */
static PyObject *Dtool_ButtonMap_get_mapped_button_575(PyObject *self, PyObject *arg) {
  ButtonMap *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonMap, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 inline ButtonHandle ButtonMap::get_mapped_button(ButtonHandle raw) const
    ButtonHandle *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_ButtonHandle, (void **)&arg_this);
    if (arg_this != NULL) {
      ButtonHandle *return_value = new ButtonHandle((*(const ButtonMap*)local_this).get_mapped_button(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
    }
  }

  {
    // -2 inline ButtonHandle ButtonMap::get_mapped_button(std::string const &raw_name) const
    char *param1_str = NULL;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      ButtonHandle *return_value = new ButtonHandle((*(const ButtonMap*)local_this).get_mapped_button(std::string(param1_str, param1_len)));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline ButtonHandle ButtonMap::get_mapped_button(std::size_t i) const
    Py_ssize_t param1;
    if (PyArg_Parse(arg, "n:get_mapped_button", &param1)) {
#ifndef NDEBUG
      if (param1 < 0) {
        return PyErr_Format(PyExc_OverflowError,
                            "can't convert negative value %zd to size_t",
                            param1);
      }
#endif
      ButtonHandle *return_value = new ButtonHandle((*(const ButtonMap*)local_this).get_mapped_button((std::size_t)param1));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline ButtonHandle ButtonMap::get_mapped_button(ButtonHandle raw) const
    ButtonHandle arg_local;
    ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
    if ((arg_this != NULL)) {
      ButtonHandle *return_value = new ButtonHandle((*(const ButtonMap*)local_this).get_mapped_button(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
    }
  }

  // No coercion possible: inline ButtonHandle ButtonMap::get_mapped_button(std::string const &raw_name) const
  // No coercion possible: inline ButtonHandle ButtonMap::get_mapped_button(std::size_t i) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_mapped_button(ButtonMap self, ButtonHandle raw)\n"
      "get_mapped_button(ButtonMap self, str raw_name)\n"
      "get_mapped_button(ButtonMap self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonMap_get_mapped_button_575_comment =
  "C++ Interface:\n"
  "get_mapped_button(ButtonMap self, ButtonHandle raw)\n"
  "get_mapped_button(ButtonMap self, str raw_name)\n"
  "get_mapped_button(ButtonMap self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the nth mapped button, meaning the button that the nth raw button\n"
  " * is mapped to.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the button that the given button is mapped to, or\n"
  " * ButtonHandle::none() if this map does not specify a mapped button for the\n"
  " * given raw button.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the button that the given button is mapped to, or\n"
  " * ButtonHandle::none() if this map does not specify a mapped button for the\n"
  " * given raw button.\n"
  " */";
#else
static const char *Dtool_ButtonMap_get_mapped_button_575_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ButtonMap::get_mapped_button_label(ButtonHandle raw) const
 * inline std::string const &ButtonMap::get_mapped_button_label(std::size_t i) const
 * inline std::string const &ButtonMap::get_mapped_button_label(std::string const &raw_name) const
 */
static PyObject *Dtool_ButtonMap_get_mapped_button_label_576(PyObject *self, PyObject *arg) {
  ButtonMap *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonMap, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 inline std::string const &ButtonMap::get_mapped_button_label(ButtonHandle raw) const
    ButtonHandle *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_ButtonHandle, (void **)&arg_this);
    if (arg_this != NULL) {
      std::string const &return_value = (*(const ButtonMap*)local_this).get_mapped_button_label(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline std::string const &ButtonMap::get_mapped_button_label(std::string const &raw_name) const
    char *param1_str = NULL;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      std::string const &return_value = (*(const ButtonMap*)local_this).get_mapped_button_label(std::string(param1_str, param1_len));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 inline std::string const &ButtonMap::get_mapped_button_label(std::size_t i) const
    Py_ssize_t param1;
    if (PyArg_Parse(arg, "n:get_mapped_button_label", &param1)) {
#ifndef NDEBUG
      if (param1 < 0) {
        return PyErr_Format(PyExc_OverflowError,
                            "can't convert negative value %zd to size_t",
                            param1);
      }
#endif
      std::string const &return_value = (*(const ButtonMap*)local_this).get_mapped_button_label((std::size_t)param1);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 inline std::string const &ButtonMap::get_mapped_button_label(ButtonHandle raw) const
    ButtonHandle arg_local;
    ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
    if ((arg_this != NULL)) {
      std::string const &return_value = (*(const ButtonMap*)local_this).get_mapped_button_label(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline std::string const &ButtonMap::get_mapped_button_label(std::string const &raw_name) const
  // No coercion possible: inline std::string const &ButtonMap::get_mapped_button_label(std::size_t i) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_mapped_button_label(ButtonMap self, ButtonHandle raw)\n"
      "get_mapped_button_label(ButtonMap self, str raw_name)\n"
      "get_mapped_button_label(ButtonMap self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonMap_get_mapped_button_label_576_comment =
  "C++ Interface:\n"
  "get_mapped_button_label(ButtonMap self, ButtonHandle raw)\n"
  "get_mapped_button_label(ButtonMap self, str raw_name)\n"
  "get_mapped_button_label(ButtonMap self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the label associated with the nth mapped button, meaning the button\n"
  " * that the nth raw button is mapped to.\n"
  " */\n"
  "\n"
  "/**\n"
  " * If the button map specifies a special name for the button (eg.  if the\n"
  " * operating system or keyboard device has a localized name describing the\n"
  " * key), returns it, or the empty string otherwise.\n"
  " *\n"
  " * Note that this is not the same as get_mapped_button().get_name(), which\n"
  " * returns the name of the Panda event associated with the button.\n"
  " */\n"
  "\n"
  "/**\n"
  " * If the button map specifies a special name for the button (eg.  if the\n"
  " * operating system or keyboard device has a localized name describing the\n"
  " * key), returns it, or the empty string otherwise.\n"
  " *\n"
  " * Note that this is not the same as get_mapped_button().get_name(), which\n"
  " * returns the name of the Panda event associated with the button.\n"
  " */";
#else
static const char *Dtool_ButtonMap_get_mapped_button_label_576_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ButtonMap::output(ostream &out) const
 */
static PyObject *Dtool_ButtonMap_output_577(PyObject *self, PyObject *arg) {
  ButtonMap *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonMap, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ButtonMap::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ButtonMap.output", false, true);
  if (arg_this != NULL) {
    (*(const ButtonMap*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ButtonMap self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonMap_output_577_comment =
  "C++ Interface:\n"
  "output(ButtonMap self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ButtonMap_output_577_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ButtonMap::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_ButtonMap_write_578(PyObject *self, PyObject *args, PyObject *kwds) {
  ButtonMap *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonMap, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ButtonMap::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "ButtonMap.write", false, true);
    if (param1_this != NULL) {
      (*(const ButtonMap*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ButtonMap self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonMap_write_578_comment =
  "C++ Interface:\n"
  "write(ButtonMap self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ButtonMap_write_578_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ButtonMap::get_class_type(void)
 */
static PyObject *Dtool_ButtonMap_get_class_type_579(PyObject *, PyObject *) {
  // 1-static TypeHandle ButtonMap::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ButtonMap::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ButtonMap_get_class_type_579_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ButtonMap_get_class_type_579_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ButtonMap::ButtonMap(void) = default
 * inline ButtonMap::ButtonMap(ButtonMap const &) = default
 */
static int Dtool_Init_ButtonMap(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline ButtonMap::ButtonMap(void) = default
      ButtonMap *return_value = new ButtonMap();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonMap, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline ButtonMap::ButtonMap(ButtonMap const &) = default
      ButtonMap const *arg_this = (ButtonMap *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ButtonMap, 0, "ButtonMap.ButtonMap", true, true);
      if (arg_this != NULL) {
        ButtonMap *return_value = new ButtonMap(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonMap, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ButtonMap() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ButtonMap()\n"
      "ButtonMap(const ButtonMap param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ButtonMap(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ButtonMap) {
    printf("ButtonMap ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ButtonMap *local_this = (ButtonMap *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ButtonMap) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ButtonMap(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ButtonMap) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ButtonMap*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ButtonMap*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (ButtonMap*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CallbackObject
 */
/**
 * Python function wrapper for:
 * virtual void CallbackObject::output(ostream &out) const
 */
static PyObject *Dtool_CallbackObject_output_583(PyObject *self, PyObject *arg) {
  CallbackObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CallbackObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void CallbackObject::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "CallbackObject.output", false, true);
  if (arg_this != NULL) {
    (*(const CallbackObject*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CallbackObject self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CallbackObject_output_583_comment =
  "C++ Interface:\n"
  "output(CallbackObject self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CallbackObject_output_583_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< CallbackObject > CallbackObject::make(PyObject *function)
 */
static PyObject *Dtool_CallbackObject_make_584(PyObject *, PyObject *arg) {
  // 1-static PointerTo< CallbackObject > CallbackObject::make(PyObject *function)
  PointerTo< CallbackObject > return_value = Extension<CallbackObject>::make(arg);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  CallbackObject *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_CallbackObject, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(object function)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CallbackObject_make_584_comment =
  "C++ Interface:\n"
  "make(object function)\n";
#else
static const char *Dtool_CallbackObject_make_584_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CallbackObject::get_class_type(void)
 */
static PyObject *Dtool_CallbackObject_get_class_type_585(PyObject *, PyObject *) {
  // 1-static TypeHandle CallbackObject::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CallbackObject::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CallbackObject_get_class_type_585_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CallbackObject_get_class_type_585_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CallbackObject::CallbackObject(CallbackObject const &) = default
 */
static int Dtool_Init_CallbackObject(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CallbackObject() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline CallbackObject::CallbackObject(CallbackObject const &) = default
  CPT(CallbackObject) arg_this;
  if (!Dtool_ConstCoerce_CallbackObject(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 0, "CallbackObject.CallbackObject", "CallbackObject");
    return -1;
  }
  CallbackObject *return_value = new CallbackObject(*MOVE(arg_this));
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CallbackObject, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CallbackObject(const CallbackObject param0)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CallbackObject(PyObject *args, CPT(CallbackObject) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CallbackObject, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static PointerTo< CallbackObject > CallbackObject::make(PyObject *function)
    PointerTo< CallbackObject > return_value = Extension<CallbackObject>::make(arg);
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != (PyObject *)NULL) {
      return false;
    } else {
      coerced = MOVE(DCAST(CallbackObject, return_value.p()));
      return true;
    }
  }
  return false;
}

bool Dtool_Coerce_CallbackObject(PyObject *args, PT(CallbackObject) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CallbackObject, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static PointerTo< CallbackObject > CallbackObject::make(PyObject *function)
    PointerTo< CallbackObject > return_value = Extension<CallbackObject>::make(arg);
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != (PyObject *)NULL) {
      return false;
    } else {
      coerced = MOVE(DCAST(CallbackObject, return_value.p()));
      return true;
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_CallbackObject(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CallbackObject) {
    printf("CallbackObject ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CallbackObject *local_this = (CallbackObject *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CallbackObject) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CallbackObject(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CallbackObject) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CallbackObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CallbackObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CallbackObject*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CachedTypedWritableReferenceCount
 */
/**
 * Python function wrapper for:
 * inline int CachedTypedWritableReferenceCount::get_cache_ref_count(void) const
 */
static PyObject *Dtool_CachedTypedWritableReferenceCount_get_cache_ref_count_589(PyObject *self, PyObject *) {
  CachedTypedWritableReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CachedTypedWritableReferenceCount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int CachedTypedWritableReferenceCount::get_cache_ref_count(void) const
  int return_value = (*(const CachedTypedWritableReferenceCount*)local_this).get_cache_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CachedTypedWritableReferenceCount_get_cache_ref_count_589_comment =
  "C++ Interface:\n"
  "get_cache_ref_count(CachedTypedWritableReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Returns the current reference count.\n"
  " */";
#else
static const char *Dtool_CachedTypedWritableReferenceCount_get_cache_ref_count_589_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CachedTypedWritableReferenceCount::cache_ref(void) const
 */
static PyObject *Dtool_CachedTypedWritableReferenceCount_cache_ref_590(PyObject *self, PyObject *) {
  CachedTypedWritableReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CachedTypedWritableReferenceCount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void CachedTypedWritableReferenceCount::cache_ref(void) const
  (*(const CachedTypedWritableReferenceCount*)local_this).cache_ref();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CachedTypedWritableReferenceCount_cache_ref_590_comment =
  "C++ Interface:\n"
  "cache_ref(CachedTypedWritableReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Explicitly increments the cache reference count and the normal reference\n"
  " * count simultaneously.\n"
  " */";
#else
static const char *Dtool_CachedTypedWritableReferenceCount_cache_ref_590_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CachedTypedWritableReferenceCount::cache_unref(void) const
 */
static PyObject *Dtool_CachedTypedWritableReferenceCount_cache_unref_591(PyObject *self, PyObject *) {
  CachedTypedWritableReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CachedTypedWritableReferenceCount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CachedTypedWritableReferenceCount::cache_unref(void) const
  bool return_value = (*(const CachedTypedWritableReferenceCount*)local_this).cache_unref();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CachedTypedWritableReferenceCount_cache_unref_591_comment =
  "C++ Interface:\n"
  "cache_unref(CachedTypedWritableReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Explicitly decrements the cache reference count and the normal reference\n"
  " * count simultaneously.\n"
  " *\n"
  " * The return value is true if the new reference count is nonzero, false if it\n"
  " * is zero.\n"
  " */";
#else
static const char *Dtool_CachedTypedWritableReferenceCount_cache_unref_591_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CachedTypedWritableReferenceCount::test_ref_count_integrity(void) const
 */
static PyObject *Dtool_CachedTypedWritableReferenceCount_test_ref_count_integrity_592(PyObject *self, PyObject *) {
  CachedTypedWritableReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CachedTypedWritableReferenceCount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CachedTypedWritableReferenceCount::test_ref_count_integrity(void) const
  bool return_value = (*(const CachedTypedWritableReferenceCount*)local_this).test_ref_count_integrity();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CachedTypedWritableReferenceCount_test_ref_count_integrity_592_comment =
  "C++ Interface:\n"
  "test_ref_count_integrity(CachedTypedWritableReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Does some easy checks to make sure that the reference count isn't\n"
  " * completely bogus.\n"
  " */";
#else
static const char *Dtool_CachedTypedWritableReferenceCount_test_ref_count_integrity_592_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CachedTypedWritableReferenceCount::get_class_type(void)
 */
static PyObject *Dtool_CachedTypedWritableReferenceCount_get_class_type_594(PyObject *, PyObject *) {
  // 1-static TypeHandle CachedTypedWritableReferenceCount::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CachedTypedWritableReferenceCount::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CachedTypedWritableReferenceCount_get_class_type_594_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CachedTypedWritableReferenceCount_get_class_type_594_comment = NULL;
#endif

static PyObject *Dtool_CachedTypedWritableReferenceCount_cache_ref_count_Getter(PyObject *self, void *) {
  const CachedTypedWritableReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CachedTypedWritableReferenceCount, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int CachedTypedWritableReferenceCount::get_cache_ref_count(void) const
  int return_value = (*(const CachedTypedWritableReferenceCount*)local_this).get_cache_ref_count();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_CachedTypedWritableReferenceCount(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_CachedTypedWritableReferenceCount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CachedTypedWritableReferenceCount) {
    printf("CachedTypedWritableReferenceCount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CachedTypedWritableReferenceCount *local_this = (CachedTypedWritableReferenceCount *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CachedTypedWritableReferenceCount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CachedTypedWritableReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CachedTypedWritableReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CachedTypedWritableReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CachedTypedWritableReferenceCount*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CallbackData
 */
/**
 * Python function wrapper for:
 * virtual void CallbackData::output(ostream &out) const
 */
static PyObject *Dtool_CallbackData_output_596(PyObject *self, PyObject *arg) {
  CallbackData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CallbackData, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void CallbackData::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "CallbackData.output", false, true);
  if (arg_this != NULL) {
    (*(const CallbackData*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CallbackData self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CallbackData_output_596_comment =
  "C++ Interface:\n"
  "output(CallbackData self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CallbackData_output_596_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void CallbackData::upcall(void)
 */
static PyObject *Dtool_CallbackData_upcall_597(PyObject *self, PyObject *) {
  CallbackData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackData, (void **)&local_this, "CallbackData.upcall")) {
    return NULL;
  }
  // 1-virtual void CallbackData::upcall(void)
  (*local_this).upcall();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CallbackData_upcall_597_comment =
  "C++ Interface:\n"
  "upcall(const CallbackData self)\n"
  "\n"
  "/**\n"
  " * You should make this call during the callback if you want to continue the\n"
  " * normal function that would have been done in the absence of a callback.\n"
  " */";
#else
static const char *Dtool_CallbackData_upcall_597_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CallbackData::get_class_type(void)
 */
static PyObject *Dtool_CallbackData_get_class_type_598(PyObject *, PyObject *) {
  // 1-static TypeHandle CallbackData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CallbackData::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CallbackData_get_class_type_598_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CallbackData_get_class_type_598_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CallbackData::CallbackData(CallbackData const &) = default
 */
static int Dtool_Init_CallbackData(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CallbackData() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline CallbackData::CallbackData(CallbackData const &) = default
  CallbackData const *arg_this = (CallbackData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CallbackData, 0, "CallbackData.CallbackData", true, true);
  if (arg_this != NULL) {
    CallbackData *return_value = new CallbackData(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CallbackData, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CallbackData(const CallbackData param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CallbackData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CallbackData) {
    printf("CallbackData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CallbackData *local_this = (CallbackData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CallbackData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CallbackData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CallbackData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CallbackData*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PythonCallbackObject
 */
/**
 * Python function wrapper for:
 * void PythonCallbackObject::set_function(PyObject *function)
 */
static PyObject *Dtool_PythonCallbackObject_set_function_606(PyObject *self, PyObject *arg) {
  PythonCallbackObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonCallbackObject, (void **)&local_this, "PythonCallbackObject.set_function")) {
    return NULL;
  }
  // 1-void PythonCallbackObject::set_function(PyObject *function)
  (*local_this).set_function(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_function(const PythonCallbackObject self, object function)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PythonCallbackObject_set_function_606_comment =
  "C++ Interface:\n"
  "set_function(const PythonCallbackObject self, object function)\n"
  "\n"
  "/**\n"
  " * Replaces the function that is called for the callback.  runs.  The\n"
  " * parameter should be a Python callable object.\n"
  " */";
#else
static const char *Dtool_PythonCallbackObject_set_function_606_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *PythonCallbackObject::get_function(void)
 */
static PyObject *Dtool_PythonCallbackObject_get_function_607(PyObject *self, PyObject *) {
  PythonCallbackObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonCallbackObject, (void **)&local_this, "PythonCallbackObject.get_function")) {
    return NULL;
  }
  // 1-PyObject *PythonCallbackObject::get_function(void)
  PyObject *return_value = (*local_this).get_function();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PythonCallbackObject_get_function_607_comment =
  "C++ Interface:\n"
  "get_function(const PythonCallbackObject self)\n"
  "\n"
  "/**\n"
  " * Returns the function that is called for the callback.\n"
  " */";
#else
static const char *Dtool_PythonCallbackObject_get_function_607_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PythonCallbackObject::get_class_type(void)
 */
static PyObject *Dtool_PythonCallbackObject_get_class_type_609(PyObject *, PyObject *) {
  // 1-static TypeHandle PythonCallbackObject::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PythonCallbackObject::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PythonCallbackObject_get_class_type_609_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PythonCallbackObject_get_class_type_609_comment = NULL;
#endif

static PyObject *Dtool_PythonCallbackObject_function_Getter(PyObject *self, void *) {
  PythonCallbackObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonCallbackObject, (void **)&local_this, "PythonCallbackObject.function")) {
    return NULL;
  }

  // 1-PyObject *PythonCallbackObject::get_function(void)
  PyObject *return_value = (*local_this).get_function();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PythonCallbackObject_function_Setter(PyObject *self, PyObject *arg, void *) {
  PythonCallbackObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonCallbackObject, (void **)&local_this, "PythonCallbackObject.function")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete function attribute");
    return -1;
  }
  // 1-void PythonCallbackObject::set_function(PyObject *function)
  (*local_this).set_function(arg);
  if (Dtool_CheckErrorOccurred()) {
    return -1;
  }
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_function(const PythonCallbackObject self, object function)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * PythonCallbackObject::PythonCallbackObject(PyObject *function = (& ::_Py_NoneStruct))
 * inline PythonCallbackObject::PythonCallbackObject(PythonCallbackObject const &) = default
 */
static int Dtool_Init_PythonCallbackObject(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PythonCallbackObject::PythonCallbackObject(PyObject *function)
      PythonCallbackObject *return_value = new PythonCallbackObject();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PythonCallbackObject, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PythonCallbackObject::PythonCallbackObject(PythonCallbackObject const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PythonCallbackObject", (char **)keyword_list, &param0)) {
          PythonCallbackObject const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PythonCallbackObject, (void **)&param0_this);
          if (param0_this != NULL) {
            PythonCallbackObject *return_value = new PythonCallbackObject(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PythonCallbackObject, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PythonCallbackObject::PythonCallbackObject(PyObject *function)
        PyObject *param0;
        static const char *keyword_list[] = {"function", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PythonCallbackObject", (char **)keyword_list, &param0)) {
          PythonCallbackObject *return_value = new PythonCallbackObject(param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            unref_delete(return_value);
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              unref_delete(return_value);
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PythonCallbackObject, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PythonCallbackObject::PythonCallbackObject(PythonCallbackObject const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PythonCallbackObject", (char **)keyword_list, &param0)) {
          CPT(PythonCallbackObject) param0_this;
          if (Dtool_ConstCoerce_PythonCallbackObject(param0, param0_this)) {
            PythonCallbackObject *return_value = new PythonCallbackObject(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PythonCallbackObject, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PythonCallbackObject::PythonCallbackObject(PyObject *function)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PythonCallbackObject() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PythonCallbackObject()\n"
      "PythonCallbackObject(const PythonCallbackObject param0)\n"
      "PythonCallbackObject(object function)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PythonCallbackObject(PyObject *args, CPT(PythonCallbackObject) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PythonCallbackObject, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PythonCallbackObject::PythonCallbackObject(PyObject *function)
    PythonCallbackObject *return_value = new PythonCallbackObject(arg);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return false;
    }
    return_value->ref();
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != (PyObject *)NULL) {
      unref_delete(return_value);
      return false;
    } else {
      coerced = MOVE(return_value);
      return true;
    }
  }
  return false;
}

bool Dtool_Coerce_PythonCallbackObject(PyObject *args, PT(PythonCallbackObject) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PythonCallbackObject, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PythonCallbackObject::PythonCallbackObject(PyObject *function)
    PythonCallbackObject *return_value = new PythonCallbackObject(arg);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return false;
    }
    return_value->ref();
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != (PyObject *)NULL) {
      unref_delete(return_value);
      return false;
    } else {
      coerced = MOVE(return_value);
      return true;
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_PythonCallbackObject(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PythonCallbackObject) {
    printf("PythonCallbackObject ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PythonCallbackObject *local_this = (PythonCallbackObject *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PythonCallbackObject) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CallbackObject) {
    return (CallbackObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CallbackObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CallbackObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CallbackObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PythonCallbackObject(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PythonCallbackObject) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CallbackObject) {
    CallbackObject* other_this = (CallbackObject*)from_this;
    return (PythonCallbackObject*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PythonCallbackObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PythonCallbackObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (PythonCallbackObject*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class TimeVal
 */
/**
 * Python function wrapper for:
 * inline ulong TimeVal::get_sec(void) const
 */
static PyObject *Dtool_TimeVal_get_sec_612(PyObject *self, PyObject *) {
  TimeVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TimeVal, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ulong TimeVal::get_sec(void) const
  ulong return_value = (*(const TimeVal*)local_this).get_sec();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TimeVal_get_sec_612_comment =
  "C++ Interface:\n"
  "get_sec(TimeVal self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TimeVal_get_sec_612_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ulong TimeVal::get_usec(void) const
 */
static PyObject *Dtool_TimeVal_get_usec_613(PyObject *self, PyObject *) {
  TimeVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TimeVal, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ulong TimeVal::get_usec(void) const
  ulong return_value = (*(const TimeVal*)local_this).get_usec();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TimeVal_get_usec_613_comment =
  "C++ Interface:\n"
  "get_usec(TimeVal self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TimeVal_get_usec_613_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TimeVal::TimeVal(void)
 */
static int Dtool_Init_TimeVal(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "TimeVal() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline TimeVal::TimeVal(void)
  TimeVal *return_value = new TimeVal();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TimeVal, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TimeVal()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TimeVal(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TimeVal) {
    printf("TimeVal ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TimeVal *local_this = (TimeVal *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TimeVal) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TimeVal(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TimeVal) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ClockObject
 */
/**
 * Python function wrapper for:
 * void ClockObject::set_mode(ClockObject::Mode mode)
 */
static PyObject *Dtool_ClockObject_set_mode_624(PyObject *self, PyObject *arg) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.set_mode")) {
    return NULL;
  }
  // 1-void ClockObject::set_mode(ClockObject::Mode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_mode((ClockObject::Mode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mode(const ClockObject self, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_set_mode_624_comment =
  "C++ Interface:\n"
  "set_mode(const ClockObject self, int mode)\n"
  "\n"
  "/**\n"
  " * Changes the mode of the clock.  Normally, the clock is in mode M_normal.\n"
  " * In this mode, each call to tick() will set the value returned by\n"
  " * get_frame_time() to the current real time; thus, the clock simply reports\n"
  " * time advancing.\n"
  " *\n"
  " * Other possible modes:\n"
  " *\n"
  " * M_non_real_time - the clock ignores real time completely; at each call to\n"
  " * tick(), it pretends that exactly dt seconds have elapsed since the last\n"
  " * call to tick().  You may set the value of dt with set_dt() or\n"
  " * set_frame_rate().\n"
  " *\n"
  " * M_limited - the clock will run as fast as it can, as in M_normal, but will\n"
  " * not run faster than the rate specified by set_frame_rate().  If the\n"
  " * application would run faster than this rate, the clock will slow down the\n"
  " * application.\n"
  " *\n"
  " * M_integer - the clock will run as fast as it can, but the rate will be\n"
  " * constrained to be an integer multiple or divisor of the rate specified by\n"
  " * set_frame_rate().  The clock will slow down the application a bit to\n"
  " * guarantee this.\n"
  " *\n"
  " * M_integer_limited - a combination of M_limited and M_integer; the clock\n"
  " * will not run faster than set_frame_rate(), and if it runs slower, it will\n"
  " * run at a integer divisor of that rate.\n"
  " *\n"
  " * M_forced - the clock forces the application to run at the rate specified by\n"
  " * set_frame_rate().  If the application would run faster than this rate, the\n"
  " * clock will slow down the application; if the application would run slower\n"
  " * than this rate, the clock slows down time so that the application believes\n"
  " * it is running at the given rate.\n"
  " *\n"
  " * M_degrade - the clock runs at real time, but the application is slowed down\n"
  " * by a set factor of its frame rate, specified by set_degrade_factor().\n"
  " *\n"
  " * M_slave - the clock does not advance, but relies on the user to call\n"
  " * set_frame_time() and/or set_frame_count() each frame.\n"
  " */";
#else
static const char *Dtool_ClockObject_set_mode_624_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ClockObject::Mode ClockObject::get_mode(void) const
 */
static PyObject *Dtool_ClockObject_get_mode_625(PyObject *self, PyObject *) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ClockObject::Mode ClockObject::get_mode(void) const
  ClockObject::Mode return_value = (*(const ClockObject*)local_this).get_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_mode_625_comment =
  "C++ Interface:\n"
  "get_mode(ClockObject self)\n"
  "\n"
  "/**\n"
  " * Returns the current mode of the clock.  See set_mode().\n"
  " */";
#else
static const char *Dtool_ClockObject_get_mode_625_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double ClockObject::get_frame_time(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_ClockObject_get_frame_time_627(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline double ClockObject::get_frame_time(Thread *current_thread) const
      double return_value = (*(const ClockObject*)local_this).get_frame_time();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "current_thread");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'current_thread' (pos 1) not found");
      }
      // 1-inline double ClockObject::get_frame_time(Thread *current_thread) const
      Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "ClockObject.get_frame_time", false, true);
      if (arg_this != NULL) {
        double return_value = (*(const ClockObject*)local_this).get_frame_time(arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_frame_time() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_frame_time(ClockObject self)\n"
      "get_frame_time(ClockObject self, Thread current_thread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_frame_time_627_comment =
  "C++ Interface:\n"
  "get_frame_time(ClockObject self)\n"
  "get_frame_time(ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the time in seconds as of the last time tick() was called\n"
  " * (typically, this will be as of the start of the current frame).\n"
  " *\n"
  " * This is generally the kind of time you want to ask for in most rendering\n"
  " * and animation contexts, since it's important that all of the animation for\n"
  " * a given frame remains in sync with each other.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_frame_time_627_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double ClockObject::get_real_time(void) const
 */
static PyObject *Dtool_ClockObject_get_real_time_628(PyObject *self, PyObject *) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double ClockObject::get_real_time(void) const
  double return_value = (*(const ClockObject*)local_this).get_real_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_real_time_628_comment =
  "C++ Interface:\n"
  "get_real_time(ClockObject self)\n"
  "\n"
  "/**\n"
  " * Returns the actual number of seconds elapsed since the ClockObject was\n"
  " * created, or since it was last reset.  This is useful for doing real timing\n"
  " * measurements, e.g.  for performance statistics.\n"
  " *\n"
  " * This returns the most precise timer we have for short time intervals, but\n"
  " * it may tend to drift over the long haul.  If more accurate timekeeping is\n"
  " * needed over a long period of time, use get_long_time() instead.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_real_time_628_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double ClockObject::get_long_time(void) const
 */
static PyObject *Dtool_ClockObject_get_long_time_629(PyObject *self, PyObject *) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double ClockObject::get_long_time(void) const
  double return_value = (*(const ClockObject*)local_this).get_long_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_long_time_629_comment =
  "C++ Interface:\n"
  "get_long_time(ClockObject self)\n"
  "\n"
  "/**\n"
  " * Returns the actual number of seconds elapsed since the ClockObject was\n"
  " * created, or since it was last reset.\n"
  " *\n"
  " * This is similar to get_real_time(), except that it uses the most accurate\n"
  " * counter we have over a long period of time, and so it is less likely to\n"
  " * drift.  However, it may not be very precise for measuring short intervals.\n"
  " * On Windows, for instace, this is only accurate to within about 55\n"
  " * milliseconds.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_long_time_629_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ClockObject::reset(void)
 */
static PyObject *Dtool_ClockObject_reset_630(PyObject *self, PyObject *) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.reset")) {
    return NULL;
  }
  // 1-inline void ClockObject::reset(void)
  (*local_this).reset();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_reset_630_comment =
  "C++ Interface:\n"
  "reset(const ClockObject self)\n"
  "\n"
  "/**\n"
  " * Simultaneously resets both the time and the frame count to zero.\n"
  " */";
#else
static const char *Dtool_ClockObject_reset_630_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ClockObject::set_real_time(double time)
 */
static PyObject *Dtool_ClockObject_set_real_time_631(PyObject *self, PyObject *arg) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.set_real_time")) {
    return NULL;
  }
  // 1-void ClockObject::set_real_time(double time)
  if (PyNumber_Check(arg)) {
    (*local_this).set_real_time(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_real_time(const ClockObject self, double time)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_set_real_time_631_comment =
  "C++ Interface:\n"
  "set_real_time(const ClockObject self, double time)\n"
  "\n"
  "/**\n"
  " * Resets the clock to the indicated time.  This changes only the real time of\n"
  " * the clock as reported by get_real_time(), but does not immediately change\n"
  " * the time reported by get_frame_time()--that will change after the next call\n"
  " * to tick().  Also see reset(), set_frame_time(), and set_frame_count().\n"
  " */";
#else
static const char *Dtool_ClockObject_set_real_time_631_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ClockObject::set_frame_time(double time, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_ClockObject_set_frame_time_632(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.set_frame_time")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "time");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'time' (pos 1) not found");
      }
      // 1-void ClockObject::set_frame_time(double time, Thread *current_thread)
      if (PyNumber_Check(arg)) {
        (*local_this).set_frame_time(PyFloat_AsDouble(arg));
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void ClockObject::set_frame_time(double time, Thread *current_thread)
      double param1;
      PyObject *param2;
      static const char *keyword_list[] = {"time", "current_thread", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dO:set_frame_time", (char **)keyword_list, &param1, &param2)) {
        Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "ClockObject.set_frame_time", false, true);
        if (param2_this != NULL) {
          (*local_this).set_frame_time((double)param1, param2_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_frame_time() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_time(const ClockObject self, double time)\n"
      "set_frame_time(const ClockObject self, double time, Thread current_thread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_set_frame_time_632_comment =
  "C++ Interface:\n"
  "set_frame_time(const ClockObject self, double time)\n"
  "set_frame_time(const ClockObject self, double time, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Changes the time as reported for the current frame to the indicated time.\n"
  " * Normally, the way to adjust the frame time is via tick(); this function is\n"
  " * provided only for occasional special adjustments.\n"
  " */";
#else
static const char *Dtool_ClockObject_set_frame_time_632_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ClockObject::set_frame_count(int frame_count, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_ClockObject_set_frame_count_633(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.set_frame_count")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "frame_count");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'frame_count' (pos 1) not found");
      }
      // 1-void ClockObject::set_frame_count(int frame_count, Thread *current_thread)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        (*local_this).set_frame_count((int)arg_val);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void ClockObject::set_frame_count(int frame_count, Thread *current_thread)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"frame_count", "current_thread", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_frame_count", (char **)keyword_list, &param1, &param2)) {
        Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "ClockObject.set_frame_count", false, true);
        if (param2_this != NULL) {
          (*local_this).set_frame_count((int)param1, param2_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_frame_count() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_count(const ClockObject self, int frame_count)\n"
      "set_frame_count(const ClockObject self, int frame_count, Thread current_thread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_set_frame_count_633_comment =
  "C++ Interface:\n"
  "set_frame_count(const ClockObject self, int frame_count)\n"
  "set_frame_count(const ClockObject self, int frame_count, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Resets the number of frames counted to the indicated number.  Also see\n"
  " * reset(), set_real_time(), and set_frame_time().\n"
  " */";
#else
static const char *Dtool_ClockObject_set_frame_count_633_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ClockObject::get_frame_count(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_ClockObject_get_frame_count_634(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline int ClockObject::get_frame_count(Thread *current_thread) const
      int return_value = (*(const ClockObject*)local_this).get_frame_count();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "current_thread");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'current_thread' (pos 1) not found");
      }
      // 1-inline int ClockObject::get_frame_count(Thread *current_thread) const
      Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "ClockObject.get_frame_count", false, true);
      if (arg_this != NULL) {
        int return_value = (*(const ClockObject*)local_this).get_frame_count(arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_frame_count() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_frame_count(ClockObject self)\n"
      "get_frame_count(ClockObject self, Thread current_thread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_frame_count_634_comment =
  "C++ Interface:\n"
  "get_frame_count(ClockObject self)\n"
  "get_frame_count(ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the number of times tick() has been called since the ClockObject\n"
  " * was created, or since it was last reset.  This is generally the number of\n"
  " * frames that have been rendered.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_frame_count_634_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double ClockObject::get_net_frame_rate(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_ClockObject_get_net_frame_rate_635(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline double ClockObject::get_net_frame_rate(Thread *current_thread) const
      double return_value = (*(const ClockObject*)local_this).get_net_frame_rate();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "current_thread");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'current_thread' (pos 1) not found");
      }
      // 1-inline double ClockObject::get_net_frame_rate(Thread *current_thread) const
      Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "ClockObject.get_net_frame_rate", false, true);
      if (arg_this != NULL) {
        double return_value = (*(const ClockObject*)local_this).get_net_frame_rate(arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_net_frame_rate() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_net_frame_rate(ClockObject self)\n"
      "get_net_frame_rate(ClockObject self, Thread current_thread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_net_frame_rate_635_comment =
  "C++ Interface:\n"
  "get_net_frame_rate(ClockObject self)\n"
  "get_net_frame_rate(ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the average frame rate since the last reset.  This is simply the\n"
  " * total number of frames divided by the total elapsed time.  This reports the\n"
  " * virtual frame rate if the clock is in (or has been in) M_non_real_time\n"
  " * mode.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_net_frame_rate_635_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double ClockObject::get_dt(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_ClockObject_get_dt_640(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline double ClockObject::get_dt(Thread *current_thread) const
      double return_value = (*(const ClockObject*)local_this).get_dt();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "current_thread");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'current_thread' (pos 1) not found");
      }
      // 1-inline double ClockObject::get_dt(Thread *current_thread) const
      Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "ClockObject.get_dt", false, true);
      if (arg_this != NULL) {
        double return_value = (*(const ClockObject*)local_this).get_dt(arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_dt() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_dt(ClockObject self)\n"
      "get_dt(ClockObject self, Thread current_thread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_dt_640_comment =
  "C++ Interface:\n"
  "get_dt(ClockObject self)\n"
  "get_dt(ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the elapsed time for the previous frame: the number of seconds\n"
  " * elapsed between the last two calls to tick().\n"
  " */";
#else
static const char *Dtool_ClockObject_get_dt_640_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ClockObject::set_dt(double dt)
 */
static PyObject *Dtool_ClockObject_set_dt_641(PyObject *self, PyObject *arg) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.set_dt")) {
    return NULL;
  }
  // 1-void ClockObject::set_dt(double dt)
  if (PyNumber_Check(arg)) {
    (*local_this).set_dt(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_dt(const ClockObject self, double dt)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_set_dt_641_comment =
  "C++ Interface:\n"
  "set_dt(const ClockObject self, double dt)\n"
  "\n"
  "/**\n"
  " * In non-real-time mode, sets the number of seconds that should appear to\n"
  " * elapse between frames.  In forced mode or limited mode, sets our target dt.\n"
  " * In normal mode, this has no effect.\n"
  " *\n"
  " * Also see set_frame_rate(), which is a different way to specify the same\n"
  " * quantity.\n"
  " */";
#else
static const char *Dtool_ClockObject_set_dt_641_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ClockObject::set_frame_rate(double frame_rate)
 */
static PyObject *Dtool_ClockObject_set_frame_rate_642(PyObject *self, PyObject *arg) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.set_frame_rate")) {
    return NULL;
  }
  // 1-void ClockObject::set_frame_rate(double frame_rate)
  if (PyNumber_Check(arg)) {
    (*local_this).set_frame_rate(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_rate(const ClockObject self, double frame_rate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_set_frame_rate_642_comment =
  "C++ Interface:\n"
  "set_frame_rate(const ClockObject self, double frame_rate)\n"
  "\n"
  "/**\n"
  " * In non-real-time mode, sets the number of frames per second that we should\n"
  " * appear to be running.  In forced mode or limited mode, sets our target\n"
  " * frame rate.  In normal mode, this has no effect.\n"
  " *\n"
  " * Also see set_dt(), which is a different way to specify the same quantity.\n"
  " */";
#else
static const char *Dtool_ClockObject_set_frame_rate_642_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double ClockObject::get_max_dt(void) const
 */
static PyObject *Dtool_ClockObject_get_max_dt_644(PyObject *self, PyObject *) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double ClockObject::get_max_dt(void) const
  double return_value = (*(const ClockObject*)local_this).get_max_dt();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_max_dt_644_comment =
  "C++ Interface:\n"
  "get_max_dt(ClockObject self)\n"
  "\n"
  "/**\n"
  " * Returns the current maximum allowable time elapsed between any two frames.\n"
  " * See set_max_dt().\n"
  " */";
#else
static const char *Dtool_ClockObject_get_max_dt_644_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ClockObject::set_max_dt(double max_dt)
 */
static PyObject *Dtool_ClockObject_set_max_dt_645(PyObject *self, PyObject *arg) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.set_max_dt")) {
    return NULL;
  }
  // 1-inline void ClockObject::set_max_dt(double max_dt)
  if (PyNumber_Check(arg)) {
    (*local_this).set_max_dt(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_dt(const ClockObject self, double max_dt)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_set_max_dt_645_comment =
  "C++ Interface:\n"
  "set_max_dt(const ClockObject self, double max_dt)\n"
  "\n"
  "/**\n"
  " * Sets a limit on the value returned by get_dt().  If this value is less than\n"
  " * zero, no limit is imposed; otherwise, this is the maximum value that will\n"
  " * ever be returned by get_dt(), regardless of how much time has actually\n"
  " * elapsed between frames.\n"
  " *\n"
  " * This limit is only imposed in real-time mode; in non-real-time mode, the dt\n"
  " * is fixed anyway and max_dt is ignored.\n"
  " *\n"
  " * This is generally used to guarantee reasonable behavior even in the\n"
  " * presence of a very slow or chuggy frame rame.\n"
  " */";
#else
static const char *Dtool_ClockObject_set_max_dt_645_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double ClockObject::get_degrade_factor(void) const
 */
static PyObject *Dtool_ClockObject_get_degrade_factor_647(PyObject *self, PyObject *) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double ClockObject::get_degrade_factor(void) const
  double return_value = (*(const ClockObject*)local_this).get_degrade_factor();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_degrade_factor_647_comment =
  "C++ Interface:\n"
  "get_degrade_factor(ClockObject self)\n"
  "\n"
  "/**\n"
  " * In degrade mode, returns the ratio by which the performance is degraded.  A\n"
  " * value of 2.0 causes the clock to be slowed down by a factor of two\n"
  " * (reducing performance to 1/2 what would be otherwise).\n"
  " *\n"
  " * This has no effect if mode is not M_degrade.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_degrade_factor_647_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ClockObject::set_degrade_factor(double degrade_factor)
 */
static PyObject *Dtool_ClockObject_set_degrade_factor_648(PyObject *self, PyObject *arg) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.set_degrade_factor")) {
    return NULL;
  }
  // 1-inline void ClockObject::set_degrade_factor(double degrade_factor)
  if (PyNumber_Check(arg)) {
    (*local_this).set_degrade_factor(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_degrade_factor(const ClockObject self, double degrade_factor)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_set_degrade_factor_648_comment =
  "C++ Interface:\n"
  "set_degrade_factor(const ClockObject self, double degrade_factor)\n"
  "\n"
  "/**\n"
  " * In degrade mode, sets the ratio by which the performance is degraded.  A\n"
  " * value of 2.0 causes the clock to be slowed down by a factor of two\n"
  " * (reducing performance to 1/2 what would be otherwise).\n"
  " *\n"
  " * This has no effect if mode is not M_degrade.\n"
  " */";
#else
static const char *Dtool_ClockObject_set_degrade_factor_648_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ClockObject::set_average_frame_rate_interval(double time)
 */
static PyObject *Dtool_ClockObject_set_average_frame_rate_interval_650(PyObject *self, PyObject *arg) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.set_average_frame_rate_interval")) {
    return NULL;
  }
  // 1-inline void ClockObject::set_average_frame_rate_interval(double time)
  if (PyNumber_Check(arg)) {
    (*local_this).set_average_frame_rate_interval(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_average_frame_rate_interval(const ClockObject self, double time)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_set_average_frame_rate_interval_650_comment =
  "C++ Interface:\n"
  "set_average_frame_rate_interval(const ClockObject self, double time)\n"
  "\n"
  "/**\n"
  " * Specifies the interval of time (in seconds) over which\n"
  " * get_average_frame_rate() averages the number of frames per second to\n"
  " * compute the frame rate.  Changing this does not necessarily immediately\n"
  " * change the result of get_average_frame_rate(), until this interval of time\n"
  " * has elapsed again.\n"
  " *\n"
  " * Setting this to zero disables the computation of get_average_frame_rate().\n"
  " */";
#else
static const char *Dtool_ClockObject_set_average_frame_rate_interval_650_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double ClockObject::get_average_frame_rate_interval(void) const
 */
static PyObject *Dtool_ClockObject_get_average_frame_rate_interval_651(PyObject *self, PyObject *) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double ClockObject::get_average_frame_rate_interval(void) const
  double return_value = (*(const ClockObject*)local_this).get_average_frame_rate_interval();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_average_frame_rate_interval_651_comment =
  "C++ Interface:\n"
  "get_average_frame_rate_interval(ClockObject self)\n"
  "\n"
  "/**\n"
  " * Returns the interval of time (in seconds) over which\n"
  " * get_average_frame_rate() averages the number of frames per second to\n"
  " * compute the frame rate.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_average_frame_rate_interval_651_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double ClockObject::get_average_frame_rate(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_ClockObject_get_average_frame_rate_653(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-double ClockObject::get_average_frame_rate(Thread *current_thread) const
      double return_value = (*(const ClockObject*)local_this).get_average_frame_rate();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "current_thread");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'current_thread' (pos 1) not found");
      }
      // 1-double ClockObject::get_average_frame_rate(Thread *current_thread) const
      Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "ClockObject.get_average_frame_rate", false, true);
      if (arg_this != NULL) {
        double return_value = (*(const ClockObject*)local_this).get_average_frame_rate(arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_average_frame_rate() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_average_frame_rate(ClockObject self)\n"
      "get_average_frame_rate(ClockObject self, Thread current_thread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_average_frame_rate_653_comment =
  "C++ Interface:\n"
  "get_average_frame_rate(ClockObject self)\n"
  "get_average_frame_rate(ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the average frame rate in number of frames per second over the last\n"
  " * get_average_frame_rate_interval() seconds.  This measures the virtual frame\n"
  " * rate if the clock is in M_non_real_time mode.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_average_frame_rate_653_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double ClockObject::get_max_frame_duration(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_ClockObject_get_max_frame_duration_654(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-double ClockObject::get_max_frame_duration(Thread *current_thread) const
      double return_value = (*(const ClockObject*)local_this).get_max_frame_duration();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "current_thread");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'current_thread' (pos 1) not found");
      }
      // 1-double ClockObject::get_max_frame_duration(Thread *current_thread) const
      Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "ClockObject.get_max_frame_duration", false, true);
      if (arg_this != NULL) {
        double return_value = (*(const ClockObject*)local_this).get_max_frame_duration(arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_max_frame_duration() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_max_frame_duration(ClockObject self)\n"
      "get_max_frame_duration(ClockObject self, Thread current_thread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_max_frame_duration_654_comment =
  "C++ Interface:\n"
  "get_max_frame_duration(ClockObject self)\n"
  "get_max_frame_duration(ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the maximum frame duration over the last\n"
  " * get_average_frame_rate_interval() seconds.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_max_frame_duration_654_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double ClockObject::calc_frame_rate_deviation(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_ClockObject_calc_frame_rate_deviation_655(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-double ClockObject::calc_frame_rate_deviation(Thread *current_thread) const
      double return_value = (*(const ClockObject*)local_this).calc_frame_rate_deviation();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "current_thread");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'current_thread' (pos 1) not found");
      }
      // 1-double ClockObject::calc_frame_rate_deviation(Thread *current_thread) const
      Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "ClockObject.calc_frame_rate_deviation", false, true);
      if (arg_this != NULL) {
        double return_value = (*(const ClockObject*)local_this).calc_frame_rate_deviation(arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "calc_frame_rate_deviation() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_frame_rate_deviation(ClockObject self)\n"
      "calc_frame_rate_deviation(ClockObject self, Thread current_thread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_calc_frame_rate_deviation_655_comment =
  "C++ Interface:\n"
  "calc_frame_rate_deviation(ClockObject self)\n"
  "calc_frame_rate_deviation(ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the standard deviation of the frame times of the frames rendered\n"
  " * over the past get_average_frame_rate_interval() seconds.  This number gives\n"
  " * an estimate of the chugginess of the frame rate; if it is large, there is a\n"
  " * large variation in the frame rate; if is small, all of the frames are\n"
  " * consistent in length.\n"
  " *\n"
  " * A large value might also represent just a recent change in frame rate, for\n"
  " * instance, because the camera has just rotated from looking at a simple\n"
  " * scene to looking at a more complex scene.\n"
  " */";
#else
static const char *Dtool_ClockObject_calc_frame_rate_deviation_655_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ClockObject::tick(Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_ClockObject_tick_658(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.tick")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-void ClockObject::tick(Thread *current_thread)
      (*local_this).tick();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "current_thread");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'current_thread' (pos 1) not found");
      }
      // 1-void ClockObject::tick(Thread *current_thread)
      Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "ClockObject.tick", false, true);
      if (arg_this != NULL) {
        (*local_this).tick(arg_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "tick() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "tick(const ClockObject self)\n"
      "tick(const ClockObject self, Thread current_thread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_tick_658_comment =
  "C++ Interface:\n"
  "tick(const ClockObject self)\n"
  "tick(const ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Instructs the clock that a new frame has just begun.  In normal, real-time\n"
  " * mode, get_frame_time() will henceforth report the time as of this instant\n"
  " * as the current start-of-frame time.  In non-real-time mode,\n"
  " * get_frame_time() will be incremented by the value of dt.\n"
  " */";
#else
static const char *Dtool_ClockObject_tick_658_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ClockObject::sync_frame_time(Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_ClockObject_sync_frame_time_659(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.sync_frame_time")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-void ClockObject::sync_frame_time(Thread *current_thread)
      (*local_this).sync_frame_time();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "current_thread");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'current_thread' (pos 1) not found");
      }
      // 1-void ClockObject::sync_frame_time(Thread *current_thread)
      Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "ClockObject.sync_frame_time", false, true);
      if (arg_this != NULL) {
        (*local_this).sync_frame_time(arg_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "sync_frame_time() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "sync_frame_time(const ClockObject self)\n"
      "sync_frame_time(const ClockObject self, Thread current_thread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_sync_frame_time_659_comment =
  "C++ Interface:\n"
  "sync_frame_time(const ClockObject self)\n"
  "sync_frame_time(const ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Resets the frame time to the current real time.  This is similar to tick(),\n"
  " * except that it does not advance the frame counter and does not affect dt.\n"
  " * This is intended to be used in the middle of a particularly long frame to\n"
  " * compensate for the time that has already elapsed.\n"
  " *\n"
  " * In non-real-time mode, this function has no effect (because in this mode\n"
  " * all frames take the same length of time).\n"
  " */";
#else
static const char *Dtool_ClockObject_sync_frame_time_659_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ClockObject::check_errors(Thread *current_thread)
 */
static PyObject *Dtool_ClockObject_check_errors_660(PyObject *self, PyObject *arg) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.check_errors")) {
    return NULL;
  }
  // 1-inline bool ClockObject::check_errors(Thread *current_thread)
  Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "ClockObject.check_errors", false, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).check_errors(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "check_errors(const ClockObject self, Thread current_thread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_check_errors_660_comment =
  "C++ Interface:\n"
  "check_errors(const ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns true if a clock error was detected since the last time\n"
  " * check_errors() was called.  A clock error means that something happened, an\n"
  " * OS or BIOS bug, for instance, that makes the current value of the clock\n"
  " * somewhat suspect, and an application may wish to resynchronize with any\n"
  " * external clocks.\n"
  " */";
#else
static const char *Dtool_ClockObject_check_errors_660_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline ClockObject *ClockObject::get_global_clock(void)
 */
static PyObject *Dtool_ClockObject_get_global_clock_661(PyObject *, PyObject *) {
  // 1-static inline ClockObject *ClockObject::get_global_clock(void)
  ClockObject *return_value = ClockObject::get_global_clock();
  if (return_value != (ClockObject *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (ClockObject *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ClockObject, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_global_clock_661_comment =
  "C++ Interface:\n"
  "get_global_clock()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the global ClockObject.  This is the ClockObject that\n"
  " * most code should use for handling scene graph rendering and animation.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_global_clock_661_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ClockObject::get_class_type(void)
 */
static PyObject *Dtool_ClockObject_get_class_type_662(PyObject *, PyObject *) {
  // 1-static TypeHandle ClockObject::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ClockObject::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_class_type_662_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ClockObject_get_class_type_662_comment = NULL;
#endif

static PyObject *Dtool_ClockObject_mode_Getter(PyObject *self, void *) {
  const ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline ClockObject::Mode ClockObject::get_mode(void) const
  ClockObject::Mode return_value = (*(const ClockObject*)local_this).get_mode();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ClockObject_mode_Setter(PyObject *self, PyObject *arg, void *) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.mode")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete mode attribute");
    return -1;
  }
  // 1-void ClockObject::set_mode(ClockObject::Mode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_mode((ClockObject::Mode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_mode(const ClockObject self, int mode)\n");
  }
  return -1;
}

static PyObject *Dtool_ClockObject_frame_time_Getter(PyObject *self, void *) {
  const ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double ClockObject::get_frame_time(Thread *current_thread) const
  double return_value = (*(const ClockObject*)local_this).get_frame_time();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ClockObject_frame_time_Setter(PyObject *self, PyObject *arg, void *) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.frame_time")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete frame_time attribute");
    return -1;
  }
  // 1-void ClockObject::set_frame_time(double time, Thread *current_thread)
  if (PyNumber_Check(arg)) {
    (*local_this).set_frame_time(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_frame_time(const ClockObject self, double time)\n");
  }
  return -1;
}

static PyObject *Dtool_ClockObject_real_time_Getter(PyObject *self, void *) {
  const ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double ClockObject::get_real_time(void) const
  double return_value = (*(const ClockObject*)local_this).get_real_time();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ClockObject_real_time_Setter(PyObject *self, PyObject *arg, void *) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.real_time")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete real_time attribute");
    return -1;
  }
  // 1-void ClockObject::set_real_time(double time)
  if (PyNumber_Check(arg)) {
    (*local_this).set_real_time(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_real_time(const ClockObject self, double time)\n");
  }
  return -1;
}

static PyObject *Dtool_ClockObject_long_time_Getter(PyObject *self, void *) {
  const ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double ClockObject::get_long_time(void) const
  double return_value = (*(const ClockObject*)local_this).get_long_time();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ClockObject_frame_count_Getter(PyObject *self, void *) {
  const ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int ClockObject::get_frame_count(Thread *current_thread) const
  int return_value = (*(const ClockObject*)local_this).get_frame_count();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ClockObject_frame_count_Setter(PyObject *self, PyObject *arg, void *) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.frame_count")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete frame_count attribute");
    return -1;
  }
  // 1-void ClockObject::set_frame_count(int frame_count, Thread *current_thread)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_frame_count((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_frame_count(const ClockObject self, int frame_count)\n");
  }
  return -1;
}

static PyObject *Dtool_ClockObject_dt_Getter(PyObject *self, void *) {
  const ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double ClockObject::get_dt(Thread *current_thread) const
  double return_value = (*(const ClockObject*)local_this).get_dt();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ClockObject_dt_Setter(PyObject *self, PyObject *arg, void *) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.dt")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete dt attribute");
    return -1;
  }
  // 1-void ClockObject::set_dt(double dt)
  if (PyNumber_Check(arg)) {
    (*local_this).set_dt(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_dt(const ClockObject self, double dt)\n");
  }
  return -1;
}

static PyObject *Dtool_ClockObject_max_dt_Getter(PyObject *self, void *) {
  const ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double ClockObject::get_max_dt(void) const
  double return_value = (*(const ClockObject*)local_this).get_max_dt();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ClockObject_max_dt_Setter(PyObject *self, PyObject *arg, void *) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.max_dt")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete max_dt attribute");
    return -1;
  }
  // 1-inline void ClockObject::set_max_dt(double max_dt)
  if (PyNumber_Check(arg)) {
    (*local_this).set_max_dt(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_dt(const ClockObject self, double max_dt)\n");
  }
  return -1;
}

static PyObject *Dtool_ClockObject_degrade_factor_Getter(PyObject *self, void *) {
  const ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double ClockObject::get_degrade_factor(void) const
  double return_value = (*(const ClockObject*)local_this).get_degrade_factor();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ClockObject_degrade_factor_Setter(PyObject *self, PyObject *arg, void *) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.degrade_factor")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete degrade_factor attribute");
    return -1;
  }
  // 1-inline void ClockObject::set_degrade_factor(double degrade_factor)
  if (PyNumber_Check(arg)) {
    (*local_this).set_degrade_factor(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_degrade_factor(const ClockObject self, double degrade_factor)\n");
  }
  return -1;
}

static PyObject *Dtool_ClockObject_average_frame_rate_interval_Getter(PyObject *self, void *) {
  const ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double ClockObject::get_average_frame_rate_interval(void) const
  double return_value = (*(const ClockObject*)local_this).get_average_frame_rate_interval();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ClockObject_average_frame_rate_interval_Setter(PyObject *self, PyObject *arg, void *) {
  ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.average_frame_rate_interval")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete average_frame_rate_interval attribute");
    return -1;
  }
  // 1-inline void ClockObject::set_average_frame_rate_interval(double time)
  if (PyNumber_Check(arg)) {
    (*local_this).set_average_frame_rate_interval(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_average_frame_rate_interval(const ClockObject self, double time)\n");
  }
  return -1;
}

static PyObject *Dtool_ClockObject_average_frame_rate_Getter(PyObject *self, void *) {
  const ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }

  // 1-double ClockObject::get_average_frame_rate(Thread *current_thread) const
  double return_value = (*(const ClockObject*)local_this).get_average_frame_rate();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ClockObject_max_frame_duration_Getter(PyObject *self, void *) {
  const ClockObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return NULL;
  }

  // 1-double ClockObject::get_max_frame_duration(Thread *current_thread) const
  double return_value = (*(const ClockObject*)local_this).get_max_frame_duration();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * ClockObject::ClockObject(void)
 * ClockObject::ClockObject(ClockObject const &copy)
 */
static int Dtool_Init_ClockObject(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-ClockObject::ClockObject(void)
      ClockObject *return_value = new ClockObject();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ClockObject, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-ClockObject::ClockObject(ClockObject const &copy)
      ClockObject const *arg_this = (ClockObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ClockObject, 0, "ClockObject.ClockObject", true, true);
      if (arg_this != NULL) {
        ClockObject *return_value = new ClockObject(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ClockObject, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ClockObject() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ClockObject()\n"
      "ClockObject(const ClockObject copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ClockObject(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ClockObject) {
    printf("ClockObject ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ClockObject *local_this = (ClockObject *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ClockObject) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ClockObject(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ClockObject) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ClockObject*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CopyOnWriteObject
 */
/**
 * Python function wrapper for:
 * inline void CopyOnWriteObject::cache_ref(void) const
 */
static PyObject *Dtool_CopyOnWriteObject_cache_ref_670(PyObject *self, PyObject *) {
  CopyOnWriteObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CopyOnWriteObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void CopyOnWriteObject::cache_ref(void) const
  (*(const CopyOnWriteObject*)local_this).cache_ref();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CopyOnWriteObject_cache_ref_670_comment =
  "C++ Interface:\n"
  "cache_ref(CopyOnWriteObject self)\n"
  "\n"
  "/**\n"
  " * See CachedTypedWritableReferenceCount::cache_ref().\n"
  " */";
#else
static const char *Dtool_CopyOnWriteObject_cache_ref_670_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CopyOnWriteObject::get_class_type(void)
 */
static PyObject *Dtool_CopyOnWriteObject_get_class_type_671(PyObject *, PyObject *) {
  // 1-static TypeHandle CopyOnWriteObject::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CopyOnWriteObject::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CopyOnWriteObject_get_class_type_671_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CopyOnWriteObject_get_class_type_671_comment = NULL;
#endif

static int Dtool_Init_CopyOnWriteObject(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_CopyOnWriteObject(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CopyOnWriteObject) {
    printf("CopyOnWriteObject ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CopyOnWriteObject *local_this = (CopyOnWriteObject *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CopyOnWriteObject(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CopyOnWriteObject*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CopyOnWriteObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CopyOnWriteObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CopyOnWriteObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CopyOnWriteObject*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DatagramInputFile
 */
/**
 * Python function wrapper for:
 * bool DatagramInputFile::open(FileReference const *file)
 * inline bool DatagramInputFile::open(Filename const &filename)
 * bool DatagramInputFile::open(istream &in, Filename const &filename = Filename())
 */
static PyObject *Dtool_DatagramInputFile_open_675(PyObject *self, PyObject *args, PyObject *kwds) {
  DatagramInputFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramInputFile, (void **)&local_this, "DatagramInputFile.open")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 bool DatagramInputFile::open(istream &in, Filename const &filename)
        PyObject *param1;
        static const char *keyword_list[] = {"in", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:open", (char **)keyword_list, &param1)) {
          istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_istream, 1, "DatagramInputFile.open", false, false);
          if (param1_this != NULL) {
            bool return_value = (*local_this).open(*param1_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool DatagramInputFile::open(FileReference const *file)
        PyObject *param1;
        static const char *keyword_list[] = {"file", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:open", (char **)keyword_list, &param1)) {
          FileReference const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_FileReference, (void **)&param1_this);
          if (param1_this != NULL) {
            bool return_value = (*local_this).open(param1_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool DatagramInputFile::open(Filename const &filename)
        PyObject *param1;
        static const char *keyword_list[] = {"filename", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:open", (char **)keyword_list, &param1)) {
          Filename const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
          if (param1_this != NULL) {
            bool return_value = (*local_this).open(*param1_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool DatagramInputFile::open(istream &in, Filename const &filename)
        PyObject *param1;
        static const char *keyword_list[] = {"in", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:open", (char **)keyword_list, &param1)) {
          istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_istream, 1, "DatagramInputFile.open", false, false);
          if (param1_this != NULL) {
            bool return_value = (*local_this).open(*param1_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool DatagramInputFile::open(FileReference const *file)
        PyObject *param1;
        static const char *keyword_list[] = {"file", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:open", (char **)keyword_list, &param1)) {
          CPT(FileReference) param1_this;
          if (Dtool_ConstCoerce_FileReference(param1, param1_this)) {
            bool return_value = (*local_this).open(MOVE(param1_this));
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool DatagramInputFile::open(Filename const &filename)
        PyObject *param1;
        static const char *keyword_list[] = {"filename", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:open", (char **)keyword_list, &param1)) {
          Filename param1_local;
          Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
          if ((param1_this != NULL)) {
            bool return_value = (*local_this).open(*param1_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-bool DatagramInputFile::open(istream &in, Filename const &filename)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"in", "filename", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:open", (char **)keyword_list, &param1, &param2)) {
        istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_istream, 1, "DatagramInputFile.open", false, true);
        Filename param2_local;
        Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "DatagramInputFile.open", "Filename");
        }
        if (param1_this != NULL) {
          bool return_value = (*local_this).open(*param1_this, *param2_this);
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "open() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const DatagramInputFile self, istream in)\n"
      "open(const DatagramInputFile self, const FileReference file)\n"
      "open(const DatagramInputFile self, const Filename filename)\n"
      "open(const DatagramInputFile self, istream in, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DatagramInputFile_open_675_comment =
  "C++ Interface:\n"
  "open(const DatagramInputFile self, istream in)\n"
  "open(const DatagramInputFile self, const FileReference file)\n"
  "open(const DatagramInputFile self, const Filename filename)\n"
  "open(const DatagramInputFile self, istream in, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Opens the indicated filename for reading.  Returns true on success, false\n"
  " * on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Opens the indicated filename for reading.  Returns true on success, false\n"
  " * on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Starts reading from the indicated stream.  Returns true on success, false\n"
  " * on failure.  The DatagramInputFile does not take ownership of the stream;\n"
  " * you are responsible for closing or deleting it when you are done.\n"
  " */";
#else
static const char *Dtool_DatagramInputFile_open_675_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline istream &DatagramInputFile::get_stream(void)
 */
static PyObject *Dtool_DatagramInputFile_get_stream_676(PyObject *self, PyObject *) {
  DatagramInputFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramInputFile, (void **)&local_this, "DatagramInputFile.get_stream")) {
    return NULL;
  }
  // 1-inline istream &DatagramInputFile::get_stream(void)
  istream *return_value = &((*local_this).get_stream());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_istream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DatagramInputFile_get_stream_676_comment =
  "C++ Interface:\n"
  "get_stream(const DatagramInputFile self)\n"
  "\n"
  "/**\n"
  " * Returns the istream represented by the input file.\n"
  " */";
#else
static const char *Dtool_DatagramInputFile_get_stream_676_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DatagramInputFile::close(void)
 */
static PyObject *Dtool_DatagramInputFile_close_677(PyObject *self, PyObject *) {
  DatagramInputFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramInputFile, (void **)&local_this, "DatagramInputFile.close")) {
    return NULL;
  }
  // 1-void DatagramInputFile::close(void)
  (*local_this).close();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DatagramInputFile_close_677_comment =
  "C++ Interface:\n"
  "close(const DatagramInputFile self)\n"
  "\n"
  "/**\n"
  " * Closes the file.  This is also implicitly done when the DatagramInputFile\n"
  " * destructs.\n"
  " */";
#else
static const char *Dtool_DatagramInputFile_close_677_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DatagramInputFile::DatagramInputFile(void)
 */
static int Dtool_Init_DatagramInputFile(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "DatagramInputFile() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline DatagramInputFile::DatagramInputFile(void)
  DatagramInputFile *return_value = new DatagramInputFile();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DatagramInputFile, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DatagramInputFile()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DatagramInputFile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DatagramInputFile) {
    printf("DatagramInputFile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DatagramInputFile *local_this = (DatagramInputFile *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DatagramInputFile) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DatagramGenerator) {
    return (DatagramGenerator *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DatagramInputFile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DatagramInputFile) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DatagramGenerator) {
    DatagramGenerator* other_this = (DatagramGenerator*)from_this;
    return (DatagramInputFile*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DoubleBitMask< BitMaskNative >
 */
/**
 * Python function wrapper for:
 * inline DoubleBitMask< BitMaskNative > &DoubleBitMask< BitMaskNative >::operator =(DoubleBitMask< BitMaskNative > const &copy)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_681(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.assign")) {
    return NULL;
  }
  // 1-inline DoubleBitMask< BitMaskNative > &DoubleBitMask< BitMaskNative >::operator =(DoubleBitMask< BitMaskNative > const &copy)
  DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 1, "DoubleBitMask.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    DoubleBitMask< BitMaskNative > *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const DoubleBitMask self, const DoubleBitMask copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_operator_681_comment =
  "C++ Interface:\n"
  "assign(const DoubleBitMask self, const DoubleBitMask copy)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_operator_681_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::all_on(void)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_all_on_682(PyObject *, PyObject *) {
  // 1-static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::all_on(void)
  DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >(DoubleBitMask< BitMaskNative >::all_on());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_all_on_682_comment =
  "C++ Interface:\n"
  "all_on()\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_all_on_682_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::all_off(void)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_all_off_683(PyObject *, PyObject *) {
  // 1-static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::all_off(void)
  DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >(DoubleBitMask< BitMaskNative >::all_off());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_all_off_683_comment =
  "C++ Interface:\n"
  "all_off()\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_all_off_683_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::lower_on(int on_bits)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_lower_on_684(PyObject *, PyObject *arg) {
  // 1-static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::lower_on(int on_bits)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >(DoubleBitMask< BitMaskNative >::lower_on((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lower_on(int on_bits)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_lower_on_684_comment =
  "C++ Interface:\n"
  "lower_on(int on_bits)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_lower_on_684_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::bit(int index)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_bit_685(PyObject *, PyObject *arg) {
  // 1-static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >(DoubleBitMask< BitMaskNative >::bit((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bit(int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_bit_685_comment =
  "C++ Interface:\n"
  "bit(int index)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_bit_685_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::range(int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_range_686(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::range(int low_bit, int size)
  int param0;
  int param1;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:range", (char **)keyword_list, &param0, &param1)) {
    DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >(DoubleBitMask< BitMaskNative >::range((int)param0, (int)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "range(int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_range_686_comment =
  "C++ Interface:\n"
  "range(int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_range_686_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr bool DoubleBitMask< BitMaskNative >::has_max_num_bits(void)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_has_max_num_bits_688(PyObject *, PyObject *) {
  // 1-static constexpr bool DoubleBitMask< BitMaskNative >::has_max_num_bits(void)
  bool return_value = DoubleBitMask< BitMaskNative >::has_max_num_bits();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_has_max_num_bits_688_comment =
  "C++ Interface:\n"
  "has_max_num_bits()\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_has_max_num_bits_688_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int DoubleBitMask< BitMaskNative >::get_max_num_bits(void)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_max_num_bits_689(PyObject *, PyObject *) {
  // 1-static constexpr int DoubleBitMask< BitMaskNative >::get_max_num_bits(void)
  int return_value = DoubleBitMask< BitMaskNative >::get_max_num_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_max_num_bits_689_comment =
  "C++ Interface:\n"
  "get_max_num_bits()\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_max_num_bits_689_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int DoubleBitMask< BitMaskNative >::get_num_bits(void)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_num_bits_690(PyObject *, PyObject *) {
  // 1-static constexpr int DoubleBitMask< BitMaskNative >::get_num_bits(void)
  int return_value = DoubleBitMask< BitMaskNative >::get_num_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_num_bits_690_comment =
  "C++ Interface:\n"
  "get_num_bits()\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_num_bits_690_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< BitMaskNative >::get_bit(int index) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_bit_691(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DoubleBitMask< BitMaskNative >::get_bit(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const DoubleBitMask< BitMaskNative >*)local_this).get_bit((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bit(DoubleBitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_bit_691_comment =
  "C++ Interface:\n"
  "get_bit(DoubleBitMask self, int index)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_bit_691_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< BitMaskNative >::set_bit(int index)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_set_bit_692(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.set_bit")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::set_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_bit((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit(const DoubleBitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_set_bit_692_comment =
  "C++ Interface:\n"
  "set_bit(const DoubleBitMask self, int index)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_set_bit_692_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< BitMaskNative >::clear_bit(int index)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_clear_bit_693(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.clear_bit")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::clear_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).clear_bit((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_bit(const DoubleBitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_clear_bit_693_comment =
  "C++ Interface:\n"
  "clear_bit(const DoubleBitMask self, int index)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_clear_bit_693_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< BitMaskNative >::set_bit_to(int index, bool value)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_set_bit_to_694(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.set_bit_to")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::set_bit_to(int index, bool value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_bit_to", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_bit_to((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit_to(const DoubleBitMask self, int index, bool value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_set_bit_to_694_comment =
  "C++ Interface:\n"
  "set_bit_to(const DoubleBitMask self, int index, bool value)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_set_bit_to_694_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< BitMaskNative >::is_zero(void) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_is_zero_695(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DoubleBitMask< BitMaskNative >::is_zero(void) const
  bool return_value = (*(const DoubleBitMask< BitMaskNative >*)local_this).is_zero();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_is_zero_695_comment =
  "C++ Interface:\n"
  "is_zero(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_is_zero_695_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< BitMaskNative >::is_all_on(void) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_is_all_on_696(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DoubleBitMask< BitMaskNative >::is_all_on(void) const
  bool return_value = (*(const DoubleBitMask< BitMaskNative >*)local_this).is_all_on();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_is_all_on_696_comment =
  "C++ Interface:\n"
  "is_all_on(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_is_all_on_696_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint32_t DoubleBitMask< BitMaskNative >::extract(int low_bit, int size) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_extract_697(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline uint32_t DoubleBitMask< BitMaskNative >::extract(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:extract", (char **)keyword_list, &param1, &param2)) {
    uint32_t return_value = (*(const DoubleBitMask< BitMaskNative >*)local_this).extract((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract(DoubleBitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_extract_697_comment =
  "C++ Interface:\n"
  "extract(DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_extract_697_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< BitMaskNative >::store(uint32_t value, int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_store_698(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.store")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::store(uint32_t value, int low_bit, int size)
  unsigned long param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kii:store", (char **)keyword_list, &param1, &param2, &param3)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    (*local_this).store((uint32_t)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store(const DoubleBitMask self, int value, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_store_698_comment =
  "C++ Interface:\n"
  "store(const DoubleBitMask self, int value, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_store_698_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< BitMaskNative >::has_any_of(int low_bit, int size) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_has_any_of_699(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DoubleBitMask< BitMaskNative >::has_any_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_any_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*(const DoubleBitMask< BitMaskNative >*)local_this).has_any_of((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_any_of(DoubleBitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_has_any_of_699_comment =
  "C++ Interface:\n"
  "has_any_of(DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_has_any_of_699_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< BitMaskNative >::has_all_of(int low_bit, int size) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_has_all_of_700(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DoubleBitMask< BitMaskNative >::has_all_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_all_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*(const DoubleBitMask< BitMaskNative >*)local_this).has_all_of((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_all_of(DoubleBitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_has_all_of_700_comment =
  "C++ Interface:\n"
  "has_all_of(DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_has_all_of_700_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< BitMaskNative >::set_range(int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_set_range_701(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.set_range")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::set_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_range", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_range((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range(const DoubleBitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_set_range_701_comment =
  "C++ Interface:\n"
  "set_range(const DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_set_range_701_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< BitMaskNative >::clear_range(int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_clear_range_702(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.clear_range")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::clear_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:clear_range", (char **)keyword_list, &param1, &param2)) {
    (*local_this).clear_range((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_range(const DoubleBitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_clear_range_702_comment =
  "C++ Interface:\n"
  "clear_range(const DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_clear_range_702_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< BitMaskNative >::set_range_to(bool value, int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_set_range_to_703(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.set_range_to")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::set_range_to(bool value, int low_bit, int size)
  PyObject *param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_range_to", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_range_to((PyObject_IsTrue(param1) != 0), (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range_to(const DoubleBitMask self, bool value, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_set_range_to_703_comment =
  "C++ Interface:\n"
  "set_range_to(const DoubleBitMask self, bool value, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_set_range_to_703_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< BitMaskNative >::get_num_on_bits(void) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_num_on_bits_704(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DoubleBitMask< BitMaskNative >::get_num_on_bits(void) const
  int return_value = (*(const DoubleBitMask< BitMaskNative >*)local_this).get_num_on_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_num_on_bits_704_comment =
  "C++ Interface:\n"
  "get_num_on_bits(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_num_on_bits_704_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< BitMaskNative >::get_num_off_bits(void) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_num_off_bits_705(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DoubleBitMask< BitMaskNative >::get_num_off_bits(void) const
  int return_value = (*(const DoubleBitMask< BitMaskNative >*)local_this).get_num_off_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_num_off_bits_705_comment =
  "C++ Interface:\n"
  "get_num_off_bits(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_num_off_bits_705_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< BitMaskNative >::get_lowest_on_bit(void) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_lowest_on_bit_706(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DoubleBitMask< BitMaskNative >::get_lowest_on_bit(void) const
  int return_value = (*(const DoubleBitMask< BitMaskNative >*)local_this).get_lowest_on_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_lowest_on_bit_706_comment =
  "C++ Interface:\n"
  "get_lowest_on_bit(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_lowest_on_bit_706_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< BitMaskNative >::get_lowest_off_bit(void) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_lowest_off_bit_707(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DoubleBitMask< BitMaskNative >::get_lowest_off_bit(void) const
  int return_value = (*(const DoubleBitMask< BitMaskNative >*)local_this).get_lowest_off_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_lowest_off_bit_707_comment =
  "C++ Interface:\n"
  "get_lowest_off_bit(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_lowest_off_bit_707_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< BitMaskNative >::get_highest_on_bit(void) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_highest_on_bit_708(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DoubleBitMask< BitMaskNative >::get_highest_on_bit(void) const
  int return_value = (*(const DoubleBitMask< BitMaskNative >*)local_this).get_highest_on_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_highest_on_bit_708_comment =
  "C++ Interface:\n"
  "get_highest_on_bit(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_highest_on_bit_708_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< BitMaskNative >::get_highest_off_bit(void) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_highest_off_bit_709(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DoubleBitMask< BitMaskNative >::get_highest_off_bit(void) const
  int return_value = (*(const DoubleBitMask< BitMaskNative >*)local_this).get_highest_off_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_highest_off_bit_709_comment =
  "C++ Interface:\n"
  "get_highest_off_bit(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_highest_off_bit_709_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< BitMaskNative >::get_next_higher_different_bit(int low_bit) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_next_higher_different_bit_710(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DoubleBitMask< BitMaskNative >::get_next_higher_different_bit(int low_bit) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const DoubleBitMask< BitMaskNative >*)local_this).get_next_higher_different_bit((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_next_higher_different_bit(DoubleBitMask self, int low_bit)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_next_higher_different_bit_710_comment =
  "C++ Interface:\n"
  "get_next_higher_different_bit(DoubleBitMask self, int low_bit)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_next_higher_different_bit_710_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< BitMaskNative >::invert_in_place(void)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_invert_in_place_711(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.invert_in_place")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::invert_in_place(void)
  (*local_this).invert_in_place();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_invert_in_place_711_comment =
  "C++ Interface:\n"
  "invert_in_place(const DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_invert_in_place_711_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< BitMaskNative >::has_bits_in_common(DoubleBitMask< BitMaskNative > const &other) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_has_bits_in_common_712(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DoubleBitMask< BitMaskNative >::has_bits_in_common(DoubleBitMask< BitMaskNative > const &other) const
  DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 1, "DoubleBitMask.has_bits_in_common", true, true);
  if (arg_this != NULL) {
    bool return_value = (*(const DoubleBitMask< BitMaskNative >*)local_this).has_bits_in_common(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_bits_in_common(DoubleBitMask self, const DoubleBitMask other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_has_bits_in_common_712_comment =
  "C++ Interface:\n"
  "has_bits_in_common(DoubleBitMask self, const DoubleBitMask other)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_has_bits_in_common_712_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< BitMaskNative >::clear(void)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_clear_713(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.clear")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_clear_713_comment =
  "C++ Interface:\n"
  "clear(const DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_clear_713_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DoubleBitMask< BitMaskNative >::output(ostream &out) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_output_714(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DoubleBitMask< BitMaskNative >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "DoubleBitMask.output", false, true);
  if (arg_this != NULL) {
    (*(const DoubleBitMask< BitMaskNative >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(DoubleBitMask self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_output_714_comment =
  "C++ Interface:\n"
  "output(DoubleBitMask self, ostream out)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_output_714_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DoubleBitMask< BitMaskNative >::output_binary(ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_output_binary_715(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DoubleBitMask< BitMaskNative >::output_binary(ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_binary", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "DoubleBitMask.output_binary", false, true);
    if (param1_this != NULL) {
      (*(const DoubleBitMask< BitMaskNative >*)local_this).output_binary(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_binary(DoubleBitMask self, ostream out, int spaces_every)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_output_binary_715_comment =
  "C++ Interface:\n"
  "output_binary(DoubleBitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_output_binary_715_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DoubleBitMask< BitMaskNative >::output_hex(ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_output_hex_716(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DoubleBitMask< BitMaskNative >::output_hex(ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_hex", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "DoubleBitMask.output_hex", false, true);
    if (param1_this != NULL) {
      (*(const DoubleBitMask< BitMaskNative >*)local_this).output_hex(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_hex(DoubleBitMask self, ostream out, int spaces_every)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_output_hex_716_comment =
  "C++ Interface:\n"
  "output_hex(DoubleBitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_output_hex_716_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DoubleBitMask< BitMaskNative >::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_write_717(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DoubleBitMask< BitMaskNative >::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "DoubleBitMask.write", false, true);
    if (param1_this != NULL) {
      (*(const DoubleBitMask< BitMaskNative >*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(DoubleBitMask self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_write_717_comment =
  "C++ Interface:\n"
  "write(DoubleBitMask self, ostream out, int indent_level)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_write_717_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< BitMaskNative >::compare_to(DoubleBitMask< BitMaskNative > const &other) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_compare_to_721(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DoubleBitMask< BitMaskNative >::compare_to(DoubleBitMask< BitMaskNative > const &other) const
  DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 1, "DoubleBitMask.compare_to", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const DoubleBitMask< BitMaskNative >*)local_this).compare_to(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(DoubleBitMask self, const DoubleBitMask other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_compare_to_721_comment =
  "C++ Interface:\n"
  "compare_to(DoubleBitMask self, const DoubleBitMask other)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_compare_to_721_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< BitMaskNative >::operator |=(DoubleBitMask< BitMaskNative > const &other)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_729(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.__ior__")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::operator |=(DoubleBitMask< BitMaskNative > const &other)
  DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 1, "DoubleBitMask.__ior__", true, true);
  if (arg_this != NULL) {
    (*local_this).operator |=(*arg_this);
    DoubleBitMask< BitMaskNative > *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__ior__(const DoubleBitMask self, const DoubleBitMask other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_operator_729_comment =
  "C++ Interface:\n"
  "__ior__(const DoubleBitMask self, const DoubleBitMask other)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_operator_729_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DoubleBitMask< BitMaskNative >::get_class_type(void)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_class_type_733(PyObject *, PyObject *) {
  // 1-static TypeHandle DoubleBitMask< BitMaskNative >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(DoubleBitMask< BitMaskNative >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_class_type_733_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_class_type_733_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DoubleBitMask< BitMaskNative >::DoubleBitMask(void)
 * inline DoubleBitMask< BitMaskNative >::DoubleBitMask(DoubleBitMask< BitMaskNative > const &copy)
 */
static int Dtool_Init_DoubleBitMask_BitMaskNative(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline DoubleBitMask< BitMaskNative >::DoubleBitMask(void)
      DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DoubleBitMask_BitMaskNative, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-inline DoubleBitMask< BitMaskNative >::DoubleBitMask(DoubleBitMask< BitMaskNative > const &copy)
      DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 0, "DoubleBitMask.DoubleBitMask", true, true);
      if (arg_this != NULL) {
        DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DoubleBitMask_BitMaskNative, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DoubleBitMask() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DoubleBitMask()\n"
      "DoubleBitMask(const DoubleBitMask copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DoubleBitMask_BitMaskNative(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DoubleBitMask_BitMaskNative) {
    printf("DoubleBitMask_BitMaskNative ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DoubleBitMask< BitMaskNative > *local_this = (DoubleBitMask< BitMaskNative > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DoubleBitMask_BitMaskNative) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DoubleBitMask_BitMaskNative(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DoubleBitMask_BitMaskNative) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DoubleBitMask< DoubleBitMaskNative >
 */
/**
 * Python function wrapper for:
 * inline DoubleBitMask< DoubleBitMaskNative > &DoubleBitMask< DoubleBitMaskNative >::operator =(DoubleBitMask< DoubleBitMaskNative > const &copy)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_737(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.assign")) {
    return NULL;
  }
  // 1-inline DoubleBitMask< DoubleBitMaskNative > &DoubleBitMask< DoubleBitMaskNative >::operator =(DoubleBitMask< DoubleBitMaskNative > const &copy)
  DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 1, "DoubleBitMask.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    DoubleBitMask< DoubleBitMaskNative > *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const DoubleBitMask self, const DoubleBitMask copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_737_comment =
  "C++ Interface:\n"
  "assign(const DoubleBitMask self, const DoubleBitMask copy)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_737_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::all_on(void)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_all_on_738(PyObject *, PyObject *) {
  // 1-static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::all_on(void)
  DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >(DoubleBitMask< DoubleBitMaskNative >::all_on());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_all_on_738_comment =
  "C++ Interface:\n"
  "all_on()\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_all_on_738_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::all_off(void)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_all_off_739(PyObject *, PyObject *) {
  // 1-static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::all_off(void)
  DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >(DoubleBitMask< DoubleBitMaskNative >::all_off());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_all_off_739_comment =
  "C++ Interface:\n"
  "all_off()\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_all_off_739_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::lower_on(int on_bits)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_lower_on_740(PyObject *, PyObject *arg) {
  // 1-static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::lower_on(int on_bits)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >(DoubleBitMask< DoubleBitMaskNative >::lower_on((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lower_on(int on_bits)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_lower_on_740_comment =
  "C++ Interface:\n"
  "lower_on(int on_bits)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_lower_on_740_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::bit(int index)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_bit_741(PyObject *, PyObject *arg) {
  // 1-static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >(DoubleBitMask< DoubleBitMaskNative >::bit((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bit(int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_bit_741_comment =
  "C++ Interface:\n"
  "bit(int index)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_bit_741_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::range(int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_range_742(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::range(int low_bit, int size)
  int param0;
  int param1;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:range", (char **)keyword_list, &param0, &param1)) {
    DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >(DoubleBitMask< DoubleBitMaskNative >::range((int)param0, (int)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "range(int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_range_742_comment =
  "C++ Interface:\n"
  "range(int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_range_742_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr bool DoubleBitMask< DoubleBitMaskNative >::has_max_num_bits(void)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_has_max_num_bits_744(PyObject *, PyObject *) {
  // 1-static constexpr bool DoubleBitMask< DoubleBitMaskNative >::has_max_num_bits(void)
  bool return_value = DoubleBitMask< DoubleBitMaskNative >::has_max_num_bits();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_has_max_num_bits_744_comment =
  "C++ Interface:\n"
  "has_max_num_bits()\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_has_max_num_bits_744_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int DoubleBitMask< DoubleBitMaskNative >::get_max_num_bits(void)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_max_num_bits_745(PyObject *, PyObject *) {
  // 1-static constexpr int DoubleBitMask< DoubleBitMaskNative >::get_max_num_bits(void)
  int return_value = DoubleBitMask< DoubleBitMaskNative >::get_max_num_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_max_num_bits_745_comment =
  "C++ Interface:\n"
  "get_max_num_bits()\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_max_num_bits_745_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int DoubleBitMask< DoubleBitMaskNative >::get_num_bits(void)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_bits_746(PyObject *, PyObject *) {
  // 1-static constexpr int DoubleBitMask< DoubleBitMaskNative >::get_num_bits(void)
  int return_value = DoubleBitMask< DoubleBitMaskNative >::get_num_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_bits_746_comment =
  "C++ Interface:\n"
  "get_num_bits()\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_bits_746_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< DoubleBitMaskNative >::get_bit(int index) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_bit_747(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DoubleBitMask< DoubleBitMaskNative >::get_bit(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).get_bit((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bit(DoubleBitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_bit_747_comment =
  "C++ Interface:\n"
  "get_bit(DoubleBitMask self, int index)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_bit_747_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< DoubleBitMaskNative >::set_bit(int index)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_748(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.set_bit")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::set_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_bit((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit(const DoubleBitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_748_comment =
  "C++ Interface:\n"
  "set_bit(const DoubleBitMask self, int index)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_748_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< DoubleBitMaskNative >::clear_bit(int index)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_clear_bit_749(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.clear_bit")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::clear_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).clear_bit((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_bit(const DoubleBitMask self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_clear_bit_749_comment =
  "C++ Interface:\n"
  "clear_bit(const DoubleBitMask self, int index)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_clear_bit_749_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< DoubleBitMaskNative >::set_bit_to(int index, bool value)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_to_750(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.set_bit_to")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::set_bit_to(int index, bool value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_bit_to", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_bit_to((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit_to(const DoubleBitMask self, int index, bool value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_to_750_comment =
  "C++ Interface:\n"
  "set_bit_to(const DoubleBitMask self, int index, bool value)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_to_750_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< DoubleBitMaskNative >::is_zero(void) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_is_zero_751(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DoubleBitMask< DoubleBitMaskNative >::is_zero(void) const
  bool return_value = (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).is_zero();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_is_zero_751_comment =
  "C++ Interface:\n"
  "is_zero(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_is_zero_751_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< DoubleBitMaskNative >::is_all_on(void) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_is_all_on_752(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DoubleBitMask< DoubleBitMaskNative >::is_all_on(void) const
  bool return_value = (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).is_all_on();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_is_all_on_752_comment =
  "C++ Interface:\n"
  "is_all_on(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_is_all_on_752_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint32_t DoubleBitMask< DoubleBitMaskNative >::extract(int low_bit, int size) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_extract_753(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline uint32_t DoubleBitMask< DoubleBitMaskNative >::extract(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:extract", (char **)keyword_list, &param1, &param2)) {
    uint32_t return_value = (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).extract((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract(DoubleBitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_extract_753_comment =
  "C++ Interface:\n"
  "extract(DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_extract_753_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< DoubleBitMaskNative >::store(uint32_t value, int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_store_754(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.store")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::store(uint32_t value, int low_bit, int size)
  unsigned long param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kii:store", (char **)keyword_list, &param1, &param2, &param3)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    (*local_this).store((uint32_t)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store(const DoubleBitMask self, int value, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_store_754_comment =
  "C++ Interface:\n"
  "store(const DoubleBitMask self, int value, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_store_754_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< DoubleBitMaskNative >::has_any_of(int low_bit, int size) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_has_any_of_755(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DoubleBitMask< DoubleBitMaskNative >::has_any_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_any_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).has_any_of((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_any_of(DoubleBitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_has_any_of_755_comment =
  "C++ Interface:\n"
  "has_any_of(DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_has_any_of_755_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< DoubleBitMaskNative >::has_all_of(int low_bit, int size) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_has_all_of_756(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DoubleBitMask< DoubleBitMaskNative >::has_all_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_all_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).has_all_of((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_all_of(DoubleBitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_has_all_of_756_comment =
  "C++ Interface:\n"
  "has_all_of(DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_has_all_of_756_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< DoubleBitMaskNative >::set_range(int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_757(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.set_range")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::set_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_range", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_range((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range(const DoubleBitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_757_comment =
  "C++ Interface:\n"
  "set_range(const DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_757_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< DoubleBitMaskNative >::clear_range(int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_clear_range_758(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.clear_range")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::clear_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:clear_range", (char **)keyword_list, &param1, &param2)) {
    (*local_this).clear_range((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_range(const DoubleBitMask self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_clear_range_758_comment =
  "C++ Interface:\n"
  "clear_range(const DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_clear_range_758_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< DoubleBitMaskNative >::set_range_to(bool value, int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_to_759(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.set_range_to")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::set_range_to(bool value, int low_bit, int size)
  PyObject *param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_range_to", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_range_to((PyObject_IsTrue(param1) != 0), (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range_to(const DoubleBitMask self, bool value, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_to_759_comment =
  "C++ Interface:\n"
  "set_range_to(const DoubleBitMask self, bool value, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_to_759_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< DoubleBitMaskNative >::get_num_on_bits(void) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_on_bits_760(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DoubleBitMask< DoubleBitMaskNative >::get_num_on_bits(void) const
  int return_value = (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).get_num_on_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_on_bits_760_comment =
  "C++ Interface:\n"
  "get_num_on_bits(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_on_bits_760_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< DoubleBitMaskNative >::get_num_off_bits(void) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_off_bits_761(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DoubleBitMask< DoubleBitMaskNative >::get_num_off_bits(void) const
  int return_value = (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).get_num_off_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_off_bits_761_comment =
  "C++ Interface:\n"
  "get_num_off_bits(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_off_bits_761_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< DoubleBitMaskNative >::get_lowest_on_bit(void) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_on_bit_762(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DoubleBitMask< DoubleBitMaskNative >::get_lowest_on_bit(void) const
  int return_value = (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).get_lowest_on_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_on_bit_762_comment =
  "C++ Interface:\n"
  "get_lowest_on_bit(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_on_bit_762_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< DoubleBitMaskNative >::get_lowest_off_bit(void) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_off_bit_763(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DoubleBitMask< DoubleBitMaskNative >::get_lowest_off_bit(void) const
  int return_value = (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).get_lowest_off_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_off_bit_763_comment =
  "C++ Interface:\n"
  "get_lowest_off_bit(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_off_bit_763_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< DoubleBitMaskNative >::get_highest_on_bit(void) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_on_bit_764(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DoubleBitMask< DoubleBitMaskNative >::get_highest_on_bit(void) const
  int return_value = (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).get_highest_on_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_on_bit_764_comment =
  "C++ Interface:\n"
  "get_highest_on_bit(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_on_bit_764_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< DoubleBitMaskNative >::get_highest_off_bit(void) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_off_bit_765(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DoubleBitMask< DoubleBitMaskNative >::get_highest_off_bit(void) const
  int return_value = (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).get_highest_off_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_off_bit_765_comment =
  "C++ Interface:\n"
  "get_highest_off_bit(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_off_bit_765_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< DoubleBitMaskNative >::get_next_higher_different_bit(int low_bit) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_next_higher_different_bit_766(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DoubleBitMask< DoubleBitMaskNative >::get_next_higher_different_bit(int low_bit) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).get_next_higher_different_bit((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_next_higher_different_bit(DoubleBitMask self, int low_bit)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_next_higher_different_bit_766_comment =
  "C++ Interface:\n"
  "get_next_higher_different_bit(DoubleBitMask self, int low_bit)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_next_higher_different_bit_766_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< DoubleBitMaskNative >::invert_in_place(void)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_invert_in_place_767(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.invert_in_place")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::invert_in_place(void)
  (*local_this).invert_in_place();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_invert_in_place_767_comment =
  "C++ Interface:\n"
  "invert_in_place(const DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_invert_in_place_767_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< DoubleBitMaskNative >::has_bits_in_common(DoubleBitMask< DoubleBitMaskNative > const &other) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_has_bits_in_common_768(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DoubleBitMask< DoubleBitMaskNative >::has_bits_in_common(DoubleBitMask< DoubleBitMaskNative > const &other) const
  DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 1, "DoubleBitMask.has_bits_in_common", true, true);
  if (arg_this != NULL) {
    bool return_value = (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).has_bits_in_common(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_bits_in_common(DoubleBitMask self, const DoubleBitMask other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_has_bits_in_common_768_comment =
  "C++ Interface:\n"
  "has_bits_in_common(DoubleBitMask self, const DoubleBitMask other)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_has_bits_in_common_768_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< DoubleBitMaskNative >::clear(void)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_clear_769(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.clear")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_clear_769_comment =
  "C++ Interface:\n"
  "clear(const DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_clear_769_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DoubleBitMask< DoubleBitMaskNative >::output(ostream &out) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_output_770(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DoubleBitMask< DoubleBitMaskNative >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "DoubleBitMask.output", false, true);
  if (arg_this != NULL) {
    (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(DoubleBitMask self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_output_770_comment =
  "C++ Interface:\n"
  "output(DoubleBitMask self, ostream out)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_output_770_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DoubleBitMask< DoubleBitMaskNative >::output_binary(ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_output_binary_771(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DoubleBitMask< DoubleBitMaskNative >::output_binary(ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_binary", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "DoubleBitMask.output_binary", false, true);
    if (param1_this != NULL) {
      (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).output_binary(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_binary(DoubleBitMask self, ostream out, int spaces_every)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_output_binary_771_comment =
  "C++ Interface:\n"
  "output_binary(DoubleBitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_output_binary_771_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DoubleBitMask< DoubleBitMaskNative >::output_hex(ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_output_hex_772(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DoubleBitMask< DoubleBitMaskNative >::output_hex(ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_hex", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "DoubleBitMask.output_hex", false, true);
    if (param1_this != NULL) {
      (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).output_hex(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_hex(DoubleBitMask self, ostream out, int spaces_every)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_output_hex_772_comment =
  "C++ Interface:\n"
  "output_hex(DoubleBitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_output_hex_772_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DoubleBitMask< DoubleBitMaskNative >::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_write_773(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DoubleBitMask< DoubleBitMaskNative >::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "DoubleBitMask.write", false, true);
    if (param1_this != NULL) {
      (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(DoubleBitMask self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_write_773_comment =
  "C++ Interface:\n"
  "write(DoubleBitMask self, ostream out, int indent_level)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_write_773_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< DoubleBitMaskNative >::compare_to(DoubleBitMask< DoubleBitMaskNative > const &other) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_777(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DoubleBitMask< DoubleBitMaskNative >::compare_to(DoubleBitMask< DoubleBitMaskNative > const &other) const
  DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 1, "DoubleBitMask.compare_to", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).compare_to(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(DoubleBitMask self, const DoubleBitMask other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_777_comment =
  "C++ Interface:\n"
  "compare_to(DoubleBitMask self, const DoubleBitMask other)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_777_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< DoubleBitMaskNative >::operator |=(DoubleBitMask< DoubleBitMaskNative > const &other)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_785(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.__ior__")) {
    return NULL;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::operator |=(DoubleBitMask< DoubleBitMaskNative > const &other)
  DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 1, "DoubleBitMask.__ior__", true, true);
  if (arg_this != NULL) {
    (*local_this).operator |=(*arg_this);
    DoubleBitMask< DoubleBitMaskNative > *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__ior__(const DoubleBitMask self, const DoubleBitMask other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_785_comment =
  "C++ Interface:\n"
  "__ior__(const DoubleBitMask self, const DoubleBitMask other)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_785_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DoubleBitMask< DoubleBitMaskNative >::get_class_type(void)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_class_type_789(PyObject *, PyObject *) {
  // 1-static TypeHandle DoubleBitMask< DoubleBitMaskNative >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(DoubleBitMask< DoubleBitMaskNative >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_class_type_789_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_class_type_789_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask(void)
 * inline DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask(DoubleBitMask< DoubleBitMaskNative > const &copy)
 */
static int Dtool_Init_DoubleBitMask_DoubleBitMaskNative(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask(void)
      DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DoubleBitMask_DoubleBitMaskNative, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-inline DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask(DoubleBitMask< DoubleBitMaskNative > const &copy)
      DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 0, "DoubleBitMask.DoubleBitMask", true, true);
      if (arg_this != NULL) {
        DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DoubleBitMask_DoubleBitMaskNative, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DoubleBitMask() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DoubleBitMask()\n"
      "DoubleBitMask(const DoubleBitMask copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DoubleBitMask_DoubleBitMaskNative(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative) {
    printf("DoubleBitMask_DoubleBitMaskNative ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DoubleBitMask< DoubleBitMaskNative > *local_this = (DoubleBitMask< DoubleBitMaskNative > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DoubleBitMask_DoubleBitMaskNative(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class KeyboardButton
 */
/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::ascii_key(char ascii_equivalent)
 */
static PyObject *Dtool_KeyboardButton_ascii_key_793(PyObject *, PyObject *arg) {
  // 1-static ButtonHandle KeyboardButton::ascii_key(char ascii_equivalent)
  char param0;
  if (PyArg_Parse(arg, "c:ascii_key", &param0)) {
    ButtonHandle *return_value = new ButtonHandle(KeyboardButton::ascii_key((char) param0));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ascii_key(char ascii_equivalent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_ascii_key_793_comment =
  "C++ Interface:\n"
  "ascii_key(char ascii_equivalent)\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle associated with the particular ASCII character, if\n"
  " * there is one, or ButtonHandle::none() if there is not.\n"
  " */";
#else
static const char *Dtool_KeyboardButton_ascii_key_793_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::space(void)
 */
static PyObject *Dtool_KeyboardButton_space_794(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::space(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::space());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_space_794_comment =
  "C++ Interface:\n"
  "space()\n";
#else
static const char *Dtool_KeyboardButton_space_794_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::backspace(void)
 */
static PyObject *Dtool_KeyboardButton_backspace_795(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::backspace(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::backspace());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_backspace_795_comment =
  "C++ Interface:\n"
  "backspace()\n";
#else
static const char *Dtool_KeyboardButton_backspace_795_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::tab(void)
 */
static PyObject *Dtool_KeyboardButton_tab_796(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::tab(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::tab());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_tab_796_comment =
  "C++ Interface:\n"
  "tab()\n";
#else
static const char *Dtool_KeyboardButton_tab_796_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::enter(void)
 */
static PyObject *Dtool_KeyboardButton_enter_797(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::enter(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::enter());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_enter_797_comment =
  "C++ Interface:\n"
  "enter()\n";
#else
static const char *Dtool_KeyboardButton_enter_797_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::escape(void)
 */
static PyObject *Dtool_KeyboardButton_escape_798(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::escape(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::escape());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_escape_798_comment =
  "C++ Interface:\n"
  "escape()\n";
#else
static const char *Dtool_KeyboardButton_escape_798_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f1(void)
 */
static PyObject *Dtool_KeyboardButton_f1_799(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f1(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::f1());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f1_799_comment =
  "C++ Interface:\n"
  "f1()\n";
#else
static const char *Dtool_KeyboardButton_f1_799_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f2(void)
 */
static PyObject *Dtool_KeyboardButton_f2_800(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f2(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::f2());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f2_800_comment =
  "C++ Interface:\n"
  "f2()\n";
#else
static const char *Dtool_KeyboardButton_f2_800_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f3(void)
 */
static PyObject *Dtool_KeyboardButton_f3_801(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f3(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::f3());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f3_801_comment =
  "C++ Interface:\n"
  "f3()\n";
#else
static const char *Dtool_KeyboardButton_f3_801_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f4(void)
 */
static PyObject *Dtool_KeyboardButton_f4_802(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f4(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::f4());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f4_802_comment =
  "C++ Interface:\n"
  "f4()\n";
#else
static const char *Dtool_KeyboardButton_f4_802_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f5(void)
 */
static PyObject *Dtool_KeyboardButton_f5_803(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f5(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::f5());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f5_803_comment =
  "C++ Interface:\n"
  "f5()\n";
#else
static const char *Dtool_KeyboardButton_f5_803_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f6(void)
 */
static PyObject *Dtool_KeyboardButton_f6_804(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f6(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::f6());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f6_804_comment =
  "C++ Interface:\n"
  "f6()\n";
#else
static const char *Dtool_KeyboardButton_f6_804_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f7(void)
 */
static PyObject *Dtool_KeyboardButton_f7_805(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f7(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::f7());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f7_805_comment =
  "C++ Interface:\n"
  "f7()\n";
#else
static const char *Dtool_KeyboardButton_f7_805_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f8(void)
 */
static PyObject *Dtool_KeyboardButton_f8_806(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f8(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::f8());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f8_806_comment =
  "C++ Interface:\n"
  "f8()\n";
#else
static const char *Dtool_KeyboardButton_f8_806_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f9(void)
 */
static PyObject *Dtool_KeyboardButton_f9_807(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f9(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::f9());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f9_807_comment =
  "C++ Interface:\n"
  "f9()\n";
#else
static const char *Dtool_KeyboardButton_f9_807_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f10(void)
 */
static PyObject *Dtool_KeyboardButton_f10_808(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f10(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::f10());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f10_808_comment =
  "C++ Interface:\n"
  "f10()\n";
#else
static const char *Dtool_KeyboardButton_f10_808_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f11(void)
 */
static PyObject *Dtool_KeyboardButton_f11_809(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f11(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::f11());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f11_809_comment =
  "C++ Interface:\n"
  "f11()\n";
#else
static const char *Dtool_KeyboardButton_f11_809_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f12(void)
 */
static PyObject *Dtool_KeyboardButton_f12_810(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f12(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::f12());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f12_810_comment =
  "C++ Interface:\n"
  "f12()\n";
#else
static const char *Dtool_KeyboardButton_f12_810_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f13(void)
 */
static PyObject *Dtool_KeyboardButton_f13_811(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f13(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::f13());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f13_811_comment =
  "C++ Interface:\n"
  "f13()\n"
  "\n"
  "// PC keyboards don't have these four buttons, but Macs do.";
#else
static const char *Dtool_KeyboardButton_f13_811_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f14(void)
 */
static PyObject *Dtool_KeyboardButton_f14_812(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f14(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::f14());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f14_812_comment =
  "C++ Interface:\n"
  "f14()\n";
#else
static const char *Dtool_KeyboardButton_f14_812_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f15(void)
 */
static PyObject *Dtool_KeyboardButton_f15_813(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f15(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::f15());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f15_813_comment =
  "C++ Interface:\n"
  "f15()\n";
#else
static const char *Dtool_KeyboardButton_f15_813_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f16(void)
 */
static PyObject *Dtool_KeyboardButton_f16_814(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f16(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::f16());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f16_814_comment =
  "C++ Interface:\n"
  "f16()\n";
#else
static const char *Dtool_KeyboardButton_f16_814_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::left(void)
 */
static PyObject *Dtool_KeyboardButton_left_815(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::left(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::left());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_left_815_comment =
  "C++ Interface:\n"
  "left()\n";
#else
static const char *Dtool_KeyboardButton_left_815_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::right(void)
 */
static PyObject *Dtool_KeyboardButton_right_816(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::right(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::right());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_right_816_comment =
  "C++ Interface:\n"
  "right()\n";
#else
static const char *Dtool_KeyboardButton_right_816_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::up(void)
 */
static PyObject *Dtool_KeyboardButton_up_817(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::up(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::up());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_up_817_comment =
  "C++ Interface:\n"
  "up()\n";
#else
static const char *Dtool_KeyboardButton_up_817_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::down(void)
 */
static PyObject *Dtool_KeyboardButton_down_818(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::down(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::down());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_down_818_comment =
  "C++ Interface:\n"
  "down()\n";
#else
static const char *Dtool_KeyboardButton_down_818_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::page_up(void)
 */
static PyObject *Dtool_KeyboardButton_page_up_819(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::page_up(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::page_up());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_page_up_819_comment =
  "C++ Interface:\n"
  "page_up()\n";
#else
static const char *Dtool_KeyboardButton_page_up_819_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::page_down(void)
 */
static PyObject *Dtool_KeyboardButton_page_down_820(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::page_down(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::page_down());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_page_down_820_comment =
  "C++ Interface:\n"
  "page_down()\n";
#else
static const char *Dtool_KeyboardButton_page_down_820_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::home(void)
 */
static PyObject *Dtool_KeyboardButton_home_821(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::home(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::home());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_home_821_comment =
  "C++ Interface:\n"
  "home()\n";
#else
static const char *Dtool_KeyboardButton_home_821_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::end(void)
 */
static PyObject *Dtool_KeyboardButton_end_822(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::end(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::end());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_end_822_comment =
  "C++ Interface:\n"
  "end()\n";
#else
static const char *Dtool_KeyboardButton_end_822_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::insert(void)
 */
static PyObject *Dtool_KeyboardButton_insert_823(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::insert(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::insert());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_insert_823_comment =
  "C++ Interface:\n"
  "insert()\n";
#else
static const char *Dtool_KeyboardButton_insert_823_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::del(void)
 */
static PyObject *Dtool_KeyboardButton_del_824(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::del(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::del());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_del_824_comment =
  "C++ Interface:\n"
  "_del()\n"
  "\n"
  "// delete is a C++ keyword.";
#else
static const char *Dtool_KeyboardButton_del_824_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::help(void)
 */
static PyObject *Dtool_KeyboardButton_help_825(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::help(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::help());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_help_825_comment =
  "C++ Interface:\n"
  "help()\n"
  "\n"
  "// delete is a C++ keyword.";
#else
static const char *Dtool_KeyboardButton_help_825_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::menu(void)
 */
static PyObject *Dtool_KeyboardButton_menu_826(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::menu(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::menu());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_menu_826_comment =
  "C++ Interface:\n"
  "menu()\n";
#else
static const char *Dtool_KeyboardButton_menu_826_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::shift(void)
 */
static PyObject *Dtool_KeyboardButton_shift_827(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::shift(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::shift());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_shift_827_comment =
  "C++ Interface:\n"
  "shift()\n";
#else
static const char *Dtool_KeyboardButton_shift_827_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::control(void)
 */
static PyObject *Dtool_KeyboardButton_control_828(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::control(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::control());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_control_828_comment =
  "C++ Interface:\n"
  "control()\n";
#else
static const char *Dtool_KeyboardButton_control_828_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::alt(void)
 */
static PyObject *Dtool_KeyboardButton_alt_829(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::alt(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::alt());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_alt_829_comment =
  "C++ Interface:\n"
  "alt()\n";
#else
static const char *Dtool_KeyboardButton_alt_829_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::meta(void)
 */
static PyObject *Dtool_KeyboardButton_meta_830(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::meta(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::meta());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_meta_830_comment =
  "C++ Interface:\n"
  "meta()\n";
#else
static const char *Dtool_KeyboardButton_meta_830_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::caps_lock(void)
 */
static PyObject *Dtool_KeyboardButton_caps_lock_831(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::caps_lock(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::caps_lock());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_caps_lock_831_comment =
  "C++ Interface:\n"
  "caps_lock()\n";
#else
static const char *Dtool_KeyboardButton_caps_lock_831_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::shift_lock(void)
 */
static PyObject *Dtool_KeyboardButton_shift_lock_832(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::shift_lock(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::shift_lock());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_shift_lock_832_comment =
  "C++ Interface:\n"
  "shift_lock()\n";
#else
static const char *Dtool_KeyboardButton_shift_lock_832_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::num_lock(void)
 */
static PyObject *Dtool_KeyboardButton_num_lock_833(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::num_lock(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::num_lock());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_num_lock_833_comment =
  "C++ Interface:\n"
  "num_lock()\n";
#else
static const char *Dtool_KeyboardButton_num_lock_833_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::scroll_lock(void)
 */
static PyObject *Dtool_KeyboardButton_scroll_lock_834(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::scroll_lock(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::scroll_lock());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_scroll_lock_834_comment =
  "C++ Interface:\n"
  "scroll_lock()\n";
#else
static const char *Dtool_KeyboardButton_scroll_lock_834_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::print_screen(void)
 */
static PyObject *Dtool_KeyboardButton_print_screen_835(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::print_screen(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::print_screen());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_print_screen_835_comment =
  "C++ Interface:\n"
  "print_screen()\n";
#else
static const char *Dtool_KeyboardButton_print_screen_835_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::pause(void)
 */
static PyObject *Dtool_KeyboardButton_pause_836(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::pause(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::pause());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_pause_836_comment =
  "C++ Interface:\n"
  "pause()\n";
#else
static const char *Dtool_KeyboardButton_pause_836_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::lshift(void)
 */
static PyObject *Dtool_KeyboardButton_lshift_837(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::lshift(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::lshift());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_lshift_837_comment =
  "C++ Interface:\n"
  "lshift()\n";
#else
static const char *Dtool_KeyboardButton_lshift_837_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::rshift(void)
 */
static PyObject *Dtool_KeyboardButton_rshift_838(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::rshift(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::rshift());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_rshift_838_comment =
  "C++ Interface:\n"
  "rshift()\n";
#else
static const char *Dtool_KeyboardButton_rshift_838_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::lcontrol(void)
 */
static PyObject *Dtool_KeyboardButton_lcontrol_839(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::lcontrol(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::lcontrol());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_lcontrol_839_comment =
  "C++ Interface:\n"
  "lcontrol()\n";
#else
static const char *Dtool_KeyboardButton_lcontrol_839_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::rcontrol(void)
 */
static PyObject *Dtool_KeyboardButton_rcontrol_840(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::rcontrol(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::rcontrol());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_rcontrol_840_comment =
  "C++ Interface:\n"
  "rcontrol()\n";
#else
static const char *Dtool_KeyboardButton_rcontrol_840_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::lalt(void)
 */
static PyObject *Dtool_KeyboardButton_lalt_841(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::lalt(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::lalt());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_lalt_841_comment =
  "C++ Interface:\n"
  "lalt()\n";
#else
static const char *Dtool_KeyboardButton_lalt_841_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::ralt(void)
 */
static PyObject *Dtool_KeyboardButton_ralt_842(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::ralt(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::ralt());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_ralt_842_comment =
  "C++ Interface:\n"
  "ralt()\n";
#else
static const char *Dtool_KeyboardButton_ralt_842_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::lmeta(void)
 */
static PyObject *Dtool_KeyboardButton_lmeta_843(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::lmeta(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::lmeta());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_lmeta_843_comment =
  "C++ Interface:\n"
  "lmeta()\n";
#else
static const char *Dtool_KeyboardButton_lmeta_843_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::rmeta(void)
 */
static PyObject *Dtool_KeyboardButton_rmeta_844(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::rmeta(void)
  ButtonHandle *return_value = new ButtonHandle(KeyboardButton::rmeta());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_rmeta_844_comment =
  "C++ Interface:\n"
  "rmeta()\n";
#else
static const char *Dtool_KeyboardButton_rmeta_844_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline KeyboardButton::KeyboardButton(void) = default
 * inline KeyboardButton::KeyboardButton(KeyboardButton const &) = default
 */
static int Dtool_Init_KeyboardButton(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline KeyboardButton::KeyboardButton(void) = default
      KeyboardButton *return_value = new KeyboardButton();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_KeyboardButton, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline KeyboardButton::KeyboardButton(KeyboardButton const &) = default
      KeyboardButton const *arg_this = (KeyboardButton *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_KeyboardButton, 0, "KeyboardButton.KeyboardButton", true, true);
      if (arg_this != NULL) {
        KeyboardButton *return_value = new KeyboardButton(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_KeyboardButton, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "KeyboardButton() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "KeyboardButton()\n"
      "KeyboardButton(const KeyboardButton param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_KeyboardButton(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_KeyboardButton) {
    printf("KeyboardButton ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  KeyboardButton *local_this = (KeyboardButton *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_KeyboardButton) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_KeyboardButton(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_KeyboardButton) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ModifierButtons
 */
/**
 * Python function wrapper for:
 * inline void ModifierButtons::operator =(ModifierButtons const &copy)
 */
static PyObject *Dtool_ModifierButtons_operator_854(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModifierButtons, (void **)&local_this, "ModifierButtons.assign")) {
    return NULL;
  }
  // 1-inline void ModifierButtons::operator =(ModifierButtons const &copy)
  ModifierButtons const *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 1, "ModifierButtons.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    ModifierButtons *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ModifierButtons, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const ModifierButtons self, const ModifierButtons copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_operator_854_comment =
  "C++ Interface:\n"
  "assign(const ModifierButtons self, const ModifierButtons copy)\n";
#else
static const char *Dtool_ModifierButtons_operator_854_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ModifierButtons::operator |=(ModifierButtons const &other)
 */
static PyObject *Dtool_ModifierButtons_operator_861(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModifierButtons, (void **)&local_this, "ModifierButtons.__ior__")) {
    return NULL;
  }
  // 1-void ModifierButtons::operator |=(ModifierButtons const &other)
  ModifierButtons const *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 1, "ModifierButtons.__ior__", true, true);
  if (arg_this != NULL) {
    (*local_this).operator |=(*arg_this);
    ModifierButtons *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ModifierButtons, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__ior__(const ModifierButtons self, const ModifierButtons other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_operator_861_comment =
  "C++ Interface:\n"
  "__ior__(const ModifierButtons self, const ModifierButtons other)\n";
#else
static const char *Dtool_ModifierButtons_operator_861_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ModifierButtons::set_button_list(ModifierButtons const &other)
 */
static PyObject *Dtool_ModifierButtons_set_button_list_862(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModifierButtons, (void **)&local_this, "ModifierButtons.set_button_list")) {
    return NULL;
  }
  // 1-void ModifierButtons::set_button_list(ModifierButtons const &other)
  ModifierButtons const *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 1, "ModifierButtons.set_button_list", true, true);
  if (arg_this != NULL) {
    (*local_this).set_button_list(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_button_list(const ModifierButtons self, const ModifierButtons other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_set_button_list_862_comment =
  "C++ Interface:\n"
  "set_button_list(const ModifierButtons self, const ModifierButtons other)\n"
  "\n"
  "/**\n"
  " * Sets the list of buttons to watch to be the same as that of the other\n"
  " * ModifierButtons object.  This makes the lists pointer equivalent (until one\n"
  " * or the other is later modified).\n"
  " *\n"
  " * This will preserve the state of any button that was on the original list\n"
  " * and is also on the new lists.  Any other buttons will get reset to the\n"
  " * default state of \"up\".\n"
  " */";
#else
static const char *Dtool_ModifierButtons_set_button_list_862_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ModifierButtons::matches(ModifierButtons const &other) const
 */
static PyObject *Dtool_ModifierButtons_matches_863(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool ModifierButtons::matches(ModifierButtons const &other) const
  ModifierButtons const *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 1, "ModifierButtons.matches", true, true);
  if (arg_this != NULL) {
    bool return_value = (*(const ModifierButtons*)local_this).matches(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "matches(ModifierButtons self, const ModifierButtons other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_matches_863_comment =
  "C++ Interface:\n"
  "matches(ModifierButtons self, const ModifierButtons other)\n"
  "\n"
  "/**\n"
  " * Returns true if the set of buttons indicated as down by this\n"
  " * ModifierButtons object is the same set of buttons indicated as down by the\n"
  " * other ModifierButtons object.  The buttons indicated as up are not\n"
  " * relevant.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_matches_863_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ModifierButtons::add_button(ButtonHandle button)
 */
static PyObject *Dtool_ModifierButtons_add_button_864(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModifierButtons, (void **)&local_this, "ModifierButtons.add_button")) {
    return NULL;
  }
  // 1-bool ModifierButtons::add_button(ButtonHandle button)
  ButtonHandle arg_local;
  ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ModifierButtons.add_button", "ButtonHandle");
  }
  bool return_value = (*local_this).add_button(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_button(const ModifierButtons self, ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_add_button_864_comment =
  "C++ Interface:\n"
  "add_button(const ModifierButtons self, ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Adds the indicated button to the set of buttons that will be monitored for\n"
  " * upness and downness.  Returns true if the button was added, false if it was\n"
  " * already being monitored or if too many buttons are currently being\n"
  " * monitored.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_add_button_864_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ModifierButtons::has_button(ButtonHandle button) const
 */
static PyObject *Dtool_ModifierButtons_has_button_865(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool ModifierButtons::has_button(ButtonHandle button) const
  ButtonHandle arg_local;
  ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ModifierButtons.has_button", "ButtonHandle");
  }
  bool return_value = (*(const ModifierButtons*)local_this).has_button(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_button(ModifierButtons self, ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_has_button_865_comment =
  "C++ Interface:\n"
  "has_button(ModifierButtons self, ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated button is in the set of buttons being\n"
  " * monitored, false otherwise.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_has_button_865_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ModifierButtons::remove_button(ButtonHandle button)
 */
static PyObject *Dtool_ModifierButtons_remove_button_866(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModifierButtons, (void **)&local_this, "ModifierButtons.remove_button")) {
    return NULL;
  }
  // 1-bool ModifierButtons::remove_button(ButtonHandle button)
  ButtonHandle arg_local;
  ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ModifierButtons.remove_button", "ButtonHandle");
  }
  bool return_value = (*local_this).remove_button(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_button(const ModifierButtons self, ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_remove_button_866_comment =
  "C++ Interface:\n"
  "remove_button(const ModifierButtons self, ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Removes the indicated button from the set of buttons being monitored.\n"
  " * Returns true if the button was removed, false if it was not being monitored\n"
  " * in the first place.\n"
  " *\n"
  " * Unlike the other methods, you cannot remove a button by removing its alias;\n"
  " * you have to remove exactly the button itself.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_remove_button_866_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ModifierButtons::get_num_buttons(void) const
 */
static PyObject *Dtool_ModifierButtons_get_num_buttons_867(PyObject *self, PyObject *) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ModifierButtons::get_num_buttons(void) const
  int return_value = (*(const ModifierButtons*)local_this).get_num_buttons();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_get_num_buttons_867_comment =
  "C++ Interface:\n"
  "get_num_buttons(ModifierButtons self)\n"
  "\n"
  "/**\n"
  " * Returns the number of buttons that the ModifierButtons object is monitoring\n"
  " * (e.g.  the number of buttons passed to add_button()).\n"
  " */";
#else
static const char *Dtool_ModifierButtons_get_num_buttons_867_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ButtonHandle ModifierButtons::get_button(int index) const
 */
static PyObject *Dtool_ModifierButtons_get_button_868(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ButtonHandle ModifierButtons::get_button(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ButtonHandle *return_value = new ButtonHandle((*(const ModifierButtons*)local_this).get_button((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_button(ModifierButtons self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_get_button_868_comment =
  "C++ Interface:\n"
  "get_button(ModifierButtons self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth button that the ModifierButtons object is monitoring (the\n"
  " * nth button passed to add_button()).  This must be in the range 0 <= index <\n"
  " * get_num_buttons().\n"
  " */";
#else
static const char *Dtool_ModifierButtons_get_button_868_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ModifierButtons::button_down(ButtonHandle button)
 */
static PyObject *Dtool_ModifierButtons_button_down_871(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModifierButtons, (void **)&local_this, "ModifierButtons.button_down")) {
    return NULL;
  }
  // 1-bool ModifierButtons::button_down(ButtonHandle button)
  ButtonHandle arg_local;
  ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ModifierButtons.button_down", "ButtonHandle");
  }
  bool return_value = (*local_this).button_down(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "button_down(const ModifierButtons self, ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_button_down_871_comment =
  "C++ Interface:\n"
  "button_down(const ModifierButtons self, ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Records that a particular button has been pressed.  If the given button is\n"
  " * one of the buttons that is currently being monitored, this will update the\n"
  " * internal state appropriately; otherwise, it will do nothing.  Returns true\n"
  " * if the button is one that was monitored, or false otherwise.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_button_down_871_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ModifierButtons::button_up(ButtonHandle button)
 */
static PyObject *Dtool_ModifierButtons_button_up_872(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModifierButtons, (void **)&local_this, "ModifierButtons.button_up")) {
    return NULL;
  }
  // 1-bool ModifierButtons::button_up(ButtonHandle button)
  ButtonHandle arg_local;
  ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ModifierButtons.button_up", "ButtonHandle");
  }
  bool return_value = (*local_this).button_up(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "button_up(const ModifierButtons self, ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_button_up_872_comment =
  "C++ Interface:\n"
  "button_up(const ModifierButtons self, ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Records that a particular button has been released.  If the given button is\n"
  " * one of the buttons that is currently being monitored, this will update the\n"
  " * internal state appropriately; otherwise, it will do nothing.  Returns true\n"
  " * if the button is one that was monitored, or false otherwise.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_button_up_872_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ModifierButtons::all_buttons_up(void)
 */
static PyObject *Dtool_ModifierButtons_all_buttons_up_873(PyObject *self, PyObject *) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModifierButtons, (void **)&local_this, "ModifierButtons.all_buttons_up")) {
    return NULL;
  }
  // 1-inline void ModifierButtons::all_buttons_up(void)
  (*local_this).all_buttons_up();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_all_buttons_up_873_comment =
  "C++ Interface:\n"
  "all_buttons_up(const ModifierButtons self)\n"
  "\n"
  "/**\n"
  " * Marks all monitored buttons as being in the \"up\" state.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_all_buttons_up_873_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ModifierButtons::is_down(ButtonHandle button) const
 * inline bool ModifierButtons::is_down(int index) const
 */
static PyObject *Dtool_ModifierButtons_is_down_874(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 bool ModifierButtons::is_down(ButtonHandle button) const
    ButtonHandle *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_ButtonHandle, (void **)&arg_this);
    if (arg_this != NULL) {
      bool return_value = (*(const ModifierButtons*)local_this).is_down(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool ModifierButtons::is_down(int index) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      bool return_value = (*(const ModifierButtons*)local_this).is_down((int)arg_val);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool ModifierButtons::is_down(ButtonHandle button) const
    ButtonHandle arg_local;
    ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
    if ((arg_this != NULL)) {
      bool return_value = (*(const ModifierButtons*)local_this).is_down(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: inline bool ModifierButtons::is_down(int index) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_down(ModifierButtons self, ButtonHandle button)\n"
      "is_down(ModifierButtons self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_is_down_874_comment =
  "C++ Interface:\n"
  "is_down(ModifierButtons self, ButtonHandle button)\n"
  "is_down(ModifierButtons self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated button is known to be down, or false if it is\n"
  " * known to be up.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated button is known to be down, or false if it is\n"
  " * known to be up or if it is not in the set of buttons being tracked.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_is_down_874_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ModifierButtons::is_any_down(void) const
 */
static PyObject *Dtool_ModifierButtons_is_any_down_875(PyObject *self, PyObject *) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ModifierButtons::is_any_down(void) const
  bool return_value = (*(const ModifierButtons*)local_this).is_any_down();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_is_any_down_875_comment =
  "C++ Interface:\n"
  "is_any_down(ModifierButtons self)\n"
  "\n"
  "/**\n"
  " * Returns true if any of the tracked button are known to be down, or false if\n"
  " * all of them are up.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_is_any_down_875_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string ModifierButtons::get_prefix(void) const
 */
static PyObject *Dtool_ModifierButtons_get_prefix_876(PyObject *self, PyObject *) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string ModifierButtons::get_prefix(void) const
  std::string return_value = (*(const ModifierButtons*)local_this).get_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_get_prefix_876_comment =
  "C++ Interface:\n"
  "get_prefix(ModifierButtons self)\n"
  "\n"
  "/**\n"
  " * Returns a string which can be used to prefix any button name or event name\n"
  " * with the unique set of modifier buttons currently being held.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_get_prefix_876_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ModifierButtons::output(ostream &out) const
 */
static PyObject *Dtool_ModifierButtons_output_877(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ModifierButtons::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ModifierButtons.output", false, true);
  if (arg_this != NULL) {
    (*(const ModifierButtons*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ModifierButtons self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_output_877_comment =
  "C++ Interface:\n"
  "output(ModifierButtons self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a one-line summary of the buttons known to be down.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_output_877_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ModifierButtons::write(ostream &out) const
 */
static PyObject *Dtool_ModifierButtons_write_878(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ModifierButtons::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ModifierButtons.write", false, true);
  if (arg_this != NULL) {
    (*(const ModifierButtons*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ModifierButtons self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_write_878_comment =
  "C++ Interface:\n"
  "write(ModifierButtons self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a multi-line summary including all of the buttons being monitored\n"
  " * and which ones are known to be down.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_write_878_comment = NULL;
#endif

/**
 * sequence length function for property ModifierButtons::buttons
 */
static Py_ssize_t Dtool_ModifierButtons_buttons_Len(PyObject *self) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_buttons();
}

/**
 * sequence getter for property ModifierButtons::buttons
 */
static PyObject *Dtool_ModifierButtons_buttons_Getitem(PyObject *self, Py_ssize_t index) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_buttons()) {
    PyErr_SetString(PyExc_IndexError, "ModifierButtons.buttons[] index out of range");
    return NULL;
  }
  // 1-inline ButtonHandle ModifierButtons::get_button(int index) const
  ButtonHandle *return_value = new ButtonHandle((*(const ModifierButtons*)local_this).get_button(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_button(ModifierButtons self, index)\n");
  }
}

static PyObject *Dtool_ModifierButtons_buttons_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_ModifierButtons_buttons_Len;
  wrap->_getitem_func = &Dtool_ModifierButtons_buttons_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * ModifierButtons::ModifierButtons(void)
 * ModifierButtons::ModifierButtons(ModifierButtons const &copy)
 */
static int Dtool_Init_ModifierButtons(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-ModifierButtons::ModifierButtons(void)
      ModifierButtons *return_value = new ModifierButtons();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ModifierButtons, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-ModifierButtons::ModifierButtons(ModifierButtons const &copy)
      ModifierButtons const *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 0, "ModifierButtons.ModifierButtons", true, true);
      if (arg_this != NULL) {
        ModifierButtons *return_value = new ModifierButtons(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ModifierButtons, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ModifierButtons() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ModifierButtons()\n"
      "ModifierButtons(const ModifierButtons copy)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ModifierButtons_get_buttons(PyObject *self, PyObject *) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_buttons();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ModifierButtons_get_button_868(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_ModifierButtons(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ModifierButtons) {
    printf("ModifierButtons ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ModifierButtons *local_this = (ModifierButtons *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ModifierButtons) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ModifierButtons(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ModifierButtons) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MouseButton
 */
/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::button(int button_number)
 */
static PyObject *Dtool_MouseButton_button_880(PyObject *, PyObject *arg) {
  // 1-static ButtonHandle MouseButton::button(int button_number)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ButtonHandle *return_value = new ButtonHandle(MouseButton::button((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "button(int button_number)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_button_880_comment =
  "C++ Interface:\n"
  "button(int button_number)\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle associated with the particular numbered mouse\n"
  " * button (zero-based), if there is one, or ButtonHandle::none() if there is\n"
  " * not.\n"
  " */";
#else
static const char *Dtool_MouseButton_button_880_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::one(void)
 */
static PyObject *Dtool_MouseButton_one_881(PyObject *, PyObject *) {
  // 1-static ButtonHandle MouseButton::one(void)
  ButtonHandle *return_value = new ButtonHandle(MouseButton::one());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_one_881_comment =
  "C++ Interface:\n"
  "one()\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle associated with the first mouse button.\n"
  " */";
#else
static const char *Dtool_MouseButton_one_881_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::two(void)
 */
static PyObject *Dtool_MouseButton_two_882(PyObject *, PyObject *) {
  // 1-static ButtonHandle MouseButton::two(void)
  ButtonHandle *return_value = new ButtonHandle(MouseButton::two());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_two_882_comment =
  "C++ Interface:\n"
  "two()\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle associated with the second mouse button.\n"
  " */";
#else
static const char *Dtool_MouseButton_two_882_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::three(void)
 */
static PyObject *Dtool_MouseButton_three_883(PyObject *, PyObject *) {
  // 1-static ButtonHandle MouseButton::three(void)
  ButtonHandle *return_value = new ButtonHandle(MouseButton::three());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_three_883_comment =
  "C++ Interface:\n"
  "three()\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle associated with the third mouse button.\n"
  " */";
#else
static const char *Dtool_MouseButton_three_883_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::four(void)
 */
static PyObject *Dtool_MouseButton_four_884(PyObject *, PyObject *) {
  // 1-static ButtonHandle MouseButton::four(void)
  ButtonHandle *return_value = new ButtonHandle(MouseButton::four());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_four_884_comment =
  "C++ Interface:\n"
  "four()\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle associated with the fourth mouse button.\n"
  " */";
#else
static const char *Dtool_MouseButton_four_884_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::five(void)
 */
static PyObject *Dtool_MouseButton_five_885(PyObject *, PyObject *) {
  // 1-static ButtonHandle MouseButton::five(void)
  ButtonHandle *return_value = new ButtonHandle(MouseButton::five());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_five_885_comment =
  "C++ Interface:\n"
  "five()\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle associated with the fifth mouse button.\n"
  " */";
#else
static const char *Dtool_MouseButton_five_885_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::wheel_up(void)
 */
static PyObject *Dtool_MouseButton_wheel_up_886(PyObject *, PyObject *) {
  // 1-static ButtonHandle MouseButton::wheel_up(void)
  ButtonHandle *return_value = new ButtonHandle(MouseButton::wheel_up());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_wheel_up_886_comment =
  "C++ Interface:\n"
  "wheel_up()\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle generated when the mouse wheel is rolled one notch\n"
  " * upwards.\n"
  " */";
#else
static const char *Dtool_MouseButton_wheel_up_886_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::wheel_down(void)
 */
static PyObject *Dtool_MouseButton_wheel_down_887(PyObject *, PyObject *) {
  // 1-static ButtonHandle MouseButton::wheel_down(void)
  ButtonHandle *return_value = new ButtonHandle(MouseButton::wheel_down());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_wheel_down_887_comment =
  "C++ Interface:\n"
  "wheel_down()\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle generated when the mouse wheel is rolled one notch\n"
  " * downwards.\n"
  " */";
#else
static const char *Dtool_MouseButton_wheel_down_887_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::wheel_left(void)
 */
static PyObject *Dtool_MouseButton_wheel_left_888(PyObject *, PyObject *) {
  // 1-static ButtonHandle MouseButton::wheel_left(void)
  ButtonHandle *return_value = new ButtonHandle(MouseButton::wheel_left());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_wheel_left_888_comment =
  "C++ Interface:\n"
  "wheel_left()\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle generated when the mouse is scrolled to the left.\n"
  " * Usually, you'll only find the horizontal scroll on laptops.\n"
  " */";
#else
static const char *Dtool_MouseButton_wheel_left_888_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::wheel_right(void)
 */
static PyObject *Dtool_MouseButton_wheel_right_889(PyObject *, PyObject *) {
  // 1-static ButtonHandle MouseButton::wheel_right(void)
  ButtonHandle *return_value = new ButtonHandle(MouseButton::wheel_right());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_wheel_right_889_comment =
  "C++ Interface:\n"
  "wheel_right()\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle generated when the mouse is scrolled to the right.\n"
  " * Usually, you'll only find the horizontal scroll on laptops.\n"
  " */";
#else
static const char *Dtool_MouseButton_wheel_right_889_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static bool MouseButton::is_mouse_button(ButtonHandle button)
 */
static PyObject *Dtool_MouseButton_is_mouse_button_890(PyObject *, PyObject *arg) {
  // 1-static bool MouseButton::is_mouse_button(ButtonHandle button)
  ButtonHandle arg_local;
  ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "MouseButton.is_mouse_button", "ButtonHandle");
  }
  bool return_value = MouseButton::is_mouse_button(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_mouse_button(ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_is_mouse_button_890_comment =
  "C++ Interface:\n"
  "is_mouse_button(ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated ButtonHandle is a mouse button, false if it\n"
  " * is some other kind of button.\n"
  " */";
#else
static const char *Dtool_MouseButton_is_mouse_button_890_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline MouseButton::MouseButton(void) = default
 * inline MouseButton::MouseButton(MouseButton const &) = default
 */
static int Dtool_Init_MouseButton(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline MouseButton::MouseButton(void) = default
      MouseButton *return_value = new MouseButton();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MouseButton, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline MouseButton::MouseButton(MouseButton const &) = default
      MouseButton const *arg_this = (MouseButton *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MouseButton, 0, "MouseButton.MouseButton", true, true);
      if (arg_this != NULL) {
        MouseButton *return_value = new MouseButton(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MouseButton, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "MouseButton() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MouseButton()\n"
      "MouseButton(const MouseButton param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_MouseButton(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MouseButton) {
    printf("MouseButton ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MouseButton *local_this = (MouseButton *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MouseButton) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MouseButton(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MouseButton) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MouseData
 */
/**
 * Python function wrapper for:
 * inline void MouseData::operator =(MouseData const &copy)
 */
static PyObject *Dtool_MouseData_operator_895(PyObject *self, PyObject *arg) {
  MouseData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseData, (void **)&local_this, "MouseData.assign")) {
    return NULL;
  }
  // 1-inline void MouseData::operator =(MouseData const &copy)
  MouseData const *arg_this = (MouseData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MouseData, 1, "MouseData.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    MouseData *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_MouseData, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const MouseData self, const MouseData copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseData_operator_895_comment =
  "C++ Interface:\n"
  "assign(const MouseData self, const MouseData copy)\n";
#else
static const char *Dtool_MouseData_operator_895_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double MouseData::get_x(void) const
 */
static PyObject *Dtool_MouseData_get_x_896(PyObject *self, PyObject *) {
  MouseData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double MouseData::get_x(void) const
  double return_value = (*(const MouseData*)local_this).get_x();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseData_get_x_896_comment =
  "C++ Interface:\n"
  "get_x(MouseData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_MouseData_get_x_896_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double MouseData::get_y(void) const
 */
static PyObject *Dtool_MouseData_get_y_897(PyObject *self, PyObject *) {
  MouseData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double MouseData::get_y(void) const
  double return_value = (*(const MouseData*)local_this).get_y();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseData_get_y_897_comment =
  "C++ Interface:\n"
  "get_y(MouseData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_MouseData_get_y_897_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool MouseData::get_in_window(void) const
 */
static PyObject *Dtool_MouseData_get_in_window_898(PyObject *self, PyObject *) {
  MouseData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool MouseData::get_in_window(void) const
  bool return_value = (*(const MouseData*)local_this).get_in_window();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseData_get_in_window_898_comment =
  "C++ Interface:\n"
  "get_in_window(MouseData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_MouseData_get_in_window_898_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MouseData::output(ostream &out) const
 */
static PyObject *Dtool_MouseData_output_899(PyObject *self, PyObject *arg) {
  MouseData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseData, (void **)&local_this)) {
    return NULL;
  }
  // 1-void MouseData::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "MouseData.output", false, true);
  if (arg_this != NULL) {
    (*(const MouseData*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(MouseData self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseData_output_899_comment =
  "C++ Interface:\n"
  "output(MouseData self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_MouseData_output_899_comment = NULL;
#endif

static PyObject *Dtool_MouseData_x_Getter(PyObject *self, void *) {
  const MouseData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseData, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double MouseData::get_x(void) const
  double return_value = (*(const MouseData*)local_this).get_x();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_MouseData_y_Getter(PyObject *self, void *) {
  const MouseData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseData, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double MouseData::get_y(void) const
  double return_value = (*(const MouseData*)local_this).get_y();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_MouseData_in_window_Getter(PyObject *self, void *) {
  const MouseData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseData, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool MouseData::get_in_window(void) const
  bool return_value = (*(const MouseData*)local_this).get_in_window();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline MouseData::MouseData(void)
 * inline MouseData::MouseData(MouseData const &copy)
 */
static int Dtool_Init_MouseData(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline MouseData::MouseData(void)
      MouseData *return_value = new MouseData();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MouseData, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-inline MouseData::MouseData(MouseData const &copy)
      MouseData const *arg_this = (MouseData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MouseData, 0, "MouseData.MouseData", true, true);
      if (arg_this != NULL) {
        MouseData *return_value = new MouseData(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MouseData, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "MouseData() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MouseData()\n"
      "MouseData(const MouseData copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_MouseData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MouseData) {
    printf("MouseData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MouseData *local_this = (MouseData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MouseData) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MouseData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MouseData) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class NodeCachedReferenceCount
 */
/**
 * Python function wrapper for:
 * inline int NodeCachedReferenceCount::get_node_ref_count(void) const
 */
static PyObject *Dtool_NodeCachedReferenceCount_get_node_ref_count_905(PyObject *self, PyObject *) {
  NodeCachedReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodeCachedReferenceCount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int NodeCachedReferenceCount::get_node_ref_count(void) const
  int return_value = (*(const NodeCachedReferenceCount*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodeCachedReferenceCount_get_node_ref_count_905_comment =
  "C++ Interface:\n"
  "get_node_ref_count(NodeCachedReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Returns the current reference count.\n"
  " */";
#else
static const char *Dtool_NodeCachedReferenceCount_get_node_ref_count_905_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void NodeCachedReferenceCount::node_ref(void) const
 */
static PyObject *Dtool_NodeCachedReferenceCount_node_ref_906(PyObject *self, PyObject *) {
  NodeCachedReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodeCachedReferenceCount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void NodeCachedReferenceCount::node_ref(void) const
  (*(const NodeCachedReferenceCount*)local_this).node_ref();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodeCachedReferenceCount_node_ref_906_comment =
  "C++ Interface:\n"
  "node_ref(NodeCachedReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Explicitly increments the reference count.\n"
  " *\n"
  " * This function is const, even though it changes the object, because\n"
  " * generally fiddling with an object's reference count isn't considered part\n"
  " * of fiddling with the object.  An object might be const in other ways, but\n"
  " * we still need to accurately count the number of references to it.\n"
  " */";
#else
static const char *Dtool_NodeCachedReferenceCount_node_ref_906_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool NodeCachedReferenceCount::node_unref(void) const
 */
static PyObject *Dtool_NodeCachedReferenceCount_node_unref_907(PyObject *self, PyObject *) {
  NodeCachedReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodeCachedReferenceCount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool NodeCachedReferenceCount::node_unref(void) const
  bool return_value = (*(const NodeCachedReferenceCount*)local_this).node_unref();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodeCachedReferenceCount_node_unref_907_comment =
  "C++ Interface:\n"
  "node_unref(NodeCachedReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Explicitly decrements the node reference count and the normal reference\n"
  " * count simultaneously.\n"
  " *\n"
  " * The return value is true if the new reference count is nonzero, false if it\n"
  " * is zero.\n"
  " */";
#else
static const char *Dtool_NodeCachedReferenceCount_node_unref_907_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool NodeCachedReferenceCount::test_ref_count_integrity(void) const
 */
static PyObject *Dtool_NodeCachedReferenceCount_test_ref_count_integrity_908(PyObject *self, PyObject *) {
  NodeCachedReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodeCachedReferenceCount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool NodeCachedReferenceCount::test_ref_count_integrity(void) const
  bool return_value = (*(const NodeCachedReferenceCount*)local_this).test_ref_count_integrity();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodeCachedReferenceCount_test_ref_count_integrity_908_comment =
  "C++ Interface:\n"
  "test_ref_count_integrity(NodeCachedReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Does some easy checks to make sure that the reference count isn't\n"
  " * completely bogus.\n"
  " */";
#else
static const char *Dtool_NodeCachedReferenceCount_test_ref_count_integrity_908_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int NodeCachedReferenceCount::get_referenced_bits(void) const
 */
static PyObject *Dtool_NodeCachedReferenceCount_get_referenced_bits_910(PyObject *self, PyObject *) {
  NodeCachedReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodeCachedReferenceCount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int NodeCachedReferenceCount::get_referenced_bits(void) const
  int return_value = (*(const NodeCachedReferenceCount*)local_this).get_referenced_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodeCachedReferenceCount_get_referenced_bits_910_comment =
  "C++ Interface:\n"
  "get_referenced_bits(NodeCachedReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Returns the union of the values defined in the Referenced enum that\n"
  " * represents the various things that appear to be holding a pointer to this\n"
  " * object.\n"
  " *\n"
  " * If R_node is included, at least one node is holding a pointer; if R_cache\n"
  " * is included, at least one cache element is.\n"
  " */";
#else
static const char *Dtool_NodeCachedReferenceCount_get_referenced_bits_910_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle NodeCachedReferenceCount::get_class_type(void)
 */
static PyObject *Dtool_NodeCachedReferenceCount_get_class_type_911(PyObject *, PyObject *) {
  // 1-static TypeHandle NodeCachedReferenceCount::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(NodeCachedReferenceCount::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NodeCachedReferenceCount_get_class_type_911_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_NodeCachedReferenceCount_get_class_type_911_comment = NULL;
#endif

static int Dtool_Init_NodeCachedReferenceCount(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_NodeCachedReferenceCount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_NodeCachedReferenceCount) {
    printf("NodeCachedReferenceCount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  NodeCachedReferenceCount *local_this = (NodeCachedReferenceCount *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_NodeCachedReferenceCount) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_NodeCachedReferenceCount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_NodeCachedReferenceCount) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (NodeCachedReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (NodeCachedReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (NodeCachedReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (NodeCachedReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (NodeCachedReferenceCount*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class SparseArray
 */
/**
 * Python function wrapper for:
 * inline SparseArray &SparseArray::operator =(SparseArray const &copy)
 */
static PyObject *Dtool_SparseArray_operator_914(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparseArray, (void **)&local_this, "SparseArray.assign")) {
    return NULL;
  }
  // 1-inline SparseArray &SparseArray::operator =(SparseArray const &copy)
  SparseArray const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_SparseArray(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SparseArray.assign", "SparseArray");
  }
  (*local_this).operator =(*arg_this);
  SparseArray *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const SparseArray self, const SparseArray copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_operator_914_comment =
  "C++ Interface:\n"
  "assign(const SparseArray self, const SparseArray copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SparseArray_operator_914_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline SparseArray SparseArray::all_on(void)
 */
static PyObject *Dtool_SparseArray_all_on_915(PyObject *, PyObject *) {
  // 1-static inline SparseArray SparseArray::all_on(void)
  SparseArray *return_value = new SparseArray(SparseArray::all_on());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_all_on_915_comment =
  "C++ Interface:\n"
  "all_on()\n"
  "\n"
  "/**\n"
  " * Returns a SparseArray with an infinite array of bits, all on.\n"
  " */";
#else
static const char *Dtool_SparseArray_all_on_915_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline SparseArray SparseArray::all_off(void)
 */
static PyObject *Dtool_SparseArray_all_off_916(PyObject *, PyObject *) {
  // 1-static inline SparseArray SparseArray::all_off(void)
  SparseArray *return_value = new SparseArray(SparseArray::all_off());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_all_off_916_comment =
  "C++ Interface:\n"
  "all_off()\n"
  "\n"
  "/**\n"
  " * Returns a SparseArray whose bits are all off.\n"
  " */";
#else
static const char *Dtool_SparseArray_all_off_916_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline SparseArray SparseArray::lower_on(int on_bits)
 */
static PyObject *Dtool_SparseArray_lower_on_917(PyObject *, PyObject *arg) {
  // 1-static inline SparseArray SparseArray::lower_on(int on_bits)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    SparseArray *return_value = new SparseArray(SparseArray::lower_on((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lower_on(int on_bits)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_lower_on_917_comment =
  "C++ Interface:\n"
  "lower_on(int on_bits)\n"
  "\n"
  "/**\n"
  " * Returns a SparseArray whose lower on_bits bits are on.\n"
  " */";
#else
static const char *Dtool_SparseArray_lower_on_917_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline SparseArray SparseArray::bit(int index)
 */
static PyObject *Dtool_SparseArray_bit_918(PyObject *, PyObject *arg) {
  // 1-static inline SparseArray SparseArray::bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    SparseArray *return_value = new SparseArray(SparseArray::bit((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bit(int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_bit_918_comment =
  "C++ Interface:\n"
  "bit(int index)\n"
  "\n"
  "/**\n"
  " * Returns a SparseArray with only the indicated bit on.\n"
  " */";
#else
static const char *Dtool_SparseArray_bit_918_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline SparseArray SparseArray::range(int low_bit, int size)
 */
static PyObject *Dtool_SparseArray_range_919(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline SparseArray SparseArray::range(int low_bit, int size)
  int param0;
  int param1;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:range", (char **)keyword_list, &param0, &param1)) {
    SparseArray *return_value = new SparseArray(SparseArray::range((int)param0, (int)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "range(int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_range_919_comment =
  "C++ Interface:\n"
  "range(int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Returns a SparseArray whose size bits, beginning at low_bit, are on.\n"
  " */";
#else
static const char *Dtool_SparseArray_range_919_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline bool SparseArray::has_max_num_bits(void)
 */
static PyObject *Dtool_SparseArray_has_max_num_bits_921(PyObject *, PyObject *) {
  // 1-static inline bool SparseArray::has_max_num_bits(void)
  bool return_value = SparseArray::has_max_num_bits();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_has_max_num_bits_921_comment =
  "C++ Interface:\n"
  "has_max_num_bits()\n"
  "\n"
  "/**\n"
  " * Returns true if there is a maximum number of bits that may be stored in\n"
  " * this structure, false otherwise.  If this returns true, the number may be\n"
  " * queried in get_max_num_bits().\n"
  " *\n"
  " * This method always returns false.  The SparseArray has no maximum number of\n"
  " * bits.  This method is defined so generic programming algorithms can use\n"
  " * BitMask or SparseArray interchangeably.\n"
  " */";
#else
static const char *Dtool_SparseArray_has_max_num_bits_921_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline int SparseArray::get_max_num_bits(void)
 */
static PyObject *Dtool_SparseArray_get_max_num_bits_922(PyObject *, PyObject *) {
  // 1-static inline int SparseArray::get_max_num_bits(void)
  int return_value = SparseArray::get_max_num_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_max_num_bits_922_comment =
  "C++ Interface:\n"
  "get_max_num_bits()\n"
  "\n"
  "/**\n"
  " * If get_max_num_bits() returned true, this method may be called to return\n"
  " * the maximum number of bits that may be stored in this structure.  It is an\n"
  " * error to call this if get_max_num_bits() return false.\n"
  " *\n"
  " * It is always an error to call this method.  The SparseArray has no maximum\n"
  " * number of bits.  This method is defined so generic programming algorithms\n"
  " * can use BitMask or SparseArray interchangeably.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_max_num_bits_922_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SparseArray::get_num_bits(void) const
 */
static PyObject *Dtool_SparseArray_get_num_bits_923(PyObject *self, PyObject *) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SparseArray::get_num_bits(void) const
  int return_value = (*(const SparseArray*)local_this).get_num_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_num_bits_923_comment =
  "C++ Interface:\n"
  "get_num_bits(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns the current number of possibly different bits in this array.  There\n"
  " * are actually an infinite number of bits, but every bit higher than this bit\n"
  " * will have the same value, either 0 or 1 (see get_highest_bits()).\n"
  " *\n"
  " * This number may grow and/or shrink automatically as needed.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_num_bits_923_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SparseArray::get_bit(int index) const
 */
static PyObject *Dtool_SparseArray_get_bit_924(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool SparseArray::get_bit(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const SparseArray*)local_this).get_bit((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bit(SparseArray self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_bit_924_comment =
  "C++ Interface:\n"
  "get_bit(SparseArray self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the nth bit is set, false if it is cleared.  It is valid\n"
  " * for n to increase beyond get_num_bits(), but the return value\n"
  " * get_num_bits() will always be the same.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_bit_924_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SparseArray::set_bit(int index)
 */
static PyObject *Dtool_SparseArray_set_bit_925(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparseArray, (void **)&local_this, "SparseArray.set_bit")) {
    return NULL;
  }
  // 1-inline void SparseArray::set_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_bit((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit(const SparseArray self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_set_bit_925_comment =
  "C++ Interface:\n"
  "set_bit(const SparseArray self, int index)\n"
  "\n"
  "/**\n"
  " * Sets the nth bit on.  If n >= get_num_bits(), this automatically extends\n"
  " * the array.\n"
  " */";
#else
static const char *Dtool_SparseArray_set_bit_925_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SparseArray::clear_bit(int index)
 */
static PyObject *Dtool_SparseArray_clear_bit_926(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparseArray, (void **)&local_this, "SparseArray.clear_bit")) {
    return NULL;
  }
  // 1-inline void SparseArray::clear_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).clear_bit((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_bit(const SparseArray self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_clear_bit_926_comment =
  "C++ Interface:\n"
  "clear_bit(const SparseArray self, int index)\n"
  "\n"
  "/**\n"
  " * Sets the nth bit off.  If n >= get_num_bits(), this automatically extends\n"
  " * the array.\n"
  " */";
#else
static const char *Dtool_SparseArray_clear_bit_926_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SparseArray::set_bit_to(int index, bool value)
 */
static PyObject *Dtool_SparseArray_set_bit_to_927(PyObject *self, PyObject *args, PyObject *kwds) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparseArray, (void **)&local_this, "SparseArray.set_bit_to")) {
    return NULL;
  }
  // 1-inline void SparseArray::set_bit_to(int index, bool value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_bit_to", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_bit_to((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit_to(const SparseArray self, int index, bool value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_set_bit_to_927_comment =
  "C++ Interface:\n"
  "set_bit_to(const SparseArray self, int index, bool value)\n"
  "\n"
  "/**\n"
  " * Sets the nth bit either on or off, according to the indicated bool value.\n"
  " */";
#else
static const char *Dtool_SparseArray_set_bit_to_927_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SparseArray::get_highest_bits(void) const
 */
static PyObject *Dtool_SparseArray_get_highest_bits_928(PyObject *self, PyObject *) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool SparseArray::get_highest_bits(void) const
  bool return_value = (*(const SparseArray*)local_this).get_highest_bits();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_highest_bits_928_comment =
  "C++ Interface:\n"
  "get_highest_bits(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns true if the infinite set of bits beyond get_num_bits() are all on,\n"
  " * or false of they are all off.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_highest_bits_928_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SparseArray::is_zero(void) const
 */
static PyObject *Dtool_SparseArray_is_zero_929(PyObject *self, PyObject *) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool SparseArray::is_zero(void) const
  bool return_value = (*(const SparseArray*)local_this).is_zero();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_is_zero_929_comment =
  "C++ Interface:\n"
  "is_zero(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns true if the entire bitmask is zero, false otherwise.\n"
  " */";
#else
static const char *Dtool_SparseArray_is_zero_929_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SparseArray::is_all_on(void) const
 */
static PyObject *Dtool_SparseArray_is_all_on_930(PyObject *self, PyObject *) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool SparseArray::is_all_on(void) const
  bool return_value = (*(const SparseArray*)local_this).is_all_on();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_is_all_on_930_comment =
  "C++ Interface:\n"
  "is_all_on(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns true if the entire bitmask is one, false otherwise.\n"
  " */";
#else
static const char *Dtool_SparseArray_is_all_on_930_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SparseArray::has_any_of(int low_bit, int size) const
 */
static PyObject *Dtool_SparseArray_has_any_of_931(PyObject *self, PyObject *args, PyObject *kwds) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool SparseArray::has_any_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_any_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*(const SparseArray*)local_this).has_any_of((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_any_of(SparseArray self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_has_any_of_931_comment =
  "C++ Interface:\n"
  "has_any_of(SparseArray self, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Returns true if any bit in the indicated range is set, false otherwise.\n"
  " */";
#else
static const char *Dtool_SparseArray_has_any_of_931_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SparseArray::has_all_of(int low_bit, int size) const
 */
static PyObject *Dtool_SparseArray_has_all_of_932(PyObject *self, PyObject *args, PyObject *kwds) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool SparseArray::has_all_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_all_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*(const SparseArray*)local_this).has_all_of((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_all_of(SparseArray self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_has_all_of_932_comment =
  "C++ Interface:\n"
  "has_all_of(SparseArray self, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Returns true if all bits in the indicated range are set, false otherwise.\n"
  " */";
#else
static const char *Dtool_SparseArray_has_all_of_932_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SparseArray::set_range(int low_bit, int size)
 */
static PyObject *Dtool_SparseArray_set_range_933(PyObject *self, PyObject *args, PyObject *kwds) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparseArray, (void **)&local_this, "SparseArray.set_range")) {
    return NULL;
  }
  // 1-inline void SparseArray::set_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_range", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_range((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range(const SparseArray self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_set_range_933_comment =
  "C++ Interface:\n"
  "set_range(const SparseArray self, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Sets the indicated range of bits on.\n"
  " */";
#else
static const char *Dtool_SparseArray_set_range_933_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SparseArray::clear_range(int low_bit, int size)
 */
static PyObject *Dtool_SparseArray_clear_range_934(PyObject *self, PyObject *args, PyObject *kwds) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparseArray, (void **)&local_this, "SparseArray.clear_range")) {
    return NULL;
  }
  // 1-inline void SparseArray::clear_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:clear_range", (char **)keyword_list, &param1, &param2)) {
    (*local_this).clear_range((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_range(const SparseArray self, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_clear_range_934_comment =
  "C++ Interface:\n"
  "clear_range(const SparseArray self, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Sets the indicated range of bits off.\n"
  " */";
#else
static const char *Dtool_SparseArray_clear_range_934_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SparseArray::set_range_to(bool value, int low_bit, int size)
 */
static PyObject *Dtool_SparseArray_set_range_to_935(PyObject *self, PyObject *args, PyObject *kwds) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparseArray, (void **)&local_this, "SparseArray.set_range_to")) {
    return NULL;
  }
  // 1-inline void SparseArray::set_range_to(bool value, int low_bit, int size)
  PyObject *param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_range_to", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_range_to((PyObject_IsTrue(param1) != 0), (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range_to(const SparseArray self, bool value, int low_bit, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_set_range_to_935_comment =
  "C++ Interface:\n"
  "set_range_to(const SparseArray self, bool value, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Sets the indicated range of bits to either on or off.\n"
  " */";
#else
static const char *Dtool_SparseArray_set_range_to_935_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int SparseArray::get_num_on_bits(void) const
 */
static PyObject *Dtool_SparseArray_get_num_on_bits_936(PyObject *self, PyObject *) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-int SparseArray::get_num_on_bits(void) const
  int return_value = (*(const SparseArray*)local_this).get_num_on_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_num_on_bits_936_comment =
  "C++ Interface:\n"
  "get_num_on_bits(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bits that are set to 1 in the array.  Returns -1 if\n"
  " * there are an infinite number of 1 bits.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_num_on_bits_936_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int SparseArray::get_num_off_bits(void) const
 */
static PyObject *Dtool_SparseArray_get_num_off_bits_937(PyObject *self, PyObject *) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-int SparseArray::get_num_off_bits(void) const
  int return_value = (*(const SparseArray*)local_this).get_num_off_bits();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_num_off_bits_937_comment =
  "C++ Interface:\n"
  "get_num_off_bits(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bits that are set to 0 in the array.  Returns -1 if\n"
  " * there are an infinite number of 0 bits.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_num_off_bits_937_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int SparseArray::get_lowest_on_bit(void) const
 */
static PyObject *Dtool_SparseArray_get_lowest_on_bit_938(PyObject *self, PyObject *) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-int SparseArray::get_lowest_on_bit(void) const
  int return_value = (*(const SparseArray*)local_this).get_lowest_on_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_lowest_on_bit_938_comment =
  "C++ Interface:\n"
  "get_lowest_on_bit(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the lowest 1 bit in the array.  Returns -1 if there\n"
  " * are no 1 bits or if there are an infinite number of 1 bits.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_lowest_on_bit_938_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int SparseArray::get_lowest_off_bit(void) const
 */
static PyObject *Dtool_SparseArray_get_lowest_off_bit_939(PyObject *self, PyObject *) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-int SparseArray::get_lowest_off_bit(void) const
  int return_value = (*(const SparseArray*)local_this).get_lowest_off_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_lowest_off_bit_939_comment =
  "C++ Interface:\n"
  "get_lowest_off_bit(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the lowest 0 bit in the array.  Returns -1 if there\n"
  " * are no 0 bits or if there are an infinite number of 1 bits.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_lowest_off_bit_939_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int SparseArray::get_highest_on_bit(void) const
 */
static PyObject *Dtool_SparseArray_get_highest_on_bit_940(PyObject *self, PyObject *) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-int SparseArray::get_highest_on_bit(void) const
  int return_value = (*(const SparseArray*)local_this).get_highest_on_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_highest_on_bit_940_comment =
  "C++ Interface:\n"
  "get_highest_on_bit(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the highest 1 bit in the array.  Returns -1 if there\n"
  " * are no 1 bits or if there an infinite number of 1 bits.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_highest_on_bit_940_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int SparseArray::get_highest_off_bit(void) const
 */
static PyObject *Dtool_SparseArray_get_highest_off_bit_941(PyObject *self, PyObject *) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-int SparseArray::get_highest_off_bit(void) const
  int return_value = (*(const SparseArray*)local_this).get_highest_off_bit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_highest_off_bit_941_comment =
  "C++ Interface:\n"
  "get_highest_off_bit(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the highest 0 bit in the array.  Returns -1 if there\n"
  " * are no 0 bits or if there an infinite number of 1 bits.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_highest_off_bit_941_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int SparseArray::get_next_higher_different_bit(int low_bit) const
 */
static PyObject *Dtool_SparseArray_get_next_higher_different_bit_942(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-int SparseArray::get_next_higher_different_bit(int low_bit) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const SparseArray*)local_this).get_next_higher_different_bit((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_next_higher_different_bit(SparseArray self, int low_bit)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_next_higher_different_bit_942_comment =
  "C++ Interface:\n"
  "get_next_higher_different_bit(SparseArray self, int low_bit)\n"
  "\n"
  "/**\n"
  " * Returns the index of the next bit in the array, above low_bit, whose value\n"
  " * is different that the value of low_bit.  Returns low_bit again if all bits\n"
  " * higher than low_bit have the same value.\n"
  " *\n"
  " * This can be used to quickly iterate through all of the bits in the array.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_next_higher_different_bit_942_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SparseArray::invert_in_place(void)
 */
static PyObject *Dtool_SparseArray_invert_in_place_943(PyObject *self, PyObject *) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparseArray, (void **)&local_this, "SparseArray.invert_in_place")) {
    return NULL;
  }
  // 1-inline void SparseArray::invert_in_place(void)
  (*local_this).invert_in_place();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_invert_in_place_943_comment =
  "C++ Interface:\n"
  "invert_in_place(const SparseArray self)\n"
  "\n"
  "/**\n"
  " * Inverts all the bits in the SparseArray.  This is equivalent to array =\n"
  " * ~array.\n"
  " */";
#else
static const char *Dtool_SparseArray_invert_in_place_943_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool SparseArray::has_bits_in_common(SparseArray const &other) const
 */
static PyObject *Dtool_SparseArray_has_bits_in_common_944(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool SparseArray::has_bits_in_common(SparseArray const &other) const
  SparseArray const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_SparseArray(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SparseArray.has_bits_in_common", "SparseArray");
  }
  bool return_value = (*(const SparseArray*)local_this).has_bits_in_common(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_bits_in_common(SparseArray self, const SparseArray other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_has_bits_in_common_944_comment =
  "C++ Interface:\n"
  "has_bits_in_common(SparseArray self, const SparseArray other)\n"
  "\n"
  "/**\n"
  " * Returns true if this SparseArray has any \"one\" bits in common with the\n"
  " * other one, false otherwise.\n"
  " *\n"
  " * This is equivalent to (array & other) != 0, but may be faster.\n"
  " */";
#else
static const char *Dtool_SparseArray_has_bits_in_common_944_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SparseArray::clear(void)
 */
static PyObject *Dtool_SparseArray_clear_945(PyObject *self, PyObject *) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparseArray, (void **)&local_this, "SparseArray.clear")) {
    return NULL;
  }
  // 1-inline void SparseArray::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_clear_945_comment =
  "C++ Interface:\n"
  "clear(const SparseArray self)\n"
  "\n"
  "/**\n"
  " * Sets all the bits in the SparseArray off.\n"
  " */";
#else
static const char *Dtool_SparseArray_clear_945_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void SparseArray::output(ostream &out) const
 */
static PyObject *Dtool_SparseArray_output_946(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-void SparseArray::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "SparseArray.output", false, true);
  if (arg_this != NULL) {
    (*(const SparseArray*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(SparseArray self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_output_946_comment =
  "C++ Interface:\n"
  "output(SparseArray self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SparseArray_output_946_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int SparseArray::compare_to(SparseArray const &other) const
 */
static PyObject *Dtool_SparseArray_compare_to_950(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-int SparseArray::compare_to(SparseArray const &other) const
  SparseArray const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_SparseArray(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SparseArray.compare_to", "SparseArray");
  }
  int return_value = (*(const SparseArray*)local_this).compare_to(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(SparseArray self, const SparseArray other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_compare_to_950_comment =
  "C++ Interface:\n"
  "compare_to(SparseArray self, const SparseArray other)\n"
  "\n"
  "/**\n"
  " * Returns a number less than zero if this SparseArray sorts before the\n"
  " * indicated other SparseArray, greater than zero if it sorts after, or 0 if\n"
  " * they are equivalent.  This is based on the same ordering defined by\n"
  " * operator <.\n"
  " */";
#else
static const char *Dtool_SparseArray_compare_to_950_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void SparseArray::operator |=(SparseArray const &other)
 */
static PyObject *Dtool_SparseArray_operator_958(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparseArray, (void **)&local_this, "SparseArray.__ior__")) {
    return NULL;
  }
  // 1-void SparseArray::operator |=(SparseArray const &other)
  SparseArray const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_SparseArray(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SparseArray.__ior__", "SparseArray");
  }
  (*local_this).operator |=(*arg_this);
  SparseArray *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__ior__(const SparseArray self, const SparseArray other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_operator_958_comment =
  "C++ Interface:\n"
  "__ior__(const SparseArray self, const SparseArray other)\n";
#else
static const char *Dtool_SparseArray_operator_958_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SparseArray::is_inverse(void) const
 */
static PyObject *Dtool_SparseArray_is_inverse_962(PyObject *self, PyObject *) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool SparseArray::is_inverse(void) const
  bool return_value = (*(const SparseArray*)local_this).is_inverse();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_is_inverse_962_comment =
  "C++ Interface:\n"
  "is_inverse(SparseArray self)\n"
  "\n"
  "/**\n"
  " * If this is true, the SparseArray is actually defined as a list of subranges\n"
  " * of integers that are *not* in the set.  If this is false (the default),\n"
  " * then the subranges define the integers that *are* in the set.  This affects\n"
  " * the interpretation of the values returned by iterating through\n"
  " * get_num_subranges().\n"
  " */";
#else
static const char *Dtool_SparseArray_is_inverse_962_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t SparseArray::get_num_subranges(void) const
 */
static PyObject *Dtool_SparseArray_get_num_subranges_963(PyObject *self, PyObject *) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t SparseArray::get_num_subranges(void) const
  std::size_t return_value = (*(const SparseArray*)local_this).get_num_subranges();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_num_subranges_963_comment =
  "C++ Interface:\n"
  "get_num_subranges(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns the number of separate subranges stored in the SparseArray.  You\n"
  " * can use this limit to iterate through the subranges, calling\n"
  " * get_subrange_begin() and get_subrange_end() for each one.\n"
  " *\n"
  " * Also see is_inverse().\n"
  " */";
#else
static const char *Dtool_SparseArray_get_num_subranges_963_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SparseArray::get_subrange_begin(std::size_t n) const
 */
static PyObject *Dtool_SparseArray_get_subrange_begin_964(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SparseArray::get_subrange_begin(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_subrange_begin", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    int return_value = (*(const SparseArray*)local_this).get_subrange_begin((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subrange_begin(SparseArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_subrange_begin_964_comment =
  "C++ Interface:\n"
  "get_subrange_begin(SparseArray self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the first numeric element in the nth subrange.\n"
  " *\n"
  " * Also see is_inverse().\n"
  " */";
#else
static const char *Dtool_SparseArray_get_subrange_begin_964_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SparseArray::get_subrange_end(std::size_t n) const
 */
static PyObject *Dtool_SparseArray_get_subrange_end_965(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SparseArray::get_subrange_end(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_subrange_end", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    int return_value = (*(const SparseArray*)local_this).get_subrange_end((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subrange_end(SparseArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_subrange_end_965_comment =
  "C++ Interface:\n"
  "get_subrange_end(SparseArray self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the last numeric element, plus one, in the nth subrange.\n"
  " *\n"
  " * Also see is_inverse().\n"
  " */";
#else
static const char *Dtool_SparseArray_get_subrange_end_965_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle SparseArray::get_class_type(void)
 */
static PyObject *Dtool_SparseArray_get_class_type_966(PyObject *, PyObject *) {
  // 1-static TypeHandle SparseArray::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(SparseArray::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_class_type_966_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SparseArray_get_class_type_966_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline SparseArray::SparseArray(void)
 * SparseArray::SparseArray(BitArray const &from)
 * inline SparseArray::SparseArray(SparseArray const &copy)
 */
static int Dtool_Init_SparseArray(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline SparseArray::SparseArray(void)
      SparseArray *return_value = new SparseArray();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SparseArray, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline SparseArray::SparseArray(SparseArray const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:SparseArray", (char **)keyword_list, &param0)) {
          SparseArray const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_SparseArray, (void **)&param0_this);
          if (param0_this != NULL) {
            SparseArray *return_value = new SparseArray(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SparseArray, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 SparseArray::SparseArray(BitArray const &from)
        PyObject *param0;
        static const char *keyword_list[] = {"from", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:SparseArray", (char **)keyword_list, &param0)) {
          BitArray const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_BitArray, (void **)&param0_this);
          if (param0_this != NULL) {
            SparseArray *return_value = new SparseArray(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SparseArray, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline SparseArray::SparseArray(SparseArray const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:SparseArray", (char **)keyword_list, &param0)) {
          SparseArray const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_SparseArray(param0, param0_this, param0_manage)) {
            SparseArray *return_value = new SparseArray(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SparseArray, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 SparseArray::SparseArray(BitArray const &from)
        PyObject *param0;
        static const char *keyword_list[] = {"from", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:SparseArray", (char **)keyword_list, &param0)) {
          BitArray const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_BitArray(param0, param0_this, param0_manage)) {
            SparseArray *return_value = new SparseArray(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SparseArray, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SparseArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SparseArray()\n"
      "SparseArray(const SparseArray copy)\n"
      "SparseArray(const BitArray from)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_SparseArray(PyObject *args, SparseArray const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SparseArray, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-SparseArray::SparseArray(BitArray const &from)
    BitArray const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_BitArray, (void **)&arg_this);
    if (arg_this != NULL) {
      SparseArray *return_value = new SparseArray(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_SparseArray(PyObject *args, SparseArray *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SparseArray, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-SparseArray::SparseArray(BitArray const &from)
    BitArray const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_BitArray, (void **)&arg_this);
    if (arg_this != NULL) {
      SparseArray *return_value = new SparseArray(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_SparseArray(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SparseArray) {
    printf("SparseArray ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SparseArray *local_this = (SparseArray *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SparseArray) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SparseArray(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SparseArray) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParamValueBase
 */
/**
 * Python function wrapper for:
 * virtual inline TypeHandle ParamValueBase::get_value_type(void) const
 */
static PyObject *Dtool_ParamValueBase_get_value_type_968(PyObject *self, PyObject *) {
  ParamValueBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValueBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual inline TypeHandle ParamValueBase::get_value_type(void) const
  TypeHandle *return_value = new TypeHandle((*(const ParamValueBase*)local_this).get_value_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValueBase_get_value_type_968_comment =
  "C++ Interface:\n"
  "get_value_type(ParamValueBase self)\n"
  "\n"
  "/**\n"
  " * Returns the type of the underlying value.\n"
  " */";
#else
static const char *Dtool_ParamValueBase_get_value_type_968_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void ParamValueBase::output(ostream &out) const = 0
 */
static PyObject *Dtool_ParamValueBase_output_969(PyObject *self, PyObject *arg) {
  ParamValueBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValueBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void ParamValueBase::output(ostream &out) const = 0
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ParamValueBase.output", false, true);
  if (arg_this != NULL) {
    (*(const ParamValueBase*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ParamValueBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParamValueBase_output_969_comment =
  "C++ Interface:\n"
  "output(ParamValueBase self, ostream out)\n";
#else
static const char *Dtool_ParamValueBase_output_969_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValueBase::get_class_type(void)
 */
static PyObject *Dtool_ParamValueBase_get_class_type_970(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValueBase::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ParamValueBase::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValueBase_get_class_type_970_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValueBase_get_class_type_970_comment = NULL;
#endif

static int Dtool_Init_ParamValueBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ParamValueBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParamValueBase) {
    printf("ParamValueBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParamValueBase *local_this = (ParamValueBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParamValueBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValueBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValueBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValueBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValueBase*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParamTypedRefCount
 */
/**
 * Python function wrapper for:
 * inline TypedReferenceCount *ParamTypedRefCount::get_value(void) const
 */
static PyObject *Dtool_ParamTypedRefCount_get_value_973(PyObject *self, PyObject *) {
  ParamTypedRefCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamTypedRefCount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline TypedReferenceCount *ParamTypedRefCount::get_value(void) const
  TypedReferenceCount *return_value = (*(const ParamTypedRefCount*)local_this).get_value();
  if (return_value != (TypedReferenceCount *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (TypedReferenceCount *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ParamTypedRefCount_get_value_973_comment =
  "C++ Interface:\n"
  "get_value(ParamTypedRefCount self)\n"
  "\n"
  "/**\n"
  " * Retrieves the value stored in the parameter.\n"
  " */";
#else
static const char *Dtool_ParamTypedRefCount_get_value_973_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamTypedRefCount::get_class_type(void)
 */
static PyObject *Dtool_ParamTypedRefCount_get_class_type_976(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamTypedRefCount::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ParamTypedRefCount::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamTypedRefCount_get_class_type_976_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamTypedRefCount_get_class_type_976_comment = NULL;
#endif

static PyObject *Dtool_ParamTypedRefCount_value_Getter(PyObject *self, void *) {
  const ParamTypedRefCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamTypedRefCount, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline TypedReferenceCount *ParamTypedRefCount::get_value(void) const
  TypedReferenceCount *return_value = (*(const ParamTypedRefCount*)local_this).get_value();
  if (return_value != (TypedReferenceCount *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (TypedReferenceCount *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

/**
 * Python function wrapper for:
 * inline ParamTypedRefCount::ParamTypedRefCount(TypedReferenceCount const *value)
 */
static int Dtool_Init_ParamTypedRefCount(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamTypedRefCount() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "value");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
    return -1;
  }
  // 1-inline ParamTypedRefCount::ParamTypedRefCount(TypedReferenceCount const *value)
  TypedReferenceCount const *arg_this = (TypedReferenceCount *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedReferenceCount, 0, "ParamTypedRefCount.ParamTypedRefCount", true, true);
  if (arg_this != NULL) {
    ParamTypedRefCount *return_value = new ParamTypedRefCount(arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamTypedRefCount, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamTypedRefCount(const TypedReferenceCount value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamTypedRefCount(PyObject *args, CPT(ParamTypedRefCount) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamTypedRefCount, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamTypedRefCount::ParamTypedRefCount(TypedReferenceCount const *value)
    TypedReferenceCount const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypedReferenceCount, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamTypedRefCount *return_value = new ParamTypedRefCount(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamTypedRefCount(PyObject *args, PT(ParamTypedRefCount) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamTypedRefCount, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamTypedRefCount::ParamTypedRefCount(TypedReferenceCount const *value)
    TypedReferenceCount const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypedReferenceCount, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamTypedRefCount *return_value = new ParamTypedRefCount(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamTypedRefCount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParamTypedRefCount) {
    printf("ParamTypedRefCount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParamTypedRefCount *local_this = (ParamTypedRefCount *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParamTypedRefCount) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParamTypedRefCount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParamTypedRefCount) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamTypedRefCount*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamTypedRefCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamTypedRefCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamTypedRefCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamTypedRefCount*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParamValue< std::string >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< string >::set_value(std::string const &value)
 */
static PyObject *Dtool_ParamValue_string_set_value_979(PyObject *self, PyObject *arg) {
  ParamValue< std::string > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_std_string, (void **)&local_this, "ParamValue_std::string.set_value")) {
    return NULL;
  }
  // 1-inline void ParamValue< string >::set_value(std::string const &value)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_value(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, str value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_string_set_value_979_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, str value)\n";
#else
static const char *Dtool_ParamValue_string_set_value_979_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ParamValue< string >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_string_get_value_980(PyObject *self, PyObject *) {
  ParamValue< std::string > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_std_string, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &ParamValue< string >::get_value(void) const
  std::string const &return_value = (*(const ParamValue< std::string >*)local_this).get_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_string_get_value_980_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_string_get_value_980_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< string >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_string_get_class_type_984(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< string >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ParamValue< string >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_string_get_class_type_984_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_string_get_class_type_984_comment = NULL;
#endif

static PyObject *Dtool_ParamValue_std_string_value_Getter(PyObject *self, void *) {
  const ParamValue< std::string > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_std_string, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &ParamValue< string >::get_value(void) const
  std::string const &return_value = (*(const ParamValue< std::string >*)local_this).get_value();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ParamValue_std_string_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< std::string > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_std_string, (void **)&local_this, "ParamValue_std::string.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< string >::set_value(std::string const &value)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_value(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, str value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< string >::ParamValue(std::string const &value)
 */
static int Dtool_Init_ParamValue_std_string(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "value");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
    return -1;
  }
  // 1-inline ParamValue< string >::ParamValue(std::string const &value)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    ParamValue< std::string > *return_value = new ParamValue< std::string >(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_std_string, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(str value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_std_string(PyObject *args, CPT(ParamValue< std::string >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_std_string, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< string >::ParamValue(std::string const &value)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ParamValue< std::string > *return_value = new ParamValue< std::string >(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_ParamValue_std_string(PyObject *args, PT(ParamValue< std::string >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_std_string, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< string >::ParamValue(std::string const &value)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ParamValue< std::string > *return_value = new ParamValue< std::string >(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_std_string(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParamValue_std_string) {
    printf("ParamValue_std_string ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParamValue< std::string > *local_this = (ParamValue< std::string > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParamValue_std_string) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParamValue_std_string(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParamValue_std_string) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< std::string >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< std::string >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< std::string >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< std::string >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< std::string >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParamValue< std::wstring >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< wstring >::set_value(std::wstring const &value)
 */
static PyObject *Dtool_ParamValue_wstring_set_value_988(PyObject *self, PyObject *arg) {
  ParamValue< std::wstring > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_std_wstring, (void **)&local_this, "ParamValue_std::wstring.set_value")) {
    return NULL;
  }
  // 1-inline void ParamValue< wstring >::set_value(std::wstring const &value)
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
  #else
  PyUnicodeObject *param1;
  #endif
  if (PyArg_Parse(arg, "U:set_value", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    (*local_this).set_value(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, unicode value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_wstring_set_value_988_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, unicode value)\n";
#else
static const char *Dtool_ParamValue_wstring_set_value_988_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::wstring const &ParamValue< wstring >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_wstring_get_value_989(PyObject *self, PyObject *) {
  ParamValue< std::wstring > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_std_wstring, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::wstring const &ParamValue< wstring >::get_value(void) const
  std::wstring const &return_value = (*(const ParamValue< std::wstring >*)local_this).get_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_wstring_get_value_989_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_wstring_get_value_989_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< wstring >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_wstring_get_class_type_991(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< wstring >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ParamValue< wstring >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_wstring_get_class_type_991_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_wstring_get_class_type_991_comment = NULL;
#endif

static PyObject *Dtool_ParamValue_std_wstring_value_Getter(PyObject *self, void *) {
  const ParamValue< std::wstring > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_std_wstring, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::wstring const &ParamValue< wstring >::get_value(void) const
  std::wstring const &return_value = (*(const ParamValue< std::wstring >*)local_this).get_value();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ParamValue_std_wstring_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< std::wstring > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_std_wstring, (void **)&local_this, "ParamValue_std::wstring.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< wstring >::set_value(std::wstring const &value)
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
  #else
  PyUnicodeObject *param1;
  #endif
  if (PyArg_Parse(arg, "U:set_value", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    (*local_this).set_value(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, unicode value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< wstring >::ParamValue(std::wstring const &value)
 */
static int Dtool_Init_ParamValue_std_wstring(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "value");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
    return -1;
  }
  // 1-inline ParamValue< wstring >::ParamValue(std::wstring const &value)
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param0;
  #else
  PyUnicodeObject *param0;
  #endif
  if (PyArg_Parse(arg, "U:ParamValue", &param0)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param0_len;
    wchar_t *param0_str = PyUnicode_AsWideCharString(param0, &param0_len);
#else
    Py_ssize_t param0_len = PyUnicode_GET_SIZE(param0);
    wchar_t *param0_str = (wchar_t *)alloca(sizeof(wchar_t) * (param0_len + 1));
    PyUnicode_AsWideChar(param0, param0_str, param0_len);
#endif
    ParamValue< std::wstring > *return_value = new ParamValue< std::wstring >(std::wstring(param0_str, param0_len));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param0_str);
#endif
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_std_wstring, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(unicode value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_std_wstring(PyObject *args, CPT(ParamValue< std::wstring >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_std_wstring, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< wstring >::ParamValue(std::wstring const &value)
    #if PY_VERSION_HEX >= 0x03020000
    PyObject *param0;
    #else
    PyUnicodeObject *param0;
    #endif
    if (PyArg_Parse(arg, "U:ParamValue", &param0)) {
#if PY_VERSION_HEX >= 0x03030000
      Py_ssize_t param0_len;
      wchar_t *param0_str = PyUnicode_AsWideCharString(param0, &param0_len);
#else
      Py_ssize_t param0_len = PyUnicode_GET_SIZE(param0);
      wchar_t *param0_str = (wchar_t *)alloca(sizeof(wchar_t) * (param0_len + 1));
      PyUnicode_AsWideChar(param0, param0_str, param0_len);
#endif
      ParamValue< std::wstring > *return_value = new ParamValue< std::wstring >(std::wstring(param0_str, param0_len));
#if PY_VERSION_HEX >= 0x03030000
      PyMem_Free(param0_str);
#endif
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_ParamValue_std_wstring(PyObject *args, PT(ParamValue< std::wstring >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_std_wstring, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< wstring >::ParamValue(std::wstring const &value)
    #if PY_VERSION_HEX >= 0x03020000
    PyObject *param0;
    #else
    PyUnicodeObject *param0;
    #endif
    if (PyArg_Parse(arg, "U:ParamValue", &param0)) {
#if PY_VERSION_HEX >= 0x03030000
      Py_ssize_t param0_len;
      wchar_t *param0_str = PyUnicode_AsWideCharString(param0, &param0_len);
#else
      Py_ssize_t param0_len = PyUnicode_GET_SIZE(param0);
      wchar_t *param0_str = (wchar_t *)alloca(sizeof(wchar_t) * (param0_len + 1));
      PyUnicode_AsWideChar(param0, param0_str, param0_len);
#endif
      ParamValue< std::wstring > *return_value = new ParamValue< std::wstring >(std::wstring(param0_str, param0_len));
#if PY_VERSION_HEX >= 0x03030000
      PyMem_Free(param0_str);
#endif
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_std_wstring(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParamValue_std_wstring) {
    printf("ParamValue_std_wstring ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParamValue< std::wstring > *local_this = (ParamValue< std::wstring > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParamValue_std_wstring) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParamValue_std_wstring(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParamValue_std_wstring) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< std::wstring >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< std::wstring >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< std::wstring >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< std::wstring >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< std::wstring >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParamValue< LVecBase2d >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LVecBase2d >::set_value(LVecBase2d const &value)
 */
static PyObject *Dtool_ParamValue_LVecBase2d_set_value_995(PyObject *self, PyObject *arg) {
  ParamValue< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase2d, (void **)&local_this, "ParamValue_LVecBase2d.set_value")) {
    return NULL;
  }
  // 1-inline void ParamValue< LVecBase2d >::set_value(LVecBase2d const &value)
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase2d");
  }
  (*local_this).set_value(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase2d value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase2d_set_value_995_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LVecBase2d value)\n";
#else
static const char *Dtool_ParamValue_LVecBase2d_set_value_995_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d const &ParamValue< LVecBase2d >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LVecBase2d_get_value_996(PyObject *self, PyObject *) {
  ParamValue< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2d const &ParamValue< LVecBase2d >::get_value(void) const
  LVecBase2d const *return_value = &((*(const ParamValue< LVecBase2d >*)local_this).get_value());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase2d_get_value_996_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LVecBase2d_get_value_996_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LVecBase2d >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LVecBase2d_get_class_type_998(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LVecBase2d >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ParamValue< LVecBase2d >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase2d_get_class_type_998_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LVecBase2d_get_class_type_998_comment = NULL;
#endif

static PyObject *Dtool_ParamValue_LVecBase2d_value_Getter(PyObject *self, void *) {
  const ParamValue< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2d const &ParamValue< LVecBase2d >::get_value(void) const
  LVecBase2d const *return_value = &((*(const ParamValue< LVecBase2d >*)local_this).get_value());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, true);
}

static int Dtool_ParamValue_LVecBase2d_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase2d, (void **)&local_this, "ParamValue_LVecBase2d.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LVecBase2d >::set_value(LVecBase2d const &value)
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase2d");
    return -1;
  }
  (*local_this).set_value(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase2d value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LVecBase2d >::ParamValue(LVecBase2d const &value)
 */
static int Dtool_Init_ParamValue_LVecBase2d(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "value");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
    return -1;
  }
  // 1-inline ParamValue< LVecBase2d >::ParamValue(LVecBase2d const &value)
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LVecBase2d");
    return -1;
  }
  ParamValue< LVecBase2d > *return_value = new ParamValue< LVecBase2d >(*arg_this);
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LVecBase2d, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LVecBase2d value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LVecBase2d(PyObject *args, CPT(ParamValue< LVecBase2d >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LVecBase2d, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase2d >::ParamValue(LVecBase2d const &value)
    LVecBase2d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2d, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LVecBase2d > *return_value = new ParamValue< LVecBase2d >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LVecBase2d(PyObject *args, PT(ParamValue< LVecBase2d >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LVecBase2d, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase2d >::ParamValue(LVecBase2d const &value)
    LVecBase2d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2d, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LVecBase2d > *return_value = new ParamValue< LVecBase2d >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LVecBase2d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParamValue_LVecBase2d) {
    printf("ParamValue_LVecBase2d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParamValue< LVecBase2d > *local_this = (ParamValue< LVecBase2d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParamValue_LVecBase2d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParamValue_LVecBase2d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParamValue_LVecBase2d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LVecBase2d >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LVecBase2d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LVecBase2d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LVecBase2d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LVecBase2d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParamValue< LVecBase2f >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LVecBase2f >::set_value(LVecBase2f const &value)
 */
static PyObject *Dtool_ParamValue_LVecBase2f_set_value_1002(PyObject *self, PyObject *arg) {
  ParamValue< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase2f, (void **)&local_this, "ParamValue_LVecBase2f.set_value")) {
    return NULL;
  }
  // 1-inline void ParamValue< LVecBase2f >::set_value(LVecBase2f const &value)
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase2f");
  }
  (*local_this).set_value(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase2f value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase2f_set_value_1002_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LVecBase2f value)\n";
#else
static const char *Dtool_ParamValue_LVecBase2f_set_value_1002_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2f const &ParamValue< LVecBase2f >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LVecBase2f_get_value_1003(PyObject *self, PyObject *) {
  ParamValue< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2f const &ParamValue< LVecBase2f >::get_value(void) const
  LVecBase2f const *return_value = &((*(const ParamValue< LVecBase2f >*)local_this).get_value());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase2f_get_value_1003_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LVecBase2f_get_value_1003_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LVecBase2f >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LVecBase2f_get_class_type_1005(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LVecBase2f >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ParamValue< LVecBase2f >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase2f_get_class_type_1005_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LVecBase2f_get_class_type_1005_comment = NULL;
#endif

static PyObject *Dtool_ParamValue_LVecBase2f_value_Getter(PyObject *self, void *) {
  const ParamValue< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2f const &ParamValue< LVecBase2f >::get_value(void) const
  LVecBase2f const *return_value = &((*(const ParamValue< LVecBase2f >*)local_this).get_value());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
}

static int Dtool_ParamValue_LVecBase2f_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase2f, (void **)&local_this, "ParamValue_LVecBase2f.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LVecBase2f >::set_value(LVecBase2f const &value)
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase2f");
    return -1;
  }
  (*local_this).set_value(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase2f value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LVecBase2f >::ParamValue(LVecBase2f const &value)
 */
static int Dtool_Init_ParamValue_LVecBase2f(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "value");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
    return -1;
  }
  // 1-inline ParamValue< LVecBase2f >::ParamValue(LVecBase2f const &value)
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LVecBase2f");
    return -1;
  }
  ParamValue< LVecBase2f > *return_value = new ParamValue< LVecBase2f >(*arg_this);
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LVecBase2f, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LVecBase2f value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LVecBase2f(PyObject *args, CPT(ParamValue< LVecBase2f >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LVecBase2f, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase2f >::ParamValue(LVecBase2f const &value)
    LVecBase2f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2f, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LVecBase2f > *return_value = new ParamValue< LVecBase2f >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LVecBase2f(PyObject *args, PT(ParamValue< LVecBase2f >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LVecBase2f, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase2f >::ParamValue(LVecBase2f const &value)
    LVecBase2f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2f, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LVecBase2f > *return_value = new ParamValue< LVecBase2f >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LVecBase2f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParamValue_LVecBase2f) {
    printf("ParamValue_LVecBase2f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParamValue< LVecBase2f > *local_this = (ParamValue< LVecBase2f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParamValue_LVecBase2f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParamValue_LVecBase2f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParamValue_LVecBase2f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LVecBase2f >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LVecBase2f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LVecBase2f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LVecBase2f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LVecBase2f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParamValue< LVecBase2i >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LVecBase2i >::set_value(LVecBase2i const &value)
 */
static PyObject *Dtool_ParamValue_LVecBase2i_set_value_1009(PyObject *self, PyObject *arg) {
  ParamValue< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase2i, (void **)&local_this, "ParamValue_LVecBase2i.set_value")) {
    return NULL;
  }
  // 1-inline void ParamValue< LVecBase2i >::set_value(LVecBase2i const &value)
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase2i");
  }
  (*local_this).set_value(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase2i value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase2i_set_value_1009_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LVecBase2i value)\n";
#else
static const char *Dtool_ParamValue_LVecBase2i_set_value_1009_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i const &ParamValue< LVecBase2i >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LVecBase2i_get_value_1010(PyObject *self, PyObject *) {
  ParamValue< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2i const &ParamValue< LVecBase2i >::get_value(void) const
  LVecBase2i const *return_value = &((*(const ParamValue< LVecBase2i >*)local_this).get_value());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase2i_get_value_1010_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LVecBase2i_get_value_1010_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LVecBase2i >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LVecBase2i_get_class_type_1012(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LVecBase2i >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ParamValue< LVecBase2i >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase2i_get_class_type_1012_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LVecBase2i_get_class_type_1012_comment = NULL;
#endif

static PyObject *Dtool_ParamValue_LVecBase2i_value_Getter(PyObject *self, void *) {
  const ParamValue< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2i const &ParamValue< LVecBase2i >::get_value(void) const
  LVecBase2i const *return_value = &((*(const ParamValue< LVecBase2i >*)local_this).get_value());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
}

static int Dtool_ParamValue_LVecBase2i_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase2i, (void **)&local_this, "ParamValue_LVecBase2i.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LVecBase2i >::set_value(LVecBase2i const &value)
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase2i");
    return -1;
  }
  (*local_this).set_value(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase2i value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LVecBase2i >::ParamValue(LVecBase2i const &value)
 */
static int Dtool_Init_ParamValue_LVecBase2i(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "value");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
    return -1;
  }
  // 1-inline ParamValue< LVecBase2i >::ParamValue(LVecBase2i const &value)
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LVecBase2i");
    return -1;
  }
  ParamValue< LVecBase2i > *return_value = new ParamValue< LVecBase2i >(*arg_this);
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LVecBase2i, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LVecBase2i value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LVecBase2i(PyObject *args, CPT(ParamValue< LVecBase2i >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LVecBase2i, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase2i >::ParamValue(LVecBase2i const &value)
    LVecBase2i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2i, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LVecBase2i > *return_value = new ParamValue< LVecBase2i >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LVecBase2i(PyObject *args, PT(ParamValue< LVecBase2i >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LVecBase2i, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase2i >::ParamValue(LVecBase2i const &value)
    LVecBase2i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2i, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LVecBase2i > *return_value = new ParamValue< LVecBase2i >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LVecBase2i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParamValue_LVecBase2i) {
    printf("ParamValue_LVecBase2i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParamValue< LVecBase2i > *local_this = (ParamValue< LVecBase2i > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParamValue_LVecBase2i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParamValue_LVecBase2i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParamValue_LVecBase2i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LVecBase2i >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LVecBase2i >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LVecBase2i >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LVecBase2i >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LVecBase2i >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParamValue< LVecBase3d >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LVecBase3d >::set_value(LVecBase3d const &value)
 */
static PyObject *Dtool_ParamValue_LVecBase3d_set_value_1016(PyObject *self, PyObject *arg) {
  ParamValue< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase3d, (void **)&local_this, "ParamValue_LVecBase3d.set_value")) {
    return NULL;
  }
  // 1-inline void ParamValue< LVecBase3d >::set_value(LVecBase3d const &value)
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase3d");
  }
  (*local_this).set_value(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase3d value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase3d_set_value_1016_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LVecBase3d value)\n";
#else
static const char *Dtool_ParamValue_LVecBase3d_set_value_1016_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d const &ParamValue< LVecBase3d >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LVecBase3d_get_value_1017(PyObject *self, PyObject *) {
  ParamValue< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d const &ParamValue< LVecBase3d >::get_value(void) const
  LVecBase3d const *return_value = &((*(const ParamValue< LVecBase3d >*)local_this).get_value());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase3d_get_value_1017_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LVecBase3d_get_value_1017_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LVecBase3d >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LVecBase3d_get_class_type_1019(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LVecBase3d >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ParamValue< LVecBase3d >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase3d_get_class_type_1019_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LVecBase3d_get_class_type_1019_comment = NULL;
#endif

static PyObject *Dtool_ParamValue_LVecBase3d_value_Getter(PyObject *self, void *) {
  const ParamValue< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase3d const &ParamValue< LVecBase3d >::get_value(void) const
  LVecBase3d const *return_value = &((*(const ParamValue< LVecBase3d >*)local_this).get_value());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
}

static int Dtool_ParamValue_LVecBase3d_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase3d, (void **)&local_this, "ParamValue_LVecBase3d.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LVecBase3d >::set_value(LVecBase3d const &value)
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase3d");
    return -1;
  }
  (*local_this).set_value(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase3d value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LVecBase3d >::ParamValue(LVecBase3d const &value)
 */
static int Dtool_Init_ParamValue_LVecBase3d(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "value");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
    return -1;
  }
  // 1-inline ParamValue< LVecBase3d >::ParamValue(LVecBase3d const &value)
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LVecBase3d");
    return -1;
  }
  ParamValue< LVecBase3d > *return_value = new ParamValue< LVecBase3d >(*arg_this);
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LVecBase3d, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LVecBase3d value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LVecBase3d(PyObject *args, CPT(ParamValue< LVecBase3d >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LVecBase3d, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase3d >::ParamValue(LVecBase3d const &value)
    LVecBase3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LVecBase3d > *return_value = new ParamValue< LVecBase3d >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LVecBase3d(PyObject *args, PT(ParamValue< LVecBase3d >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LVecBase3d, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase3d >::ParamValue(LVecBase3d const &value)
    LVecBase3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LVecBase3d > *return_value = new ParamValue< LVecBase3d >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LVecBase3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParamValue_LVecBase3d) {
    printf("ParamValue_LVecBase3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParamValue< LVecBase3d > *local_this = (ParamValue< LVecBase3d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParamValue_LVecBase3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParamValue_LVecBase3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParamValue_LVecBase3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LVecBase3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LVecBase3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LVecBase3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LVecBase3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LVecBase3d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParamValue< LVecBase3f >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LVecBase3f >::set_value(LVecBase3f const &value)
 */
static PyObject *Dtool_ParamValue_LVecBase3f_set_value_1023(PyObject *self, PyObject *arg) {
  ParamValue< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase3f, (void **)&local_this, "ParamValue_LVecBase3f.set_value")) {
    return NULL;
  }
  // 1-inline void ParamValue< LVecBase3f >::set_value(LVecBase3f const &value)
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase3f");
  }
  (*local_this).set_value(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase3f value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase3f_set_value_1023_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LVecBase3f value)\n";
#else
static const char *Dtool_ParamValue_LVecBase3f_set_value_1023_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f const &ParamValue< LVecBase3f >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LVecBase3f_get_value_1024(PyObject *self, PyObject *) {
  ParamValue< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f const &ParamValue< LVecBase3f >::get_value(void) const
  LVecBase3f const *return_value = &((*(const ParamValue< LVecBase3f >*)local_this).get_value());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase3f_get_value_1024_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LVecBase3f_get_value_1024_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LVecBase3f >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LVecBase3f_get_class_type_1026(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LVecBase3f >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ParamValue< LVecBase3f >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase3f_get_class_type_1026_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LVecBase3f_get_class_type_1026_comment = NULL;
#endif

static PyObject *Dtool_ParamValue_LVecBase3f_value_Getter(PyObject *self, void *) {
  const ParamValue< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase3f const &ParamValue< LVecBase3f >::get_value(void) const
  LVecBase3f const *return_value = &((*(const ParamValue< LVecBase3f >*)local_this).get_value());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

static int Dtool_ParamValue_LVecBase3f_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase3f, (void **)&local_this, "ParamValue_LVecBase3f.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LVecBase3f >::set_value(LVecBase3f const &value)
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase3f");
    return -1;
  }
  (*local_this).set_value(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase3f value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LVecBase3f >::ParamValue(LVecBase3f const &value)
 */
static int Dtool_Init_ParamValue_LVecBase3f(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "value");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
    return -1;
  }
  // 1-inline ParamValue< LVecBase3f >::ParamValue(LVecBase3f const &value)
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LVecBase3f");
    return -1;
  }
  ParamValue< LVecBase3f > *return_value = new ParamValue< LVecBase3f >(*arg_this);
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LVecBase3f, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LVecBase3f value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LVecBase3f(PyObject *args, CPT(ParamValue< LVecBase3f >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LVecBase3f, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase3f >::ParamValue(LVecBase3f const &value)
    LVecBase3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LVecBase3f > *return_value = new ParamValue< LVecBase3f >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LVecBase3f(PyObject *args, PT(ParamValue< LVecBase3f >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LVecBase3f, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase3f >::ParamValue(LVecBase3f const &value)
    LVecBase3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LVecBase3f > *return_value = new ParamValue< LVecBase3f >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LVecBase3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParamValue_LVecBase3f) {
    printf("ParamValue_LVecBase3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParamValue< LVecBase3f > *local_this = (ParamValue< LVecBase3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParamValue_LVecBase3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParamValue_LVecBase3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParamValue_LVecBase3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LVecBase3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LVecBase3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LVecBase3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LVecBase3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LVecBase3f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParamValue< LVecBase3i >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LVecBase3i >::set_value(LVecBase3i const &value)
 */
static PyObject *Dtool_ParamValue_LVecBase3i_set_value_1030(PyObject *self, PyObject *arg) {
  ParamValue< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase3i, (void **)&local_this, "ParamValue_LVecBase3i.set_value")) {
    return NULL;
  }
  // 1-inline void ParamValue< LVecBase3i >::set_value(LVecBase3i const &value)
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase3i");
  }
  (*local_this).set_value(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase3i value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase3i_set_value_1030_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LVecBase3i value)\n";
#else
static const char *Dtool_ParamValue_LVecBase3i_set_value_1030_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3i const &ParamValue< LVecBase3i >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LVecBase3i_get_value_1031(PyObject *self, PyObject *) {
  ParamValue< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3i const &ParamValue< LVecBase3i >::get_value(void) const
  LVecBase3i const *return_value = &((*(const ParamValue< LVecBase3i >*)local_this).get_value());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase3i_get_value_1031_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LVecBase3i_get_value_1031_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LVecBase3i >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LVecBase3i_get_class_type_1033(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LVecBase3i >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ParamValue< LVecBase3i >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase3i_get_class_type_1033_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LVecBase3i_get_class_type_1033_comment = NULL;
#endif

static PyObject *Dtool_ParamValue_LVecBase3i_value_Getter(PyObject *self, void *) {
  const ParamValue< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase3i const &ParamValue< LVecBase3i >::get_value(void) const
  LVecBase3i const *return_value = &((*(const ParamValue< LVecBase3i >*)local_this).get_value());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
}

static int Dtool_ParamValue_LVecBase3i_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase3i, (void **)&local_this, "ParamValue_LVecBase3i.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LVecBase3i >::set_value(LVecBase3i const &value)
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase3i");
    return -1;
  }
  (*local_this).set_value(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase3i value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LVecBase3i >::ParamValue(LVecBase3i const &value)
 */
static int Dtool_Init_ParamValue_LVecBase3i(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "value");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
    return -1;
  }
  // 1-inline ParamValue< LVecBase3i >::ParamValue(LVecBase3i const &value)
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LVecBase3i");
    return -1;
  }
  ParamValue< LVecBase3i > *return_value = new ParamValue< LVecBase3i >(*arg_this);
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LVecBase3i, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LVecBase3i value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LVecBase3i(PyObject *args, CPT(ParamValue< LVecBase3i >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LVecBase3i, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase3i >::ParamValue(LVecBase3i const &value)
    LVecBase3i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3i, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LVecBase3i > *return_value = new ParamValue< LVecBase3i >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LVecBase3i(PyObject *args, PT(ParamValue< LVecBase3i >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LVecBase3i, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase3i >::ParamValue(LVecBase3i const &value)
    LVecBase3i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3i, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LVecBase3i > *return_value = new ParamValue< LVecBase3i >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LVecBase3i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParamValue_LVecBase3i) {
    printf("ParamValue_LVecBase3i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParamValue< LVecBase3i > *local_this = (ParamValue< LVecBase3i > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParamValue_LVecBase3i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParamValue_LVecBase3i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParamValue_LVecBase3i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LVecBase3i >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LVecBase3i >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LVecBase3i >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LVecBase3i >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LVecBase3i >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParamValue< LVecBase4d >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LVecBase4d >::set_value(LVecBase4d const &value)
 */
static PyObject *Dtool_ParamValue_LVecBase4d_set_value_1037(PyObject *self, PyObject *arg) {
  ParamValue< LVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase4d, (void **)&local_this, "ParamValue_LVecBase4d.set_value")) {
    return NULL;
  }
  // 1-inline void ParamValue< LVecBase4d >::set_value(LVecBase4d const &value)
  LVecBase4d arg_local;
  LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase4d");
  }
  (*local_this).set_value(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase4d value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase4d_set_value_1037_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LVecBase4d value)\n";
#else
static const char *Dtool_ParamValue_LVecBase4d_set_value_1037_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4d const &ParamValue< LVecBase4d >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LVecBase4d_get_value_1038(PyObject *self, PyObject *) {
  ParamValue< LVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4d const &ParamValue< LVecBase4d >::get_value(void) const
  LVecBase4d const *return_value = &((*(const ParamValue< LVecBase4d >*)local_this).get_value());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase4d_get_value_1038_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LVecBase4d_get_value_1038_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LVecBase4d >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LVecBase4d_get_class_type_1040(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LVecBase4d >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ParamValue< LVecBase4d >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase4d_get_class_type_1040_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LVecBase4d_get_class_type_1040_comment = NULL;
#endif

static PyObject *Dtool_ParamValue_LVecBase4d_value_Getter(PyObject *self, void *) {
  const ParamValue< LVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase4d const &ParamValue< LVecBase4d >::get_value(void) const
  LVecBase4d const *return_value = &((*(const ParamValue< LVecBase4d >*)local_this).get_value());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, false, true);
}

static int Dtool_ParamValue_LVecBase4d_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase4d, (void **)&local_this, "ParamValue_LVecBase4d.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LVecBase4d >::set_value(LVecBase4d const &value)
  LVecBase4d arg_local;
  LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase4d");
    return -1;
  }
  (*local_this).set_value(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase4d value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LVecBase4d >::ParamValue(LVecBase4d const &value)
 */
static int Dtool_Init_ParamValue_LVecBase4d(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "value");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
    return -1;
  }
  // 1-inline ParamValue< LVecBase4d >::ParamValue(LVecBase4d const &value)
  LVecBase4d arg_local;
  LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LVecBase4d");
    return -1;
  }
  ParamValue< LVecBase4d > *return_value = new ParamValue< LVecBase4d >(*arg_this);
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LVecBase4d, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LVecBase4d value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LVecBase4d(PyObject *args, CPT(ParamValue< LVecBase4d >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LVecBase4d, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase4d >::ParamValue(LVecBase4d const &value)
    LVecBase4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4d, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LVecBase4d > *return_value = new ParamValue< LVecBase4d >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LVecBase4d(PyObject *args, PT(ParamValue< LVecBase4d >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LVecBase4d, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase4d >::ParamValue(LVecBase4d const &value)
    LVecBase4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4d, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LVecBase4d > *return_value = new ParamValue< LVecBase4d >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LVecBase4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParamValue_LVecBase4d) {
    printf("ParamValue_LVecBase4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParamValue< LVecBase4d > *local_this = (ParamValue< LVecBase4d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParamValue_LVecBase4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParamValue_LVecBase4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParamValue_LVecBase4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LVecBase4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LVecBase4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LVecBase4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LVecBase4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LVecBase4d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParamValue< LVecBase4f >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LVecBase4f >::set_value(LVecBase4f const &value)
 */
static PyObject *Dtool_ParamValue_LVecBase4f_set_value_1044(PyObject *self, PyObject *arg) {
  ParamValue< LVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase4f, (void **)&local_this, "ParamValue_LVecBase4f.set_value")) {
    return NULL;
  }
  // 1-inline void ParamValue< LVecBase4f >::set_value(LVecBase4f const &value)
  LVecBase4f arg_local;
  LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase4f");
  }
  (*local_this).set_value(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase4f value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase4f_set_value_1044_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LVecBase4f value)\n";
#else
static const char *Dtool_ParamValue_LVecBase4f_set_value_1044_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4f const &ParamValue< LVecBase4f >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LVecBase4f_get_value_1045(PyObject *self, PyObject *) {
  ParamValue< LVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4f const &ParamValue< LVecBase4f >::get_value(void) const
  LVecBase4f const *return_value = &((*(const ParamValue< LVecBase4f >*)local_this).get_value());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase4f_get_value_1045_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LVecBase4f_get_value_1045_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LVecBase4f >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LVecBase4f_get_class_type_1047(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LVecBase4f >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ParamValue< LVecBase4f >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase4f_get_class_type_1047_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LVecBase4f_get_class_type_1047_comment = NULL;
#endif

static PyObject *Dtool_ParamValue_LVecBase4f_value_Getter(PyObject *self, void *) {
  const ParamValue< LVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase4f const &ParamValue< LVecBase4f >::get_value(void) const
  LVecBase4f const *return_value = &((*(const ParamValue< LVecBase4f >*)local_this).get_value());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_ParamValue_LVecBase4f_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase4f, (void **)&local_this, "ParamValue_LVecBase4f.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LVecBase4f >::set_value(LVecBase4f const &value)
  LVecBase4f arg_local;
  LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase4f");
    return -1;
  }
  (*local_this).set_value(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase4f value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LVecBase4f >::ParamValue(LVecBase4f const &value)
 */
static int Dtool_Init_ParamValue_LVecBase4f(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "value");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
    return -1;
  }
  // 1-inline ParamValue< LVecBase4f >::ParamValue(LVecBase4f const &value)
  LVecBase4f arg_local;
  LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LVecBase4f");
    return -1;
  }
  ParamValue< LVecBase4f > *return_value = new ParamValue< LVecBase4f >(*arg_this);
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LVecBase4f, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LVecBase4f value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LVecBase4f(PyObject *args, CPT(ParamValue< LVecBase4f >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LVecBase4f, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase4f >::ParamValue(LVecBase4f const &value)
    LVecBase4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LVecBase4f > *return_value = new ParamValue< LVecBase4f >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LVecBase4f(PyObject *args, PT(ParamValue< LVecBase4f >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LVecBase4f, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase4f >::ParamValue(LVecBase4f const &value)
    LVecBase4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LVecBase4f > *return_value = new ParamValue< LVecBase4f >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LVecBase4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParamValue_LVecBase4f) {
    printf("ParamValue_LVecBase4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParamValue< LVecBase4f > *local_this = (ParamValue< LVecBase4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParamValue_LVecBase4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParamValue_LVecBase4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParamValue_LVecBase4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LVecBase4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LVecBase4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LVecBase4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LVecBase4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LVecBase4f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParamValue< LVecBase4i >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LVecBase4i >::set_value(LVecBase4i const &value)
 */
static PyObject *Dtool_ParamValue_LVecBase4i_set_value_1051(PyObject *self, PyObject *arg) {
  ParamValue< LVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase4i, (void **)&local_this, "ParamValue_LVecBase4i.set_value")) {
    return NULL;
  }
  // 1-inline void ParamValue< LVecBase4i >::set_value(LVecBase4i const &value)
  LVecBase4i arg_local;
  LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase4i");
  }
  (*local_this).set_value(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase4i value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase4i_set_value_1051_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LVecBase4i value)\n";
#else
static const char *Dtool_ParamValue_LVecBase4i_set_value_1051_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4i const &ParamValue< LVecBase4i >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LVecBase4i_get_value_1052(PyObject *self, PyObject *) {
  ParamValue< LVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4i const &ParamValue< LVecBase4i >::get_value(void) const
  LVecBase4i const *return_value = &((*(const ParamValue< LVecBase4i >*)local_this).get_value());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase4i_get_value_1052_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LVecBase4i_get_value_1052_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LVecBase4i >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LVecBase4i_get_class_type_1054(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LVecBase4i >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ParamValue< LVecBase4i >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase4i_get_class_type_1054_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LVecBase4i_get_class_type_1054_comment = NULL;
#endif

static PyObject *Dtool_ParamValue_LVecBase4i_value_Getter(PyObject *self, void *) {
  const ParamValue< LVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase4i const &ParamValue< LVecBase4i >::get_value(void) const
  LVecBase4i const *return_value = &((*(const ParamValue< LVecBase4i >*)local_this).get_value());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, false, true);
}

static int Dtool_ParamValue_LVecBase4i_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase4i, (void **)&local_this, "ParamValue_LVecBase4i.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LVecBase4i >::set_value(LVecBase4i const &value)
  LVecBase4i arg_local;
  LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase4i");
    return -1;
  }
  (*local_this).set_value(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase4i value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LVecBase4i >::ParamValue(LVecBase4i const &value)
 */
static int Dtool_Init_ParamValue_LVecBase4i(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "value");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
    return -1;
  }
  // 1-inline ParamValue< LVecBase4i >::ParamValue(LVecBase4i const &value)
  LVecBase4i arg_local;
  LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LVecBase4i");
    return -1;
  }
  ParamValue< LVecBase4i > *return_value = new ParamValue< LVecBase4i >(*arg_this);
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LVecBase4i, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LVecBase4i value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LVecBase4i(PyObject *args, CPT(ParamValue< LVecBase4i >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LVecBase4i, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase4i >::ParamValue(LVecBase4i const &value)
    LVecBase4i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4i, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LVecBase4i > *return_value = new ParamValue< LVecBase4i >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LVecBase4i(PyObject *args, PT(ParamValue< LVecBase4i >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LVecBase4i, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase4i >::ParamValue(LVecBase4i const &value)
    LVecBase4i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4i, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LVecBase4i > *return_value = new ParamValue< LVecBase4i >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LVecBase4i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParamValue_LVecBase4i) {
    printf("ParamValue_LVecBase4i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParamValue< LVecBase4i > *local_this = (ParamValue< LVecBase4i > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParamValue_LVecBase4i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParamValue_LVecBase4i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParamValue_LVecBase4i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LVecBase4i >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LVecBase4i >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LVecBase4i >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LVecBase4i >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LVecBase4i >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParamValue< LMatrix3d >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LMatrix3d >::set_value(LMatrix3d const &value)
 */
static PyObject *Dtool_ParamValue_LMatrix3d_set_value_1058(PyObject *self, PyObject *arg) {
  ParamValue< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LMatrix3d, (void **)&local_this, "ParamValue_LMatrix3d.set_value")) {
    return NULL;
  }
  // 1-inline void ParamValue< LMatrix3d >::set_value(LMatrix3d const &value)
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LMatrix3d");
  }
  (*local_this).set_value(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LMatrix3d value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix3d_set_value_1058_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LMatrix3d value)\n";
#else
static const char *Dtool_ParamValue_LMatrix3d_set_value_1058_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3d const &ParamValue< LMatrix3d >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LMatrix3d_get_value_1059(PyObject *self, PyObject *) {
  ParamValue< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix3d const &ParamValue< LMatrix3d >::get_value(void) const
  LMatrix3d const *return_value = &((*(const ParamValue< LMatrix3d >*)local_this).get_value());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix3d_get_value_1059_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LMatrix3d_get_value_1059_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LMatrix3d >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LMatrix3d_get_class_type_1061(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LMatrix3d >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ParamValue< LMatrix3d >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix3d_get_class_type_1061_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LMatrix3d_get_class_type_1061_comment = NULL;
#endif

static PyObject *Dtool_ParamValue_LMatrix3d_value_Getter(PyObject *self, void *) {
  const ParamValue< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LMatrix3d const &ParamValue< LMatrix3d >::get_value(void) const
  LMatrix3d const *return_value = &((*(const ParamValue< LMatrix3d >*)local_this).get_value());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, false, true);
}

static int Dtool_ParamValue_LMatrix3d_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LMatrix3d, (void **)&local_this, "ParamValue_LMatrix3d.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LMatrix3d >::set_value(LMatrix3d const &value)
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LMatrix3d");
    return -1;
  }
  (*local_this).set_value(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LMatrix3d value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LMatrix3d >::ParamValue(LMatrix3d const &value)
 */
static int Dtool_Init_ParamValue_LMatrix3d(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "value");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
    return -1;
  }
  // 1-inline ParamValue< LMatrix3d >::ParamValue(LMatrix3d const &value)
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LMatrix3d");
    return -1;
  }
  ParamValue< LMatrix3d > *return_value = new ParamValue< LMatrix3d >(*arg_this);
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LMatrix3d, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LMatrix3d value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LMatrix3d(PyObject *args, CPT(ParamValue< LMatrix3d >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LMatrix3d, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LMatrix3d >::ParamValue(LMatrix3d const &value)
    LMatrix3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3d, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LMatrix3d > *return_value = new ParamValue< LMatrix3d >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LMatrix3d(PyObject *args, PT(ParamValue< LMatrix3d >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LMatrix3d, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LMatrix3d >::ParamValue(LMatrix3d const &value)
    LMatrix3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3d, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LMatrix3d > *return_value = new ParamValue< LMatrix3d >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LMatrix3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParamValue_LMatrix3d) {
    printf("ParamValue_LMatrix3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParamValue< LMatrix3d > *local_this = (ParamValue< LMatrix3d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParamValue_LMatrix3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParamValue_LMatrix3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParamValue_LMatrix3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LMatrix3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LMatrix3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LMatrix3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LMatrix3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LMatrix3d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParamValue< LMatrix3f >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LMatrix3f >::set_value(LMatrix3f const &value)
 */
static PyObject *Dtool_ParamValue_LMatrix3f_set_value_1065(PyObject *self, PyObject *arg) {
  ParamValue< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LMatrix3f, (void **)&local_this, "ParamValue_LMatrix3f.set_value")) {
    return NULL;
  }
  // 1-inline void ParamValue< LMatrix3f >::set_value(LMatrix3f const &value)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LMatrix3f");
  }
  (*local_this).set_value(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LMatrix3f value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix3f_set_value_1065_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LMatrix3f value)\n";
#else
static const char *Dtool_ParamValue_LMatrix3f_set_value_1065_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3f const &ParamValue< LMatrix3f >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LMatrix3f_get_value_1066(PyObject *self, PyObject *) {
  ParamValue< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix3f const &ParamValue< LMatrix3f >::get_value(void) const
  LMatrix3f const *return_value = &((*(const ParamValue< LMatrix3f >*)local_this).get_value());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix3f_get_value_1066_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LMatrix3f_get_value_1066_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LMatrix3f >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LMatrix3f_get_class_type_1068(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LMatrix3f >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ParamValue< LMatrix3f >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix3f_get_class_type_1068_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LMatrix3f_get_class_type_1068_comment = NULL;
#endif

static PyObject *Dtool_ParamValue_LMatrix3f_value_Getter(PyObject *self, void *) {
  const ParamValue< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LMatrix3f const &ParamValue< LMatrix3f >::get_value(void) const
  LMatrix3f const *return_value = &((*(const ParamValue< LMatrix3f >*)local_this).get_value());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, false, true);
}

static int Dtool_ParamValue_LMatrix3f_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LMatrix3f, (void **)&local_this, "ParamValue_LMatrix3f.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LMatrix3f >::set_value(LMatrix3f const &value)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LMatrix3f");
    return -1;
  }
  (*local_this).set_value(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LMatrix3f value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LMatrix3f >::ParamValue(LMatrix3f const &value)
 */
static int Dtool_Init_ParamValue_LMatrix3f(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "value");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
    return -1;
  }
  // 1-inline ParamValue< LMatrix3f >::ParamValue(LMatrix3f const &value)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LMatrix3f");
    return -1;
  }
  ParamValue< LMatrix3f > *return_value = new ParamValue< LMatrix3f >(*arg_this);
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LMatrix3f, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LMatrix3f value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LMatrix3f(PyObject *args, CPT(ParamValue< LMatrix3f >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LMatrix3f, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LMatrix3f >::ParamValue(LMatrix3f const &value)
    LMatrix3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3f, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LMatrix3f > *return_value = new ParamValue< LMatrix3f >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LMatrix3f(PyObject *args, PT(ParamValue< LMatrix3f >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LMatrix3f, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LMatrix3f >::ParamValue(LMatrix3f const &value)
    LMatrix3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3f, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LMatrix3f > *return_value = new ParamValue< LMatrix3f >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LMatrix3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParamValue_LMatrix3f) {
    printf("ParamValue_LMatrix3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParamValue< LMatrix3f > *local_this = (ParamValue< LMatrix3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParamValue_LMatrix3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParamValue_LMatrix3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParamValue_LMatrix3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LMatrix3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LMatrix3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LMatrix3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LMatrix3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LMatrix3f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParamValue< LMatrix4d >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LMatrix4d >::set_value(LMatrix4d const &value)
 */
static PyObject *Dtool_ParamValue_LMatrix4d_set_value_1072(PyObject *self, PyObject *arg) {
  ParamValue< LMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LMatrix4d, (void **)&local_this, "ParamValue_LMatrix4d.set_value")) {
    return NULL;
  }
  // 1-inline void ParamValue< LMatrix4d >::set_value(LMatrix4d const &value)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LMatrix4d");
  }
  (*local_this).set_value(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LMatrix4d value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix4d_set_value_1072_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LMatrix4d value)\n";
#else
static const char *Dtool_ParamValue_LMatrix4d_set_value_1072_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const &ParamValue< LMatrix4d >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LMatrix4d_get_value_1073(PyObject *self, PyObject *) {
  ParamValue< LMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4d const &ParamValue< LMatrix4d >::get_value(void) const
  LMatrix4d const *return_value = &((*(const ParamValue< LMatrix4d >*)local_this).get_value());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix4d_get_value_1073_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LMatrix4d_get_value_1073_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LMatrix4d >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LMatrix4d_get_class_type_1075(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LMatrix4d >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ParamValue< LMatrix4d >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix4d_get_class_type_1075_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LMatrix4d_get_class_type_1075_comment = NULL;
#endif

static PyObject *Dtool_ParamValue_LMatrix4d_value_Getter(PyObject *self, void *) {
  const ParamValue< LMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LMatrix4d const &ParamValue< LMatrix4d >::get_value(void) const
  LMatrix4d const *return_value = &((*(const ParamValue< LMatrix4d >*)local_this).get_value());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

static int Dtool_ParamValue_LMatrix4d_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LMatrix4d, (void **)&local_this, "ParamValue_LMatrix4d.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LMatrix4d >::set_value(LMatrix4d const &value)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LMatrix4d");
    return -1;
  }
  (*local_this).set_value(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LMatrix4d value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LMatrix4d >::ParamValue(LMatrix4d const &value)
 */
static int Dtool_Init_ParamValue_LMatrix4d(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "value");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
    return -1;
  }
  // 1-inline ParamValue< LMatrix4d >::ParamValue(LMatrix4d const &value)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LMatrix4d");
    return -1;
  }
  ParamValue< LMatrix4d > *return_value = new ParamValue< LMatrix4d >(*arg_this);
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LMatrix4d, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LMatrix4d value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LMatrix4d(PyObject *args, CPT(ParamValue< LMatrix4d >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LMatrix4d, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LMatrix4d >::ParamValue(LMatrix4d const &value)
    LMatrix4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4d, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LMatrix4d > *return_value = new ParamValue< LMatrix4d >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LMatrix4d(PyObject *args, PT(ParamValue< LMatrix4d >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LMatrix4d, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LMatrix4d >::ParamValue(LMatrix4d const &value)
    LMatrix4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4d, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LMatrix4d > *return_value = new ParamValue< LMatrix4d >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LMatrix4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParamValue_LMatrix4d) {
    printf("ParamValue_LMatrix4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParamValue< LMatrix4d > *local_this = (ParamValue< LMatrix4d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParamValue_LMatrix4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParamValue_LMatrix4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParamValue_LMatrix4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LMatrix4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LMatrix4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LMatrix4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LMatrix4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LMatrix4d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParamValue< LMatrix4f >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LMatrix4f >::set_value(LMatrix4f const &value)
 */
static PyObject *Dtool_ParamValue_LMatrix4f_set_value_1079(PyObject *self, PyObject *arg) {
  ParamValue< LMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LMatrix4f, (void **)&local_this, "ParamValue_LMatrix4f.set_value")) {
    return NULL;
  }
  // 1-inline void ParamValue< LMatrix4f >::set_value(LMatrix4f const &value)
  LMatrix4f arg_local;
  LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LMatrix4f");
  }
  (*local_this).set_value(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LMatrix4f value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix4f_set_value_1079_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LMatrix4f value)\n";
#else
static const char *Dtool_ParamValue_LMatrix4f_set_value_1079_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4f const &ParamValue< LMatrix4f >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LMatrix4f_get_value_1080(PyObject *self, PyObject *) {
  ParamValue< LMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4f const &ParamValue< LMatrix4f >::get_value(void) const
  LMatrix4f const *return_value = &((*(const ParamValue< LMatrix4f >*)local_this).get_value());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix4f_get_value_1080_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LMatrix4f_get_value_1080_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LMatrix4f >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LMatrix4f_get_class_type_1082(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LMatrix4f >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ParamValue< LMatrix4f >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix4f_get_class_type_1082_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LMatrix4f_get_class_type_1082_comment = NULL;
#endif

static PyObject *Dtool_ParamValue_LMatrix4f_value_Getter(PyObject *self, void *) {
  const ParamValue< LMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LMatrix4f const &ParamValue< LMatrix4f >::get_value(void) const
  LMatrix4f const *return_value = &((*(const ParamValue< LMatrix4f >*)local_this).get_value());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

static int Dtool_ParamValue_LMatrix4f_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LMatrix4f, (void **)&local_this, "ParamValue_LMatrix4f.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LMatrix4f >::set_value(LMatrix4f const &value)
  LMatrix4f arg_local;
  LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LMatrix4f");
    return -1;
  }
  (*local_this).set_value(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LMatrix4f value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LMatrix4f >::ParamValue(LMatrix4f const &value)
 */
static int Dtool_Init_ParamValue_LMatrix4f(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "value");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
    return -1;
  }
  // 1-inline ParamValue< LMatrix4f >::ParamValue(LMatrix4f const &value)
  LMatrix4f arg_local;
  LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LMatrix4f");
    return -1;
  }
  ParamValue< LMatrix4f > *return_value = new ParamValue< LMatrix4f >(*arg_this);
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LMatrix4f, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LMatrix4f value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LMatrix4f(PyObject *args, CPT(ParamValue< LMatrix4f >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LMatrix4f, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LMatrix4f >::ParamValue(LMatrix4f const &value)
    LMatrix4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4f, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LMatrix4f > *return_value = new ParamValue< LMatrix4f >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LMatrix4f(PyObject *args, PT(ParamValue< LMatrix4f >) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParamValue_LMatrix4f, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LMatrix4f >::ParamValue(LMatrix4f const &value)
    LMatrix4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4f, (void **)&arg_this);
    if (arg_this != NULL) {
      ParamValue< LMatrix4f > *return_value = new ParamValue< LMatrix4f >(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LMatrix4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParamValue_LMatrix4f) {
    printf("ParamValue_LMatrix4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParamValue< LMatrix4f > *local_this = (ParamValue< LMatrix4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParamValue_LMatrix4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParamValue_LMatrix4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParamValue_LMatrix4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LMatrix4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LMatrix4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LMatrix4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LMatrix4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LMatrix4f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class WritableConfigurable
 */
/**
 * Python function wrapper for:
 * static TypeHandle WritableConfigurable::get_class_type(void)
 */
static PyObject *Dtool_WritableConfigurable_get_class_type_1090(PyObject *, PyObject *) {
  // 1-static TypeHandle WritableConfigurable::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(WritableConfigurable::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_WritableConfigurable_get_class_type_1090_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_WritableConfigurable_get_class_type_1090_comment = NULL;
#endif

static int Dtool_Init_WritableConfigurable(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_WritableConfigurable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_WritableConfigurable) {
    printf("WritableConfigurable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  WritableConfigurable *local_this = (WritableConfigurable *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_WritableConfigurable) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_WritableConfigurable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_WritableConfigurable) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (WritableConfigurable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (WritableConfigurable*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class UniqueIdAllocator
 */
/**
 * Python function wrapper for:
 * uint32_t UniqueIdAllocator::allocate(void)
 */
static PyObject *Dtool_UniqueIdAllocator_allocate_1095(PyObject *self, PyObject *) {
  UniqueIdAllocator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UniqueIdAllocator, (void **)&local_this, "UniqueIdAllocator.allocate")) {
    return NULL;
  }
  // 1-uint32_t UniqueIdAllocator::allocate(void)
  uint32_t return_value = (*local_this).allocate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UniqueIdAllocator_allocate_1095_comment =
  "C++ Interface:\n"
  "allocate(const UniqueIdAllocator self)\n"
  "\n"
  "/**\n"
  " * Returns an id between _min and _max (that were passed to the constructor).\n"
  " * IndexEnd is returned if no ids are available.\n"
  " */";
#else
static const char *Dtool_UniqueIdAllocator_allocate_1095_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void UniqueIdAllocator::initial_reserve_id(uint32_t id)
 */
static PyObject *Dtool_UniqueIdAllocator_initial_reserve_id_1096(PyObject *self, PyObject *arg) {
  UniqueIdAllocator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UniqueIdAllocator, (void **)&local_this, "UniqueIdAllocator.initial_reserve_id")) {
    return NULL;
  }
  // 1-void UniqueIdAllocator::initial_reserve_id(uint32_t id)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    (*local_this).initial_reserve_id((uint32_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "initial_reserve_id(const UniqueIdAllocator self, int id)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UniqueIdAllocator_initial_reserve_id_1096_comment =
  "C++ Interface:\n"
  "initial_reserve_id(const UniqueIdAllocator self, int id)\n"
  "\n"
  "/**\n"
  " * This may be called to mark a particular id as having already been allocated\n"
  " * (for instance, by a prior pass).  The specified id is removed from the\n"
  " * available pool.\n"
  " *\n"
  " * Because of the limitations of this algorithm, this is most efficient when\n"
  " * it is called before the first call to allocate(), and when all the calls to\n"
  " * initial_reserve_id() are made in descending order by id.  However, this is\n"
  " * a performance warning only; if performance is not an issue, any id may be\n"
  " * reserved at any time.\n"
  " */";
#else
static const char *Dtool_UniqueIdAllocator_initial_reserve_id_1096_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void UniqueIdAllocator::free(uint32_t index)
 */
static PyObject *Dtool_UniqueIdAllocator_free_1097(PyObject *self, PyObject *arg) {
  UniqueIdAllocator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UniqueIdAllocator, (void **)&local_this, "UniqueIdAllocator.free")) {
    return NULL;
  }
  // 1-void UniqueIdAllocator::free(uint32_t index)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    (*local_this).free((uint32_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "free(const UniqueIdAllocator self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UniqueIdAllocator_free_1097_comment =
  "C++ Interface:\n"
  "free(const UniqueIdAllocator self, int index)\n"
  "\n"
  "/**\n"
  " * Free an allocated index (index must be between _min and _max that were\n"
  " * passed to the constructor).\n"
  " */";
#else
static const char *Dtool_UniqueIdAllocator_free_1097_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat UniqueIdAllocator::fraction_used(void) const
 */
static PyObject *Dtool_UniqueIdAllocator_fraction_used_1098(PyObject *self, PyObject *) {
  UniqueIdAllocator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UniqueIdAllocator, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat UniqueIdAllocator::fraction_used(void) const
  PN_stdfloat return_value = (*(const UniqueIdAllocator*)local_this).fraction_used();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UniqueIdAllocator_fraction_used_1098_comment =
  "C++ Interface:\n"
  "fraction_used(UniqueIdAllocator self)\n"
  "\n"
  "/**\n"
  " * return the decimal fraction of the pool that is used.  The range is 0 to\n"
  " * 1.0 (e.g.  75% would be 0.75).\n"
  " */";
#else
static const char *Dtool_UniqueIdAllocator_fraction_used_1098_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void UniqueIdAllocator::output(ostream &out) const
 */
static PyObject *Dtool_UniqueIdAllocator_output_1099(PyObject *self, PyObject *arg) {
  UniqueIdAllocator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UniqueIdAllocator, (void **)&local_this)) {
    return NULL;
  }
  // 1-void UniqueIdAllocator::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "UniqueIdAllocator.output", false, true);
  if (arg_this != NULL) {
    (*(const UniqueIdAllocator*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(UniqueIdAllocator self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UniqueIdAllocator_output_1099_comment =
  "C++ Interface:\n"
  "output(UniqueIdAllocator self, ostream out)\n"
  "\n"
  "/**\n"
  " * ...intended for debugging only.\n"
  " */";
#else
static const char *Dtool_UniqueIdAllocator_output_1099_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void UniqueIdAllocator::write(ostream &out) const
 */
static PyObject *Dtool_UniqueIdAllocator_write_1100(PyObject *self, PyObject *arg) {
  UniqueIdAllocator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UniqueIdAllocator, (void **)&local_this)) {
    return NULL;
  }
  // 1-void UniqueIdAllocator::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "UniqueIdAllocator.write", false, true);
  if (arg_this != NULL) {
    (*(const UniqueIdAllocator*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(UniqueIdAllocator self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UniqueIdAllocator_write_1100_comment =
  "C++ Interface:\n"
  "write(UniqueIdAllocator self, ostream out)\n"
  "\n"
  "/**\n"
  " * ...intended for debugging only.\n"
  " */";
#else
static const char *Dtool_UniqueIdAllocator_write_1100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline UniqueIdAllocator::UniqueIdAllocator(UniqueIdAllocator const &) = default
 * UniqueIdAllocator::UniqueIdAllocator(uint32_t min = 0, uint32_t max = 20)
 */
static int Dtool_Init_UniqueIdAllocator(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-UniqueIdAllocator::UniqueIdAllocator(uint32_t min, uint32_t max)
      UniqueIdAllocator *return_value = new UniqueIdAllocator();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UniqueIdAllocator, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 UniqueIdAllocator::UniqueIdAllocator(uint32_t min, uint32_t max = 20)
        unsigned long param0;
        unsigned long param1 = 20;
        static const char *keyword_list[] = {"min", "max", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "k|k:UniqueIdAllocator", (char **)keyword_list, &param0, &param1)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (param0 > UINT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %lu out of range for unsigned integer",
                         param0);
            return -1;
          }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (param1 > UINT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %lu out of range for unsigned integer",
                         param1);
            return -1;
          }
#endif
          UniqueIdAllocator *return_value = new UniqueIdAllocator((uint32_t)param0, (uint32_t)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UniqueIdAllocator, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: UniqueIdAllocator::UniqueIdAllocator(uint32_t min, uint32_t max = 20)
      {
        // -2 inline UniqueIdAllocator::UniqueIdAllocator(UniqueIdAllocator const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:UniqueIdAllocator", (char **)keyword_list, &param0)) {
          UniqueIdAllocator const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_UniqueIdAllocator(param0, param0_this, param0_manage)) {
            UniqueIdAllocator *return_value = new UniqueIdAllocator(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UniqueIdAllocator, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "UniqueIdAllocator() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UniqueIdAllocator()\n"
      "UniqueIdAllocator(int min, int max)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_UniqueIdAllocator(PyObject *args, UniqueIdAllocator const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_UniqueIdAllocator, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-UniqueIdAllocator::UniqueIdAllocator(uint32_t min, uint32_t max)
    if (PyLongOrInt_Check(arg)) {
      unsigned long param0 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (param0 > UINT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %lu out of range for unsigned integer",
                     param0);
        return false;
      }
#endif
      UniqueIdAllocator *return_value = new UniqueIdAllocator((uint32_t)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-UniqueIdAllocator::UniqueIdAllocator(uint32_t min, uint32_t max)
      unsigned long param0;
      unsigned long param1;
      if (PyArg_ParseTuple(args, "kk:UniqueIdAllocator", &param0, &param1)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param0 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param0);
          return false;
        }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param1 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param1);
          return false;
        }
#endif
        UniqueIdAllocator *return_value = new UniqueIdAllocator((uint32_t)param0, (uint32_t)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_UniqueIdAllocator(PyObject *args, UniqueIdAllocator *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_UniqueIdAllocator, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-UniqueIdAllocator::UniqueIdAllocator(uint32_t min, uint32_t max)
    if (PyLongOrInt_Check(arg)) {
      unsigned long param0 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (param0 > UINT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %lu out of range for unsigned integer",
                     param0);
        return false;
      }
#endif
      UniqueIdAllocator *return_value = new UniqueIdAllocator((uint32_t)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-UniqueIdAllocator::UniqueIdAllocator(uint32_t min, uint32_t max)
      unsigned long param0;
      unsigned long param1;
      if (PyArg_ParseTuple(args, "kk:UniqueIdAllocator", &param0, &param1)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param0 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param0);
          return false;
        }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param1 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param1);
          return false;
        }
#endif
        UniqueIdAllocator *return_value = new UniqueIdAllocator((uint32_t)param0, (uint32_t)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_UniqueIdAllocator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_UniqueIdAllocator) {
    printf("UniqueIdAllocator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  UniqueIdAllocator *local_this = (UniqueIdAllocator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_UniqueIdAllocator) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_UniqueIdAllocator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_UniqueIdAllocator) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for ConstPointerToArray_ushort (ConstPointerToArray_ushort)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_ushort[] = {
  {"get_element", &Dtool_ConstPointerToArray_ushort_get_element_10, METH_O, (const char *)Dtool_ConstPointerToArray_ushort_get_element_10_comment},
  {"getElement", &Dtool_ConstPointerToArray_ushort_get_element_10, METH_O, (const char *)Dtool_ConstPointerToArray_ushort_get_element_10_comment},
  {"get_data", &Dtool_ConstPointerToArray_ushort_get_data_12, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_ushort_get_data_12_comment},
  {"getData", &Dtool_ConstPointerToArray_ushort_get_data_12, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_ushort_get_data_12_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_ushort_get_subdata_13, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_ushort_get_subdata_13_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_ushort_get_subdata_13, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_ushort_get_subdata_13_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_ushort_get_ref_count_14, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_ushort_get_ref_count_14_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_ushort_get_ref_count_14, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_ushort_get_ref_count_14_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_ushort_get_node_ref_count_15, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_ushort_get_node_ref_count_15_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_ushort_get_node_ref_count_15, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_ushort_get_node_ref_count_15_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_ushort slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_ushort_getbuffer_16_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_ushort, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< ushort > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_ushort slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_ushort_releasebuffer_17_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_ushort, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< ushort > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_ushort slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_ushort_getitem_11_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_ushort, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_ushort index out of range");
    return NULL;
  }
  // 1-ushort const &ConstPointerToArray< ushort >::__getitem__(unsigned long int n) const
  ushort return_value = invoke_extension((const ConstPointerToArray< ushort >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_ushort slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_ushort_size_9_sq_length(PyObject *self) {
  ConstPointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_ushort, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_ushort = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_ushort = {
  &Dtool_ConstPointerToArray_ushort_size_9_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConstPointerToArray_ushort_getitem_11_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_ushort = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_ushort = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_ushort_getbuffer_16_bf_getbuffer,
  &Dtool_ConstPointerToArray_ushort_releasebuffer_17_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_ushort = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConstPointerToArray_ushort",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_ushort,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConstPointerToArray_ushort,
    &Dtool_SequenceMethods_ConstPointerToArray_ushort,
    &Dtool_MappingMethods_ConstPointerToArray_ushort,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConstPointerToArray_ushort,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConstPointerToArray_ushort,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_ushort,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_ushort,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_ushort,
  Dtool_UpcastInterface_ConstPointerToArray_ushort,
  Dtool_DowncastInterface_ConstPointerToArray_ushort,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_ushort,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_ushort(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_ushort(NULL);
    Dtool_ConstPointerToArray_ushort._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_ushort);
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_ushort._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_ushort) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_ushort)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_ushort);
  }
}

/**
 * Python method tables for PointerToArrayBase_ushort (PointerToArrayBase_ushort)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_ushort[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_ushort = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_ushort = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_ushort = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_ushort = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_ushort = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArrayBase_ushort",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_ushort,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArrayBase_ushort,
    &Dtool_SequenceMethods_PointerToArrayBase_ushort,
    &Dtool_MappingMethods_PointerToArrayBase_ushort,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArrayBase_ushort,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArrayBase_ushort,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_ushort,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_ushort,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_ushort,
  Dtool_UpcastInterface_PointerToArrayBase_ushort,
  Dtool_DowncastInterface_PointerToArrayBase_ushort,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_ushort(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_ushort(NULL);
    Dtool_PointerToArrayBase_ushort._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_ushort);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_ushort._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_ushort) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_ushort)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_ushort);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_ushort (PointerToBase_ReferenceCountedVector_ushort)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_ushort[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_ushort_clear_5, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_ushort_clear_5_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_ushort_output_6, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_ushort_output_6_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_ushort
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_ushort(PyObject *self) {
  PointerToBase< ReferenceCountedVector< ushort > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_ushort, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_ushort = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_ushort = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_ushort = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_ushort = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_ushort = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_ushort",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_ushort,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_ushort,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_ushort,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_ushort,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_ushort,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_ushort,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_ushort,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_ReferenceCountedVector_ushort,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_ushort,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_ushort,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_ushort,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_ushort,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_ushort,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_ushort(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != NULL);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(NULL);
    Dtool_PointerToBase_ReferenceCountedVector_ushort._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_ushort._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_ushort) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_ushort)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_ushort);
  }
}

/**
 * Python method tables for PointerToArray_ushort (PointerToArray_ushort)
 */
static PyMethodDef Dtool_Methods_PointerToArray_ushort[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_ushort_empty_array_21, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_ushort_empty_array_21_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_ushort_empty_array_21, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_ushort_empty_array_21_comment},
  {"push_back", &Dtool_PointerToArray_ushort_push_back_23, METH_O, (const char *)Dtool_PointerToArray_ushort_push_back_23_comment},
  {"pushBack", &Dtool_PointerToArray_ushort_push_back_23, METH_O, (const char *)Dtool_PointerToArray_ushort_push_back_23_comment},
  {"pop_back", &Dtool_PointerToArray_ushort_pop_back_24, METH_NOARGS, (const char *)Dtool_PointerToArray_ushort_pop_back_24_comment},
  {"popBack", &Dtool_PointerToArray_ushort_pop_back_24, METH_NOARGS, (const char *)Dtool_PointerToArray_ushort_pop_back_24_comment},
  {"get_element", &Dtool_PointerToArray_ushort_get_element_25, METH_O, (const char *)Dtool_PointerToArray_ushort_get_element_25_comment},
  {"getElement", &Dtool_PointerToArray_ushort_get_element_25, METH_O, (const char *)Dtool_PointerToArray_ushort_get_element_25_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_ushort_set_element_26, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_ushort_set_element_26_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_ushort_set_element_26, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_ushort_set_element_26_comment},
  {"get_data", &Dtool_PointerToArray_ushort_get_data_29, METH_NOARGS, (const char *)Dtool_PointerToArray_ushort_get_data_29_comment},
  {"getData", &Dtool_PointerToArray_ushort_get_data_29, METH_NOARGS, (const char *)Dtool_PointerToArray_ushort_get_data_29_comment},
  {"set_data", &Dtool_PointerToArray_ushort_set_data_30, METH_O, (const char *)Dtool_PointerToArray_ushort_set_data_30_comment},
  {"setData", &Dtool_PointerToArray_ushort_set_data_30, METH_O, (const char *)Dtool_PointerToArray_ushort_set_data_30_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_ushort_get_subdata_31, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_ushort_get_subdata_31_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_ushort_get_subdata_31, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_ushort_get_subdata_31_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_ushort_set_subdata_32, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_ushort_set_subdata_32_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_ushort_set_subdata_32, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_ushort_set_subdata_32_comment},
  {"get_ref_count", &Dtool_PointerToArray_ushort_get_ref_count_33, METH_NOARGS, (const char *)Dtool_PointerToArray_ushort_get_ref_count_33_comment},
  {"getRefCount", &Dtool_PointerToArray_ushort_get_ref_count_33, METH_NOARGS, (const char *)Dtool_PointerToArray_ushort_get_ref_count_33_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_ushort_get_node_ref_count_34, METH_NOARGS, (const char *)Dtool_PointerToArray_ushort_get_node_ref_count_34_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_ushort_get_node_ref_count_34, METH_NOARGS, (const char *)Dtool_PointerToArray_ushort_get_node_ref_count_34_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_ushort slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_ushort_getbuffer_35_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_ushort, (void **)&local_this)) {
    return -1;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_ushort.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_ushort slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_ushort_releasebuffer_36_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_ushort, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< ushort > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_ushort slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_ushort_setitem_28_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_ushort, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_ushort index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PointerToArray< ushort >::__setitem__(unsigned long int n, ushort const &value)
      if (PyLongOrInt_Check(arg)) {
        long param2 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param2);
          return -1;
        }
#endif
        invoke_extension(local_this).__setitem__(index, (ushort)param2);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, int value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_ushort slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_ushort_getitem_27_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_ushort, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_ushort index out of range");
    return NULL;
  }
  // 1-ushort const &PointerToArray< ushort >::__getitem__(unsigned long int n) const
  ushort return_value = invoke_extension((const PointerToArray< ushort >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_ushort slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_ushort_size_22_sq_length(PyObject *self) {
  PointerToArray< ushort > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_ushort, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_ushort = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_ushort = {
  &Dtool_PointerToArray_ushort_size_22_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PointerToArray_ushort_getitem_27_sq_item,
  0, // sq_slice
  &Dtool_PointerToArray_ushort_setitem_28_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_ushort = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_ushort = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_ushort_getbuffer_35_bf_getbuffer,
  &Dtool_PointerToArray_ushort_releasebuffer_36_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArray_ushort = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArray_ushort",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_ushort,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArray_ushort,
    &Dtool_SequenceMethods_PointerToArray_ushort,
    &Dtool_MappingMethods_PointerToArray_ushort,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArray_ushort,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArray_ushort,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_ushort,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_ushort,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_ushort,
  Dtool_UpcastInterface_PointerToArray_ushort,
  Dtool_DowncastInterface_PointerToArray_ushort,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_PointerToArray_ushort,
};

static void Dtool_PyModuleClassInit_PointerToArray_ushort(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_ushort(NULL);
    Dtool_PointerToArray_ushort._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_ushort);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_ushort._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_ushort) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_ushort)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_ushort);
  }
}

/**
 * Python method tables for AnimInterface (AnimInterface)
 */
static PyMethodDef Dtool_Methods_AnimInterface[] = {
  {"play", (PyCFunction) &Dtool_AnimInterface_play_40, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimInterface_play_40_comment},
  {"loop", (PyCFunction) &Dtool_AnimInterface_loop_41, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimInterface_loop_41_comment},
  {"pingpong", (PyCFunction) &Dtool_AnimInterface_pingpong_42, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimInterface_pingpong_42_comment},
  {"stop", &Dtool_AnimInterface_stop_43, METH_NOARGS, (const char *)Dtool_AnimInterface_stop_43_comment},
  {"pose", &Dtool_AnimInterface_pose_44, METH_O, (const char *)Dtool_AnimInterface_pose_44_comment},
  {"set_play_rate", &Dtool_AnimInterface_set_play_rate_45, METH_O, (const char *)Dtool_AnimInterface_set_play_rate_45_comment},
  {"setPlayRate", &Dtool_AnimInterface_set_play_rate_45, METH_O, (const char *)Dtool_AnimInterface_set_play_rate_45_comment},
  {"get_play_rate", &Dtool_AnimInterface_get_play_rate_46, METH_NOARGS, (const char *)Dtool_AnimInterface_get_play_rate_46_comment},
  {"getPlayRate", &Dtool_AnimInterface_get_play_rate_46, METH_NOARGS, (const char *)Dtool_AnimInterface_get_play_rate_46_comment},
  {"get_frame_rate", &Dtool_AnimInterface_get_frame_rate_47, METH_NOARGS, (const char *)Dtool_AnimInterface_get_frame_rate_47_comment},
  {"getFrameRate", &Dtool_AnimInterface_get_frame_rate_47, METH_NOARGS, (const char *)Dtool_AnimInterface_get_frame_rate_47_comment},
  {"get_num_frames", &Dtool_AnimInterface_get_num_frames_48, METH_NOARGS, (const char *)Dtool_AnimInterface_get_num_frames_48_comment},
  {"getNumFrames", &Dtool_AnimInterface_get_num_frames_48, METH_NOARGS, (const char *)Dtool_AnimInterface_get_num_frames_48_comment},
  {"get_frame", &Dtool_AnimInterface_get_frame_49, METH_NOARGS, (const char *)Dtool_AnimInterface_get_frame_49_comment},
  {"getFrame", &Dtool_AnimInterface_get_frame_49, METH_NOARGS, (const char *)Dtool_AnimInterface_get_frame_49_comment},
  {"get_next_frame", &Dtool_AnimInterface_get_next_frame_50, METH_NOARGS, (const char *)Dtool_AnimInterface_get_next_frame_50_comment},
  {"getNextFrame", &Dtool_AnimInterface_get_next_frame_50, METH_NOARGS, (const char *)Dtool_AnimInterface_get_next_frame_50_comment},
  {"get_frac", &Dtool_AnimInterface_get_frac_51, METH_NOARGS, (const char *)Dtool_AnimInterface_get_frac_51_comment},
  {"getFrac", &Dtool_AnimInterface_get_frac_51, METH_NOARGS, (const char *)Dtool_AnimInterface_get_frac_51_comment},
  {"get_full_frame", &Dtool_AnimInterface_get_full_frame_52, METH_NOARGS, (const char *)Dtool_AnimInterface_get_full_frame_52_comment},
  {"getFullFrame", &Dtool_AnimInterface_get_full_frame_52, METH_NOARGS, (const char *)Dtool_AnimInterface_get_full_frame_52_comment},
  {"get_full_fframe", &Dtool_AnimInterface_get_full_fframe_53, METH_NOARGS, (const char *)Dtool_AnimInterface_get_full_fframe_53_comment},
  {"getFullFframe", &Dtool_AnimInterface_get_full_fframe_53, METH_NOARGS, (const char *)Dtool_AnimInterface_get_full_fframe_53_comment},
  {"is_playing", &Dtool_AnimInterface_is_playing_54, METH_NOARGS, (const char *)Dtool_AnimInterface_is_playing_54_comment},
  {"isPlaying", &Dtool_AnimInterface_is_playing_54, METH_NOARGS, (const char *)Dtool_AnimInterface_is_playing_54_comment},
  {"output", &Dtool_AnimInterface_output_55, METH_O, (const char *)Dtool_AnimInterface_output_55_comment},
  {"get_class_type", &Dtool_AnimInterface_get_class_type_68, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimInterface_get_class_type_68_comment},
  {"getClassType", &Dtool_AnimInterface_get_class_type_68, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimInterface_get_class_type_68_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     AnimInterface
//////////////////
static PyObject *Dtool_Repr_AnimInterface(PyObject *self) {
  AnimInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_AnimInterface[] = {
  {(char *)"play_rate", &Dtool_AnimInterface_play_rate_Getter, &Dtool_AnimInterface_play_rate_Setter, NULL, NULL},
  {(char *)"frame_rate", &Dtool_AnimInterface_frame_rate_Getter, NULL, NULL, NULL},
  {(char *)"num_frames", &Dtool_AnimInterface_num_frames_Getter, NULL, NULL, NULL},
  {(char *)"frame", &Dtool_AnimInterface_frame_Getter, NULL, NULL, NULL},
  {(char *)"next_frame", &Dtool_AnimInterface_next_frame_Getter, NULL, NULL, NULL},
  {(char *)"frac", &Dtool_AnimInterface_frac_Getter, NULL, NULL, NULL},
  {(char *)"full_frame", &Dtool_AnimInterface_full_frame_Getter, NULL, NULL, NULL},
  {(char *)"full_fframe", &Dtool_AnimInterface_full_fframe_Getter, NULL, NULL, NULL},
  {(char *)"playing", &Dtool_AnimInterface_playing_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_AnimInterface = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_AnimInterface = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AnimInterface",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimInterface,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_AnimInterface,
    &Dtool_NumberMethods_AnimInterface,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_AnimInterface,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the fundamental interface for things that have a play/loop/stop\n"
    " * type interface for frame-based animation, such as animated characters.\n"
    " * This is the base class for AnimControl and other, similar classes.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AnimInterface,
    0, // tp_members
    Dtool_Properties_AnimInterface,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AnimInterface,
    PyType_GenericAlloc,
    Dtool_new_AnimInterface,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimInterface,
  Dtool_UpcastInterface_AnimInterface,
  Dtool_DowncastInterface_AnimInterface,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AnimInterface(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_AnimInterface._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_AnimInterface._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimInterface) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimInterface)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimInterface);
  }
}

/**
 * Python method tables for UpdateSeq (UpdateSeq)
 */
static PyMethodDef Dtool_Methods_UpdateSeq[] = {
  {"initial", &Dtool_UpdateSeq_initial_72, METH_NOARGS | METH_STATIC, (const char *)Dtool_UpdateSeq_initial_72_comment},
  {"old", &Dtool_UpdateSeq_old_73, METH_NOARGS | METH_STATIC, (const char *)Dtool_UpdateSeq_old_73_comment},
  {"fresh", &Dtool_UpdateSeq_fresh_74, METH_NOARGS | METH_STATIC, (const char *)Dtool_UpdateSeq_fresh_74_comment},
  {"assign", &Dtool_UpdateSeq_operator_75, METH_O, (const char *)Dtool_UpdateSeq_operator_75_comment},
  {"clear", &Dtool_UpdateSeq_clear_76, METH_NOARGS, (const char *)Dtool_UpdateSeq_clear_76_comment},
  {"is_initial", &Dtool_UpdateSeq_is_initial_77, METH_NOARGS, (const char *)Dtool_UpdateSeq_is_initial_77_comment},
  {"isInitial", &Dtool_UpdateSeq_is_initial_77, METH_NOARGS, (const char *)Dtool_UpdateSeq_is_initial_77_comment},
  {"is_old", &Dtool_UpdateSeq_is_old_78, METH_NOARGS, (const char *)Dtool_UpdateSeq_is_old_78_comment},
  {"isOld", &Dtool_UpdateSeq_is_old_78, METH_NOARGS, (const char *)Dtool_UpdateSeq_is_old_78_comment},
  {"is_fresh", &Dtool_UpdateSeq_is_fresh_79, METH_NOARGS, (const char *)Dtool_UpdateSeq_is_fresh_79_comment},
  {"isFresh", &Dtool_UpdateSeq_is_fresh_79, METH_NOARGS, (const char *)Dtool_UpdateSeq_is_fresh_79_comment},
  {"is_special", &Dtool_UpdateSeq_is_special_80, METH_NOARGS, (const char *)Dtool_UpdateSeq_is_special_80_comment},
  {"isSpecial", &Dtool_UpdateSeq_is_special_80, METH_NOARGS, (const char *)Dtool_UpdateSeq_is_special_80_comment},
  {"increment", &Dtool_UpdateSeq_operator_87, METH_NOARGS, (const char *)Dtool_UpdateSeq_operator_87_comment},
  {"increment", &Dtool_UpdateSeq_operator_88, METH_O, (const char *)Dtool_UpdateSeq_operator_88_comment},
  {"get_seq", &Dtool_UpdateSeq_get_seq_89, METH_NOARGS, (const char *)Dtool_UpdateSeq_get_seq_89_comment},
  {"getSeq", &Dtool_UpdateSeq_get_seq_89, METH_NOARGS, (const char *)Dtool_UpdateSeq_get_seq_89_comment},
  {"output", &Dtool_UpdateSeq_output_94, METH_O, (const char *)Dtool_UpdateSeq_output_94_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     UpdateSeq
//////////////////
static PyObject *Dtool_Repr_UpdateSeq(PyObject *self) {
  UpdateSeq *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UpdateSeq, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     UpdateSeq
//////////////////
static PyObject *Dtool_RichCompare_UpdateSeq(PyObject *self, PyObject *arg, int op) {
  UpdateSeq *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UpdateSeq, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool UpdateSeq::operator ==(UpdateSeq const &other) const
      UpdateSeq const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_UpdateSeq, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const UpdateSeq*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool UpdateSeq::operator !=(UpdateSeq const &other) const
      UpdateSeq const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_UpdateSeq, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const UpdateSeq*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool UpdateSeq::operator <(UpdateSeq const &other) const
      UpdateSeq const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_UpdateSeq, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const UpdateSeq*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LE:
    {
      // 1-inline bool UpdateSeq::operator <=(UpdateSeq const &other) const
      UpdateSeq const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_UpdateSeq, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const UpdateSeq*)local_this).operator <=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_GT:
    {
      // 1-inline bool UpdateSeq::operator >(UpdateSeq const &other) const
      UpdateSeq const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_UpdateSeq, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const UpdateSeq*)local_this).operator >(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_GE:
    {
      // 1-inline bool UpdateSeq::operator >=(UpdateSeq const &other) const
      UpdateSeq const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_UpdateSeq, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const UpdateSeq*)local_this).operator >=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_UpdateSeq[] = {
  {(char *)"seq", &Dtool_UpdateSeq_seq_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_UpdateSeq = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_UpdateSeq = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.UpdateSeq",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_UpdateSeq,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &DTOOL_PyObject_ComparePointers,
#endif
    &Dtool_Repr_UpdateSeq,
    &Dtool_NumberMethods_UpdateSeq,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Repr_UpdateSeq,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a sequence number that increments monotonically.  It can be used to\n"
    " * track cache updates, or serve as a kind of timestamp for any changing\n"
    " * properties.\n"
    " *\n"
    " * A special class is used instead of simply an int, so we can elegantly\n"
    " * handle such things as wraparound and special cases.  There are two special\n"
    " * cases.  Firstly, a sequence number is 'initial' when it is first created.\n"
    " * This sequence is older than any other sequence number.  Secondly, a\n"
    " * sequence number may be explicitly set to 'old'.  This is older than any\n"
    " * other sequence number except 'initial'.  Finally, we have the explicit\n"
    " * number 'fresh', which is newer than any other sequence number.  All other\n"
    " * sequences are numeric and are monotonically increasing.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_UpdateSeq,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_UpdateSeq,
    0, // tp_members
    Dtool_Properties_UpdateSeq,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_UpdateSeq,
    PyType_GenericAlloc,
    Dtool_new_UpdateSeq,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UpdateSeq,
  Dtool_UpcastInterface_UpdateSeq,
  Dtool_DowncastInterface_UpdateSeq,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_UpdateSeq(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_UpdateSeq._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_UpdateSeq._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_UpdateSeq) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UpdateSeq)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UpdateSeq);
  }
}

/**
 * Python method tables for TypedWritable (TypedWritable)
 */
static PyMethodDef Dtool_Methods_TypedWritable[] = {
  {"fillin", (PyCFunction) &Dtool_TypedWritable_fillin_98, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypedWritable_fillin_98_comment},
  {"mark_bam_modified", &Dtool_TypedWritable_mark_bam_modified_99, METH_NOARGS, (const char *)Dtool_TypedWritable_mark_bam_modified_99_comment},
  {"markBamModified", &Dtool_TypedWritable_mark_bam_modified_99, METH_NOARGS, (const char *)Dtool_TypedWritable_mark_bam_modified_99_comment},
  {"get_bam_modified", &Dtool_TypedWritable_get_bam_modified_100, METH_NOARGS, (const char *)Dtool_TypedWritable_get_bam_modified_100_comment},
  {"getBamModified", &Dtool_TypedWritable_get_bam_modified_100, METH_NOARGS, (const char *)Dtool_TypedWritable_get_bam_modified_100_comment},
  {"__reduce__", &Dtool_TypedWritable_reduce_101, METH_NOARGS, (const char *)Dtool_TypedWritable_reduce_101_comment},
  {"__reduce_persist__", &Dtool_TypedWritable_reduce_persist_102, METH_O, (const char *)Dtool_TypedWritable_reduce_persist_102_comment},
  {"encode_to_bam_stream", &Dtool_TypedWritable_encode_to_bam_stream_103, METH_NOARGS, (const char *)Dtool_TypedWritable_encode_to_bam_stream_103_comment},
  {"encodeToBamStream", &Dtool_TypedWritable_encode_to_bam_stream_103, METH_NOARGS, (const char *)Dtool_TypedWritable_encode_to_bam_stream_103_comment},
  {"get_class_type", &Dtool_TypedWritable_get_class_type_105, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypedWritable_get_class_type_105_comment},
  {"getClassType", &Dtool_TypedWritable_get_class_type_105, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypedWritable_get_class_type_105_comment},
  {"downcast_to_TypedWritableReferenceCount", &Dtool_TypedWritable_downcast_to_TypedWritableReferenceCount_108, METH_NOARGS, (const char *)Dtool_TypedWritable_downcast_to_TypedWritableReferenceCount_108_comment},
  {"downcastToTypedWritableReferenceCount", &Dtool_TypedWritable_downcast_to_TypedWritableReferenceCount_108, METH_NOARGS, (const char *)Dtool_TypedWritable_downcast_to_TypedWritableReferenceCount_108_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_TypedWritable = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TypedWritable = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_TypedWritable = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_TypedWritable = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_TypedWritable = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.TypedWritable",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TypedWritable,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TypedWritable,
    &Dtool_SequenceMethods_TypedWritable,
    &Dtool_MappingMethods_TypedWritable,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_TypedWritable,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Base class for objects that can be written to and read from Bam files.\n"
    " *\n"
    " * See also TypedObject for detailed instructions.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TypedWritable,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TypedWritable,
    PyType_GenericAlloc,
    Dtool_new_TypedWritable,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TypedWritable,
  Dtool_UpcastInterface_TypedWritable,
  Dtool_DowncastInterface_TypedWritable,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_TypedWritable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != NULL);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(NULL);
    Dtool_TypedWritable._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    PyObject *dict = PyDict_New();
    Dtool_TypedWritable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TypedWritable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TypedWritable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TypedWritable);
  }
}

/**
 * Python method tables for TypedWritableReferenceCount (TypedWritableReferenceCount)
 */
static PyMethodDef Dtool_Methods_TypedWritableReferenceCount[] = {
  {"decode_from_bam_stream", (PyCFunction) &Dtool_TypedWritableReferenceCount_decode_from_bam_stream_112, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TypedWritableReferenceCount_decode_from_bam_stream_112_comment},
  {"decodeFromBamStream", (PyCFunction) &Dtool_TypedWritableReferenceCount_decode_from_bam_stream_112, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TypedWritableReferenceCount_decode_from_bam_stream_112_comment},
  {"get_class_type", &Dtool_TypedWritableReferenceCount_get_class_type_113, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypedWritableReferenceCount_get_class_type_113_comment},
  {"getClassType", &Dtool_TypedWritableReferenceCount_get_class_type_113, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypedWritableReferenceCount_get_class_type_113_comment},
  {"upcast_to_TypedWritable", &Dtool_TypedWritableReferenceCount_upcast_to_TypedWritable_107, METH_NOARGS, (const char *)Dtool_TypedWritableReferenceCount_upcast_to_TypedWritable_107_comment},
  {"upcastToTypedWritable", &Dtool_TypedWritableReferenceCount_upcast_to_TypedWritable_107, METH_NOARGS, (const char *)Dtool_TypedWritableReferenceCount_upcast_to_TypedWritable_107_comment},
  {"upcast_to_ReferenceCount", &Dtool_TypedWritableReferenceCount_upcast_to_ReferenceCount_110, METH_NOARGS, (const char *)Dtool_TypedWritableReferenceCount_upcast_to_ReferenceCount_110_comment},
  {"upcastToReferenceCount", &Dtool_TypedWritableReferenceCount_upcast_to_ReferenceCount_110, METH_NOARGS, (const char *)Dtool_TypedWritableReferenceCount_upcast_to_ReferenceCount_110_comment},
  {"downcast_to_BamCacheRecord", &Dtool_TypedWritableReferenceCount_downcast_to_BamCacheRecord_117, METH_NOARGS, (const char *)Dtool_TypedWritableReferenceCount_downcast_to_BamCacheRecord_117_comment},
  {"downcastToBamCacheRecord", &Dtool_TypedWritableReferenceCount_downcast_to_BamCacheRecord_117, METH_NOARGS, (const char *)Dtool_TypedWritableReferenceCount_downcast_to_BamCacheRecord_117_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_TypedWritableReferenceCount = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TypedWritableReferenceCount = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_TypedWritableReferenceCount = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_TypedWritableReferenceCount = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.TypedWritableReferenceCount",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TypedWritableReferenceCount,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TypedWritableReferenceCount,
    &Dtool_SequenceMethods_TypedWritableReferenceCount,
    &Dtool_MappingMethods_TypedWritableReferenceCount,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_TypedWritableReferenceCount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for things which need to inherit from both TypedWritable and\n"
    " * from ReferenceCount.  It's convenient to define this intermediate base\n"
    " * class instead of multiply inheriting from the two classes each time they\n"
    " * are needed, so that we can sensibly pass around pointers to things which\n"
    " * are both TypedWritables and ReferenceCounters.\n"
    " *\n"
    " * See also TypedObject for detailed instructions.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TypedWritableReferenceCount,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TypedWritableReferenceCount,
    PyType_GenericAlloc,
    Dtool_new_TypedWritableReferenceCount,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TypedWritableReferenceCount,
  Dtool_UpcastInterface_TypedWritableReferenceCount,
  Dtool_DowncastInterface_TypedWritableReferenceCount,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_TypedWritableReferenceCount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TypedWritable(NULL);
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_TypedWritableReferenceCount._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_TypedWritable, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_TypedWritableReferenceCount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TypedWritableReferenceCount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TypedWritableReferenceCount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TypedWritableReferenceCount);
  }
}

/**
 * Python method tables for BamCacheRecord (BamCacheRecord)
 */
static PyMethodDef Dtool_Methods_BamCacheRecord[] = {
  {"make_copy", &Dtool_BamCacheRecord_make_copy_122, METH_NOARGS, (const char *)Dtool_BamCacheRecord_make_copy_122_comment},
  {"makeCopy", &Dtool_BamCacheRecord_make_copy_122, METH_NOARGS, (const char *)Dtool_BamCacheRecord_make_copy_122_comment},
  {"get_source_pathname", &Dtool_BamCacheRecord_get_source_pathname_124, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_source_pathname_124_comment},
  {"getSourcePathname", &Dtool_BamCacheRecord_get_source_pathname_124, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_source_pathname_124_comment},
  {"get_cache_filename", &Dtool_BamCacheRecord_get_cache_filename_125, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_cache_filename_125_comment},
  {"getCacheFilename", &Dtool_BamCacheRecord_get_cache_filename_125, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_cache_filename_125_comment},
  {"get_source_timestamp", &Dtool_BamCacheRecord_get_source_timestamp_126, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_source_timestamp_126_comment},
  {"getSourceTimestamp", &Dtool_BamCacheRecord_get_source_timestamp_126, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_source_timestamp_126_comment},
  {"get_recorded_time", &Dtool_BamCacheRecord_get_recorded_time_127, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_recorded_time_127_comment},
  {"getRecordedTime", &Dtool_BamCacheRecord_get_recorded_time_127, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_recorded_time_127_comment},
  {"get_num_dependent_files", &Dtool_BamCacheRecord_get_num_dependent_files_135, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_num_dependent_files_135_comment},
  {"getNumDependentFiles", &Dtool_BamCacheRecord_get_num_dependent_files_135, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_num_dependent_files_135_comment},
  {"get_dependent_pathname", &Dtool_BamCacheRecord_get_dependent_pathname_136, METH_O, (const char *)Dtool_BamCacheRecord_get_dependent_pathname_136_comment},
  {"getDependentPathname", &Dtool_BamCacheRecord_get_dependent_pathname_136, METH_O, (const char *)Dtool_BamCacheRecord_get_dependent_pathname_136_comment},
  {"dependents_unchanged", &Dtool_BamCacheRecord_dependents_unchanged_137, METH_NOARGS, (const char *)Dtool_BamCacheRecord_dependents_unchanged_137_comment},
  {"dependentsUnchanged", &Dtool_BamCacheRecord_dependents_unchanged_137, METH_NOARGS, (const char *)Dtool_BamCacheRecord_dependents_unchanged_137_comment},
  {"clear_dependent_files", &Dtool_BamCacheRecord_clear_dependent_files_138, METH_NOARGS, (const char *)Dtool_BamCacheRecord_clear_dependent_files_138_comment},
  {"clearDependentFiles", &Dtool_BamCacheRecord_clear_dependent_files_138, METH_NOARGS, (const char *)Dtool_BamCacheRecord_clear_dependent_files_138_comment},
  {"add_dependent_file", &Dtool_BamCacheRecord_add_dependent_file_139, METH_O, (const char *)Dtool_BamCacheRecord_add_dependent_file_139_comment},
  {"addDependentFile", &Dtool_BamCacheRecord_add_dependent_file_139, METH_O, (const char *)Dtool_BamCacheRecord_add_dependent_file_139_comment},
  {"has_data", &Dtool_BamCacheRecord_has_data_140, METH_NOARGS, (const char *)Dtool_BamCacheRecord_has_data_140_comment},
  {"hasData", &Dtool_BamCacheRecord_has_data_140, METH_NOARGS, (const char *)Dtool_BamCacheRecord_has_data_140_comment},
  {"clear_data", &Dtool_BamCacheRecord_clear_data_141, METH_NOARGS, (const char *)Dtool_BamCacheRecord_clear_data_141_comment},
  {"clearData", &Dtool_BamCacheRecord_clear_data_141, METH_NOARGS, (const char *)Dtool_BamCacheRecord_clear_data_141_comment},
  {"get_data", &Dtool_BamCacheRecord_get_data_142, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_data_142_comment},
  {"getData", &Dtool_BamCacheRecord_get_data_142, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_data_142_comment},
  {"set_data", (PyCFunction) &Dtool_BamCacheRecord_set_data_144, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamCacheRecord_set_data_144_comment},
  {"setData", (PyCFunction) &Dtool_BamCacheRecord_set_data_144, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamCacheRecord_set_data_144_comment},
  {"output", &Dtool_BamCacheRecord_output_147, METH_O, (const char *)Dtool_BamCacheRecord_output_147_comment},
  {"write", (PyCFunction) &Dtool_BamCacheRecord_write_148, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamCacheRecord_write_148_comment},
  {"get_class_type", &Dtool_BamCacheRecord_get_class_type_149, METH_NOARGS | METH_STATIC, (const char *)Dtool_BamCacheRecord_get_class_type_149_comment},
  {"getClassType", &Dtool_BamCacheRecord_get_class_type_149, METH_NOARGS | METH_STATIC, (const char *)Dtool_BamCacheRecord_get_class_type_149_comment},
  {"upcast_to_TypedWritableReferenceCount", &Dtool_BamCacheRecord_upcast_to_TypedWritableReferenceCount_116, METH_NOARGS, (const char *)Dtool_BamCacheRecord_upcast_to_TypedWritableReferenceCount_116_comment},
  {"upcastToTypedWritableReferenceCount", &Dtool_BamCacheRecord_upcast_to_TypedWritableReferenceCount_116, METH_NOARGS, (const char *)Dtool_BamCacheRecord_upcast_to_TypedWritableReferenceCount_116_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     BamCacheRecord
//////////////////
static PyObject *Dtool_Repr_BamCacheRecord(PyObject *self) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     BamCacheRecord
//////////////////
static PyObject *Dtool_Str_BamCacheRecord(PyObject *self) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     BamCacheRecord
//////////////////
static PyObject *Dtool_RichCompare_BamCacheRecord(PyObject *self, PyObject *arg, int op) {
  BamCacheRecord *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool BamCacheRecord::operator ==(BamCacheRecord const &other) const
      BamCacheRecord const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_BamCacheRecord, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const BamCacheRecord*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_BamCacheRecord[] = {
  {(char *)"source_pathname", &Dtool_BamCacheRecord_source_pathname_Getter, NULL, NULL, NULL},
  {(char *)"cache_filename", &Dtool_BamCacheRecord_cache_filename_Getter, NULL, NULL, NULL},
  {(char *)"source_timestamp", &Dtool_BamCacheRecord_source_timestamp_Getter, NULL, NULL, NULL},
  {(char *)"recorded_time", &Dtool_BamCacheRecord_recorded_time_Getter, NULL, NULL, NULL},
  {(char *)"data", &Dtool_BamCacheRecord_data_Getter, &Dtool_BamCacheRecord_data_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_BamCacheRecord = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BamCacheRecord = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_BamCacheRecord = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_BamCacheRecord = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_BamCacheRecord = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.BamCacheRecord",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BamCacheRecord,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &DTOOL_PyObject_ComparePointers,
#endif
    &Dtool_Repr_BamCacheRecord,
    &Dtool_NumberMethods_BamCacheRecord,
    &Dtool_SequenceMethods_BamCacheRecord,
    &Dtool_MappingMethods_BamCacheRecord,
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Str_BamCacheRecord,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_BamCacheRecord,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An instance of this class is written to the front of a Bam or Txo file to\n"
    " * make the file a cached instance of some other loadable resource.  This\n"
    " * record contains information needed to test the validity of the cache.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_BamCacheRecord,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BamCacheRecord,
    0, // tp_members
    Dtool_Properties_BamCacheRecord,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BamCacheRecord,
    PyType_GenericAlloc,
    Dtool_new_BamCacheRecord,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BamCacheRecord,
  Dtool_UpcastInterface_BamCacheRecord,
  Dtool_DowncastInterface_BamCacheRecord,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_BamCacheRecord(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TypedWritableReferenceCount(NULL);
    Dtool_BamCacheRecord._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TypedWritableReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_BamCacheRecord._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BamCacheRecord) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BamCacheRecord)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BamCacheRecord);
  }
}

/**
 * Python method tables for BamCache (BamCache)
 */
static PyMethodDef Dtool_Methods_BamCache[] = {
  {"set_active", &Dtool_BamCache_set_active_153, METH_O, (const char *)Dtool_BamCache_set_active_153_comment},
  {"setActive", &Dtool_BamCache_set_active_153, METH_O, (const char *)Dtool_BamCache_set_active_153_comment},
  {"get_active", &Dtool_BamCache_get_active_154, METH_NOARGS, (const char *)Dtool_BamCache_get_active_154_comment},
  {"getActive", &Dtool_BamCache_get_active_154, METH_NOARGS, (const char *)Dtool_BamCache_get_active_154_comment},
  {"set_cache_models", &Dtool_BamCache_set_cache_models_155, METH_O, (const char *)Dtool_BamCache_set_cache_models_155_comment},
  {"setCacheModels", &Dtool_BamCache_set_cache_models_155, METH_O, (const char *)Dtool_BamCache_set_cache_models_155_comment},
  {"get_cache_models", &Dtool_BamCache_get_cache_models_156, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_models_156_comment},
  {"getCacheModels", &Dtool_BamCache_get_cache_models_156, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_models_156_comment},
  {"set_cache_textures", &Dtool_BamCache_set_cache_textures_157, METH_O, (const char *)Dtool_BamCache_set_cache_textures_157_comment},
  {"setCacheTextures", &Dtool_BamCache_set_cache_textures_157, METH_O, (const char *)Dtool_BamCache_set_cache_textures_157_comment},
  {"get_cache_textures", &Dtool_BamCache_get_cache_textures_158, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_textures_158_comment},
  {"getCacheTextures", &Dtool_BamCache_get_cache_textures_158, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_textures_158_comment},
  {"set_cache_compressed_textures", &Dtool_BamCache_set_cache_compressed_textures_159, METH_O, (const char *)Dtool_BamCache_set_cache_compressed_textures_159_comment},
  {"setCacheCompressedTextures", &Dtool_BamCache_set_cache_compressed_textures_159, METH_O, (const char *)Dtool_BamCache_set_cache_compressed_textures_159_comment},
  {"get_cache_compressed_textures", &Dtool_BamCache_get_cache_compressed_textures_160, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_compressed_textures_160_comment},
  {"getCacheCompressedTextures", &Dtool_BamCache_get_cache_compressed_textures_160, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_compressed_textures_160_comment},
  {"set_cache_compiled_shaders", &Dtool_BamCache_set_cache_compiled_shaders_161, METH_O, (const char *)Dtool_BamCache_set_cache_compiled_shaders_161_comment},
  {"setCacheCompiledShaders", &Dtool_BamCache_set_cache_compiled_shaders_161, METH_O, (const char *)Dtool_BamCache_set_cache_compiled_shaders_161_comment},
  {"get_cache_compiled_shaders", &Dtool_BamCache_get_cache_compiled_shaders_162, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_compiled_shaders_162_comment},
  {"getCacheCompiledShaders", &Dtool_BamCache_get_cache_compiled_shaders_162, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_compiled_shaders_162_comment},
  {"set_root", &Dtool_BamCache_set_root_163, METH_O, (const char *)Dtool_BamCache_set_root_163_comment},
  {"setRoot", &Dtool_BamCache_set_root_163, METH_O, (const char *)Dtool_BamCache_set_root_163_comment},
  {"get_root", &Dtool_BamCache_get_root_164, METH_NOARGS, (const char *)Dtool_BamCache_get_root_164_comment},
  {"getRoot", &Dtool_BamCache_get_root_164, METH_NOARGS, (const char *)Dtool_BamCache_get_root_164_comment},
  {"set_flush_time", &Dtool_BamCache_set_flush_time_165, METH_O, (const char *)Dtool_BamCache_set_flush_time_165_comment},
  {"setFlushTime", &Dtool_BamCache_set_flush_time_165, METH_O, (const char *)Dtool_BamCache_set_flush_time_165_comment},
  {"get_flush_time", &Dtool_BamCache_get_flush_time_166, METH_NOARGS, (const char *)Dtool_BamCache_get_flush_time_166_comment},
  {"getFlushTime", &Dtool_BamCache_get_flush_time_166, METH_NOARGS, (const char *)Dtool_BamCache_get_flush_time_166_comment},
  {"set_cache_max_kbytes", &Dtool_BamCache_set_cache_max_kbytes_167, METH_O, (const char *)Dtool_BamCache_set_cache_max_kbytes_167_comment},
  {"setCacheMaxKbytes", &Dtool_BamCache_set_cache_max_kbytes_167, METH_O, (const char *)Dtool_BamCache_set_cache_max_kbytes_167_comment},
  {"get_cache_max_kbytes", &Dtool_BamCache_get_cache_max_kbytes_168, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_max_kbytes_168_comment},
  {"getCacheMaxKbytes", &Dtool_BamCache_get_cache_max_kbytes_168, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_max_kbytes_168_comment},
  {"set_read_only", &Dtool_BamCache_set_read_only_169, METH_O, (const char *)Dtool_BamCache_set_read_only_169_comment},
  {"setReadOnly", &Dtool_BamCache_set_read_only_169, METH_O, (const char *)Dtool_BamCache_set_read_only_169_comment},
  {"get_read_only", &Dtool_BamCache_get_read_only_170, METH_NOARGS, (const char *)Dtool_BamCache_get_read_only_170_comment},
  {"getReadOnly", &Dtool_BamCache_get_read_only_170, METH_NOARGS, (const char *)Dtool_BamCache_get_read_only_170_comment},
  {"lookup", (PyCFunction) &Dtool_BamCache_lookup_171, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamCache_lookup_171_comment},
  {"store", &Dtool_BamCache_store_172, METH_O, (const char *)Dtool_BamCache_store_172_comment},
  {"consider_flush_index", &Dtool_BamCache_consider_flush_index_173, METH_NOARGS, (const char *)Dtool_BamCache_consider_flush_index_173_comment},
  {"considerFlushIndex", &Dtool_BamCache_consider_flush_index_173, METH_NOARGS, (const char *)Dtool_BamCache_consider_flush_index_173_comment},
  {"flush_index", &Dtool_BamCache_flush_index_174, METH_NOARGS, (const char *)Dtool_BamCache_flush_index_174_comment},
  {"flushIndex", &Dtool_BamCache_flush_index_174, METH_NOARGS, (const char *)Dtool_BamCache_flush_index_174_comment},
  {"list_index", (PyCFunction) &Dtool_BamCache_list_index_175, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamCache_list_index_175_comment},
  {"listIndex", (PyCFunction) &Dtool_BamCache_list_index_175, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamCache_list_index_175_comment},
  {"get_global_ptr", &Dtool_BamCache_get_global_ptr_176, METH_NOARGS | METH_STATIC, (const char *)Dtool_BamCache_get_global_ptr_176_comment},
  {"getGlobalPtr", &Dtool_BamCache_get_global_ptr_176, METH_NOARGS | METH_STATIC, (const char *)Dtool_BamCache_get_global_ptr_176_comment},
  {"consider_flush_global_index", &Dtool_BamCache_consider_flush_global_index_177, METH_NOARGS | METH_STATIC, (const char *)Dtool_BamCache_consider_flush_global_index_177_comment},
  {"considerFlushGlobalIndex", &Dtool_BamCache_consider_flush_global_index_177, METH_NOARGS | METH_STATIC, (const char *)Dtool_BamCache_consider_flush_global_index_177_comment},
  {"flush_global_index", &Dtool_BamCache_flush_global_index_178, METH_NOARGS | METH_STATIC, (const char *)Dtool_BamCache_flush_global_index_178_comment},
  {"flushGlobalIndex", &Dtool_BamCache_flush_global_index_178, METH_NOARGS | METH_STATIC, (const char *)Dtool_BamCache_flush_global_index_178_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_BamCache[] = {
  {(char *)"active", &Dtool_BamCache_active_Getter, &Dtool_BamCache_active_Setter, NULL, NULL},
  {(char *)"cache_models", &Dtool_BamCache_cache_models_Getter, &Dtool_BamCache_cache_models_Setter, NULL, NULL},
  {(char *)"cache_textures", &Dtool_BamCache_cache_textures_Getter, &Dtool_BamCache_cache_textures_Setter, NULL, NULL},
  {(char *)"cache_compressed_textures", &Dtool_BamCache_cache_compressed_textures_Getter, &Dtool_BamCache_cache_compressed_textures_Setter, NULL, NULL},
  {(char *)"cache_compiled_shaders", &Dtool_BamCache_cache_compiled_shaders_Getter, &Dtool_BamCache_cache_compiled_shaders_Setter, NULL, NULL},
  {(char *)"root", &Dtool_BamCache_root_Getter, &Dtool_BamCache_root_Setter, NULL, NULL},
  {(char *)"flush_time", &Dtool_BamCache_flush_time_Getter, &Dtool_BamCache_flush_time_Setter, NULL, NULL},
  {(char *)"cache_max_kbytes", &Dtool_BamCache_cache_max_kbytes_Getter, &Dtool_BamCache_cache_max_kbytes_Setter, NULL, NULL},
  {(char *)"read_only", &Dtool_BamCache_read_only_Getter, &Dtool_BamCache_read_only_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_BamCache = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_BamCache = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.BamCache",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BamCache,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_BamCache,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class maintains a cache of Bam and/or Txo objects generated from model\n"
    " * files and texture images (as well as possibly other kinds of loadable\n"
    " * objects that can be stored in bam file format).\n"
    " *\n"
    " * This class also maintains a persistent index that lists all of the cached\n"
    " * objects (see BamCacheIndex). We go through some considerable effort to make\n"
    " * sure this index gets saved correctly to disk, even in the presence of\n"
    " * multiple different processes writing to the same index, and without relying\n"
    " * too heavily on low-level os-provided file locks (which work poorly with C++\n"
    " * iostreams).\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BamCache,
    0, // tp_members
    Dtool_Properties_BamCache,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BamCache,
    PyType_GenericAlloc,
    Dtool_new_BamCache,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BamCache,
  Dtool_UpcastInterface_BamCache,
  Dtool_DowncastInterface_BamCache,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_BamCache(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_BamCache._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_BamCache._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BamCache) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BamCache)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BamCache);
  }
}

/**
 * Python method tables for BamEnums (BamEnums)
 */
static PyMethodDef Dtool_Methods_BamEnums[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_BamEnums = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_BamEnums = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.BamEnums",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BamEnums,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_BamEnums,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class exists just to provide scoping for the enums shared by BamReader\n"
    " * and BamWriter.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BamEnums,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BamEnums,
    PyType_GenericAlloc,
    Dtool_new_BamEnums,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BamEnums,
  Dtool_UpcastInterface_BamEnums,
  Dtool_DowncastInterface_BamEnums,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_BamEnums(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_BamEnums._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(27);
    Dtool_BamEnums._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum BamEnums::BamEndian;
    PyDict_SetItemString(dict, "BE_bigendian", Dtool_WrapValue(BamEnums::BE_bigendian));
    PyDict_SetItemString(dict, "BEBigendian", Dtool_WrapValue(BamEnums::BE_bigendian));
    PyDict_SetItemString(dict, "BE_littleendian", Dtool_WrapValue(BamEnums::BE_littleendian));
    PyDict_SetItemString(dict, "BELittleendian", Dtool_WrapValue(BamEnums::BE_littleendian));
    PyDict_SetItemString(dict, "BE_native", Dtool_WrapValue(BamEnums::BE_native));
    PyDict_SetItemString(dict, "BENative", Dtool_WrapValue(BamEnums::BE_native));
    // enum BamEnums::BamObjectCode;
    PyDict_SetItemString(dict, "BOC_push", Dtool_WrapValue(BamEnums::BOC_push));
    PyDict_SetItemString(dict, "BOCPush", Dtool_WrapValue(BamEnums::BOC_push));
    PyDict_SetItemString(dict, "BOC_pop", Dtool_WrapValue(BamEnums::BOC_pop));
    PyDict_SetItemString(dict, "BOCPop", Dtool_WrapValue(BamEnums::BOC_pop));
    PyDict_SetItemString(dict, "BOC_adjunct", Dtool_WrapValue(BamEnums::BOC_adjunct));
    PyDict_SetItemString(dict, "BOCAdjunct", Dtool_WrapValue(BamEnums::BOC_adjunct));
    PyDict_SetItemString(dict, "BOC_remove", Dtool_WrapValue(BamEnums::BOC_remove));
    PyDict_SetItemString(dict, "BOCRemove", Dtool_WrapValue(BamEnums::BOC_remove));
    PyDict_SetItemString(dict, "BOC_file_data", Dtool_WrapValue(BamEnums::BOC_file_data));
    PyDict_SetItemString(dict, "BOCFileData", Dtool_WrapValue(BamEnums::BOC_file_data));
    // enum BamEnums::BamTextureMode;
    PyDict_SetItemString(dict, "BTM_unchanged", Dtool_WrapValue(BamEnums::BTM_unchanged));
    PyDict_SetItemString(dict, "BTMUnchanged", Dtool_WrapValue(BamEnums::BTM_unchanged));
    PyDict_SetItemString(dict, "BTM_fullpath", Dtool_WrapValue(BamEnums::BTM_fullpath));
    PyDict_SetItemString(dict, "BTMFullpath", Dtool_WrapValue(BamEnums::BTM_fullpath));
    PyDict_SetItemString(dict, "BTM_relative", Dtool_WrapValue(BamEnums::BTM_relative));
    PyDict_SetItemString(dict, "BTMRelative", Dtool_WrapValue(BamEnums::BTM_relative));
    PyDict_SetItemString(dict, "BTM_basename", Dtool_WrapValue(BamEnums::BTM_basename));
    PyDict_SetItemString(dict, "BTMBasename", Dtool_WrapValue(BamEnums::BTM_basename));
    PyDict_SetItemString(dict, "BTM_rawdata", Dtool_WrapValue(BamEnums::BTM_rawdata));
    PyDict_SetItemString(dict, "BTMRawdata", Dtool_WrapValue(BamEnums::BTM_rawdata));
    if (PyType_Ready((PyTypeObject *)&Dtool_BamEnums) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BamEnums)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BamEnums);
  }
}

/**
 * Python method tables for LoaderOptions (LoaderOptions)
 */
static PyMethodDef Dtool_Methods_LoaderOptions[] = {
  {"assign", &Dtool_LoaderOptions_operator_198, METH_O, (const char *)Dtool_LoaderOptions_operator_198_comment},
  {"set_flags", &Dtool_LoaderOptions_set_flags_199, METH_O, (const char *)Dtool_LoaderOptions_set_flags_199_comment},
  {"setFlags", &Dtool_LoaderOptions_set_flags_199, METH_O, (const char *)Dtool_LoaderOptions_set_flags_199_comment},
  {"get_flags", &Dtool_LoaderOptions_get_flags_200, METH_NOARGS, (const char *)Dtool_LoaderOptions_get_flags_200_comment},
  {"getFlags", &Dtool_LoaderOptions_get_flags_200, METH_NOARGS, (const char *)Dtool_LoaderOptions_get_flags_200_comment},
  {"set_texture_flags", &Dtool_LoaderOptions_set_texture_flags_202, METH_O, (const char *)Dtool_LoaderOptions_set_texture_flags_202_comment},
  {"setTextureFlags", &Dtool_LoaderOptions_set_texture_flags_202, METH_O, (const char *)Dtool_LoaderOptions_set_texture_flags_202_comment},
  {"get_texture_flags", &Dtool_LoaderOptions_get_texture_flags_203, METH_NOARGS, (const char *)Dtool_LoaderOptions_get_texture_flags_203_comment},
  {"getTextureFlags", &Dtool_LoaderOptions_get_texture_flags_203, METH_NOARGS, (const char *)Dtool_LoaderOptions_get_texture_flags_203_comment},
  {"set_texture_num_views", &Dtool_LoaderOptions_set_texture_num_views_204, METH_O, (const char *)Dtool_LoaderOptions_set_texture_num_views_204_comment},
  {"setTextureNumViews", &Dtool_LoaderOptions_set_texture_num_views_204, METH_O, (const char *)Dtool_LoaderOptions_set_texture_num_views_204_comment},
  {"get_texture_num_views", &Dtool_LoaderOptions_get_texture_num_views_205, METH_NOARGS, (const char *)Dtool_LoaderOptions_get_texture_num_views_205_comment},
  {"getTextureNumViews", &Dtool_LoaderOptions_get_texture_num_views_205, METH_NOARGS, (const char *)Dtool_LoaderOptions_get_texture_num_views_205_comment},
  {"set_auto_texture_scale", &Dtool_LoaderOptions_set_auto_texture_scale_208, METH_O, (const char *)Dtool_LoaderOptions_set_auto_texture_scale_208_comment},
  {"setAutoTextureScale", &Dtool_LoaderOptions_set_auto_texture_scale_208, METH_O, (const char *)Dtool_LoaderOptions_set_auto_texture_scale_208_comment},
  {"get_auto_texture_scale", &Dtool_LoaderOptions_get_auto_texture_scale_209, METH_NOARGS, (const char *)Dtool_LoaderOptions_get_auto_texture_scale_209_comment},
  {"getAutoTextureScale", &Dtool_LoaderOptions_get_auto_texture_scale_209, METH_NOARGS, (const char *)Dtool_LoaderOptions_get_auto_texture_scale_209_comment},
  {"output", &Dtool_LoaderOptions_output_211, METH_O, (const char *)Dtool_LoaderOptions_output_211_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     LoaderOptions
//////////////////
static PyObject *Dtool_Repr_LoaderOptions(PyObject *self) {
  LoaderOptions *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LoaderOptions, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_LoaderOptions[] = {
  {(char *)"flags", &Dtool_LoaderOptions_flags_Getter, &Dtool_LoaderOptions_flags_Setter, NULL, NULL},
  {(char *)"texture_flags", &Dtool_LoaderOptions_texture_flags_Getter, &Dtool_LoaderOptions_texture_flags_Setter, NULL, NULL},
  {(char *)"texture_num_views", &Dtool_LoaderOptions_texture_num_views_Getter, &Dtool_LoaderOptions_texture_num_views_Setter, NULL, NULL},
  {(char *)"auto_texture_scale", &Dtool_LoaderOptions_auto_texture_scale_Getter, &Dtool_LoaderOptions_auto_texture_scale_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LoaderOptions = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_LoaderOptions = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LoaderOptions",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LoaderOptions,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_LoaderOptions,
    &Dtool_NumberMethods_LoaderOptions,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_LoaderOptions,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Specifies parameters that may be passed to the loader.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LoaderOptions,
    0, // tp_members
    Dtool_Properties_LoaderOptions,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LoaderOptions,
    PyType_GenericAlloc,
    Dtool_new_LoaderOptions,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LoaderOptions,
  Dtool_UpcastInterface_LoaderOptions,
  Dtool_DowncastInterface_LoaderOptions,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LoaderOptions,
};

static void Dtool_PyModuleClassInit_LoaderOptions(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LoaderOptions._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(37);
    Dtool_LoaderOptions._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LoaderOptions::LoaderFlags;
    PyDict_SetItemString(dict, "LF_search", Dtool_WrapValue(LoaderOptions::LF_search));
    PyDict_SetItemString(dict, "LFSearch", Dtool_WrapValue(LoaderOptions::LF_search));
    PyDict_SetItemString(dict, "LF_report_errors", Dtool_WrapValue(LoaderOptions::LF_report_errors));
    PyDict_SetItemString(dict, "LFReportErrors", Dtool_WrapValue(LoaderOptions::LF_report_errors));
    PyDict_SetItemString(dict, "LF_convert_skeleton", Dtool_WrapValue(LoaderOptions::LF_convert_skeleton));
    PyDict_SetItemString(dict, "LFConvertSkeleton", Dtool_WrapValue(LoaderOptions::LF_convert_skeleton));
    PyDict_SetItemString(dict, "LF_convert_channels", Dtool_WrapValue(LoaderOptions::LF_convert_channels));
    PyDict_SetItemString(dict, "LFConvertChannels", Dtool_WrapValue(LoaderOptions::LF_convert_channels));
    PyDict_SetItemString(dict, "LF_convert_anim", Dtool_WrapValue(LoaderOptions::LF_convert_anim));
    PyDict_SetItemString(dict, "LFConvertAnim", Dtool_WrapValue(LoaderOptions::LF_convert_anim));
    PyDict_SetItemString(dict, "LF_no_disk_cache", Dtool_WrapValue(LoaderOptions::LF_no_disk_cache));
    PyDict_SetItemString(dict, "LFNoDiskCache", Dtool_WrapValue(LoaderOptions::LF_no_disk_cache));
    PyDict_SetItemString(dict, "LF_no_ram_cache", Dtool_WrapValue(LoaderOptions::LF_no_ram_cache));
    PyDict_SetItemString(dict, "LFNoRamCache", Dtool_WrapValue(LoaderOptions::LF_no_ram_cache));
    PyDict_SetItemString(dict, "LF_no_cache", Dtool_WrapValue(LoaderOptions::LF_no_cache));
    PyDict_SetItemString(dict, "LFNoCache", Dtool_WrapValue(LoaderOptions::LF_no_cache));
    PyDict_SetItemString(dict, "LF_cache_only", Dtool_WrapValue(LoaderOptions::LF_cache_only));
    PyDict_SetItemString(dict, "LFCacheOnly", Dtool_WrapValue(LoaderOptions::LF_cache_only));
    PyDict_SetItemString(dict, "LF_allow_instance", Dtool_WrapValue(LoaderOptions::LF_allow_instance));
    PyDict_SetItemString(dict, "LFAllowInstance", Dtool_WrapValue(LoaderOptions::LF_allow_instance));
    // enum LoaderOptions::TextureFlags;
    PyDict_SetItemString(dict, "TF_preload", Dtool_WrapValue(LoaderOptions::TF_preload));
    PyDict_SetItemString(dict, "TFPreload", Dtool_WrapValue(LoaderOptions::TF_preload));
    PyDict_SetItemString(dict, "TF_preload_simple", Dtool_WrapValue(LoaderOptions::TF_preload_simple));
    PyDict_SetItemString(dict, "TFPreloadSimple", Dtool_WrapValue(LoaderOptions::TF_preload_simple));
    PyDict_SetItemString(dict, "TF_allow_1d", Dtool_WrapValue(LoaderOptions::TF_allow_1d));
    PyDict_SetItemString(dict, "TFAllow1d", Dtool_WrapValue(LoaderOptions::TF_allow_1d));
    PyDict_SetItemString(dict, "TF_generate_mipmaps", Dtool_WrapValue(LoaderOptions::TF_generate_mipmaps));
    PyDict_SetItemString(dict, "TFGenerateMipmaps", Dtool_WrapValue(LoaderOptions::TF_generate_mipmaps));
    PyDict_SetItemString(dict, "TF_multiview", Dtool_WrapValue(LoaderOptions::TF_multiview));
    PyDict_SetItemString(dict, "TFMultiview", Dtool_WrapValue(LoaderOptions::TF_multiview));
    PyDict_SetItemString(dict, "TF_integer", Dtool_WrapValue(LoaderOptions::TF_integer));
    PyDict_SetItemString(dict, "TFInteger", Dtool_WrapValue(LoaderOptions::TF_integer));
    PyDict_SetItemString(dict, "TF_float", Dtool_WrapValue(LoaderOptions::TF_float));
    PyDict_SetItemString(dict, "TFFloat", Dtool_WrapValue(LoaderOptions::TF_float));
    PyDict_SetItemString(dict, "TF_allow_compression", Dtool_WrapValue(LoaderOptions::TF_allow_compression));
    PyDict_SetItemString(dict, "TFAllowCompression", Dtool_WrapValue(LoaderOptions::TF_allow_compression));
    if (PyType_Ready((PyTypeObject *)&Dtool_LoaderOptions) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LoaderOptions)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LoaderOptions);
  }
}

/**
 * Python method tables for BamReader (BamReader)
 */
static PyMethodDef Dtool_Methods_BamReader[] = {
  {"set_source", &Dtool_BamReader_set_source_216, METH_O, (const char *)Dtool_BamReader_set_source_216_comment},
  {"setSource", &Dtool_BamReader_set_source_216, METH_O, (const char *)Dtool_BamReader_set_source_216_comment},
  {"get_source", &Dtool_BamReader_get_source_217, METH_NOARGS, (const char *)Dtool_BamReader_get_source_217_comment},
  {"getSource", &Dtool_BamReader_get_source_217, METH_NOARGS, (const char *)Dtool_BamReader_get_source_217_comment},
  {"init", &Dtool_BamReader_init_218, METH_NOARGS, (const char *)Dtool_BamReader_init_218_comment},
  {"get_filename", &Dtool_BamReader_get_filename_221, METH_NOARGS, (const char *)Dtool_BamReader_get_filename_221_comment},
  {"getFilename", &Dtool_BamReader_get_filename_221, METH_NOARGS, (const char *)Dtool_BamReader_get_filename_221_comment},
  {"get_loader_options", &Dtool_BamReader_get_loader_options_222, METH_NOARGS, (const char *)Dtool_BamReader_get_loader_options_222_comment},
  {"getLoaderOptions", &Dtool_BamReader_get_loader_options_222, METH_NOARGS, (const char *)Dtool_BamReader_get_loader_options_222_comment},
  {"set_loader_options", &Dtool_BamReader_set_loader_options_223, METH_O, (const char *)Dtool_BamReader_set_loader_options_223_comment},
  {"setLoaderOptions", &Dtool_BamReader_set_loader_options_223, METH_O, (const char *)Dtool_BamReader_set_loader_options_223_comment},
  {"read_object", &Dtool_BamReader_read_object_224, METH_NOARGS, (const char *)Dtool_BamReader_read_object_224_comment},
  {"readObject", &Dtool_BamReader_read_object_224, METH_NOARGS, (const char *)Dtool_BamReader_read_object_224_comment},
  {"is_eof", &Dtool_BamReader_is_eof_225, METH_NOARGS, (const char *)Dtool_BamReader_is_eof_225_comment},
  {"isEof", &Dtool_BamReader_is_eof_225, METH_NOARGS, (const char *)Dtool_BamReader_is_eof_225_comment},
  {"resolve", &Dtool_BamReader_resolve_226, METH_NOARGS, (const char *)Dtool_BamReader_resolve_226_comment},
  {"change_pointer", (PyCFunction) &Dtool_BamReader_change_pointer_227, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamReader_change_pointer_227_comment},
  {"changePointer", (PyCFunction) &Dtool_BamReader_change_pointer_227, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamReader_change_pointer_227_comment},
  {"get_file_major_ver", &Dtool_BamReader_get_file_major_ver_228, METH_NOARGS, (const char *)Dtool_BamReader_get_file_major_ver_228_comment},
  {"getFileMajorVer", &Dtool_BamReader_get_file_major_ver_228, METH_NOARGS, (const char *)Dtool_BamReader_get_file_major_ver_228_comment},
  {"get_file_minor_ver", &Dtool_BamReader_get_file_minor_ver_229, METH_NOARGS, (const char *)Dtool_BamReader_get_file_minor_ver_229_comment},
  {"getFileMinorVer", &Dtool_BamReader_get_file_minor_ver_229, METH_NOARGS, (const char *)Dtool_BamReader_get_file_minor_ver_229_comment},
  {"get_file_endian", &Dtool_BamReader_get_file_endian_230, METH_NOARGS, (const char *)Dtool_BamReader_get_file_endian_230_comment},
  {"getFileEndian", &Dtool_BamReader_get_file_endian_230, METH_NOARGS, (const char *)Dtool_BamReader_get_file_endian_230_comment},
  {"get_file_stdfloat_double", &Dtool_BamReader_get_file_stdfloat_double_231, METH_NOARGS, (const char *)Dtool_BamReader_get_file_stdfloat_double_231_comment},
  {"getFileStdfloatDouble", &Dtool_BamReader_get_file_stdfloat_double_231, METH_NOARGS, (const char *)Dtool_BamReader_get_file_stdfloat_double_231_comment},
  {"get_current_major_ver", &Dtool_BamReader_get_current_major_ver_232, METH_NOARGS, (const char *)Dtool_BamReader_get_current_major_ver_232_comment},
  {"getCurrentMajorVer", &Dtool_BamReader_get_current_major_ver_232, METH_NOARGS, (const char *)Dtool_BamReader_get_current_major_ver_232_comment},
  {"get_current_minor_ver", &Dtool_BamReader_get_current_minor_ver_233, METH_NOARGS, (const char *)Dtool_BamReader_get_current_minor_ver_233_comment},
  {"getCurrentMinorVer", &Dtool_BamReader_get_current_minor_ver_233, METH_NOARGS, (const char *)Dtool_BamReader_get_current_minor_ver_233_comment},
  {"get_file_version", &Dtool_BamReader_get_file_version_234, METH_NOARGS, (const char *)Dtool_BamReader_get_file_version_234_comment},
  {"getFileVersion", &Dtool_BamReader_get_file_version_234, METH_NOARGS, (const char *)Dtool_BamReader_get_file_version_234_comment},
  {"register_factory", (PyCFunction) &Dtool_BamReader_register_factory_247, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_BamReader_register_factory_247_comment},
  {"registerFactory", (PyCFunction) &Dtool_BamReader_register_factory_247, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_BamReader_register_factory_247_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_BamReader[] = {
  {(char *)"source", &Dtool_BamReader_source_Getter, &Dtool_BamReader_source_Setter, NULL, NULL},
  {(char *)"filename", &Dtool_BamReader_filename_Getter, NULL, NULL, NULL},
  {(char *)"loader_options", &Dtool_BamReader_loader_options_Getter, &Dtool_BamReader_loader_options_Setter, NULL, NULL},
  {(char *)"file_version", &Dtool_BamReader_file_version_Getter, NULL, NULL, NULL},
  {(char *)"file_endian", &Dtool_BamReader_file_endian_Getter, NULL, NULL, NULL},
  {(char *)"file_stdfloat_double", &Dtool_BamReader_file_stdfloat_double_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_BamReader = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BamReader = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_BamReader = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_BamReader = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_BamReader = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.BamReader",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BamReader,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_BamReader,
    &Dtool_SequenceMethods_BamReader,
    &Dtool_MappingMethods_BamReader,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_BamReader,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the fundamental interface for extracting binary objects from a Bam\n"
    " * file, as generated by a BamWriter.\n"
    " *\n"
    " * A Bam file can be thought of as a linear collection of objects.  Each\n"
    " * object is an instance of a class that inherits, directly or indirectly,\n"
    " * from TypedWritable.  The objects may include pointers to other objects\n"
    " * within the Bam file; the BamReader automatically manages these (with help\n"
    " * from code within each class) and restores the pointers correctly.\n"
    " *\n"
    " * This is the abstract interface and does not specifically deal with disk\n"
    " * files, but rather with a DatagramGenerator of some kind, which is simply a\n"
    " * linear source of Datagrams.  It is probably from a disk file, but it might\n"
    " * conceivably be streamed directly from a network or some such nonsense.\n"
    " *\n"
    " * Bam files are most often used to store scene graphs or subgraphs, and by\n"
    " * convention they are given filenames ending in the extension \".bam\" when\n"
    " * they are used for this purpose.  However, a Bam file may store any\n"
    " * arbitrary list of TypedWritable objects; in this more general usage, they\n"
    " * are given filenames ending in \".boo\" to differentiate them from the more\n"
    " * common scene graph files.\n"
    " *\n"
    " * See also BamFile, which defines a higher-level interface to read and write\n"
    " * Bam files on disk.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BamReader,
    0, // tp_members
    Dtool_Properties_BamReader,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BamReader,
    PyType_GenericAlloc,
    Dtool_new_BamReader,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BamReader,
  Dtool_UpcastInterface_BamReader,
  Dtool_DowncastInterface_BamReader,
  (CoerceFunction)Dtool_ConstCoerce_BamReader,
  (CoerceFunction)Dtool_Coerce_BamReader,
};

static void Dtool_PyModuleClassInit_BamReader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BamEnums(NULL);
    Dtool_BamReader._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BamEnums);
    PyObject *dict = PyDict_New();
    Dtool_BamReader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BamReader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BamReader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BamReader);
  }
}

/**
 * Python method tables for BamWriter (BamWriter)
 */
static PyMethodDef Dtool_Methods_BamWriter[] = {
  {"set_target", &Dtool_BamWriter_set_target_251, METH_O, (const char *)Dtool_BamWriter_set_target_251_comment},
  {"setTarget", &Dtool_BamWriter_set_target_251, METH_O, (const char *)Dtool_BamWriter_set_target_251_comment},
  {"get_target", &Dtool_BamWriter_get_target_252, METH_NOARGS, (const char *)Dtool_BamWriter_get_target_252_comment},
  {"getTarget", &Dtool_BamWriter_get_target_252, METH_NOARGS, (const char *)Dtool_BamWriter_get_target_252_comment},
  {"init", &Dtool_BamWriter_init_253, METH_NOARGS, (const char *)Dtool_BamWriter_init_253_comment},
  {"get_filename", &Dtool_BamWriter_get_filename_254, METH_NOARGS, (const char *)Dtool_BamWriter_get_filename_254_comment},
  {"getFilename", &Dtool_BamWriter_get_filename_254, METH_NOARGS, (const char *)Dtool_BamWriter_get_filename_254_comment},
  {"write_object", &Dtool_BamWriter_write_object_255, METH_O, (const char *)Dtool_BamWriter_write_object_255_comment},
  {"writeObject", &Dtool_BamWriter_write_object_255, METH_O, (const char *)Dtool_BamWriter_write_object_255_comment},
  {"has_object", &Dtool_BamWriter_has_object_256, METH_O, (const char *)Dtool_BamWriter_has_object_256_comment},
  {"hasObject", &Dtool_BamWriter_has_object_256, METH_O, (const char *)Dtool_BamWriter_has_object_256_comment},
  {"flush", &Dtool_BamWriter_flush_257, METH_NOARGS, (const char *)Dtool_BamWriter_flush_257_comment},
  {"get_file_major_ver", &Dtool_BamWriter_get_file_major_ver_258, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_major_ver_258_comment},
  {"getFileMajorVer", &Dtool_BamWriter_get_file_major_ver_258, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_major_ver_258_comment},
  {"get_file_minor_ver", &Dtool_BamWriter_get_file_minor_ver_259, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_minor_ver_259_comment},
  {"getFileMinorVer", &Dtool_BamWriter_get_file_minor_ver_259, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_minor_ver_259_comment},
  {"set_file_minor_ver", &Dtool_BamWriter_set_file_minor_ver_260, METH_O, (const char *)Dtool_BamWriter_set_file_minor_ver_260_comment},
  {"setFileMinorVer", &Dtool_BamWriter_set_file_minor_ver_260, METH_O, (const char *)Dtool_BamWriter_set_file_minor_ver_260_comment},
  {"get_file_endian", &Dtool_BamWriter_get_file_endian_261, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_endian_261_comment},
  {"getFileEndian", &Dtool_BamWriter_get_file_endian_261, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_endian_261_comment},
  {"get_file_stdfloat_double", &Dtool_BamWriter_get_file_stdfloat_double_262, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_stdfloat_double_262_comment},
  {"getFileStdfloatDouble", &Dtool_BamWriter_get_file_stdfloat_double_262, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_stdfloat_double_262_comment},
  {"get_file_texture_mode", &Dtool_BamWriter_get_file_texture_mode_263, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_texture_mode_263_comment},
  {"getFileTextureMode", &Dtool_BamWriter_get_file_texture_mode_263, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_texture_mode_263_comment},
  {"set_file_texture_mode", &Dtool_BamWriter_set_file_texture_mode_264, METH_O, (const char *)Dtool_BamWriter_set_file_texture_mode_264_comment},
  {"setFileTextureMode", &Dtool_BamWriter_set_file_texture_mode_264, METH_O, (const char *)Dtool_BamWriter_set_file_texture_mode_264_comment},
  {"get_root_node", &Dtool_BamWriter_get_root_node_265, METH_NOARGS, (const char *)Dtool_BamWriter_get_root_node_265_comment},
  {"getRootNode", &Dtool_BamWriter_get_root_node_265, METH_NOARGS, (const char *)Dtool_BamWriter_get_root_node_265_comment},
  {"set_root_node", &Dtool_BamWriter_set_root_node_266, METH_O, (const char *)Dtool_BamWriter_set_root_node_266_comment},
  {"setRootNode", &Dtool_BamWriter_set_root_node_266, METH_O, (const char *)Dtool_BamWriter_set_root_node_266_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_BamWriter[] = {
  {(char *)"target", &Dtool_BamWriter_target_Getter, &Dtool_BamWriter_target_Setter, NULL, NULL},
  {(char *)"filename", &Dtool_BamWriter_filename_Getter, NULL, NULL, NULL},
  {(char *)"file_endian", &Dtool_BamWriter_file_endian_Getter, NULL, NULL, NULL},
  {(char *)"file_stdfloat_double", &Dtool_BamWriter_file_stdfloat_double_Getter, NULL, NULL, NULL},
  {(char *)"file_texture_mode", &Dtool_BamWriter_file_texture_mode_Getter, NULL, NULL, NULL},
  {(char *)"root_node", &Dtool_BamWriter_root_node_Getter, &Dtool_BamWriter_root_node_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_BamWriter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BamWriter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_BamWriter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_BamWriter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_BamWriter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.BamWriter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BamWriter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_BamWriter,
    &Dtool_SequenceMethods_BamWriter,
    &Dtool_MappingMethods_BamWriter,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_BamWriter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the fundamental interface for writing binary objects to a Bam file,\n"
    " * to be extracted later by a BamReader.\n"
    " *\n"
    " * A Bam file can be thought of as a linear collection of objects.  Each\n"
    " * object is an instance of a class that inherits, directly or indirectly,\n"
    " * from TypedWritable.  The objects may include pointers to other objects; the\n"
    " * BamWriter automatically manages these (with help from code within each\n"
    " * class) and writes all referenced objects to the file in such a way that the\n"
    " * pointers may be correctly restored later.\n"
    " *\n"
    " * This is the abstract interface and does not specifically deal with disk\n"
    " * files, but rather with a DatagramSink of some kind, which simply accepts a\n"
    " * linear stream of Datagrams.  It is probably written to a disk file, but it\n"
    " * might conceivably be streamed directly to a network or some such nonsense.\n"
    " *\n"
    " * Bam files are most often used to store scene graphs or subgraphs, and by\n"
    " * convention they are given filenames ending in the extension \".bam\" when\n"
    " * they are used for this purpose.  However, a Bam file may store any\n"
    " * arbitrary list of TypedWritable objects; in this more general usage, they\n"
    " * are given filenames ending in \".boo\" to differentiate them from the more\n"
    " * common scene graph files.\n"
    " *\n"
    " * See also BamFile, which defines a higher-level interface to read and write\n"
    " * Bam files on disk.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BamWriter,
    0, // tp_members
    Dtool_Properties_BamWriter,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BamWriter,
    PyType_GenericAlloc,
    Dtool_new_BamWriter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BamWriter,
  Dtool_UpcastInterface_BamWriter,
  Dtool_DowncastInterface_BamWriter,
  (CoerceFunction)Dtool_ConstCoerce_BamWriter,
  (CoerceFunction)Dtool_Coerce_BamWriter,
};

static void Dtool_PyModuleClassInit_BamWriter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BamEnums(NULL);
    Dtool_BamWriter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BamEnums);
    PyObject *dict = PyDict_New();
    Dtool_BamWriter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BamWriter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BamWriter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BamWriter);
  }
}

/**
 * Python method tables for BitMask_uint16_t_16 (BitMask_uint16_t_16)
 */
static PyMethodDef Dtool_Methods_BitMask_uint16_t_16[] = {
  {"assign", &Dtool_BitMask_uint16_t_16_operator_277, METH_O, (const char *)Dtool_BitMask_uint16_t_16_operator_277_comment},
  {"all_on", &Dtool_BitMask_uint16_t_16_all_on_278, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_all_on_278_comment},
  {"allOn", &Dtool_BitMask_uint16_t_16_all_on_278, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_all_on_278_comment},
  {"all_off", &Dtool_BitMask_uint16_t_16_all_off_279, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_all_off_279_comment},
  {"allOff", &Dtool_BitMask_uint16_t_16_all_off_279, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_all_off_279_comment},
  {"lower_on", &Dtool_BitMask_uint16_t_16_lower_on_280, METH_O | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_lower_on_280_comment},
  {"lowerOn", &Dtool_BitMask_uint16_t_16_lower_on_280, METH_O | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_lower_on_280_comment},
  {"bit", &Dtool_BitMask_uint16_t_16_bit_281, METH_O | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_bit_281_comment},
  {"range", (PyCFunction) &Dtool_BitMask_uint16_t_16_range_282, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_range_282_comment},
  {"has_max_num_bits", &Dtool_BitMask_uint16_t_16_has_max_num_bits_284, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_has_max_num_bits_284_comment},
  {"hasMaxNumBits", &Dtool_BitMask_uint16_t_16_has_max_num_bits_284, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_has_max_num_bits_284_comment},
  {"get_max_num_bits", &Dtool_BitMask_uint16_t_16_get_max_num_bits_285, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_get_max_num_bits_285_comment},
  {"getMaxNumBits", &Dtool_BitMask_uint16_t_16_get_max_num_bits_285, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_get_max_num_bits_285_comment},
  {"get_num_bits", &Dtool_BitMask_uint16_t_16_get_num_bits_286, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_get_num_bits_286_comment},
  {"getNumBits", &Dtool_BitMask_uint16_t_16_get_num_bits_286, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_get_num_bits_286_comment},
  {"get_bit", &Dtool_BitMask_uint16_t_16_get_bit_287, METH_O, (const char *)Dtool_BitMask_uint16_t_16_get_bit_287_comment},
  {"getBit", &Dtool_BitMask_uint16_t_16_get_bit_287, METH_O, (const char *)Dtool_BitMask_uint16_t_16_get_bit_287_comment},
  {"set_bit", &Dtool_BitMask_uint16_t_16_set_bit_288, METH_O, (const char *)Dtool_BitMask_uint16_t_16_set_bit_288_comment},
  {"setBit", &Dtool_BitMask_uint16_t_16_set_bit_288, METH_O, (const char *)Dtool_BitMask_uint16_t_16_set_bit_288_comment},
  {"clear_bit", &Dtool_BitMask_uint16_t_16_clear_bit_289, METH_O, (const char *)Dtool_BitMask_uint16_t_16_clear_bit_289_comment},
  {"clearBit", &Dtool_BitMask_uint16_t_16_clear_bit_289, METH_O, (const char *)Dtool_BitMask_uint16_t_16_clear_bit_289_comment},
  {"set_bit_to", (PyCFunction) &Dtool_BitMask_uint16_t_16_set_bit_to_290, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_set_bit_to_290_comment},
  {"setBitTo", (PyCFunction) &Dtool_BitMask_uint16_t_16_set_bit_to_290, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_set_bit_to_290_comment},
  {"is_zero", &Dtool_BitMask_uint16_t_16_is_zero_291, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_is_zero_291_comment},
  {"isZero", &Dtool_BitMask_uint16_t_16_is_zero_291, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_is_zero_291_comment},
  {"is_all_on", &Dtool_BitMask_uint16_t_16_is_all_on_292, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_is_all_on_292_comment},
  {"isAllOn", &Dtool_BitMask_uint16_t_16_is_all_on_292, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_is_all_on_292_comment},
  {"extract", (PyCFunction) &Dtool_BitMask_uint16_t_16_extract_293, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_extract_293_comment},
  {"store", (PyCFunction) &Dtool_BitMask_uint16_t_16_store_294, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_store_294_comment},
  {"has_any_of", (PyCFunction) &Dtool_BitMask_uint16_t_16_has_any_of_295, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_has_any_of_295_comment},
  {"hasAnyOf", (PyCFunction) &Dtool_BitMask_uint16_t_16_has_any_of_295, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_has_any_of_295_comment},
  {"has_all_of", (PyCFunction) &Dtool_BitMask_uint16_t_16_has_all_of_296, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_has_all_of_296_comment},
  {"hasAllOf", (PyCFunction) &Dtool_BitMask_uint16_t_16_has_all_of_296, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_has_all_of_296_comment},
  {"set_range", (PyCFunction) &Dtool_BitMask_uint16_t_16_set_range_297, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_set_range_297_comment},
  {"setRange", (PyCFunction) &Dtool_BitMask_uint16_t_16_set_range_297, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_set_range_297_comment},
  {"clear_range", (PyCFunction) &Dtool_BitMask_uint16_t_16_clear_range_298, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_clear_range_298_comment},
  {"clearRange", (PyCFunction) &Dtool_BitMask_uint16_t_16_clear_range_298, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_clear_range_298_comment},
  {"set_range_to", (PyCFunction) &Dtool_BitMask_uint16_t_16_set_range_to_299, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_set_range_to_299_comment},
  {"setRangeTo", (PyCFunction) &Dtool_BitMask_uint16_t_16_set_range_to_299, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_set_range_to_299_comment},
  {"get_word", &Dtool_BitMask_uint16_t_16_get_word_300, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_word_300_comment},
  {"getWord", &Dtool_BitMask_uint16_t_16_get_word_300, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_word_300_comment},
  {"set_word", &Dtool_BitMask_uint16_t_16_set_word_301, METH_O, (const char *)Dtool_BitMask_uint16_t_16_set_word_301_comment},
  {"setWord", &Dtool_BitMask_uint16_t_16_set_word_301, METH_O, (const char *)Dtool_BitMask_uint16_t_16_set_word_301_comment},
  {"get_num_on_bits", &Dtool_BitMask_uint16_t_16_get_num_on_bits_302, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_num_on_bits_302_comment},
  {"getNumOnBits", &Dtool_BitMask_uint16_t_16_get_num_on_bits_302, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_num_on_bits_302_comment},
  {"get_num_off_bits", &Dtool_BitMask_uint16_t_16_get_num_off_bits_303, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_num_off_bits_303_comment},
  {"getNumOffBits", &Dtool_BitMask_uint16_t_16_get_num_off_bits_303, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_num_off_bits_303_comment},
  {"get_lowest_on_bit", &Dtool_BitMask_uint16_t_16_get_lowest_on_bit_304, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_lowest_on_bit_304_comment},
  {"getLowestOnBit", &Dtool_BitMask_uint16_t_16_get_lowest_on_bit_304, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_lowest_on_bit_304_comment},
  {"get_lowest_off_bit", &Dtool_BitMask_uint16_t_16_get_lowest_off_bit_305, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_lowest_off_bit_305_comment},
  {"getLowestOffBit", &Dtool_BitMask_uint16_t_16_get_lowest_off_bit_305, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_lowest_off_bit_305_comment},
  {"get_highest_on_bit", &Dtool_BitMask_uint16_t_16_get_highest_on_bit_306, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_highest_on_bit_306_comment},
  {"getHighestOnBit", &Dtool_BitMask_uint16_t_16_get_highest_on_bit_306, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_highest_on_bit_306_comment},
  {"get_highest_off_bit", &Dtool_BitMask_uint16_t_16_get_highest_off_bit_307, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_highest_off_bit_307_comment},
  {"getHighestOffBit", &Dtool_BitMask_uint16_t_16_get_highest_off_bit_307, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_highest_off_bit_307_comment},
  {"get_next_higher_different_bit", &Dtool_BitMask_uint16_t_16_get_next_higher_different_bit_308, METH_O, (const char *)Dtool_BitMask_uint16_t_16_get_next_higher_different_bit_308_comment},
  {"getNextHigherDifferentBit", &Dtool_BitMask_uint16_t_16_get_next_higher_different_bit_308, METH_O, (const char *)Dtool_BitMask_uint16_t_16_get_next_higher_different_bit_308_comment},
  {"invert_in_place", &Dtool_BitMask_uint16_t_16_invert_in_place_309, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_invert_in_place_309_comment},
  {"invertInPlace", &Dtool_BitMask_uint16_t_16_invert_in_place_309, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_invert_in_place_309_comment},
  {"has_bits_in_common", &Dtool_BitMask_uint16_t_16_has_bits_in_common_310, METH_O, (const char *)Dtool_BitMask_uint16_t_16_has_bits_in_common_310_comment},
  {"hasBitsInCommon", &Dtool_BitMask_uint16_t_16_has_bits_in_common_310, METH_O, (const char *)Dtool_BitMask_uint16_t_16_has_bits_in_common_310_comment},
  {"clear", &Dtool_BitMask_uint16_t_16_clear_311, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_clear_311_comment},
  {"output", &Dtool_BitMask_uint16_t_16_output_312, METH_O, (const char *)Dtool_BitMask_uint16_t_16_output_312_comment},
  {"output_binary", (PyCFunction) &Dtool_BitMask_uint16_t_16_output_binary_313, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_output_binary_313_comment},
  {"outputBinary", (PyCFunction) &Dtool_BitMask_uint16_t_16_output_binary_313, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_output_binary_313_comment},
  {"output_hex", (PyCFunction) &Dtool_BitMask_uint16_t_16_output_hex_314, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_output_hex_314_comment},
  {"outputHex", (PyCFunction) &Dtool_BitMask_uint16_t_16_output_hex_314, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_output_hex_314_comment},
  {"write", (PyCFunction) &Dtool_BitMask_uint16_t_16_write_315, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_write_315_comment},
  {"compare_to", &Dtool_BitMask_uint16_t_16_compare_to_319, METH_O, (const char *)Dtool_BitMask_uint16_t_16_compare_to_319_comment},
  {"compareTo", &Dtool_BitMask_uint16_t_16_compare_to_319, METH_O, (const char *)Dtool_BitMask_uint16_t_16_compare_to_319_comment},
  {"__ior__", &Dtool_BitMask_uint16_t_16_operator_327, METH_O, (const char *)Dtool_BitMask_uint16_t_16_operator_327_comment},
  {"flood_down_in_place", &Dtool_BitMask_uint16_t_16_flood_down_in_place_331, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_flood_down_in_place_331_comment},
  {"floodDownInPlace", &Dtool_BitMask_uint16_t_16_flood_down_in_place_331, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_flood_down_in_place_331_comment},
  {"flood_up_in_place", &Dtool_BitMask_uint16_t_16_flood_up_in_place_332, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_flood_up_in_place_332_comment},
  {"floodUpInPlace", &Dtool_BitMask_uint16_t_16_flood_up_in_place_332, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_flood_up_in_place_332_comment},
  {"flood_bits_down", &Dtool_BitMask_uint16_t_16_flood_bits_down_333, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_flood_bits_down_333_comment},
  {"floodBitsDown", &Dtool_BitMask_uint16_t_16_flood_bits_down_333, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_flood_bits_down_333_comment},
  {"flood_bits_up", &Dtool_BitMask_uint16_t_16_flood_bits_up_334, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_flood_bits_up_334_comment},
  {"floodBitsUp", &Dtool_BitMask_uint16_t_16_flood_bits_up_334, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_flood_bits_up_334_comment},
  {"keep_next_highest_bit", &Dtool_BitMask_uint16_t_16_keep_next_highest_bit_335, METH_VARARGS, (const char *)Dtool_BitMask_uint16_t_16_keep_next_highest_bit_335_comment},
  {"keepNextHighestBit", &Dtool_BitMask_uint16_t_16_keep_next_highest_bit_335, METH_VARARGS, (const char *)Dtool_BitMask_uint16_t_16_keep_next_highest_bit_335_comment},
  {"keep_next_lowest_bit", &Dtool_BitMask_uint16_t_16_keep_next_lowest_bit_336, METH_VARARGS, (const char *)Dtool_BitMask_uint16_t_16_keep_next_lowest_bit_336_comment},
  {"keepNextLowestBit", &Dtool_BitMask_uint16_t_16_keep_next_lowest_bit_336, METH_VARARGS, (const char *)Dtool_BitMask_uint16_t_16_keep_next_lowest_bit_336_comment},
  {"get_key", &Dtool_BitMask_uint16_t_16_get_key_337, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_key_337_comment},
  {"getKey", &Dtool_BitMask_uint16_t_16_get_key_337, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_key_337_comment},
  {"get_class_type", &Dtool_BitMask_uint16_t_16_get_class_type_339, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_get_class_type_339_comment},
  {"getClassType", &Dtool_BitMask_uint16_t_16_get_class_type_339, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_get_class_type_339_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_and -> operator &
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_320_nb_and(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint16_t_16, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator &(BitMask< uint16_t, 16 > const &other) const
  BitMask< uint16_t, 16 > arg_local;
  BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__and__", "BitMask");
  }
  BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((*(const BitMask< uint16_t, 16 >*)local_this).operator &(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_bool -> __nonzero__
//////////////////
static int Dtool_BitMask_uint16_t_16_nonzero_338_nb_bool(PyObject *self) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return -1;
  }

  return (int) (*local_this).__nonzero__();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_inplace_and -> operator &=
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_326_nb_inplace_and(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint16_t_16, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void BitMask< uint16_t, 16 >::operator &=(BitMask< uint16_t, 16 > const &other)
    BitMask< uint16_t, 16 > arg_local;
    BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__iand__", "BitMask");
      return NULL;
    }
    (*local_this).operator &=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call BitMask.__iand__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_inplace_lshift -> operator <<=
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_329_nb_inplace_lshift(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint16_t_16, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void BitMask< uint16_t, 16 >::operator <<=(int shift)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator <<=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call BitMask.__ilshift__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_inplace_rshift -> operator >>=
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_330_nb_inplace_rshift(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint16_t_16, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void BitMask< uint16_t, 16 >::operator >>=(int shift)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator >>=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call BitMask.__irshift__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_inplace_xor -> operator ^=
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_328_nb_inplace_xor(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint16_t_16, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void BitMask< uint16_t, 16 >::operator ^=(BitMask< uint16_t, 16 > const &other)
    BitMask< uint16_t, 16 > arg_local;
    BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__ixor__", "BitMask");
      return NULL;
    }
    (*local_this).operator ^=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call BitMask.__ixor__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_invert -> operator ~
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_323_nb_invert(PyObject *self) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator ~(void) const
  BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((*(const BitMask< uint16_t, 16 >*)local_this).operator ~());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__invert__(BitMask self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_lshift -> operator <<
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_324_nb_lshift(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint16_t_16, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator <<(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((*(const BitMask< uint16_t, 16 >*)local_this).operator <<((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_or -> operator |
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_321_nb_or(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint16_t_16, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator |(BitMask< uint16_t, 16 > const &other) const
  BitMask< uint16_t, 16 > arg_local;
  BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__or__", "BitMask");
  }
  BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((*(const BitMask< uint16_t, 16 >*)local_this).operator |(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_rshift -> operator >>
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_325_nb_rshift(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint16_t_16, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator >>(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((*(const BitMask< uint16_t, 16 >*)local_this).operator >>((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_xor -> operator ^
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_322_nb_xor(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint16_t_16, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator ^(BitMask< uint16_t, 16 > const &other) const
  BitMask< uint16_t, 16 > arg_local;
  BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__xor__", "BitMask");
  }
  BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((*(const BitMask< uint16_t, 16 >*)local_this).operator ^(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot tp_compare -> compare_to
//////////////////
static int Dtool_BitMask_uint16_t_16_compare_to_319_tp_compare(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int BitMask< uint16_t, 16 >::compare_to(BitMask< uint16_t, 16 > const &other) const
  BitMask< uint16_t, 16 > arg_local;
  BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitMask.compare_to", "BitMask");
    return -1;
  }
  int return_value = (*(const BitMask< uint16_t, 16 >*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(BitMask self, const BitMask other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot tp_hash -> get_key
//////////////////
static Py_hash_t Dtool_BitMask_uint16_t_16_get_key_337_tp_hash(PyObject *self) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_key();
}

//////////////////
//  A __repr__ function
//     BitMask_uint16_t_16
//////////////////
static PyObject *Dtool_Repr_BitMask_uint16_t_16(PyObject *self) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     BitMask_uint16_t_16
//////////////////
static PyObject *Dtool_Str_BitMask_uint16_t_16(PyObject *self) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     BitMask_uint16_t_16
//////////////////
static PyObject *Dtool_RichCompare_BitMask_uint16_t_16(PyObject *self, PyObject *arg, int op) {
  BitMask< uint16_t, 16 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool BitMask< uint16_t, 16 >::operator ==(BitMask< uint16_t, 16 > const &other) const
      BitMask< uint16_t, 16 > arg_local;
      BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const BitMask< uint16_t, 16 >*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool BitMask< uint16_t, 16 >::operator !=(BitMask< uint16_t, 16 > const &other) const
      BitMask< uint16_t, 16 > arg_local;
      BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const BitMask< uint16_t, 16 >*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool BitMask< uint16_t, 16 >::operator <(BitMask< uint16_t, 16 > const &other) const
      BitMask< uint16_t, 16 > arg_local;
      BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const BitMask< uint16_t, 16 >*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_BitMask_uint16_t_16_compare_to_319_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_BitMask_uint16_t_16 = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  &Dtool_BitMask_uint16_t_16_nonzero_338_nb_bool,
  &Dtool_BitMask_uint16_t_16_operator_323_nb_invert,
  &Dtool_BitMask_uint16_t_16_operator_324_nb_lshift,
  &Dtool_BitMask_uint16_t_16_operator_325_nb_rshift,
  &Dtool_BitMask_uint16_t_16_operator_320_nb_and,
  &Dtool_BitMask_uint16_t_16_operator_322_nb_xor,
  &Dtool_BitMask_uint16_t_16_operator_321_nb_or,
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  &Dtool_BitMask_uint16_t_16_operator_329_nb_inplace_lshift,
  &Dtool_BitMask_uint16_t_16_operator_330_nb_inplace_rshift,
  &Dtool_BitMask_uint16_t_16_operator_326_nb_inplace_and,
  &Dtool_BitMask_uint16_t_16_operator_328_nb_inplace_xor,
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_BitMask_uint16_t_16 = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.BitMask_uint16_t_16",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BitMask_uint16_t_16,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_BitMask_uint16_t_16_compare_to_319_tp_compare,
#endif
    &Dtool_Repr_BitMask_uint16_t_16,
    &Dtool_NumberMethods_BitMask_uint16_t_16,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &Dtool_BitMask_uint16_t_16_get_key_337_tp_hash,
    0, // tp_call
    &Dtool_Str_BitMask_uint16_t_16,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_BitMask_uint16_t_16,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BitMask_uint16_t_16,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BitMask_uint16_t_16,
    PyType_GenericAlloc,
    Dtool_new_BitMask_uint16_t_16,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BitMask_uint16_t_16,
  Dtool_UpcastInterface_BitMask_uint16_t_16,
  Dtool_DowncastInterface_BitMask_uint16_t_16,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_BitMask_uint16_t_16,
};

static void Dtool_PyModuleClassInit_BitMask_uint16_t_16(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_BitMask_uint16_t_16._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_BitMask_uint16_t_16._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BitMask_uint16_t_16) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BitMask_uint16_t_16)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BitMask_uint16_t_16);
  }
}

/**
 * Python method tables for BitMask_uint32_t_32 (BitMask_uint32_t_32)
 */
static PyMethodDef Dtool_Methods_BitMask_uint32_t_32[] = {
  {"assign", &Dtool_BitMask_uint32_t_32_operator_343, METH_O, (const char *)Dtool_BitMask_uint32_t_32_operator_343_comment},
  {"all_on", &Dtool_BitMask_uint32_t_32_all_on_344, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_all_on_344_comment},
  {"allOn", &Dtool_BitMask_uint32_t_32_all_on_344, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_all_on_344_comment},
  {"all_off", &Dtool_BitMask_uint32_t_32_all_off_345, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_all_off_345_comment},
  {"allOff", &Dtool_BitMask_uint32_t_32_all_off_345, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_all_off_345_comment},
  {"lower_on", &Dtool_BitMask_uint32_t_32_lower_on_346, METH_O | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_lower_on_346_comment},
  {"lowerOn", &Dtool_BitMask_uint32_t_32_lower_on_346, METH_O | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_lower_on_346_comment},
  {"bit", &Dtool_BitMask_uint32_t_32_bit_347, METH_O | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_bit_347_comment},
  {"range", (PyCFunction) &Dtool_BitMask_uint32_t_32_range_348, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_range_348_comment},
  {"has_max_num_bits", &Dtool_BitMask_uint32_t_32_has_max_num_bits_350, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_has_max_num_bits_350_comment},
  {"hasMaxNumBits", &Dtool_BitMask_uint32_t_32_has_max_num_bits_350, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_has_max_num_bits_350_comment},
  {"get_max_num_bits", &Dtool_BitMask_uint32_t_32_get_max_num_bits_351, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_get_max_num_bits_351_comment},
  {"getMaxNumBits", &Dtool_BitMask_uint32_t_32_get_max_num_bits_351, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_get_max_num_bits_351_comment},
  {"get_num_bits", &Dtool_BitMask_uint32_t_32_get_num_bits_352, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_get_num_bits_352_comment},
  {"getNumBits", &Dtool_BitMask_uint32_t_32_get_num_bits_352, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_get_num_bits_352_comment},
  {"get_bit", &Dtool_BitMask_uint32_t_32_get_bit_353, METH_O, (const char *)Dtool_BitMask_uint32_t_32_get_bit_353_comment},
  {"getBit", &Dtool_BitMask_uint32_t_32_get_bit_353, METH_O, (const char *)Dtool_BitMask_uint32_t_32_get_bit_353_comment},
  {"set_bit", &Dtool_BitMask_uint32_t_32_set_bit_354, METH_O, (const char *)Dtool_BitMask_uint32_t_32_set_bit_354_comment},
  {"setBit", &Dtool_BitMask_uint32_t_32_set_bit_354, METH_O, (const char *)Dtool_BitMask_uint32_t_32_set_bit_354_comment},
  {"clear_bit", &Dtool_BitMask_uint32_t_32_clear_bit_355, METH_O, (const char *)Dtool_BitMask_uint32_t_32_clear_bit_355_comment},
  {"clearBit", &Dtool_BitMask_uint32_t_32_clear_bit_355, METH_O, (const char *)Dtool_BitMask_uint32_t_32_clear_bit_355_comment},
  {"set_bit_to", (PyCFunction) &Dtool_BitMask_uint32_t_32_set_bit_to_356, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_set_bit_to_356_comment},
  {"setBitTo", (PyCFunction) &Dtool_BitMask_uint32_t_32_set_bit_to_356, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_set_bit_to_356_comment},
  {"is_zero", &Dtool_BitMask_uint32_t_32_is_zero_357, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_is_zero_357_comment},
  {"isZero", &Dtool_BitMask_uint32_t_32_is_zero_357, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_is_zero_357_comment},
  {"is_all_on", &Dtool_BitMask_uint32_t_32_is_all_on_358, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_is_all_on_358_comment},
  {"isAllOn", &Dtool_BitMask_uint32_t_32_is_all_on_358, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_is_all_on_358_comment},
  {"extract", (PyCFunction) &Dtool_BitMask_uint32_t_32_extract_359, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_extract_359_comment},
  {"store", (PyCFunction) &Dtool_BitMask_uint32_t_32_store_360, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_store_360_comment},
  {"has_any_of", (PyCFunction) &Dtool_BitMask_uint32_t_32_has_any_of_361, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_has_any_of_361_comment},
  {"hasAnyOf", (PyCFunction) &Dtool_BitMask_uint32_t_32_has_any_of_361, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_has_any_of_361_comment},
  {"has_all_of", (PyCFunction) &Dtool_BitMask_uint32_t_32_has_all_of_362, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_has_all_of_362_comment},
  {"hasAllOf", (PyCFunction) &Dtool_BitMask_uint32_t_32_has_all_of_362, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_has_all_of_362_comment},
  {"set_range", (PyCFunction) &Dtool_BitMask_uint32_t_32_set_range_363, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_set_range_363_comment},
  {"setRange", (PyCFunction) &Dtool_BitMask_uint32_t_32_set_range_363, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_set_range_363_comment},
  {"clear_range", (PyCFunction) &Dtool_BitMask_uint32_t_32_clear_range_364, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_clear_range_364_comment},
  {"clearRange", (PyCFunction) &Dtool_BitMask_uint32_t_32_clear_range_364, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_clear_range_364_comment},
  {"set_range_to", (PyCFunction) &Dtool_BitMask_uint32_t_32_set_range_to_365, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_set_range_to_365_comment},
  {"setRangeTo", (PyCFunction) &Dtool_BitMask_uint32_t_32_set_range_to_365, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_set_range_to_365_comment},
  {"get_word", &Dtool_BitMask_uint32_t_32_get_word_366, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_word_366_comment},
  {"getWord", &Dtool_BitMask_uint32_t_32_get_word_366, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_word_366_comment},
  {"set_word", &Dtool_BitMask_uint32_t_32_set_word_367, METH_O, (const char *)Dtool_BitMask_uint32_t_32_set_word_367_comment},
  {"setWord", &Dtool_BitMask_uint32_t_32_set_word_367, METH_O, (const char *)Dtool_BitMask_uint32_t_32_set_word_367_comment},
  {"get_num_on_bits", &Dtool_BitMask_uint32_t_32_get_num_on_bits_368, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_num_on_bits_368_comment},
  {"getNumOnBits", &Dtool_BitMask_uint32_t_32_get_num_on_bits_368, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_num_on_bits_368_comment},
  {"get_num_off_bits", &Dtool_BitMask_uint32_t_32_get_num_off_bits_369, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_num_off_bits_369_comment},
  {"getNumOffBits", &Dtool_BitMask_uint32_t_32_get_num_off_bits_369, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_num_off_bits_369_comment},
  {"get_lowest_on_bit", &Dtool_BitMask_uint32_t_32_get_lowest_on_bit_370, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_lowest_on_bit_370_comment},
  {"getLowestOnBit", &Dtool_BitMask_uint32_t_32_get_lowest_on_bit_370, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_lowest_on_bit_370_comment},
  {"get_lowest_off_bit", &Dtool_BitMask_uint32_t_32_get_lowest_off_bit_371, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_lowest_off_bit_371_comment},
  {"getLowestOffBit", &Dtool_BitMask_uint32_t_32_get_lowest_off_bit_371, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_lowest_off_bit_371_comment},
  {"get_highest_on_bit", &Dtool_BitMask_uint32_t_32_get_highest_on_bit_372, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_highest_on_bit_372_comment},
  {"getHighestOnBit", &Dtool_BitMask_uint32_t_32_get_highest_on_bit_372, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_highest_on_bit_372_comment},
  {"get_highest_off_bit", &Dtool_BitMask_uint32_t_32_get_highest_off_bit_373, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_highest_off_bit_373_comment},
  {"getHighestOffBit", &Dtool_BitMask_uint32_t_32_get_highest_off_bit_373, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_highest_off_bit_373_comment},
  {"get_next_higher_different_bit", &Dtool_BitMask_uint32_t_32_get_next_higher_different_bit_374, METH_O, (const char *)Dtool_BitMask_uint32_t_32_get_next_higher_different_bit_374_comment},
  {"getNextHigherDifferentBit", &Dtool_BitMask_uint32_t_32_get_next_higher_different_bit_374, METH_O, (const char *)Dtool_BitMask_uint32_t_32_get_next_higher_different_bit_374_comment},
  {"invert_in_place", &Dtool_BitMask_uint32_t_32_invert_in_place_375, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_invert_in_place_375_comment},
  {"invertInPlace", &Dtool_BitMask_uint32_t_32_invert_in_place_375, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_invert_in_place_375_comment},
  {"has_bits_in_common", &Dtool_BitMask_uint32_t_32_has_bits_in_common_376, METH_O, (const char *)Dtool_BitMask_uint32_t_32_has_bits_in_common_376_comment},
  {"hasBitsInCommon", &Dtool_BitMask_uint32_t_32_has_bits_in_common_376, METH_O, (const char *)Dtool_BitMask_uint32_t_32_has_bits_in_common_376_comment},
  {"clear", &Dtool_BitMask_uint32_t_32_clear_377, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_clear_377_comment},
  {"output", &Dtool_BitMask_uint32_t_32_output_378, METH_O, (const char *)Dtool_BitMask_uint32_t_32_output_378_comment},
  {"output_binary", (PyCFunction) &Dtool_BitMask_uint32_t_32_output_binary_379, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_output_binary_379_comment},
  {"outputBinary", (PyCFunction) &Dtool_BitMask_uint32_t_32_output_binary_379, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_output_binary_379_comment},
  {"output_hex", (PyCFunction) &Dtool_BitMask_uint32_t_32_output_hex_380, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_output_hex_380_comment},
  {"outputHex", (PyCFunction) &Dtool_BitMask_uint32_t_32_output_hex_380, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_output_hex_380_comment},
  {"write", (PyCFunction) &Dtool_BitMask_uint32_t_32_write_381, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_write_381_comment},
  {"compare_to", &Dtool_BitMask_uint32_t_32_compare_to_385, METH_O, (const char *)Dtool_BitMask_uint32_t_32_compare_to_385_comment},
  {"compareTo", &Dtool_BitMask_uint32_t_32_compare_to_385, METH_O, (const char *)Dtool_BitMask_uint32_t_32_compare_to_385_comment},
  {"__ior__", &Dtool_BitMask_uint32_t_32_operator_393, METH_O, (const char *)Dtool_BitMask_uint32_t_32_operator_393_comment},
  {"flood_down_in_place", &Dtool_BitMask_uint32_t_32_flood_down_in_place_397, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_flood_down_in_place_397_comment},
  {"floodDownInPlace", &Dtool_BitMask_uint32_t_32_flood_down_in_place_397, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_flood_down_in_place_397_comment},
  {"flood_up_in_place", &Dtool_BitMask_uint32_t_32_flood_up_in_place_398, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_flood_up_in_place_398_comment},
  {"floodUpInPlace", &Dtool_BitMask_uint32_t_32_flood_up_in_place_398, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_flood_up_in_place_398_comment},
  {"flood_bits_down", &Dtool_BitMask_uint32_t_32_flood_bits_down_399, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_flood_bits_down_399_comment},
  {"floodBitsDown", &Dtool_BitMask_uint32_t_32_flood_bits_down_399, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_flood_bits_down_399_comment},
  {"flood_bits_up", &Dtool_BitMask_uint32_t_32_flood_bits_up_400, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_flood_bits_up_400_comment},
  {"floodBitsUp", &Dtool_BitMask_uint32_t_32_flood_bits_up_400, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_flood_bits_up_400_comment},
  {"keep_next_highest_bit", &Dtool_BitMask_uint32_t_32_keep_next_highest_bit_401, METH_VARARGS, (const char *)Dtool_BitMask_uint32_t_32_keep_next_highest_bit_401_comment},
  {"keepNextHighestBit", &Dtool_BitMask_uint32_t_32_keep_next_highest_bit_401, METH_VARARGS, (const char *)Dtool_BitMask_uint32_t_32_keep_next_highest_bit_401_comment},
  {"keep_next_lowest_bit", &Dtool_BitMask_uint32_t_32_keep_next_lowest_bit_402, METH_VARARGS, (const char *)Dtool_BitMask_uint32_t_32_keep_next_lowest_bit_402_comment},
  {"keepNextLowestBit", &Dtool_BitMask_uint32_t_32_keep_next_lowest_bit_402, METH_VARARGS, (const char *)Dtool_BitMask_uint32_t_32_keep_next_lowest_bit_402_comment},
  {"get_key", &Dtool_BitMask_uint32_t_32_get_key_403, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_key_403_comment},
  {"getKey", &Dtool_BitMask_uint32_t_32_get_key_403, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_key_403_comment},
  {"get_class_type", &Dtool_BitMask_uint32_t_32_get_class_type_405, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_get_class_type_405_comment},
  {"getClassType", &Dtool_BitMask_uint32_t_32_get_class_type_405, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_get_class_type_405_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_and -> operator &
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_386_nb_and(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint32_t_32, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator &(BitMask< uint32_t, 32 > const &other) const
  BitMask< uint32_t, 32 > arg_local;
  BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__and__", "BitMask");
  }
  BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((*(const BitMask< uint32_t, 32 >*)local_this).operator &(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_bool -> __nonzero__
//////////////////
static int Dtool_BitMask_uint32_t_32_nonzero_404_nb_bool(PyObject *self) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return -1;
  }

  return (int) (*local_this).__nonzero__();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_inplace_and -> operator &=
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_392_nb_inplace_and(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint32_t_32, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void BitMask< uint32_t, 32 >::operator &=(BitMask< uint32_t, 32 > const &other)
    BitMask< uint32_t, 32 > arg_local;
    BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__iand__", "BitMask");
      return NULL;
    }
    (*local_this).operator &=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call BitMask.__iand__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_inplace_lshift -> operator <<=
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_395_nb_inplace_lshift(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint32_t_32, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void BitMask< uint32_t, 32 >::operator <<=(int shift)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator <<=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call BitMask.__ilshift__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_inplace_rshift -> operator >>=
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_396_nb_inplace_rshift(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint32_t_32, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void BitMask< uint32_t, 32 >::operator >>=(int shift)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator >>=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call BitMask.__irshift__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_inplace_xor -> operator ^=
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_394_nb_inplace_xor(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint32_t_32, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void BitMask< uint32_t, 32 >::operator ^=(BitMask< uint32_t, 32 > const &other)
    BitMask< uint32_t, 32 > arg_local;
    BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__ixor__", "BitMask");
      return NULL;
    }
    (*local_this).operator ^=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call BitMask.__ixor__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_invert -> operator ~
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_389_nb_invert(PyObject *self) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator ~(void) const
  BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((*(const BitMask< uint32_t, 32 >*)local_this).operator ~());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__invert__(BitMask self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_lshift -> operator <<
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_390_nb_lshift(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint32_t_32, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator <<(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((*(const BitMask< uint32_t, 32 >*)local_this).operator <<((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_or -> operator |
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_387_nb_or(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint32_t_32, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator |(BitMask< uint32_t, 32 > const &other) const
  BitMask< uint32_t, 32 > arg_local;
  BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__or__", "BitMask");
  }
  BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((*(const BitMask< uint32_t, 32 >*)local_this).operator |(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_rshift -> operator >>
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_391_nb_rshift(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint32_t_32, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator >>(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((*(const BitMask< uint32_t, 32 >*)local_this).operator >>((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_xor -> operator ^
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_388_nb_xor(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint32_t_32, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator ^(BitMask< uint32_t, 32 > const &other) const
  BitMask< uint32_t, 32 > arg_local;
  BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__xor__", "BitMask");
  }
  BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((*(const BitMask< uint32_t, 32 >*)local_this).operator ^(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot tp_compare -> compare_to
//////////////////
static int Dtool_BitMask_uint32_t_32_compare_to_385_tp_compare(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int BitMask< uint32_t, 32 >::compare_to(BitMask< uint32_t, 32 > const &other) const
  BitMask< uint32_t, 32 > arg_local;
  BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitMask.compare_to", "BitMask");
    return -1;
  }
  int return_value = (*(const BitMask< uint32_t, 32 >*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(BitMask self, const BitMask other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot tp_hash -> get_key
//////////////////
static Py_hash_t Dtool_BitMask_uint32_t_32_get_key_403_tp_hash(PyObject *self) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_key();
}

//////////////////
//  A __repr__ function
//     BitMask_uint32_t_32
//////////////////
static PyObject *Dtool_Repr_BitMask_uint32_t_32(PyObject *self) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     BitMask_uint32_t_32
//////////////////
static PyObject *Dtool_Str_BitMask_uint32_t_32(PyObject *self) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     BitMask_uint32_t_32
//////////////////
static PyObject *Dtool_RichCompare_BitMask_uint32_t_32(PyObject *self, PyObject *arg, int op) {
  BitMask< uint32_t, 32 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool BitMask< uint32_t, 32 >::operator ==(BitMask< uint32_t, 32 > const &other) const
      BitMask< uint32_t, 32 > arg_local;
      BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const BitMask< uint32_t, 32 >*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool BitMask< uint32_t, 32 >::operator !=(BitMask< uint32_t, 32 > const &other) const
      BitMask< uint32_t, 32 > arg_local;
      BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const BitMask< uint32_t, 32 >*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool BitMask< uint32_t, 32 >::operator <(BitMask< uint32_t, 32 > const &other) const
      BitMask< uint32_t, 32 > arg_local;
      BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const BitMask< uint32_t, 32 >*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_BitMask_uint32_t_32_compare_to_385_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_BitMask_uint32_t_32 = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  &Dtool_BitMask_uint32_t_32_nonzero_404_nb_bool,
  &Dtool_BitMask_uint32_t_32_operator_389_nb_invert,
  &Dtool_BitMask_uint32_t_32_operator_390_nb_lshift,
  &Dtool_BitMask_uint32_t_32_operator_391_nb_rshift,
  &Dtool_BitMask_uint32_t_32_operator_386_nb_and,
  &Dtool_BitMask_uint32_t_32_operator_388_nb_xor,
  &Dtool_BitMask_uint32_t_32_operator_387_nb_or,
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  &Dtool_BitMask_uint32_t_32_operator_395_nb_inplace_lshift,
  &Dtool_BitMask_uint32_t_32_operator_396_nb_inplace_rshift,
  &Dtool_BitMask_uint32_t_32_operator_392_nb_inplace_and,
  &Dtool_BitMask_uint32_t_32_operator_394_nb_inplace_xor,
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_BitMask_uint32_t_32 = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.BitMask_uint32_t_32",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BitMask_uint32_t_32,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_BitMask_uint32_t_32_compare_to_385_tp_compare,
#endif
    &Dtool_Repr_BitMask_uint32_t_32,
    &Dtool_NumberMethods_BitMask_uint32_t_32,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &Dtool_BitMask_uint32_t_32_get_key_403_tp_hash,
    0, // tp_call
    &Dtool_Str_BitMask_uint32_t_32,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_BitMask_uint32_t_32,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BitMask_uint32_t_32,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BitMask_uint32_t_32,
    PyType_GenericAlloc,
    Dtool_new_BitMask_uint32_t_32,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BitMask_uint32_t_32,
  Dtool_UpcastInterface_BitMask_uint32_t_32,
  Dtool_DowncastInterface_BitMask_uint32_t_32,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_BitMask_uint32_t_32,
};

static void Dtool_PyModuleClassInit_BitMask_uint32_t_32(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_BitMask_uint32_t_32._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_BitMask_uint32_t_32._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BitMask_uint32_t_32) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BitMask_uint32_t_32)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BitMask_uint32_t_32);
  }
}

/**
 * Python method tables for BitMask_uint64_t_64 (BitMask_uint64_t_64)
 */
static PyMethodDef Dtool_Methods_BitMask_uint64_t_64[] = {
  {"assign", &Dtool_BitMask_uint64_t_64_operator_409, METH_O, (const char *)Dtool_BitMask_uint64_t_64_operator_409_comment},
  {"all_on", &Dtool_BitMask_uint64_t_64_all_on_410, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_all_on_410_comment},
  {"allOn", &Dtool_BitMask_uint64_t_64_all_on_410, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_all_on_410_comment},
  {"all_off", &Dtool_BitMask_uint64_t_64_all_off_411, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_all_off_411_comment},
  {"allOff", &Dtool_BitMask_uint64_t_64_all_off_411, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_all_off_411_comment},
  {"lower_on", &Dtool_BitMask_uint64_t_64_lower_on_412, METH_O | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_lower_on_412_comment},
  {"lowerOn", &Dtool_BitMask_uint64_t_64_lower_on_412, METH_O | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_lower_on_412_comment},
  {"bit", &Dtool_BitMask_uint64_t_64_bit_413, METH_O | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_bit_413_comment},
  {"range", (PyCFunction) &Dtool_BitMask_uint64_t_64_range_414, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_range_414_comment},
  {"has_max_num_bits", &Dtool_BitMask_uint64_t_64_has_max_num_bits_416, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_has_max_num_bits_416_comment},
  {"hasMaxNumBits", &Dtool_BitMask_uint64_t_64_has_max_num_bits_416, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_has_max_num_bits_416_comment},
  {"get_max_num_bits", &Dtool_BitMask_uint64_t_64_get_max_num_bits_417, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_get_max_num_bits_417_comment},
  {"getMaxNumBits", &Dtool_BitMask_uint64_t_64_get_max_num_bits_417, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_get_max_num_bits_417_comment},
  {"get_num_bits", &Dtool_BitMask_uint64_t_64_get_num_bits_418, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_get_num_bits_418_comment},
  {"getNumBits", &Dtool_BitMask_uint64_t_64_get_num_bits_418, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_get_num_bits_418_comment},
  {"get_bit", &Dtool_BitMask_uint64_t_64_get_bit_419, METH_O, (const char *)Dtool_BitMask_uint64_t_64_get_bit_419_comment},
  {"getBit", &Dtool_BitMask_uint64_t_64_get_bit_419, METH_O, (const char *)Dtool_BitMask_uint64_t_64_get_bit_419_comment},
  {"set_bit", &Dtool_BitMask_uint64_t_64_set_bit_420, METH_O, (const char *)Dtool_BitMask_uint64_t_64_set_bit_420_comment},
  {"setBit", &Dtool_BitMask_uint64_t_64_set_bit_420, METH_O, (const char *)Dtool_BitMask_uint64_t_64_set_bit_420_comment},
  {"clear_bit", &Dtool_BitMask_uint64_t_64_clear_bit_421, METH_O, (const char *)Dtool_BitMask_uint64_t_64_clear_bit_421_comment},
  {"clearBit", &Dtool_BitMask_uint64_t_64_clear_bit_421, METH_O, (const char *)Dtool_BitMask_uint64_t_64_clear_bit_421_comment},
  {"set_bit_to", (PyCFunction) &Dtool_BitMask_uint64_t_64_set_bit_to_422, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_set_bit_to_422_comment},
  {"setBitTo", (PyCFunction) &Dtool_BitMask_uint64_t_64_set_bit_to_422, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_set_bit_to_422_comment},
  {"is_zero", &Dtool_BitMask_uint64_t_64_is_zero_423, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_is_zero_423_comment},
  {"isZero", &Dtool_BitMask_uint64_t_64_is_zero_423, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_is_zero_423_comment},
  {"is_all_on", &Dtool_BitMask_uint64_t_64_is_all_on_424, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_is_all_on_424_comment},
  {"isAllOn", &Dtool_BitMask_uint64_t_64_is_all_on_424, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_is_all_on_424_comment},
  {"extract", (PyCFunction) &Dtool_BitMask_uint64_t_64_extract_425, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_extract_425_comment},
  {"store", (PyCFunction) &Dtool_BitMask_uint64_t_64_store_426, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_store_426_comment},
  {"has_any_of", (PyCFunction) &Dtool_BitMask_uint64_t_64_has_any_of_427, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_has_any_of_427_comment},
  {"hasAnyOf", (PyCFunction) &Dtool_BitMask_uint64_t_64_has_any_of_427, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_has_any_of_427_comment},
  {"has_all_of", (PyCFunction) &Dtool_BitMask_uint64_t_64_has_all_of_428, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_has_all_of_428_comment},
  {"hasAllOf", (PyCFunction) &Dtool_BitMask_uint64_t_64_has_all_of_428, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_has_all_of_428_comment},
  {"set_range", (PyCFunction) &Dtool_BitMask_uint64_t_64_set_range_429, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_set_range_429_comment},
  {"setRange", (PyCFunction) &Dtool_BitMask_uint64_t_64_set_range_429, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_set_range_429_comment},
  {"clear_range", (PyCFunction) &Dtool_BitMask_uint64_t_64_clear_range_430, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_clear_range_430_comment},
  {"clearRange", (PyCFunction) &Dtool_BitMask_uint64_t_64_clear_range_430, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_clear_range_430_comment},
  {"set_range_to", (PyCFunction) &Dtool_BitMask_uint64_t_64_set_range_to_431, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_set_range_to_431_comment},
  {"setRangeTo", (PyCFunction) &Dtool_BitMask_uint64_t_64_set_range_to_431, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_set_range_to_431_comment},
  {"get_word", &Dtool_BitMask_uint64_t_64_get_word_432, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_word_432_comment},
  {"getWord", &Dtool_BitMask_uint64_t_64_get_word_432, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_word_432_comment},
  {"set_word", &Dtool_BitMask_uint64_t_64_set_word_433, METH_O, (const char *)Dtool_BitMask_uint64_t_64_set_word_433_comment},
  {"setWord", &Dtool_BitMask_uint64_t_64_set_word_433, METH_O, (const char *)Dtool_BitMask_uint64_t_64_set_word_433_comment},
  {"get_num_on_bits", &Dtool_BitMask_uint64_t_64_get_num_on_bits_434, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_num_on_bits_434_comment},
  {"getNumOnBits", &Dtool_BitMask_uint64_t_64_get_num_on_bits_434, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_num_on_bits_434_comment},
  {"get_num_off_bits", &Dtool_BitMask_uint64_t_64_get_num_off_bits_435, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_num_off_bits_435_comment},
  {"getNumOffBits", &Dtool_BitMask_uint64_t_64_get_num_off_bits_435, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_num_off_bits_435_comment},
  {"get_lowest_on_bit", &Dtool_BitMask_uint64_t_64_get_lowest_on_bit_436, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_lowest_on_bit_436_comment},
  {"getLowestOnBit", &Dtool_BitMask_uint64_t_64_get_lowest_on_bit_436, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_lowest_on_bit_436_comment},
  {"get_lowest_off_bit", &Dtool_BitMask_uint64_t_64_get_lowest_off_bit_437, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_lowest_off_bit_437_comment},
  {"getLowestOffBit", &Dtool_BitMask_uint64_t_64_get_lowest_off_bit_437, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_lowest_off_bit_437_comment},
  {"get_highest_on_bit", &Dtool_BitMask_uint64_t_64_get_highest_on_bit_438, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_highest_on_bit_438_comment},
  {"getHighestOnBit", &Dtool_BitMask_uint64_t_64_get_highest_on_bit_438, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_highest_on_bit_438_comment},
  {"get_highest_off_bit", &Dtool_BitMask_uint64_t_64_get_highest_off_bit_439, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_highest_off_bit_439_comment},
  {"getHighestOffBit", &Dtool_BitMask_uint64_t_64_get_highest_off_bit_439, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_highest_off_bit_439_comment},
  {"get_next_higher_different_bit", &Dtool_BitMask_uint64_t_64_get_next_higher_different_bit_440, METH_O, (const char *)Dtool_BitMask_uint64_t_64_get_next_higher_different_bit_440_comment},
  {"getNextHigherDifferentBit", &Dtool_BitMask_uint64_t_64_get_next_higher_different_bit_440, METH_O, (const char *)Dtool_BitMask_uint64_t_64_get_next_higher_different_bit_440_comment},
  {"invert_in_place", &Dtool_BitMask_uint64_t_64_invert_in_place_441, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_invert_in_place_441_comment},
  {"invertInPlace", &Dtool_BitMask_uint64_t_64_invert_in_place_441, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_invert_in_place_441_comment},
  {"has_bits_in_common", &Dtool_BitMask_uint64_t_64_has_bits_in_common_442, METH_O, (const char *)Dtool_BitMask_uint64_t_64_has_bits_in_common_442_comment},
  {"hasBitsInCommon", &Dtool_BitMask_uint64_t_64_has_bits_in_common_442, METH_O, (const char *)Dtool_BitMask_uint64_t_64_has_bits_in_common_442_comment},
  {"clear", &Dtool_BitMask_uint64_t_64_clear_443, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_clear_443_comment},
  {"output", &Dtool_BitMask_uint64_t_64_output_444, METH_O, (const char *)Dtool_BitMask_uint64_t_64_output_444_comment},
  {"output_binary", (PyCFunction) &Dtool_BitMask_uint64_t_64_output_binary_445, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_output_binary_445_comment},
  {"outputBinary", (PyCFunction) &Dtool_BitMask_uint64_t_64_output_binary_445, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_output_binary_445_comment},
  {"output_hex", (PyCFunction) &Dtool_BitMask_uint64_t_64_output_hex_446, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_output_hex_446_comment},
  {"outputHex", (PyCFunction) &Dtool_BitMask_uint64_t_64_output_hex_446, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_output_hex_446_comment},
  {"write", (PyCFunction) &Dtool_BitMask_uint64_t_64_write_447, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_write_447_comment},
  {"compare_to", &Dtool_BitMask_uint64_t_64_compare_to_451, METH_O, (const char *)Dtool_BitMask_uint64_t_64_compare_to_451_comment},
  {"compareTo", &Dtool_BitMask_uint64_t_64_compare_to_451, METH_O, (const char *)Dtool_BitMask_uint64_t_64_compare_to_451_comment},
  {"__ior__", &Dtool_BitMask_uint64_t_64_operator_459, METH_O, (const char *)Dtool_BitMask_uint64_t_64_operator_459_comment},
  {"flood_down_in_place", &Dtool_BitMask_uint64_t_64_flood_down_in_place_463, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_flood_down_in_place_463_comment},
  {"floodDownInPlace", &Dtool_BitMask_uint64_t_64_flood_down_in_place_463, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_flood_down_in_place_463_comment},
  {"flood_up_in_place", &Dtool_BitMask_uint64_t_64_flood_up_in_place_464, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_flood_up_in_place_464_comment},
  {"floodUpInPlace", &Dtool_BitMask_uint64_t_64_flood_up_in_place_464, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_flood_up_in_place_464_comment},
  {"flood_bits_down", &Dtool_BitMask_uint64_t_64_flood_bits_down_465, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_flood_bits_down_465_comment},
  {"floodBitsDown", &Dtool_BitMask_uint64_t_64_flood_bits_down_465, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_flood_bits_down_465_comment},
  {"flood_bits_up", &Dtool_BitMask_uint64_t_64_flood_bits_up_466, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_flood_bits_up_466_comment},
  {"floodBitsUp", &Dtool_BitMask_uint64_t_64_flood_bits_up_466, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_flood_bits_up_466_comment},
  {"keep_next_highest_bit", &Dtool_BitMask_uint64_t_64_keep_next_highest_bit_467, METH_VARARGS, (const char *)Dtool_BitMask_uint64_t_64_keep_next_highest_bit_467_comment},
  {"keepNextHighestBit", &Dtool_BitMask_uint64_t_64_keep_next_highest_bit_467, METH_VARARGS, (const char *)Dtool_BitMask_uint64_t_64_keep_next_highest_bit_467_comment},
  {"keep_next_lowest_bit", &Dtool_BitMask_uint64_t_64_keep_next_lowest_bit_468, METH_VARARGS, (const char *)Dtool_BitMask_uint64_t_64_keep_next_lowest_bit_468_comment},
  {"keepNextLowestBit", &Dtool_BitMask_uint64_t_64_keep_next_lowest_bit_468, METH_VARARGS, (const char *)Dtool_BitMask_uint64_t_64_keep_next_lowest_bit_468_comment},
  {"get_key", &Dtool_BitMask_uint64_t_64_get_key_469, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_key_469_comment},
  {"getKey", &Dtool_BitMask_uint64_t_64_get_key_469, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_key_469_comment},
  {"get_class_type", &Dtool_BitMask_uint64_t_64_get_class_type_471, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_get_class_type_471_comment},
  {"getClassType", &Dtool_BitMask_uint64_t_64_get_class_type_471, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_get_class_type_471_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_and -> operator &
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_452_nb_and(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint64_t_64, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator &(BitMask< uint64_t, 64 > const &other) const
  BitMask< uint64_t, 64 > arg_local;
  BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__and__", "BitMask");
  }
  BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((*(const BitMask< uint64_t, 64 >*)local_this).operator &(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_bool -> __nonzero__
//////////////////
static int Dtool_BitMask_uint64_t_64_nonzero_470_nb_bool(PyObject *self) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return -1;
  }

  return (int) (*local_this).__nonzero__();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_inplace_and -> operator &=
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_458_nb_inplace_and(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint64_t_64, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void BitMask< uint64_t, 64 >::operator &=(BitMask< uint64_t, 64 > const &other)
    BitMask< uint64_t, 64 > arg_local;
    BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__iand__", "BitMask");
      return NULL;
    }
    (*local_this).operator &=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call BitMask.__iand__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_inplace_lshift -> operator <<=
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_461_nb_inplace_lshift(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint64_t_64, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void BitMask< uint64_t, 64 >::operator <<=(int shift)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator <<=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call BitMask.__ilshift__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_inplace_rshift -> operator >>=
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_462_nb_inplace_rshift(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint64_t_64, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void BitMask< uint64_t, 64 >::operator >>=(int shift)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator >>=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call BitMask.__irshift__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_inplace_xor -> operator ^=
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_460_nb_inplace_xor(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint64_t_64, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void BitMask< uint64_t, 64 >::operator ^=(BitMask< uint64_t, 64 > const &other)
    BitMask< uint64_t, 64 > arg_local;
    BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__ixor__", "BitMask");
      return NULL;
    }
    (*local_this).operator ^=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call BitMask.__ixor__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_invert -> operator ~
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_455_nb_invert(PyObject *self) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator ~(void) const
  BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((*(const BitMask< uint64_t, 64 >*)local_this).operator ~());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__invert__(BitMask self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_lshift -> operator <<
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_456_nb_lshift(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint64_t_64, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator <<(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((*(const BitMask< uint64_t, 64 >*)local_this).operator <<((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_or -> operator |
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_453_nb_or(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint64_t_64, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator |(BitMask< uint64_t, 64 > const &other) const
  BitMask< uint64_t, 64 > arg_local;
  BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__or__", "BitMask");
  }
  BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((*(const BitMask< uint64_t, 64 >*)local_this).operator |(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_rshift -> operator >>
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_457_nb_rshift(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint64_t_64, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator >>(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((*(const BitMask< uint64_t, 64 >*)local_this).operator >>((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_xor -> operator ^
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_454_nb_xor(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint64_t_64, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator ^(BitMask< uint64_t, 64 > const &other) const
  BitMask< uint64_t, 64 > arg_local;
  BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__xor__", "BitMask");
  }
  BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((*(const BitMask< uint64_t, 64 >*)local_this).operator ^(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot tp_compare -> compare_to
//////////////////
static int Dtool_BitMask_uint64_t_64_compare_to_451_tp_compare(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int BitMask< uint64_t, 64 >::compare_to(BitMask< uint64_t, 64 > const &other) const
  BitMask< uint64_t, 64 > arg_local;
  BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitMask.compare_to", "BitMask");
    return -1;
  }
  int return_value = (*(const BitMask< uint64_t, 64 >*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(BitMask self, const BitMask other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot tp_hash -> get_key
//////////////////
static Py_hash_t Dtool_BitMask_uint64_t_64_get_key_469_tp_hash(PyObject *self) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_key();
}

//////////////////
//  A __repr__ function
//     BitMask_uint64_t_64
//////////////////
static PyObject *Dtool_Repr_BitMask_uint64_t_64(PyObject *self) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     BitMask_uint64_t_64
//////////////////
static PyObject *Dtool_Str_BitMask_uint64_t_64(PyObject *self) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     BitMask_uint64_t_64
//////////////////
static PyObject *Dtool_RichCompare_BitMask_uint64_t_64(PyObject *self, PyObject *arg, int op) {
  BitMask< uint64_t, 64 > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool BitMask< uint64_t, 64 >::operator ==(BitMask< uint64_t, 64 > const &other) const
      BitMask< uint64_t, 64 > arg_local;
      BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const BitMask< uint64_t, 64 >*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool BitMask< uint64_t, 64 >::operator !=(BitMask< uint64_t, 64 > const &other) const
      BitMask< uint64_t, 64 > arg_local;
      BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const BitMask< uint64_t, 64 >*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool BitMask< uint64_t, 64 >::operator <(BitMask< uint64_t, 64 > const &other) const
      BitMask< uint64_t, 64 > arg_local;
      BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const BitMask< uint64_t, 64 >*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_BitMask_uint64_t_64_compare_to_451_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_BitMask_uint64_t_64 = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  &Dtool_BitMask_uint64_t_64_nonzero_470_nb_bool,
  &Dtool_BitMask_uint64_t_64_operator_455_nb_invert,
  &Dtool_BitMask_uint64_t_64_operator_456_nb_lshift,
  &Dtool_BitMask_uint64_t_64_operator_457_nb_rshift,
  &Dtool_BitMask_uint64_t_64_operator_452_nb_and,
  &Dtool_BitMask_uint64_t_64_operator_454_nb_xor,
  &Dtool_BitMask_uint64_t_64_operator_453_nb_or,
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  &Dtool_BitMask_uint64_t_64_operator_461_nb_inplace_lshift,
  &Dtool_BitMask_uint64_t_64_operator_462_nb_inplace_rshift,
  &Dtool_BitMask_uint64_t_64_operator_458_nb_inplace_and,
  &Dtool_BitMask_uint64_t_64_operator_460_nb_inplace_xor,
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_BitMask_uint64_t_64 = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.BitMask_uint64_t_64",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BitMask_uint64_t_64,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_BitMask_uint64_t_64_compare_to_451_tp_compare,
#endif
    &Dtool_Repr_BitMask_uint64_t_64,
    &Dtool_NumberMethods_BitMask_uint64_t_64,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &Dtool_BitMask_uint64_t_64_get_key_469_tp_hash,
    0, // tp_call
    &Dtool_Str_BitMask_uint64_t_64,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_BitMask_uint64_t_64,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BitMask_uint64_t_64,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BitMask_uint64_t_64,
    PyType_GenericAlloc,
    Dtool_new_BitMask_uint64_t_64,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BitMask_uint64_t_64,
  Dtool_UpcastInterface_BitMask_uint64_t_64,
  Dtool_DowncastInterface_BitMask_uint64_t_64,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_BitMask_uint64_t_64,
};

static void Dtool_PyModuleClassInit_BitMask_uint64_t_64(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_BitMask_uint64_t_64._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_BitMask_uint64_t_64._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BitMask_uint64_t_64) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BitMask_uint64_t_64)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BitMask_uint64_t_64);
  }
}

/**
 * Python method tables for BitArray (BitArray)
 */
static PyMethodDef Dtool_Methods_BitArray[] = {
  {"assign", &Dtool_BitArray_operator_477, METH_O, (const char *)Dtool_BitArray_operator_477_comment},
  {"all_on", &Dtool_BitArray_all_on_478, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_all_on_478_comment},
  {"allOn", &Dtool_BitArray_all_on_478, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_all_on_478_comment},
  {"all_off", &Dtool_BitArray_all_off_479, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_all_off_479_comment},
  {"allOff", &Dtool_BitArray_all_off_479, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_all_off_479_comment},
  {"lower_on", &Dtool_BitArray_lower_on_480, METH_O | METH_STATIC, (const char *)Dtool_BitArray_lower_on_480_comment},
  {"lowerOn", &Dtool_BitArray_lower_on_480, METH_O | METH_STATIC, (const char *)Dtool_BitArray_lower_on_480_comment},
  {"bit", &Dtool_BitArray_bit_481, METH_O | METH_STATIC, (const char *)Dtool_BitArray_bit_481_comment},
  {"range", (PyCFunction) &Dtool_BitArray_range_482, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_BitArray_range_482_comment},
  {"has_max_num_bits", &Dtool_BitArray_has_max_num_bits_484, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_has_max_num_bits_484_comment},
  {"hasMaxNumBits", &Dtool_BitArray_has_max_num_bits_484, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_has_max_num_bits_484_comment},
  {"get_max_num_bits", &Dtool_BitArray_get_max_num_bits_485, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_get_max_num_bits_485_comment},
  {"getMaxNumBits", &Dtool_BitArray_get_max_num_bits_485, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_get_max_num_bits_485_comment},
  {"get_num_bits_per_word", &Dtool_BitArray_get_num_bits_per_word_486, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_get_num_bits_per_word_486_comment},
  {"getNumBitsPerWord", &Dtool_BitArray_get_num_bits_per_word_486, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_get_num_bits_per_word_486_comment},
  {"get_num_bits", &Dtool_BitArray_get_num_bits_487, METH_NOARGS, (const char *)Dtool_BitArray_get_num_bits_487_comment},
  {"getNumBits", &Dtool_BitArray_get_num_bits_487, METH_NOARGS, (const char *)Dtool_BitArray_get_num_bits_487_comment},
  {"get_bit", &Dtool_BitArray_get_bit_488, METH_O, (const char *)Dtool_BitArray_get_bit_488_comment},
  {"getBit", &Dtool_BitArray_get_bit_488, METH_O, (const char *)Dtool_BitArray_get_bit_488_comment},
  {"set_bit", &Dtool_BitArray_set_bit_489, METH_O, (const char *)Dtool_BitArray_set_bit_489_comment},
  {"setBit", &Dtool_BitArray_set_bit_489, METH_O, (const char *)Dtool_BitArray_set_bit_489_comment},
  {"clear_bit", &Dtool_BitArray_clear_bit_490, METH_O, (const char *)Dtool_BitArray_clear_bit_490_comment},
  {"clearBit", &Dtool_BitArray_clear_bit_490, METH_O, (const char *)Dtool_BitArray_clear_bit_490_comment},
  {"set_bit_to", (PyCFunction) &Dtool_BitArray_set_bit_to_491, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_set_bit_to_491_comment},
  {"setBitTo", (PyCFunction) &Dtool_BitArray_set_bit_to_491, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_set_bit_to_491_comment},
  {"get_highest_bits", &Dtool_BitArray_get_highest_bits_492, METH_NOARGS, (const char *)Dtool_BitArray_get_highest_bits_492_comment},
  {"getHighestBits", &Dtool_BitArray_get_highest_bits_492, METH_NOARGS, (const char *)Dtool_BitArray_get_highest_bits_492_comment},
  {"is_zero", &Dtool_BitArray_is_zero_493, METH_NOARGS, (const char *)Dtool_BitArray_is_zero_493_comment},
  {"isZero", &Dtool_BitArray_is_zero_493, METH_NOARGS, (const char *)Dtool_BitArray_is_zero_493_comment},
  {"is_all_on", &Dtool_BitArray_is_all_on_494, METH_NOARGS, (const char *)Dtool_BitArray_is_all_on_494_comment},
  {"isAllOn", &Dtool_BitArray_is_all_on_494, METH_NOARGS, (const char *)Dtool_BitArray_is_all_on_494_comment},
  {"extract", (PyCFunction) &Dtool_BitArray_extract_495, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_extract_495_comment},
  {"store", (PyCFunction) &Dtool_BitArray_store_496, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_store_496_comment},
  {"has_any_of", (PyCFunction) &Dtool_BitArray_has_any_of_497, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_has_any_of_497_comment},
  {"hasAnyOf", (PyCFunction) &Dtool_BitArray_has_any_of_497, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_has_any_of_497_comment},
  {"has_all_of", (PyCFunction) &Dtool_BitArray_has_all_of_498, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_has_all_of_498_comment},
  {"hasAllOf", (PyCFunction) &Dtool_BitArray_has_all_of_498, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_has_all_of_498_comment},
  {"set_range", (PyCFunction) &Dtool_BitArray_set_range_499, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_set_range_499_comment},
  {"setRange", (PyCFunction) &Dtool_BitArray_set_range_499, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_set_range_499_comment},
  {"clear_range", (PyCFunction) &Dtool_BitArray_clear_range_500, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_clear_range_500_comment},
  {"clearRange", (PyCFunction) &Dtool_BitArray_clear_range_500, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_clear_range_500_comment},
  {"set_range_to", (PyCFunction) &Dtool_BitArray_set_range_to_501, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_set_range_to_501_comment},
  {"setRangeTo", (PyCFunction) &Dtool_BitArray_set_range_to_501, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_set_range_to_501_comment},
  {"get_num_on_bits", &Dtool_BitArray_get_num_on_bits_502, METH_NOARGS, (const char *)Dtool_BitArray_get_num_on_bits_502_comment},
  {"getNumOnBits", &Dtool_BitArray_get_num_on_bits_502, METH_NOARGS, (const char *)Dtool_BitArray_get_num_on_bits_502_comment},
  {"get_num_off_bits", &Dtool_BitArray_get_num_off_bits_503, METH_NOARGS, (const char *)Dtool_BitArray_get_num_off_bits_503_comment},
  {"getNumOffBits", &Dtool_BitArray_get_num_off_bits_503, METH_NOARGS, (const char *)Dtool_BitArray_get_num_off_bits_503_comment},
  {"get_lowest_on_bit", &Dtool_BitArray_get_lowest_on_bit_504, METH_NOARGS, (const char *)Dtool_BitArray_get_lowest_on_bit_504_comment},
  {"getLowestOnBit", &Dtool_BitArray_get_lowest_on_bit_504, METH_NOARGS, (const char *)Dtool_BitArray_get_lowest_on_bit_504_comment},
  {"get_lowest_off_bit", &Dtool_BitArray_get_lowest_off_bit_505, METH_NOARGS, (const char *)Dtool_BitArray_get_lowest_off_bit_505_comment},
  {"getLowestOffBit", &Dtool_BitArray_get_lowest_off_bit_505, METH_NOARGS, (const char *)Dtool_BitArray_get_lowest_off_bit_505_comment},
  {"get_highest_on_bit", &Dtool_BitArray_get_highest_on_bit_506, METH_NOARGS, (const char *)Dtool_BitArray_get_highest_on_bit_506_comment},
  {"getHighestOnBit", &Dtool_BitArray_get_highest_on_bit_506, METH_NOARGS, (const char *)Dtool_BitArray_get_highest_on_bit_506_comment},
  {"get_highest_off_bit", &Dtool_BitArray_get_highest_off_bit_507, METH_NOARGS, (const char *)Dtool_BitArray_get_highest_off_bit_507_comment},
  {"getHighestOffBit", &Dtool_BitArray_get_highest_off_bit_507, METH_NOARGS, (const char *)Dtool_BitArray_get_highest_off_bit_507_comment},
  {"get_next_higher_different_bit", &Dtool_BitArray_get_next_higher_different_bit_508, METH_O, (const char *)Dtool_BitArray_get_next_higher_different_bit_508_comment},
  {"getNextHigherDifferentBit", &Dtool_BitArray_get_next_higher_different_bit_508, METH_O, (const char *)Dtool_BitArray_get_next_higher_different_bit_508_comment},
  {"get_num_words", &Dtool_BitArray_get_num_words_509, METH_NOARGS, (const char *)Dtool_BitArray_get_num_words_509_comment},
  {"getNumWords", &Dtool_BitArray_get_num_words_509, METH_NOARGS, (const char *)Dtool_BitArray_get_num_words_509_comment},
  {"get_word", &Dtool_BitArray_get_word_510, METH_O, (const char *)Dtool_BitArray_get_word_510_comment},
  {"getWord", &Dtool_BitArray_get_word_510, METH_O, (const char *)Dtool_BitArray_get_word_510_comment},
  {"set_word", (PyCFunction) &Dtool_BitArray_set_word_511, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_set_word_511_comment},
  {"setWord", (PyCFunction) &Dtool_BitArray_set_word_511, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_set_word_511_comment},
  {"invert_in_place", &Dtool_BitArray_invert_in_place_512, METH_NOARGS, (const char *)Dtool_BitArray_invert_in_place_512_comment},
  {"invertInPlace", &Dtool_BitArray_invert_in_place_512, METH_NOARGS, (const char *)Dtool_BitArray_invert_in_place_512_comment},
  {"has_bits_in_common", &Dtool_BitArray_has_bits_in_common_513, METH_O, (const char *)Dtool_BitArray_has_bits_in_common_513_comment},
  {"hasBitsInCommon", &Dtool_BitArray_has_bits_in_common_513, METH_O, (const char *)Dtool_BitArray_has_bits_in_common_513_comment},
  {"clear", &Dtool_BitArray_clear_514, METH_NOARGS, (const char *)Dtool_BitArray_clear_514_comment},
  {"output", &Dtool_BitArray_output_515, METH_O, (const char *)Dtool_BitArray_output_515_comment},
  {"output_binary", (PyCFunction) &Dtool_BitArray_output_binary_516, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_output_binary_516_comment},
  {"outputBinary", (PyCFunction) &Dtool_BitArray_output_binary_516, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_output_binary_516_comment},
  {"output_hex", (PyCFunction) &Dtool_BitArray_output_hex_517, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_output_hex_517_comment},
  {"outputHex", (PyCFunction) &Dtool_BitArray_output_hex_517, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_output_hex_517_comment},
  {"write", (PyCFunction) &Dtool_BitArray_write_518, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_write_518_comment},
  {"compare_to", &Dtool_BitArray_compare_to_522, METH_O, (const char *)Dtool_BitArray_compare_to_522_comment},
  {"compareTo", &Dtool_BitArray_compare_to_522, METH_O, (const char *)Dtool_BitArray_compare_to_522_comment},
  {"__ior__", &Dtool_BitArray_operator_530, METH_O, (const char *)Dtool_BitArray_operator_530_comment},
  {"get_class_type", &Dtool_BitArray_get_class_type_534, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_get_class_type_534_comment},
  {"getClassType", &Dtool_BitArray_get_class_type_534, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_get_class_type_534_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_and -> operator &
//////////////////
static PyObject *Dtool_BitArray_operator_523_nb_and(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitArray, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitArray BitArray::operator &(BitArray const &other) const
  BitArray const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_BitArray(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitArray.__and__", "BitArray");
  }
  BitArray *return_value = new BitArray((*(const BitArray*)local_this).operator &(*arg_this));
  if (arg_manage) {
    delete arg_this;
  }
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_inplace_and -> operator &=
//////////////////
static PyObject *Dtool_BitArray_operator_529_nb_inplace_and(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitArray, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void BitArray::operator &=(BitArray const &other)
    BitArray const *arg_this;
    bool arg_manage = false;
    if (!Dtool_ConstCoerce_BitArray(arg, arg_this, arg_manage)) {
      Dtool_Raise_ArgTypeError(arg, 1, "BitArray.__iand__", "BitArray");
      return NULL;
    }
    (*local_this).operator &=(*arg_this);
    if (arg_manage) {
      delete arg_this;
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call BitArray.__iand__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_inplace_lshift -> operator <<=
//////////////////
static PyObject *Dtool_BitArray_operator_532_nb_inplace_lshift(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitArray, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void BitArray::operator <<=(int shift)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator <<=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call BitArray.__ilshift__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_inplace_rshift -> operator >>=
//////////////////
static PyObject *Dtool_BitArray_operator_533_nb_inplace_rshift(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitArray, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void BitArray::operator >>=(int shift)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator >>=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call BitArray.__irshift__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_inplace_xor -> operator ^=
//////////////////
static PyObject *Dtool_BitArray_operator_531_nb_inplace_xor(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitArray, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void BitArray::operator ^=(BitArray const &other)
    BitArray const *arg_this;
    bool arg_manage = false;
    if (!Dtool_ConstCoerce_BitArray(arg, arg_this, arg_manage)) {
      Dtool_Raise_ArgTypeError(arg, 1, "BitArray.__ixor__", "BitArray");
      return NULL;
    }
    (*local_this).operator ^=(*arg_this);
    if (arg_manage) {
      delete arg_this;
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call BitArray.__ixor__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_invert -> operator ~
//////////////////
static PyObject *Dtool_BitArray_operator_526_nb_invert(PyObject *self) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline BitArray BitArray::operator ~(void) const
  BitArray *return_value = new BitArray((*(const BitArray*)local_this).operator ~());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__invert__(BitArray self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_lshift -> operator <<
//////////////////
static PyObject *Dtool_BitArray_operator_527_nb_lshift(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitArray, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitArray BitArray::operator <<(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitArray *return_value = new BitArray((*(const BitArray*)local_this).operator <<((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_or -> operator |
//////////////////
static PyObject *Dtool_BitArray_operator_524_nb_or(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitArray, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitArray BitArray::operator |(BitArray const &other) const
  BitArray const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_BitArray(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitArray.__or__", "BitArray");
  }
  BitArray *return_value = new BitArray((*(const BitArray*)local_this).operator |(*arg_this));
  if (arg_manage) {
    delete arg_this;
  }
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_rshift -> operator >>
//////////////////
static PyObject *Dtool_BitArray_operator_528_nb_rshift(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitArray, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitArray BitArray::operator >>(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitArray *return_value = new BitArray((*(const BitArray*)local_this).operator >>((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_xor -> operator ^
//////////////////
static PyObject *Dtool_BitArray_operator_525_nb_xor(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitArray, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitArray BitArray::operator ^(BitArray const &other) const
  BitArray const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_BitArray(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitArray.__xor__", "BitArray");
  }
  BitArray *return_value = new BitArray((*(const BitArray*)local_this).operator ^(*arg_this));
  if (arg_manage) {
    delete arg_this;
  }
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot tp_compare -> compare_to
//////////////////
static int Dtool_BitArray_compare_to_522_tp_compare(PyObject *self, PyObject *arg) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return -1;
  }

  // 1-int BitArray::compare_to(BitArray const &other) const
  BitArray const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_BitArray(arg, arg_this, arg_manage)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitArray.compare_to", "BitArray");
    return -1;
  }
  int return_value = (*(const BitArray*)local_this).compare_to(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(BitArray self, const BitArray other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     BitArray
//////////////////
static PyObject *Dtool_Repr_BitArray(PyObject *self) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     BitArray
//////////////////
static PyObject *Dtool_Str_BitArray(PyObject *self) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     BitArray
//////////////////
static PyObject *Dtool_RichCompare_BitArray(PyObject *self, PyObject *arg, int op) {
  BitArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool BitArray::operator ==(BitArray const &other) const
      BitArray const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_BitArray(arg, arg_this, arg_manage)) {
        bool return_value = (*(const BitArray*)local_this).operator ==(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool BitArray::operator !=(BitArray const &other) const
      BitArray const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_BitArray(arg, arg_this, arg_manage)) {
        bool return_value = (*(const BitArray*)local_this).operator !=(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool BitArray::operator <(BitArray const &other) const
      BitArray const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_BitArray(arg, arg_this, arg_manage)) {
        bool return_value = (*(const BitArray*)local_this).operator <(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_BitArray_compare_to_522_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_BitArray = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  &Dtool_BitArray_operator_526_nb_invert,
  &Dtool_BitArray_operator_527_nb_lshift,
  &Dtool_BitArray_operator_528_nb_rshift,
  &Dtool_BitArray_operator_523_nb_and,
  &Dtool_BitArray_operator_525_nb_xor,
  &Dtool_BitArray_operator_524_nb_or,
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  &Dtool_BitArray_operator_532_nb_inplace_lshift,
  &Dtool_BitArray_operator_533_nb_inplace_rshift,
  &Dtool_BitArray_operator_529_nb_inplace_and,
  &Dtool_BitArray_operator_531_nb_inplace_xor,
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_BitArray = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.BitArray",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BitArray,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_BitArray_compare_to_522_tp_compare,
#endif
    &Dtool_Repr_BitArray,
    &Dtool_NumberMethods_BitArray,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Str_BitArray,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A dynamic array with an unlimited number of bits.\n"
    " *\n"
    " * This is similar to a BitMask, except it appears to contain an infinite\n"
    " * number of bits.  You can use it very much as you would use a BitMask.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_BitArray,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BitArray,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BitArray,
    PyType_GenericAlloc,
    Dtool_new_BitArray,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BitArray,
  Dtool_UpcastInterface_BitArray,
  Dtool_DowncastInterface_BitArray,
  (CoerceFunction)Dtool_ConstCoerce_BitArray,
  (CoerceFunction)Dtool_Coerce_BitArray,
};

static void Dtool_PyModuleClassInit_BitArray(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_BitArray._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_BitArray._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum BitArray::;
    PyDict_SetItemString(dict, "num_bits_per_word", Dtool_WrapValue(BitArray::num_bits_per_word));
    if (PyType_Ready((PyTypeObject *)&Dtool_BitArray) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BitArray)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BitArray);
  }
}

/**
 * Python method tables for ButtonHandle (ButtonHandle)
 */
static PyMethodDef Dtool_Methods_ButtonHandle[] = {
  {"compare_to", &Dtool_ButtonHandle_compare_to_543, METH_O, (const char *)Dtool_ButtonHandle_compare_to_543_comment},
  {"compareTo", &Dtool_ButtonHandle_compare_to_543, METH_O, (const char *)Dtool_ButtonHandle_compare_to_543_comment},
  {"get_hash", &Dtool_ButtonHandle_get_hash_544, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_hash_544_comment},
  {"getHash", &Dtool_ButtonHandle_get_hash_544, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_hash_544_comment},
  {"get_name", &Dtool_ButtonHandle_get_name_545, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_name_545_comment},
  {"getName", &Dtool_ButtonHandle_get_name_545, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_name_545_comment},
  {"has_ascii_equivalent", &Dtool_ButtonHandle_has_ascii_equivalent_546, METH_NOARGS, (const char *)Dtool_ButtonHandle_has_ascii_equivalent_546_comment},
  {"hasAsciiEquivalent", &Dtool_ButtonHandle_has_ascii_equivalent_546, METH_NOARGS, (const char *)Dtool_ButtonHandle_has_ascii_equivalent_546_comment},
  {"get_ascii_equivalent", &Dtool_ButtonHandle_get_ascii_equivalent_547, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_ascii_equivalent_547_comment},
  {"getAsciiEquivalent", &Dtool_ButtonHandle_get_ascii_equivalent_547, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_ascii_equivalent_547_comment},
  {"get_alias", &Dtool_ButtonHandle_get_alias_548, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_alias_548_comment},
  {"getAlias", &Dtool_ButtonHandle_get_alias_548, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_alias_548_comment},
  {"matches", &Dtool_ButtonHandle_matches_549, METH_O, (const char *)Dtool_ButtonHandle_matches_549_comment},
  {"get_index", &Dtool_ButtonHandle_get_index_550, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_index_550_comment},
  {"getIndex", &Dtool_ButtonHandle_get_index_550, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_index_550_comment},
  {"output", &Dtool_ButtonHandle_output_551, METH_O, (const char *)Dtool_ButtonHandle_output_551_comment},
  {"none", &Dtool_ButtonHandle_none_552, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonHandle_none_552_comment},
  {"get_class_type", &Dtool_ButtonHandle_get_class_type_561, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonHandle_get_class_type_561_comment},
  {"getClassType", &Dtool_ButtonHandle_get_class_type_561, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonHandle_get_class_type_561_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ButtonHandle slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_ButtonHandle_operator_typecast_bool_553_nb_bool(PyObject *self) {
  ButtonHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ButtonHandle slot tp_compare -> compare_to
//////////////////
static int Dtool_ButtonHandle_compare_to_543_tp_compare(PyObject *self, PyObject *arg) {
  ButtonHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int ButtonHandle::compare_to(ButtonHandle const &other) const
  ButtonHandle arg_local;
  ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ButtonHandle.compare_to", "ButtonHandle");
    return -1;
  }
  int return_value = (*(const ButtonHandle*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(ButtonHandle self, const ButtonHandle other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ButtonHandle slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_ButtonHandle_get_hash_544_tp_hash(PyObject *self) {
  ButtonHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

//////////////////
//  A __repr__ function
//     ButtonHandle
//////////////////
static PyObject *Dtool_Repr_ButtonHandle(PyObject *self) {
  ButtonHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     ButtonHandle
//////////////////
static PyObject *Dtool_RichCompare_ButtonHandle(PyObject *self, PyObject *arg, int op) {
  ButtonHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool ButtonHandle::operator ==(ButtonHandle const &other) const
      ButtonHandle arg_local;
      ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const ButtonHandle*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool ButtonHandle::operator !=(ButtonHandle const &other) const
      ButtonHandle arg_local;
      ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const ButtonHandle*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool ButtonHandle::operator <(ButtonHandle const &other) const
      ButtonHandle arg_local;
      ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const ButtonHandle*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LE:
    {
      // 1-inline bool ButtonHandle::operator <=(ButtonHandle const &other) const
      ButtonHandle arg_local;
      ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const ButtonHandle*)local_this).operator <=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_GT:
    {
      // 1-inline bool ButtonHandle::operator >(ButtonHandle const &other) const
      ButtonHandle arg_local;
      ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const ButtonHandle*)local_this).operator >(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_GE:
    {
      // 1-inline bool ButtonHandle::operator >=(ButtonHandle const &other) const
      ButtonHandle arg_local;
      ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const ButtonHandle*)local_this).operator >=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_ButtonHandle_compare_to_543_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_ButtonHandle[] = {
  {(char *)"index", &Dtool_ButtonHandle_index_Getter, NULL, NULL, NULL},
  {(char *)"name", &Dtool_ButtonHandle_name_Getter, NULL, NULL, NULL},
  {(char *)"ascii_equivalent", &Dtool_ButtonHandle_ascii_equivalent_Getter, NULL, NULL, NULL},
  {(char *)"alias", &Dtool_ButtonHandle_alias_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ButtonHandle = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  &Dtool_ButtonHandle_operator_typecast_bool_553_nb_bool,
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_ButtonHandle = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ButtonHandle",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ButtonHandle,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_ButtonHandle_compare_to_543_tp_compare,
#endif
    &Dtool_Repr_ButtonHandle,
    &Dtool_NumberMethods_ButtonHandle,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &Dtool_ButtonHandle_get_hash_544_tp_hash,
    0, // tp_call
    &Dtool_Repr_ButtonHandle,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A ButtonHandle represents a single button from any device, including\n"
    " * keyboard buttons and mouse buttons (but see KeyboardButton and\n"
    " * MouseButton).\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_ButtonHandle,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ButtonHandle,
    0, // tp_members
    Dtool_Properties_ButtonHandle,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ButtonHandle,
    PyType_GenericAlloc,
    Dtool_new_ButtonHandle,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ButtonHandle,
  Dtool_UpcastInterface_ButtonHandle,
  Dtool_DowncastInterface_ButtonHandle,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_ButtonHandle,
};

static void Dtool_PyModuleClassInit_ButtonHandle(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ButtonHandle._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_ButtonHandle._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ButtonHandle) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ButtonHandle)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ButtonHandle);
  }
}

/**
 * Python method tables for ButtonRegistry (ButtonRegistry)
 */
static PyMethodDef Dtool_Methods_ButtonRegistry[] = {
  {"get_button", &Dtool_ButtonRegistry_get_button_564, METH_O, (const char *)Dtool_ButtonRegistry_get_button_564_comment},
  {"getButton", &Dtool_ButtonRegistry_get_button_564, METH_O, (const char *)Dtool_ButtonRegistry_get_button_564_comment},
  {"find_button", &Dtool_ButtonRegistry_find_button_565, METH_O, (const char *)Dtool_ButtonRegistry_find_button_565_comment},
  {"findButton", &Dtool_ButtonRegistry_find_button_565, METH_O, (const char *)Dtool_ButtonRegistry_find_button_565_comment},
  {"find_ascii_button", &Dtool_ButtonRegistry_find_ascii_button_566, METH_O, (const char *)Dtool_ButtonRegistry_find_ascii_button_566_comment},
  {"findAsciiButton", &Dtool_ButtonRegistry_find_ascii_button_566, METH_O, (const char *)Dtool_ButtonRegistry_find_ascii_button_566_comment},
  {"write", &Dtool_ButtonRegistry_write_567, METH_O, (const char *)Dtool_ButtonRegistry_write_567_comment},
  {"ptr", &Dtool_ButtonRegistry_ptr_568, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonRegistry_ptr_568_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     ButtonRegistry
//////////////////
static PyObject *Dtool_Str_ButtonRegistry(PyObject *self) {
  ButtonRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonRegistry, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ButtonRegistry = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_ButtonRegistry = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ButtonRegistry",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ButtonRegistry,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ButtonRegistry,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_ButtonRegistry,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The ButtonRegistry class maintains all the assigned ButtonHandles in a\n"
    " * given system.  There should be only one ButtonRegistry class during the\n"
    " * lifetime of the application.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ButtonRegistry,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ButtonRegistry,
    PyType_GenericAlloc,
    Dtool_new_ButtonRegistry,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ButtonRegistry,
  Dtool_UpcastInterface_ButtonRegistry,
  Dtool_DowncastInterface_ButtonRegistry,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ButtonRegistry(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ButtonRegistry._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_ButtonRegistry._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ButtonRegistry) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ButtonRegistry)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ButtonRegistry);
  }
}

/**
 * Python method tables for ButtonMap (ButtonMap)
 */
static PyMethodDef Dtool_Methods_ButtonMap[] = {
  {"get_num_buttons", &Dtool_ButtonMap_get_num_buttons_573, METH_NOARGS, (const char *)Dtool_ButtonMap_get_num_buttons_573_comment},
  {"getNumButtons", &Dtool_ButtonMap_get_num_buttons_573, METH_NOARGS, (const char *)Dtool_ButtonMap_get_num_buttons_573_comment},
  {"get_raw_button", &Dtool_ButtonMap_get_raw_button_574, METH_O, (const char *)Dtool_ButtonMap_get_raw_button_574_comment},
  {"getRawButton", &Dtool_ButtonMap_get_raw_button_574, METH_O, (const char *)Dtool_ButtonMap_get_raw_button_574_comment},
  {"get_mapped_button", &Dtool_ButtonMap_get_mapped_button_575, METH_O, (const char *)Dtool_ButtonMap_get_mapped_button_575_comment},
  {"getMappedButton", &Dtool_ButtonMap_get_mapped_button_575, METH_O, (const char *)Dtool_ButtonMap_get_mapped_button_575_comment},
  {"get_mapped_button_label", &Dtool_ButtonMap_get_mapped_button_label_576, METH_O, (const char *)Dtool_ButtonMap_get_mapped_button_label_576_comment},
  {"getMappedButtonLabel", &Dtool_ButtonMap_get_mapped_button_label_576, METH_O, (const char *)Dtool_ButtonMap_get_mapped_button_label_576_comment},
  {"output", &Dtool_ButtonMap_output_577, METH_O, (const char *)Dtool_ButtonMap_output_577_comment},
  {"write", (PyCFunction) &Dtool_ButtonMap_write_578, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ButtonMap_write_578_comment},
  {"get_class_type", &Dtool_ButtonMap_get_class_type_579, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonMap_get_class_type_579_comment},
  {"getClassType", &Dtool_ButtonMap_get_class_type_579, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonMap_get_class_type_579_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     ButtonMap
//////////////////
static PyObject *Dtool_Repr_ButtonMap(PyObject *self) {
  ButtonMap *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonMap, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ButtonMap
//////////////////
static PyObject *Dtool_Str_ButtonMap(PyObject *self) {
  ButtonMap *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonMap, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ButtonMap = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ButtonMap = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ButtonMap = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ButtonMap = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ButtonMap = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ButtonMap",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ButtonMap,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_ButtonMap,
    &Dtool_NumberMethods_ButtonMap,
    &Dtool_SequenceMethods_ButtonMap,
    &Dtool_MappingMethods_ButtonMap,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_ButtonMap,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ButtonMap,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class represents a map containing all of the buttons of a (keyboard)\n"
    " * device, though it can also be used as a generic mapping between\n"
    " * ButtonHandles.  It maps an underlying 'raw' button to a 'virtual' button,\n"
    " * which may optionally be associated with an appropriate platform-specific\n"
    " * name for the button.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ButtonMap,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ButtonMap,
    PyType_GenericAlloc,
    Dtool_new_ButtonMap,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ButtonMap,
  Dtool_UpcastInterface_ButtonMap,
  Dtool_DowncastInterface_ButtonMap,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ButtonMap(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_ButtonMap._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_ButtonMap._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ButtonMap) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ButtonMap)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ButtonMap);
  }
}

/**
 * Python method tables for CallbackObject (CallbackObject)
 */
static PyMethodDef Dtool_Methods_CallbackObject[] = {
  {"output", &Dtool_CallbackObject_output_583, METH_O, (const char *)Dtool_CallbackObject_output_583_comment},
  {"make", &Dtool_CallbackObject_make_584, METH_O | METH_STATIC, (const char *)Dtool_CallbackObject_make_584_comment},
  {"get_class_type", &Dtool_CallbackObject_get_class_type_585, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackObject_get_class_type_585_comment},
  {"getClassType", &Dtool_CallbackObject_get_class_type_585, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackObject_get_class_type_585_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     CallbackObject
//////////////////
static PyObject *Dtool_Repr_CallbackObject(PyObject *self) {
  CallbackObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CallbackObject, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_CallbackObject = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CallbackObject = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CallbackObject = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CallbackObject = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CallbackObject = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CallbackObject",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CallbackObject,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_CallbackObject,
    &Dtool_NumberMethods_CallbackObject,
    &Dtool_SequenceMethods_CallbackObject,
    &Dtool_MappingMethods_CallbackObject,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_CallbackObject,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CallbackObject,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a generic object that can be assigned to a callback at various\n"
    " * points in the rendering process.  This is actually a base class for a\n"
    " * handful of specialized callback object types.  You can also subclass it\n"
    " * yourself to make your own callback handler.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CallbackObject,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CallbackObject,
    PyType_GenericAlloc,
    Dtool_new_CallbackObject,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CallbackObject,
  Dtool_UpcastInterface_CallbackObject,
  Dtool_DowncastInterface_CallbackObject,
  (CoerceFunction)Dtool_ConstCoerce_CallbackObject,
  (CoerceFunction)Dtool_Coerce_CallbackObject,
};

static void Dtool_PyModuleClassInit_CallbackObject(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_CallbackObject._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_CallbackObject._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CallbackObject) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CallbackObject)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CallbackObject);
  }
}

/**
 * Python method tables for CachedTypedWritableReferenceCount (CachedTypedWritableReferenceCount)
 */
static PyMethodDef Dtool_Methods_CachedTypedWritableReferenceCount[] = {
  {"get_cache_ref_count", &Dtool_CachedTypedWritableReferenceCount_get_cache_ref_count_589, METH_NOARGS, (const char *)Dtool_CachedTypedWritableReferenceCount_get_cache_ref_count_589_comment},
  {"getCacheRefCount", &Dtool_CachedTypedWritableReferenceCount_get_cache_ref_count_589, METH_NOARGS, (const char *)Dtool_CachedTypedWritableReferenceCount_get_cache_ref_count_589_comment},
  {"cache_ref", &Dtool_CachedTypedWritableReferenceCount_cache_ref_590, METH_NOARGS, (const char *)Dtool_CachedTypedWritableReferenceCount_cache_ref_590_comment},
  {"cacheRef", &Dtool_CachedTypedWritableReferenceCount_cache_ref_590, METH_NOARGS, (const char *)Dtool_CachedTypedWritableReferenceCount_cache_ref_590_comment},
  {"cache_unref", &Dtool_CachedTypedWritableReferenceCount_cache_unref_591, METH_NOARGS, (const char *)Dtool_CachedTypedWritableReferenceCount_cache_unref_591_comment},
  {"cacheUnref", &Dtool_CachedTypedWritableReferenceCount_cache_unref_591, METH_NOARGS, (const char *)Dtool_CachedTypedWritableReferenceCount_cache_unref_591_comment},
  {"test_ref_count_integrity", &Dtool_CachedTypedWritableReferenceCount_test_ref_count_integrity_592, METH_NOARGS, (const char *)Dtool_CachedTypedWritableReferenceCount_test_ref_count_integrity_592_comment},
  {"testRefCountIntegrity", &Dtool_CachedTypedWritableReferenceCount_test_ref_count_integrity_592, METH_NOARGS, (const char *)Dtool_CachedTypedWritableReferenceCount_test_ref_count_integrity_592_comment},
  {"get_class_type", &Dtool_CachedTypedWritableReferenceCount_get_class_type_594, METH_NOARGS | METH_STATIC, (const char *)Dtool_CachedTypedWritableReferenceCount_get_class_type_594_comment},
  {"getClassType", &Dtool_CachedTypedWritableReferenceCount_get_class_type_594, METH_NOARGS | METH_STATIC, (const char *)Dtool_CachedTypedWritableReferenceCount_get_class_type_594_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_CachedTypedWritableReferenceCount[] = {
  {(char *)"cache_ref_count", &Dtool_CachedTypedWritableReferenceCount_cache_ref_count_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CachedTypedWritableReferenceCount = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CachedTypedWritableReferenceCount = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CachedTypedWritableReferenceCount = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CachedTypedWritableReferenceCount = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CachedTypedWritableReferenceCount = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CachedTypedWritableReferenceCount",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CachedTypedWritableReferenceCount,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CachedTypedWritableReferenceCount,
    &Dtool_SequenceMethods_CachedTypedWritableReferenceCount,
    &Dtool_MappingMethods_CachedTypedWritableReferenceCount,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CachedTypedWritableReferenceCount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special extension to ReferenceCount that includes dual reference\n"
    " * counts: the standard reference count number, which includes all references\n"
    " * to the object, and a separate number (the cache reference count) that\n"
    " * counts the number of references to the object just within its cache alone.\n"
    " * When get_ref_count() == get_cache_ref_count(), the object is not referenced\n"
    " * outside the cache.\n"
    " *\n"
    " * The cache refs must be explicitly maintained; there is no PointerTo<> class\n"
    " * to maintain the cache reference counts automatically.  The cache reference\n"
    " * count is automatically included in the overall reference count: calling\n"
    " * cache_ref() and cache_unref() automatically calls ref() and unref().\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CachedTypedWritableReferenceCount,
    0, // tp_members
    Dtool_Properties_CachedTypedWritableReferenceCount,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CachedTypedWritableReferenceCount,
    PyType_GenericAlloc,
    Dtool_new_CachedTypedWritableReferenceCount,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CachedTypedWritableReferenceCount,
  Dtool_UpcastInterface_CachedTypedWritableReferenceCount,
  Dtool_DowncastInterface_CachedTypedWritableReferenceCount,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CachedTypedWritableReferenceCount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TypedWritableReferenceCount(NULL);
    Dtool_CachedTypedWritableReferenceCount._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TypedWritableReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_CachedTypedWritableReferenceCount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CachedTypedWritableReferenceCount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CachedTypedWritableReferenceCount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CachedTypedWritableReferenceCount);
  }
}

/**
 * Python method tables for CallbackData (CallbackData)
 */
static PyMethodDef Dtool_Methods_CallbackData[] = {
  {"output", &Dtool_CallbackData_output_596, METH_O, (const char *)Dtool_CallbackData_output_596_comment},
  {"upcall", &Dtool_CallbackData_upcall_597, METH_NOARGS, (const char *)Dtool_CallbackData_upcall_597_comment},
  {"get_class_type", &Dtool_CallbackData_get_class_type_598, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackData_get_class_type_598_comment},
  {"getClassType", &Dtool_CallbackData_get_class_type_598, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackData_get_class_type_598_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     CallbackData
//////////////////
static PyObject *Dtool_Repr_CallbackData(PyObject *self) {
  CallbackData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CallbackData, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_CallbackData = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CallbackData = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CallbackData = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CallbackData = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CallbackData = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CallbackData",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CallbackData,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_CallbackData,
    &Dtool_NumberMethods_CallbackData,
    &Dtool_SequenceMethods_CallbackData,
    &Dtool_MappingMethods_CallbackData,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_CallbackData,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CallbackData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a generic data block that is passed along to a CallbackObject when\n"
    " * a callback is made.  It contains data specific to the particular callback\n"
    " * type in question.\n"
    " *\n"
    " * This is actually an abstract base class and contains no data.\n"
    " * Specializations of this class will contain the actual data relevant to each\n"
    " * callback type.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CallbackData,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CallbackData,
    PyType_GenericAlloc,
    Dtool_new_CallbackData,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CallbackData,
  Dtool_UpcastInterface_CallbackData,
  Dtool_DowncastInterface_CallbackData,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CallbackData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != NULL);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(NULL);
    Dtool_CallbackData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    PyObject *dict = PyDict_New();
    Dtool_CallbackData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CallbackData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CallbackData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CallbackData);
  }
}

/**
 * Python method tables for PythonCallbackObject (PythonCallbackObject)
 */
static PyMethodDef Dtool_Methods_PythonCallbackObject[] = {
  {"set_function", &Dtool_PythonCallbackObject_set_function_606, METH_O, (const char *)Dtool_PythonCallbackObject_set_function_606_comment},
  {"setFunction", &Dtool_PythonCallbackObject_set_function_606, METH_O, (const char *)Dtool_PythonCallbackObject_set_function_606_comment},
  {"get_function", &Dtool_PythonCallbackObject_get_function_607, METH_NOARGS, (const char *)Dtool_PythonCallbackObject_get_function_607_comment},
  {"getFunction", &Dtool_PythonCallbackObject_get_function_607, METH_NOARGS, (const char *)Dtool_PythonCallbackObject_get_function_607_comment},
  {"get_class_type", &Dtool_PythonCallbackObject_get_class_type_609, METH_NOARGS | METH_STATIC, (const char *)Dtool_PythonCallbackObject_get_class_type_609_comment},
  {"getClassType", &Dtool_PythonCallbackObject_get_class_type_609, METH_NOARGS | METH_STATIC, (const char *)Dtool_PythonCallbackObject_get_class_type_609_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_PythonCallbackObject[] = {
  {(char *)"function", &Dtool_PythonCallbackObject_function_Getter, &Dtool_PythonCallbackObject_function_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_PythonCallbackObject = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PythonCallbackObject = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PythonCallbackObject = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PythonCallbackObject = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PythonCallbackObject = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PythonCallbackObject",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PythonCallbackObject,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PythonCallbackObject,
    &Dtool_SequenceMethods_PythonCallbackObject,
    &Dtool_MappingMethods_PythonCallbackObject,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PythonCallbackObject,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a specialization on CallbackObject to allow a callback to directly\n"
    " * call an arbitarary Python function.  Powerful!  But use with caution.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PythonCallbackObject,
    0, // tp_members
    Dtool_Properties_PythonCallbackObject,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PythonCallbackObject,
    PyType_GenericAlloc,
    Dtool_new_PythonCallbackObject,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PythonCallbackObject,
  Dtool_UpcastInterface_PythonCallbackObject,
  Dtool_DowncastInterface_PythonCallbackObject,
  (CoerceFunction)Dtool_ConstCoerce_PythonCallbackObject,
  (CoerceFunction)Dtool_Coerce_PythonCallbackObject,
};

static void Dtool_PyModuleClassInit_PythonCallbackObject(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CallbackObject(NULL);
    Dtool_PythonCallbackObject._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CallbackObject);
    PyObject *dict = PyDict_New();
    Dtool_PythonCallbackObject._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PythonCallbackObject) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PythonCallbackObject)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PythonCallbackObject);
  }
}

/**
 * Python method tables for TimeVal (TimeVal)
 */
static PyMethodDef Dtool_Methods_TimeVal[] = {
  {"get_sec", &Dtool_TimeVal_get_sec_612, METH_NOARGS, (const char *)Dtool_TimeVal_get_sec_612_comment},
  {"getSec", &Dtool_TimeVal_get_sec_612, METH_NOARGS, (const char *)Dtool_TimeVal_get_sec_612_comment},
  {"get_usec", &Dtool_TimeVal_get_usec_613, METH_NOARGS, (const char *)Dtool_TimeVal_get_usec_613_comment},
  {"getUsec", &Dtool_TimeVal_get_usec_613, METH_NOARGS, (const char *)Dtool_TimeVal_get_usec_613_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_TimeVal = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_TimeVal = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.TimeVal",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TimeVal,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TimeVal,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TimeVal,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TimeVal,
    PyType_GenericAlloc,
    Dtool_new_TimeVal,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TimeVal,
  Dtool_UpcastInterface_TimeVal,
  Dtool_DowncastInterface_TimeVal,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_TimeVal(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TimeVal._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_TimeVal._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TimeVal) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TimeVal)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TimeVal);
  }
}

/**
 * Python method tables for ClockObject (ClockObject)
 */
static PyMethodDef Dtool_Methods_ClockObject[] = {
  {"set_mode", &Dtool_ClockObject_set_mode_624, METH_O, (const char *)Dtool_ClockObject_set_mode_624_comment},
  {"setMode", &Dtool_ClockObject_set_mode_624, METH_O, (const char *)Dtool_ClockObject_set_mode_624_comment},
  {"get_mode", &Dtool_ClockObject_get_mode_625, METH_NOARGS, (const char *)Dtool_ClockObject_get_mode_625_comment},
  {"getMode", &Dtool_ClockObject_get_mode_625, METH_NOARGS, (const char *)Dtool_ClockObject_get_mode_625_comment},
  {"get_frame_time", (PyCFunction) &Dtool_ClockObject_get_frame_time_627, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_frame_time_627_comment},
  {"getFrameTime", (PyCFunction) &Dtool_ClockObject_get_frame_time_627, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_frame_time_627_comment},
  {"get_real_time", &Dtool_ClockObject_get_real_time_628, METH_NOARGS, (const char *)Dtool_ClockObject_get_real_time_628_comment},
  {"getRealTime", &Dtool_ClockObject_get_real_time_628, METH_NOARGS, (const char *)Dtool_ClockObject_get_real_time_628_comment},
  {"get_long_time", &Dtool_ClockObject_get_long_time_629, METH_NOARGS, (const char *)Dtool_ClockObject_get_long_time_629_comment},
  {"getLongTime", &Dtool_ClockObject_get_long_time_629, METH_NOARGS, (const char *)Dtool_ClockObject_get_long_time_629_comment},
  {"reset", &Dtool_ClockObject_reset_630, METH_NOARGS, (const char *)Dtool_ClockObject_reset_630_comment},
  {"set_real_time", &Dtool_ClockObject_set_real_time_631, METH_O, (const char *)Dtool_ClockObject_set_real_time_631_comment},
  {"setRealTime", &Dtool_ClockObject_set_real_time_631, METH_O, (const char *)Dtool_ClockObject_set_real_time_631_comment},
  {"set_frame_time", (PyCFunction) &Dtool_ClockObject_set_frame_time_632, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_set_frame_time_632_comment},
  {"setFrameTime", (PyCFunction) &Dtool_ClockObject_set_frame_time_632, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_set_frame_time_632_comment},
  {"set_frame_count", (PyCFunction) &Dtool_ClockObject_set_frame_count_633, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_set_frame_count_633_comment},
  {"setFrameCount", (PyCFunction) &Dtool_ClockObject_set_frame_count_633, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_set_frame_count_633_comment},
  {"get_frame_count", (PyCFunction) &Dtool_ClockObject_get_frame_count_634, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_frame_count_634_comment},
  {"getFrameCount", (PyCFunction) &Dtool_ClockObject_get_frame_count_634, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_frame_count_634_comment},
  {"get_net_frame_rate", (PyCFunction) &Dtool_ClockObject_get_net_frame_rate_635, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_net_frame_rate_635_comment},
  {"getNetFrameRate", (PyCFunction) &Dtool_ClockObject_get_net_frame_rate_635, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_net_frame_rate_635_comment},
  {"get_dt", (PyCFunction) &Dtool_ClockObject_get_dt_640, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_dt_640_comment},
  {"getDt", (PyCFunction) &Dtool_ClockObject_get_dt_640, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_dt_640_comment},
  {"set_dt", &Dtool_ClockObject_set_dt_641, METH_O, (const char *)Dtool_ClockObject_set_dt_641_comment},
  {"setDt", &Dtool_ClockObject_set_dt_641, METH_O, (const char *)Dtool_ClockObject_set_dt_641_comment},
  {"set_frame_rate", &Dtool_ClockObject_set_frame_rate_642, METH_O, (const char *)Dtool_ClockObject_set_frame_rate_642_comment},
  {"setFrameRate", &Dtool_ClockObject_set_frame_rate_642, METH_O, (const char *)Dtool_ClockObject_set_frame_rate_642_comment},
  {"get_max_dt", &Dtool_ClockObject_get_max_dt_644, METH_NOARGS, (const char *)Dtool_ClockObject_get_max_dt_644_comment},
  {"getMaxDt", &Dtool_ClockObject_get_max_dt_644, METH_NOARGS, (const char *)Dtool_ClockObject_get_max_dt_644_comment},
  {"set_max_dt", &Dtool_ClockObject_set_max_dt_645, METH_O, (const char *)Dtool_ClockObject_set_max_dt_645_comment},
  {"setMaxDt", &Dtool_ClockObject_set_max_dt_645, METH_O, (const char *)Dtool_ClockObject_set_max_dt_645_comment},
  {"get_degrade_factor", &Dtool_ClockObject_get_degrade_factor_647, METH_NOARGS, (const char *)Dtool_ClockObject_get_degrade_factor_647_comment},
  {"getDegradeFactor", &Dtool_ClockObject_get_degrade_factor_647, METH_NOARGS, (const char *)Dtool_ClockObject_get_degrade_factor_647_comment},
  {"set_degrade_factor", &Dtool_ClockObject_set_degrade_factor_648, METH_O, (const char *)Dtool_ClockObject_set_degrade_factor_648_comment},
  {"setDegradeFactor", &Dtool_ClockObject_set_degrade_factor_648, METH_O, (const char *)Dtool_ClockObject_set_degrade_factor_648_comment},
  {"set_average_frame_rate_interval", &Dtool_ClockObject_set_average_frame_rate_interval_650, METH_O, (const char *)Dtool_ClockObject_set_average_frame_rate_interval_650_comment},
  {"setAverageFrameRateInterval", &Dtool_ClockObject_set_average_frame_rate_interval_650, METH_O, (const char *)Dtool_ClockObject_set_average_frame_rate_interval_650_comment},
  {"get_average_frame_rate_interval", &Dtool_ClockObject_get_average_frame_rate_interval_651, METH_NOARGS, (const char *)Dtool_ClockObject_get_average_frame_rate_interval_651_comment},
  {"getAverageFrameRateInterval", &Dtool_ClockObject_get_average_frame_rate_interval_651, METH_NOARGS, (const char *)Dtool_ClockObject_get_average_frame_rate_interval_651_comment},
  {"get_average_frame_rate", (PyCFunction) &Dtool_ClockObject_get_average_frame_rate_653, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_average_frame_rate_653_comment},
  {"getAverageFrameRate", (PyCFunction) &Dtool_ClockObject_get_average_frame_rate_653, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_average_frame_rate_653_comment},
  {"get_max_frame_duration", (PyCFunction) &Dtool_ClockObject_get_max_frame_duration_654, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_max_frame_duration_654_comment},
  {"getMaxFrameDuration", (PyCFunction) &Dtool_ClockObject_get_max_frame_duration_654, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_max_frame_duration_654_comment},
  {"calc_frame_rate_deviation", (PyCFunction) &Dtool_ClockObject_calc_frame_rate_deviation_655, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_calc_frame_rate_deviation_655_comment},
  {"calcFrameRateDeviation", (PyCFunction) &Dtool_ClockObject_calc_frame_rate_deviation_655, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_calc_frame_rate_deviation_655_comment},
  {"tick", (PyCFunction) &Dtool_ClockObject_tick_658, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_tick_658_comment},
  {"sync_frame_time", (PyCFunction) &Dtool_ClockObject_sync_frame_time_659, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_sync_frame_time_659_comment},
  {"syncFrameTime", (PyCFunction) &Dtool_ClockObject_sync_frame_time_659, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_sync_frame_time_659_comment},
  {"check_errors", &Dtool_ClockObject_check_errors_660, METH_O, (const char *)Dtool_ClockObject_check_errors_660_comment},
  {"checkErrors", &Dtool_ClockObject_check_errors_660, METH_O, (const char *)Dtool_ClockObject_check_errors_660_comment},
  {"get_global_clock", &Dtool_ClockObject_get_global_clock_661, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClockObject_get_global_clock_661_comment},
  {"getGlobalClock", &Dtool_ClockObject_get_global_clock_661, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClockObject_get_global_clock_661_comment},
  {"get_class_type", &Dtool_ClockObject_get_class_type_662, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClockObject_get_class_type_662_comment},
  {"getClassType", &Dtool_ClockObject_get_class_type_662, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClockObject_get_class_type_662_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ClockObject[] = {
  {(char *)"mode", &Dtool_ClockObject_mode_Getter, &Dtool_ClockObject_mode_Setter, NULL, NULL},
  {(char *)"frame_time", &Dtool_ClockObject_frame_time_Getter, &Dtool_ClockObject_frame_time_Setter, NULL, NULL},
  {(char *)"real_time", &Dtool_ClockObject_real_time_Getter, &Dtool_ClockObject_real_time_Setter, NULL, NULL},
  {(char *)"long_time", &Dtool_ClockObject_long_time_Getter, NULL, NULL, NULL},
  {(char *)"frame_count", &Dtool_ClockObject_frame_count_Getter, &Dtool_ClockObject_frame_count_Setter, NULL, NULL},
  {(char *)"dt", &Dtool_ClockObject_dt_Getter, &Dtool_ClockObject_dt_Setter, NULL, NULL},
  {(char *)"max_dt", &Dtool_ClockObject_max_dt_Getter, &Dtool_ClockObject_max_dt_Setter, NULL, NULL},
  {(char *)"degrade_factor", &Dtool_ClockObject_degrade_factor_Getter, &Dtool_ClockObject_degrade_factor_Setter, NULL, NULL},
  {(char *)"average_frame_rate_interval", &Dtool_ClockObject_average_frame_rate_interval_Getter, &Dtool_ClockObject_average_frame_rate_interval_Setter, NULL, NULL},
  {(char *)"average_frame_rate", &Dtool_ClockObject_average_frame_rate_Getter, NULL, NULL, NULL},
  {(char *)"max_frame_duration", &Dtool_ClockObject_max_frame_duration_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ClockObject = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ClockObject = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ClockObject = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ClockObject = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ClockObject = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ClockObject",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ClockObject,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ClockObject,
    &Dtool_SequenceMethods_ClockObject,
    &Dtool_MappingMethods_ClockObject,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ClockObject,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A ClockObject keeps track of elapsed real time and discrete time.  In\n"
    " * normal mode, get_frame_time() returns the time as of the last time tick()\n"
    " * was called.  This is the \"discrete\" time, and is usually used to get the\n"
    " * time as of, for instance, the beginning of the current frame.\n"
    " *\n"
    " * In other modes, as set by set_mode() or the clock-mode config variable,\n"
    " * get_frame_time() may return other values to simulate different timing\n"
    " * effects, for instance to perform non-real-time animation.  See set_mode().\n"
    " *\n"
    " * In all modes, get_real_time() always returns the elapsed real time in\n"
    " * seconds since the ClockObject was constructed, or since it was last reset.\n"
    " *\n"
    " * You can create your own ClockObject whenever you want to have your own\n"
    " * local timer.  There is also a default, global ClockObject intended to\n"
    " * represent global time for the application; this is normally set up to tick\n"
    " * every frame so that its get_frame_time() will return the time for the\n"
    " * current frame.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ClockObject,
    0, // tp_members
    Dtool_Properties_ClockObject,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ClockObject,
    PyType_GenericAlloc,
    Dtool_new_ClockObject,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ClockObject,
  Dtool_UpcastInterface_ClockObject,
  Dtool_DowncastInterface_ClockObject,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ClockObject(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_ClockObject._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = _PyDict_NewPresized(17);
    Dtool_ClockObject._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum ClockObject::Mode;
    PyDict_SetItemString(dict, "M_normal", Dtool_WrapValue(ClockObject::M_normal));
    PyDict_SetItemString(dict, "MNormal", Dtool_WrapValue(ClockObject::M_normal));
    PyDict_SetItemString(dict, "M_non_real_time", Dtool_WrapValue(ClockObject::M_non_real_time));
    PyDict_SetItemString(dict, "MNonRealTime", Dtool_WrapValue(ClockObject::M_non_real_time));
    PyDict_SetItemString(dict, "M_forced", Dtool_WrapValue(ClockObject::M_forced));
    PyDict_SetItemString(dict, "MForced", Dtool_WrapValue(ClockObject::M_forced));
    PyDict_SetItemString(dict, "M_degrade", Dtool_WrapValue(ClockObject::M_degrade));
    PyDict_SetItemString(dict, "MDegrade", Dtool_WrapValue(ClockObject::M_degrade));
    PyDict_SetItemString(dict, "M_slave", Dtool_WrapValue(ClockObject::M_slave));
    PyDict_SetItemString(dict, "MSlave", Dtool_WrapValue(ClockObject::M_slave));
    PyDict_SetItemString(dict, "M_limited", Dtool_WrapValue(ClockObject::M_limited));
    PyDict_SetItemString(dict, "MLimited", Dtool_WrapValue(ClockObject::M_limited));
    PyDict_SetItemString(dict, "M_integer", Dtool_WrapValue(ClockObject::M_integer));
    PyDict_SetItemString(dict, "MInteger", Dtool_WrapValue(ClockObject::M_integer));
    PyDict_SetItemString(dict, "M_integer_limited", Dtool_WrapValue(ClockObject::M_integer_limited));
    PyDict_SetItemString(dict, "MIntegerLimited", Dtool_WrapValue(ClockObject::M_integer_limited));
    if (PyType_Ready((PyTypeObject *)&Dtool_ClockObject) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ClockObject)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ClockObject);
  }
}

/**
 * Python method tables for CopyOnWriteObject (CopyOnWriteObject)
 */
static PyMethodDef Dtool_Methods_CopyOnWriteObject[] = {
  {"cache_ref", &Dtool_CopyOnWriteObject_cache_ref_670, METH_NOARGS, (const char *)Dtool_CopyOnWriteObject_cache_ref_670_comment},
  {"cacheRef", &Dtool_CopyOnWriteObject_cache_ref_670, METH_NOARGS, (const char *)Dtool_CopyOnWriteObject_cache_ref_670_comment},
  {"get_class_type", &Dtool_CopyOnWriteObject_get_class_type_671, METH_NOARGS | METH_STATIC, (const char *)Dtool_CopyOnWriteObject_get_class_type_671_comment},
  {"getClassType", &Dtool_CopyOnWriteObject_get_class_type_671, METH_NOARGS | METH_STATIC, (const char *)Dtool_CopyOnWriteObject_get_class_type_671_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CopyOnWriteObject = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CopyOnWriteObject = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CopyOnWriteObject = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CopyOnWriteObject = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CopyOnWriteObject = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CopyOnWriteObject",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CopyOnWriteObject,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CopyOnWriteObject,
    &Dtool_SequenceMethods_CopyOnWriteObject,
    &Dtool_MappingMethods_CopyOnWriteObject,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CopyOnWriteObject,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This base class provides basic reference counting, but also can be used\n"
    " * with a CopyOnWritePointer to provide get_read_pointer() and\n"
    " * get_write_pointer().\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CopyOnWriteObject,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CopyOnWriteObject,
    PyType_GenericAlloc,
    Dtool_new_CopyOnWriteObject,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CopyOnWriteObject,
  Dtool_UpcastInterface_CopyOnWriteObject,
  Dtool_DowncastInterface_CopyOnWriteObject,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CopyOnWriteObject(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CachedTypedWritableReferenceCount(NULL);
    Dtool_CopyOnWriteObject._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CachedTypedWritableReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_CopyOnWriteObject._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CopyOnWriteObject) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CopyOnWriteObject)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CopyOnWriteObject);
  }
}

/**
 * Python method tables for DatagramInputFile (DatagramInputFile)
 */
static PyMethodDef Dtool_Methods_DatagramInputFile[] = {
  {"open", (PyCFunction) &Dtool_DatagramInputFile_open_675, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DatagramInputFile_open_675_comment},
  {"get_stream", &Dtool_DatagramInputFile_get_stream_676, METH_NOARGS, (const char *)Dtool_DatagramInputFile_get_stream_676_comment},
  {"getStream", &Dtool_DatagramInputFile_get_stream_676, METH_NOARGS, (const char *)Dtool_DatagramInputFile_get_stream_676_comment},
  {"close", &Dtool_DatagramInputFile_close_677, METH_NOARGS, (const char *)Dtool_DatagramInputFile_close_677_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DatagramInputFile = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DatagramInputFile = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DatagramInputFile = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DatagramInputFile = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DatagramInputFile = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.DatagramInputFile",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DatagramInputFile,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DatagramInputFile,
    &Dtool_SequenceMethods_DatagramInputFile,
    &Dtool_MappingMethods_DatagramInputFile,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DatagramInputFile,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class can be used to read a binary file that consists of an arbitrary\n"
    " * header followed by a number of datagrams.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DatagramInputFile,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DatagramInputFile,
    PyType_GenericAlloc,
    Dtool_new_DatagramInputFile,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DatagramInputFile,
  Dtool_UpcastInterface_DatagramInputFile,
  Dtool_DowncastInterface_DatagramInputFile,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DatagramInputFile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DatagramGenerator != NULL);
    assert(Dtool_Ptr_DatagramGenerator->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_DatagramGenerator->_Dtool_ModuleClassInit(NULL);
    Dtool_DatagramInputFile._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DatagramGenerator);
    PyObject *dict = PyDict_New();
    Dtool_DatagramInputFile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DatagramInputFile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DatagramInputFile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DatagramInputFile);
  }
}

/**
 * Python method tables for DoubleBitMask_BitMaskNative (DoubleBitMask_BitMaskNative)
 */
static PyMethodDef Dtool_Methods_DoubleBitMask_BitMaskNative[] = {
  {"assign", &Dtool_DoubleBitMask_BitMaskNative_operator_681, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_operator_681_comment},
  {"all_on", &Dtool_DoubleBitMask_BitMaskNative_all_on_682, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_all_on_682_comment},
  {"allOn", &Dtool_DoubleBitMask_BitMaskNative_all_on_682, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_all_on_682_comment},
  {"all_off", &Dtool_DoubleBitMask_BitMaskNative_all_off_683, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_all_off_683_comment},
  {"allOff", &Dtool_DoubleBitMask_BitMaskNative_all_off_683, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_all_off_683_comment},
  {"lower_on", &Dtool_DoubleBitMask_BitMaskNative_lower_on_684, METH_O | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_lower_on_684_comment},
  {"lowerOn", &Dtool_DoubleBitMask_BitMaskNative_lower_on_684, METH_O | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_lower_on_684_comment},
  {"bit", &Dtool_DoubleBitMask_BitMaskNative_bit_685, METH_O | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_bit_685_comment},
  {"range", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_range_686, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_range_686_comment},
  {"has_max_num_bits", &Dtool_DoubleBitMask_BitMaskNative_has_max_num_bits_688, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_has_max_num_bits_688_comment},
  {"hasMaxNumBits", &Dtool_DoubleBitMask_BitMaskNative_has_max_num_bits_688, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_has_max_num_bits_688_comment},
  {"get_max_num_bits", &Dtool_DoubleBitMask_BitMaskNative_get_max_num_bits_689, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_max_num_bits_689_comment},
  {"getMaxNumBits", &Dtool_DoubleBitMask_BitMaskNative_get_max_num_bits_689, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_max_num_bits_689_comment},
  {"get_num_bits", &Dtool_DoubleBitMask_BitMaskNative_get_num_bits_690, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_num_bits_690_comment},
  {"getNumBits", &Dtool_DoubleBitMask_BitMaskNative_get_num_bits_690, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_num_bits_690_comment},
  {"get_bit", &Dtool_DoubleBitMask_BitMaskNative_get_bit_691, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_bit_691_comment},
  {"getBit", &Dtool_DoubleBitMask_BitMaskNative_get_bit_691, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_bit_691_comment},
  {"set_bit", &Dtool_DoubleBitMask_BitMaskNative_set_bit_692, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_set_bit_692_comment},
  {"setBit", &Dtool_DoubleBitMask_BitMaskNative_set_bit_692, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_set_bit_692_comment},
  {"clear_bit", &Dtool_DoubleBitMask_BitMaskNative_clear_bit_693, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_clear_bit_693_comment},
  {"clearBit", &Dtool_DoubleBitMask_BitMaskNative_clear_bit_693, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_clear_bit_693_comment},
  {"set_bit_to", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_set_bit_to_694, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_set_bit_to_694_comment},
  {"setBitTo", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_set_bit_to_694, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_set_bit_to_694_comment},
  {"is_zero", &Dtool_DoubleBitMask_BitMaskNative_is_zero_695, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_is_zero_695_comment},
  {"isZero", &Dtool_DoubleBitMask_BitMaskNative_is_zero_695, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_is_zero_695_comment},
  {"is_all_on", &Dtool_DoubleBitMask_BitMaskNative_is_all_on_696, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_is_all_on_696_comment},
  {"isAllOn", &Dtool_DoubleBitMask_BitMaskNative_is_all_on_696, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_is_all_on_696_comment},
  {"extract", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_extract_697, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_extract_697_comment},
  {"store", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_store_698, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_store_698_comment},
  {"has_any_of", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_has_any_of_699, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_has_any_of_699_comment},
  {"hasAnyOf", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_has_any_of_699, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_has_any_of_699_comment},
  {"has_all_of", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_has_all_of_700, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_has_all_of_700_comment},
  {"hasAllOf", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_has_all_of_700, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_has_all_of_700_comment},
  {"set_range", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_set_range_701, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_set_range_701_comment},
  {"setRange", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_set_range_701, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_set_range_701_comment},
  {"clear_range", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_clear_range_702, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_clear_range_702_comment},
  {"clearRange", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_clear_range_702, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_clear_range_702_comment},
  {"set_range_to", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_set_range_to_703, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_set_range_to_703_comment},
  {"setRangeTo", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_set_range_to_703, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_set_range_to_703_comment},
  {"get_num_on_bits", &Dtool_DoubleBitMask_BitMaskNative_get_num_on_bits_704, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_num_on_bits_704_comment},
  {"getNumOnBits", &Dtool_DoubleBitMask_BitMaskNative_get_num_on_bits_704, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_num_on_bits_704_comment},
  {"get_num_off_bits", &Dtool_DoubleBitMask_BitMaskNative_get_num_off_bits_705, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_num_off_bits_705_comment},
  {"getNumOffBits", &Dtool_DoubleBitMask_BitMaskNative_get_num_off_bits_705, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_num_off_bits_705_comment},
  {"get_lowest_on_bit", &Dtool_DoubleBitMask_BitMaskNative_get_lowest_on_bit_706, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_lowest_on_bit_706_comment},
  {"getLowestOnBit", &Dtool_DoubleBitMask_BitMaskNative_get_lowest_on_bit_706, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_lowest_on_bit_706_comment},
  {"get_lowest_off_bit", &Dtool_DoubleBitMask_BitMaskNative_get_lowest_off_bit_707, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_lowest_off_bit_707_comment},
  {"getLowestOffBit", &Dtool_DoubleBitMask_BitMaskNative_get_lowest_off_bit_707, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_lowest_off_bit_707_comment},
  {"get_highest_on_bit", &Dtool_DoubleBitMask_BitMaskNative_get_highest_on_bit_708, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_highest_on_bit_708_comment},
  {"getHighestOnBit", &Dtool_DoubleBitMask_BitMaskNative_get_highest_on_bit_708, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_highest_on_bit_708_comment},
  {"get_highest_off_bit", &Dtool_DoubleBitMask_BitMaskNative_get_highest_off_bit_709, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_highest_off_bit_709_comment},
  {"getHighestOffBit", &Dtool_DoubleBitMask_BitMaskNative_get_highest_off_bit_709, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_highest_off_bit_709_comment},
  {"get_next_higher_different_bit", &Dtool_DoubleBitMask_BitMaskNative_get_next_higher_different_bit_710, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_next_higher_different_bit_710_comment},
  {"getNextHigherDifferentBit", &Dtool_DoubleBitMask_BitMaskNative_get_next_higher_different_bit_710, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_next_higher_different_bit_710_comment},
  {"invert_in_place", &Dtool_DoubleBitMask_BitMaskNative_invert_in_place_711, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_invert_in_place_711_comment},
  {"invertInPlace", &Dtool_DoubleBitMask_BitMaskNative_invert_in_place_711, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_invert_in_place_711_comment},
  {"has_bits_in_common", &Dtool_DoubleBitMask_BitMaskNative_has_bits_in_common_712, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_has_bits_in_common_712_comment},
  {"hasBitsInCommon", &Dtool_DoubleBitMask_BitMaskNative_has_bits_in_common_712, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_has_bits_in_common_712_comment},
  {"clear", &Dtool_DoubleBitMask_BitMaskNative_clear_713, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_clear_713_comment},
  {"output", &Dtool_DoubleBitMask_BitMaskNative_output_714, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_output_714_comment},
  {"output_binary", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_output_binary_715, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_output_binary_715_comment},
  {"outputBinary", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_output_binary_715, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_output_binary_715_comment},
  {"output_hex", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_output_hex_716, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_output_hex_716_comment},
  {"outputHex", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_output_hex_716, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_output_hex_716_comment},
  {"write", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_write_717, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_write_717_comment},
  {"compare_to", &Dtool_DoubleBitMask_BitMaskNative_compare_to_721, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_compare_to_721_comment},
  {"compareTo", &Dtool_DoubleBitMask_BitMaskNative_compare_to_721, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_compare_to_721_comment},
  {"__ior__", &Dtool_DoubleBitMask_BitMaskNative_operator_729, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_operator_729_comment},
  {"get_class_type", &Dtool_DoubleBitMask_BitMaskNative_get_class_type_733, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_class_type_733_comment},
  {"getClassType", &Dtool_DoubleBitMask_BitMaskNative_get_class_type_733, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_class_type_733_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_and -> operator &
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_722_nb_and(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator &(DoubleBitMask< BitMaskNative > const &other) const
  DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 1, "DoubleBitMask.__and__", true, true);
  if (arg_this != NULL) {
    DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >((*(const DoubleBitMask< BitMaskNative >*)local_this).operator &(*arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_inplace_and -> operator &=
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_728_nb_inplace_and(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DoubleBitMask< BitMaskNative >::operator &=(DoubleBitMask< BitMaskNative > const &other)
    DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 1, "DoubleBitMask.__iand__", true, true);
    if (arg_this != NULL) {
      (*local_this).operator &=(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call DoubleBitMask.__iand__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_inplace_lshift -> operator <<=
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_731_nb_inplace_lshift(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DoubleBitMask< BitMaskNative >::operator <<=(int shift)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator <<=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call DoubleBitMask.__ilshift__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_inplace_rshift -> operator >>=
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_732_nb_inplace_rshift(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DoubleBitMask< BitMaskNative >::operator >>=(int shift)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator >>=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call DoubleBitMask.__irshift__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_inplace_xor -> operator ^=
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_730_nb_inplace_xor(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DoubleBitMask< BitMaskNative >::operator ^=(DoubleBitMask< BitMaskNative > const &other)
    DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 1, "DoubleBitMask.__ixor__", true, true);
    if (arg_this != NULL) {
      (*local_this).operator ^=(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call DoubleBitMask.__ixor__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_invert -> operator ~
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_725_nb_invert(PyObject *self) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator ~(void) const
  DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >((*(const DoubleBitMask< BitMaskNative >*)local_this).operator ~());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__invert__(DoubleBitMask self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_lshift -> operator <<
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_726_nb_lshift(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator <<(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >((*(const DoubleBitMask< BitMaskNative >*)local_this).operator <<((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_or -> operator |
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_723_nb_or(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator |(DoubleBitMask< BitMaskNative > const &other) const
  DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 1, "DoubleBitMask.__or__", true, true);
  if (arg_this != NULL) {
    DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >((*(const DoubleBitMask< BitMaskNative >*)local_this).operator |(*arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_rshift -> operator >>
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_727_nb_rshift(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator >>(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >((*(const DoubleBitMask< BitMaskNative >*)local_this).operator >>((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_xor -> operator ^
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_724_nb_xor(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator ^(DoubleBitMask< BitMaskNative > const &other) const
  DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 1, "DoubleBitMask.__xor__", true, true);
  if (arg_this != NULL) {
    DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >((*(const DoubleBitMask< BitMaskNative >*)local_this).operator ^(*arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot tp_compare -> compare_to
//////////////////
static int Dtool_DoubleBitMask_BitMaskNative_compare_to_721_tp_compare(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int DoubleBitMask< BitMaskNative >::compare_to(DoubleBitMask< BitMaskNative > const &other) const
  DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 1, "DoubleBitMask.compare_to", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const DoubleBitMask< BitMaskNative >*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(DoubleBitMask self, const DoubleBitMask other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     DoubleBitMask_BitMaskNative
//////////////////
static PyObject *Dtool_Repr_DoubleBitMask_BitMaskNative(PyObject *self) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     DoubleBitMask_BitMaskNative
//////////////////
static PyObject *Dtool_Str_DoubleBitMask_BitMaskNative(PyObject *self) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     DoubleBitMask_BitMaskNative
//////////////////
static PyObject *Dtool_RichCompare_DoubleBitMask_BitMaskNative(PyObject *self, PyObject *arg, int op) {
  DoubleBitMask< BitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool DoubleBitMask< BitMaskNative >::operator ==(DoubleBitMask< BitMaskNative > const &other) const
      DoubleBitMask< BitMaskNative > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const DoubleBitMask< BitMaskNative >*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool DoubleBitMask< BitMaskNative >::operator !=(DoubleBitMask< BitMaskNative > const &other) const
      DoubleBitMask< BitMaskNative > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const DoubleBitMask< BitMaskNative >*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool DoubleBitMask< BitMaskNative >::operator <(DoubleBitMask< BitMaskNative > const &other) const
      DoubleBitMask< BitMaskNative > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const DoubleBitMask< BitMaskNative >*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_DoubleBitMask_BitMaskNative_compare_to_721_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_DoubleBitMask_BitMaskNative = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  &Dtool_DoubleBitMask_BitMaskNative_operator_725_nb_invert,
  &Dtool_DoubleBitMask_BitMaskNative_operator_726_nb_lshift,
  &Dtool_DoubleBitMask_BitMaskNative_operator_727_nb_rshift,
  &Dtool_DoubleBitMask_BitMaskNative_operator_722_nb_and,
  &Dtool_DoubleBitMask_BitMaskNative_operator_724_nb_xor,
  &Dtool_DoubleBitMask_BitMaskNative_operator_723_nb_or,
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  &Dtool_DoubleBitMask_BitMaskNative_operator_731_nb_inplace_lshift,
  &Dtool_DoubleBitMask_BitMaskNative_operator_732_nb_inplace_rshift,
  &Dtool_DoubleBitMask_BitMaskNative_operator_728_nb_inplace_and,
  &Dtool_DoubleBitMask_BitMaskNative_operator_730_nb_inplace_xor,
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_DoubleBitMask_BitMaskNative = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.DoubleBitMask_BitMaskNative",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DoubleBitMask_BitMaskNative,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_DoubleBitMask_BitMaskNative_compare_to_721_tp_compare,
#endif
    &Dtool_Repr_DoubleBitMask_BitMaskNative,
    &Dtool_NumberMethods_DoubleBitMask_BitMaskNative,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Str_DoubleBitMask_BitMaskNative,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_DoubleBitMask_BitMaskNative,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DoubleBitMask_BitMaskNative,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DoubleBitMask_BitMaskNative,
    PyType_GenericAlloc,
    Dtool_new_DoubleBitMask_BitMaskNative,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DoubleBitMask_BitMaskNative,
  Dtool_UpcastInterface_DoubleBitMask_BitMaskNative,
  Dtool_DowncastInterface_DoubleBitMask_BitMaskNative,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DoubleBitMask_BitMaskNative(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DoubleBitMask_BitMaskNative._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_DoubleBitMask_BitMaskNative._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DoubleBitMask_BitMaskNative) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DoubleBitMask_BitMaskNative)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DoubleBitMask_BitMaskNative);
  }
}

/**
 * Python method tables for DoubleBitMask_DoubleBitMaskNative (DoubleBitMask_DoubleBitMaskNative)
 */
static PyMethodDef Dtool_Methods_DoubleBitMask_DoubleBitMaskNative[] = {
  {"assign", &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_737, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_operator_737_comment},
  {"all_on", &Dtool_DoubleBitMask_DoubleBitMaskNative_all_on_738, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_all_on_738_comment},
  {"allOn", &Dtool_DoubleBitMask_DoubleBitMaskNative_all_on_738, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_all_on_738_comment},
  {"all_off", &Dtool_DoubleBitMask_DoubleBitMaskNative_all_off_739, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_all_off_739_comment},
  {"allOff", &Dtool_DoubleBitMask_DoubleBitMaskNative_all_off_739, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_all_off_739_comment},
  {"lower_on", &Dtool_DoubleBitMask_DoubleBitMaskNative_lower_on_740, METH_O | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_lower_on_740_comment},
  {"lowerOn", &Dtool_DoubleBitMask_DoubleBitMaskNative_lower_on_740, METH_O | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_lower_on_740_comment},
  {"bit", &Dtool_DoubleBitMask_DoubleBitMaskNative_bit_741, METH_O | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_bit_741_comment},
  {"range", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_range_742, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_range_742_comment},
  {"has_max_num_bits", &Dtool_DoubleBitMask_DoubleBitMaskNative_has_max_num_bits_744, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_has_max_num_bits_744_comment},
  {"hasMaxNumBits", &Dtool_DoubleBitMask_DoubleBitMaskNative_has_max_num_bits_744, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_has_max_num_bits_744_comment},
  {"get_max_num_bits", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_max_num_bits_745, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_max_num_bits_745_comment},
  {"getMaxNumBits", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_max_num_bits_745, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_max_num_bits_745_comment},
  {"get_num_bits", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_bits_746, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_bits_746_comment},
  {"getNumBits", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_bits_746, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_bits_746_comment},
  {"get_bit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_bit_747, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_bit_747_comment},
  {"getBit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_bit_747, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_bit_747_comment},
  {"set_bit", &Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_748, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_748_comment},
  {"setBit", &Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_748, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_748_comment},
  {"clear_bit", &Dtool_DoubleBitMask_DoubleBitMaskNative_clear_bit_749, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_clear_bit_749_comment},
  {"clearBit", &Dtool_DoubleBitMask_DoubleBitMaskNative_clear_bit_749, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_clear_bit_749_comment},
  {"set_bit_to", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_to_750, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_to_750_comment},
  {"setBitTo", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_to_750, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_to_750_comment},
  {"is_zero", &Dtool_DoubleBitMask_DoubleBitMaskNative_is_zero_751, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_is_zero_751_comment},
  {"isZero", &Dtool_DoubleBitMask_DoubleBitMaskNative_is_zero_751, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_is_zero_751_comment},
  {"is_all_on", &Dtool_DoubleBitMask_DoubleBitMaskNative_is_all_on_752, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_is_all_on_752_comment},
  {"isAllOn", &Dtool_DoubleBitMask_DoubleBitMaskNative_is_all_on_752, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_is_all_on_752_comment},
  {"extract", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_extract_753, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_extract_753_comment},
  {"store", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_store_754, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_store_754_comment},
  {"has_any_of", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_has_any_of_755, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_has_any_of_755_comment},
  {"hasAnyOf", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_has_any_of_755, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_has_any_of_755_comment},
  {"has_all_of", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_has_all_of_756, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_has_all_of_756_comment},
  {"hasAllOf", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_has_all_of_756, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_has_all_of_756_comment},
  {"set_range", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_757, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_757_comment},
  {"setRange", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_757, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_757_comment},
  {"clear_range", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_clear_range_758, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_clear_range_758_comment},
  {"clearRange", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_clear_range_758, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_clear_range_758_comment},
  {"set_range_to", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_to_759, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_to_759_comment},
  {"setRangeTo", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_to_759, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_to_759_comment},
  {"get_num_on_bits", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_on_bits_760, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_on_bits_760_comment},
  {"getNumOnBits", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_on_bits_760, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_on_bits_760_comment},
  {"get_num_off_bits", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_off_bits_761, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_off_bits_761_comment},
  {"getNumOffBits", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_off_bits_761, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_off_bits_761_comment},
  {"get_lowest_on_bit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_on_bit_762, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_on_bit_762_comment},
  {"getLowestOnBit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_on_bit_762, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_on_bit_762_comment},
  {"get_lowest_off_bit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_off_bit_763, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_off_bit_763_comment},
  {"getLowestOffBit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_off_bit_763, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_off_bit_763_comment},
  {"get_highest_on_bit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_on_bit_764, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_on_bit_764_comment},
  {"getHighestOnBit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_on_bit_764, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_on_bit_764_comment},
  {"get_highest_off_bit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_off_bit_765, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_off_bit_765_comment},
  {"getHighestOffBit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_off_bit_765, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_off_bit_765_comment},
  {"get_next_higher_different_bit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_next_higher_different_bit_766, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_next_higher_different_bit_766_comment},
  {"getNextHigherDifferentBit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_next_higher_different_bit_766, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_next_higher_different_bit_766_comment},
  {"invert_in_place", &Dtool_DoubleBitMask_DoubleBitMaskNative_invert_in_place_767, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_invert_in_place_767_comment},
  {"invertInPlace", &Dtool_DoubleBitMask_DoubleBitMaskNative_invert_in_place_767, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_invert_in_place_767_comment},
  {"has_bits_in_common", &Dtool_DoubleBitMask_DoubleBitMaskNative_has_bits_in_common_768, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_has_bits_in_common_768_comment},
  {"hasBitsInCommon", &Dtool_DoubleBitMask_DoubleBitMaskNative_has_bits_in_common_768, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_has_bits_in_common_768_comment},
  {"clear", &Dtool_DoubleBitMask_DoubleBitMaskNative_clear_769, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_clear_769_comment},
  {"output", &Dtool_DoubleBitMask_DoubleBitMaskNative_output_770, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_output_770_comment},
  {"output_binary", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_output_binary_771, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_output_binary_771_comment},
  {"outputBinary", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_output_binary_771, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_output_binary_771_comment},
  {"output_hex", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_output_hex_772, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_output_hex_772_comment},
  {"outputHex", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_output_hex_772, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_output_hex_772_comment},
  {"write", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_write_773, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_write_773_comment},
  {"compare_to", &Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_777, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_777_comment},
  {"compareTo", &Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_777, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_777_comment},
  {"__ior__", &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_785, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_operator_785_comment},
  {"get_class_type", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_class_type_789, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_class_type_789_comment},
  {"getClassType", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_class_type_789, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_class_type_789_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_and -> operator &
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_778_nb_and(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator &(DoubleBitMask< DoubleBitMaskNative > const &other) const
  DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 1, "DoubleBitMask.__and__", true, true);
  if (arg_this != NULL) {
    DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).operator &(*arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_inplace_and -> operator &=
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_784_nb_inplace_and(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DoubleBitMask< DoubleBitMaskNative >::operator &=(DoubleBitMask< DoubleBitMaskNative > const &other)
    DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 1, "DoubleBitMask.__iand__", true, true);
    if (arg_this != NULL) {
      (*local_this).operator &=(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call DoubleBitMask.__iand__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_inplace_lshift -> operator <<=
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_787_nb_inplace_lshift(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DoubleBitMask< DoubleBitMaskNative >::operator <<=(int shift)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator <<=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call DoubleBitMask.__ilshift__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_inplace_rshift -> operator >>=
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_788_nb_inplace_rshift(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DoubleBitMask< DoubleBitMaskNative >::operator >>=(int shift)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator >>=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call DoubleBitMask.__irshift__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_inplace_xor -> operator ^=
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_786_nb_inplace_xor(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void DoubleBitMask< DoubleBitMaskNative >::operator ^=(DoubleBitMask< DoubleBitMaskNative > const &other)
    DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 1, "DoubleBitMask.__ixor__", true, true);
    if (arg_this != NULL) {
      (*local_this).operator ^=(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call DoubleBitMask.__ixor__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_invert -> operator ~
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_781_nb_invert(PyObject *self) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator ~(void) const
  DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).operator ~());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__invert__(DoubleBitMask self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_lshift -> operator <<
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_782_nb_lshift(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator <<(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).operator <<((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_or -> operator |
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_779_nb_or(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator |(DoubleBitMask< DoubleBitMaskNative > const &other) const
  DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 1, "DoubleBitMask.__or__", true, true);
  if (arg_this != NULL) {
    DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).operator |(*arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_rshift -> operator >>
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_783_nb_rshift(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator >>(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).operator >>((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_xor -> operator ^
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_780_nb_xor(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator ^(DoubleBitMask< DoubleBitMaskNative > const &other) const
  DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 1, "DoubleBitMask.__xor__", true, true);
  if (arg_this != NULL) {
    DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).operator ^(*arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot tp_compare -> compare_to
//////////////////
static int Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_777_tp_compare(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int DoubleBitMask< DoubleBitMaskNative >::compare_to(DoubleBitMask< DoubleBitMaskNative > const &other) const
  DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 1, "DoubleBitMask.compare_to", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(DoubleBitMask self, const DoubleBitMask other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     DoubleBitMask_DoubleBitMaskNative
//////////////////
static PyObject *Dtool_Repr_DoubleBitMask_DoubleBitMaskNative(PyObject *self) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     DoubleBitMask_DoubleBitMaskNative
//////////////////
static PyObject *Dtool_Str_DoubleBitMask_DoubleBitMaskNative(PyObject *self) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     DoubleBitMask_DoubleBitMaskNative
//////////////////
static PyObject *Dtool_RichCompare_DoubleBitMask_DoubleBitMaskNative(PyObject *self, PyObject *arg, int op) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool DoubleBitMask< DoubleBitMaskNative >::operator ==(DoubleBitMask< DoubleBitMaskNative > const &other) const
      DoubleBitMask< DoubleBitMaskNative > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool DoubleBitMask< DoubleBitMaskNative >::operator !=(DoubleBitMask< DoubleBitMaskNative > const &other) const
      DoubleBitMask< DoubleBitMaskNative > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool DoubleBitMask< DoubleBitMaskNative >::operator <(DoubleBitMask< DoubleBitMaskNative > const &other) const
      DoubleBitMask< DoubleBitMaskNative > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_777_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_DoubleBitMask_DoubleBitMaskNative = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_781_nb_invert,
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_782_nb_lshift,
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_783_nb_rshift,
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_778_nb_and,
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_780_nb_xor,
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_779_nb_or,
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_787_nb_inplace_lshift,
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_788_nb_inplace_rshift,
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_784_nb_inplace_and,
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_786_nb_inplace_xor,
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_DoubleBitMask_DoubleBitMaskNative = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.DoubleBitMask_DoubleBitMaskNative",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DoubleBitMask_DoubleBitMaskNative,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_777_tp_compare,
#endif
    &Dtool_Repr_DoubleBitMask_DoubleBitMaskNative,
    &Dtool_NumberMethods_DoubleBitMask_DoubleBitMaskNative,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Str_DoubleBitMask_DoubleBitMaskNative,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_DoubleBitMask_DoubleBitMaskNative,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DoubleBitMask_DoubleBitMaskNative,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DoubleBitMask_DoubleBitMaskNative,
    PyType_GenericAlloc,
    Dtool_new_DoubleBitMask_DoubleBitMaskNative,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DoubleBitMask_DoubleBitMaskNative,
  Dtool_UpcastInterface_DoubleBitMask_DoubleBitMaskNative,
  Dtool_DowncastInterface_DoubleBitMask_DoubleBitMaskNative,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DoubleBitMask_DoubleBitMaskNative(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DoubleBitMask_DoubleBitMaskNative._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_DoubleBitMask_DoubleBitMaskNative._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DoubleBitMask_DoubleBitMaskNative) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DoubleBitMask_DoubleBitMaskNative)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DoubleBitMask_DoubleBitMaskNative);
  }
}

/**
 * Python method tables for KeyboardButton (KeyboardButton)
 */
static PyMethodDef Dtool_Methods_KeyboardButton[] = {
  {"ascii_key", &Dtool_KeyboardButton_ascii_key_793, METH_O | METH_STATIC, (const char *)Dtool_KeyboardButton_ascii_key_793_comment},
  {"asciiKey", &Dtool_KeyboardButton_ascii_key_793, METH_O | METH_STATIC, (const char *)Dtool_KeyboardButton_ascii_key_793_comment},
  {"space", &Dtool_KeyboardButton_space_794, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_space_794_comment},
  {"backspace", &Dtool_KeyboardButton_backspace_795, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_backspace_795_comment},
  {"tab", &Dtool_KeyboardButton_tab_796, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_tab_796_comment},
  {"enter", &Dtool_KeyboardButton_enter_797, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_enter_797_comment},
  {"escape", &Dtool_KeyboardButton_escape_798, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_escape_798_comment},
  {"f1", &Dtool_KeyboardButton_f1_799, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f1_799_comment},
  {"f2", &Dtool_KeyboardButton_f2_800, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f2_800_comment},
  {"f3", &Dtool_KeyboardButton_f3_801, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f3_801_comment},
  {"f4", &Dtool_KeyboardButton_f4_802, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f4_802_comment},
  {"f5", &Dtool_KeyboardButton_f5_803, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f5_803_comment},
  {"f6", &Dtool_KeyboardButton_f6_804, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f6_804_comment},
  {"f7", &Dtool_KeyboardButton_f7_805, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f7_805_comment},
  {"f8", &Dtool_KeyboardButton_f8_806, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f8_806_comment},
  {"f9", &Dtool_KeyboardButton_f9_807, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f9_807_comment},
  {"f10", &Dtool_KeyboardButton_f10_808, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f10_808_comment},
  {"f11", &Dtool_KeyboardButton_f11_809, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f11_809_comment},
  {"f12", &Dtool_KeyboardButton_f12_810, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f12_810_comment},
  {"f13", &Dtool_KeyboardButton_f13_811, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f13_811_comment},
  {"f14", &Dtool_KeyboardButton_f14_812, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f14_812_comment},
  {"f15", &Dtool_KeyboardButton_f15_813, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f15_813_comment},
  {"f16", &Dtool_KeyboardButton_f16_814, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f16_814_comment},
  {"left", &Dtool_KeyboardButton_left_815, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_left_815_comment},
  {"right", &Dtool_KeyboardButton_right_816, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_right_816_comment},
  {"up", &Dtool_KeyboardButton_up_817, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_up_817_comment},
  {"down", &Dtool_KeyboardButton_down_818, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_down_818_comment},
  {"page_up", &Dtool_KeyboardButton_page_up_819, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_page_up_819_comment},
  {"pageUp", &Dtool_KeyboardButton_page_up_819, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_page_up_819_comment},
  {"page_down", &Dtool_KeyboardButton_page_down_820, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_page_down_820_comment},
  {"pageDown", &Dtool_KeyboardButton_page_down_820, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_page_down_820_comment},
  {"home", &Dtool_KeyboardButton_home_821, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_home_821_comment},
  {"end", &Dtool_KeyboardButton_end_822, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_end_822_comment},
  {"insert", &Dtool_KeyboardButton_insert_823, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_insert_823_comment},
  {"_del", &Dtool_KeyboardButton_del_824, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_del_824_comment},
  {"help", &Dtool_KeyboardButton_help_825, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_help_825_comment},
  {"menu", &Dtool_KeyboardButton_menu_826, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_menu_826_comment},
  {"shift", &Dtool_KeyboardButton_shift_827, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_shift_827_comment},
  {"control", &Dtool_KeyboardButton_control_828, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_control_828_comment},
  {"alt", &Dtool_KeyboardButton_alt_829, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_alt_829_comment},
  {"meta", &Dtool_KeyboardButton_meta_830, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_meta_830_comment},
  {"caps_lock", &Dtool_KeyboardButton_caps_lock_831, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_caps_lock_831_comment},
  {"capsLock", &Dtool_KeyboardButton_caps_lock_831, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_caps_lock_831_comment},
  {"shift_lock", &Dtool_KeyboardButton_shift_lock_832, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_shift_lock_832_comment},
  {"shiftLock", &Dtool_KeyboardButton_shift_lock_832, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_shift_lock_832_comment},
  {"num_lock", &Dtool_KeyboardButton_num_lock_833, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_num_lock_833_comment},
  {"numLock", &Dtool_KeyboardButton_num_lock_833, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_num_lock_833_comment},
  {"scroll_lock", &Dtool_KeyboardButton_scroll_lock_834, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_scroll_lock_834_comment},
  {"scrollLock", &Dtool_KeyboardButton_scroll_lock_834, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_scroll_lock_834_comment},
  {"print_screen", &Dtool_KeyboardButton_print_screen_835, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_print_screen_835_comment},
  {"printScreen", &Dtool_KeyboardButton_print_screen_835, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_print_screen_835_comment},
  {"pause", &Dtool_KeyboardButton_pause_836, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_pause_836_comment},
  {"lshift", &Dtool_KeyboardButton_lshift_837, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_lshift_837_comment},
  {"rshift", &Dtool_KeyboardButton_rshift_838, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_rshift_838_comment},
  {"lcontrol", &Dtool_KeyboardButton_lcontrol_839, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_lcontrol_839_comment},
  {"rcontrol", &Dtool_KeyboardButton_rcontrol_840, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_rcontrol_840_comment},
  {"lalt", &Dtool_KeyboardButton_lalt_841, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_lalt_841_comment},
  {"ralt", &Dtool_KeyboardButton_ralt_842, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_ralt_842_comment},
  {"lmeta", &Dtool_KeyboardButton_lmeta_843, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_lmeta_843_comment},
  {"rmeta", &Dtool_KeyboardButton_rmeta_844, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_rmeta_844_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_KeyboardButton = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_KeyboardButton = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.KeyboardButton",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_KeyboardButton,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_KeyboardButton,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is just used as a convenient namespace for grouping all of these\n"
    " * handy functions that return buttons which map to standard keyboard keys.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_KeyboardButton,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_KeyboardButton,
    PyType_GenericAlloc,
    Dtool_new_KeyboardButton,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_KeyboardButton,
  Dtool_UpcastInterface_KeyboardButton,
  Dtool_DowncastInterface_KeyboardButton,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_KeyboardButton(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_KeyboardButton._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_KeyboardButton._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_KeyboardButton) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(KeyboardButton)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_KeyboardButton);
  }
}

/**
 * Python method tables for ModifierButtons (ModifierButtons)
 */
static PyMethodDef Dtool_Methods_ModifierButtons[] = {
  {"assign", &Dtool_ModifierButtons_operator_854, METH_O, (const char *)Dtool_ModifierButtons_operator_854_comment},
  {"__ior__", &Dtool_ModifierButtons_operator_861, METH_O, (const char *)Dtool_ModifierButtons_operator_861_comment},
  {"set_button_list", &Dtool_ModifierButtons_set_button_list_862, METH_O, (const char *)Dtool_ModifierButtons_set_button_list_862_comment},
  {"setButtonList", &Dtool_ModifierButtons_set_button_list_862, METH_O, (const char *)Dtool_ModifierButtons_set_button_list_862_comment},
  {"matches", &Dtool_ModifierButtons_matches_863, METH_O, (const char *)Dtool_ModifierButtons_matches_863_comment},
  {"add_button", &Dtool_ModifierButtons_add_button_864, METH_O, (const char *)Dtool_ModifierButtons_add_button_864_comment},
  {"addButton", &Dtool_ModifierButtons_add_button_864, METH_O, (const char *)Dtool_ModifierButtons_add_button_864_comment},
  {"has_button", &Dtool_ModifierButtons_has_button_865, METH_O, (const char *)Dtool_ModifierButtons_has_button_865_comment},
  {"hasButton", &Dtool_ModifierButtons_has_button_865, METH_O, (const char *)Dtool_ModifierButtons_has_button_865_comment},
  {"remove_button", &Dtool_ModifierButtons_remove_button_866, METH_O, (const char *)Dtool_ModifierButtons_remove_button_866_comment},
  {"removeButton", &Dtool_ModifierButtons_remove_button_866, METH_O, (const char *)Dtool_ModifierButtons_remove_button_866_comment},
  {"get_num_buttons", &Dtool_ModifierButtons_get_num_buttons_867, METH_NOARGS, (const char *)Dtool_ModifierButtons_get_num_buttons_867_comment},
  {"getNumButtons", &Dtool_ModifierButtons_get_num_buttons_867, METH_NOARGS, (const char *)Dtool_ModifierButtons_get_num_buttons_867_comment},
  {"get_button", &Dtool_ModifierButtons_get_button_868, METH_O, (const char *)Dtool_ModifierButtons_get_button_868_comment},
  {"getButton", &Dtool_ModifierButtons_get_button_868, METH_O, (const char *)Dtool_ModifierButtons_get_button_868_comment},
  {"button_down", &Dtool_ModifierButtons_button_down_871, METH_O, (const char *)Dtool_ModifierButtons_button_down_871_comment},
  {"buttonDown", &Dtool_ModifierButtons_button_down_871, METH_O, (const char *)Dtool_ModifierButtons_button_down_871_comment},
  {"button_up", &Dtool_ModifierButtons_button_up_872, METH_O, (const char *)Dtool_ModifierButtons_button_up_872_comment},
  {"buttonUp", &Dtool_ModifierButtons_button_up_872, METH_O, (const char *)Dtool_ModifierButtons_button_up_872_comment},
  {"all_buttons_up", &Dtool_ModifierButtons_all_buttons_up_873, METH_NOARGS, (const char *)Dtool_ModifierButtons_all_buttons_up_873_comment},
  {"allButtonsUp", &Dtool_ModifierButtons_all_buttons_up_873, METH_NOARGS, (const char *)Dtool_ModifierButtons_all_buttons_up_873_comment},
  {"is_down", &Dtool_ModifierButtons_is_down_874, METH_O, (const char *)Dtool_ModifierButtons_is_down_874_comment},
  {"isDown", &Dtool_ModifierButtons_is_down_874, METH_O, (const char *)Dtool_ModifierButtons_is_down_874_comment},
  {"is_any_down", &Dtool_ModifierButtons_is_any_down_875, METH_NOARGS, (const char *)Dtool_ModifierButtons_is_any_down_875_comment},
  {"isAnyDown", &Dtool_ModifierButtons_is_any_down_875, METH_NOARGS, (const char *)Dtool_ModifierButtons_is_any_down_875_comment},
  {"get_prefix", &Dtool_ModifierButtons_get_prefix_876, METH_NOARGS, (const char *)Dtool_ModifierButtons_get_prefix_876_comment},
  {"getPrefix", &Dtool_ModifierButtons_get_prefix_876, METH_NOARGS, (const char *)Dtool_ModifierButtons_get_prefix_876_comment},
  {"output", &Dtool_ModifierButtons_output_877, METH_O, (const char *)Dtool_ModifierButtons_output_877_comment},
  {"write", &Dtool_ModifierButtons_write_878, METH_O, (const char *)Dtool_ModifierButtons_write_878_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_buttons", (PyCFunction) &MakeSeq_ModifierButtons_get_buttons, METH_NOARGS, NULL},
  { "getButtons", (PyCFunction) &MakeSeq_ModifierButtons_get_buttons, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ModifierButtons slot nb_and -> operator &
//////////////////
static PyObject *Dtool_ModifierButtons_operator_858_nb_and(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_ModifierButtons, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline ModifierButtons ModifierButtons::operator &(ModifierButtons const &other) const
  ModifierButtons const *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 1, "ModifierButtons.__and__", true, true);
  if (arg_this != NULL) {
    ModifierButtons *return_value = new ModifierButtons((*(const ModifierButtons*)local_this).operator &(*arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ModifierButtons, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ModifierButtons slot nb_inplace_and -> operator &=
//////////////////
static PyObject *Dtool_ModifierButtons_operator_860_nb_inplace_and(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_ModifierButtons, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void ModifierButtons::operator &=(ModifierButtons const &other)
    ModifierButtons const *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 1, "ModifierButtons.__iand__", true, true);
    if (arg_this != NULL) {
      (*local_this).operator &=(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call ModifierButtons.__iand__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ModifierButtons slot nb_or -> operator |
//////////////////
static PyObject *Dtool_ModifierButtons_operator_859_nb_or(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_ModifierButtons, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline ModifierButtons ModifierButtons::operator |(ModifierButtons const &other) const
  ModifierButtons const *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 1, "ModifierButtons.__or__", true, true);
  if (arg_this != NULL) {
    ModifierButtons *return_value = new ModifierButtons((*(const ModifierButtons*)local_this).operator |(*arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ModifierButtons, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
//  A __repr__ function
//     ModifierButtons
//////////////////
static PyObject *Dtool_Repr_ModifierButtons(PyObject *self) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ModifierButtons
//////////////////
static PyObject *Dtool_Str_ModifierButtons(PyObject *self) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     ModifierButtons
//////////////////
static PyObject *Dtool_RichCompare_ModifierButtons(PyObject *self, PyObject *arg, int op) {
  ModifierButtons *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool ModifierButtons::operator ==(ModifierButtons const &other) const
      ModifierButtons const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_ModifierButtons, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const ModifierButtons*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool ModifierButtons::operator !=(ModifierButtons const &other) const
      ModifierButtons const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_ModifierButtons, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const ModifierButtons*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool ModifierButtons::operator <(ModifierButtons const &other) const
      ModifierButtons const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_ModifierButtons, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const ModifierButtons*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_ModifierButtons[] = {
  {(char *)"buttons", &Dtool_ModifierButtons_buttons_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ModifierButtons = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  &Dtool_ModifierButtons_operator_858_nb_and,
  0, // nb_xor
  &Dtool_ModifierButtons_operator_859_nb_or,
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  &Dtool_ModifierButtons_operator_860_nb_inplace_and,
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_ModifierButtons = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ModifierButtons",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ModifierButtons,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &DTOOL_PyObject_ComparePointers,
#endif
    &Dtool_Repr_ModifierButtons,
    &Dtool_NumberMethods_ModifierButtons,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Str_ModifierButtons,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class monitors the state of a number of individual buttons and tracks\n"
    " * whether each button is known to be down or up.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_ModifierButtons,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ModifierButtons,
    0, // tp_members
    Dtool_Properties_ModifierButtons,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ModifierButtons,
    PyType_GenericAlloc,
    Dtool_new_ModifierButtons,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ModifierButtons,
  Dtool_UpcastInterface_ModifierButtons,
  Dtool_DowncastInterface_ModifierButtons,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ModifierButtons(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ModifierButtons._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_ModifierButtons._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ModifierButtons) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ModifierButtons)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ModifierButtons);
  }
}

/**
 * Python method tables for MouseButton (MouseButton)
 */
static PyMethodDef Dtool_Methods_MouseButton[] = {
  {"button", &Dtool_MouseButton_button_880, METH_O | METH_STATIC, (const char *)Dtool_MouseButton_button_880_comment},
  {"one", &Dtool_MouseButton_one_881, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_one_881_comment},
  {"two", &Dtool_MouseButton_two_882, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_two_882_comment},
  {"three", &Dtool_MouseButton_three_883, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_three_883_comment},
  {"four", &Dtool_MouseButton_four_884, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_four_884_comment},
  {"five", &Dtool_MouseButton_five_885, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_five_885_comment},
  {"wheel_up", &Dtool_MouseButton_wheel_up_886, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_wheel_up_886_comment},
  {"wheelUp", &Dtool_MouseButton_wheel_up_886, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_wheel_up_886_comment},
  {"wheel_down", &Dtool_MouseButton_wheel_down_887, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_wheel_down_887_comment},
  {"wheelDown", &Dtool_MouseButton_wheel_down_887, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_wheel_down_887_comment},
  {"wheel_left", &Dtool_MouseButton_wheel_left_888, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_wheel_left_888_comment},
  {"wheelLeft", &Dtool_MouseButton_wheel_left_888, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_wheel_left_888_comment},
  {"wheel_right", &Dtool_MouseButton_wheel_right_889, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_wheel_right_889_comment},
  {"wheelRight", &Dtool_MouseButton_wheel_right_889, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_wheel_right_889_comment},
  {"is_mouse_button", &Dtool_MouseButton_is_mouse_button_890, METH_O | METH_STATIC, (const char *)Dtool_MouseButton_is_mouse_button_890_comment},
  {"isMouseButton", &Dtool_MouseButton_is_mouse_button_890, METH_O | METH_STATIC, (const char *)Dtool_MouseButton_is_mouse_button_890_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MouseButton = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_MouseButton = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MouseButton",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MouseButton,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MouseButton,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is just used as a convenient namespace for grouping all of these\n"
    " * handy functions that return buttons which map to standard mouse buttons.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MouseButton,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MouseButton,
    PyType_GenericAlloc,
    Dtool_new_MouseButton,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MouseButton,
  Dtool_UpcastInterface_MouseButton,
  Dtool_DowncastInterface_MouseButton,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MouseButton(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_MouseButton._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_MouseButton._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MouseButton) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MouseButton)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MouseButton);
  }
}

/**
 * Python method tables for MouseData (MouseData)
 */
static PyMethodDef Dtool_Methods_MouseData[] = {
  {"assign", &Dtool_MouseData_operator_895, METH_O, (const char *)Dtool_MouseData_operator_895_comment},
  {"get_x", &Dtool_MouseData_get_x_896, METH_NOARGS, (const char *)Dtool_MouseData_get_x_896_comment},
  {"getX", &Dtool_MouseData_get_x_896, METH_NOARGS, (const char *)Dtool_MouseData_get_x_896_comment},
  {"get_y", &Dtool_MouseData_get_y_897, METH_NOARGS, (const char *)Dtool_MouseData_get_y_897_comment},
  {"getY", &Dtool_MouseData_get_y_897, METH_NOARGS, (const char *)Dtool_MouseData_get_y_897_comment},
  {"get_in_window", &Dtool_MouseData_get_in_window_898, METH_NOARGS, (const char *)Dtool_MouseData_get_in_window_898_comment},
  {"getInWindow", &Dtool_MouseData_get_in_window_898, METH_NOARGS, (const char *)Dtool_MouseData_get_in_window_898_comment},
  {"output", &Dtool_MouseData_output_899, METH_O, (const char *)Dtool_MouseData_output_899_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     MouseData
//////////////////
static PyObject *Dtool_Repr_MouseData(PyObject *self) {
  MouseData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseData, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_MouseData[] = {
  {(char *)"x", &Dtool_MouseData_x_Getter, NULL, NULL, NULL},
  {(char *)"y", &Dtool_MouseData_y_Getter, NULL, NULL, NULL},
  {(char *)"in_window", &Dtool_MouseData_in_window_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_MouseData = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_MouseData = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MouseData",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MouseData,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_MouseData,
    &Dtool_NumberMethods_MouseData,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_MouseData,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Holds the data that might be generated by a 2-d pointer input device, such\n"
    " * as the mouse in the GraphicsWindow.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MouseData,
    0, // tp_members
    Dtool_Properties_MouseData,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MouseData,
    PyType_GenericAlloc,
    Dtool_new_MouseData,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MouseData,
  Dtool_UpcastInterface_MouseData,
  Dtool_DowncastInterface_MouseData,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MouseData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_MouseData._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_MouseData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MouseData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MouseData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MouseData);
  }
}

/**
 * Python method tables for NodeCachedReferenceCount (NodeCachedReferenceCount)
 */
static PyMethodDef Dtool_Methods_NodeCachedReferenceCount[] = {
  {"get_node_ref_count", &Dtool_NodeCachedReferenceCount_get_node_ref_count_905, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_get_node_ref_count_905_comment},
  {"getNodeRefCount", &Dtool_NodeCachedReferenceCount_get_node_ref_count_905, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_get_node_ref_count_905_comment},
  {"node_ref", &Dtool_NodeCachedReferenceCount_node_ref_906, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_node_ref_906_comment},
  {"nodeRef", &Dtool_NodeCachedReferenceCount_node_ref_906, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_node_ref_906_comment},
  {"node_unref", &Dtool_NodeCachedReferenceCount_node_unref_907, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_node_unref_907_comment},
  {"nodeUnref", &Dtool_NodeCachedReferenceCount_node_unref_907, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_node_unref_907_comment},
  {"test_ref_count_integrity", &Dtool_NodeCachedReferenceCount_test_ref_count_integrity_908, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_test_ref_count_integrity_908_comment},
  {"testRefCountIntegrity", &Dtool_NodeCachedReferenceCount_test_ref_count_integrity_908, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_test_ref_count_integrity_908_comment},
  {"get_referenced_bits", &Dtool_NodeCachedReferenceCount_get_referenced_bits_910, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_get_referenced_bits_910_comment},
  {"getReferencedBits", &Dtool_NodeCachedReferenceCount_get_referenced_bits_910, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_get_referenced_bits_910_comment},
  {"get_class_type", &Dtool_NodeCachedReferenceCount_get_class_type_911, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodeCachedReferenceCount_get_class_type_911_comment},
  {"getClassType", &Dtool_NodeCachedReferenceCount_get_class_type_911, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodeCachedReferenceCount_get_class_type_911_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_NodeCachedReferenceCount = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NodeCachedReferenceCount = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_NodeCachedReferenceCount = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_NodeCachedReferenceCount = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_NodeCachedReferenceCount = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.NodeCachedReferenceCount",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_NodeCachedReferenceCount,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_NodeCachedReferenceCount,
    &Dtool_SequenceMethods_NodeCachedReferenceCount,
    &Dtool_MappingMethods_NodeCachedReferenceCount,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_NodeCachedReferenceCount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class further specializes CachedTypedWritableReferenceCount to also\n"
    " * add a node_ref_count, for the purposes of counting the number of times the\n"
    " * object is referenced by a \"node\", presumably a PandaNode.\n"
    " *\n"
    " * This essentially combines the functionality of NodeReferenceCount and\n"
    " * CachedTypedWritableReferenceCount, so that a derivative of this object\n"
    " * actually has three counters: the standard reference count, the \"cache\"\n"
    " * reference count, and the \"node\" reference count.  Rather than multiply\n"
    " * inheriting from the two reference count classes, we inherit only from\n"
    " * CachedTypedWritableReferenceCount and simply duplicate the functionality of\n"
    " * NodeReferenceCount, to avoid all of the problems associated with multiple\n"
    " * inheritance.\n"
    " *\n"
    " * The intended design is to use this as a base class for RenderState and\n"
    " * TransformState, both of which are held by PandaNodes, and also have caches\n"
    " * which are independently maintained.  By keeping track of how many nodes\n"
    " * hold a pointer to a particular object, we can classify each object into\n"
    " * node-referenced, cache-referenced, or other, which is primarily useful for\n"
    " * PStats reporting.\n"
    " *\n"
    " * As with CachedTypedWritableReferenceCount's cache_ref() and cache_unref(),\n"
    " * the new methods node_ref() and node_unref() automatically increment and\n"
    " * decrement the primary reference count as well.  In this case, however,\n"
    " * there does exist a NodePointerTo<> class to maintain the node_ref counters\n"
    " * automatically.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_NodeCachedReferenceCount,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_NodeCachedReferenceCount,
    PyType_GenericAlloc,
    Dtool_new_NodeCachedReferenceCount,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NodeCachedReferenceCount,
  Dtool_UpcastInterface_NodeCachedReferenceCount,
  Dtool_DowncastInterface_NodeCachedReferenceCount,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_NodeCachedReferenceCount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CachedTypedWritableReferenceCount(NULL);
    Dtool_NodeCachedReferenceCount._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CachedTypedWritableReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_NodeCachedReferenceCount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum NodeCachedReferenceCount::Referenced;
    PyDict_SetItemString(dict, "R_node", Dtool_WrapValue(NodeCachedReferenceCount::R_node));
    PyDict_SetItemString(dict, "RNode", Dtool_WrapValue(NodeCachedReferenceCount::R_node));
    PyDict_SetItemString(dict, "R_cache", Dtool_WrapValue(NodeCachedReferenceCount::R_cache));
    PyDict_SetItemString(dict, "RCache", Dtool_WrapValue(NodeCachedReferenceCount::R_cache));
    if (PyType_Ready((PyTypeObject *)&Dtool_NodeCachedReferenceCount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NodeCachedReferenceCount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NodeCachedReferenceCount);
  }
}

/**
 * Python method tables for SparseArray (SparseArray)
 */
static PyMethodDef Dtool_Methods_SparseArray[] = {
  {"assign", &Dtool_SparseArray_operator_914, METH_O, (const char *)Dtool_SparseArray_operator_914_comment},
  {"all_on", &Dtool_SparseArray_all_on_915, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_all_on_915_comment},
  {"allOn", &Dtool_SparseArray_all_on_915, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_all_on_915_comment},
  {"all_off", &Dtool_SparseArray_all_off_916, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_all_off_916_comment},
  {"allOff", &Dtool_SparseArray_all_off_916, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_all_off_916_comment},
  {"lower_on", &Dtool_SparseArray_lower_on_917, METH_O | METH_STATIC, (const char *)Dtool_SparseArray_lower_on_917_comment},
  {"lowerOn", &Dtool_SparseArray_lower_on_917, METH_O | METH_STATIC, (const char *)Dtool_SparseArray_lower_on_917_comment},
  {"bit", &Dtool_SparseArray_bit_918, METH_O | METH_STATIC, (const char *)Dtool_SparseArray_bit_918_comment},
  {"range", (PyCFunction) &Dtool_SparseArray_range_919, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_SparseArray_range_919_comment},
  {"has_max_num_bits", &Dtool_SparseArray_has_max_num_bits_921, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_has_max_num_bits_921_comment},
  {"hasMaxNumBits", &Dtool_SparseArray_has_max_num_bits_921, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_has_max_num_bits_921_comment},
  {"get_max_num_bits", &Dtool_SparseArray_get_max_num_bits_922, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_get_max_num_bits_922_comment},
  {"getMaxNumBits", &Dtool_SparseArray_get_max_num_bits_922, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_get_max_num_bits_922_comment},
  {"get_num_bits", &Dtool_SparseArray_get_num_bits_923, METH_NOARGS, (const char *)Dtool_SparseArray_get_num_bits_923_comment},
  {"getNumBits", &Dtool_SparseArray_get_num_bits_923, METH_NOARGS, (const char *)Dtool_SparseArray_get_num_bits_923_comment},
  {"get_bit", &Dtool_SparseArray_get_bit_924, METH_O, (const char *)Dtool_SparseArray_get_bit_924_comment},
  {"getBit", &Dtool_SparseArray_get_bit_924, METH_O, (const char *)Dtool_SparseArray_get_bit_924_comment},
  {"set_bit", &Dtool_SparseArray_set_bit_925, METH_O, (const char *)Dtool_SparseArray_set_bit_925_comment},
  {"setBit", &Dtool_SparseArray_set_bit_925, METH_O, (const char *)Dtool_SparseArray_set_bit_925_comment},
  {"clear_bit", &Dtool_SparseArray_clear_bit_926, METH_O, (const char *)Dtool_SparseArray_clear_bit_926_comment},
  {"clearBit", &Dtool_SparseArray_clear_bit_926, METH_O, (const char *)Dtool_SparseArray_clear_bit_926_comment},
  {"set_bit_to", (PyCFunction) &Dtool_SparseArray_set_bit_to_927, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_set_bit_to_927_comment},
  {"setBitTo", (PyCFunction) &Dtool_SparseArray_set_bit_to_927, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_set_bit_to_927_comment},
  {"get_highest_bits", &Dtool_SparseArray_get_highest_bits_928, METH_NOARGS, (const char *)Dtool_SparseArray_get_highest_bits_928_comment},
  {"getHighestBits", &Dtool_SparseArray_get_highest_bits_928, METH_NOARGS, (const char *)Dtool_SparseArray_get_highest_bits_928_comment},
  {"is_zero", &Dtool_SparseArray_is_zero_929, METH_NOARGS, (const char *)Dtool_SparseArray_is_zero_929_comment},
  {"isZero", &Dtool_SparseArray_is_zero_929, METH_NOARGS, (const char *)Dtool_SparseArray_is_zero_929_comment},
  {"is_all_on", &Dtool_SparseArray_is_all_on_930, METH_NOARGS, (const char *)Dtool_SparseArray_is_all_on_930_comment},
  {"isAllOn", &Dtool_SparseArray_is_all_on_930, METH_NOARGS, (const char *)Dtool_SparseArray_is_all_on_930_comment},
  {"has_any_of", (PyCFunction) &Dtool_SparseArray_has_any_of_931, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_has_any_of_931_comment},
  {"hasAnyOf", (PyCFunction) &Dtool_SparseArray_has_any_of_931, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_has_any_of_931_comment},
  {"has_all_of", (PyCFunction) &Dtool_SparseArray_has_all_of_932, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_has_all_of_932_comment},
  {"hasAllOf", (PyCFunction) &Dtool_SparseArray_has_all_of_932, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_has_all_of_932_comment},
  {"set_range", (PyCFunction) &Dtool_SparseArray_set_range_933, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_set_range_933_comment},
  {"setRange", (PyCFunction) &Dtool_SparseArray_set_range_933, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_set_range_933_comment},
  {"clear_range", (PyCFunction) &Dtool_SparseArray_clear_range_934, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_clear_range_934_comment},
  {"clearRange", (PyCFunction) &Dtool_SparseArray_clear_range_934, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_clear_range_934_comment},
  {"set_range_to", (PyCFunction) &Dtool_SparseArray_set_range_to_935, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_set_range_to_935_comment},
  {"setRangeTo", (PyCFunction) &Dtool_SparseArray_set_range_to_935, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_set_range_to_935_comment},
  {"get_num_on_bits", &Dtool_SparseArray_get_num_on_bits_936, METH_NOARGS, (const char *)Dtool_SparseArray_get_num_on_bits_936_comment},
  {"getNumOnBits", &Dtool_SparseArray_get_num_on_bits_936, METH_NOARGS, (const char *)Dtool_SparseArray_get_num_on_bits_936_comment},
  {"get_num_off_bits", &Dtool_SparseArray_get_num_off_bits_937, METH_NOARGS, (const char *)Dtool_SparseArray_get_num_off_bits_937_comment},
  {"getNumOffBits", &Dtool_SparseArray_get_num_off_bits_937, METH_NOARGS, (const char *)Dtool_SparseArray_get_num_off_bits_937_comment},
  {"get_lowest_on_bit", &Dtool_SparseArray_get_lowest_on_bit_938, METH_NOARGS, (const char *)Dtool_SparseArray_get_lowest_on_bit_938_comment},
  {"getLowestOnBit", &Dtool_SparseArray_get_lowest_on_bit_938, METH_NOARGS, (const char *)Dtool_SparseArray_get_lowest_on_bit_938_comment},
  {"get_lowest_off_bit", &Dtool_SparseArray_get_lowest_off_bit_939, METH_NOARGS, (const char *)Dtool_SparseArray_get_lowest_off_bit_939_comment},
  {"getLowestOffBit", &Dtool_SparseArray_get_lowest_off_bit_939, METH_NOARGS, (const char *)Dtool_SparseArray_get_lowest_off_bit_939_comment},
  {"get_highest_on_bit", &Dtool_SparseArray_get_highest_on_bit_940, METH_NOARGS, (const char *)Dtool_SparseArray_get_highest_on_bit_940_comment},
  {"getHighestOnBit", &Dtool_SparseArray_get_highest_on_bit_940, METH_NOARGS, (const char *)Dtool_SparseArray_get_highest_on_bit_940_comment},
  {"get_highest_off_bit", &Dtool_SparseArray_get_highest_off_bit_941, METH_NOARGS, (const char *)Dtool_SparseArray_get_highest_off_bit_941_comment},
  {"getHighestOffBit", &Dtool_SparseArray_get_highest_off_bit_941, METH_NOARGS, (const char *)Dtool_SparseArray_get_highest_off_bit_941_comment},
  {"get_next_higher_different_bit", &Dtool_SparseArray_get_next_higher_different_bit_942, METH_O, (const char *)Dtool_SparseArray_get_next_higher_different_bit_942_comment},
  {"getNextHigherDifferentBit", &Dtool_SparseArray_get_next_higher_different_bit_942, METH_O, (const char *)Dtool_SparseArray_get_next_higher_different_bit_942_comment},
  {"invert_in_place", &Dtool_SparseArray_invert_in_place_943, METH_NOARGS, (const char *)Dtool_SparseArray_invert_in_place_943_comment},
  {"invertInPlace", &Dtool_SparseArray_invert_in_place_943, METH_NOARGS, (const char *)Dtool_SparseArray_invert_in_place_943_comment},
  {"has_bits_in_common", &Dtool_SparseArray_has_bits_in_common_944, METH_O, (const char *)Dtool_SparseArray_has_bits_in_common_944_comment},
  {"hasBitsInCommon", &Dtool_SparseArray_has_bits_in_common_944, METH_O, (const char *)Dtool_SparseArray_has_bits_in_common_944_comment},
  {"clear", &Dtool_SparseArray_clear_945, METH_NOARGS, (const char *)Dtool_SparseArray_clear_945_comment},
  {"output", &Dtool_SparseArray_output_946, METH_O, (const char *)Dtool_SparseArray_output_946_comment},
  {"compare_to", &Dtool_SparseArray_compare_to_950, METH_O, (const char *)Dtool_SparseArray_compare_to_950_comment},
  {"compareTo", &Dtool_SparseArray_compare_to_950, METH_O, (const char *)Dtool_SparseArray_compare_to_950_comment},
  {"__ior__", &Dtool_SparseArray_operator_958, METH_O, (const char *)Dtool_SparseArray_operator_958_comment},
  {"is_inverse", &Dtool_SparseArray_is_inverse_962, METH_NOARGS, (const char *)Dtool_SparseArray_is_inverse_962_comment},
  {"isInverse", &Dtool_SparseArray_is_inverse_962, METH_NOARGS, (const char *)Dtool_SparseArray_is_inverse_962_comment},
  {"get_num_subranges", &Dtool_SparseArray_get_num_subranges_963, METH_NOARGS, (const char *)Dtool_SparseArray_get_num_subranges_963_comment},
  {"getNumSubranges", &Dtool_SparseArray_get_num_subranges_963, METH_NOARGS, (const char *)Dtool_SparseArray_get_num_subranges_963_comment},
  {"get_subrange_begin", &Dtool_SparseArray_get_subrange_begin_964, METH_O, (const char *)Dtool_SparseArray_get_subrange_begin_964_comment},
  {"getSubrangeBegin", &Dtool_SparseArray_get_subrange_begin_964, METH_O, (const char *)Dtool_SparseArray_get_subrange_begin_964_comment},
  {"get_subrange_end", &Dtool_SparseArray_get_subrange_end_965, METH_O, (const char *)Dtool_SparseArray_get_subrange_end_965_comment},
  {"getSubrangeEnd", &Dtool_SparseArray_get_subrange_end_965, METH_O, (const char *)Dtool_SparseArray_get_subrange_end_965_comment},
  {"get_class_type", &Dtool_SparseArray_get_class_type_966, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_get_class_type_966_comment},
  {"getClassType", &Dtool_SparseArray_get_class_type_966, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_get_class_type_966_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_and -> operator &
//////////////////
static PyObject *Dtool_SparseArray_operator_951_nb_and(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SparseArray, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline SparseArray SparseArray::operator &(SparseArray const &other) const
  SparseArray const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_SparseArray(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SparseArray.__and__", "SparseArray");
  }
  SparseArray *return_value = new SparseArray((*(const SparseArray*)local_this).operator &(*arg_this));
  if (arg_manage) {
    delete arg_this;
  }
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_inplace_and -> operator &=
//////////////////
static PyObject *Dtool_SparseArray_operator_957_nb_inplace_and(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SparseArray, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void SparseArray::operator &=(SparseArray const &other)
    SparseArray const *arg_this;
    bool arg_manage = false;
    if (!Dtool_ConstCoerce_SparseArray(arg, arg_this, arg_manage)) {
      Dtool_Raise_ArgTypeError(arg, 1, "SparseArray.__iand__", "SparseArray");
      return NULL;
    }
    (*local_this).operator &=(*arg_this);
    if (arg_manage) {
      delete arg_this;
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call SparseArray.__iand__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_inplace_lshift -> operator <<=
//////////////////
static PyObject *Dtool_SparseArray_operator_960_nb_inplace_lshift(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SparseArray, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void SparseArray::operator <<=(int shift)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator <<=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call SparseArray.__ilshift__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_inplace_rshift -> operator >>=
//////////////////
static PyObject *Dtool_SparseArray_operator_961_nb_inplace_rshift(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SparseArray, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void SparseArray::operator >>=(int shift)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator >>=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call SparseArray.__irshift__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_inplace_xor -> operator ^=
//////////////////
static PyObject *Dtool_SparseArray_operator_959_nb_inplace_xor(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SparseArray, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void SparseArray::operator ^=(SparseArray const &other)
    SparseArray const *arg_this;
    bool arg_manage = false;
    if (!Dtool_ConstCoerce_SparseArray(arg, arg_this, arg_manage)) {
      Dtool_Raise_ArgTypeError(arg, 1, "SparseArray.__ixor__", "SparseArray");
      return NULL;
    }
    (*local_this).operator ^=(*arg_this);
    if (arg_manage) {
      delete arg_this;
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call SparseArray.__ixor__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_invert -> operator ~
//////////////////
static PyObject *Dtool_SparseArray_operator_954_nb_invert(PyObject *self) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline SparseArray SparseArray::operator ~(void) const
  SparseArray *return_value = new SparseArray((*(const SparseArray*)local_this).operator ~());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__invert__(SparseArray self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_lshift -> operator <<
//////////////////
static PyObject *Dtool_SparseArray_operator_955_nb_lshift(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SparseArray, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline SparseArray SparseArray::operator <<(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    SparseArray *return_value = new SparseArray((*(const SparseArray*)local_this).operator <<((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_or -> operator |
//////////////////
static PyObject *Dtool_SparseArray_operator_952_nb_or(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SparseArray, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline SparseArray SparseArray::operator |(SparseArray const &other) const
  SparseArray const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_SparseArray(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SparseArray.__or__", "SparseArray");
  }
  SparseArray *return_value = new SparseArray((*(const SparseArray*)local_this).operator |(*arg_this));
  if (arg_manage) {
    delete arg_this;
  }
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_rshift -> operator >>
//////////////////
static PyObject *Dtool_SparseArray_operator_956_nb_rshift(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SparseArray, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline SparseArray SparseArray::operator >>(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    SparseArray *return_value = new SparseArray((*(const SparseArray*)local_this).operator >>((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_xor -> operator ^
//////////////////
static PyObject *Dtool_SparseArray_operator_953_nb_xor(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SparseArray, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline SparseArray SparseArray::operator ^(SparseArray const &other) const
  SparseArray const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_SparseArray(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SparseArray.__xor__", "SparseArray");
  }
  SparseArray *return_value = new SparseArray((*(const SparseArray*)local_this).operator ^(*arg_this));
  if (arg_manage) {
    delete arg_this;
  }
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot tp_compare -> compare_to
//////////////////
static int Dtool_SparseArray_compare_to_950_tp_compare(PyObject *self, PyObject *arg) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return -1;
  }

  // 1-int SparseArray::compare_to(SparseArray const &other) const
  SparseArray const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_SparseArray(arg, arg_this, arg_manage)) {
    Dtool_Raise_ArgTypeError(arg, 1, "SparseArray.compare_to", "SparseArray");
    return -1;
  }
  int return_value = (*(const SparseArray*)local_this).compare_to(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(SparseArray self, const SparseArray other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     SparseArray
//////////////////
static PyObject *Dtool_Repr_SparseArray(PyObject *self) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     SparseArray
//////////////////
static PyObject *Dtool_RichCompare_SparseArray(PyObject *self, PyObject *arg, int op) {
  SparseArray *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool SparseArray::operator ==(SparseArray const &other) const
      SparseArray const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_SparseArray(arg, arg_this, arg_manage)) {
        bool return_value = (*(const SparseArray*)local_this).operator ==(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool SparseArray::operator !=(SparseArray const &other) const
      SparseArray const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_SparseArray(arg, arg_this, arg_manage)) {
        bool return_value = (*(const SparseArray*)local_this).operator !=(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool SparseArray::operator <(SparseArray const &other) const
      SparseArray const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_SparseArray(arg, arg_this, arg_manage)) {
        bool return_value = (*(const SparseArray*)local_this).operator <(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_SparseArray_compare_to_950_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_SparseArray = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  &Dtool_SparseArray_operator_954_nb_invert,
  &Dtool_SparseArray_operator_955_nb_lshift,
  &Dtool_SparseArray_operator_956_nb_rshift,
  &Dtool_SparseArray_operator_951_nb_and,
  &Dtool_SparseArray_operator_953_nb_xor,
  &Dtool_SparseArray_operator_952_nb_or,
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  &Dtool_SparseArray_operator_960_nb_inplace_lshift,
  &Dtool_SparseArray_operator_961_nb_inplace_rshift,
  &Dtool_SparseArray_operator_957_nb_inplace_and,
  &Dtool_SparseArray_operator_959_nb_inplace_xor,
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_SparseArray = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.SparseArray",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SparseArray,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_SparseArray_compare_to_950_tp_compare,
#endif
    &Dtool_Repr_SparseArray,
    &Dtool_NumberMethods_SparseArray,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Repr_SparseArray,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class records a set of integers, where each integer is either present\n"
    " * or not present in the set.\n"
    " *\n"
    " * It is similar in principle and in interface to a BitArray (which can be\n"
    " * thought of as a set of integers, one integer corresponding to each\n"
    " * different bit position), but the SparseArray is implemented as a list of\n"
    " * min/max subrange lists, rather than as a bitmask.\n"
    " *\n"
    " * This makes it particularly efficient for storing sets which consist of\n"
    " * large sections of consecutively included or consecutively excluded\n"
    " * elements, with arbitrarily large integers, but particularly inefficient for\n"
    " * doing boolean operations such as & or |.\n"
    " *\n"
    " * Also, unlike BitArray, the SparseArray can store negative integers.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_SparseArray,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SparseArray,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SparseArray,
    PyType_GenericAlloc,
    Dtool_new_SparseArray,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SparseArray,
  Dtool_UpcastInterface_SparseArray,
  Dtool_DowncastInterface_SparseArray,
  (CoerceFunction)Dtool_ConstCoerce_SparseArray,
  (CoerceFunction)Dtool_Coerce_SparseArray,
};

static void Dtool_PyModuleClassInit_SparseArray(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_SparseArray._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_SparseArray._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SparseArray) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SparseArray)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SparseArray);
  }
}

/**
 * Python method tables for ParamValueBase (ParamValueBase)
 */
static PyMethodDef Dtool_Methods_ParamValueBase[] = {
  {"get_value_type", &Dtool_ParamValueBase_get_value_type_968, METH_NOARGS, (const char *)Dtool_ParamValueBase_get_value_type_968_comment},
  {"getValueType", &Dtool_ParamValueBase_get_value_type_968, METH_NOARGS, (const char *)Dtool_ParamValueBase_get_value_type_968_comment},
  {"output", &Dtool_ParamValueBase_output_969, METH_O, (const char *)Dtool_ParamValueBase_output_969_comment},
  {"get_class_type", &Dtool_ParamValueBase_get_class_type_970, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValueBase_get_class_type_970_comment},
  {"getClassType", &Dtool_ParamValueBase_get_class_type_970, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValueBase_get_class_type_970_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     ParamValueBase
//////////////////
static PyObject *Dtool_Repr_ParamValueBase(PyObject *self) {
  ParamValueBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValueBase, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ParamValueBase = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValueBase = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParamValueBase = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParamValueBase = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParamValueBase = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ParamValueBase",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValueBase,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_ParamValueBase,
    &Dtool_NumberMethods_ParamValueBase,
    &Dtool_SequenceMethods_ParamValueBase,
    &Dtool_MappingMethods_ParamValueBase,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_ParamValueBase,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParamValueBase,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A non-template base class of ParamValue (below), which serves mainly to\n"
    " * define the placeholder for the virtual output function.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParamValueBase,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParamValueBase,
    PyType_GenericAlloc,
    Dtool_new_ParamValueBase,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValueBase,
  Dtool_UpcastInterface_ParamValueBase,
  Dtool_DowncastInterface_ParamValueBase,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ParamValueBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TypedWritableReferenceCount(NULL);
    Dtool_ParamValueBase._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TypedWritableReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_ParamValueBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValueBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValueBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValueBase);
  }
}

/**
 * Python method tables for ParamTypedRefCount (ParamTypedRefCount)
 */
static PyMethodDef Dtool_Methods_ParamTypedRefCount[] = {
  {"get_value", &Dtool_ParamTypedRefCount_get_value_973, METH_NOARGS, (const char *)Dtool_ParamTypedRefCount_get_value_973_comment},
  {"getValue", &Dtool_ParamTypedRefCount_get_value_973, METH_NOARGS, (const char *)Dtool_ParamTypedRefCount_get_value_973_comment},
  {"get_class_type", &Dtool_ParamTypedRefCount_get_class_type_976, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamTypedRefCount_get_class_type_976_comment},
  {"getClassType", &Dtool_ParamTypedRefCount_get_class_type_976, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamTypedRefCount_get_class_type_976_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ParamTypedRefCount[] = {
  {(char *)"value", &Dtool_ParamTypedRefCount_value_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ParamTypedRefCount = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamTypedRefCount = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParamTypedRefCount = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParamTypedRefCount = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParamTypedRefCount = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ParamTypedRefCount",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamTypedRefCount,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ParamTypedRefCount,
    &Dtool_SequenceMethods_ParamTypedRefCount,
    &Dtool_MappingMethods_ParamTypedRefCount,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParamTypedRefCount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class object for storing specifically objects of type\n"
    " * TypedReferenceCount, which is different than TypedWritableReferenceCount.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParamTypedRefCount,
    0, // tp_members
    Dtool_Properties_ParamTypedRefCount,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParamTypedRefCount,
    PyType_GenericAlloc,
    Dtool_new_ParamTypedRefCount,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamTypedRefCount,
  Dtool_UpcastInterface_ParamTypedRefCount,
  Dtool_DowncastInterface_ParamTypedRefCount,
  (CoerceFunction)Dtool_ConstCoerce_ParamTypedRefCount,
  (CoerceFunction)Dtool_Coerce_ParamTypedRefCount,
};

static void Dtool_PyModuleClassInit_ParamTypedRefCount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(NULL);
    Dtool_ParamTypedRefCount._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    PyObject *dict = PyDict_New();
    Dtool_ParamTypedRefCount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamTypedRefCount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamTypedRefCount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamTypedRefCount);
  }
}

/**
 * Python method tables for ParamValue_std_string (ParamValue_string)
 */
static PyMethodDef Dtool_Methods_ParamValue_std_string[] = {
  {"set_value", &Dtool_ParamValue_string_set_value_979, METH_O, (const char *)Dtool_ParamValue_string_set_value_979_comment},
  {"setValue", &Dtool_ParamValue_string_set_value_979, METH_O, (const char *)Dtool_ParamValue_string_set_value_979_comment},
  {"get_value", &Dtool_ParamValue_string_get_value_980, METH_NOARGS, (const char *)Dtool_ParamValue_string_get_value_980_comment},
  {"getValue", &Dtool_ParamValue_string_get_value_980, METH_NOARGS, (const char *)Dtool_ParamValue_string_get_value_980_comment},
  {"get_class_type", &Dtool_ParamValue_string_get_class_type_984, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_string_get_class_type_984_comment},
  {"getClassType", &Dtool_ParamValue_string_get_class_type_984, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_string_get_class_type_984_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ParamValue_std_string[] = {
  {(char *)"value", &Dtool_ParamValue_std_string_value_Getter, &Dtool_ParamValue_std_string_value_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_std_string = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_std_string = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_std_string = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_std_string = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParamValue_std_string = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ParamValue_string",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_std_string,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ParamValue_std_string,
    &Dtool_SequenceMethods_ParamValue_std_string,
    &Dtool_MappingMethods_ParamValue_std_string,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParamValue_std_string,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParamValue_std_string,
    0, // tp_members
    Dtool_Properties_ParamValue_std_string,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParamValue_std_string,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_std_string,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_std_string,
  Dtool_UpcastInterface_ParamValue_std_string,
  Dtool_DowncastInterface_ParamValue_std_string,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_std_string,
  (CoerceFunction)Dtool_Coerce_ParamValue_std_string,
};

static void Dtool_PyModuleClassInit_ParamValue_std_string(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(NULL);
    Dtool_ParamValue_std_string._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_std_string._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_std_string) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_std_string)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_std_string);
  }
}

/**
 * Python method tables for ParamValue_std_wstring (ParamValue_wstring)
 */
static PyMethodDef Dtool_Methods_ParamValue_std_wstring[] = {
  {"set_value", &Dtool_ParamValue_wstring_set_value_988, METH_O, (const char *)Dtool_ParamValue_wstring_set_value_988_comment},
  {"setValue", &Dtool_ParamValue_wstring_set_value_988, METH_O, (const char *)Dtool_ParamValue_wstring_set_value_988_comment},
  {"get_value", &Dtool_ParamValue_wstring_get_value_989, METH_NOARGS, (const char *)Dtool_ParamValue_wstring_get_value_989_comment},
  {"getValue", &Dtool_ParamValue_wstring_get_value_989, METH_NOARGS, (const char *)Dtool_ParamValue_wstring_get_value_989_comment},
  {"get_class_type", &Dtool_ParamValue_wstring_get_class_type_991, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_wstring_get_class_type_991_comment},
  {"getClassType", &Dtool_ParamValue_wstring_get_class_type_991, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_wstring_get_class_type_991_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ParamValue_std_wstring[] = {
  {(char *)"value", &Dtool_ParamValue_std_wstring_value_Getter, &Dtool_ParamValue_std_wstring_value_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_std_wstring = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_std_wstring = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_std_wstring = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_std_wstring = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParamValue_std_wstring = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ParamValue_wstring",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_std_wstring,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ParamValue_std_wstring,
    &Dtool_SequenceMethods_ParamValue_std_wstring,
    &Dtool_MappingMethods_ParamValue_std_wstring,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParamValue_std_wstring,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParamValue_std_wstring,
    0, // tp_members
    Dtool_Properties_ParamValue_std_wstring,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParamValue_std_wstring,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_std_wstring,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_std_wstring,
  Dtool_UpcastInterface_ParamValue_std_wstring,
  Dtool_DowncastInterface_ParamValue_std_wstring,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_std_wstring,
  (CoerceFunction)Dtool_Coerce_ParamValue_std_wstring,
};

static void Dtool_PyModuleClassInit_ParamValue_std_wstring(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(NULL);
    Dtool_ParamValue_std_wstring._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_std_wstring._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_std_wstring) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_std_wstring)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_std_wstring);
  }
}

/**
 * Python method tables for ParamValue_LVecBase2d (ParamValue_LVecBase2d)
 */
static PyMethodDef Dtool_Methods_ParamValue_LVecBase2d[] = {
  {"set_value", &Dtool_ParamValue_LVecBase2d_set_value_995, METH_O, (const char *)Dtool_ParamValue_LVecBase2d_set_value_995_comment},
  {"setValue", &Dtool_ParamValue_LVecBase2d_set_value_995, METH_O, (const char *)Dtool_ParamValue_LVecBase2d_set_value_995_comment},
  {"get_value", &Dtool_ParamValue_LVecBase2d_get_value_996, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase2d_get_value_996_comment},
  {"getValue", &Dtool_ParamValue_LVecBase2d_get_value_996, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase2d_get_value_996_comment},
  {"get_class_type", &Dtool_ParamValue_LVecBase2d_get_class_type_998, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase2d_get_class_type_998_comment},
  {"getClassType", &Dtool_ParamValue_LVecBase2d_get_class_type_998, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase2d_get_class_type_998_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ParamValue_LVecBase2d[] = {
  {(char *)"value", &Dtool_ParamValue_LVecBase2d_value_Getter, &Dtool_ParamValue_LVecBase2d_value_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LVecBase2d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LVecBase2d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LVecBase2d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LVecBase2d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParamValue_LVecBase2d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ParamValue_LVecBase2d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LVecBase2d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ParamValue_LVecBase2d,
    &Dtool_SequenceMethods_ParamValue_LVecBase2d,
    &Dtool_MappingMethods_ParamValue_LVecBase2d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParamValue_LVecBase2d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParamValue_LVecBase2d,
    0, // tp_members
    Dtool_Properties_ParamValue_LVecBase2d,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LVecBase2d,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LVecBase2d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LVecBase2d,
  Dtool_UpcastInterface_ParamValue_LVecBase2d,
  Dtool_DowncastInterface_ParamValue_LVecBase2d,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LVecBase2d,
  (CoerceFunction)Dtool_Coerce_ParamValue_LVecBase2d,
};

static void Dtool_PyModuleClassInit_ParamValue_LVecBase2d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(NULL);
    Dtool_ParamValue_LVecBase2d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LVecBase2d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LVecBase2d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LVecBase2d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LVecBase2d);
  }
}

/**
 * Python method tables for ParamValue_LVecBase2f (ParamValue_LVecBase2f)
 */
static PyMethodDef Dtool_Methods_ParamValue_LVecBase2f[] = {
  {"set_value", &Dtool_ParamValue_LVecBase2f_set_value_1002, METH_O, (const char *)Dtool_ParamValue_LVecBase2f_set_value_1002_comment},
  {"setValue", &Dtool_ParamValue_LVecBase2f_set_value_1002, METH_O, (const char *)Dtool_ParamValue_LVecBase2f_set_value_1002_comment},
  {"get_value", &Dtool_ParamValue_LVecBase2f_get_value_1003, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase2f_get_value_1003_comment},
  {"getValue", &Dtool_ParamValue_LVecBase2f_get_value_1003, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase2f_get_value_1003_comment},
  {"get_class_type", &Dtool_ParamValue_LVecBase2f_get_class_type_1005, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase2f_get_class_type_1005_comment},
  {"getClassType", &Dtool_ParamValue_LVecBase2f_get_class_type_1005, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase2f_get_class_type_1005_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ParamValue_LVecBase2f[] = {
  {(char *)"value", &Dtool_ParamValue_LVecBase2f_value_Getter, &Dtool_ParamValue_LVecBase2f_value_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LVecBase2f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LVecBase2f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LVecBase2f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LVecBase2f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParamValue_LVecBase2f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ParamValue_LVecBase2f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LVecBase2f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ParamValue_LVecBase2f,
    &Dtool_SequenceMethods_ParamValue_LVecBase2f,
    &Dtool_MappingMethods_ParamValue_LVecBase2f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParamValue_LVecBase2f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParamValue_LVecBase2f,
    0, // tp_members
    Dtool_Properties_ParamValue_LVecBase2f,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LVecBase2f,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LVecBase2f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LVecBase2f,
  Dtool_UpcastInterface_ParamValue_LVecBase2f,
  Dtool_DowncastInterface_ParamValue_LVecBase2f,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LVecBase2f,
  (CoerceFunction)Dtool_Coerce_ParamValue_LVecBase2f,
};

static void Dtool_PyModuleClassInit_ParamValue_LVecBase2f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(NULL);
    Dtool_ParamValue_LVecBase2f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LVecBase2f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LVecBase2f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LVecBase2f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LVecBase2f);
  }
}

/**
 * Python method tables for ParamValue_LVecBase2i (ParamValue_LVecBase2i)
 */
static PyMethodDef Dtool_Methods_ParamValue_LVecBase2i[] = {
  {"set_value", &Dtool_ParamValue_LVecBase2i_set_value_1009, METH_O, (const char *)Dtool_ParamValue_LVecBase2i_set_value_1009_comment},
  {"setValue", &Dtool_ParamValue_LVecBase2i_set_value_1009, METH_O, (const char *)Dtool_ParamValue_LVecBase2i_set_value_1009_comment},
  {"get_value", &Dtool_ParamValue_LVecBase2i_get_value_1010, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase2i_get_value_1010_comment},
  {"getValue", &Dtool_ParamValue_LVecBase2i_get_value_1010, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase2i_get_value_1010_comment},
  {"get_class_type", &Dtool_ParamValue_LVecBase2i_get_class_type_1012, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase2i_get_class_type_1012_comment},
  {"getClassType", &Dtool_ParamValue_LVecBase2i_get_class_type_1012, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase2i_get_class_type_1012_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ParamValue_LVecBase2i[] = {
  {(char *)"value", &Dtool_ParamValue_LVecBase2i_value_Getter, &Dtool_ParamValue_LVecBase2i_value_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LVecBase2i = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LVecBase2i = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LVecBase2i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LVecBase2i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParamValue_LVecBase2i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ParamValue_LVecBase2i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LVecBase2i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ParamValue_LVecBase2i,
    &Dtool_SequenceMethods_ParamValue_LVecBase2i,
    &Dtool_MappingMethods_ParamValue_LVecBase2i,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParamValue_LVecBase2i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParamValue_LVecBase2i,
    0, // tp_members
    Dtool_Properties_ParamValue_LVecBase2i,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LVecBase2i,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LVecBase2i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LVecBase2i,
  Dtool_UpcastInterface_ParamValue_LVecBase2i,
  Dtool_DowncastInterface_ParamValue_LVecBase2i,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LVecBase2i,
  (CoerceFunction)Dtool_Coerce_ParamValue_LVecBase2i,
};

static void Dtool_PyModuleClassInit_ParamValue_LVecBase2i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(NULL);
    Dtool_ParamValue_LVecBase2i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LVecBase2i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LVecBase2i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LVecBase2i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LVecBase2i);
  }
}

/**
 * Python method tables for ParamValue_LVecBase3d (ParamValue_LVecBase3d)
 */
static PyMethodDef Dtool_Methods_ParamValue_LVecBase3d[] = {
  {"set_value", &Dtool_ParamValue_LVecBase3d_set_value_1016, METH_O, (const char *)Dtool_ParamValue_LVecBase3d_set_value_1016_comment},
  {"setValue", &Dtool_ParamValue_LVecBase3d_set_value_1016, METH_O, (const char *)Dtool_ParamValue_LVecBase3d_set_value_1016_comment},
  {"get_value", &Dtool_ParamValue_LVecBase3d_get_value_1017, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase3d_get_value_1017_comment},
  {"getValue", &Dtool_ParamValue_LVecBase3d_get_value_1017, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase3d_get_value_1017_comment},
  {"get_class_type", &Dtool_ParamValue_LVecBase3d_get_class_type_1019, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase3d_get_class_type_1019_comment},
  {"getClassType", &Dtool_ParamValue_LVecBase3d_get_class_type_1019, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase3d_get_class_type_1019_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ParamValue_LVecBase3d[] = {
  {(char *)"value", &Dtool_ParamValue_LVecBase3d_value_Getter, &Dtool_ParamValue_LVecBase3d_value_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LVecBase3d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LVecBase3d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LVecBase3d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LVecBase3d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParamValue_LVecBase3d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ParamValue_LVecBase3d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LVecBase3d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ParamValue_LVecBase3d,
    &Dtool_SequenceMethods_ParamValue_LVecBase3d,
    &Dtool_MappingMethods_ParamValue_LVecBase3d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParamValue_LVecBase3d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParamValue_LVecBase3d,
    0, // tp_members
    Dtool_Properties_ParamValue_LVecBase3d,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LVecBase3d,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LVecBase3d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LVecBase3d,
  Dtool_UpcastInterface_ParamValue_LVecBase3d,
  Dtool_DowncastInterface_ParamValue_LVecBase3d,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LVecBase3d,
  (CoerceFunction)Dtool_Coerce_ParamValue_LVecBase3d,
};

static void Dtool_PyModuleClassInit_ParamValue_LVecBase3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(NULL);
    Dtool_ParamValue_LVecBase3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LVecBase3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LVecBase3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LVecBase3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LVecBase3d);
  }
}

/**
 * Python method tables for ParamValue_LVecBase3f (ParamValue_LVecBase3f)
 */
static PyMethodDef Dtool_Methods_ParamValue_LVecBase3f[] = {
  {"set_value", &Dtool_ParamValue_LVecBase3f_set_value_1023, METH_O, (const char *)Dtool_ParamValue_LVecBase3f_set_value_1023_comment},
  {"setValue", &Dtool_ParamValue_LVecBase3f_set_value_1023, METH_O, (const char *)Dtool_ParamValue_LVecBase3f_set_value_1023_comment},
  {"get_value", &Dtool_ParamValue_LVecBase3f_get_value_1024, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase3f_get_value_1024_comment},
  {"getValue", &Dtool_ParamValue_LVecBase3f_get_value_1024, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase3f_get_value_1024_comment},
  {"get_class_type", &Dtool_ParamValue_LVecBase3f_get_class_type_1026, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase3f_get_class_type_1026_comment},
  {"getClassType", &Dtool_ParamValue_LVecBase3f_get_class_type_1026, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase3f_get_class_type_1026_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ParamValue_LVecBase3f[] = {
  {(char *)"value", &Dtool_ParamValue_LVecBase3f_value_Getter, &Dtool_ParamValue_LVecBase3f_value_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LVecBase3f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LVecBase3f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LVecBase3f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LVecBase3f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParamValue_LVecBase3f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ParamValue_LVecBase3f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LVecBase3f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ParamValue_LVecBase3f,
    &Dtool_SequenceMethods_ParamValue_LVecBase3f,
    &Dtool_MappingMethods_ParamValue_LVecBase3f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParamValue_LVecBase3f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParamValue_LVecBase3f,
    0, // tp_members
    Dtool_Properties_ParamValue_LVecBase3f,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LVecBase3f,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LVecBase3f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LVecBase3f,
  Dtool_UpcastInterface_ParamValue_LVecBase3f,
  Dtool_DowncastInterface_ParamValue_LVecBase3f,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LVecBase3f,
  (CoerceFunction)Dtool_Coerce_ParamValue_LVecBase3f,
};

static void Dtool_PyModuleClassInit_ParamValue_LVecBase3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(NULL);
    Dtool_ParamValue_LVecBase3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LVecBase3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LVecBase3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LVecBase3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LVecBase3f);
  }
}

/**
 * Python method tables for ParamValue_LVecBase3i (ParamValue_LVecBase3i)
 */
static PyMethodDef Dtool_Methods_ParamValue_LVecBase3i[] = {
  {"set_value", &Dtool_ParamValue_LVecBase3i_set_value_1030, METH_O, (const char *)Dtool_ParamValue_LVecBase3i_set_value_1030_comment},
  {"setValue", &Dtool_ParamValue_LVecBase3i_set_value_1030, METH_O, (const char *)Dtool_ParamValue_LVecBase3i_set_value_1030_comment},
  {"get_value", &Dtool_ParamValue_LVecBase3i_get_value_1031, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase3i_get_value_1031_comment},
  {"getValue", &Dtool_ParamValue_LVecBase3i_get_value_1031, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase3i_get_value_1031_comment},
  {"get_class_type", &Dtool_ParamValue_LVecBase3i_get_class_type_1033, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase3i_get_class_type_1033_comment},
  {"getClassType", &Dtool_ParamValue_LVecBase3i_get_class_type_1033, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase3i_get_class_type_1033_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ParamValue_LVecBase3i[] = {
  {(char *)"value", &Dtool_ParamValue_LVecBase3i_value_Getter, &Dtool_ParamValue_LVecBase3i_value_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LVecBase3i = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LVecBase3i = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LVecBase3i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LVecBase3i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParamValue_LVecBase3i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ParamValue_LVecBase3i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LVecBase3i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ParamValue_LVecBase3i,
    &Dtool_SequenceMethods_ParamValue_LVecBase3i,
    &Dtool_MappingMethods_ParamValue_LVecBase3i,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParamValue_LVecBase3i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParamValue_LVecBase3i,
    0, // tp_members
    Dtool_Properties_ParamValue_LVecBase3i,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LVecBase3i,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LVecBase3i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LVecBase3i,
  Dtool_UpcastInterface_ParamValue_LVecBase3i,
  Dtool_DowncastInterface_ParamValue_LVecBase3i,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LVecBase3i,
  (CoerceFunction)Dtool_Coerce_ParamValue_LVecBase3i,
};

static void Dtool_PyModuleClassInit_ParamValue_LVecBase3i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(NULL);
    Dtool_ParamValue_LVecBase3i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LVecBase3i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LVecBase3i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LVecBase3i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LVecBase3i);
  }
}

/**
 * Python method tables for ParamValue_LVecBase4d (ParamValue_LVecBase4d)
 */
static PyMethodDef Dtool_Methods_ParamValue_LVecBase4d[] = {
  {"set_value", &Dtool_ParamValue_LVecBase4d_set_value_1037, METH_O, (const char *)Dtool_ParamValue_LVecBase4d_set_value_1037_comment},
  {"setValue", &Dtool_ParamValue_LVecBase4d_set_value_1037, METH_O, (const char *)Dtool_ParamValue_LVecBase4d_set_value_1037_comment},
  {"get_value", &Dtool_ParamValue_LVecBase4d_get_value_1038, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase4d_get_value_1038_comment},
  {"getValue", &Dtool_ParamValue_LVecBase4d_get_value_1038, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase4d_get_value_1038_comment},
  {"get_class_type", &Dtool_ParamValue_LVecBase4d_get_class_type_1040, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase4d_get_class_type_1040_comment},
  {"getClassType", &Dtool_ParamValue_LVecBase4d_get_class_type_1040, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase4d_get_class_type_1040_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ParamValue_LVecBase4d[] = {
  {(char *)"value", &Dtool_ParamValue_LVecBase4d_value_Getter, &Dtool_ParamValue_LVecBase4d_value_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LVecBase4d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LVecBase4d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LVecBase4d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LVecBase4d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParamValue_LVecBase4d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ParamValue_LVecBase4d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LVecBase4d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ParamValue_LVecBase4d,
    &Dtool_SequenceMethods_ParamValue_LVecBase4d,
    &Dtool_MappingMethods_ParamValue_LVecBase4d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParamValue_LVecBase4d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParamValue_LVecBase4d,
    0, // tp_members
    Dtool_Properties_ParamValue_LVecBase4d,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LVecBase4d,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LVecBase4d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LVecBase4d,
  Dtool_UpcastInterface_ParamValue_LVecBase4d,
  Dtool_DowncastInterface_ParamValue_LVecBase4d,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LVecBase4d,
  (CoerceFunction)Dtool_Coerce_ParamValue_LVecBase4d,
};

static void Dtool_PyModuleClassInit_ParamValue_LVecBase4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(NULL);
    Dtool_ParamValue_LVecBase4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LVecBase4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LVecBase4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LVecBase4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LVecBase4d);
  }
}

/**
 * Python method tables for ParamValue_LVecBase4f (ParamValue_LVecBase4f)
 */
static PyMethodDef Dtool_Methods_ParamValue_LVecBase4f[] = {
  {"set_value", &Dtool_ParamValue_LVecBase4f_set_value_1044, METH_O, (const char *)Dtool_ParamValue_LVecBase4f_set_value_1044_comment},
  {"setValue", &Dtool_ParamValue_LVecBase4f_set_value_1044, METH_O, (const char *)Dtool_ParamValue_LVecBase4f_set_value_1044_comment},
  {"get_value", &Dtool_ParamValue_LVecBase4f_get_value_1045, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase4f_get_value_1045_comment},
  {"getValue", &Dtool_ParamValue_LVecBase4f_get_value_1045, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase4f_get_value_1045_comment},
  {"get_class_type", &Dtool_ParamValue_LVecBase4f_get_class_type_1047, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase4f_get_class_type_1047_comment},
  {"getClassType", &Dtool_ParamValue_LVecBase4f_get_class_type_1047, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase4f_get_class_type_1047_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ParamValue_LVecBase4f[] = {
  {(char *)"value", &Dtool_ParamValue_LVecBase4f_value_Getter, &Dtool_ParamValue_LVecBase4f_value_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LVecBase4f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LVecBase4f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LVecBase4f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LVecBase4f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParamValue_LVecBase4f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ParamValue_LVecBase4f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LVecBase4f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ParamValue_LVecBase4f,
    &Dtool_SequenceMethods_ParamValue_LVecBase4f,
    &Dtool_MappingMethods_ParamValue_LVecBase4f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParamValue_LVecBase4f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParamValue_LVecBase4f,
    0, // tp_members
    Dtool_Properties_ParamValue_LVecBase4f,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LVecBase4f,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LVecBase4f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LVecBase4f,
  Dtool_UpcastInterface_ParamValue_LVecBase4f,
  Dtool_DowncastInterface_ParamValue_LVecBase4f,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LVecBase4f,
  (CoerceFunction)Dtool_Coerce_ParamValue_LVecBase4f,
};

static void Dtool_PyModuleClassInit_ParamValue_LVecBase4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(NULL);
    Dtool_ParamValue_LVecBase4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LVecBase4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LVecBase4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LVecBase4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LVecBase4f);
  }
}

/**
 * Python method tables for ParamValue_LVecBase4i (ParamValue_LVecBase4i)
 */
static PyMethodDef Dtool_Methods_ParamValue_LVecBase4i[] = {
  {"set_value", &Dtool_ParamValue_LVecBase4i_set_value_1051, METH_O, (const char *)Dtool_ParamValue_LVecBase4i_set_value_1051_comment},
  {"setValue", &Dtool_ParamValue_LVecBase4i_set_value_1051, METH_O, (const char *)Dtool_ParamValue_LVecBase4i_set_value_1051_comment},
  {"get_value", &Dtool_ParamValue_LVecBase4i_get_value_1052, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase4i_get_value_1052_comment},
  {"getValue", &Dtool_ParamValue_LVecBase4i_get_value_1052, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase4i_get_value_1052_comment},
  {"get_class_type", &Dtool_ParamValue_LVecBase4i_get_class_type_1054, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase4i_get_class_type_1054_comment},
  {"getClassType", &Dtool_ParamValue_LVecBase4i_get_class_type_1054, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase4i_get_class_type_1054_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ParamValue_LVecBase4i[] = {
  {(char *)"value", &Dtool_ParamValue_LVecBase4i_value_Getter, &Dtool_ParamValue_LVecBase4i_value_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LVecBase4i = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LVecBase4i = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LVecBase4i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LVecBase4i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParamValue_LVecBase4i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ParamValue_LVecBase4i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LVecBase4i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ParamValue_LVecBase4i,
    &Dtool_SequenceMethods_ParamValue_LVecBase4i,
    &Dtool_MappingMethods_ParamValue_LVecBase4i,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParamValue_LVecBase4i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParamValue_LVecBase4i,
    0, // tp_members
    Dtool_Properties_ParamValue_LVecBase4i,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LVecBase4i,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LVecBase4i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LVecBase4i,
  Dtool_UpcastInterface_ParamValue_LVecBase4i,
  Dtool_DowncastInterface_ParamValue_LVecBase4i,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LVecBase4i,
  (CoerceFunction)Dtool_Coerce_ParamValue_LVecBase4i,
};

static void Dtool_PyModuleClassInit_ParamValue_LVecBase4i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(NULL);
    Dtool_ParamValue_LVecBase4i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LVecBase4i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LVecBase4i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LVecBase4i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LVecBase4i);
  }
}

/**
 * Python method tables for ParamValue_LMatrix3d (ParamValue_LMatrix3d)
 */
static PyMethodDef Dtool_Methods_ParamValue_LMatrix3d[] = {
  {"set_value", &Dtool_ParamValue_LMatrix3d_set_value_1058, METH_O, (const char *)Dtool_ParamValue_LMatrix3d_set_value_1058_comment},
  {"setValue", &Dtool_ParamValue_LMatrix3d_set_value_1058, METH_O, (const char *)Dtool_ParamValue_LMatrix3d_set_value_1058_comment},
  {"get_value", &Dtool_ParamValue_LMatrix3d_get_value_1059, METH_NOARGS, (const char *)Dtool_ParamValue_LMatrix3d_get_value_1059_comment},
  {"getValue", &Dtool_ParamValue_LMatrix3d_get_value_1059, METH_NOARGS, (const char *)Dtool_ParamValue_LMatrix3d_get_value_1059_comment},
  {"get_class_type", &Dtool_ParamValue_LMatrix3d_get_class_type_1061, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LMatrix3d_get_class_type_1061_comment},
  {"getClassType", &Dtool_ParamValue_LMatrix3d_get_class_type_1061, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LMatrix3d_get_class_type_1061_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ParamValue_LMatrix3d[] = {
  {(char *)"value", &Dtool_ParamValue_LMatrix3d_value_Getter, &Dtool_ParamValue_LMatrix3d_value_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LMatrix3d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LMatrix3d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LMatrix3d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LMatrix3d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParamValue_LMatrix3d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ParamValue_LMatrix3d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LMatrix3d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ParamValue_LMatrix3d,
    &Dtool_SequenceMethods_ParamValue_LMatrix3d,
    &Dtool_MappingMethods_ParamValue_LMatrix3d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParamValue_LMatrix3d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParamValue_LMatrix3d,
    0, // tp_members
    Dtool_Properties_ParamValue_LMatrix3d,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LMatrix3d,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LMatrix3d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LMatrix3d,
  Dtool_UpcastInterface_ParamValue_LMatrix3d,
  Dtool_DowncastInterface_ParamValue_LMatrix3d,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LMatrix3d,
  (CoerceFunction)Dtool_Coerce_ParamValue_LMatrix3d,
};

static void Dtool_PyModuleClassInit_ParamValue_LMatrix3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(NULL);
    Dtool_ParamValue_LMatrix3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LMatrix3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LMatrix3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LMatrix3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LMatrix3d);
  }
}

/**
 * Python method tables for ParamValue_LMatrix3f (ParamValue_LMatrix3f)
 */
static PyMethodDef Dtool_Methods_ParamValue_LMatrix3f[] = {
  {"set_value", &Dtool_ParamValue_LMatrix3f_set_value_1065, METH_O, (const char *)Dtool_ParamValue_LMatrix3f_set_value_1065_comment},
  {"setValue", &Dtool_ParamValue_LMatrix3f_set_value_1065, METH_O, (const char *)Dtool_ParamValue_LMatrix3f_set_value_1065_comment},
  {"get_value", &Dtool_ParamValue_LMatrix3f_get_value_1066, METH_NOARGS, (const char *)Dtool_ParamValue_LMatrix3f_get_value_1066_comment},
  {"getValue", &Dtool_ParamValue_LMatrix3f_get_value_1066, METH_NOARGS, (const char *)Dtool_ParamValue_LMatrix3f_get_value_1066_comment},
  {"get_class_type", &Dtool_ParamValue_LMatrix3f_get_class_type_1068, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LMatrix3f_get_class_type_1068_comment},
  {"getClassType", &Dtool_ParamValue_LMatrix3f_get_class_type_1068, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LMatrix3f_get_class_type_1068_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ParamValue_LMatrix3f[] = {
  {(char *)"value", &Dtool_ParamValue_LMatrix3f_value_Getter, &Dtool_ParamValue_LMatrix3f_value_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LMatrix3f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LMatrix3f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LMatrix3f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LMatrix3f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParamValue_LMatrix3f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ParamValue_LMatrix3f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LMatrix3f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ParamValue_LMatrix3f,
    &Dtool_SequenceMethods_ParamValue_LMatrix3f,
    &Dtool_MappingMethods_ParamValue_LMatrix3f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParamValue_LMatrix3f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParamValue_LMatrix3f,
    0, // tp_members
    Dtool_Properties_ParamValue_LMatrix3f,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LMatrix3f,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LMatrix3f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LMatrix3f,
  Dtool_UpcastInterface_ParamValue_LMatrix3f,
  Dtool_DowncastInterface_ParamValue_LMatrix3f,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LMatrix3f,
  (CoerceFunction)Dtool_Coerce_ParamValue_LMatrix3f,
};

static void Dtool_PyModuleClassInit_ParamValue_LMatrix3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(NULL);
    Dtool_ParamValue_LMatrix3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LMatrix3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LMatrix3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LMatrix3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LMatrix3f);
  }
}

/**
 * Python method tables for ParamValue_LMatrix4d (ParamValue_LMatrix4d)
 */
static PyMethodDef Dtool_Methods_ParamValue_LMatrix4d[] = {
  {"set_value", &Dtool_ParamValue_LMatrix4d_set_value_1072, METH_O, (const char *)Dtool_ParamValue_LMatrix4d_set_value_1072_comment},
  {"setValue", &Dtool_ParamValue_LMatrix4d_set_value_1072, METH_O, (const char *)Dtool_ParamValue_LMatrix4d_set_value_1072_comment},
  {"get_value", &Dtool_ParamValue_LMatrix4d_get_value_1073, METH_NOARGS, (const char *)Dtool_ParamValue_LMatrix4d_get_value_1073_comment},
  {"getValue", &Dtool_ParamValue_LMatrix4d_get_value_1073, METH_NOARGS, (const char *)Dtool_ParamValue_LMatrix4d_get_value_1073_comment},
  {"get_class_type", &Dtool_ParamValue_LMatrix4d_get_class_type_1075, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LMatrix4d_get_class_type_1075_comment},
  {"getClassType", &Dtool_ParamValue_LMatrix4d_get_class_type_1075, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LMatrix4d_get_class_type_1075_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ParamValue_LMatrix4d[] = {
  {(char *)"value", &Dtool_ParamValue_LMatrix4d_value_Getter, &Dtool_ParamValue_LMatrix4d_value_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LMatrix4d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LMatrix4d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LMatrix4d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LMatrix4d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParamValue_LMatrix4d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ParamValue_LMatrix4d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LMatrix4d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ParamValue_LMatrix4d,
    &Dtool_SequenceMethods_ParamValue_LMatrix4d,
    &Dtool_MappingMethods_ParamValue_LMatrix4d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParamValue_LMatrix4d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParamValue_LMatrix4d,
    0, // tp_members
    Dtool_Properties_ParamValue_LMatrix4d,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LMatrix4d,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LMatrix4d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LMatrix4d,
  Dtool_UpcastInterface_ParamValue_LMatrix4d,
  Dtool_DowncastInterface_ParamValue_LMatrix4d,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LMatrix4d,
  (CoerceFunction)Dtool_Coerce_ParamValue_LMatrix4d,
};

static void Dtool_PyModuleClassInit_ParamValue_LMatrix4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(NULL);
    Dtool_ParamValue_LMatrix4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LMatrix4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LMatrix4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LMatrix4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LMatrix4d);
  }
}

/**
 * Python method tables for ParamValue_LMatrix4f (ParamValue_LMatrix4f)
 */
static PyMethodDef Dtool_Methods_ParamValue_LMatrix4f[] = {
  {"set_value", &Dtool_ParamValue_LMatrix4f_set_value_1079, METH_O, (const char *)Dtool_ParamValue_LMatrix4f_set_value_1079_comment},
  {"setValue", &Dtool_ParamValue_LMatrix4f_set_value_1079, METH_O, (const char *)Dtool_ParamValue_LMatrix4f_set_value_1079_comment},
  {"get_value", &Dtool_ParamValue_LMatrix4f_get_value_1080, METH_NOARGS, (const char *)Dtool_ParamValue_LMatrix4f_get_value_1080_comment},
  {"getValue", &Dtool_ParamValue_LMatrix4f_get_value_1080, METH_NOARGS, (const char *)Dtool_ParamValue_LMatrix4f_get_value_1080_comment},
  {"get_class_type", &Dtool_ParamValue_LMatrix4f_get_class_type_1082, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LMatrix4f_get_class_type_1082_comment},
  {"getClassType", &Dtool_ParamValue_LMatrix4f_get_class_type_1082, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LMatrix4f_get_class_type_1082_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ParamValue_LMatrix4f[] = {
  {(char *)"value", &Dtool_ParamValue_LMatrix4f_value_Getter, &Dtool_ParamValue_LMatrix4f_value_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LMatrix4f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LMatrix4f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LMatrix4f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LMatrix4f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParamValue_LMatrix4f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ParamValue_LMatrix4f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LMatrix4f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ParamValue_LMatrix4f,
    &Dtool_SequenceMethods_ParamValue_LMatrix4f,
    &Dtool_MappingMethods_ParamValue_LMatrix4f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParamValue_LMatrix4f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParamValue_LMatrix4f,
    0, // tp_members
    Dtool_Properties_ParamValue_LMatrix4f,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LMatrix4f,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LMatrix4f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LMatrix4f,
  Dtool_UpcastInterface_ParamValue_LMatrix4f,
  Dtool_DowncastInterface_ParamValue_LMatrix4f,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LMatrix4f,
  (CoerceFunction)Dtool_Coerce_ParamValue_LMatrix4f,
};

static void Dtool_PyModuleClassInit_ParamValue_LMatrix4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(NULL);
    Dtool_ParamValue_LMatrix4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LMatrix4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LMatrix4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LMatrix4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LMatrix4f);
  }
}

/**
 * Python method tables for WritableConfigurable (WritableConfigurable)
 */
static PyMethodDef Dtool_Methods_WritableConfigurable[] = {
  {"get_class_type", &Dtool_WritableConfigurable_get_class_type_1090, METH_NOARGS | METH_STATIC, (const char *)Dtool_WritableConfigurable_get_class_type_1090_comment},
  {"getClassType", &Dtool_WritableConfigurable_get_class_type_1090, METH_NOARGS | METH_STATIC, (const char *)Dtool_WritableConfigurable_get_class_type_1090_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_WritableConfigurable = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_WritableConfigurable = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_WritableConfigurable = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_WritableConfigurable = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_WritableConfigurable = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.WritableConfigurable",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_WritableConfigurable,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_WritableConfigurable,
    &Dtool_SequenceMethods_WritableConfigurable,
    &Dtool_MappingMethods_WritableConfigurable,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_WritableConfigurable,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defined as a fix to allow creating Configurable and Writable objects.\n"
    " * Otherwise the compiler gets confused since both TypedWritable and\n"
    " * Configurable inherit from TypedObject.\n"
    " *\n"
    " * An object that has data or parameters that are set less frequently (at\n"
    " * least occasionally) than every frame.  We can cache the configuration info\n"
    " * by by using the \"dirty\" flag.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_WritableConfigurable,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_WritableConfigurable,
    PyType_GenericAlloc,
    Dtool_new_WritableConfigurable,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_WritableConfigurable,
  Dtool_UpcastInterface_WritableConfigurable,
  Dtool_DowncastInterface_WritableConfigurable,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_WritableConfigurable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TypedWritable(NULL);
    Dtool_WritableConfigurable._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TypedWritable);
    PyObject *dict = PyDict_New();
    Dtool_WritableConfigurable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_WritableConfigurable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(WritableConfigurable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_WritableConfigurable);
  }
}

/**
 * Python method tables for UniqueIdAllocator (UniqueIdAllocator)
 */
static PyMethodDef Dtool_Methods_UniqueIdAllocator[] = {
  {"allocate", &Dtool_UniqueIdAllocator_allocate_1095, METH_NOARGS, (const char *)Dtool_UniqueIdAllocator_allocate_1095_comment},
  {"initial_reserve_id", &Dtool_UniqueIdAllocator_initial_reserve_id_1096, METH_O, (const char *)Dtool_UniqueIdAllocator_initial_reserve_id_1096_comment},
  {"initialReserveId", &Dtool_UniqueIdAllocator_initial_reserve_id_1096, METH_O, (const char *)Dtool_UniqueIdAllocator_initial_reserve_id_1096_comment},
  {"free", &Dtool_UniqueIdAllocator_free_1097, METH_O, (const char *)Dtool_UniqueIdAllocator_free_1097_comment},
  {"fraction_used", &Dtool_UniqueIdAllocator_fraction_used_1098, METH_NOARGS, (const char *)Dtool_UniqueIdAllocator_fraction_used_1098_comment},
  {"fractionUsed", &Dtool_UniqueIdAllocator_fraction_used_1098, METH_NOARGS, (const char *)Dtool_UniqueIdAllocator_fraction_used_1098_comment},
  {"output", &Dtool_UniqueIdAllocator_output_1099, METH_O, (const char *)Dtool_UniqueIdAllocator_output_1099_comment},
  {"write", &Dtool_UniqueIdAllocator_write_1100, METH_O, (const char *)Dtool_UniqueIdAllocator_write_1100_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     UniqueIdAllocator
//////////////////
static PyObject *Dtool_Repr_UniqueIdAllocator(PyObject *self) {
  UniqueIdAllocator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UniqueIdAllocator, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     UniqueIdAllocator
//////////////////
static PyObject *Dtool_Str_UniqueIdAllocator(PyObject *self) {
  UniqueIdAllocator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UniqueIdAllocator, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_UniqueIdAllocator = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_UniqueIdAllocator = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.UniqueIdAllocator",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_UniqueIdAllocator,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_UniqueIdAllocator,
    &Dtool_NumberMethods_UniqueIdAllocator,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_UniqueIdAllocator,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Manage a set of ID values from min to max inclusive.  The ID numbers that\n"
    " * are freed will be allocated (reused) in the same order.  I.e.  the oldest\n"
    " * ID numbers will be allocated.\n"
    " *\n"
    " * This implementation will use 4 bytes per id number, plus a few bytes of\n"
    " * management data.  e.g.  10,000 ID numbers will use 40KB.\n"
    " *\n"
    " * Also be advised that ID -1 and -2 are used internally by the allocator.  If\n"
    " * allocate returns IndexEnd (-1) then the allocator is out of free ID\n"
    " * numbers.\n"
    " *\n"
    " * There are other implementations that can better leverage runs of used or\n"
    " * unused IDs or use bit arrays for the IDs.  But, it takes extra work to\n"
    " * track the age of freed IDs, which is required for what we wanted.  If you\n"
    " * would like to kick around other implementation ideas, please contact\n"
    " * Schuyler.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_UniqueIdAllocator,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_UniqueIdAllocator,
    PyType_GenericAlloc,
    Dtool_new_UniqueIdAllocator,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UniqueIdAllocator,
  Dtool_UpcastInterface_UniqueIdAllocator,
  Dtool_DowncastInterface_UniqueIdAllocator,
  (CoerceFunction)Dtool_ConstCoerce_UniqueIdAllocator,
  (CoerceFunction)Dtool_Coerce_UniqueIdAllocator,
};

static void Dtool_PyModuleClassInit_UniqueIdAllocator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_UniqueIdAllocator._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_UniqueIdAllocator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_UniqueIdAllocator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UniqueIdAllocator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UniqueIdAllocator);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3putil_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConstPointerToArray< ushort >", Dtool_ConstPointerToArray_ushort);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArrayBase< ushort >", Dtool_PointerToArrayBase_ushort);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< ReferenceCountedVector< ushort > >", Dtool_PointerToBase_ReferenceCountedVector_ushort);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArray< ushort >", Dtool_PointerToArray_ushort);
#endif
  Dtool_AnimInterface._type = AnimInterface::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AnimInterface);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("UpdateSeq", Dtool_UpdateSeq);
#endif
  Dtool_TypedWritable._type = TypedWritable::get_class_type();
  RegisterRuntimeTypedClass(Dtool_TypedWritable);
  Dtool_TypedWritableReferenceCount._type = TypedWritableReferenceCount::get_class_type();
  RegisterRuntimeTypedClass(Dtool_TypedWritableReferenceCount);
  Dtool_BamCacheRecord._type = BamCacheRecord::get_class_type();
  RegisterRuntimeTypedClass(Dtool_BamCacheRecord);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("BamCache", Dtool_BamCache);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("BamEnums", Dtool_BamEnums);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LoaderOptions", Dtool_LoaderOptions);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("BamReader", Dtool_BamReader);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("BamWriter", Dtool_BamWriter);
#endif
  Dtool_BitMask_uint16_t_16._type = BitMask< uint16_t, 16 >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_BitMask_uint16_t_16);
  Dtool_BitMask_uint32_t_32._type = BitMask< uint32_t, 32 >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_BitMask_uint32_t_32);
  Dtool_BitMask_uint64_t_64._type = BitMask< uint64_t, 64 >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_BitMask_uint64_t_64);
  Dtool_BitArray._type = BitArray::get_class_type();
  RegisterRuntimeTypedClass(Dtool_BitArray);
  Dtool_ButtonHandle._type = ButtonHandle::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ButtonHandle);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ButtonRegistry", Dtool_ButtonRegistry);
#endif
  Dtool_ButtonMap._type = ButtonMap::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ButtonMap);
  Dtool_CallbackObject._type = CallbackObject::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CallbackObject);
  Dtool_CachedTypedWritableReferenceCount._type = CachedTypedWritableReferenceCount::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CachedTypedWritableReferenceCount);
  Dtool_CallbackData._type = CallbackData::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CallbackData);
  Dtool_PythonCallbackObject._type = PythonCallbackObject::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PythonCallbackObject);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("TimeVal", Dtool_TimeVal);
#endif
  Dtool_ClockObject._type = ClockObject::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ClockObject);
  Dtool_CopyOnWriteObject._type = CopyOnWriteObject::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CopyOnWriteObject);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DatagramInputFile", Dtool_DatagramInputFile);
#endif
  Dtool_DoubleBitMask_BitMaskNative._type = DoubleBitMask< BitMaskNative >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_DoubleBitMask_BitMaskNative);
  Dtool_DoubleBitMask_DoubleBitMaskNative._type = DoubleBitMask< DoubleBitMaskNative >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_DoubleBitMask_DoubleBitMaskNative);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("KeyboardButton", Dtool_KeyboardButton);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ModifierButtons", Dtool_ModifierButtons);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("MouseButton", Dtool_MouseButton);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("MouseData", Dtool_MouseData);
#endif
  Dtool_NodeCachedReferenceCount._type = NodeCachedReferenceCount::get_class_type();
  RegisterRuntimeTypedClass(Dtool_NodeCachedReferenceCount);
  Dtool_SparseArray._type = SparseArray::get_class_type();
  RegisterRuntimeTypedClass(Dtool_SparseArray);
  Dtool_ParamValueBase._type = ParamValueBase::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ParamValueBase);
  Dtool_ParamTypedRefCount._type = ParamTypedRefCount::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ParamTypedRefCount);
  Dtool_ParamValue_std_string._type = ParamValue< std::string >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ParamValue_std_string);
  Dtool_ParamValue_std_wstring._type = ParamValue< std::wstring >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ParamValue_std_wstring);
  Dtool_ParamValue_LVecBase2d._type = ParamValue< LVecBase2d >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ParamValue_LVecBase2d);
  Dtool_ParamValue_LVecBase2f._type = ParamValue< LVecBase2f >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ParamValue_LVecBase2f);
  Dtool_ParamValue_LVecBase2i._type = ParamValue< LVecBase2i >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ParamValue_LVecBase2i);
  Dtool_ParamValue_LVecBase3d._type = ParamValue< LVecBase3d >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ParamValue_LVecBase3d);
  Dtool_ParamValue_LVecBase3f._type = ParamValue< LVecBase3f >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ParamValue_LVecBase3f);
  Dtool_ParamValue_LVecBase3i._type = ParamValue< LVecBase3i >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ParamValue_LVecBase3i);
  Dtool_ParamValue_LVecBase4d._type = ParamValue< LVecBase4d >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ParamValue_LVecBase4d);
  Dtool_ParamValue_LVecBase4f._type = ParamValue< LVecBase4f >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ParamValue_LVecBase4f);
  Dtool_ParamValue_LVecBase4i._type = ParamValue< LVecBase4i >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ParamValue_LVecBase4i);
  Dtool_ParamValue_LMatrix3d._type = ParamValue< LMatrix3d >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ParamValue_LMatrix3d);
  Dtool_ParamValue_LMatrix3f._type = ParamValue< LMatrix3f >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ParamValue_LMatrix3f);
  Dtool_ParamValue_LMatrix4d._type = ParamValue< LMatrix4d >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ParamValue_LMatrix4d);
  Dtool_ParamValue_LMatrix4f._type = ParamValue< LMatrix4f >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ParamValue_LMatrix4f);
  Dtool_WritableConfigurable._type = WritableConfigurable::get_class_type();
  RegisterRuntimeTypedClass(Dtool_WritableConfigurable);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("UniqueIdAllocator", Dtool_UniqueIdAllocator);
#endif
}

void Dtool_libp3putil_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_istream = LookupNamedClass("istream");
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_Filename = LookupRuntimeTypedClass(Filename::get_class_type());
  Dtool_Ptr_ConfigPage = LookupNamedClass("ConfigPage");
  Dtool_Ptr_PointerToVoid = LookupNamedClass("PointerToVoid");
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_Thread = LookupRuntimeTypedClass(Thread::get_class_type());
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_DatagramIterator = LookupRuntimeTypedClass(DatagramIterator::get_class_type());
  Dtool_Ptr_DatagramGenerator = LookupNamedClass("DatagramGenerator");
  Dtool_Ptr_FileReference = LookupRuntimeTypedClass(FileReference::get_class_type());
  Dtool_Ptr_DatagramSink = LookupNamedClass("DatagramSink");
  Dtool_Ptr_ConfigVariableSearchPath = LookupNamedClass("ConfigVariableSearchPath");
  Dtool_Ptr_VirtualFile = LookupRuntimeTypedClass(VirtualFile::get_class_type());
  Dtool_Ptr_HashVal = LookupNamedClass("HashVal");
  Dtool_Ptr_LVecBase2f = LookupRuntimeTypedClass(LVecBase2f::get_class_type());
  Dtool_Ptr_LVecBase3i = LookupRuntimeTypedClass(LVecBase3i::get_class_type());
  Dtool_Ptr_LVecBase2i = LookupRuntimeTypedClass(LVecBase2i::get_class_type());
  Dtool_Ptr_LVecBase2d = LookupRuntimeTypedClass(LVecBase2d::get_class_type());
  Dtool_Ptr_LVecBase3f = LookupRuntimeTypedClass(LVecBase3f::get_class_type());
  Dtool_Ptr_LVecBase3d = LookupRuntimeTypedClass(LVecBase3d::get_class_type());
  Dtool_Ptr_LMatrix4f = LookupRuntimeTypedClass(LMatrix4f::get_class_type());
  Dtool_Ptr_LVecBase4i = LookupRuntimeTypedClass(LVecBase4i::get_class_type());
  Dtool_Ptr_LVecBase4d = LookupRuntimeTypedClass(LVecBase4d::get_class_type());
  Dtool_Ptr_LMatrix3f = LookupRuntimeTypedClass(LMatrix3f::get_class_type());
  Dtool_Ptr_LVecBase4f = LookupRuntimeTypedClass(LVecBase4f::get_class_type());
  Dtool_Ptr_LMatrix3d = LookupRuntimeTypedClass(LMatrix3d::get_class_type());
  Dtool_Ptr_LMatrix4d = LookupRuntimeTypedClass(LMatrix4d::get_class_type());
#endif
}

void Dtool_libp3putil_BuildInstants(PyObject *module) {
  (void) module;
  // enum AutoTextureScale
  PyModule_AddObject(module, "ATS_none", Dtool_WrapValue(::ATS_none));
  PyModule_AddObject(module, "ATSNone", Dtool_WrapValue(::ATS_none));
  PyModule_AddObject(module, "ATS_down", Dtool_WrapValue(::ATS_down));
  PyModule_AddObject(module, "ATSDown", Dtool_WrapValue(::ATS_down));
  PyModule_AddObject(module, "ATS_up", Dtool_WrapValue(::ATS_up));
  PyModule_AddObject(module, "ATSUp", Dtool_WrapValue(::ATS_up));
  PyModule_AddObject(module, "ATS_pad", Dtool_WrapValue(::ATS_pad));
  PyModule_AddObject(module, "ATSPad", Dtool_WrapValue(::ATS_pad));
  PyModule_AddObject(module, "ATS_unspecified", Dtool_WrapValue(::ATS_unspecified));
  PyModule_AddObject(module, "ATSUnspecified", Dtool_WrapValue(::ATS_unspecified));
  // enum ColorSpace
  PyModule_AddObject(module, "CS_unspecified", Dtool_WrapValue(::CS_unspecified));
  PyModule_AddObject(module, "CSUnspecified", Dtool_WrapValue(::CS_unspecified));
  PyModule_AddObject(module, "CS_linear", Dtool_WrapValue(::CS_linear));
  PyModule_AddObject(module, "CSLinear", Dtool_WrapValue(::CS_linear));
  PyModule_AddObject(module, "CS_sRGB", Dtool_WrapValue(::CS_sRGB));
  PyModule_AddObject(module, "CSSRGB", Dtool_WrapValue(::CS_sRGB));
  PyModule_AddObject(module, "CS_scRGB", Dtool_WrapValue(::CS_scRGB));
  PyModule_AddObject(module, "CSScRGB", Dtool_WrapValue(::CS_scRGB));
  // ConstPointerToArray< ushort >
  Dtool_PyModuleClassInit_ConstPointerToArray_ushort(module);
  PyModule_AddObject(module, "ConstPointerToArray_ushort", (PyObject *)&Dtool_ConstPointerToArray_ushort);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_ushort);
  PyModule_AddObject(module, "ConstPointerToArrayUshort", (PyObject *)&Dtool_ConstPointerToArray_ushort);
  // PointerToArrayBase< ushort >
  Dtool_PyModuleClassInit_PointerToArrayBase_ushort(module);
  PyModule_AddObject(module, "PointerToArrayBase_ushort", (PyObject *)&Dtool_PointerToArrayBase_ushort);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_ushort);
  PyModule_AddObject(module, "PointerToArrayBaseUshort", (PyObject *)&Dtool_PointerToArrayBase_ushort);
  // PointerToBase< ReferenceCountedVector< ushort > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_ushort(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_ushort", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_ushort);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorUshort", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_ushort);
  // PointerToArray< ushort >
  Dtool_PyModuleClassInit_PointerToArray_ushort(module);
  PyModule_AddObject(module, "PointerToArray_ushort", (PyObject *)&Dtool_PointerToArray_ushort);
  Py_INCREF(Dtool_Ptr_PointerToArray_ushort);
  PyModule_AddObject(module, "PointerToArrayUshort", (PyObject *)&Dtool_PointerToArray_ushort);
  // AnimInterface
  Dtool_PyModuleClassInit_AnimInterface(module);
  PyModule_AddObject(module, "AnimInterface", (PyObject *)&Dtool_AnimInterface);
  // UpdateSeq
  Dtool_PyModuleClassInit_UpdateSeq(module);
  PyModule_AddObject(module, "UpdateSeq", (PyObject *)&Dtool_UpdateSeq);
  // TypedWritable
  Dtool_PyModuleClassInit_TypedWritable(module);
  PyModule_AddObject(module, "TypedWritable", (PyObject *)&Dtool_TypedWritable);
  // TypedWritableReferenceCount
  Dtool_PyModuleClassInit_TypedWritableReferenceCount(module);
  PyModule_AddObject(module, "TypedWritableReferenceCount", (PyObject *)&Dtool_TypedWritableReferenceCount);
  // BamCacheRecord
  Dtool_PyModuleClassInit_BamCacheRecord(module);
  PyModule_AddObject(module, "BamCacheRecord", (PyObject *)&Dtool_BamCacheRecord);
  // BamCache
  Dtool_PyModuleClassInit_BamCache(module);
  PyModule_AddObject(module, "BamCache", (PyObject *)&Dtool_BamCache);
  // BamEnums
  Dtool_PyModuleClassInit_BamEnums(module);
  PyModule_AddObject(module, "BamEnums", (PyObject *)&Dtool_BamEnums);
  // LoaderOptions
  Dtool_PyModuleClassInit_LoaderOptions(module);
  PyModule_AddObject(module, "LoaderOptions", (PyObject *)&Dtool_LoaderOptions);
  // BamReader
  Dtool_PyModuleClassInit_BamReader(module);
  PyModule_AddObject(module, "BamReader", (PyObject *)&Dtool_BamReader);
  // BamWriter
  Dtool_PyModuleClassInit_BamWriter(module);
  PyModule_AddObject(module, "BamWriter", (PyObject *)&Dtool_BamWriter);
  // BitMask< uint16_t, 16 >
  Dtool_PyModuleClassInit_BitMask_uint16_t_16(module);
  PyModule_AddObject(module, "BitMask_uint16_t_16", (PyObject *)&Dtool_BitMask_uint16_t_16);
  Py_INCREF(Dtool_Ptr_BitMask_uint16_t_16);
  PyModule_AddObject(module, "BitMaskUint16T16", (PyObject *)&Dtool_BitMask_uint16_t_16);
  // typedef BitMask< uint16_t, 16 > BitMask16
  Dtool_PyModuleClassInit_BitMask_uint16_t_16(module);
  Py_INCREF((PyObject *)&Dtool_BitMask_uint16_t_16);
  PyModule_AddObject(module, "BitMask16", (PyObject *)&Dtool_BitMask_uint16_t_16);
  // BitMask< uint32_t, 32 >
  Dtool_PyModuleClassInit_BitMask_uint32_t_32(module);
  PyModule_AddObject(module, "BitMask_uint32_t_32", (PyObject *)&Dtool_BitMask_uint32_t_32);
  Py_INCREF(Dtool_Ptr_BitMask_uint32_t_32);
  PyModule_AddObject(module, "BitMaskUint32T32", (PyObject *)&Dtool_BitMask_uint32_t_32);
  // typedef BitMask< uint32_t, 32 > BitMask32
  Dtool_PyModuleClassInit_BitMask_uint32_t_32(module);
  Py_INCREF((PyObject *)&Dtool_BitMask_uint32_t_32);
  PyModule_AddObject(module, "BitMask32", (PyObject *)&Dtool_BitMask_uint32_t_32);
  // BitMask< uint64_t, 64 >
  Dtool_PyModuleClassInit_BitMask_uint64_t_64(module);
  PyModule_AddObject(module, "BitMask_uint64_t_64", (PyObject *)&Dtool_BitMask_uint64_t_64);
  Py_INCREF(Dtool_Ptr_BitMask_uint64_t_64);
  PyModule_AddObject(module, "BitMaskUint64T64", (PyObject *)&Dtool_BitMask_uint64_t_64);
  // typedef BitMask< uint64_t, 64 > BitMask64
  Dtool_PyModuleClassInit_BitMask_uint64_t_64(module);
  Py_INCREF((PyObject *)&Dtool_BitMask_uint64_t_64);
  PyModule_AddObject(module, "BitMask64", (PyObject *)&Dtool_BitMask_uint64_t_64);
  // BitArray
  Dtool_PyModuleClassInit_BitArray(module);
  PyModule_AddObject(module, "BitArray", (PyObject *)&Dtool_BitArray);
  // ButtonHandle
  Dtool_PyModuleClassInit_ButtonHandle(module);
  PyModule_AddObject(module, "ButtonHandle", (PyObject *)&Dtool_ButtonHandle);
  // ButtonRegistry
  Dtool_PyModuleClassInit_ButtonRegistry(module);
  PyModule_AddObject(module, "ButtonRegistry", (PyObject *)&Dtool_ButtonRegistry);
  // ButtonMap
  Dtool_PyModuleClassInit_ButtonMap(module);
  PyModule_AddObject(module, "ButtonMap", (PyObject *)&Dtool_ButtonMap);
  // CallbackObject
  Dtool_PyModuleClassInit_CallbackObject(module);
  PyModule_AddObject(module, "CallbackObject", (PyObject *)&Dtool_CallbackObject);
  // CachedTypedWritableReferenceCount
  Dtool_PyModuleClassInit_CachedTypedWritableReferenceCount(module);
  PyModule_AddObject(module, "CachedTypedWritableReferenceCount", (PyObject *)&Dtool_CachedTypedWritableReferenceCount);
  // CallbackData
  Dtool_PyModuleClassInit_CallbackData(module);
  PyModule_AddObject(module, "CallbackData", (PyObject *)&Dtool_CallbackData);
  // PythonCallbackObject
  Dtool_PyModuleClassInit_PythonCallbackObject(module);
  PyModule_AddObject(module, "PythonCallbackObject", (PyObject *)&Dtool_PythonCallbackObject);
  // TimeVal
  Dtool_PyModuleClassInit_TimeVal(module);
  PyModule_AddObject(module, "TimeVal", (PyObject *)&Dtool_TimeVal);
  // ClockObject
  Dtool_PyModuleClassInit_ClockObject(module);
  PyModule_AddObject(module, "ClockObject", (PyObject *)&Dtool_ClockObject);
  // typedef BitMask< uint32_t, 32 > CollideMask
  Dtool_PyModuleClassInit_BitMask_uint32_t_32(module);
  Py_INCREF((PyObject *)&Dtool_BitMask_uint32_t_32);
  PyModule_AddObject(module, "CollideMask", (PyObject *)&Dtool_BitMask_uint32_t_32);
  // CopyOnWriteObject
  Dtool_PyModuleClassInit_CopyOnWriteObject(module);
  PyModule_AddObject(module, "CopyOnWriteObject", (PyObject *)&Dtool_CopyOnWriteObject);
  // DatagramInputFile
  Dtool_PyModuleClassInit_DatagramInputFile(module);
  PyModule_AddObject(module, "DatagramInputFile", (PyObject *)&Dtool_DatagramInputFile);
  // DoubleBitMask< BitMaskNative >
  Dtool_PyModuleClassInit_DoubleBitMask_BitMaskNative(module);
  PyModule_AddObject(module, "DoubleBitMask_BitMaskNative", (PyObject *)&Dtool_DoubleBitMask_BitMaskNative);
  Py_INCREF(Dtool_Ptr_DoubleBitMask_BitMaskNative);
  PyModule_AddObject(module, "DoubleBitMaskBitMaskNative", (PyObject *)&Dtool_DoubleBitMask_BitMaskNative);
  // typedef DoubleBitMask< BitMaskNative > DoubleBitMaskNative
  Dtool_PyModuleClassInit_DoubleBitMask_BitMaskNative(module);
  Py_INCREF((PyObject *)&Dtool_DoubleBitMask_BitMaskNative);
  PyModule_AddObject(module, "DoubleBitMaskNative", (PyObject *)&Dtool_DoubleBitMask_BitMaskNative);
  // DoubleBitMask< DoubleBitMaskNative >
  Dtool_PyModuleClassInit_DoubleBitMask_DoubleBitMaskNative(module);
  PyModule_AddObject(module, "DoubleBitMask_DoubleBitMaskNative", (PyObject *)&Dtool_DoubleBitMask_DoubleBitMaskNative);
  Py_INCREF(Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative);
  PyModule_AddObject(module, "DoubleBitMaskDoubleBitMaskNative", (PyObject *)&Dtool_DoubleBitMask_DoubleBitMaskNative);
  // typedef DoubleBitMask< DoubleBitMaskNative > QuadBitMaskNative
  Dtool_PyModuleClassInit_DoubleBitMask_DoubleBitMaskNative(module);
  Py_INCREF((PyObject *)&Dtool_DoubleBitMask_DoubleBitMaskNative);
  PyModule_AddObject(module, "QuadBitMaskNative", (PyObject *)&Dtool_DoubleBitMask_DoubleBitMaskNative);
  // typedef BitMask< uint32_t, 32 > DrawMask
  Dtool_PyModuleClassInit_BitMask_uint32_t_32(module);
  Py_INCREF((PyObject *)&Dtool_BitMask_uint32_t_32);
  PyModule_AddObject(module, "DrawMask", (PyObject *)&Dtool_BitMask_uint32_t_32);
  // KeyboardButton
  Dtool_PyModuleClassInit_KeyboardButton(module);
  PyModule_AddObject(module, "KeyboardButton", (PyObject *)&Dtool_KeyboardButton);
  // ModifierButtons
  Dtool_PyModuleClassInit_ModifierButtons(module);
  PyModule_AddObject(module, "ModifierButtons", (PyObject *)&Dtool_ModifierButtons);
  // MouseButton
  Dtool_PyModuleClassInit_MouseButton(module);
  PyModule_AddObject(module, "MouseButton", (PyObject *)&Dtool_MouseButton);
  // MouseData
  Dtool_PyModuleClassInit_MouseData(module);
  PyModule_AddObject(module, "MouseData", (PyObject *)&Dtool_MouseData);
  // NodeCachedReferenceCount
  Dtool_PyModuleClassInit_NodeCachedReferenceCount(module);
  PyModule_AddObject(module, "NodeCachedReferenceCount", (PyObject *)&Dtool_NodeCachedReferenceCount);
  // SparseArray
  Dtool_PyModuleClassInit_SparseArray(module);
  PyModule_AddObject(module, "SparseArray", (PyObject *)&Dtool_SparseArray);
  // ParamValueBase
  Dtool_PyModuleClassInit_ParamValueBase(module);
  PyModule_AddObject(module, "ParamValueBase", (PyObject *)&Dtool_ParamValueBase);
  // ParamTypedRefCount
  Dtool_PyModuleClassInit_ParamTypedRefCount(module);
  PyModule_AddObject(module, "ParamTypedRefCount", (PyObject *)&Dtool_ParamTypedRefCount);
  // ParamValue< string >
  Dtool_PyModuleClassInit_ParamValue_std_string(module);
  PyModule_AddObject(module, "ParamValue_string", (PyObject *)&Dtool_ParamValue_std_string);
  Py_INCREF(Dtool_Ptr_ParamValue_std_string);
  PyModule_AddObject(module, "ParamValueString", (PyObject *)&Dtool_ParamValue_std_string);
  // typedef ParamValue< std::string > ParamString
  Dtool_PyModuleClassInit_ParamValue_std_string(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_std_string);
  PyModule_AddObject(module, "ParamString", (PyObject *)&Dtool_ParamValue_std_string);
  // ParamValue< wstring >
  Dtool_PyModuleClassInit_ParamValue_std_wstring(module);
  PyModule_AddObject(module, "ParamValue_wstring", (PyObject *)&Dtool_ParamValue_std_wstring);
  Py_INCREF(Dtool_Ptr_ParamValue_std_wstring);
  PyModule_AddObject(module, "ParamValueWstring", (PyObject *)&Dtool_ParamValue_std_wstring);
  // typedef ParamValue< std::wstring > ParamWstring
  Dtool_PyModuleClassInit_ParamValue_std_wstring(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_std_wstring);
  PyModule_AddObject(module, "ParamWstring", (PyObject *)&Dtool_ParamValue_std_wstring);
  // ParamValue< LVecBase2d >
  Dtool_PyModuleClassInit_ParamValue_LVecBase2d(module);
  PyModule_AddObject(module, "ParamValue_LVecBase2d", (PyObject *)&Dtool_ParamValue_LVecBase2d);
  Py_INCREF(Dtool_Ptr_ParamValue_LVecBase2d);
  PyModule_AddObject(module, "ParamValueLVecBase2d", (PyObject *)&Dtool_ParamValue_LVecBase2d);
  // typedef ParamValue< LVecBase2d > ParamVecBase2d
  Dtool_PyModuleClassInit_ParamValue_LVecBase2d(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase2d);
  PyModule_AddObject(module, "ParamVecBase2d", (PyObject *)&Dtool_ParamValue_LVecBase2d);
  // ParamValue< LVecBase2f >
  Dtool_PyModuleClassInit_ParamValue_LVecBase2f(module);
  PyModule_AddObject(module, "ParamValue_LVecBase2f", (PyObject *)&Dtool_ParamValue_LVecBase2f);
  Py_INCREF(Dtool_Ptr_ParamValue_LVecBase2f);
  PyModule_AddObject(module, "ParamValueLVecBase2f", (PyObject *)&Dtool_ParamValue_LVecBase2f);
  // typedef ParamValue< LVecBase2f > ParamVecBase2f
  Dtool_PyModuleClassInit_ParamValue_LVecBase2f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase2f);
  PyModule_AddObject(module, "ParamVecBase2f", (PyObject *)&Dtool_ParamValue_LVecBase2f);
  // ParamValue< LVecBase2i >
  Dtool_PyModuleClassInit_ParamValue_LVecBase2i(module);
  PyModule_AddObject(module, "ParamValue_LVecBase2i", (PyObject *)&Dtool_ParamValue_LVecBase2i);
  Py_INCREF(Dtool_Ptr_ParamValue_LVecBase2i);
  PyModule_AddObject(module, "ParamValueLVecBase2i", (PyObject *)&Dtool_ParamValue_LVecBase2i);
  // typedef ParamValue< LVecBase2i > ParamVecBase2i
  Dtool_PyModuleClassInit_ParamValue_LVecBase2i(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase2i);
  PyModule_AddObject(module, "ParamVecBase2i", (PyObject *)&Dtool_ParamValue_LVecBase2i);
  // ParamValue< LVecBase3d >
  Dtool_PyModuleClassInit_ParamValue_LVecBase3d(module);
  PyModule_AddObject(module, "ParamValue_LVecBase3d", (PyObject *)&Dtool_ParamValue_LVecBase3d);
  Py_INCREF(Dtool_Ptr_ParamValue_LVecBase3d);
  PyModule_AddObject(module, "ParamValueLVecBase3d", (PyObject *)&Dtool_ParamValue_LVecBase3d);
  // typedef ParamValue< LVecBase3d > ParamVecBase3d
  Dtool_PyModuleClassInit_ParamValue_LVecBase3d(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase3d);
  PyModule_AddObject(module, "ParamVecBase3d", (PyObject *)&Dtool_ParamValue_LVecBase3d);
  // ParamValue< LVecBase3f >
  Dtool_PyModuleClassInit_ParamValue_LVecBase3f(module);
  PyModule_AddObject(module, "ParamValue_LVecBase3f", (PyObject *)&Dtool_ParamValue_LVecBase3f);
  Py_INCREF(Dtool_Ptr_ParamValue_LVecBase3f);
  PyModule_AddObject(module, "ParamValueLVecBase3f", (PyObject *)&Dtool_ParamValue_LVecBase3f);
  // typedef ParamValue< LVecBase3f > ParamVecBase3f
  Dtool_PyModuleClassInit_ParamValue_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase3f);
  PyModule_AddObject(module, "ParamVecBase3f", (PyObject *)&Dtool_ParamValue_LVecBase3f);
  // ParamValue< LVecBase3i >
  Dtool_PyModuleClassInit_ParamValue_LVecBase3i(module);
  PyModule_AddObject(module, "ParamValue_LVecBase3i", (PyObject *)&Dtool_ParamValue_LVecBase3i);
  Py_INCREF(Dtool_Ptr_ParamValue_LVecBase3i);
  PyModule_AddObject(module, "ParamValueLVecBase3i", (PyObject *)&Dtool_ParamValue_LVecBase3i);
  // typedef ParamValue< LVecBase3i > ParamVecBase3i
  Dtool_PyModuleClassInit_ParamValue_LVecBase3i(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase3i);
  PyModule_AddObject(module, "ParamVecBase3i", (PyObject *)&Dtool_ParamValue_LVecBase3i);
  // ParamValue< LVecBase4d >
  Dtool_PyModuleClassInit_ParamValue_LVecBase4d(module);
  PyModule_AddObject(module, "ParamValue_LVecBase4d", (PyObject *)&Dtool_ParamValue_LVecBase4d);
  Py_INCREF(Dtool_Ptr_ParamValue_LVecBase4d);
  PyModule_AddObject(module, "ParamValueLVecBase4d", (PyObject *)&Dtool_ParamValue_LVecBase4d);
  // typedef ParamValue< LVecBase4d > ParamVecBase4d
  Dtool_PyModuleClassInit_ParamValue_LVecBase4d(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase4d);
  PyModule_AddObject(module, "ParamVecBase4d", (PyObject *)&Dtool_ParamValue_LVecBase4d);
  // ParamValue< LVecBase4f >
  Dtool_PyModuleClassInit_ParamValue_LVecBase4f(module);
  PyModule_AddObject(module, "ParamValue_LVecBase4f", (PyObject *)&Dtool_ParamValue_LVecBase4f);
  Py_INCREF(Dtool_Ptr_ParamValue_LVecBase4f);
  PyModule_AddObject(module, "ParamValueLVecBase4f", (PyObject *)&Dtool_ParamValue_LVecBase4f);
  // typedef ParamValue< LVecBase4f > ParamVecBase4f
  Dtool_PyModuleClassInit_ParamValue_LVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase4f);
  PyModule_AddObject(module, "ParamVecBase4f", (PyObject *)&Dtool_ParamValue_LVecBase4f);
  // ParamValue< LVecBase4i >
  Dtool_PyModuleClassInit_ParamValue_LVecBase4i(module);
  PyModule_AddObject(module, "ParamValue_LVecBase4i", (PyObject *)&Dtool_ParamValue_LVecBase4i);
  Py_INCREF(Dtool_Ptr_ParamValue_LVecBase4i);
  PyModule_AddObject(module, "ParamValueLVecBase4i", (PyObject *)&Dtool_ParamValue_LVecBase4i);
  // typedef ParamValue< LVecBase4i > ParamVecBase4i
  Dtool_PyModuleClassInit_ParamValue_LVecBase4i(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase4i);
  PyModule_AddObject(module, "ParamVecBase4i", (PyObject *)&Dtool_ParamValue_LVecBase4i);
  // ParamValue< LMatrix3d >
  Dtool_PyModuleClassInit_ParamValue_LMatrix3d(module);
  PyModule_AddObject(module, "ParamValue_LMatrix3d", (PyObject *)&Dtool_ParamValue_LMatrix3d);
  Py_INCREF(Dtool_Ptr_ParamValue_LMatrix3d);
  PyModule_AddObject(module, "ParamValueLMatrix3d", (PyObject *)&Dtool_ParamValue_LMatrix3d);
  // typedef ParamValue< LMatrix3d > ParamMatrix3d
  Dtool_PyModuleClassInit_ParamValue_LMatrix3d(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LMatrix3d);
  PyModule_AddObject(module, "ParamMatrix3d", (PyObject *)&Dtool_ParamValue_LMatrix3d);
  // ParamValue< LMatrix3f >
  Dtool_PyModuleClassInit_ParamValue_LMatrix3f(module);
  PyModule_AddObject(module, "ParamValue_LMatrix3f", (PyObject *)&Dtool_ParamValue_LMatrix3f);
  Py_INCREF(Dtool_Ptr_ParamValue_LMatrix3f);
  PyModule_AddObject(module, "ParamValueLMatrix3f", (PyObject *)&Dtool_ParamValue_LMatrix3f);
  // typedef ParamValue< LMatrix3f > ParamMatrix3f
  Dtool_PyModuleClassInit_ParamValue_LMatrix3f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LMatrix3f);
  PyModule_AddObject(module, "ParamMatrix3f", (PyObject *)&Dtool_ParamValue_LMatrix3f);
  // ParamValue< LMatrix4d >
  Dtool_PyModuleClassInit_ParamValue_LMatrix4d(module);
  PyModule_AddObject(module, "ParamValue_LMatrix4d", (PyObject *)&Dtool_ParamValue_LMatrix4d);
  Py_INCREF(Dtool_Ptr_ParamValue_LMatrix4d);
  PyModule_AddObject(module, "ParamValueLMatrix4d", (PyObject *)&Dtool_ParamValue_LMatrix4d);
  // typedef ParamValue< LMatrix4d > ParamMatrix4d
  Dtool_PyModuleClassInit_ParamValue_LMatrix4d(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LMatrix4d);
  PyModule_AddObject(module, "ParamMatrix4d", (PyObject *)&Dtool_ParamValue_LMatrix4d);
  // ParamValue< LMatrix4f >
  Dtool_PyModuleClassInit_ParamValue_LMatrix4f(module);
  PyModule_AddObject(module, "ParamValue_LMatrix4f", (PyObject *)&Dtool_ParamValue_LMatrix4f);
  Py_INCREF(Dtool_Ptr_ParamValue_LMatrix4f);
  PyModule_AddObject(module, "ParamValueLMatrix4f", (PyObject *)&Dtool_ParamValue_LMatrix4f);
  // typedef ParamValue< LMatrix4f > ParamMatrix4f
  Dtool_PyModuleClassInit_ParamValue_LMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LMatrix4f);
  PyModule_AddObject(module, "ParamMatrix4f", (PyObject *)&Dtool_ParamValue_LMatrix4f);
  // typedef ParamValue< LVecBase2f > ParamVecBase2
  Dtool_PyModuleClassInit_ParamValue_LVecBase2f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase2f);
  PyModule_AddObject(module, "ParamVecBase2", (PyObject *)&Dtool_ParamValue_LVecBase2f);
  // typedef ParamValue< LVecBase3f > ParamVecBase3
  Dtool_PyModuleClassInit_ParamValue_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase3f);
  PyModule_AddObject(module, "ParamVecBase3", (PyObject *)&Dtool_ParamValue_LVecBase3f);
  // typedef ParamValue< LVecBase4f > ParamVecBase4
  Dtool_PyModuleClassInit_ParamValue_LVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase4f);
  PyModule_AddObject(module, "ParamVecBase4", (PyObject *)&Dtool_ParamValue_LVecBase4f);
  // typedef ParamValue< LMatrix3f > ParamMatrix3
  Dtool_PyModuleClassInit_ParamValue_LMatrix3f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LMatrix3f);
  PyModule_AddObject(module, "ParamMatrix3", (PyObject *)&Dtool_ParamValue_LMatrix3f);
  // typedef ParamValue< LMatrix4f > ParamMatrix4
  Dtool_PyModuleClassInit_ParamValue_LMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LMatrix4f);
  PyModule_AddObject(module, "ParamMatrix4", (PyObject *)&Dtool_ParamValue_LMatrix4f);
  // WritableConfigurable
  Dtool_PyModuleClassInit_WritableConfigurable(module);
  PyModule_AddObject(module, "WritableConfigurable", (PyObject *)&Dtool_WritableConfigurable);
  // UniqueIdAllocator
  Dtool_PyModuleClassInit_UniqueIdAllocator(module);
  PyModule_AddObject(module, "UniqueIdAllocator", (PyObject *)&Dtool_UniqueIdAllocator);
  // typedef BitMask< uint32_t, 32 > PortalMask
  Dtool_PyModuleClassInit_BitMask_uint32_t_32(module);
  Py_INCREF((PyObject *)&Dtool_BitMask_uint32_t_32);
  PyModule_AddObject(module, "PortalMask", (PyObject *)&Dtool_BitMask_uint32_t_32);
}

static PyMethodDef python_simple_funcs[] = {
  {"parse_color_space_string", &Dtool_parse_color_space_string_665, METH_O, (const char *)Dtool_parse_color_space_string_665_comment},
  {"parseColorSpaceString", &Dtool_parse_color_space_string_665, METH_O, (const char *)Dtool_parse_color_space_string_665_comment},
  {"format_color_space", &Dtool_format_color_space_666, METH_O, (const char *)Dtool_format_color_space_666_comment},
  {"formatColorSpace", &Dtool_format_color_space_666, METH_O, (const char *)Dtool_format_color_space_666_comment},
  {"get_model_path", &Dtool_get_model_path_667, METH_NOARGS, (const char *)Dtool_get_model_path_667_comment},
  {"getModelPath", &Dtool_get_model_path_667, METH_NOARGS, (const char *)Dtool_get_model_path_667_comment},
  {"get_plugin_path", &Dtool_get_plugin_path_668, METH_NOARGS, (const char *)Dtool_get_plugin_path_668_comment},
  {"getPluginPath", &Dtool_get_plugin_path_668, METH_NOARGS, (const char *)Dtool_get_plugin_path_668_comment},
  {"load_prc_file", &Dtool_load_prc_file_847, METH_O, (const char *)Dtool_load_prc_file_847_comment},
  {"loadPrcFile", &Dtool_load_prc_file_847, METH_O, (const char *)Dtool_load_prc_file_847_comment},
  {"load_prc_file_data", (PyCFunction) &Dtool_load_prc_file_data_848, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_load_prc_file_data_848_comment},
  {"loadPrcFileData", (PyCFunction) &Dtool_load_prc_file_data_848, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_load_prc_file_data_848_comment},
  {"unload_prc_file", &Dtool_unload_prc_file_849, METH_O, (const char *)Dtool_unload_prc_file_849_comment},
  {"unloadPrcFile", &Dtool_unload_prc_file_849, METH_O, (const char *)Dtool_unload_prc_file_849_comment},
  {"hash_prc_variables", &Dtool_hash_prc_variables_850, METH_O, (const char *)Dtool_hash_prc_variables_850_comment},
  {"hashPrcVariables", &Dtool_hash_prc_variables_850, METH_O, (const char *)Dtool_hash_prc_variables_850_comment},
  {"py_decode_TypedWritable_from_bam_stream", (PyCFunction) &Dtool_py_decode_TypedWritable_from_bam_stream_1101, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_py_decode_TypedWritable_from_bam_stream_1101_comment},
  {"pyDecodeTypedWritableFromBamStream", (PyCFunction) &Dtool_py_decode_TypedWritable_from_bam_stream_1101, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_py_decode_TypedWritable_from_bam_stream_1101_comment},
  {"py_decode_TypedWritable_from_bam_stream_persist", (PyCFunction) &Dtool_py_decode_TypedWritable_from_bam_stream_persist_1102, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_py_decode_TypedWritable_from_bam_stream_persist_1102_comment},
  {"pyDecodeTypedWritableFromBamStreamPersist", (PyCFunction) &Dtool_py_decode_TypedWritable_from_bam_stream_persist_1102, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_py_decode_TypedWritable_from_bam_stream_persist_1102_comment},
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3putil_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478210038,  /* file_identifier */
  "libp3putil",  /* library_name */
  "xqRv",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3putil.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  2257  /* next_index */
};

Configure(_in_configure_libp3putil);
ConfigureFn(_in_configure_libp3putil) {
  interrogate_request_module(&_in_module_def);
}

