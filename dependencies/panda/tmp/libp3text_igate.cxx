/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/text -Ipanda/src/text -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3text_igate.cxx -od built/pandac/input/libp3text.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/text -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/zlib/include -Sthirdparty/win-libs-vc10/freetype/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3text config_text.h default_font.h dynamicTextFont.h dynamicTextGlyph.h dynamicTextPage.h fontPool.h geomTextGlyph.h p3text_composite1.cxx p3text_composite2.cxx staticTextFont.h textAssembler.h textFont.h textGlyph.h textGraphic.h textNode.h textProperties.h textPropertiesManager.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3text
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "configVariableEnum.h"
#include "configVariableFilename.h"
#include "configVariableInt.h"
#include "config_text.h"
#include "default_font.h"
#include "dynamicTextFont.h"
#include "dynamicTextGlyph.h"
#include "dynamicTextPage.h"
#include "filename.h"
#include "fontPool.h"
#include "freetypeFont.h"
#include <ft2build.h>
#include "geom.h"
#include "geomTextGlyph.h"
#include "lightMutex.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "pmap.h"
#include "pvector.h"
#include "staticTextFont.h"
#include "textAssembler.h"
#include "textFont.h"
#include "textGlyph.h"
#include "textGraphic.h"
#include "textNode.h"
#include "textProperties.h"
#include "textPropertiesManager.h"
#include "texture.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class TextGlyph
 */
typedef TextGlyph TextGlyph_localtype;
Define_Module_ClassRef(panda3d.core, TextGlyph, TextGlyph_localtype, TextGlyph);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextGlyph = &Dtool_TextGlyph;
static void Dtool_PyModuleClassInit_TextGlyph(PyObject *module);

/**
 * Forward declarations for top-level class TextFont
 */
typedef TextFont TextFont_localtype;
Define_Module_ClassRef(panda3d.core, TextFont, TextFont_localtype, TextFont);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextFont = &Dtool_TextFont;
static void Dtool_PyModuleClassInit_TextFont(PyObject *module);

/**
 * Forward declarations for top-level class DynamicTextGlyph
 */
typedef DynamicTextGlyph DynamicTextGlyph_localtype;
Define_Module_ClassRef(panda3d.core, DynamicTextGlyph, DynamicTextGlyph_localtype, DynamicTextGlyph);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DynamicTextGlyph = &Dtool_DynamicTextGlyph;
static void Dtool_PyModuleClassInit_DynamicTextGlyph(PyObject *module);

/**
 * Forward declarations for top-level class DynamicTextPage
 */
typedef DynamicTextPage DynamicTextPage_localtype;
Define_Module_ClassRef(panda3d.core, DynamicTextPage, DynamicTextPage_localtype, DynamicTextPage);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DynamicTextPage = &Dtool_DynamicTextPage;
static void Dtool_PyModuleClassInit_DynamicTextPage(PyObject *module);

/**
 * Forward declarations for top-level class DynamicTextFont
 */
typedef DynamicTextFont DynamicTextFont_localtype;
Define_Module_ClassRef(panda3d.core, DynamicTextFont, DynamicTextFont_localtype, DynamicTextFont);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DynamicTextFont = &Dtool_DynamicTextFont;
static void Dtool_PyModuleClassInit_DynamicTextFont(PyObject *module);
bool Dtool_ConstCoerce_DynamicTextFont(PyObject *args, CPT(DynamicTextFont) &coerced);
bool Dtool_Coerce_DynamicTextFont(PyObject *args, PT(DynamicTextFont) &coerced);

/**
 * Forward declarations for top-level class FontPool
 */
typedef FontPool FontPool_localtype;
Define_Module_Class(panda3d.core, FontPool, FontPool_localtype, FontPool);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FontPool = &Dtool_FontPool;
static void Dtool_PyModuleClassInit_FontPool(PyObject *module);

/**
 * Forward declarations for top-level class GeomTextGlyph
 */
typedef GeomTextGlyph GeomTextGlyph_localtype;
Define_Module_ClassRef(panda3d.core, GeomTextGlyph, GeomTextGlyph_localtype, GeomTextGlyph);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomTextGlyph = &Dtool_GeomTextGlyph;
static void Dtool_PyModuleClassInit_GeomTextGlyph(PyObject *module);

/**
 * Forward declarations for top-level class StaticTextFont
 */
typedef StaticTextFont StaticTextFont_localtype;
Define_Module_ClassRef(panda3d.core, StaticTextFont, StaticTextFont_localtype, StaticTextFont);
static struct Dtool_PyTypedObject *const Dtool_Ptr_StaticTextFont = &Dtool_StaticTextFont;
static void Dtool_PyModuleClassInit_StaticTextFont(PyObject *module);
bool Dtool_ConstCoerce_StaticTextFont(PyObject *args, CPT(StaticTextFont) &coerced);
bool Dtool_Coerce_StaticTextFont(PyObject *args, PT(StaticTextFont) &coerced);

/**
 * Forward declarations for top-level class TextProperties
 */
typedef TextProperties TextProperties_localtype;
Define_Module_Class(panda3d.core, TextProperties, TextProperties_localtype, TextProperties);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextProperties = &Dtool_TextProperties;
static void Dtool_PyModuleClassInit_TextProperties(PyObject *module);

/**
 * Forward declarations for top-level class TextGraphic
 */
typedef TextGraphic TextGraphic_localtype;
Define_Module_Class(panda3d.core, TextGraphic, TextGraphic_localtype, TextGraphic);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextGraphic = &Dtool_TextGraphic;
static void Dtool_PyModuleClassInit_TextGraphic(PyObject *module);
bool Dtool_ConstCoerce_TextGraphic(PyObject *args, TextGraphic const *&coerced, bool &manage);
bool Dtool_Coerce_TextGraphic(PyObject *args, TextGraphic *&coerced, bool &manage);

/**
 * Forward declarations for top-level class TextPropertiesManager
 */
typedef TextPropertiesManager TextPropertiesManager_localtype;
Define_Module_Class_Private(panda3d.core, TextPropertiesManager, TextPropertiesManager_localtype, TextPropertiesManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextPropertiesManager = &Dtool_TextPropertiesManager;
static void Dtool_PyModuleClassInit_TextPropertiesManager(PyObject *module);

/**
 * Forward declarations for top-level class TextAssembler
 */
typedef TextAssembler TextAssembler_localtype;
Define_Module_Class(panda3d.core, TextAssembler, TextAssembler_localtype, TextAssembler);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextAssembler = &Dtool_TextAssembler;
static void Dtool_PyModuleClassInit_TextAssembler(PyObject *module);
bool Dtool_ConstCoerce_TextAssembler(PyObject *args, TextAssembler const *&coerced, bool &manage);
bool Dtool_Coerce_TextAssembler(PyObject *args, TextAssembler *&coerced, bool &manage);

/**
 * Forward declarations for top-level class TextNode
 */
typedef TextNode TextNode_localtype;
Define_Module_ClassRef(panda3d.core, TextNode, TextNode_localtype, TextNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextNode = &Dtool_TextNode;
static void Dtool_PyModuleClassInit_TextNode(PyObject *module);
bool Dtool_ConstCoerce_TextNode(PyObject *args, CPT(TextNode) &coerced);
bool Dtool_Coerce_TextNode(PyObject *args, PT(TextNode) &coerced);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// Filename
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Filename;
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != NULL, NULL);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != NULL, NULL);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// TextEncoder
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TextEncoder;
#else
extern struct Dtool_PyTypedObject Dtool_TextEncoder;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextEncoder = &Dtool_TextEncoder;
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritable;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// CachedTypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_CachedTypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_CachedTypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CachedTypedWritableReferenceCount = &Dtool_CachedTypedWritableReferenceCount;
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4f;
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint3f;
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != NULL, NULL);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix4f;
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// LVecBase2f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase2f;
inline static LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced) {
  nassertr(Dtool_Ptr_LVecBase2f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase2f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase2f *(*)(PyObject *, LVecBase2f &))Dtool_Ptr_LVecBase2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2f = &Dtool_LVecBase2f;
extern LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced);
#endif
// LVecBase2i
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase2i;
inline static LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced) {
  nassertr(Dtool_Ptr_LVecBase2i != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase2i->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase2i *(*)(PyObject *, LVecBase2i &))Dtool_Ptr_LVecBase2i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2i = &Dtool_LVecBase2i;
extern LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced);
#endif
// LVector2f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVector2f;
inline static LVector2f *Dtool_Coerce_LVector2f(PyObject *args, LVector2f &coerced) {
  nassertr(Dtool_Ptr_LVector2f != NULL, NULL);
  nassertr(Dtool_Ptr_LVector2f->_Dtool_Coerce != NULL, NULL);
  return ((LVector2f *(*)(PyObject *, LVector2f &))Dtool_Ptr_LVector2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector2f = &Dtool_LVector2f;
extern LVector2f *Dtool_Coerce_LVector2f(PyObject *args, LVector2f &coerced);
#endif
// CopyOnWriteObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_CopyOnWriteObject;
#else
extern struct Dtool_PyTypedObject Dtool_CopyOnWriteObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CopyOnWriteObject = &Dtool_CopyOnWriteObject;
#endif
// GeomEnums
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GeomEnums;
#else
extern struct Dtool_PyTypedObject Dtool_GeomEnums;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomEnums = &Dtool_GeomEnums;
#endif
// Texture
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Texture;
#else
extern struct Dtool_PyTypedObject Dtool_Texture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Texture = &Dtool_Texture;
#endif
// Geom
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Geom;
#else
extern struct Dtool_PyTypedObject Dtool_Geom;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Geom = &Dtool_Geom;
#endif
// RenderState
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_RenderState;
inline static bool Dtool_ConstCoerce_RenderState(PyObject *args, CPT(RenderState) &coerced) {
  nassertr(Dtool_Ptr_RenderState != NULL, false);
  nassertr(Dtool_Ptr_RenderState->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(RenderState) &))Dtool_Ptr_RenderState->_Dtool_ConstCoerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_RenderState;
static struct Dtool_PyTypedObject *const Dtool_Ptr_RenderState = &Dtool_RenderState;
extern bool Dtool_ConstCoerce_RenderState(PyObject *args, CPT(RenderState) &coerced);
#endif
// FreetypeFont
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_FreetypeFont;
#else
extern struct Dtool_PyTypedObject Dtool_FreetypeFont;
static struct Dtool_PyTypedObject *const Dtool_Ptr_FreetypeFont = &Dtool_FreetypeFont;
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PandaNode;
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// NodePath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePath;
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class TextGlyph
 */
/**
 * Python function wrapper for:
 * inline int TextGlyph::get_character(void) const
 */
static PyObject *Dtool_TextGlyph_get_character_3(PyObject *self, PyObject *) {
  TextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGlyph, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int TextGlyph::get_character(void) const
  int return_value = (*(const TextGlyph*)local_this).get_character();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextGlyph_get_character_3_comment =
  "C++ Interface:\n"
  "get_character(TextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the Unicode value that corresponds to the character this glyph\n"
  " * represents.\n"
  " */";
#else
static const char *Dtool_TextGlyph_get_character_3_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextGlyph::has_quad(void) const
 */
static PyObject *Dtool_TextGlyph_has_quad_4(PyObject *self, PyObject *) {
  TextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGlyph, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextGlyph::has_quad(void) const
  bool return_value = (*(const TextGlyph*)local_this).has_quad();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextGlyph_has_quad_4_comment =
  "C++ Interface:\n"
  "has_quad(TextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns true if this glyph contains the definition for a simple quad,\n"
  " * rather than a more complex piece of geometry.\n"
  " *\n"
  " * You may still call get_geom() even if this returns true, which will\n"
  " * synthesize a Geom for this quad.\n"
  " */";
#else
static const char *Dtool_TextGlyph_has_quad_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextGlyph::get_quad(LVecBase4 &dimensions, LVecBase4 &texcoords) const
 */
static PyObject *Dtool_TextGlyph_get_quad_5(PyObject *self, PyObject *args, PyObject *kwds) {
  TextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGlyph, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextGlyph::get_quad(LVecBase4 &dimensions, LVecBase4 &texcoords) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"dimensions", "texcoords", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_quad", (char **)keyword_list, &param1, &param2)) {
    LVecBase4f param1_local;
    LVecBase4 *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TextGlyph.get_quad", "LVecBase4f");
    }
    LVecBase4f param2_local;
    LVecBase4 *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TextGlyph.get_quad", "LVecBase4f");
    }
    bool return_value = (*(const TextGlyph*)local_this).get_quad(*param1_this, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_quad(TextGlyph self, LVecBase4f dimensions, LVecBase4f texcoords)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextGlyph_get_quad_5_comment =
  "C++ Interface:\n"
  "get_quad(TextGlyph self, LVecBase4f dimensions, LVecBase4f texcoords)\n"
  "\n"
  "/**\n"
  " * Assuming that this glyph is representable as a textured quad, returns its\n"
  " * dimensions and UV range.  Returns false if it is not representable as a\n"
  " * quad, or if it is whitespace.\n"
  " *\n"
  " * The order of the components is left, bottom, right, top.\n"
  " */";
#else
static const char *Dtool_TextGlyph_get_quad_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline RenderState const *TextGlyph::get_state(void) const
 */
static PyObject *Dtool_TextGlyph_get_state_6(PyObject *self, PyObject *) {
  TextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGlyph, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline RenderState const *TextGlyph::get_state(void) const
  RenderState const *return_value = (*(const TextGlyph*)local_this).get_state();
  if (return_value != (RenderState const *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (RenderState const *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderState, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextGlyph_get_state_6_comment =
  "C++ Interface:\n"
  "get_state(TextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the state in which the glyph should be rendered.\n"
  " */";
#else
static const char *Dtool_TextGlyph_get_state_6_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextGlyph::get_advance(void) const
 */
static PyObject *Dtool_TextGlyph_get_advance_7(PyObject *self, PyObject *) {
  TextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGlyph, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextGlyph::get_advance(void) const
  PN_stdfloat return_value = (*(const TextGlyph*)local_this).get_advance();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextGlyph_get_advance_7_comment =
  "C++ Interface:\n"
  "get_advance(TextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the distance by which the character pointer should be advanced\n"
  " * after placing this character; i.e.  the approximate width the character\n"
  " * takes up on the line.\n"
  " */";
#else
static const char *Dtool_TextGlyph_get_advance_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool TextGlyph::is_whitespace(void) const
 */
static PyObject *Dtool_TextGlyph_is_whitespace_17(PyObject *self, PyObject *) {
  TextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGlyph, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool TextGlyph::is_whitespace(void) const
  bool return_value = (*(const TextGlyph*)local_this).is_whitespace();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextGlyph_is_whitespace_17_comment =
  "C++ Interface:\n"
  "is_whitespace(TextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns true if this glyph represents invisible whitespace, or false if it\n"
  " * corresponds to some visible character.\n"
  " */";
#else
static const char *Dtool_TextGlyph_is_whitespace_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< Geom > TextGlyph::get_geom(GeomEnums::UsageHint usage_hint) const
 */
static PyObject *Dtool_TextGlyph_get_geom_18(PyObject *self, PyObject *arg) {
  TextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGlyph, (void **)&local_this)) {
    return NULL;
  }
  // 1-PointerTo< Geom > TextGlyph::get_geom(GeomEnums::UsageHint usage_hint) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PointerTo< Geom > return_value = (*(const TextGlyph*)local_this).get_geom((GeomEnums::UsageHint)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    Geom *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Geom, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_geom(TextGlyph self, int usage_hint)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextGlyph_get_geom_18_comment =
  "C++ Interface:\n"
  "get_geom(TextGlyph self, int usage_hint)\n"
  "\n"
  "/**\n"
  " * Returns a Geom that renders the particular glyph.  It will be generated if\n"
  " * necessary.\n"
  " *\n"
  " * This method will always return a copy of the Geom, so the caller is free to\n"
  " * modify it.\n"
  " */";
#else
static const char *Dtool_TextGlyph_get_geom_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TextGlyph::get_class_type(void)
 */
static PyObject *Dtool_TextGlyph_get_class_type_19(PyObject *, PyObject *) {
  // 1-static TypeHandle TextGlyph::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(TextGlyph::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextGlyph_get_class_type_19_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TextGlyph_get_class_type_19_comment = NULL;
#endif

static PyObject *Dtool_TextGlyph_character_Getter(PyObject *self, void *) {
  const TextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGlyph, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int TextGlyph::get_character(void) const
  int return_value = (*(const TextGlyph*)local_this).get_character();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_TextGlyph_state_Getter(PyObject *self, void *) {
  const TextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGlyph, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline RenderState const *TextGlyph::get_state(void) const
  RenderState const *return_value = (*(const TextGlyph*)local_this).get_state();
  if (return_value != (RenderState const *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (RenderState const *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RenderState, true, true, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_TextGlyph_advance_Getter(PyObject *self, void *) {
  const TextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGlyph, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat TextGlyph::get_advance(void) const
  PN_stdfloat return_value = (*(const TextGlyph*)local_this).get_advance();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_TextGlyph(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TextGlyph(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TextGlyph) {
    printf("TextGlyph ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TextGlyph *local_this = (TextGlyph *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TextGlyph) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TextGlyph(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TextGlyph) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (TextGlyph*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class TextFont
 */
/**
 * Python function wrapper for:
 * virtual PointerTo< TextFont > TextFont::make_copy(void) const = 0
 */
static PyObject *Dtool_TextFont_make_copy_28(PyObject *self, PyObject *) {
  TextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual PointerTo< TextFont > TextFont::make_copy(void) const = 0
  PointerTo< TextFont > return_value = (*(const TextFont*)local_this).make_copy();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  TextFont *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_TextFont, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextFont_make_copy_28_comment =
  "C++ Interface:\n"
  "make_copy(TextFont self)\n";
#else
static const char *Dtool_TextFont_make_copy_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextFont::is_valid(void) const
 */
static PyObject *Dtool_TextFont_is_valid_29(PyObject *self, PyObject *) {
  TextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextFont::is_valid(void) const
  bool return_value = (*(const TextFont*)local_this).is_valid();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextFont_is_valid_29_comment =
  "C++ Interface:\n"
  "is_valid(TextFont self)\n"
  "\n"
  "/**\n"
  " * Returns true if the font is valid and ready to use, false otherwise.\n"
  " */";
#else
static const char *Dtool_TextFont_is_valid_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextFont::get_line_height(void) const
 */
static PyObject *Dtool_TextFont_get_line_height_31(PyObject *self, PyObject *) {
  TextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextFont::get_line_height(void) const
  PN_stdfloat return_value = (*(const TextFont*)local_this).get_line_height();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextFont_get_line_height_31_comment =
  "C++ Interface:\n"
  "get_line_height(TextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the number of units high each line of text is.\n"
  " */";
#else
static const char *Dtool_TextFont_get_line_height_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextFont::set_line_height(PN_stdfloat line_height)
 */
static PyObject *Dtool_TextFont_set_line_height_32(PyObject *self, PyObject *arg) {
  TextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextFont, (void **)&local_this, "TextFont.set_line_height")) {
    return NULL;
  }
  // 1-inline void TextFont::set_line_height(PN_stdfloat line_height)
  if (PyNumber_Check(arg)) {
    (*local_this).set_line_height((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_line_height(const TextFont self, float line_height)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextFont_set_line_height_32_comment =
  "C++ Interface:\n"
  "set_line_height(const TextFont self, float line_height)\n"
  "\n"
  "/**\n"
  " * Changes the number of units high each line of text is.\n"
  " */";
#else
static const char *Dtool_TextFont_set_line_height_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextFont::get_space_advance(void) const
 */
static PyObject *Dtool_TextFont_get_space_advance_36(PyObject *self, PyObject *) {
  TextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextFont::get_space_advance(void) const
  PN_stdfloat return_value = (*(const TextFont*)local_this).get_space_advance();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextFont_get_space_advance_36_comment =
  "C++ Interface:\n"
  "get_space_advance(TextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the number of units wide a space is.\n"
  " */";
#else
static const char *Dtool_TextFont_get_space_advance_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextFont::set_space_advance(PN_stdfloat space_advance)
 */
static PyObject *Dtool_TextFont_set_space_advance_37(PyObject *self, PyObject *arg) {
  TextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextFont, (void **)&local_this, "TextFont.set_space_advance")) {
    return NULL;
  }
  // 1-inline void TextFont::set_space_advance(PN_stdfloat space_advance)
  if (PyNumber_Check(arg)) {
    (*local_this).set_space_advance((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_space_advance(const TextFont self, float space_advance)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextFont_set_space_advance_37_comment =
  "C++ Interface:\n"
  "set_space_advance(const TextFont self, float space_advance)\n"
  "\n"
  "/**\n"
  " * Changes the number of units wide a space is.\n"
  " */";
#else
static const char *Dtool_TextFont_set_space_advance_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< TextGlyph > TextFont::get_glyph(int character)
 */
static PyObject *Dtool_TextFont_get_glyph_39(PyObject *self, PyObject *arg) {
  TextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextFont, (void **)&local_this, "TextFont.get_glyph")) {
    return NULL;
  }
  // 1-inline ConstPointerTo< TextGlyph > TextFont::get_glyph(int character)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ConstPointerTo< TextGlyph > return_value = (*local_this).get_glyph((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    TextGlyph const *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_TextGlyph, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_glyph(const TextFont self, int character)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextFont_get_glyph_39_comment =
  "C++ Interface:\n"
  "get_glyph(const TextFont self, int character)\n"
  "\n"
  "/**\n"
  " * Gets the glyph associated with the given character code, as well as an\n"
  " * optional scaling parameter that should be applied to the glyph's geometry\n"
  " * and advance parameters.  Returns the glyph on success.  On failure, it may\n"
  " * still return a printable glyph, or it may return NULL.\n"
  " */";
#else
static const char *Dtool_TextFont_get_glyph_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void TextFont::write(ostream &out, int indent_level) const
 */
static PyObject *Dtool_TextFont_write_40(PyObject *self, PyObject *args, PyObject *kwds) {
  TextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void TextFont::write(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "TextFont.write", false, true);
    if (param1_this != NULL) {
      (*(const TextFont*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(TextFont self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextFont_write_40_comment =
  "C++ Interface:\n"
  "write(TextFont self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextFont_write_40_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TextFont::get_class_type(void)
 */
static PyObject *Dtool_TextFont_get_class_type_41(PyObject *, PyObject *) {
  // 1-static TypeHandle TextFont::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(TextFont::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextFont_get_class_type_41_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TextFont_get_class_type_41_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypedReferenceCount *TextFont::upcast_to_TypedReferenceCount(void)
 */
static PyObject *Dtool_TextFont_upcast_to_TypedReferenceCount_21(PyObject *self, PyObject *) {
  TextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextFont, (void **)&local_this, "TextFont.upcast_to_TypedReferenceCount")) {
    return NULL;
  }
  // 1-TypedReferenceCount *TextFont::upcast_to_TypedReferenceCount(void)
  TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextFont_upcast_to_TypedReferenceCount_21_comment =
  "C++ Interface:\n"
  "upcast_to_TypedReferenceCount(const TextFont self)\n"
  "\n"
  "upcast from TextFont to TypedReferenceCount";
#else
static const char *Dtool_TextFont_upcast_to_TypedReferenceCount_21_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Namable *TextFont::upcast_to_Namable(void)
 */
static PyObject *Dtool_TextFont_upcast_to_Namable_24(PyObject *self, PyObject *) {
  TextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextFont, (void **)&local_this, "TextFont.upcast_to_Namable")) {
    return NULL;
  }
  // 1-Namable *TextFont::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TextFont_upcast_to_Namable_24_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const TextFont self)\n"
  "\n"
  "upcast from TextFont to Namable";
#else
static const char *Dtool_TextFont_upcast_to_Namable_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DynamicTextFont *TextFont::downcast_to_DynamicTextFont(void)
 */
static PyObject *Dtool_TextFont_downcast_to_DynamicTextFont_67(PyObject *self, PyObject *) {
  TextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextFont, (void **)&local_this, "TextFont.downcast_to_DynamicTextFont")) {
    return NULL;
  }
  // 1-DynamicTextFont *TextFont::downcast_to_DynamicTextFont(void)
  DynamicTextFont *return_value = (DynamicTextFont *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DynamicTextFont, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextFont_downcast_to_DynamicTextFont_67_comment =
  "C++ Interface:\n"
  "downcast_to_DynamicTextFont(const TextFont self)\n"
  "\n"
  "downcast from TextFont to DynamicTextFont";
#else
static const char *Dtool_TextFont_downcast_to_DynamicTextFont_67_comment = NULL;
#endif

static PyObject *Dtool_TextFont_valid_Getter(PyObject *self, void *) {
  const TextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextFont, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool TextFont::is_valid(void) const
  bool return_value = (*(const TextFont*)local_this).is_valid();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_TextFont_line_height_Getter(PyObject *self, void *) {
  const TextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextFont, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat TextFont::get_line_height(void) const
  PN_stdfloat return_value = (*(const TextFont*)local_this).get_line_height();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextFont_line_height_Setter(PyObject *self, PyObject *arg, void *) {
  TextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextFont, (void **)&local_this, "TextFont.line_height")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete line_height attribute");
    return -1;
  }
  // 1-inline void TextFont::set_line_height(PN_stdfloat line_height)
  if (PyNumber_Check(arg)) {
    (*local_this).set_line_height((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_line_height(const TextFont self, float line_height)\n");
  }
  return -1;
}

static PyObject *Dtool_TextFont_space_advance_Getter(PyObject *self, void *) {
  const TextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextFont, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat TextFont::get_space_advance(void) const
  PN_stdfloat return_value = (*(const TextFont*)local_this).get_space_advance();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextFont_space_advance_Setter(PyObject *self, PyObject *arg, void *) {
  TextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextFont, (void **)&local_this, "TextFont.space_advance")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete space_advance attribute");
    return -1;
  }
  // 1-inline void TextFont::set_space_advance(PN_stdfloat space_advance)
  if (PyNumber_Check(arg)) {
    (*local_this).set_space_advance((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_space_advance(const TextFont self, float space_advance)\n");
  }
  return -1;
}

static int Dtool_Init_TextFont(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TextFont(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TextFont) {
    printf("TextFont ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TextFont *local_this = (TextFont *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TextFont) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TextFont(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TextFont) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (TextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (TextFont*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DynamicTextGlyph
 */
/**
 * Python function wrapper for:
 * inline DynamicTextPage *DynamicTextGlyph::get_page(void) const
 */
static PyObject *Dtool_DynamicTextGlyph_get_page_43(PyObject *self, PyObject *) {
  DynamicTextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextGlyph, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline DynamicTextPage *DynamicTextGlyph::get_page(void) const
  DynamicTextPage *return_value = (*(const DynamicTextGlyph*)local_this).get_page();
  if (return_value != (DynamicTextPage *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (DynamicTextPage *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DynamicTextPage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_page_43_comment =
  "C++ Interface:\n"
  "get_page(DynamicTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the DynamicTextPage that this glyph is on.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_get_page_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DynamicTextGlyph::intersects(int x, int y, int x_size, int y_size) const
 */
static PyObject *Dtool_DynamicTextGlyph_intersects_55(PyObject *self, PyObject *args, PyObject *kwds) {
  DynamicTextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextGlyph, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DynamicTextGlyph::intersects(int x, int y, int x_size, int y_size) const
  int param1;
  int param2;
  int param3;
  int param4;
  static const char *keyword_list[] = {"x", "y", "x_size", "y_size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiii:intersects", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    bool return_value = (*(const DynamicTextGlyph*)local_this).intersects((int)param1, (int)param2, (int)param3, (int)param4);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "intersects(DynamicTextGlyph self, int x, int y, int x_size, int y_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_intersects_55_comment =
  "C++ Interface:\n"
  "intersects(DynamicTextGlyph self, int x, int y, int x_size, int y_size)\n"
  "\n"
  "/**\n"
  " * Returns true if the particular position this glyph has been assigned to\n"
  " * overlaps the rectangle whose top left corner is at x, y and whose size is\n"
  " * given by x_size, y_size, or false otherwise.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_intersects_55_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextGlyph::get_left(void) const
 */
static PyObject *Dtool_DynamicTextGlyph_get_left_56(PyObject *self, PyObject *) {
  DynamicTextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextGlyph, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DynamicTextGlyph::get_left(void) const
  PN_stdfloat return_value = (*(const DynamicTextGlyph*)local_this).get_left();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_left_56_comment =
  "C++ Interface:\n"
  "get_left(DynamicTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the vertex coordinates that can be used when creating a custom text\n"
  " * renderer.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_get_left_56_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextGlyph::get_bottom(void) const
 */
static PyObject *Dtool_DynamicTextGlyph_get_bottom_57(PyObject *self, PyObject *) {
  DynamicTextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextGlyph, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DynamicTextGlyph::get_bottom(void) const
  PN_stdfloat return_value = (*(const DynamicTextGlyph*)local_this).get_bottom();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_bottom_57_comment =
  "C++ Interface:\n"
  "get_bottom(DynamicTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the vertex coordinates that can be used when creating a custom text\n"
  " * renderer.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_get_bottom_57_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextGlyph::get_right(void) const
 */
static PyObject *Dtool_DynamicTextGlyph_get_right_58(PyObject *self, PyObject *) {
  DynamicTextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextGlyph, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DynamicTextGlyph::get_right(void) const
  PN_stdfloat return_value = (*(const DynamicTextGlyph*)local_this).get_right();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_right_58_comment =
  "C++ Interface:\n"
  "get_right(DynamicTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the vertex coordinates that can be used when creating a custom text\n"
  " * renderer.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_get_right_58_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextGlyph::get_top(void) const
 */
static PyObject *Dtool_DynamicTextGlyph_get_top_59(PyObject *self, PyObject *) {
  DynamicTextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextGlyph, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DynamicTextGlyph::get_top(void) const
  PN_stdfloat return_value = (*(const DynamicTextGlyph*)local_this).get_top();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_top_59_comment =
  "C++ Interface:\n"
  "get_top(DynamicTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the vertex coordinates that can be used when creating a custom text\n"
  " * renderer.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_get_top_59_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextGlyph::get_uv_left(void) const
 */
static PyObject *Dtool_DynamicTextGlyph_get_uv_left_60(PyObject *self, PyObject *) {
  DynamicTextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextGlyph, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DynamicTextGlyph::get_uv_left(void) const
  PN_stdfloat return_value = (*(const DynamicTextGlyph*)local_this).get_uv_left();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_uv_left_60_comment =
  "C++ Interface:\n"
  "get_uv_left(DynamicTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the UV coordinates that can be used when creating a custom text\n"
  " * renderer.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_get_uv_left_60_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextGlyph::get_uv_bottom(void) const
 */
static PyObject *Dtool_DynamicTextGlyph_get_uv_bottom_61(PyObject *self, PyObject *) {
  DynamicTextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextGlyph, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DynamicTextGlyph::get_uv_bottom(void) const
  PN_stdfloat return_value = (*(const DynamicTextGlyph*)local_this).get_uv_bottom();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_uv_bottom_61_comment =
  "C++ Interface:\n"
  "get_uv_bottom(DynamicTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the UV coordinates that can be used when creating a custom text\n"
  " * renderer.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_get_uv_bottom_61_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextGlyph::get_uv_right(void) const
 */
static PyObject *Dtool_DynamicTextGlyph_get_uv_right_62(PyObject *self, PyObject *) {
  DynamicTextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextGlyph, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DynamicTextGlyph::get_uv_right(void) const
  PN_stdfloat return_value = (*(const DynamicTextGlyph*)local_this).get_uv_right();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_uv_right_62_comment =
  "C++ Interface:\n"
  "get_uv_right(DynamicTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the UV coordinates that can be used when creating a custom text\n"
  " * renderer.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_get_uv_right_62_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextGlyph::get_uv_top(void) const
 */
static PyObject *Dtool_DynamicTextGlyph_get_uv_top_63(PyObject *self, PyObject *) {
  DynamicTextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextGlyph, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DynamicTextGlyph::get_uv_top(void) const
  PN_stdfloat return_value = (*(const DynamicTextGlyph*)local_this).get_uv_top();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_uv_top_63_comment =
  "C++ Interface:\n"
  "get_uv_top(DynamicTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the UV coordinates that can be used when creating a custom text\n"
  " * renderer.\n"
  " */";
#else
static const char *Dtool_DynamicTextGlyph_get_uv_top_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DynamicTextGlyph::get_class_type(void)
 */
static PyObject *Dtool_DynamicTextGlyph_get_class_type_64(PyObject *, PyObject *) {
  // 1-static TypeHandle DynamicTextGlyph::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(DynamicTextGlyph::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextGlyph_get_class_type_64_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DynamicTextGlyph_get_class_type_64_comment = NULL;
#endif

static PyObject *Dtool_DynamicTextGlyph_page_Getter(PyObject *self, void *) {
  const DynamicTextGlyph *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextGlyph, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline DynamicTextPage *DynamicTextGlyph::get_page(void) const
  DynamicTextPage *return_value = (*(const DynamicTextGlyph*)local_this).get_page();
  if (return_value != (DynamicTextPage *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (DynamicTextPage *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DynamicTextPage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_Init_DynamicTextGlyph(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DynamicTextGlyph(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DynamicTextGlyph) {
    printf("DynamicTextGlyph ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DynamicTextGlyph *local_this = (DynamicTextGlyph *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DynamicTextGlyph) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(TextGlyph *) local_this;
  }
  if (requested_type == Dtool_Ptr_TextGlyph) {
    return (TextGlyph *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(TextGlyph *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(TextGlyph *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DynamicTextGlyph(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DynamicTextGlyph) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (DynamicTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_TextGlyph) {
    TextGlyph* other_this = (TextGlyph*)from_this;
    return (DynamicTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DynamicTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (DynamicTextGlyph*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DynamicTextPage
 */
/**
 * Python function wrapper for:
 * inline LVecBase2i const &DynamicTextPage::get_size(void) const
 */
static PyObject *Dtool_DynamicTextPage_get_size_48(PyObject *self, PyObject *) {
  DynamicTextPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextPage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2i const &DynamicTextPage::get_size(void) const
  LVecBase2i const *return_value = &((*(const DynamicTextPage*)local_this).get_size());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextPage_get_size_48_comment =
  "C++ Interface:\n"
  "get_size(DynamicTextPage self)\n"
  "\n"
  "/**\n"
  " * Returns the size of the page (texture), in pixels.\n"
  " */";
#else
static const char *Dtool_DynamicTextPage_get_size_48_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DynamicTextPage::get_x_size(void) const
 */
static PyObject *Dtool_DynamicTextPage_get_x_size_49(PyObject *self, PyObject *) {
  DynamicTextPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextPage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DynamicTextPage::get_x_size(void) const
  int return_value = (*(const DynamicTextPage*)local_this).get_x_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextPage_get_x_size_49_comment =
  "C++ Interface:\n"
  "get_x_size(DynamicTextPage self)\n"
  "\n"
  "/**\n"
  " * Returns the x size of the page (texture), in pixels.\n"
  " */";
#else
static const char *Dtool_DynamicTextPage_get_x_size_49_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DynamicTextPage::get_y_size(void) const
 */
static PyObject *Dtool_DynamicTextPage_get_y_size_50(PyObject *self, PyObject *) {
  DynamicTextPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextPage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DynamicTextPage::get_y_size(void) const
  int return_value = (*(const DynamicTextPage*)local_this).get_y_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextPage_get_y_size_50_comment =
  "C++ Interface:\n"
  "get_y_size(DynamicTextPage self)\n"
  "\n"
  "/**\n"
  " * Returns the y size of the page (texture), in pixels.\n"
  " */";
#else
static const char *Dtool_DynamicTextPage_get_y_size_50_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DynamicTextPage::is_empty(void) const
 */
static PyObject *Dtool_DynamicTextPage_is_empty_51(PyObject *self, PyObject *) {
  DynamicTextPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextPage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DynamicTextPage::is_empty(void) const
  bool return_value = (*(const DynamicTextPage*)local_this).is_empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextPage_is_empty_51_comment =
  "C++ Interface:\n"
  "is_empty(DynamicTextPage self)\n"
  "\n"
  "/**\n"
  " * Returns true if the page has no glyphs, false otherwise.\n"
  " */";
#else
static const char *Dtool_DynamicTextPage_is_empty_51_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DynamicTextPage::get_class_type(void)
 */
static PyObject *Dtool_DynamicTextPage_get_class_type_52(PyObject *, PyObject *) {
  // 1-static TypeHandle DynamicTextPage::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(DynamicTextPage::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextPage_get_class_type_52_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DynamicTextPage_get_class_type_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DynamicTextPage::DynamicTextPage(DynamicTextPage const &) = default
 */
static int Dtool_Init_DynamicTextPage(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "DynamicTextPage() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline DynamicTextPage::DynamicTextPage(DynamicTextPage const &) = default
  DynamicTextPage const *arg_this = (DynamicTextPage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DynamicTextPage, 0, "DynamicTextPage.DynamicTextPage", true, true);
  if (arg_this != NULL) {
    DynamicTextPage *return_value = new DynamicTextPage(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DynamicTextPage, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DynamicTextPage(const DynamicTextPage param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DynamicTextPage(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DynamicTextPage) {
    printf("DynamicTextPage ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DynamicTextPage *local_this = (DynamicTextPage *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DynamicTextPage) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_Texture) {
    return (Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(Texture *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(Texture *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DynamicTextPage(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DynamicTextPage) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (DynamicTextPage*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (DynamicTextPage*)other_this;
  }
  if (from_type == Dtool_Ptr_Texture) {
    Texture* other_this = (Texture*)from_this;
    return (DynamicTextPage*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DynamicTextPage*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (DynamicTextPage*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (DynamicTextPage*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DynamicTextFont
 */
/**
 * Python function wrapper for:
 * virtual PointerTo< TextFont > DynamicTextFont::make_copy(void) const
 */
static PyObject *Dtool_DynamicTextFont_make_copy_73(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual PointerTo< TextFont > DynamicTextFont::make_copy(void) const
  PointerTo< TextFont > return_value = (*(const DynamicTextFont*)local_this).make_copy();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  TextFont *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_TextFont, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_make_copy_73_comment =
  "C++ Interface:\n"
  "make_copy(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns a new copy of the same font.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_make_copy_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &DynamicTextFont::get_name(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_name_74(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &DynamicTextFont::get_name(void) const
  std::string const &return_value = (*(const DynamicTextFont*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_name_74_comment =
  "C++ Interface:\n"
  "get_name(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Disambiguates the get_name() method between that inherited from TextFont\n"
  " * and that inherited from FreetypeFont.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_name_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DynamicTextFont::set_point_size(PN_stdfloat point_size)
 */
static PyObject *Dtool_DynamicTextFont_set_point_size_75(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_point_size")) {
    return NULL;
  }
  // 1-inline bool DynamicTextFont::set_point_size(PN_stdfloat point_size)
  if (PyNumber_Check(arg)) {
    bool return_value = (*local_this).set_point_size((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point_size(const DynamicTextFont self, float point_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_point_size_75_comment =
  "C++ Interface:\n"
  "set_point_size(const DynamicTextFont self, float point_size)\n"
  "\n"
  "/**\n"
  " * Sets the point size of the font.  This controls the apparent size of the\n"
  " * font onscreen.  By convention, a 10 point font is about 1 screen unit high.\n"
  " *\n"
  " * This should only be called before any characters have been requested out of\n"
  " * the font, or immediately after calling clear().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_point_size_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextFont::get_point_size(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_point_size_76(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DynamicTextFont::get_point_size(void) const
  PN_stdfloat return_value = (*(const DynamicTextFont*)local_this).get_point_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_point_size_76_comment =
  "C++ Interface:\n"
  "get_point_size(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the point size of the font.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_point_size_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DynamicTextFont::set_pixels_per_unit(PN_stdfloat pixels_per_unit)
 */
static PyObject *Dtool_DynamicTextFont_set_pixels_per_unit_78(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_pixels_per_unit")) {
    return NULL;
  }
  // 1-inline bool DynamicTextFont::set_pixels_per_unit(PN_stdfloat pixels_per_unit)
  if (PyNumber_Check(arg)) {
    bool return_value = (*local_this).set_pixels_per_unit((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pixels_per_unit(const DynamicTextFont self, float pixels_per_unit)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_pixels_per_unit_78_comment =
  "C++ Interface:\n"
  "set_pixels_per_unit(const DynamicTextFont self, float pixels_per_unit)\n"
  "\n"
  "/**\n"
  " * Set the resolution of the texture map, and hence the clarity of the\n"
  " * resulting font.  This sets the number of pixels in the texture map that are\n"
  " * used for each onscreen unit.\n"
  " *\n"
  " * Setting this number larger results in an easier to read font, but at the\n"
  " * cost of more texture memory.\n"
  " *\n"
  " * This should only be called before any characters have been requested out of\n"
  " * the font, or immediately after calling clear().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_pixels_per_unit_78_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextFont::get_pixels_per_unit(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_pixels_per_unit_79(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DynamicTextFont::get_pixels_per_unit(void) const
  PN_stdfloat return_value = (*(const DynamicTextFont*)local_this).get_pixels_per_unit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_pixels_per_unit_79_comment =
  "C++ Interface:\n"
  "get_pixels_per_unit(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the resolution of the texture map.  See set_pixels_per_unit().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_pixels_per_unit_79_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DynamicTextFont::set_scale_factor(PN_stdfloat scale_factor)
 */
static PyObject *Dtool_DynamicTextFont_set_scale_factor_81(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_scale_factor")) {
    return NULL;
  }
  // 1-inline bool DynamicTextFont::set_scale_factor(PN_stdfloat scale_factor)
  if (PyNumber_Check(arg)) {
    bool return_value = (*local_this).set_scale_factor((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale_factor(const DynamicTextFont self, float scale_factor)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_scale_factor_81_comment =
  "C++ Interface:\n"
  "set_scale_factor(const DynamicTextFont self, float scale_factor)\n"
  "\n"
  "/**\n"
  " * Sets the factor by which the font is rendered larger by the FreeType\n"
  " * library before being filtered down to its actual size in the texture as\n"
  " * specified by set_pixels_per_unit().  This may be set to a number larger\n"
  " * than 1.0 to improve the font's antialiasing (since FreeType doesn't really\n"
  " * do a swell job of antialiasing by itself).  There is some performance\n"
  " * implication for setting this different than 1.0, but it is probably small.\n"
  " *\n"
  " * This should only be called before any characters have been requested out of\n"
  " * the font, or immediately after calling clear().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_scale_factor_81_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextFont::get_scale_factor(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_scale_factor_82(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DynamicTextFont::get_scale_factor(void) const
  PN_stdfloat return_value = (*(const DynamicTextFont*)local_this).get_scale_factor();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_scale_factor_82_comment =
  "C++ Interface:\n"
  "get_scale_factor(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the antialiasing scale factor.  See set_scale_factor().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_scale_factor_82_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_native_antialias(bool native_antialias)
 */
static PyObject *Dtool_DynamicTextFont_set_native_antialias_84(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_native_antialias")) {
    return NULL;
  }
  // 1-inline void DynamicTextFont::set_native_antialias(bool native_antialias)
  (*local_this).set_native_antialias((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_native_antialias(const DynamicTextFont self, bool native_antialias)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_native_antialias_84_comment =
  "C++ Interface:\n"
  "set_native_antialias(const DynamicTextFont self, bool native_antialias)\n"
  "\n"
  "/**\n"
  " * Sets whether the Freetype library's built-in antialias mode is enabled.\n"
  " * There are two unrelated ways to achieve antialiasing: with Freetype's\n"
  " * native antialias mode, and with the use of a scale_factor greater than one.\n"
  " * By default, both modes are enabled.\n"
  " *\n"
  " * At low resolutions, some fonts may do better with one mode or the other.\n"
  " * In general, Freetype's native antialiasing will produce less blurry\n"
  " * results, but may introduce more artifacts.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_native_antialias_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DynamicTextFont::get_native_antialias(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_native_antialias_85(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DynamicTextFont::get_native_antialias(void) const
  bool return_value = (*(const DynamicTextFont*)local_this).get_native_antialias();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_native_antialias_85_comment =
  "C++ Interface:\n"
  "get_native_antialias(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns whether Freetype's built-in antialias mode is enabled.  See\n"
  " * set_native_antialias().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_native_antialias_85_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DynamicTextFont::get_font_pixel_size(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_font_pixel_size_87(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DynamicTextFont::get_font_pixel_size(void) const
  int return_value = (*(const DynamicTextFont*)local_this).get_font_pixel_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_font_pixel_size_87_comment =
  "C++ Interface:\n"
  "get_font_pixel_size(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * This is used to report whether the requested pixel size is being only\n"
  " * approximated by a fixed-pixel-size font.  This returns 0 in the normal\n"
  " * case, in which a scalable font is used, or the fixed-pixel-size font has\n"
  " * exactly the requested pixel size.\n"
  " *\n"
  " * If this returns non-zero, it is the pixel size of the font that we are\n"
  " * using to approximate our desired size.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_font_pixel_size_87_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextFont::get_line_height(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_line_height_89(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DynamicTextFont::get_line_height(void) const
  PN_stdfloat return_value = (*(const DynamicTextFont*)local_this).get_line_height();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_line_height_89_comment =
  "C++ Interface:\n"
  "get_line_height(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the number of units high each line of text is.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_line_height_89_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextFont::get_space_advance(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_space_advance_90(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DynamicTextFont::get_space_advance(void) const
  PN_stdfloat return_value = (*(const DynamicTextFont*)local_this).get_space_advance();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_space_advance_90_comment =
  "C++ Interface:\n"
  "get_space_advance(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the number of units wide a space is.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_space_advance_90_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_texture_margin(int texture_margin)
 */
static PyObject *Dtool_DynamicTextFont_set_texture_margin_91(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_texture_margin")) {
    return NULL;
  }
  // 1-inline void DynamicTextFont::set_texture_margin(int texture_margin)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_texture_margin((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture_margin(const DynamicTextFont self, int texture_margin)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_texture_margin_91_comment =
  "C++ Interface:\n"
  "set_texture_margin(const DynamicTextFont self, int texture_margin)\n"
  "\n"
  "/**\n"
  " * Sets the number of pixels of padding that is added around the border of\n"
  " * each glyph before adding it to the texture map.  This reduces the bleed in\n"
  " * from neighboring glyphs in the texture map.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_texture_margin_91_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DynamicTextFont::get_texture_margin(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_texture_margin_92(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DynamicTextFont::get_texture_margin(void) const
  int return_value = (*(const DynamicTextFont*)local_this).get_texture_margin();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_texture_margin_92_comment =
  "C++ Interface:\n"
  "get_texture_margin(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the number of pixels of padding that is added around the border of\n"
  " * each glyph in the texture map.  See set_texture_margin().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_texture_margin_92_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_poly_margin(PN_stdfloat poly_margin)
 */
static PyObject *Dtool_DynamicTextFont_set_poly_margin_93(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_poly_margin")) {
    return NULL;
  }
  // 1-inline void DynamicTextFont::set_poly_margin(PN_stdfloat poly_margin)
  if (PyNumber_Check(arg)) {
    (*local_this).set_poly_margin((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_poly_margin(const DynamicTextFont self, float poly_margin)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_poly_margin_93_comment =
  "C++ Interface:\n"
  "set_poly_margin(const DynamicTextFont self, float poly_margin)\n"
  "\n"
  "/**\n"
  " * Sets the number of pixels of padding that is included around each glyph in\n"
  " * the generated polygons.  This helps prevent the edges of the glyphs from\n"
  " * being cut off at small minifications.  It is not related to the amount of\n"
  " * extra pixels reserved in the texture map (but it should be set somewhat\n"
  " * smaller than this number, which is controlled by set_texture_margin(), to\n"
  " * prevent bleed-in from neighboring letters in the texture).\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_poly_margin_93_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextFont::get_poly_margin(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_poly_margin_94(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DynamicTextFont::get_poly_margin(void) const
  PN_stdfloat return_value = (*(const DynamicTextFont*)local_this).get_poly_margin();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_poly_margin_94_comment =
  "C++ Interface:\n"
  "get_poly_margin(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the number of pixels of padding that is included around each glyph\n"
  " * in the generated polygons.  See set_poly_margin().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_poly_margin_94_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_page_size(LVecBase2i const &page_size)
 * inline void DynamicTextFont::set_page_size(int x_size, int y_size)
 */
static PyObject *Dtool_DynamicTextFont_set_page_size_97(PyObject *self, PyObject *args, PyObject *kwds) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_page_size")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "page_size");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'page_size' (pos 1) not found");
      }
      // 1-inline void DynamicTextFont::set_page_size(LVecBase2i const &page_size)
      LVecBase2i arg_local;
      LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "DynamicTextFont.set_page_size", "LVecBase2i");
      }
      (*local_this).set_page_size(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 2:
    {
      // 1-inline void DynamicTextFont::set_page_size(int x_size, int y_size)
      int param1;
      int param2;
      static const char *keyword_list[] = {"x_size", "y_size", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_page_size", (char **)keyword_list, &param1, &param2)) {
        (*local_this).set_page_size((int)param1, (int)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_page_size() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_page_size(const DynamicTextFont self, const LVecBase2i page_size)\n"
      "set_page_size(const DynamicTextFont self, int x_size, int y_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_page_size_97_comment =
  "C++ Interface:\n"
  "set_page_size(const DynamicTextFont self, const LVecBase2i page_size)\n"
  "set_page_size(const DynamicTextFont self, int x_size, int y_size)\n"
  "\n"
  "/**\n"
  " * Sets the x, y size of the textures that are created for the\n"
  " * DynamicTextFont.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the x, y size of the textures that are created for the\n"
  " * DynamicTextFont.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_page_size_97_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i const &DynamicTextFont::get_page_size(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_page_size_98(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2i const &DynamicTextFont::get_page_size(void) const
  LVecBase2i const *return_value = &((*(const DynamicTextFont*)local_this).get_page_size());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_page_size_98_comment =
  "C++ Interface:\n"
  "get_page_size(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the size of the textures that are created for the DynamicTextFont.\n"
  " * See set_page_size().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_page_size_98_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DynamicTextFont::get_page_x_size(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_page_x_size_99(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DynamicTextFont::get_page_x_size(void) const
  int return_value = (*(const DynamicTextFont*)local_this).get_page_x_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_page_x_size_99_comment =
  "C++ Interface:\n"
  "get_page_x_size(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the x size of the textures that are created for the\n"
  " * DynamicTextFont.  See set_page_size().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_page_x_size_99_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DynamicTextFont::get_page_y_size(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_page_y_size_100(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DynamicTextFont::get_page_y_size(void) const
  int return_value = (*(const DynamicTextFont*)local_this).get_page_y_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_page_y_size_100_comment =
  "C++ Interface:\n"
  "get_page_y_size(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the y size of the textures that are created for the\n"
  " * DynamicTextFont.  See set_page_size().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_page_y_size_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_minfilter(SamplerState::FilterType filter)
 */
static PyObject *Dtool_DynamicTextFont_set_minfilter_104(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_minfilter")) {
    return NULL;
  }
  // 1-inline void DynamicTextFont::set_minfilter(SamplerState::FilterType filter)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_minfilter((SamplerState::FilterType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_minfilter(const DynamicTextFont self, int filter)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_minfilter_104_comment =
  "C++ Interface:\n"
  "set_minfilter(const DynamicTextFont self, int filter)\n"
  "\n"
  "/**\n"
  " * Sets the filter type used when minimizing the textures created for this\n"
  " * font.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_minfilter_104_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline SamplerState::FilterType DynamicTextFont::get_minfilter(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_minfilter_105(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline SamplerState::FilterType DynamicTextFont::get_minfilter(void) const
  SamplerState::FilterType return_value = (*(const DynamicTextFont*)local_this).get_minfilter();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_minfilter_105_comment =
  "C++ Interface:\n"
  "get_minfilter(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the filter type used when minimizing the textures created for this\n"
  " * font.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_minfilter_105_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_magfilter(SamplerState::FilterType filter)
 */
static PyObject *Dtool_DynamicTextFont_set_magfilter_106(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_magfilter")) {
    return NULL;
  }
  // 1-inline void DynamicTextFont::set_magfilter(SamplerState::FilterType filter)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_magfilter((SamplerState::FilterType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_magfilter(const DynamicTextFont self, int filter)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_magfilter_106_comment =
  "C++ Interface:\n"
  "set_magfilter(const DynamicTextFont self, int filter)\n"
  "\n"
  "/**\n"
  " * Sets the filter type used when enlarging the textures created for this\n"
  " * font.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_magfilter_106_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline SamplerState::FilterType DynamicTextFont::get_magfilter(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_magfilter_107(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline SamplerState::FilterType DynamicTextFont::get_magfilter(void) const
  SamplerState::FilterType return_value = (*(const DynamicTextFont*)local_this).get_magfilter();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_magfilter_107_comment =
  "C++ Interface:\n"
  "get_magfilter(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the filter type used when enlarging the textures created for this\n"
  " * font.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_magfilter_107_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_anisotropic_degree(int anisotropic_degree)
 */
static PyObject *Dtool_DynamicTextFont_set_anisotropic_degree_108(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_anisotropic_degree")) {
    return NULL;
  }
  // 1-inline void DynamicTextFont::set_anisotropic_degree(int anisotropic_degree)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_anisotropic_degree((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anisotropic_degree(const DynamicTextFont self, int anisotropic_degree)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_anisotropic_degree_108_comment =
  "C++ Interface:\n"
  "set_anisotropic_degree(const DynamicTextFont self, int anisotropic_degree)\n"
  "\n"
  "/**\n"
  " * Enables or disables anisotropic filtering on the textures created for this\n"
  " * font.  The default value is specified by the text-anisotropic-degree\n"
  " * variable.  See Texture::set_anisotropic_degree().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_anisotropic_degree_108_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DynamicTextFont::get_anisotropic_degree(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_anisotropic_degree_109(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DynamicTextFont::get_anisotropic_degree(void) const
  int return_value = (*(const DynamicTextFont*)local_this).get_anisotropic_degree();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_anisotropic_degree_109_comment =
  "C++ Interface:\n"
  "get_anisotropic_degree(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the current anisotropic degree for textures created for this font.\n"
  " * See set_anisotropic_degree().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_anisotropic_degree_109_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_render_mode(TextFont::RenderMode render_mode)
 */
static PyObject *Dtool_DynamicTextFont_set_render_mode_115(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_render_mode")) {
    return NULL;
  }
  // 1-inline void DynamicTextFont::set_render_mode(TextFont::RenderMode render_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_render_mode((TextFont::RenderMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_render_mode(const DynamicTextFont self, int render_mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_render_mode_115_comment =
  "C++ Interface:\n"
  "set_render_mode(const DynamicTextFont self, int render_mode)\n"
  "\n"
  "/**\n"
  " * Specifies the way the glyphs on this particular font are generated.  The\n"
  " * default is RM_texture, which is the only mode supported for bitmap fonts.\n"
  " * Other modes are possible for most modern fonts.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_render_mode_115_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TextFont::RenderMode DynamicTextFont::get_render_mode(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_render_mode_116(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline TextFont::RenderMode DynamicTextFont::get_render_mode(void) const
  TextFont::RenderMode return_value = (*(const DynamicTextFont*)local_this).get_render_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_render_mode_116_comment =
  "C++ Interface:\n"
  "get_render_mode(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the way the glyphs on this particular font are generated.  See\n"
  " * set_render_mode().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_render_mode_116_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_fg(LColor const &fg)
 */
static PyObject *Dtool_DynamicTextFont_set_fg_118(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_fg")) {
    return NULL;
  }
  // 1-inline void DynamicTextFont::set_fg(LColor const &fg)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DynamicTextFont.set_fg", "LVecBase4f");
  }
  (*local_this).set_fg(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fg(const DynamicTextFont self, const LVecBase4f fg)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_fg_118_comment =
  "C++ Interface:\n"
  "set_fg(const DynamicTextFont self, const LVecBase4f fg)\n"
  "\n"
  "/**\n"
  " * Changes the color of the foreground pixels of the font as they are rendered\n"
  " * into the font texture.  The default is (1, 1, 1, 1), or opaque white, which\n"
  " * allows text created with the font to be colored individually.  Normally,\n"
  " * you would not change this unless you really need a particular color effect\n"
  " * to appear in the font itself.\n"
  " *\n"
  " * This should only be called before any characters have been requested out of\n"
  " * the font, or immediately after calling clear().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_fg_118_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &DynamicTextFont::get_fg(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_fg_119(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor const &DynamicTextFont::get_fg(void) const
  LColor const *return_value = &((*(const DynamicTextFont*)local_this).get_fg());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_fg_119_comment =
  "C++ Interface:\n"
  "get_fg(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the color of the foreground pixels of the font as they are rendered\n"
  " * into the font texture.  See set_fg().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_fg_119_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_bg(LColor const &bg)
 */
static PyObject *Dtool_DynamicTextFont_set_bg_120(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_bg")) {
    return NULL;
  }
  // 1-inline void DynamicTextFont::set_bg(LColor const &bg)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DynamicTextFont.set_bg", "LVecBase4f");
  }
  (*local_this).set_bg(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bg(const DynamicTextFont self, const LVecBase4f bg)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_bg_120_comment =
  "C++ Interface:\n"
  "set_bg(const DynamicTextFont self, const LVecBase4f bg)\n"
  "\n"
  "/**\n"
  " * Changes the color of the background pixels of the font as they are rendered\n"
  " * into the font texture.  The default is (1, 1, 1, 0), or transparent white,\n"
  " * which allows text created with the font to be colored individually.  (Note\n"
  " * that it should not generally be (0, 0, 0, 0), which would tend to bleed\n"
  " * into the foreground color, unless you have also specified a outline color\n"
  " * of (0, 0, 0, 1)) .\n"
  " *\n"
  " * Normally, you would not change this unless you really need a particular\n"
  " * color effect to appear in the font itself.\n"
  " *\n"
  " * This should only be called before any characters have been requested out of\n"
  " * the font, or immediately after calling clear().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_bg_120_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &DynamicTextFont::get_bg(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_bg_121(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor const &DynamicTextFont::get_bg(void) const
  LColor const *return_value = &((*(const DynamicTextFont*)local_this).get_bg());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_bg_121_comment =
  "C++ Interface:\n"
  "get_bg(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the color of the background pixels of the font as they are rendered\n"
  " * into the font texture.  See set_bg().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_bg_121_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DynamicTextFont::set_outline(LColor const &outline_color, PN_stdfloat outline_width, PN_stdfloat outline_feather)
 */
static PyObject *Dtool_DynamicTextFont_set_outline_122(PyObject *self, PyObject *args, PyObject *kwds) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.set_outline")) {
    return NULL;
  }
  // 1-inline void DynamicTextFont::set_outline(LColor const &outline_color, PN_stdfloat outline_width, PN_stdfloat outline_feather)
  PyObject *param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"outline_color", "outline_width", "outline_feather", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:set_outline", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase4f param1_local;
    LColor const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "DynamicTextFont.set_outline", "LVecBase4f");
    }
    (*local_this).set_outline(*param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_outline(const DynamicTextFont self, const LVecBase4f outline_color, float outline_width, float outline_feather)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_set_outline_122_comment =
  "C++ Interface:\n"
  "set_outline(const DynamicTextFont self, const LVecBase4f outline_color, float outline_width, float outline_feather)\n"
  "\n"
  "/**\n"
  " * Sets up the font to have an outline around each font letter.  This is\n"
  " * achieved via a Gaussian post-process as each letter is generated; there is\n"
  " * some runtime cost for this effect, but it is minimal as each letter is\n"
  " * normally generated only once and then cached.\n"
  " *\n"
  " * The color is the desired color of the outline, width is the number of\n"
  " * points beyond the letter that the outline extends (a typical font is 10\n"
  " * points high), and feather is a number in the range 0.0 .. 1.0 that controls\n"
  " * the softness of the outline.  Set the width to 0.0 to disable the outline.\n"
  " *\n"
  " * This should only be called before any characters have been requested out of\n"
  " * the font, or immediately after calling clear().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_set_outline_122_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &DynamicTextFont::get_outline_color(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_outline_color_123(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor const &DynamicTextFont::get_outline_color(void) const
  LColor const *return_value = &((*(const DynamicTextFont*)local_this).get_outline_color());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_outline_color_123_comment =
  "C++ Interface:\n"
  "get_outline_color(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the color of the outline pixels of the font as they are rendered\n"
  " * into the font texture.  See set_outline().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_outline_color_123_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextFont::get_outline_width(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_outline_width_124(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DynamicTextFont::get_outline_width(void) const
  PN_stdfloat return_value = (*(const DynamicTextFont*)local_this).get_outline_width();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_outline_width_124_comment =
  "C++ Interface:\n"
  "get_outline_width(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the width of the outline pixels of the font, as the number of\n"
  " * points beyond each letter.  See set_outline().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_outline_width_124_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DynamicTextFont::get_outline_feather(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_outline_feather_125(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DynamicTextFont::get_outline_feather(void) const
  PN_stdfloat return_value = (*(const DynamicTextFont*)local_this).get_outline_feather();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_outline_feather_125_comment =
  "C++ Interface:\n"
  "get_outline_feather(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the softness of the outline pixels of the font, as a value in the\n"
  " * range 0.0 to 1.0. See set_outline().\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_outline_feather_125_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Texture::Format DynamicTextFont::get_tex_format(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_tex_format_126(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Texture::Format DynamicTextFont::get_tex_format(void) const
  Texture::Format return_value = (*(const DynamicTextFont*)local_this).get_tex_format();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_tex_format_126_comment =
  "C++ Interface:\n"
  "get_tex_format(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the texture format used to render the individual pages.  This is\n"
  " * set automatically according to the colors selected.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_tex_format_126_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DynamicTextFont::get_num_pages(void) const
 */
static PyObject *Dtool_DynamicTextFont_get_num_pages_135(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DynamicTextFont::get_num_pages(void) const
  int return_value = (*(const DynamicTextFont*)local_this).get_num_pages();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_num_pages_135_comment =
  "C++ Interface:\n"
  "get_num_pages(DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Returns the number of pages associated with the font.  Initially, the font\n"
  " * has zero pages; when the first piece of text is rendered with the font, it\n"
  " * will add additional pages as needed.  Each page is a Texture object that\n"
  " * contains the images for each of the glyphs currently in use somewhere.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_num_pages_135_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DynamicTextPage *DynamicTextFont::get_page(int n) const
 */
static PyObject *Dtool_DynamicTextFont_get_page_136(PyObject *self, PyObject *arg) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-DynamicTextPage *DynamicTextFont::get_page(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DynamicTextPage *return_value = (*(const DynamicTextFont*)local_this).get_page((int)arg_val);
    if (return_value != (DynamicTextPage *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (DynamicTextPage *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DynamicTextPage, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_page(DynamicTextFont self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_page_136_comment =
  "C++ Interface:\n"
  "get_page(DynamicTextFont self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth page associated with the font.  Initially, the font has\n"
  " * zero pages; when the first piece of text is rendered with the font, it will\n"
  " * add additional pages as needed.  Each page is a Texture object that\n"
  " * contains the images for each of the glyphs currently in use somewhere.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_get_page_136_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DynamicTextFont::garbage_collect(void)
 */
static PyObject *Dtool_DynamicTextFont_garbage_collect_139(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.garbage_collect")) {
    return NULL;
  }
  // 1-int DynamicTextFont::garbage_collect(void)
  int return_value = (*local_this).garbage_collect();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_garbage_collect_139_comment =
  "C++ Interface:\n"
  "garbage_collect(const DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Removes all of the glyphs from the font that are no longer being used by\n"
  " * any Geoms.  Returns the number of glyphs removed.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_garbage_collect_139_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DynamicTextFont::clear(void)
 */
static PyObject *Dtool_DynamicTextFont_clear_140(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.clear")) {
    return NULL;
  }
  // 1-void DynamicTextFont::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_clear_140_comment =
  "C++ Interface:\n"
  "clear(const DynamicTextFont self)\n"
  "\n"
  "/**\n"
  " * Drops all the glyphs out of the cache and frees any association with any\n"
  " * previously-generated pages.\n"
  " *\n"
  " * Calling this frequently can result in wasted texture memory, as any\n"
  " * previously rendered text will still keep a pointer to the old, previously-\n"
  " * generated pages.  As long as the previously rendered text remains around,\n"
  " * the old pages will also remain around.\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_clear_140_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void DynamicTextFont::write(ostream &out, int indent_level) const
 */
static PyObject *Dtool_DynamicTextFont_write_141(PyObject *self, PyObject *args, PyObject *kwds) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void DynamicTextFont::write(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "DynamicTextFont.write", false, true);
    if (param1_this != NULL) {
      (*(const DynamicTextFont*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(DynamicTextFont self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_write_141_comment =
  "C++ Interface:\n"
  "write(DynamicTextFont self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DynamicTextFont_write_141_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DynamicTextFont::get_class_type(void)
 */
static PyObject *Dtool_DynamicTextFont_get_class_type_142(PyObject *, PyObject *) {
  // 1-static TypeHandle DynamicTextFont::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(DynamicTextFont::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_get_class_type_142_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DynamicTextFont_get_class_type_142_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TextFont *DynamicTextFont::upcast_to_TextFont(void)
 */
static PyObject *Dtool_DynamicTextFont_upcast_to_TextFont_66(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.upcast_to_TextFont")) {
    return NULL;
  }
  // 1-TextFont *DynamicTextFont::upcast_to_TextFont(void)
  TextFont *return_value = (TextFont *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextFont, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_upcast_to_TextFont_66_comment =
  "C++ Interface:\n"
  "upcast_to_TextFont(const DynamicTextFont self)\n"
  "\n"
  "upcast from DynamicTextFont to TextFont";
#else
static const char *Dtool_DynamicTextFont_upcast_to_TextFont_66_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * FreetypeFont *DynamicTextFont::upcast_to_FreetypeFont(void)
 */
static PyObject *Dtool_DynamicTextFont_upcast_to_FreetypeFont_69(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.upcast_to_FreetypeFont")) {
    return NULL;
  }
  // 1-FreetypeFont *DynamicTextFont::upcast_to_FreetypeFont(void)
  FreetypeFont *return_value = (FreetypeFont *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_FreetypeFont, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DynamicTextFont_upcast_to_FreetypeFont_69_comment =
  "C++ Interface:\n"
  "upcast_to_FreetypeFont(const DynamicTextFont self)\n"
  "\n"
  "upcast from DynamicTextFont to FreetypeFont";
#else
static const char *Dtool_DynamicTextFont_upcast_to_FreetypeFont_69_comment = NULL;
#endif

static PyObject *Dtool_DynamicTextFont_point_size_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat DynamicTextFont::get_point_size(void) const
  PN_stdfloat return_value = (*(const DynamicTextFont*)local_this).get_point_size();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_point_size_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.point_size")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete point_size attribute");
    return -1;
  }
  // 1-inline bool DynamicTextFont::set_point_size(PN_stdfloat point_size)
  if (PyNumber_Check(arg)) {
    bool return_value = (*local_this).set_point_size((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (return_value) ? 0 : -1;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_point_size(const DynamicTextFont self, float point_size)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_pixels_per_unit_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat DynamicTextFont::get_pixels_per_unit(void) const
  PN_stdfloat return_value = (*(const DynamicTextFont*)local_this).get_pixels_per_unit();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_pixels_per_unit_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.pixels_per_unit")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete pixels_per_unit attribute");
    return -1;
  }
  // 1-inline bool DynamicTextFont::set_pixels_per_unit(PN_stdfloat pixels_per_unit)
  if (PyNumber_Check(arg)) {
    bool return_value = (*local_this).set_pixels_per_unit((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (return_value) ? 0 : -1;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_pixels_per_unit(const DynamicTextFont self, float pixels_per_unit)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_scale_factor_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat DynamicTextFont::get_scale_factor(void) const
  PN_stdfloat return_value = (*(const DynamicTextFont*)local_this).get_scale_factor();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_scale_factor_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.scale_factor")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete scale_factor attribute");
    return -1;
  }
  // 1-inline bool DynamicTextFont::set_scale_factor(PN_stdfloat scale_factor)
  if (PyNumber_Check(arg)) {
    bool return_value = (*local_this).set_scale_factor((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (return_value) ? 0 : -1;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_scale_factor(const DynamicTextFont self, float scale_factor)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_native_antialias_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool DynamicTextFont::get_native_antialias(void) const
  bool return_value = (*(const DynamicTextFont*)local_this).get_native_antialias();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_native_antialias_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.native_antialias")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete native_antialias attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_native_antialias(bool native_antialias)
  (*local_this).set_native_antialias((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_native_antialias(const DynamicTextFont self, bool native_antialias)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_font_pixel_size_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int DynamicTextFont::get_font_pixel_size(void) const
  int return_value = (*(const DynamicTextFont*)local_this).get_font_pixel_size();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_DynamicTextFont_texture_margin_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int DynamicTextFont::get_texture_margin(void) const
  int return_value = (*(const DynamicTextFont*)local_this).get_texture_margin();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_texture_margin_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.texture_margin")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete texture_margin attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_texture_margin(int texture_margin)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_texture_margin((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_texture_margin(const DynamicTextFont self, int texture_margin)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_poly_margin_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat DynamicTextFont::get_poly_margin(void) const
  PN_stdfloat return_value = (*(const DynamicTextFont*)local_this).get_poly_margin();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_poly_margin_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.poly_margin")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete poly_margin attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_poly_margin(PN_stdfloat poly_margin)
  if (PyNumber_Check(arg)) {
    (*local_this).set_poly_margin((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_poly_margin(const DynamicTextFont self, float poly_margin)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_page_size_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2i const &DynamicTextFont::get_page_size(void) const
  LVecBase2i const *return_value = &((*(const DynamicTextFont*)local_this).get_page_size());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
}

static int Dtool_DynamicTextFont_page_size_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.page_size")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete page_size attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_page_size(LVecBase2i const &page_size)
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DynamicTextFont.set_page_size", "LVecBase2i");
    return -1;
  }
  (*local_this).set_page_size(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_page_size(const DynamicTextFont self, const LVecBase2i page_size)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_minfilter_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline SamplerState::FilterType DynamicTextFont::get_minfilter(void) const
  SamplerState::FilterType return_value = (*(const DynamicTextFont*)local_this).get_minfilter();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_minfilter_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.minfilter")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete minfilter attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_minfilter(SamplerState::FilterType filter)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_minfilter((SamplerState::FilterType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_minfilter(const DynamicTextFont self, int filter)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_magfilter_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline SamplerState::FilterType DynamicTextFont::get_magfilter(void) const
  SamplerState::FilterType return_value = (*(const DynamicTextFont*)local_this).get_magfilter();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_magfilter_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.magfilter")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete magfilter attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_magfilter(SamplerState::FilterType filter)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_magfilter((SamplerState::FilterType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_magfilter(const DynamicTextFont self, int filter)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_anisotropic_degree_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int DynamicTextFont::get_anisotropic_degree(void) const
  int return_value = (*(const DynamicTextFont*)local_this).get_anisotropic_degree();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_anisotropic_degree_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.anisotropic_degree")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete anisotropic_degree attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_anisotropic_degree(int anisotropic_degree)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_anisotropic_degree((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_anisotropic_degree(const DynamicTextFont self, int anisotropic_degree)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_render_mode_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline TextFont::RenderMode DynamicTextFont::get_render_mode(void) const
  TextFont::RenderMode return_value = (*(const DynamicTextFont*)local_this).get_render_mode();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DynamicTextFont_render_mode_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.render_mode")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete render_mode attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_render_mode(TextFont::RenderMode render_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_render_mode((TextFont::RenderMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_render_mode(const DynamicTextFont self, int render_mode)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_fg_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LColor const &DynamicTextFont::get_fg(void) const
  LColor const *return_value = &((*(const DynamicTextFont*)local_this).get_fg());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_DynamicTextFont_fg_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.fg")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete fg attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_fg(LColor const &fg)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DynamicTextFont.set_fg", "LVecBase4f");
    return -1;
  }
  (*local_this).set_fg(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_fg(const DynamicTextFont self, const LVecBase4f fg)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_bg_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LColor const &DynamicTextFont::get_bg(void) const
  LColor const *return_value = &((*(const DynamicTextFont*)local_this).get_bg());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_DynamicTextFont_bg_Setter(PyObject *self, PyObject *arg, void *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DynamicTextFont, (void **)&local_this, "DynamicTextFont.bg")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete bg attribute");
    return -1;
  }
  // 1-inline void DynamicTextFont::set_bg(LColor const &bg)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DynamicTextFont.set_bg", "LVecBase4f");
    return -1;
  }
  (*local_this).set_bg(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bg(const DynamicTextFont self, const LVecBase4f bg)\n");
  }
  return -1;
}

static PyObject *Dtool_DynamicTextFont_tex_format_Getter(PyObject *self, void *) {
  const DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline Texture::Format DynamicTextFont::get_tex_format(void) const
  Texture::Format return_value = (*(const DynamicTextFont*)local_this).get_tex_format();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * sequence length function for property DynamicTextFont::pages
 */
static Py_ssize_t Dtool_DynamicTextFont_pages_Len(PyObject *self) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_pages();
}

/**
 * sequence getter for property DynamicTextFont::pages
 */
static PyObject *Dtool_DynamicTextFont_pages_Getitem(PyObject *self, Py_ssize_t index) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_pages()) {
    PyErr_SetString(PyExc_IndexError, "DynamicTextFont.pages[] index out of range");
    return NULL;
  }
  // 1-DynamicTextPage *DynamicTextFont::get_page(int n) const
  DynamicTextPage *return_value = (*(const DynamicTextFont*)local_this).get_page(index);
  if (return_value != (DynamicTextPage *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (DynamicTextPage *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DynamicTextPage, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_page(DynamicTextFont self, index)\n");
  }
}

static PyObject *Dtool_DynamicTextFont_pages_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_DynamicTextFont_pages_Len;
  wrap->_getitem_func = &Dtool_DynamicTextFont_pages_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * DynamicTextFont::DynamicTextFont(DynamicTextFont const &copy)
 * DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index = 0)
 * DynamicTextFont::DynamicTextFont(char const *font_data, int data_length, int face_index)
 */
static int Dtool_Init_DynamicTextFont(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index)
        PyObject *param0;
        static const char *keyword_list[] = {"font_filename", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:DynamicTextFont", (char **)keyword_list, &param0)) {
          Filename const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Filename, (void **)&param0_this);
          if (param0_this != NULL) {
            DynamicTextFont *return_value = new DynamicTextFont(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DynamicTextFont, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 DynamicTextFont::DynamicTextFont(DynamicTextFont const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:DynamicTextFont", (char **)keyword_list, &param0)) {
          DynamicTextFont const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_DynamicTextFont, (void **)&param0_this);
          if (param0_this != NULL) {
            DynamicTextFont *return_value = new DynamicTextFont(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DynamicTextFont, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index)
        PyObject *param0;
        static const char *keyword_list[] = {"font_filename", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:DynamicTextFont", (char **)keyword_list, &param0)) {
          Filename param0_local;
          Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
          if ((param0_this != NULL)) {
            DynamicTextFont *return_value = new DynamicTextFont(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DynamicTextFont, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 DynamicTextFont::DynamicTextFont(DynamicTextFont const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:DynamicTextFont", (char **)keyword_list, &param0)) {
          CPT(DynamicTextFont) param0_this;
          if (Dtool_ConstCoerce_DynamicTextFont(param0, param0_this)) {
            DynamicTextFont *return_value = new DynamicTextFont(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DynamicTextFont, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index)
      PyObject *param0;
      int param1;
      static const char *keyword_list[] = {"font_filename", "face_index", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:DynamicTextFont", (char **)keyword_list, &param0, &param1)) {
        Filename param0_local;
        Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "DynamicTextFont.DynamicTextFont", "Filename");
          return -1;
        }
        DynamicTextFont *return_value = new DynamicTextFont(*param0_this, (int)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DynamicTextFont, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-DynamicTextFont::DynamicTextFont(char const *font_data, int data_length, int face_index)
      char const *param0;
      int param1;
      int param2;
      static const char *keyword_list[] = {"font_data", "data_length", "face_index", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "zii:DynamicTextFont", (char **)keyword_list, &param0, &param1, &param2)) {
        DynamicTextFont *return_value = new DynamicTextFont((char const *)param0, (int)param1, (int)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DynamicTextFont, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DynamicTextFont() takes 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DynamicTextFont(const Filename font_filename)\n"
      "DynamicTextFont(const DynamicTextFont copy)\n"
      "DynamicTextFont(const Filename font_filename, int face_index)\n"
      "DynamicTextFont(str font_data, int data_length, int face_index)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_DynamicTextFont(PyObject *args, CPT(DynamicTextFont) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_DynamicTextFont, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index)
    Filename const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Filename, (void **)&arg_this);
    if (arg_this != NULL) {
      DynamicTextFont *return_value = new DynamicTextFont(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index)
        PyObject *param0;
        int param1;
        if (PyArg_ParseTuple(args, "Oi:DynamicTextFont", &param0, &param1)) {
          Filename const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Filename, (void **)&param0_this);
          if (param0_this != NULL) {
            DynamicTextFont *return_value = new DynamicTextFont(*param0_this, (int)param1);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-DynamicTextFont::DynamicTextFont(char const *font_data, int data_length, int face_index)
        char const *param0;
        int param1;
        int param2;
        if (PyArg_ParseTuple(args, "zii:DynamicTextFont", &param0, &param1, &param2)) {
          DynamicTextFont *return_value = new DynamicTextFont((char const *)param0, (int)param1, (int)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_DynamicTextFont(PyObject *args, PT(DynamicTextFont) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_DynamicTextFont, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index)
    Filename const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Filename, (void **)&arg_this);
    if (arg_this != NULL) {
      DynamicTextFont *return_value = new DynamicTextFont(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index)
        PyObject *param0;
        int param1;
        if (PyArg_ParseTuple(args, "Oi:DynamicTextFont", &param0, &param1)) {
          Filename const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Filename, (void **)&param0_this);
          if (param0_this != NULL) {
            DynamicTextFont *return_value = new DynamicTextFont(*param0_this, (int)param1);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-DynamicTextFont::DynamicTextFont(char const *font_data, int data_length, int face_index)
        char const *param0;
        int param1;
        int param2;
        if (PyArg_ParseTuple(args, "zii:DynamicTextFont", &param0, &param1, &param2)) {
          DynamicTextFont *return_value = new DynamicTextFont((char const *)param0, (int)param1, (int)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_DynamicTextFont_get_pages(PyObject *self, PyObject *) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_pages();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_DynamicTextFont_get_page_136(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_DynamicTextFont(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DynamicTextFont) {
    printf("DynamicTextFont ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DynamicTextFont *local_this = (DynamicTextFont *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DynamicTextFont) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_FreetypeFont) {
    return (FreetypeFont *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(TextFont *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(TextFont *) local_this;
  }
  if (requested_type == Dtool_Ptr_TextFont) {
    return (TextFont *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(TextFont *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(TextFont *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DynamicTextFont(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DynamicTextFont) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_FreetypeFont) {
    FreetypeFont* other_this = (FreetypeFont*)from_this;
    return (DynamicTextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (DynamicTextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_TextFont) {
    TextFont* other_this = (TextFont*)from_this;
    return (DynamicTextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DynamicTextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (DynamicTextFont*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class FontPool
 */
/**
 * Python function wrapper for:
 * static inline bool FontPool::has_font(std::string const &filename)
 */
static PyObject *Dtool_FontPool_has_font_144(PyObject *, PyObject *arg) {
  // 1-static inline bool FontPool::has_font(std::string const &filename)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    bool return_value = FontPool::has_font(std::string(param0_str, param0_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_font(str filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FontPool_has_font_144_comment =
  "C++ Interface:\n"
  "has_font(str filename)\n"
  "\n"
  "/**\n"
  " * Returns true if the font has ever been loaded, false otherwise.\n"
  " */";
#else
static const char *Dtool_FontPool_has_font_144_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline bool FontPool::verify_font(std::string const &filename)
 */
static PyObject *Dtool_FontPool_verify_font_145(PyObject *, PyObject *arg) {
  // 1-static inline bool FontPool::verify_font(std::string const &filename)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    bool return_value = FontPool::verify_font(std::string(param0_str, param0_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "verify_font(str filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FontPool_verify_font_145_comment =
  "C++ Interface:\n"
  "verify_font(str filename)\n"
  "\n"
  "/**\n"
  " * Loads the given filename up into a font, if it has not already been loaded,\n"
  " * and returns true to indicate success, or false to indicate failure.  If\n"
  " * this returns true, it is guaranteed that a subsequent call to load_font()\n"
  " * with the same font name will return a valid Font pointer.\n"
  " */";
#else
static const char *Dtool_FontPool_verify_font_145_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline TextFont *FontPool::load_font(std::string const &filename)
 */
static PyObject *Dtool_FontPool_load_font_146(PyObject *, PyObject *arg) {
  // 1-static inline TextFont *FontPool::load_font(std::string const &filename)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    TextFont *return_value = FontPool::load_font(std::string(param0_str, param0_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (return_value != (TextFont *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (TextFont *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextFont, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_font(str filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FontPool_load_font_146_comment =
  "C++ Interface:\n"
  "load_font(str filename)\n"
  "\n"
  "/**\n"
  " * Loads the given filename up into a font, if it has not already been loaded,\n"
  " * and returns the new font.  If a font with the same filename was previously\n"
  " * loaded, returns that one instead.  If the font file cannot be found,\n"
  " * returns NULL.\n"
  " */";
#else
static const char *Dtool_FontPool_load_font_146_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void FontPool::add_font(std::string const &filename, TextFont *font)
 */
static PyObject *Dtool_FontPool_add_font_147(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline void FontPool::add_font(std::string const &filename, TextFont *font)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  PyObject *param1;
  static const char *keyword_list[] = {"filename", "font", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:add_font", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    TextFont *param1_this = (TextFont *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextFont, 1, "FontPool.add_font", false, true);
    if (param1_this != NULL) {
      FontPool::add_font(std::string(param0_str, param0_len), param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_font(str filename, TextFont font)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FontPool_add_font_147_comment =
  "C++ Interface:\n"
  "add_font(str filename, TextFont font)\n"
  "\n"
  "/**\n"
  " * Adds the indicated already-loaded font to the pool.  The font will always\n"
  " * replace any previously-loaded font in the pool that had the same filename.\n"
  " */";
#else
static const char *Dtool_FontPool_add_font_147_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void FontPool::release_font(std::string const &filename)
 */
static PyObject *Dtool_FontPool_release_font_148(PyObject *, PyObject *arg) {
  // 1-static inline void FontPool::release_font(std::string const &filename)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    FontPool::release_font(std::string(param0_str, param0_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release_font(str filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FontPool_release_font_148_comment =
  "C++ Interface:\n"
  "release_font(str filename)\n"
  "\n"
  "/**\n"
  " * Removes the indicated font from the pool, indicating it will never be\n"
  " * loaded again; the font may then be freed.  If this function is never\n"
  " * called, a reference count will be maintained on every font every loaded,\n"
  " * and fonts will never be freed.\n"
  " */";
#else
static const char *Dtool_FontPool_release_font_148_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void FontPool::release_all_fonts(void)
 */
static PyObject *Dtool_FontPool_release_all_fonts_149(PyObject *, PyObject *) {
  // 1-static inline void FontPool::release_all_fonts(void)
  FontPool::release_all_fonts();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_FontPool_release_all_fonts_149_comment =
  "C++ Interface:\n"
  "release_all_fonts()\n"
  "\n"
  "/**\n"
  " * Releases all fonts in the pool and restores the pool to the empty state.\n"
  " */";
#else
static const char *Dtool_FontPool_release_all_fonts_149_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline int FontPool::garbage_collect(void)
 */
static PyObject *Dtool_FontPool_garbage_collect_150(PyObject *, PyObject *) {
  // 1-static inline int FontPool::garbage_collect(void)
  int return_value = FontPool::garbage_collect();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FontPool_garbage_collect_150_comment =
  "C++ Interface:\n"
  "garbage_collect()\n"
  "\n"
  "/**\n"
  " * Releases only those fonts in the pool that have a reference count of\n"
  " * exactly 1; i.e.  only those fonts that are not being used outside of the\n"
  " * pool.  Returns the number of fonts released.\n"
  " */";
#else
static const char *Dtool_FontPool_garbage_collect_150_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void FontPool::list_contents(ostream &out)
 */
static PyObject *Dtool_FontPool_list_contents_151(PyObject *, PyObject *arg) {
  // 1-static inline void FontPool::list_contents(ostream &out)
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 0, "FontPool.list_contents", false, true);
  if (arg_this != NULL) {
    FontPool::list_contents(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "list_contents(ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FontPool_list_contents_151_comment =
  "C++ Interface:\n"
  "list_contents(ostream out)\n"
  "\n"
  "/**\n"
  " * Lists the contents of the font pool to the indicated output stream.\n"
  " */";
#else
static const char *Dtool_FontPool_list_contents_151_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static void FontPool::write(ostream &out)
 */
static PyObject *Dtool_FontPool_write_152(PyObject *, PyObject *arg) {
  // 1-static void FontPool::write(ostream &out)
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 0, "FontPool.write", false, true);
  if (arg_this != NULL) {
    FontPool::write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FontPool_write_152_comment =
  "C++ Interface:\n"
  "write(ostream out)\n"
  "\n"
  "/**\n"
  " * Lists the contents of the font pool to the indicated output stream.\n"
  " */";
#else
static const char *Dtool_FontPool_write_152_comment = NULL;
#endif

static int Dtool_Init_FontPool(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_FontPool(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_FontPool) {
    printf("FontPool ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  FontPool *local_this = (FontPool *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_FontPool) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_FontPool(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_FontPool) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class GeomTextGlyph
 */
/**
 * Python function wrapper for:
 * static TypeHandle GeomTextGlyph::get_class_type(void)
 */
static PyObject *Dtool_GeomTextGlyph_get_class_type_156(PyObject *, PyObject *) {
  // 1-static TypeHandle GeomTextGlyph::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(GeomTextGlyph::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomTextGlyph_get_class_type_156_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeomTextGlyph_get_class_type_156_comment = NULL;
#endif

static int Dtool_Init_GeomTextGlyph(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_GeomTextGlyph(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_GeomTextGlyph) {
    printf("GeomTextGlyph ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  GeomTextGlyph *local_this = (GeomTextGlyph *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_GeomTextGlyph) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(Geom *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(Geom *) local_this;
  }
  if (requested_type == Dtool_Ptr_Geom) {
    return (Geom *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeomEnums) {
    return (GeomEnums *)(Geom *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(Geom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(Geom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(Geom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(Geom *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_GeomTextGlyph(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_GeomTextGlyph) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (GeomTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (GeomTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_Geom) {
    Geom* other_this = (Geom*)from_this;
    return (GeomTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_GeomEnums) {
    GeomEnums* other_this = (GeomEnums*)from_this;
    return (GeomTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeomTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GeomTextGlyph*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GeomTextGlyph*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class StaticTextFont
 */
/**
 * Python function wrapper for:
 * static TypeHandle StaticTextFont::get_class_type(void)
 */
static PyObject *Dtool_StaticTextFont_get_class_type_159(PyObject *, PyObject *) {
  // 1-static TypeHandle StaticTextFont::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(StaticTextFont::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_StaticTextFont_get_class_type_159_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_StaticTextFont_get_class_type_159_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * StaticTextFont::StaticTextFont(PandaNode *font_def, CoordinateSystem cs = ::CS_default)
 * inline StaticTextFont::StaticTextFont(StaticTextFont const &) = default
 */
static int Dtool_Init_StaticTextFont(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    // -2 StaticTextFont::StaticTextFont(PandaNode *font_def, CoordinateSystem cs = ::CS_default)
    PyObject *param0;
    int param1 = ::CS_default;
    static const char *keyword_list[] = {"font_def", "cs", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:StaticTextFont", (char **)keyword_list, &param0, &param1)) {
      PandaNode *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PandaNode, 0, "StaticTextFont.StaticTextFont", false, false);
      if (param0_this != NULL) {
        StaticTextFont *return_value = new StaticTextFont(param0_this, (CoordinateSystem)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StaticTextFont, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: StaticTextFont::StaticTextFont(PandaNode *font_def, CoordinateSystem cs = ::CS_default)
  {
    // -2 inline StaticTextFont::StaticTextFont(StaticTextFont const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:StaticTextFont", (char **)keyword_list, &param0)) {
      CPT(StaticTextFont) param0_this;
      if (Dtool_ConstCoerce_StaticTextFont(param0, param0_this)) {
        StaticTextFont *return_value = new StaticTextFont(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StaticTextFont, true, false);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "StaticTextFont(PandaNode font_def, int cs)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_StaticTextFont(PyObject *args, CPT(StaticTextFont) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_StaticTextFont, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-StaticTextFont::StaticTextFont(PandaNode *font_def, CoordinateSystem cs)
    PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 0, "StaticTextFont.StaticTextFont", false, false);
    if (arg_this != NULL) {
      StaticTextFont *return_value = new StaticTextFont(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-StaticTextFont::StaticTextFont(PandaNode *font_def, CoordinateSystem cs)
      PyObject *param0;
      int param1;
      if (PyArg_ParseTuple(args, "Oi:StaticTextFont", &param0, &param1)) {
        PandaNode *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PandaNode, 0, "StaticTextFont.StaticTextFont", false, false);
        if (param0_this != NULL) {
          StaticTextFont *return_value = new StaticTextFont(param0_this, (CoordinateSystem)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_StaticTextFont(PyObject *args, PT(StaticTextFont) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_StaticTextFont, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-StaticTextFont::StaticTextFont(PandaNode *font_def, CoordinateSystem cs)
    PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 0, "StaticTextFont.StaticTextFont", false, false);
    if (arg_this != NULL) {
      StaticTextFont *return_value = new StaticTextFont(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-StaticTextFont::StaticTextFont(PandaNode *font_def, CoordinateSystem cs)
      PyObject *param0;
      int param1;
      if (PyArg_ParseTuple(args, "Oi:StaticTextFont", &param0, &param1)) {
        PandaNode *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PandaNode, 0, "StaticTextFont.StaticTextFont", false, false);
        if (param0_this != NULL) {
          StaticTextFont *return_value = new StaticTextFont(param0_this, (CoordinateSystem)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_StaticTextFont(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_StaticTextFont) {
    printf("StaticTextFont ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  StaticTextFont *local_this = (StaticTextFont *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_StaticTextFont) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(TextFont *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(TextFont *) local_this;
  }
  if (requested_type == Dtool_Ptr_TextFont) {
    return (TextFont *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(TextFont *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(TextFont *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_StaticTextFont(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_StaticTextFont) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (StaticTextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (StaticTextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_TextFont) {
    TextFont* other_this = (TextFont*)from_this;
    return (StaticTextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (StaticTextFont*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (StaticTextFont*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class TextProperties
 */
/**
 * Python function wrapper for:
 * void TextProperties::operator =(TextProperties const &copy)
 */
static PyObject *Dtool_TextProperties_operator_164(PyObject *self, PyObject *arg) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.assign")) {
    return NULL;
  }
  // 1-void TextProperties::operator =(TextProperties const &copy)
  TextProperties const *arg_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextProperties, 1, "TextProperties.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    TextProperties *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextProperties, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const TextProperties self, const TextProperties copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_operator_164_comment =
  "C++ Interface:\n"
  "assign(const TextProperties self, const TextProperties copy)\n";
#else
static const char *Dtool_TextProperties_operator_164_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void TextProperties::clear(void)
 */
static PyObject *Dtool_TextProperties_clear_167(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear")) {
    return NULL;
  }
  // 1-void TextProperties::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_167_comment =
  "C++ Interface:\n"
  "clear(const TextProperties self)\n"
  "\n"
  "/**\n"
  " * Unsets all properties that have been specified so far, and resets the\n"
  " * TextProperties structure to its initial empty state.\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_167_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::is_any_specified(void) const
 */
static PyObject *Dtool_TextProperties_is_any_specified_168(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::is_any_specified(void) const
  bool return_value = (*(const TextProperties*)local_this).is_any_specified();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_is_any_specified_168_comment =
  "C++ Interface:\n"
  "is_any_specified(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if any properties have been specified, false otherwise.\n"
  " */";
#else
static const char *Dtool_TextProperties_is_any_specified_168_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void TextProperties::set_default_font(TextFont *)
 */
static PyObject *Dtool_TextProperties_set_default_font_169(PyObject *, PyObject *arg) {
  // 1-static inline void TextProperties::set_default_font(TextFont *)
  TextFont *arg_this = (TextFont *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextFont, 0, "TextProperties.set_default_font", false, true);
  if (arg_this != NULL) {
    TextProperties::set_default_font(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_default_font(TextFont param0)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_default_font_169_comment =
  "C++ Interface:\n"
  "set_default_font(TextFont param0)\n"
  "\n"
  "/**\n"
  " * Specifies the default font to be used for any TextNode whose font is\n"
  " * uninitialized or NULL.  See set_font().\n"
  " */";
#else
static const char *Dtool_TextProperties_set_default_font_169_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline TextFont *TextProperties::get_default_font(void)
 */
static PyObject *Dtool_TextProperties_get_default_font_170(PyObject *, PyObject *) {
  // 1-static inline TextFont *TextProperties::get_default_font(void)
  TextFont *return_value = TextProperties::get_default_font();
  if (return_value != (TextFont *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (TextFont *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextFont, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_default_font_170_comment =
  "C++ Interface:\n"
  "get_default_font()\n"
  "\n"
  "/**\n"
  " * Specifies the default font to be used for any TextNode whose font is\n"
  " * uninitialized or NULL.  See set_font().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_default_font_170_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_font(TextFont *font)
 */
static PyObject *Dtool_TextProperties_set_font_171(PyObject *self, PyObject *arg) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_font")) {
    return NULL;
  }
  // 1-inline void TextProperties::set_font(TextFont *font)
  TextFont *arg_this = (TextFont *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextFont, 1, "TextProperties.set_font", false, true);
  if (arg_this != NULL) {
    (*local_this).set_font(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_font(const TextProperties self, TextFont font)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_font_171_comment =
  "C++ Interface:\n"
  "set_font(const TextProperties self, TextFont font)\n"
  "\n"
  "/**\n"
  " * Sets the font that will be used when making text.  If this is set to NULL,\n"
  " * the default font will be used, which can be set via set_default_font().\n"
  " */";
#else
static const char *Dtool_TextProperties_set_font_171_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_font(void)
 */
static PyObject *Dtool_TextProperties_clear_font_172(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_font")) {
    return NULL;
  }
  // 1-inline void TextProperties::clear_font(void)
  (*local_this).clear_font();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_font_172_comment =
  "C++ Interface:\n"
  "clear_font(const TextProperties self)\n"
  "\n"
  "/**\n"
  " * Restores the default font to the text.\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_font_172_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_font(void) const
 */
static PyObject *Dtool_TextProperties_has_font_173(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::has_font(void) const
  bool return_value = (*(const TextProperties*)local_this).has_font();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_font_173_comment =
  "C++ Interface:\n"
  "has_font(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_font_173_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TextFont *TextProperties::get_font(void) const
 */
static PyObject *Dtool_TextProperties_get_font_174(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline TextFont *TextProperties::get_font(void) const
  TextFont *return_value = (*(const TextProperties*)local_this).get_font();
  if (return_value != (TextFont *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (TextFont *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextFont, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_font_174_comment =
  "C++ Interface:\n"
  "get_font(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the font currently in use, if any.  If no font is in use, this\n"
  " * returns the default font.\n"
  " */";
#else
static const char *Dtool_TextProperties_get_font_174_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_small_caps(bool small_caps)
 */
static PyObject *Dtool_TextProperties_set_small_caps_175(PyObject *self, PyObject *arg) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_small_caps")) {
    return NULL;
  }
  // 1-inline void TextProperties::set_small_caps(bool small_caps)
  (*local_this).set_small_caps((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_small_caps(const TextProperties self, bool small_caps)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_small_caps_175_comment =
  "C++ Interface:\n"
  "set_small_caps(const TextProperties self, bool small_caps)\n"
  "\n"
  "/**\n"
  " * Sets the small_caps flag.  When this is set, lowercase letters are\n"
  " * generated as scaled-down versions of their uppercase equivalents.  This is\n"
  " * particularly useful to set for fonts that do not have lowercase letters.\n"
  " *\n"
  " * It is also a good idea to set this for a (dynamic) font that has already\n"
  " * implemented lowercase letters as scaled-down versions of their uppercase\n"
  " * equivalents, since without this flag the texture memory may needlessly\n"
  " * duplicate equivalent glyphs for upper and lowercase letters.  Setting this\n"
  " * flag causes the texture memory to share the mixed-case letters.\n"
  " *\n"
  " * The amount by which the lowercase letters are scaled is specified by\n"
  " * set_small_caps_scale().\n"
  " */";
#else
static const char *Dtool_TextProperties_set_small_caps_175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_small_caps(void)
 */
static PyObject *Dtool_TextProperties_clear_small_caps_176(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_small_caps")) {
    return NULL;
  }
  // 1-inline void TextProperties::clear_small_caps(void)
  (*local_this).clear_small_caps();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_small_caps_176_comment =
  "C++ Interface:\n"
  "clear_small_caps(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_small_caps_176_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_small_caps(void) const
 */
static PyObject *Dtool_TextProperties_has_small_caps_177(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::has_small_caps(void) const
  bool return_value = (*(const TextProperties*)local_this).has_small_caps();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_small_caps_177_comment =
  "C++ Interface:\n"
  "has_small_caps(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_small_caps_177_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::get_small_caps(void) const
 */
static PyObject *Dtool_TextProperties_get_small_caps_178(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::get_small_caps(void) const
  bool return_value = (*(const TextProperties*)local_this).get_small_caps();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_small_caps_178_comment =
  "C++ Interface:\n"
  "get_small_caps(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the small_caps flag.  See set_small_caps().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_small_caps_178_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_small_caps_scale(PN_stdfloat small_caps_scale)
 */
static PyObject *Dtool_TextProperties_set_small_caps_scale_179(PyObject *self, PyObject *arg) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_small_caps_scale")) {
    return NULL;
  }
  // 1-inline void TextProperties::set_small_caps_scale(PN_stdfloat small_caps_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_small_caps_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_small_caps_scale(const TextProperties self, float small_caps_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_small_caps_scale_179_comment =
  "C++ Interface:\n"
  "set_small_caps_scale(const TextProperties self, float small_caps_scale)\n"
  "\n"
  "/**\n"
  " * Sets the scale factor applied to lowercase letters from their uppercase\n"
  " * equivalents, when the small_caps flag is in effect.  See set_small_caps().\n"
  " * Normally, this will be a number less than one.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_small_caps_scale_179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_small_caps_scale(void)
 */
static PyObject *Dtool_TextProperties_clear_small_caps_scale_180(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_small_caps_scale")) {
    return NULL;
  }
  // 1-inline void TextProperties::clear_small_caps_scale(void)
  (*local_this).clear_small_caps_scale();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_small_caps_scale_180_comment =
  "C++ Interface:\n"
  "clear_small_caps_scale(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_small_caps_scale_180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_small_caps_scale(void) const
 */
static PyObject *Dtool_TextProperties_has_small_caps_scale_181(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::has_small_caps_scale(void) const
  bool return_value = (*(const TextProperties*)local_this).has_small_caps_scale();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_small_caps_scale_181_comment =
  "C++ Interface:\n"
  "has_small_caps_scale(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_small_caps_scale_181_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextProperties::get_small_caps_scale(void) const
 */
static PyObject *Dtool_TextProperties_get_small_caps_scale_182(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextProperties::get_small_caps_scale(void) const
  PN_stdfloat return_value = (*(const TextProperties*)local_this).get_small_caps_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_small_caps_scale_182_comment =
  "C++ Interface:\n"
  "get_small_caps_scale(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the scale factor applied to lowercase letters from their uppercase\n"
  " * equivalents, when the small_caps flag is in effect.  See set_small_caps()\n"
  " * and set_small_caps_scale().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_small_caps_scale_182_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_slant(PN_stdfloat slant)
 */
static PyObject *Dtool_TextProperties_set_slant_183(PyObject *self, PyObject *arg) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_slant")) {
    return NULL;
  }
  // 1-inline void TextProperties::set_slant(PN_stdfloat slant)
  if (PyNumber_Check(arg)) {
    (*local_this).set_slant((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_slant(const TextProperties self, float slant)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_slant_183_comment =
  "C++ Interface:\n"
  "set_slant(const TextProperties self, float slant)\n"
  "\n"
  "/**\n"
  " * Specifies the factor by which the text slants to the right.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_slant_183_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_slant(void)
 */
static PyObject *Dtool_TextProperties_clear_slant_184(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_slant")) {
    return NULL;
  }
  // 1-inline void TextProperties::clear_slant(void)
  (*local_this).clear_slant();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_slant_184_comment =
  "C++ Interface:\n"
  "clear_slant(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_slant_184_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_slant(void) const
 */
static PyObject *Dtool_TextProperties_has_slant_185(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::has_slant(void) const
  bool return_value = (*(const TextProperties*)local_this).has_slant();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_slant_185_comment =
  "C++ Interface:\n"
  "has_slant(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_slant_185_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextProperties::get_slant(void) const
 */
static PyObject *Dtool_TextProperties_get_slant_186(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextProperties::get_slant(void) const
  PN_stdfloat return_value = (*(const TextProperties*)local_this).get_slant();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_slant_186_comment =
  "C++ Interface:\n"
  "get_slant(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the factor by which the text is specified to slant to the right.\n"
  " */";
#else
static const char *Dtool_TextProperties_get_slant_186_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_underscore(bool underscore)
 */
static PyObject *Dtool_TextProperties_set_underscore_187(PyObject *self, PyObject *arg) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_underscore")) {
    return NULL;
  }
  // 1-inline void TextProperties::set_underscore(bool underscore)
  (*local_this).set_underscore((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_underscore(const TextProperties self, bool underscore)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_underscore_187_comment =
  "C++ Interface:\n"
  "set_underscore(const TextProperties self, bool underscore)\n"
  "\n"
  "/**\n"
  " * Sets the underscore flag.  When this is set, the text is underscored with a\n"
  " * one-pixel line the same color as the text foreground, drawn at the\n"
  " * baseline.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_underscore_187_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_underscore(void)
 */
static PyObject *Dtool_TextProperties_clear_underscore_188(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_underscore")) {
    return NULL;
  }
  // 1-inline void TextProperties::clear_underscore(void)
  (*local_this).clear_underscore();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_underscore_188_comment =
  "C++ Interface:\n"
  "clear_underscore(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_underscore_188_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_underscore(void) const
 */
static PyObject *Dtool_TextProperties_has_underscore_189(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::has_underscore(void) const
  bool return_value = (*(const TextProperties*)local_this).has_underscore();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_underscore_189_comment =
  "C++ Interface:\n"
  "has_underscore(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_underscore_189_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::get_underscore(void) const
 */
static PyObject *Dtool_TextProperties_get_underscore_190(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::get_underscore(void) const
  bool return_value = (*(const TextProperties*)local_this).get_underscore();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_underscore_190_comment =
  "C++ Interface:\n"
  "get_underscore(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the underscore flag.  See set_underscore().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_underscore_190_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_underscore_height(PN_stdfloat underscore_height)
 */
static PyObject *Dtool_TextProperties_set_underscore_height_191(PyObject *self, PyObject *arg) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_underscore_height")) {
    return NULL;
  }
  // 1-inline void TextProperties::set_underscore_height(PN_stdfloat underscore_height)
  if (PyNumber_Check(arg)) {
    (*local_this).set_underscore_height((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_underscore_height(const TextProperties self, float underscore_height)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_underscore_height_191_comment =
  "C++ Interface:\n"
  "set_underscore_height(const TextProperties self, float underscore_height)\n"
  "\n"
  "/**\n"
  " * Specifies the vertical height of the underscore, relative to the text\n"
  " * baseline.  This only has meaning if the underscore mode is enabled with\n"
  " * set_underscore().\n"
  " */";
#else
static const char *Dtool_TextProperties_set_underscore_height_191_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_underscore_height(void)
 */
static PyObject *Dtool_TextProperties_clear_underscore_height_192(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_underscore_height")) {
    return NULL;
  }
  // 1-inline void TextProperties::clear_underscore_height(void)
  (*local_this).clear_underscore_height();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_underscore_height_192_comment =
  "C++ Interface:\n"
  "clear_underscore_height(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_underscore_height_192_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_underscore_height(void) const
 */
static PyObject *Dtool_TextProperties_has_underscore_height_193(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::has_underscore_height(void) const
  bool return_value = (*(const TextProperties*)local_this).has_underscore_height();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_underscore_height_193_comment =
  "C++ Interface:\n"
  "has_underscore_height(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_underscore_height_193_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextProperties::get_underscore_height(void) const
 */
static PyObject *Dtool_TextProperties_get_underscore_height_194(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextProperties::get_underscore_height(void) const
  PN_stdfloat return_value = (*(const TextProperties*)local_this).get_underscore_height();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_underscore_height_194_comment =
  "C++ Interface:\n"
  "get_underscore_height(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the vertical height of the underscore; see set_underscore_height().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_underscore_height_194_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_align(TextProperties::Alignment align_type)
 */
static PyObject *Dtool_TextProperties_set_align_195(PyObject *self, PyObject *arg) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_align")) {
    return NULL;
  }
  // 1-inline void TextProperties::set_align(TextProperties::Alignment align_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_align((TextProperties::Alignment)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_align(const TextProperties self, int align_type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_align_195_comment =
  "C++ Interface:\n"
  "set_align(const TextProperties self, int align_type)\n"
  "\n"
  "/**\n"
  " * Specifies the alignment of the text within its margins.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_align_195_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_align(void)
 */
static PyObject *Dtool_TextProperties_clear_align_196(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_align")) {
    return NULL;
  }
  // 1-inline void TextProperties::clear_align(void)
  (*local_this).clear_align();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_align_196_comment =
  "C++ Interface:\n"
  "clear_align(const TextProperties self)\n"
  "\n"
  "/**\n"
  " * Restores the default alignment of the text.\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_align_196_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_align(void) const
 */
static PyObject *Dtool_TextProperties_has_align_197(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::has_align(void) const
  bool return_value = (*(const TextProperties*)local_this).has_align();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_align_197_comment =
  "C++ Interface:\n"
  "has_align(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_align_197_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TextProperties::Alignment TextProperties::get_align(void) const
 */
static PyObject *Dtool_TextProperties_get_align_198(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline TextProperties::Alignment TextProperties::get_align(void) const
  TextProperties::Alignment return_value = (*(const TextProperties*)local_this).get_align();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_align_198_comment =
  "C++ Interface:\n"
  "get_align(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_get_align_198_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_indent(PN_stdfloat indent)
 */
static PyObject *Dtool_TextProperties_set_indent_199(PyObject *self, PyObject *arg) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_indent")) {
    return NULL;
  }
  // 1-inline void TextProperties::set_indent(PN_stdfloat indent)
  if (PyNumber_Check(arg)) {
    (*local_this).set_indent((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_indent(const TextProperties self, float indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_indent_199_comment =
  "C++ Interface:\n"
  "set_indent(const TextProperties self, float indent)\n"
  "\n"
  "/**\n"
  " * Specifies the amount of extra space that is inserted before the first\n"
  " * character of each line.  This can be thought of as a left margin.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_indent_199_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_indent(void)
 */
static PyObject *Dtool_TextProperties_clear_indent_200(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_indent")) {
    return NULL;
  }
  // 1-inline void TextProperties::clear_indent(void)
  (*local_this).clear_indent();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_indent_200_comment =
  "C++ Interface:\n"
  "clear_indent(const TextProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the indent setting from the text.  Text will be as wide as it is.\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_indent_200_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_indent(void) const
 */
static PyObject *Dtool_TextProperties_has_indent_201(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::has_indent(void) const
  bool return_value = (*(const TextProperties*)local_this).has_indent();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_indent_201_comment =
  "C++ Interface:\n"
  "has_indent(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_indent_201_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextProperties::get_indent(void) const
 */
static PyObject *Dtool_TextProperties_get_indent_202(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextProperties::get_indent(void) const
  PN_stdfloat return_value = (*(const TextProperties*)local_this).get_indent();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_indent_202_comment =
  "C++ Interface:\n"
  "get_indent(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_get_indent_202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_wordwrap(PN_stdfloat wordwrap)
 */
static PyObject *Dtool_TextProperties_set_wordwrap_203(PyObject *self, PyObject *arg) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_wordwrap")) {
    return NULL;
  }
  // 1-inline void TextProperties::set_wordwrap(PN_stdfloat wordwrap)
  if (PyNumber_Check(arg)) {
    (*local_this).set_wordwrap((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wordwrap(const TextProperties self, float wordwrap)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_wordwrap_203_comment =
  "C++ Interface:\n"
  "set_wordwrap(const TextProperties self, float wordwrap)\n"
  "\n"
  "/**\n"
  " * Sets the text up to automatically wordwrap when it exceeds the indicated\n"
  " * width.  This can be thought of as a right margin or margin width.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_wordwrap_203_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_wordwrap(void)
 */
static PyObject *Dtool_TextProperties_clear_wordwrap_204(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_wordwrap")) {
    return NULL;
  }
  // 1-inline void TextProperties::clear_wordwrap(void)
  (*local_this).clear_wordwrap();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_wordwrap_204_comment =
  "C++ Interface:\n"
  "clear_wordwrap(const TextProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the wordwrap setting from the text.  Text will be as wide as it is.\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_wordwrap_204_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_wordwrap(void) const
 */
static PyObject *Dtool_TextProperties_has_wordwrap_205(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::has_wordwrap(void) const
  bool return_value = (*(const TextProperties*)local_this).has_wordwrap();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_wordwrap_205_comment =
  "C++ Interface:\n"
  "has_wordwrap(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_wordwrap_205_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextProperties::get_wordwrap(void) const
 */
static PyObject *Dtool_TextProperties_get_wordwrap_206(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextProperties::get_wordwrap(void) const
  PN_stdfloat return_value = (*(const TextProperties*)local_this).get_wordwrap();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_wordwrap_206_comment =
  "C++ Interface:\n"
  "get_wordwrap(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_get_wordwrap_206_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_preserve_trailing_whitespace(bool preserve_trailing_whitespace)
 */
static PyObject *Dtool_TextProperties_set_preserve_trailing_whitespace_207(PyObject *self, PyObject *arg) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_preserve_trailing_whitespace")) {
    return NULL;
  }
  // 1-inline void TextProperties::set_preserve_trailing_whitespace(bool preserve_trailing_whitespace)
  (*local_this).set_preserve_trailing_whitespace((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_preserve_trailing_whitespace(const TextProperties self, bool preserve_trailing_whitespace)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_preserve_trailing_whitespace_207_comment =
  "C++ Interface:\n"
  "set_preserve_trailing_whitespace(const TextProperties self, bool preserve_trailing_whitespace)\n"
  "\n"
  "/**\n"
  " * Sets the preserve_trailing_whitespace flag.  When this is set, trailing\n"
  " * whitespace at the end of the line is not stripped when the text is\n"
  " * wordwrapped (it is stripped by default).  Since the trailing whitespace is\n"
  " * invisible, this is important primarily for determining the proper width of\n"
  " * a frame or card behind the text.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_preserve_trailing_whitespace_207_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_preserve_trailing_whitespace(void)
 */
static PyObject *Dtool_TextProperties_clear_preserve_trailing_whitespace_208(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_preserve_trailing_whitespace")) {
    return NULL;
  }
  // 1-inline void TextProperties::clear_preserve_trailing_whitespace(void)
  (*local_this).clear_preserve_trailing_whitespace();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_preserve_trailing_whitespace_208_comment =
  "C++ Interface:\n"
  "clear_preserve_trailing_whitespace(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_preserve_trailing_whitespace_208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_preserve_trailing_whitespace(void) const
 */
static PyObject *Dtool_TextProperties_has_preserve_trailing_whitespace_209(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::has_preserve_trailing_whitespace(void) const
  bool return_value = (*(const TextProperties*)local_this).has_preserve_trailing_whitespace();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_preserve_trailing_whitespace_209_comment =
  "C++ Interface:\n"
  "has_preserve_trailing_whitespace(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_preserve_trailing_whitespace_209_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::get_preserve_trailing_whitespace(void) const
 */
static PyObject *Dtool_TextProperties_get_preserve_trailing_whitespace_210(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::get_preserve_trailing_whitespace(void) const
  bool return_value = (*(const TextProperties*)local_this).get_preserve_trailing_whitespace();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_preserve_trailing_whitespace_210_comment =
  "C++ Interface:\n"
  "get_preserve_trailing_whitespace(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the preserve_trailing_whitespace flag.  See\n"
  " * set_preserve_trailing_whitespace().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_preserve_trailing_whitespace_210_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_text_color(LColor const &text_color)
 * inline void TextProperties::set_text_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
 */
static PyObject *Dtool_TextProperties_set_text_color_211(PyObject *self, PyObject *args, PyObject *kwds) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_text_color")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "text_color");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'text_color' (pos 1) not found");
      }
      // 1-inline void TextProperties::set_text_color(LColor const &text_color)
      LVecBase4f arg_local;
      LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "TextProperties.set_text_color", "LVecBase4f");
      }
      (*local_this).set_text_color(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void TextProperties::set_text_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"r", "g", "b", "a", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_text_color", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_text_color((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_text_color() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_text_color(const TextProperties self, const LVecBase4f text_color)\n"
      "set_text_color(const TextProperties self, float r, float g, float b, float a)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_text_color_211_comment =
  "C++ Interface:\n"
  "set_text_color(const TextProperties self, const LVecBase4f text_color)\n"
  "set_text_color(const TextProperties self, float r, float g, float b, float a)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_set_text_color_211_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_text_color(void)
 */
static PyObject *Dtool_TextProperties_clear_text_color_212(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_text_color")) {
    return NULL;
  }
  // 1-inline void TextProperties::clear_text_color(void)
  (*local_this).clear_text_color();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_text_color_212_comment =
  "C++ Interface:\n"
  "clear_text_color(const TextProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the text color specification; the text will be colored whatever it\n"
  " * was in the source font file.\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_text_color_212_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_text_color(void) const
 */
static PyObject *Dtool_TextProperties_has_text_color_213(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::has_text_color(void) const
  bool return_value = (*(const TextProperties*)local_this).has_text_color();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_text_color_213_comment =
  "C++ Interface:\n"
  "has_text_color(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_text_color_213_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor TextProperties::get_text_color(void) const
 */
static PyObject *Dtool_TextProperties_get_text_color_214(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor TextProperties::get_text_color(void) const
  LColor *return_value = new LColor((*(const TextProperties*)local_this).get_text_color());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_text_color_214_comment =
  "C++ Interface:\n"
  "get_text_color(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_get_text_color_214_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_shadow_color(LColor const &shadow_color)
 * inline void TextProperties::set_shadow_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
 */
static PyObject *Dtool_TextProperties_set_shadow_color_215(PyObject *self, PyObject *args, PyObject *kwds) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_shadow_color")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "shadow_color");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'shadow_color' (pos 1) not found");
      }
      // 1-inline void TextProperties::set_shadow_color(LColor const &shadow_color)
      LVecBase4f arg_local;
      LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "TextProperties.set_shadow_color", "LVecBase4f");
      }
      (*local_this).set_shadow_color(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void TextProperties::set_shadow_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"r", "g", "b", "a", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_shadow_color", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_shadow_color((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_shadow_color() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow_color(const TextProperties self, const LVecBase4f shadow_color)\n"
      "set_shadow_color(const TextProperties self, float r, float g, float b, float a)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_shadow_color_215_comment =
  "C++ Interface:\n"
  "set_shadow_color(const TextProperties self, const LVecBase4f shadow_color)\n"
  "set_shadow_color(const TextProperties self, float r, float g, float b, float a)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_set_shadow_color_215_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_shadow_color(void)
 */
static PyObject *Dtool_TextProperties_clear_shadow_color_216(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_shadow_color")) {
    return NULL;
  }
  // 1-inline void TextProperties::clear_shadow_color(void)
  (*local_this).clear_shadow_color();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_shadow_color_216_comment =
  "C++ Interface:\n"
  "clear_shadow_color(const TextProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the shadow color specification.\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_shadow_color_216_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_shadow_color(void) const
 */
static PyObject *Dtool_TextProperties_has_shadow_color_217(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::has_shadow_color(void) const
  bool return_value = (*(const TextProperties*)local_this).has_shadow_color();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_shadow_color_217_comment =
  "C++ Interface:\n"
  "has_shadow_color(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_shadow_color_217_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor TextProperties::get_shadow_color(void) const
 */
static PyObject *Dtool_TextProperties_get_shadow_color_218(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor TextProperties::get_shadow_color(void) const
  LColor *return_value = new LColor((*(const TextProperties*)local_this).get_shadow_color());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_shadow_color_218_comment =
  "C++ Interface:\n"
  "get_shadow_color(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_get_shadow_color_218_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_shadow(LVecBase2 const &shadow_offset)
 * inline void TextProperties::set_shadow(PN_stdfloat xoffset, PN_stdfloat yoffset)
 */
static PyObject *Dtool_TextProperties_set_shadow_219(PyObject *self, PyObject *args, PyObject *kwds) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_shadow")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "shadow_offset");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'shadow_offset' (pos 1) not found");
      }
      // 1-inline void TextProperties::set_shadow(LVecBase2 const &shadow_offset)
      LVecBase2f arg_local;
      LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "TextProperties.set_shadow", "LVecBase2f");
      }
      (*local_this).set_shadow(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 2:
    {
      // 1-inline void TextProperties::set_shadow(PN_stdfloat xoffset, PN_stdfloat yoffset)
      float param1;
      float param2;
      static const char *keyword_list[] = {"xoffset", "yoffset", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_shadow", (char **)keyword_list, &param1, &param2)) {
        (*local_this).set_shadow((PN_stdfloat)param1, (PN_stdfloat)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_shadow() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow(const TextProperties self, const LVecBase2f shadow_offset)\n"
      "set_shadow(const TextProperties self, float xoffset, float yoffset)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_shadow_219_comment =
  "C++ Interface:\n"
  "set_shadow(const TextProperties self, const LVecBase2f shadow_offset)\n"
  "set_shadow(const TextProperties self, float xoffset, float yoffset)\n"
  "\n"
  "/**\n"
  " * Specifies that the text should be drawn with a shadow, by creating a second\n"
  " * copy of the text and offsetting it slightly behind the first.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies that the text should be drawn with a shadow, by creating a second\n"
  " * copy of the text and offsetting it slightly behind the first.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_shadow_219_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_shadow(void)
 */
static PyObject *Dtool_TextProperties_clear_shadow_220(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_shadow")) {
    return NULL;
  }
  // 1-inline void TextProperties::clear_shadow(void)
  (*local_this).clear_shadow();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_shadow_220_comment =
  "C++ Interface:\n"
  "clear_shadow(const TextProperties self)\n"
  "\n"
  "/**\n"
  " * Specifies that a shadow will not be drawn behind the text.\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_shadow_220_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_shadow(void) const
 */
static PyObject *Dtool_TextProperties_has_shadow_221(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::has_shadow(void) const
  bool return_value = (*(const TextProperties*)local_this).has_shadow();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_shadow_221_comment =
  "C++ Interface:\n"
  "has_shadow(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_shadow_221_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2 TextProperties::get_shadow(void) const
 */
static PyObject *Dtool_TextProperties_get_shadow_222(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector2 TextProperties::get_shadow(void) const
  LVector2 *return_value = new LVector2((*(const TextProperties*)local_this).get_shadow());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_shadow_222_comment =
  "C++ Interface:\n"
  "get_shadow(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the offset of the shadow as set by set_shadow().  It is an error to\n"
  " * call this if has_shadow() is false.\n"
  " */";
#else
static const char *Dtool_TextProperties_get_shadow_222_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_bin(std::string const &bin)
 */
static PyObject *Dtool_TextProperties_set_bin_223(PyObject *self, PyObject *arg) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_bin")) {
    return NULL;
  }
  // 1-inline void TextProperties::set_bin(std::string const &bin)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_bin(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bin(const TextProperties self, str bin)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_bin_223_comment =
  "C++ Interface:\n"
  "set_bin(const TextProperties self, str bin)\n"
  "\n"
  "/**\n"
  " * Names the CullBin that the text geometry should be assigned to.  If this is\n"
  " * set, then a CullBinAttrib will be created to explicitly place each\n"
  " * component in the named bin.\n"
  " *\n"
  " * The draw_order value will also be passed to each CullBinAttrib as\n"
  " * appropriate; this is particularly useful if this names a CullBinFixed, e.g.\n"
  " * \"fixed\".\n"
  " */";
#else
static const char *Dtool_TextProperties_set_bin_223_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_bin(void)
 */
static PyObject *Dtool_TextProperties_clear_bin_224(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_bin")) {
    return NULL;
  }
  // 1-inline void TextProperties::clear_bin(void)
  (*local_this).clear_bin();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_bin_224_comment =
  "C++ Interface:\n"
  "clear_bin(const TextProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the effect of a previous call to set_bin().  Text will be drawn in\n"
  " * whatever bin it would like to be drawn in, with no explicit ordering.\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_bin_224_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_bin(void) const
 */
static PyObject *Dtool_TextProperties_has_bin_225(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::has_bin(void) const
  bool return_value = (*(const TextProperties*)local_this).has_bin();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_bin_225_comment =
  "C++ Interface:\n"
  "has_bin(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if an explicit drawing bin has been set via set_bin(), false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_TextProperties_has_bin_225_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &TextProperties::get_bin(void) const
 */
static PyObject *Dtool_TextProperties_get_bin_226(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &TextProperties::get_bin(void) const
  std::string const &return_value = (*(const TextProperties*)local_this).get_bin();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_bin_226_comment =
  "C++ Interface:\n"
  "get_bin(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the drawing bin set with set_bin(), or empty string if no bin has\n"
  " * been set.\n"
  " */";
#else
static const char *Dtool_TextProperties_get_bin_226_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int TextProperties::set_draw_order(int draw_order)
 */
static PyObject *Dtool_TextProperties_set_draw_order_227(PyObject *self, PyObject *arg) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_draw_order")) {
    return NULL;
  }
  // 1-inline int TextProperties::set_draw_order(int draw_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*local_this).set_draw_order((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_draw_order(const TextProperties self, int draw_order)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_draw_order_227_comment =
  "C++ Interface:\n"
  "set_draw_order(const TextProperties self, int draw_order)\n"
  "\n"
  "/**\n"
  " * Sets the drawing order of text created by the TextNode.  This is actually\n"
  " * the draw order of the card and frame.  The shadow is drawn at\n"
  " * _draw_order+1, and the text at _draw_order+2.\n"
  " *\n"
  " * This affects the sorting order assigned to the nodes as they are created,\n"
  " * and also is passed to whatever bin may be assigned via set_bin().\n"
  " *\n"
  " * The return value is the first unused draw_order number, e.g.  _draw_order +\n"
  " * 3.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_draw_order_227_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_draw_order(void)
 */
static PyObject *Dtool_TextProperties_clear_draw_order_228(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_draw_order")) {
    return NULL;
  }
  // 1-inline void TextProperties::clear_draw_order(void)
  (*local_this).clear_draw_order();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_draw_order_228_comment =
  "C++ Interface:\n"
  "clear_draw_order(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_draw_order_228_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_draw_order(void) const
 */
static PyObject *Dtool_TextProperties_has_draw_order_229(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::has_draw_order(void) const
  bool return_value = (*(const TextProperties*)local_this).has_draw_order();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_draw_order_229_comment =
  "C++ Interface:\n"
  "has_draw_order(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_draw_order_229_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int TextProperties::get_draw_order(void) const
 */
static PyObject *Dtool_TextProperties_get_draw_order_230(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int TextProperties::get_draw_order(void) const
  int return_value = (*(const TextProperties*)local_this).get_draw_order();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_draw_order_230_comment =
  "C++ Interface:\n"
  "get_draw_order(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the drawing order set with set_draw_order().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_draw_order_230_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_tab_width(PN_stdfloat tab_width)
 */
static PyObject *Dtool_TextProperties_set_tab_width_231(PyObject *self, PyObject *arg) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_tab_width")) {
    return NULL;
  }
  // 1-inline void TextProperties::set_tab_width(PN_stdfloat tab_width)
  if (PyNumber_Check(arg)) {
    (*local_this).set_tab_width((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tab_width(const TextProperties self, float tab_width)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_tab_width_231_comment =
  "C++ Interface:\n"
  "set_tab_width(const TextProperties self, float tab_width)\n"
  "\n"
  "/**\n"
  " * Sets the width of each tab stop, in screen units.  A tab character embedded\n"
  " * in the text will advance the horizontal position to the next tab stop.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_tab_width_231_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_tab_width(void)
 */
static PyObject *Dtool_TextProperties_clear_tab_width_232(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_tab_width")) {
    return NULL;
  }
  // 1-inline void TextProperties::clear_tab_width(void)
  (*local_this).clear_tab_width();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_tab_width_232_comment =
  "C++ Interface:\n"
  "clear_tab_width(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_tab_width_232_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_tab_width(void) const
 */
static PyObject *Dtool_TextProperties_has_tab_width_233(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::has_tab_width(void) const
  bool return_value = (*(const TextProperties*)local_this).has_tab_width();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_tab_width_233_comment =
  "C++ Interface:\n"
  "has_tab_width(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_tab_width_233_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextProperties::get_tab_width(void) const
 */
static PyObject *Dtool_TextProperties_get_tab_width_234(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextProperties::get_tab_width(void) const
  PN_stdfloat return_value = (*(const TextProperties*)local_this).get_tab_width();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_tab_width_234_comment =
  "C++ Interface:\n"
  "get_tab_width(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the width set via set_tab_width().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_tab_width_234_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_glyph_scale(PN_stdfloat glyph_scale)
 */
static PyObject *Dtool_TextProperties_set_glyph_scale_235(PyObject *self, PyObject *arg) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_glyph_scale")) {
    return NULL;
  }
  // 1-inline void TextProperties::set_glyph_scale(PN_stdfloat glyph_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_glyph_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_glyph_scale(const TextProperties self, float glyph_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_glyph_scale_235_comment =
  "C++ Interface:\n"
  "set_glyph_scale(const TextProperties self, float glyph_scale)\n"
  "\n"
  "/**\n"
  " * Specifies the factor by which to scale each letter of the text as it is\n"
  " * placed, in addition to any scales inherited from the node or from\n"
  " * set_text_scale(). This can be used (possibly in conjunction with\n"
  " * set_glyph_shift()) to implement superscripting or subscripting.\n"
  " *\n"
  " * The glyph scale is cumulative when applied to nested TextProperties.  It is\n"
  " * intended primarily for implementing superscripts, not for scaling the text\n"
  " * in general.  See also set_text_scale(), which is intended primarily for\n"
  " * scaling the text in general, and is not cumulative.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_glyph_scale_235_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_glyph_scale(void)
 */
static PyObject *Dtool_TextProperties_clear_glyph_scale_236(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_glyph_scale")) {
    return NULL;
  }
  // 1-inline void TextProperties::clear_glyph_scale(void)
  (*local_this).clear_glyph_scale();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_glyph_scale_236_comment =
  "C++ Interface:\n"
  "clear_glyph_scale(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_glyph_scale_236_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_glyph_scale(void) const
 */
static PyObject *Dtool_TextProperties_has_glyph_scale_237(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::has_glyph_scale(void) const
  bool return_value = (*(const TextProperties*)local_this).has_glyph_scale();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_glyph_scale_237_comment =
  "C++ Interface:\n"
  "has_glyph_scale(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_glyph_scale_237_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextProperties::get_glyph_scale(void) const
 */
static PyObject *Dtool_TextProperties_get_glyph_scale_238(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextProperties::get_glyph_scale(void) const
  PN_stdfloat return_value = (*(const TextProperties*)local_this).get_glyph_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_glyph_scale_238_comment =
  "C++ Interface:\n"
  "get_glyph_scale(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the scale factor of each letter as specified by set_glyph_scale().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_glyph_scale_238_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_glyph_shift(PN_stdfloat glyph_shift)
 */
static PyObject *Dtool_TextProperties_set_glyph_shift_239(PyObject *self, PyObject *arg) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_glyph_shift")) {
    return NULL;
  }
  // 1-inline void TextProperties::set_glyph_shift(PN_stdfloat glyph_shift)
  if (PyNumber_Check(arg)) {
    (*local_this).set_glyph_shift((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_glyph_shift(const TextProperties self, float glyph_shift)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_glyph_shift_239_comment =
  "C++ Interface:\n"
  "set_glyph_shift(const TextProperties self, float glyph_shift)\n"
  "\n"
  "/**\n"
  " * Specifies a vertical amount to shift each letter of the text as it is\n"
  " * placed.  This can be used (possibly in conjunction with set_glyph_scale())\n"
  " * to implement superscripting or subscripting.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_glyph_shift_239_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_glyph_shift(void)
 */
static PyObject *Dtool_TextProperties_clear_glyph_shift_240(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_glyph_shift")) {
    return NULL;
  }
  // 1-inline void TextProperties::clear_glyph_shift(void)
  (*local_this).clear_glyph_shift();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_glyph_shift_240_comment =
  "C++ Interface:\n"
  "clear_glyph_shift(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_glyph_shift_240_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_glyph_shift(void) const
 */
static PyObject *Dtool_TextProperties_has_glyph_shift_241(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::has_glyph_shift(void) const
  bool return_value = (*(const TextProperties*)local_this).has_glyph_shift();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_glyph_shift_241_comment =
  "C++ Interface:\n"
  "has_glyph_shift(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_glyph_shift_241_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextProperties::get_glyph_shift(void) const
 */
static PyObject *Dtool_TextProperties_get_glyph_shift_242(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextProperties::get_glyph_shift(void) const
  PN_stdfloat return_value = (*(const TextProperties*)local_this).get_glyph_shift();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_glyph_shift_242_comment =
  "C++ Interface:\n"
  "get_glyph_shift(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the vertical shift of each letter as specified by\n"
  " * set_glyph_shift().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_glyph_shift_242_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::set_text_scale(PN_stdfloat text_scale)
 */
static PyObject *Dtool_TextProperties_set_text_scale_243(PyObject *self, PyObject *arg) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.set_text_scale")) {
    return NULL;
  }
  // 1-inline void TextProperties::set_text_scale(PN_stdfloat text_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_text_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_text_scale(const TextProperties self, float text_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_set_text_scale_243_comment =
  "C++ Interface:\n"
  "set_text_scale(const TextProperties self, float text_scale)\n"
  "\n"
  "/**\n"
  " * Specifies the factor by which to scale the text, in addition to any\n"
  " * scalings imposed by the node, as well as in addition to the glyph scale.\n"
  " *\n"
  " * The text scale is not cumulative when applied to nested TextProperties.\n"
  " * See also set_glyph_scale(), which is cumulative.\n"
  " */";
#else
static const char *Dtool_TextProperties_set_text_scale_243_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextProperties::clear_text_scale(void)
 */
static PyObject *Dtool_TextProperties_clear_text_scale_244(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.clear_text_scale")) {
    return NULL;
  }
  // 1-inline void TextProperties::clear_text_scale(void)
  (*local_this).clear_text_scale();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_clear_text_scale_244_comment =
  "C++ Interface:\n"
  "clear_text_scale(const TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_clear_text_scale_244_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextProperties::has_text_scale(void) const
 */
static PyObject *Dtool_TextProperties_has_text_scale_245(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextProperties::has_text_scale(void) const
  bool return_value = (*(const TextProperties*)local_this).has_text_scale();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_has_text_scale_245_comment =
  "C++ Interface:\n"
  "has_text_scale(TextProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_has_text_scale_245_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextProperties::get_text_scale(void) const
 */
static PyObject *Dtool_TextProperties_get_text_scale_246(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextProperties::get_text_scale(void) const
  PN_stdfloat return_value = (*(const TextProperties*)local_this).get_text_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_text_scale_246_comment =
  "C++ Interface:\n"
  "get_text_scale(TextProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the scale factor of the text as specified by set_text_scale().\n"
  " */";
#else
static const char *Dtool_TextProperties_get_text_scale_246_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void TextProperties::add_properties(TextProperties const &other)
 */
static PyObject *Dtool_TextProperties_add_properties_247(PyObject *self, PyObject *arg) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.add_properties")) {
    return NULL;
  }
  // 1-void TextProperties::add_properties(TextProperties const &other)
  TextProperties const *arg_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextProperties, 1, "TextProperties.add_properties", true, true);
  if (arg_this != NULL) {
    (*local_this).add_properties(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_properties(const TextProperties self, const TextProperties other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_add_properties_247_comment =
  "C++ Interface:\n"
  "add_properties(const TextProperties self, const TextProperties other)\n"
  "\n"
  "/**\n"
  " * Sets any properties that are explicitly specified in other on this object.\n"
  " * Leaves other properties unchanged.\n"
  " */";
#else
static const char *Dtool_TextProperties_add_properties_247_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void TextProperties::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_TextProperties_write_248(PyObject *self, PyObject *args, PyObject *kwds) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }
  // 1-void TextProperties::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "TextProperties.write", false, true);
    if (param1_this != NULL) {
      (*(const TextProperties*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(TextProperties self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_write_248_comment =
  "C++ Interface:\n"
  "write(TextProperties self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextProperties_write_248_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TextProperties::get_class_type(void)
 */
static PyObject *Dtool_TextProperties_get_class_type_274(PyObject *, PyObject *) {
  // 1-static TypeHandle TextProperties::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(TextProperties::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_get_class_type_274_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TextProperties_get_class_type_274_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TextNode *TextProperties::downcast_to_TextNode(void)
 */
static PyObject *Dtool_TextProperties_downcast_to_TextNode_357(PyObject *self, PyObject *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.downcast_to_TextNode")) {
    return NULL;
  }
  // 1-TextNode *TextProperties::downcast_to_TextNode(void)
  TextNode *return_value = (TextNode *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextProperties_downcast_to_TextNode_357_comment =
  "C++ Interface:\n"
  "downcast_to_TextNode(const TextProperties self)\n"
  "\n"
  "downcast from TextProperties to TextNode";
#else
static const char *Dtool_TextProperties_downcast_to_TextNode_357_comment = NULL;
#endif

static PyObject *Dtool_TextProperties_font_Getter(PyObject *self, void *) {
  const TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_font()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline TextFont *TextProperties::get_font(void) const
  TextFont *return_value = (*(const TextProperties*)local_this).get_font();
  if (return_value != (TextFont *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (TextFont *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextFont, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_TextProperties_font_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.font")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete font attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_font();
    return 0;
  }
  // 1-inline void TextProperties::set_font(TextFont *font)
  TextFont *arg_this = (TextFont *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextFont, 1, "TextProperties.set_font", false, true);
  if (arg_this != NULL) {
    (*local_this).set_font(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_font(const TextProperties self, TextFont font)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_small_caps_Getter(PyObject *self, void *) {
  const TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_small_caps()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool TextProperties::get_small_caps(void) const
  bool return_value = (*(const TextProperties*)local_this).get_small_caps();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_small_caps_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.small_caps")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete small_caps attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_small_caps();
    return 0;
  }
  // 1-inline void TextProperties::set_small_caps(bool small_caps)
  (*local_this).set_small_caps((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_small_caps(const TextProperties self, bool small_caps)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_small_caps_scale_Getter(PyObject *self, void *) {
  const TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_small_caps_scale()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextProperties::get_small_caps_scale(void) const
  PN_stdfloat return_value = (*(const TextProperties*)local_this).get_small_caps_scale();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_small_caps_scale_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.small_caps_scale")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete small_caps_scale attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_small_caps_scale();
    return 0;
  }
  // 1-inline void TextProperties::set_small_caps_scale(PN_stdfloat small_caps_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_small_caps_scale((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_small_caps_scale(const TextProperties self, float small_caps_scale)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_slant_Getter(PyObject *self, void *) {
  const TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_slant()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextProperties::get_slant(void) const
  PN_stdfloat return_value = (*(const TextProperties*)local_this).get_slant();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_slant_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.slant")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete slant attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_slant();
    return 0;
  }
  // 1-inline void TextProperties::set_slant(PN_stdfloat slant)
  if (PyNumber_Check(arg)) {
    (*local_this).set_slant((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_slant(const TextProperties self, float slant)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_underscore_Getter(PyObject *self, void *) {
  const TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_underscore()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool TextProperties::get_underscore(void) const
  bool return_value = (*(const TextProperties*)local_this).get_underscore();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_underscore_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.underscore")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete underscore attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_underscore();
    return 0;
  }
  // 1-inline void TextProperties::set_underscore(bool underscore)
  (*local_this).set_underscore((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_underscore(const TextProperties self, bool underscore)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_underscore_height_Getter(PyObject *self, void *) {
  const TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_underscore_height()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextProperties::get_underscore_height(void) const
  PN_stdfloat return_value = (*(const TextProperties*)local_this).get_underscore_height();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_underscore_height_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.underscore_height")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete underscore_height attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_underscore_height();
    return 0;
  }
  // 1-inline void TextProperties::set_underscore_height(PN_stdfloat underscore_height)
  if (PyNumber_Check(arg)) {
    (*local_this).set_underscore_height((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_underscore_height(const TextProperties self, float underscore_height)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_align_Getter(PyObject *self, void *) {
  const TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_align()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline TextProperties::Alignment TextProperties::get_align(void) const
  TextProperties::Alignment return_value = (*(const TextProperties*)local_this).get_align();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_align_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.align")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete align attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_align();
    return 0;
  }
  // 1-inline void TextProperties::set_align(TextProperties::Alignment align_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_align((TextProperties::Alignment)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_align(const TextProperties self, int align_type)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_indent_Getter(PyObject *self, void *) {
  const TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_indent()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextProperties::get_indent(void) const
  PN_stdfloat return_value = (*(const TextProperties*)local_this).get_indent();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_indent_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.indent")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete indent attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_indent();
    return 0;
  }
  // 1-inline void TextProperties::set_indent(PN_stdfloat indent)
  if (PyNumber_Check(arg)) {
    (*local_this).set_indent((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_indent(const TextProperties self, float indent)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_wordwrap_Getter(PyObject *self, void *) {
  const TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_wordwrap()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextProperties::get_wordwrap(void) const
  PN_stdfloat return_value = (*(const TextProperties*)local_this).get_wordwrap();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_wordwrap_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.wordwrap")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete wordwrap attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_wordwrap();
    return 0;
  }
  // 1-inline void TextProperties::set_wordwrap(PN_stdfloat wordwrap)
  if (PyNumber_Check(arg)) {
    (*local_this).set_wordwrap((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_wordwrap(const TextProperties self, float wordwrap)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_preserve_trailing_whitespace_Getter(PyObject *self, void *) {
  const TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_preserve_trailing_whitespace()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool TextProperties::get_preserve_trailing_whitespace(void) const
  bool return_value = (*(const TextProperties*)local_this).get_preserve_trailing_whitespace();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_preserve_trailing_whitespace_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.preserve_trailing_whitespace")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete preserve_trailing_whitespace attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_preserve_trailing_whitespace();
    return 0;
  }
  // 1-inline void TextProperties::set_preserve_trailing_whitespace(bool preserve_trailing_whitespace)
  (*local_this).set_preserve_trailing_whitespace((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_preserve_trailing_whitespace(const TextProperties self, bool preserve_trailing_whitespace)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_text_color_Getter(PyObject *self, void *) {
  const TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_text_color()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor TextProperties::get_text_color(void) const
  LColor *return_value = new LColor((*(const TextProperties*)local_this).get_text_color());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_TextProperties_text_color_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.text_color")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete text_color attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_text_color();
    return 0;
  }
  // 1-inline void TextProperties::set_text_color(LColor const &text_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextProperties.set_text_color", "LVecBase4f");
    return -1;
  }
  (*local_this).set_text_color(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_text_color(const TextProperties self, const LVecBase4f text_color)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_shadow_color_Getter(PyObject *self, void *) {
  const TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_shadow_color()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor TextProperties::get_shadow_color(void) const
  LColor *return_value = new LColor((*(const TextProperties*)local_this).get_shadow_color());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_TextProperties_shadow_color_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.shadow_color")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete shadow_color attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_shadow_color();
    return 0;
  }
  // 1-inline void TextProperties::set_shadow_color(LColor const &shadow_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextProperties.set_shadow_color", "LVecBase4f");
    return -1;
  }
  (*local_this).set_shadow_color(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_shadow_color(const TextProperties self, const LVecBase4f shadow_color)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_shadow_Getter(PyObject *self, void *) {
  const TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_shadow()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LVector2 TextProperties::get_shadow(void) const
  LVector2 *return_value = new LVector2((*(const TextProperties*)local_this).get_shadow());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

static int Dtool_TextProperties_shadow_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.shadow")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete shadow attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_shadow();
    return 0;
  }
  // 1-inline void TextProperties::set_shadow(LVecBase2 const &shadow_offset)
  LVecBase2f arg_local;
  LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextProperties.set_shadow", "LVecBase2f");
    return -1;
  }
  (*local_this).set_shadow(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_shadow(const TextProperties self, const LVecBase2f shadow_offset)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_bin_Getter(PyObject *self, void *) {
  const TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_bin()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline std::string const &TextProperties::get_bin(void) const
  std::string const &return_value = (*(const TextProperties*)local_this).get_bin();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_bin_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.bin")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete bin attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_bin();
    return 0;
  }
  // 1-inline void TextProperties::set_bin(std::string const &bin)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_bin(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bin(const TextProperties self, str bin)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_draw_order_Getter(PyObject *self, void *) {
  const TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_draw_order()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline int TextProperties::get_draw_order(void) const
  int return_value = (*(const TextProperties*)local_this).get_draw_order();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_draw_order_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.draw_order")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete draw_order attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_draw_order();
    return 0;
  }
  // 1-inline int TextProperties::set_draw_order(int draw_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    int return_value = (*local_this).set_draw_order((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return return_value;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_draw_order(const TextProperties self, int draw_order)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_tab_width_Getter(PyObject *self, void *) {
  const TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_tab_width()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextProperties::get_tab_width(void) const
  PN_stdfloat return_value = (*(const TextProperties*)local_this).get_tab_width();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_tab_width_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.tab_width")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete tab_width attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_tab_width();
    return 0;
  }
  // 1-inline void TextProperties::set_tab_width(PN_stdfloat tab_width)
  if (PyNumber_Check(arg)) {
    (*local_this).set_tab_width((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_tab_width(const TextProperties self, float tab_width)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_glyph_scale_Getter(PyObject *self, void *) {
  const TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_glyph_scale()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextProperties::get_glyph_scale(void) const
  PN_stdfloat return_value = (*(const TextProperties*)local_this).get_glyph_scale();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_glyph_scale_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.glyph_scale")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete glyph_scale attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_glyph_scale();
    return 0;
  }
  // 1-inline void TextProperties::set_glyph_scale(PN_stdfloat glyph_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_glyph_scale((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_glyph_scale(const TextProperties self, float glyph_scale)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_glyph_shift_Getter(PyObject *self, void *) {
  const TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_glyph_shift()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextProperties::get_glyph_shift(void) const
  PN_stdfloat return_value = (*(const TextProperties*)local_this).get_glyph_shift();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_glyph_shift_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.glyph_shift")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete glyph_shift attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_glyph_shift();
    return 0;
  }
  // 1-inline void TextProperties::set_glyph_shift(PN_stdfloat glyph_shift)
  if (PyNumber_Check(arg)) {
    (*local_this).set_glyph_shift((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_glyph_shift(const TextProperties self, float glyph_shift)\n");
  }
  return -1;
}

static PyObject *Dtool_TextProperties_text_scale_Getter(PyObject *self, void *) {
  const TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_text_scale()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextProperties::get_text_scale(void) const
  PN_stdfloat return_value = (*(const TextProperties*)local_this).get_text_scale();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextProperties_text_scale_Setter(PyObject *self, PyObject *arg, void *) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextProperties, (void **)&local_this, "TextProperties.text_scale")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete text_scale attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_text_scale();
    return 0;
  }
  // 1-inline void TextProperties::set_text_scale(PN_stdfloat text_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_text_scale((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_text_scale(const TextProperties self, float text_scale)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * TextProperties::TextProperties(void)
 * TextProperties::TextProperties(TextProperties const &copy)
 */
static int Dtool_Init_TextProperties(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-TextProperties::TextProperties(void)
      TextProperties *return_value = new TextProperties();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextProperties, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-TextProperties::TextProperties(TextProperties const &copy)
      TextProperties const *arg_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextProperties, 0, "TextProperties.TextProperties", true, true);
      if (arg_this != NULL) {
        TextProperties *return_value = new TextProperties(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextProperties, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TextProperties() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TextProperties()\n"
      "TextProperties(const TextProperties copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TextProperties(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TextProperties) {
    printf("TextProperties ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TextProperties *local_this = (TextProperties *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TextProperties) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TextProperties(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TextProperties) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class TextGraphic
 */
/**
 * Python function wrapper for:
 * inline NodePath TextGraphic::get_model(void) const
 */
static PyObject *Dtool_TextGraphic_get_model_278(PyObject *self, PyObject *) {
  TextGraphic *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGraphic, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath TextGraphic::get_model(void) const
  NodePath *return_value = new NodePath((*(const TextGraphic*)local_this).get_model());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextGraphic_get_model_278_comment =
  "C++ Interface:\n"
  "get_model(TextGraphic self)\n"
  "\n"
  "/**\n"
  " * Returns the NodePath associated with the graphic, that renders the desired\n"
  " * image.\n"
  " */";
#else
static const char *Dtool_TextGraphic_get_model_278_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextGraphic::set_model(NodePath const &model)
 */
static PyObject *Dtool_TextGraphic_set_model_279(PyObject *self, PyObject *arg) {
  TextGraphic *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextGraphic, (void **)&local_this, "TextGraphic.set_model")) {
    return NULL;
  }
  // 1-inline void TextGraphic::set_model(NodePath const &model)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "TextGraphic.set_model", true, true);
  if (arg_this != NULL) {
    (*local_this).set_model(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_model(const TextGraphic self, const NodePath model)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextGraphic_set_model_279_comment =
  "C++ Interface:\n"
  "set_model(const TextGraphic self, const NodePath model)\n"
  "\n"
  "/**\n"
  " * Changes the NodePath associated with the graphic.  This NodePath should\n"
  " * contain geometry that will render the desired graphic image.\n"
  " */";
#else
static const char *Dtool_TextGraphic_set_model_279_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 TextGraphic::get_frame(void) const
 */
static PyObject *Dtool_TextGraphic_get_frame_282(PyObject *self, PyObject *) {
  TextGraphic *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGraphic, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4 TextGraphic::get_frame(void) const
  LVecBase4 *return_value = new LVecBase4((*(const TextGraphic*)local_this).get_frame());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextGraphic_get_frame_282_comment =
  "C++ Interface:\n"
  "get_frame(TextGraphic self)\n"
  "\n"
  "/**\n"
  " * Returns the frame specified for the graphic.  This is the amount of space\n"
  " * that will be reserved for the graphic when it is embedded in a text\n"
  " * paragraph, in the form (left, right, bottom, top).\n"
  " *\n"
  " * The actual graphic, as rendered by the NodePath specified via set_model(),\n"
  " * should more or less fit within this rectangle.  It is not required to fit\n"
  " * completely within it, but if it does not, it may visually overlap with\n"
  " * nearby text.\n"
  " */";
#else
static const char *Dtool_TextGraphic_get_frame_282_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextGraphic::set_frame(LVecBase4 const &frame)
 * inline void TextGraphic::set_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 */
static PyObject *Dtool_TextGraphic_set_frame_283(PyObject *self, PyObject *args, PyObject *kwds) {
  TextGraphic *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextGraphic, (void **)&local_this, "TextGraphic.set_frame")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "frame");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'frame' (pos 1) not found");
      }
      // 1-inline void TextGraphic::set_frame(LVecBase4 const &frame)
      LVecBase4f arg_local;
      LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "TextGraphic.set_frame", "LVecBase4f");
      }
      (*local_this).set_frame(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void TextGraphic::set_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"left", "right", "bottom", "top", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_frame", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_frame((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_frame() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame(const TextGraphic self, const LVecBase4f frame)\n"
      "set_frame(const TextGraphic self, float left, float right, float bottom, float top)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextGraphic_set_frame_283_comment =
  "C++ Interface:\n"
  "set_frame(const TextGraphic self, const LVecBase4f frame)\n"
  "set_frame(const TextGraphic self, float left, float right, float bottom, float top)\n"
  "\n"
  "/**\n"
  " * Specifies the (left, right, bottom, top) bounding frame for the graphic.\n"
  " * See get_frame().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies the (left, right, bottom, top) bounding frame for the graphic.\n"
  " * See get_frame().\n"
  " */";
#else
static const char *Dtool_TextGraphic_set_frame_283_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextGraphic::get_instance_flag(void) const
 */
static PyObject *Dtool_TextGraphic_get_instance_flag_286(PyObject *self, PyObject *) {
  TextGraphic *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGraphic, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextGraphic::get_instance_flag(void) const
  bool return_value = (*(const TextGraphic*)local_this).get_instance_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextGraphic_get_instance_flag_286_comment =
  "C++ Interface:\n"
  "get_instance_flag(TextGraphic self)\n"
  "\n"
  "/**\n"
  " * Returns the instance_flag.  See set_instance_flag().\n"
  " */";
#else
static const char *Dtool_TextGraphic_get_instance_flag_286_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextGraphic::set_instance_flag(bool instance_flag)
 */
static PyObject *Dtool_TextGraphic_set_instance_flag_287(PyObject *self, PyObject *arg) {
  TextGraphic *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextGraphic, (void **)&local_this, "TextGraphic.set_instance_flag")) {
    return NULL;
  }
  // 1-inline void TextGraphic::set_instance_flag(bool instance_flag)
  (*local_this).set_instance_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_instance_flag(const TextGraphic self, bool instance_flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextGraphic_set_instance_flag_287_comment =
  "C++ Interface:\n"
  "set_instance_flag(const TextGraphic self, bool instance_flag)\n"
  "\n"
  "/**\n"
  " * Sets the instance_flag.  When this is true, the graphic is directly\n"
  " * instanced to the scene graph whenever it appears; when it is false, the\n"
  " * graphic is copied.  The default is false, which is best for most\n"
  " * applications.  You might need to set it true for special kinds of\n"
  " * \"graphics\" like interactive elements, for instance a PGEntry.\n"
  " */";
#else
static const char *Dtool_TextGraphic_set_instance_flag_287_comment = NULL;
#endif

static PyObject *Dtool_TextGraphic_model_Getter(PyObject *self, void *) {
  const TextGraphic *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGraphic, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline NodePath TextGraphic::get_model(void) const
  NodePath *return_value = new NodePath((*(const TextGraphic*)local_this).get_model());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

static int Dtool_TextGraphic_model_Setter(PyObject *self, PyObject *arg, void *) {
  TextGraphic *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextGraphic, (void **)&local_this, "TextGraphic.model")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete model attribute");
    return -1;
  }
  // 1-inline void TextGraphic::set_model(NodePath const &model)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "TextGraphic.set_model", true, true);
  if (arg_this != NULL) {
    (*local_this).set_model(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_model(const TextGraphic self, const NodePath model)\n");
  }
  return -1;
}

static PyObject *Dtool_TextGraphic_frame_Getter(PyObject *self, void *) {
  const TextGraphic *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGraphic, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase4 TextGraphic::get_frame(void) const
  LVecBase4 *return_value = new LVecBase4((*(const TextGraphic*)local_this).get_frame());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_TextGraphic_frame_Setter(PyObject *self, PyObject *arg, void *) {
  TextGraphic *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextGraphic, (void **)&local_this, "TextGraphic.frame")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete frame attribute");
    return -1;
  }
  // 1-inline void TextGraphic::set_frame(LVecBase4 const &frame)
  LVecBase4f arg_local;
  LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextGraphic.set_frame", "LVecBase4f");
    return -1;
  }
  (*local_this).set_frame(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_frame(const TextGraphic self, const LVecBase4f frame)\n");
  }
  return -1;
}

static PyObject *Dtool_TextGraphic_instance_flag_Getter(PyObject *self, void *) {
  const TextGraphic *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextGraphic, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool TextGraphic::get_instance_flag(void) const
  bool return_value = (*(const TextGraphic*)local_this).get_instance_flag();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextGraphic_instance_flag_Setter(PyObject *self, PyObject *arg, void *) {
  TextGraphic *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextGraphic, (void **)&local_this, "TextGraphic.instance_flag")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete instance_flag attribute");
    return -1;
  }
  // 1-inline void TextGraphic::set_instance_flag(bool instance_flag)
  (*local_this).set_instance_flag((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_instance_flag(const TextGraphic self, bool instance_flag)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline TextGraphic::TextGraphic(void)
 * inline TextGraphic::TextGraphic(NodePath const &model, LVecBase4 const &frame)
 * inline TextGraphic::TextGraphic(NodePath const &model, PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 * inline TextGraphic::TextGraphic(TextGraphic const &) = default
 */
static int Dtool_Init_TextGraphic(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline TextGraphic::TextGraphic(void)
      TextGraphic *return_value = new TextGraphic();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextGraphic, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline TextGraphic::TextGraphic(TextGraphic const &) = default
      TextGraphic const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_TextGraphic(arg, arg_this, arg_manage)) {
        Dtool_Raise_ArgTypeError(arg, 0, "TextGraphic.TextGraphic", "TextGraphic");
        return -1;
      }
      TextGraphic *return_value = new TextGraphic(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextGraphic, true, false);
    }
    break;
  case 2:
    {
      // 1-inline TextGraphic::TextGraphic(NodePath const &model, LVecBase4 const &frame)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"model", "frame", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:TextGraphic", (char **)keyword_list, &param0, &param1)) {
        NodePath const *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_NodePath, 0, "TextGraphic.TextGraphic", true, true);
        LVecBase4f param1_local;
        LVecBase4 const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "TextGraphic.TextGraphic", "LVecBase4f");
          return -1;
        }
        if (param0_this != NULL) {
          TextGraphic *return_value = new TextGraphic(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextGraphic, true, false);
        }
      }
    }
    break;
  case 5:
    {
      // 1-inline TextGraphic::TextGraphic(NodePath const &model, PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
      PyObject *param0;
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"model", "left", "right", "bottom", "top", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offff:TextGraphic", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
        NodePath const *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_NodePath, 0, "TextGraphic.TextGraphic", true, true);
        if (param0_this != NULL) {
          TextGraphic *return_value = new TextGraphic(*param0_this, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextGraphic, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TextGraphic() takes 0, 1, 2 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TextGraphic()\n"
      "TextGraphic(const TextGraphic param0)\n"
      "TextGraphic(const NodePath model, const LVecBase4f frame)\n"
      "TextGraphic(const NodePath model, float left, float right, float bottom, float top)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_TextGraphic(PyObject *args, TextGraphic const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_TextGraphic, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline TextGraphic::TextGraphic(NodePath const &model, LVecBase4 const &frame)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "TextGraphic", 2, 2, &param0, &param1)) {
          NodePath const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_NodePath, (void **)&param0_this);
          LVecBase4 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase4f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            TextGraphic *return_value = new TextGraphic(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 5: {
        // 1-inline TextGraphic::TextGraphic(NodePath const &model, PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
        PyObject *param0;
        float param1;
        float param2;
        float param3;
        float param4;
        if (PyArg_ParseTuple(args, "Offff:TextGraphic", &param0, &param1, &param2, &param3, &param4)) {
          NodePath const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_NodePath, (void **)&param0_this);
          if (param0_this != NULL) {
            TextGraphic *return_value = new TextGraphic(*param0_this, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_TextGraphic(PyObject *args, TextGraphic *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_TextGraphic, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline TextGraphic::TextGraphic(NodePath const &model, LVecBase4 const &frame)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "TextGraphic", 2, 2, &param0, &param1)) {
          NodePath const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_NodePath, (void **)&param0_this);
          LVecBase4 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase4f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            TextGraphic *return_value = new TextGraphic(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 5: {
        // 1-inline TextGraphic::TextGraphic(NodePath const &model, PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
        PyObject *param0;
        float param1;
        float param2;
        float param3;
        float param4;
        if (PyArg_ParseTuple(args, "Offff:TextGraphic", &param0, &param1, &param2, &param3, &param4)) {
          NodePath const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_NodePath, (void **)&param0_this);
          if (param0_this != NULL) {
            TextGraphic *return_value = new TextGraphic(*param0_this, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_TextGraphic(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TextGraphic) {
    printf("TextGraphic ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TextGraphic *local_this = (TextGraphic *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TextGraphic) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TextGraphic(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TextGraphic) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class TextPropertiesManager
 */
/**
 * Python function wrapper for:
 * void TextPropertiesManager::set_properties(std::string const &name, TextProperties const &properties)
 */
static PyObject *Dtool_TextPropertiesManager_set_properties_291(PyObject *self, PyObject *args, PyObject *kwds) {
  TextPropertiesManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextPropertiesManager, (void **)&local_this, "TextPropertiesManager.set_properties")) {
    return NULL;
  }
  // 1-void TextPropertiesManager::set_properties(std::string const &name, TextProperties const &properties)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"name", "properties", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_properties", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    TextProperties const *param2_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TextProperties, 2, "TextPropertiesManager.set_properties", true, true);
    if (param2_this != NULL) {
      (*local_this).set_properties(std::string(param1_str, param1_len), *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_properties(const TextPropertiesManager self, str name, const TextProperties properties)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_set_properties_291_comment =
  "C++ Interface:\n"
  "set_properties(const TextPropertiesManager self, str name, const TextProperties properties)\n"
  "\n"
  "/**\n"
  " * Defines the TextProperties associated with the indicated name.  When the\n"
  " * name is subsequently encountered in text embedded between \\1 characters in\n"
  " * a TextNode string, the following text will be rendered with these\n"
  " * properties.\n"
  " *\n"
  " * If there was already a TextProperties structure associated with this name,\n"
  " * it is quietly replaced with the new definition.\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_set_properties_291_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TextProperties TextPropertiesManager::get_properties(std::string const &name)
 */
static PyObject *Dtool_TextPropertiesManager_get_properties_292(PyObject *self, PyObject *arg) {
  TextPropertiesManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextPropertiesManager, (void **)&local_this, "TextPropertiesManager.get_properties")) {
    return NULL;
  }
  // 1-TextProperties TextPropertiesManager::get_properties(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    TextProperties *return_value = new TextProperties((*local_this).get_properties(std::string(param1_str, param1_len)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextProperties, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_properties(const TextPropertiesManager self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_get_properties_292_comment =
  "C++ Interface:\n"
  "get_properties(const TextPropertiesManager self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the TextProperties associated with the indicated name.  If there\n"
  " * was not previously a TextProperties associated with this name, a warning is\n"
  " * printed and then a default TextProperties structure is associated with the\n"
  " * name, and returned.\n"
  " *\n"
  " * Call has_properties() instead to check whether a particular name has been\n"
  " * defined.\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_get_properties_292_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool TextPropertiesManager::has_properties(std::string const &name) const
 */
static PyObject *Dtool_TextPropertiesManager_has_properties_293(PyObject *self, PyObject *arg) {
  TextPropertiesManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextPropertiesManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool TextPropertiesManager::has_properties(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*(const TextPropertiesManager*)local_this).has_properties(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_properties(TextPropertiesManager self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_has_properties_293_comment =
  "C++ Interface:\n"
  "has_properties(TextPropertiesManager self, str name)\n"
  "\n"
  "/**\n"
  " * Returns true if a TextProperties structure has been associated with the\n"
  " * indicated name, false otherwise.  Normally this means set_properties() has\n"
  " * been called with this name, but because get_properties() will implicitly\n"
  " * create a default TextProperties structure, it may also mean simply that\n"
  " * get_properties() has been called with the indicated name.\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_has_properties_293_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void TextPropertiesManager::clear_properties(std::string const &name)
 */
static PyObject *Dtool_TextPropertiesManager_clear_properties_294(PyObject *self, PyObject *arg) {
  TextPropertiesManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextPropertiesManager, (void **)&local_this, "TextPropertiesManager.clear_properties")) {
    return NULL;
  }
  // 1-void TextPropertiesManager::clear_properties(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).clear_properties(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_properties(const TextPropertiesManager self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_clear_properties_294_comment =
  "C++ Interface:\n"
  "clear_properties(const TextPropertiesManager self, str name)\n"
  "\n"
  "/**\n"
  " * Removes the named TextProperties structure from the manager.\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_clear_properties_294_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void TextPropertiesManager::set_graphic(std::string const &name, NodePath const &model)
 * void TextPropertiesManager::set_graphic(std::string const &name, TextGraphic const &graphic)
 */
static PyObject *Dtool_TextPropertiesManager_set_graphic_295(PyObject *self, PyObject *args, PyObject *kwds) {
  TextPropertiesManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextPropertiesManager, (void **)&local_this, "TextPropertiesManager.set_graphic")) {
    return NULL;
  }
  {
    // -2 void TextPropertiesManager::set_graphic(std::string const &name, NodePath const &model)
    char *param1_str = NULL;
    Py_ssize_t param1_len;
    PyObject *param2;
    static const char *keyword_list[] = {"name", "model", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_graphic", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
      NodePath const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_NodePath, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_graphic(std::string(param1_str, param1_len), *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: void TextPropertiesManager::set_graphic(std::string const &name, NodePath const &model)
  {
    // -2 void TextPropertiesManager::set_graphic(std::string const &name, TextGraphic const &graphic)
    char *param1_str = NULL;
    Py_ssize_t param1_len;
    PyObject *param2;
    static const char *keyword_list[] = {"name", "graphic", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_graphic", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
      TextGraphic const *param2_this;
      bool param2_manage = false;
      if (Dtool_ConstCoerce_TextGraphic(param2, param2_this, param2_manage)) {
        (*local_this).set_graphic(std::string(param1_str, param1_len), *param2_this);
        if (param2_manage) {
          delete param2_this;
        }
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_graphic(const TextPropertiesManager self, str name, const NodePath model)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_set_graphic_295_comment =
  "C++ Interface:\n"
  "set_graphic(const TextPropertiesManager self, str name, const NodePath model)\n"
  "\n"
  "/**\n"
  " * Defines the TextGraphic associated with the indicated name.  When the name\n"
  " * is subsequently encountered in text embedded between \\5 characters in a\n"
  " * TextNode string, the specified graphic will be embedded in the text at that\n"
  " * point.\n"
  " *\n"
  " * If there was already a TextGraphic structure associated with this name, it\n"
  " * is quietly replaced with the new definition.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of set_graphic implicitly creates a frame for the model using\n"
  " * the model's actual computed bounding volume, as derived from\n"
  " * NodePath::calc_tight_bounds().  Create a TextGraphic object first if you\n"
  " * want to have explicit control of the frame.\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_set_graphic_295_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TextGraphic TextPropertiesManager::get_graphic(std::string const &name)
 */
static PyObject *Dtool_TextPropertiesManager_get_graphic_296(PyObject *self, PyObject *arg) {
  TextPropertiesManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextPropertiesManager, (void **)&local_this, "TextPropertiesManager.get_graphic")) {
    return NULL;
  }
  // 1-TextGraphic TextPropertiesManager::get_graphic(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    TextGraphic *return_value = new TextGraphic((*local_this).get_graphic(std::string(param1_str, param1_len)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextGraphic, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_graphic(const TextPropertiesManager self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_get_graphic_296_comment =
  "C++ Interface:\n"
  "get_graphic(const TextPropertiesManager self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the TextGraphic associated with the indicated name.  If there was\n"
  " * not previously a TextGraphic associated with this name, a warning is\n"
  " * printed and then a default TextGraphic structure is associated with the\n"
  " * name, and returned.\n"
  " *\n"
  " * Call has_graphic() instead to check whether a particular name has been\n"
  " * defined.\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_get_graphic_296_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool TextPropertiesManager::has_graphic(std::string const &name) const
 */
static PyObject *Dtool_TextPropertiesManager_has_graphic_297(PyObject *self, PyObject *arg) {
  TextPropertiesManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextPropertiesManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool TextPropertiesManager::has_graphic(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*(const TextPropertiesManager*)local_this).has_graphic(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_graphic(TextPropertiesManager self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_has_graphic_297_comment =
  "C++ Interface:\n"
  "has_graphic(TextPropertiesManager self, str name)\n"
  "\n"
  "/**\n"
  " * Returns true if a TextGraphic structure has been associated with the\n"
  " * indicated name, false otherwise.  Normally this means set_graphic() has\n"
  " * been called with this name, but because get_graphic() will implicitly\n"
  " * create a default TextGraphic structure, it may also mean simply that\n"
  " * get_graphic() has been called with the indicated name.\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_has_graphic_297_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void TextPropertiesManager::clear_graphic(std::string const &name)
 */
static PyObject *Dtool_TextPropertiesManager_clear_graphic_298(PyObject *self, PyObject *arg) {
  TextPropertiesManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextPropertiesManager, (void **)&local_this, "TextPropertiesManager.clear_graphic")) {
    return NULL;
  }
  // 1-void TextPropertiesManager::clear_graphic(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).clear_graphic(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_graphic(const TextPropertiesManager self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_clear_graphic_298_comment =
  "C++ Interface:\n"
  "clear_graphic(const TextPropertiesManager self, str name)\n"
  "\n"
  "/**\n"
  " * Removes the named TextGraphic structure from the manager.\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_clear_graphic_298_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void TextPropertiesManager::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_TextPropertiesManager_write_299(PyObject *self, PyObject *args, PyObject *kwds) {
  TextPropertiesManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextPropertiesManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-void TextPropertiesManager::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "TextPropertiesManager.write", false, true);
    if (param1_this != NULL) {
      (*(const TextPropertiesManager*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(TextPropertiesManager self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_write_299_comment =
  "C++ Interface:\n"
  "write(TextPropertiesManager self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_write_299_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TextPropertiesManager *TextPropertiesManager::get_global_ptr(void)
 */
static PyObject *Dtool_TextPropertiesManager_get_global_ptr_300(PyObject *, PyObject *) {
  // 1-static TextPropertiesManager *TextPropertiesManager::get_global_ptr(void)
  TextPropertiesManager *return_value = TextPropertiesManager::get_global_ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextPropertiesManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TextPropertiesManager_get_global_ptr_300_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns the pointer to the global TextPropertiesManager object.\n"
  " */";
#else
static const char *Dtool_TextPropertiesManager_get_global_ptr_300_comment = NULL;
#endif

static int Dtool_Init_TextPropertiesManager(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TextPropertiesManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TextPropertiesManager) {
    printf("TextPropertiesManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TextPropertiesManager *local_this = (TextPropertiesManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TextPropertiesManager) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TextPropertiesManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TextPropertiesManager) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class TextAssembler
 */
/**
 * Python function wrapper for:
 * void TextAssembler::operator =(TextAssembler const &copy)
 */
static PyObject *Dtool_TextAssembler_operator_303(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.assign")) {
    return NULL;
  }
  // 1-void TextAssembler::operator =(TextAssembler const &copy)
  TextAssembler const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_TextAssembler(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TextAssembler.assign", "TextAssembler");
  }
  (*local_this).operator =(*arg_this);
  TextAssembler *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextAssembler, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const TextAssembler self, const TextAssembler copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_operator_303_comment =
  "C++ Interface:\n"
  "assign(const TextAssembler self, const TextAssembler copy)\n";
#else
static const char *Dtool_TextAssembler_operator_303_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void TextAssembler::clear(void)
 */
static PyObject *Dtool_TextAssembler_clear_305(PyObject *self, PyObject *) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.clear")) {
    return NULL;
  }
  // 1-void TextAssembler::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_clear_305_comment =
  "C++ Interface:\n"
  "clear(const TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Reinitializes the contents of the TextAssembler.\n"
  " */";
#else
static const char *Dtool_TextAssembler_clear_305_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextAssembler::set_usage_hint(GeomEnums::UsageHint usage_hint)
 */
static PyObject *Dtool_TextAssembler_set_usage_hint_306(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.set_usage_hint")) {
    return NULL;
  }
  // 1-inline void TextAssembler::set_usage_hint(GeomEnums::UsageHint usage_hint)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_usage_hint((GeomEnums::UsageHint)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_usage_hint(const TextAssembler self, int usage_hint)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_set_usage_hint_306_comment =
  "C++ Interface:\n"
  "set_usage_hint(const TextAssembler self, int usage_hint)\n"
  "\n"
  "/**\n"
  " * Specifies the UsageHint that will be applied to generated geometry.  The\n"
  " * default is UH_static, which is probably the right setting, but if you know\n"
  " * the TextNode's geometry will have a short lifespan, it may be better to set\n"
  " * it to UH_stream.  See geomEnums.h.\n"
  " */";
#else
static const char *Dtool_TextAssembler_set_usage_hint_306_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline GeomEnums::UsageHint TextAssembler::get_usage_hint(void) const
 */
static PyObject *Dtool_TextAssembler_get_usage_hint_307(PyObject *self, PyObject *) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline GeomEnums::UsageHint TextAssembler::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = (*(const TextAssembler*)local_this).get_usage_hint();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_usage_hint_307_comment =
  "C++ Interface:\n"
  "get_usage_hint(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns the UsageHint that will be applied to generated geometry.  See\n"
  " * set_usage_hint().\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_usage_hint_307_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextAssembler::set_max_rows(int max_rows)
 */
static PyObject *Dtool_TextAssembler_set_max_rows_308(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.set_max_rows")) {
    return NULL;
  }
  // 1-inline void TextAssembler::set_max_rows(int max_rows)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_max_rows((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_rows(const TextAssembler self, int max_rows)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_set_max_rows_308_comment =
  "C++ Interface:\n"
  "set_max_rows(const TextAssembler self, int max_rows)\n"
  "\n"
  "/**\n"
  " * If max_rows is greater than zero, no more than max_rows will be accepted.\n"
  " * Text beyond that will be truncated.\n"
  " *\n"
  " * Setting this will not truncate text immediately.  You must follow this up\n"
  " * with a call to set_wtext() to truncate the existing text.\n"
  " */";
#else
static const char *Dtool_TextAssembler_set_max_rows_308_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int TextAssembler::get_max_rows(void) const
 */
static PyObject *Dtool_TextAssembler_get_max_rows_309(PyObject *self, PyObject *) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int TextAssembler::get_max_rows(void) const
  int return_value = (*(const TextAssembler*)local_this).get_max_rows();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_max_rows_309_comment =
  "C++ Interface:\n"
  "get_max_rows(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * If max_rows is greater than zero, no more than max_rows will be accepted.\n"
  " * Text beyond that will be truncated.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_max_rows_309_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextAssembler::set_dynamic_merge(bool dynamic_merge)
 */
static PyObject *Dtool_TextAssembler_set_dynamic_merge_310(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.set_dynamic_merge")) {
    return NULL;
  }
  // 1-inline void TextAssembler::set_dynamic_merge(bool dynamic_merge)
  (*local_this).set_dynamic_merge((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_dynamic_merge(const TextAssembler self, bool dynamic_merge)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_set_dynamic_merge_310_comment =
  "C++ Interface:\n"
  "set_dynamic_merge(const TextAssembler self, bool dynamic_merge)\n"
  "\n"
  "/**\n"
  " * Sets the dynamic_merge flag.  See TextNode::set_flatten_flags().\n"
  " */";
#else
static const char *Dtool_TextAssembler_set_dynamic_merge_310_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextAssembler::get_dynamic_merge(void) const
 */
static PyObject *Dtool_TextAssembler_get_dynamic_merge_311(PyObject *self, PyObject *) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextAssembler::get_dynamic_merge(void) const
  bool return_value = (*(const TextAssembler*)local_this).get_dynamic_merge();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_dynamic_merge_311_comment =
  "C++ Interface:\n"
  "get_dynamic_merge(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns the dynamic_merge flag.  See TextNode::set_flatten_flags().\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_dynamic_merge_311_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextAssembler::set_multiline_mode(bool flag)
 */
static PyObject *Dtool_TextAssembler_set_multiline_mode_312(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.set_multiline_mode")) {
    return NULL;
  }
  // 1-inline void TextAssembler::set_multiline_mode(bool flag)
  (*local_this).set_multiline_mode((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_multiline_mode(const TextAssembler self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_set_multiline_mode_312_comment =
  "C++ Interface:\n"
  "set_multiline_mode(const TextAssembler self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the multiline mode flag.  Set the multiline mode to allow text to\n"
  " * wrap.  It defaults to true.\n"
  " */";
#else
static const char *Dtool_TextAssembler_set_multiline_mode_312_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextAssembler::get_multiline_mode(void) const
 */
static PyObject *Dtool_TextAssembler_get_multiline_mode_313(PyObject *self, PyObject *) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextAssembler::get_multiline_mode(void) const
  bool return_value = (*(const TextAssembler*)local_this).get_multiline_mode();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_multiline_mode_313_comment =
  "C++ Interface:\n"
  "get_multiline_mode(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns the multline_mode flag.  See TextNode::set_multiline_mode().\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_multiline_mode_313_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextAssembler::set_properties(TextProperties const &properties)
 */
static PyObject *Dtool_TextAssembler_set_properties_314(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.set_properties")) {
    return NULL;
  }
  // 1-inline void TextAssembler::set_properties(TextProperties const &properties)
  TextProperties const *arg_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextProperties, 1, "TextAssembler.set_properties", true, true);
  if (arg_this != NULL) {
    (*local_this).set_properties(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_properties(const TextAssembler self, const TextProperties properties)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_set_properties_314_comment =
  "C++ Interface:\n"
  "set_properties(const TextAssembler self, const TextProperties properties)\n"
  "\n"
  "/**\n"
  " * Specifies the default TextProperties that are applied to the text in the\n"
  " * absence of any nested property change sequences.\n"
  " */";
#else
static const char *Dtool_TextAssembler_set_properties_314_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TextProperties const &TextAssembler::get_properties(void) const
 * inline TextProperties const &TextAssembler::get_properties(int n) const
 * inline TextProperties const &TextAssembler::get_properties(int r, int c) const
 */
static PyObject *Dtool_TextAssembler_get_properties_315(PyObject *self, PyObject *args, PyObject *kwds) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline TextProperties const &TextAssembler::get_properties(void) const
      TextProperties const *return_value = &((*(const TextAssembler*)local_this).get_properties());
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextProperties, false, true);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-inline TextProperties const &TextAssembler::get_properties(int n) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        TextProperties const *return_value = &((*(const TextAssembler*)local_this).get_properties((int)arg_val));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextProperties, false, true);
      }
    }
    break;
  case 2:
    {
      // 1-inline TextProperties const &TextAssembler::get_properties(int r, int c) const
      int param1;
      int param2;
      static const char *keyword_list[] = {"r", "c", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_properties", (char **)keyword_list, &param1, &param2)) {
        TextProperties const *return_value = &((*(const TextAssembler*)local_this).get_properties((int)param1, (int)param2));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextProperties, false, true);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_properties() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_properties(TextAssembler self)\n"
      "get_properties(TextAssembler self, int n)\n"
      "get_properties(TextAssembler self, int r, int c)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_properties_315_comment =
  "C++ Interface:\n"
  "get_properties(TextAssembler self)\n"
  "get_properties(TextAssembler self, int n)\n"
  "get_properties(TextAssembler self, int r, int c)\n"
  "\n"
  "/**\n"
  " * Returns the default TextProperties that are applied to the text in the\n"
  " * absence of any nested property change sequences.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the TextProperties in effect for the object at the indicated\n"
  " * position in the pre-wordwrapped string.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the TextProperties in effect for the object at the indicated\n"
  " * position in the indicated row.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_properties_315_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool TextAssembler::set_wtext(std::wstring const &wtext)
 */
static PyObject *Dtool_TextAssembler_set_wtext_316(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.set_wtext")) {
    return NULL;
  }
  // 1-bool TextAssembler::set_wtext(std::wstring const &wtext)
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
  #else
  PyUnicodeObject *param1;
  #endif
  if (PyArg_Parse(arg, "U:set_wtext", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    bool return_value = (*local_this).set_wtext(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wtext(const TextAssembler self, unicode wtext)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_set_wtext_316_comment =
  "C++ Interface:\n"
  "set_wtext(const TextAssembler self, unicode wtext)\n"
  "\n"
  "/**\n"
  " * Accepts a new text string and associated properties structure, and\n"
  " * precomputes the wordwrapping layout appropriately.  After this call,\n"
  " * get_wordwrapped_wtext() and get_num_rows() can be called.\n"
  " *\n"
  " * The return value is true if all the text is accepted, or false if some was\n"
  " * truncated (see set_max_rows()).\n"
  " */";
#else
static const char *Dtool_TextAssembler_set_wtext_316_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool TextAssembler::set_wsubstr(std::wstring const &wtext, int start, int count)
 */
static PyObject *Dtool_TextAssembler_set_wsubstr_317(PyObject *self, PyObject *args, PyObject *kwds) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.set_wsubstr")) {
    return NULL;
  }
  // 1-bool TextAssembler::set_wsubstr(std::wstring const &wtext, int start, int count)
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
  #else
  PyUnicodeObject *param1;
  #endif
  int param2;
  int param3;
  static const char *keyword_list[] = {"wtext", "start", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Uii:set_wsubstr", (char **)keyword_list, &param1, &param2, &param3)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    bool return_value = (*local_this).set_wsubstr(std::wstring(param1_str, param1_len), (int)param2, (int)param3);
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wsubstr(const TextAssembler self, unicode wtext, int start, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_set_wsubstr_317_comment =
  "C++ Interface:\n"
  "set_wsubstr(const TextAssembler self, unicode wtext, int start, int count)\n"
  "\n"
  "/**\n"
  " * Replaces the 'count' characters from 'start' of the current text with the\n"
  " * indicated replacement text.  If the replacement text does not have count\n"
  " * characters, the length of the string will be changed accordingly.\n"
  " *\n"
  " * The substring may include nested formatting characters, but they must be\n"
  " * self-contained and self-closed.  The formatting characters are not\n"
  " * literally saved in the internal string; they are parsed at the time of the\n"
  " * set_wsubstr() call.\n"
  " *\n"
  " * The return value is true if all the text is accepted, or false if some was\n"
  " * truncated (see set_max_rows()).\n"
  " */";
#else
static const char *Dtool_TextAssembler_set_wsubstr_317_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::wstring TextAssembler::get_plain_wtext(void) const
 */
static PyObject *Dtool_TextAssembler_get_plain_wtext_318(PyObject *self, PyObject *) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::wstring TextAssembler::get_plain_wtext(void) const
  std::wstring return_value = (*(const TextAssembler*)local_this).get_plain_wtext();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_plain_wtext_318_comment =
  "C++ Interface:\n"
  "get_plain_wtext(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns a wstring that represents the contents of the text, without any\n"
  " * embedded properties characters.  If there is an embedded graphic object, a\n"
  " * zero value is inserted in that position.\n"
  " *\n"
  " * This string has the same length as get_num_characters(), and the characters\n"
  " * in this string correspond one-to-one with the characters returned by\n"
  " * get_character(n).\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_plain_wtext_318_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::wstring TextAssembler::get_wordwrapped_plain_wtext(void) const
 */
static PyObject *Dtool_TextAssembler_get_wordwrapped_plain_wtext_319(PyObject *self, PyObject *) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::wstring TextAssembler::get_wordwrapped_plain_wtext(void) const
  std::wstring return_value = (*(const TextAssembler*)local_this).get_wordwrapped_plain_wtext();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_wordwrapped_plain_wtext_319_comment =
  "C++ Interface:\n"
  "get_wordwrapped_plain_wtext(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns a wstring that represents the contents of the text, with newlines\n"
  " * inserted according to the wordwrapping.  The string will contain no\n"
  " * embedded properties characters.  If there is an embedded graphic object, a\n"
  " * zero value is inserted in that position.\n"
  " *\n"
  " * This string has the same number of newline characters as get_num_rows(),\n"
  " * and the characters in this string correspond one-to-one with the characters\n"
  " * returned by get_character(r, c).\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_wordwrapped_plain_wtext_319_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::wstring TextAssembler::get_wtext(void) const
 */
static PyObject *Dtool_TextAssembler_get_wtext_320(PyObject *self, PyObject *) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::wstring TextAssembler::get_wtext(void) const
  std::wstring return_value = (*(const TextAssembler*)local_this).get_wtext();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_wtext_320_comment =
  "C++ Interface:\n"
  "get_wtext(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns a wstring that represents the contents of the text.\n"
  " *\n"
  " * The string will contain embedded properties characters, which may not\n"
  " * exactly match the embedded properties characters of the original string,\n"
  " * but it will encode the same way.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_wtext_320_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::wstring TextAssembler::get_wordwrapped_wtext(void) const
 */
static PyObject *Dtool_TextAssembler_get_wordwrapped_wtext_321(PyObject *self, PyObject *) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::wstring TextAssembler::get_wordwrapped_wtext(void) const
  std::wstring return_value = (*(const TextAssembler*)local_this).get_wordwrapped_wtext();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_wordwrapped_wtext_321_comment =
  "C++ Interface:\n"
  "get_wordwrapped_wtext(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns a wstring that represents the contents of the text, with newlines\n"
  " * inserted according to the wordwrapping.\n"
  " *\n"
  " * The string will contain embedded properties characters, which may not\n"
  " * exactly match the embedded properties characters of the original string,\n"
  " * but it will encode the same way.\n"
  " *\n"
  " * Embedded properties characters will be closed before every newline, then\n"
  " * reopened (if necessary) on the subsequent character following the newline.\n"
  " * This means it will be safe to divide the text up at the newline characters\n"
  " * and treat each line as an independent piece.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_wordwrapped_wtext_321_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int TextAssembler::calc_r(int n) const
 */
static PyObject *Dtool_TextAssembler_calc_r_323(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int TextAssembler::calc_r(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const TextAssembler*)local_this).calc_r((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_r(TextAssembler self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_calc_r_323_comment =
  "C++ Interface:\n"
  "calc_r(TextAssembler self, int n)\n"
  "\n"
  "/**\n"
  " * Computes the row index of the nth character or graphic object in the text\n"
  " * and returns it.\n"
  " *\n"
  " * If the nth character is not a normal printable character with a position in\n"
  " * the wordwrapped string, returns -1 (for instance, a soft-hyphen character,\n"
  " * or a newline character, may not have a corresponding position).\n"
  " */";
#else
static const char *Dtool_TextAssembler_calc_r_323_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int TextAssembler::calc_c(int n) const
 */
static PyObject *Dtool_TextAssembler_calc_c_324(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int TextAssembler::calc_c(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const TextAssembler*)local_this).calc_c((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_c(TextAssembler self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_calc_c_324_comment =
  "C++ Interface:\n"
  "calc_c(TextAssembler self, int n)\n"
  "\n"
  "/**\n"
  " * Computes the column index of the nth character or graphic object in the\n"
  " * text and returns it.\n"
  " *\n"
  " * If the nth character is not a normal printable character with a position in\n"
  " * the wordwrapped string, returns -1 (for instance, a soft-hyphen character,\n"
  " * or a newline character, may not have a corresponding position).\n"
  " */";
#else
static const char *Dtool_TextAssembler_calc_c_324_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int TextAssembler::calc_index(int r, int c) const
 */
static PyObject *Dtool_TextAssembler_calc_index_325(PyObject *self, PyObject *args, PyObject *kwds) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  // 1-int TextAssembler::calc_index(int r, int c) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"r", "c", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:calc_index", (char **)keyword_list, &param1, &param2)) {
    int return_value = (*(const TextAssembler*)local_this).calc_index((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_index(TextAssembler self, int r, int c)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_calc_index_325_comment =
  "C++ Interface:\n"
  "calc_index(TextAssembler self, int r, int c)\n"
  "\n"
  "/**\n"
  " * Computes the character index of the character at the rth row and cth column\n"
  " * position.  This is the inverse of calc_r_c().\n"
  " *\n"
  " * It is legal for c to exceed the index number of the last column by 1, and\n"
  " * it is legal for r to exceed the index number of the last row by 1, if c is\n"
  " * 0.\n"
  " */";
#else
static const char *Dtool_TextAssembler_calc_index_325_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int TextAssembler::get_num_characters(void) const
 */
static PyObject *Dtool_TextAssembler_get_num_characters_326(PyObject *self, PyObject *) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int TextAssembler::get_num_characters(void) const
  int return_value = (*(const TextAssembler*)local_this).get_num_characters();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_num_characters_326_comment =
  "C++ Interface:\n"
  "get_num_characters(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns the number of characters of text, before wordwrapping.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_num_characters_326_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline wchar_t TextAssembler::get_character(int n) const
 * inline wchar_t TextAssembler::get_character(int r, int c) const
 */
static PyObject *Dtool_TextAssembler_get_character_327(PyObject *self, PyObject *args, PyObject *kwds) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-inline wchar_t TextAssembler::get_character(int n) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        wchar_t return_value = (*(const TextAssembler*)local_this).get_character((int)arg_val);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-inline wchar_t TextAssembler::get_character(int r, int c) const
      int param1;
      int param2;
      static const char *keyword_list[] = {"r", "c", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_character", (char **)keyword_list, &param1, &param2)) {
        wchar_t return_value = (*(const TextAssembler*)local_this).get_character((int)param1, (int)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_character() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_character(TextAssembler self, int n)\n"
      "get_character(TextAssembler self, int r, int c)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_character_327_comment =
  "C++ Interface:\n"
  "get_character(TextAssembler self, int n)\n"
  "get_character(TextAssembler self, int r, int c)\n"
  "\n"
  "/**\n"
  " * Returns the character at the indicated position in the pre-wordwrapped\n"
  " * string.  If the object at this position is a graphic object instead of a\n"
  " * character, returns 0.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the character at the indicated position in the indicated row.  If\n"
  " * the object at this position is a graphic object instead of a character,\n"
  " * returns 0.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_character_327_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TextGraphic const *TextAssembler::get_graphic(int n) const
 * inline TextGraphic const *TextAssembler::get_graphic(int r, int c) const
 */
static PyObject *Dtool_TextAssembler_get_graphic_328(PyObject *self, PyObject *args, PyObject *kwds) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-inline TextGraphic const *TextAssembler::get_graphic(int n) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        TextGraphic const *return_value = (*(const TextAssembler*)local_this).get_graphic((int)arg_val);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextGraphic, false, true);
      }
    }
    break;
  case 2:
    {
      // 1-inline TextGraphic const *TextAssembler::get_graphic(int r, int c) const
      int param1;
      int param2;
      static const char *keyword_list[] = {"r", "c", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_graphic", (char **)keyword_list, &param1, &param2)) {
        TextGraphic const *return_value = (*(const TextAssembler*)local_this).get_graphic((int)param1, (int)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextGraphic, false, true);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_graphic() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_graphic(TextAssembler self, int n)\n"
      "get_graphic(TextAssembler self, int r, int c)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_graphic_328_comment =
  "C++ Interface:\n"
  "get_graphic(TextAssembler self, int n)\n"
  "get_graphic(TextAssembler self, int r, int c)\n"
  "\n"
  "/**\n"
  " * Returns the graphic object at the indicated position in the pre-wordwrapped\n"
  " * string.  If the object at this position is a character instead of a graphic\n"
  " * object, returns NULL.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the graphic object at the indicated position in the indicated row.\n"
  " * If the object at this position is a character instead of a graphic object,\n"
  " * returns NULL.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_graphic_328_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextAssembler::get_width(int n) const
 * inline PN_stdfloat TextAssembler::get_width(int r, int c) const
 */
static PyObject *Dtool_TextAssembler_get_width_329(PyObject *self, PyObject *args, PyObject *kwds) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-inline PN_stdfloat TextAssembler::get_width(int n) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        PN_stdfloat return_value = (*(const TextAssembler*)local_this).get_width((int)arg_val);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-inline PN_stdfloat TextAssembler::get_width(int r, int c) const
      int param1;
      int param2;
      static const char *keyword_list[] = {"r", "c", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_width", (char **)keyword_list, &param1, &param2)) {
        PN_stdfloat return_value = (*(const TextAssembler*)local_this).get_width((int)param1, (int)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_width() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_width(TextAssembler self, int n)\n"
      "get_width(TextAssembler self, int r, int c)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_width_329_comment =
  "C++ Interface:\n"
  "get_width(TextAssembler self, int n)\n"
  "get_width(TextAssembler self, int r, int c)\n"
  "\n"
  "/**\n"
  " * Returns the width of the character or object at the indicated position in\n"
  " * the pre-wordwrapped string.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the width of the character or object at the indicated position in\n"
  " * the indicated row.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_width_329_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int TextAssembler::get_num_rows(void) const
 */
static PyObject *Dtool_TextAssembler_get_num_rows_330(PyObject *self, PyObject *) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int TextAssembler::get_num_rows(void) const
  int return_value = (*(const TextAssembler*)local_this).get_num_rows();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_num_rows_330_comment =
  "C++ Interface:\n"
  "get_num_rows(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns the number of rows of text after it has all been wordwrapped and\n"
  " * assembled.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_num_rows_330_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int TextAssembler::get_num_cols(int r) const
 */
static PyObject *Dtool_TextAssembler_get_num_cols_331(PyObject *self, PyObject *arg) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int TextAssembler::get_num_cols(int r) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const TextAssembler*)local_this).get_num_cols((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_cols(TextAssembler self, int r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_num_cols_331_comment =
  "C++ Interface:\n"
  "get_num_cols(TextAssembler self, int r)\n"
  "\n"
  "/**\n"
  " * Returns the number of characters and/or graphic objects in the nth row.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_num_cols_331_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat TextAssembler::get_xpos(int r, int c) const
 */
static PyObject *Dtool_TextAssembler_get_xpos_332(PyObject *self, PyObject *args, PyObject *kwds) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat TextAssembler::get_xpos(int r, int c) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"r", "c", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_xpos", (char **)keyword_list, &param1, &param2)) {
    PN_stdfloat return_value = (*(const TextAssembler*)local_this).get_xpos((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_xpos(TextAssembler self, int r, int c)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_xpos_332_comment =
  "C++ Interface:\n"
  "get_xpos(TextAssembler self, int r, int c)\n"
  "\n"
  "/**\n"
  " * Returns the x position of the origin of the character or graphic object at\n"
  " * the indicated position in the indicated row.\n"
  " *\n"
  " * It is legal for c to exceed the index number of the last column by 1, and\n"
  " * it is legal for r to exceed the index number of the last row by 1, if c is\n"
  " * 0.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_xpos_332_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextAssembler::get_ypos(int r, int c) const
 */
static PyObject *Dtool_TextAssembler_get_ypos_333(PyObject *self, PyObject *args, PyObject *kwds) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextAssembler::get_ypos(int r, int c) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"r", "c", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_ypos", (char **)keyword_list, &param1, &param2)) {
    PN_stdfloat return_value = (*(const TextAssembler*)local_this).get_ypos((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_ypos(TextAssembler self, int r, int c)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_ypos_333_comment =
  "C++ Interface:\n"
  "get_ypos(TextAssembler self, int r, int c)\n"
  "\n"
  "/**\n"
  " * Returns the y position of the origin of all of the characters or graphic\n"
  " * objects in the indicated row.\n"
  " *\n"
  " * It is legal for r to exceed the index number of the last row by 1.  The\n"
  " * value of c is presently ignored.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_ypos_333_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< PandaNode > TextAssembler::assemble_text(void)
 */
static PyObject *Dtool_TextAssembler_assemble_text_334(PyObject *self, PyObject *) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.assemble_text")) {
    return NULL;
  }
  // 1-PointerTo< PandaNode > TextAssembler::assemble_text(void)
  PointerTo< PandaNode > return_value = (*local_this).assemble_text();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  PandaNode *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PandaNode, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_assemble_text_334_comment =
  "C++ Interface:\n"
  "assemble_text(const TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Actually assembles all of the text into a GeomNode, and returns the node\n"
  " * (or possibly a parent of the node, to keep the shadow separate).  Once this\n"
  " * has been called, you may query the extents of the text via get_ul(),\n"
  " * get_lr().\n"
  " */";
#else
static const char *Dtool_TextAssembler_assemble_text_334_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2 const &TextAssembler::get_ul(void) const
 */
static PyObject *Dtool_TextAssembler_get_ul_335(PyObject *self, PyObject *) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector2 const &TextAssembler::get_ul(void) const
  LVector2 const *return_value = &((*(const TextAssembler*)local_this).get_ul());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_ul_335_comment =
  "C++ Interface:\n"
  "get_ul(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns the upper-left corner of the assembled text, in 2-d text\n"
  " * coordinates.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_ul_335_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2 const &TextAssembler::get_lr(void) const
 */
static PyObject *Dtool_TextAssembler_get_lr_336(PyObject *self, PyObject *) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector2 const &TextAssembler::get_lr(void) const
  LVector2 const *return_value = &((*(const TextAssembler*)local_this).get_lr());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_get_lr_336_comment =
  "C++ Interface:\n"
  "get_lr(TextAssembler self)\n"
  "\n"
  "/**\n"
  " * Returns the lower-right corner of the assembled text, in 2-d text\n"
  " * coordinates.\n"
  " */";
#else
static const char *Dtool_TextAssembler_get_lr_336_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static PN_stdfloat TextAssembler::calc_width(TextGraphic const *graphic, TextProperties const &properties)
 * static PN_stdfloat TextAssembler::calc_width(wchar_t character, TextProperties const &properties)
 */
static PyObject *Dtool_TextAssembler_calc_width_337(PyObject *, PyObject *args, PyObject *kwds) {
  {
    // -2 static PN_stdfloat TextAssembler::calc_width(TextGraphic const *graphic, TextProperties const &properties)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"graphic", "properties", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:calc_width", (char **)keyword_list, &param0, &param1)) {
      TextGraphic const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TextGraphic, (void **)&param0_this);
      TextProperties const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_TextProperties, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        PN_stdfloat return_value = TextAssembler::calc_width(param0_this, *param1_this);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 static PN_stdfloat TextAssembler::calc_width(wchar_t character, TextProperties const &properties)
    #if PY_VERSION_HEX >= 0x03020000
    PyObject *param0;
    #else
    PyUnicodeObject *param0;
    #endif
    PyObject *param1;
    static const char *keyword_list[] = {"character", "properties", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "UO:calc_width", (char **)keyword_list, &param0, &param1)) {
      wchar_t param0_chars[2];
      TextProperties const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_TextProperties, (void **)&param1_this);
      if (PyUnicode_AsWideChar(param0, param0_chars, 2) == 1 && param1_this != NULL) {
        PN_stdfloat return_value = TextAssembler::calc_width(param0_chars[0], *param1_this);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 static PN_stdfloat TextAssembler::calc_width(TextGraphic const *graphic, TextProperties const &properties)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"graphic", "properties", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:calc_width", (char **)keyword_list, &param0, &param1)) {
      TextGraphic const *param0_this;
      bool param0_manage = false;
      TextProperties const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_TextProperties, (void **)&param1_this);
      if (Dtool_ConstCoerce_TextGraphic(param0, param0_this, param0_manage) && param1_this != NULL) {
        PN_stdfloat return_value = TextAssembler::calc_width(param0_this, *param1_this);
        if (param0_manage) {
          delete param0_this;
        }
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: static PN_stdfloat TextAssembler::calc_width(wchar_t character, TextProperties const &properties)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_width(const TextGraphic graphic, const TextProperties properties)\n"
      "calc_width(unicode char character, const TextProperties properties)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_calc_width_337_comment =
  "C++ Interface:\n"
  "calc_width(const TextGraphic graphic, const TextProperties properties)\n"
  "calc_width(unicode char character, const TextProperties properties)\n"
  "\n"
  "/**\n"
  " * Returns the width of a single character, according to its associated font.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the width of a single character, according to its associated font.\n"
  " * This also correctly calculates the width of cheesy ligatures and accented\n"
  " * characters, which may not exist in the font as such.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the width of a single TextGraphic image.\n"
  " */";
#else
static const char *Dtool_TextAssembler_calc_width_337_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static bool TextAssembler::has_exact_character(wchar_t character, TextProperties const &properties)
 */
static PyObject *Dtool_TextAssembler_has_exact_character_338(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static bool TextAssembler::has_exact_character(wchar_t character, TextProperties const &properties)
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param0;
  #else
  PyUnicodeObject *param0;
  #endif
  PyObject *param1;
  static const char *keyword_list[] = {"character", "properties", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "UO:has_exact_character", (char **)keyword_list, &param0, &param1)) {
    wchar_t param0_chars[2];
    TextProperties const *param1_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextProperties, 1, "TextAssembler.has_exact_character", true, true);
    if (PyUnicode_AsWideChar(param0, param0_chars, 2) == 1 && param1_this != NULL) {
      bool return_value = TextAssembler::has_exact_character(param0_chars[0], *param1_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_exact_character(unicode char character, const TextProperties properties)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_has_exact_character_338_comment =
  "C++ Interface:\n"
  "has_exact_character(unicode char character, const TextProperties properties)\n"
  "\n"
  "/**\n"
  " * Returns true if the named character exists in the font exactly as named,\n"
  " * false otherwise.  Note that because Panda can assemble glyphs together\n"
  " * automatically using cheesy accent marks, this is not a reliable indicator\n"
  " * of whether a suitable glyph can be rendered for the character.  For that,\n"
  " * use has_character() instead.\n"
  " *\n"
  " * This returns true for whitespace and Unicode whitespace characters (if they\n"
  " * exist in the font), but returns false for characters that would render with\n"
  " * the \"invalid glyph\".  It also returns false for characters that would be\n"
  " * synthesized within Panda, but see has_character().\n"
  " */";
#else
static const char *Dtool_TextAssembler_has_exact_character_338_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static bool TextAssembler::has_character(wchar_t character, TextProperties const &properties)
 */
static PyObject *Dtool_TextAssembler_has_character_339(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static bool TextAssembler::has_character(wchar_t character, TextProperties const &properties)
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param0;
  #else
  PyUnicodeObject *param0;
  #endif
  PyObject *param1;
  static const char *keyword_list[] = {"character", "properties", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "UO:has_character", (char **)keyword_list, &param0, &param1)) {
    wchar_t param0_chars[2];
    TextProperties const *param1_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextProperties, 1, "TextAssembler.has_character", true, true);
    if (PyUnicode_AsWideChar(param0, param0_chars, 2) == 1 && param1_this != NULL) {
      bool return_value = TextAssembler::has_character(param0_chars[0], *param1_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_character(unicode char character, const TextProperties properties)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_has_character_339_comment =
  "C++ Interface:\n"
  "has_character(unicode char character, const TextProperties properties)\n"
  "\n"
  "/**\n"
  " * Returns true if the named character exists in the font or can be\n"
  " * synthesized by Panda, false otherwise.  (Panda can synthesize some accented\n"
  " * characters by combining similar-looking glyphs from the font.)\n"
  " *\n"
  " * This returns true for whitespace and Unicode whitespace characters (if they\n"
  " * exist in the font), but returns false for characters that would render with\n"
  " * the \"invalid glyph\".\n"
  " */";
#else
static const char *Dtool_TextAssembler_has_character_339_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static bool TextAssembler::is_whitespace(wchar_t character, TextProperties const &properties)
 */
static PyObject *Dtool_TextAssembler_is_whitespace_340(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static bool TextAssembler::is_whitespace(wchar_t character, TextProperties const &properties)
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param0;
  #else
  PyUnicodeObject *param0;
  #endif
  PyObject *param1;
  static const char *keyword_list[] = {"character", "properties", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "UO:is_whitespace", (char **)keyword_list, &param0, &param1)) {
    wchar_t param0_chars[2];
    TextProperties const *param1_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextProperties, 1, "TextAssembler.is_whitespace", true, true);
    if (PyUnicode_AsWideChar(param0, param0_chars, 2) == 1 && param1_this != NULL) {
      bool return_value = TextAssembler::is_whitespace(param0_chars[0], *param1_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_whitespace(unicode char character, const TextProperties properties)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextAssembler_is_whitespace_340_comment =
  "C++ Interface:\n"
  "is_whitespace(unicode char character, const TextProperties properties)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated character represents whitespace in the font,\n"
  " * or false if anything visible will be rendered for it.\n"
  " *\n"
  " * This returns true for whitespace and Unicode whitespace characters (if they\n"
  " * exist in the font), and returns false for any other characters, including\n"
  " * characters that do not exist in the font (these would be rendered with the\n"
  " * \"invalid glyph\", which is visible).\n"
  " *\n"
  " * Note that this function can be reliably used to identify Unicode whitespace\n"
  " * characters only if the font has all of the whitespace characters defined.\n"
  " * It will return false for any character not in the font, even if it is an\n"
  " * official Unicode whitespace character.\n"
  " */";
#else
static const char *Dtool_TextAssembler_is_whitespace_340_comment = NULL;
#endif

static PyObject *Dtool_TextAssembler_usage_hint_Getter(PyObject *self, void *) {
  const TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline GeomEnums::UsageHint TextAssembler::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = (*(const TextAssembler*)local_this).get_usage_hint();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextAssembler_usage_hint_Setter(PyObject *self, PyObject *arg, void *) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.usage_hint")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete usage_hint attribute");
    return -1;
  }
  // 1-inline void TextAssembler::set_usage_hint(GeomEnums::UsageHint usage_hint)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_usage_hint((GeomEnums::UsageHint)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_usage_hint(const TextAssembler self, int usage_hint)\n");
  }
  return -1;
}

static PyObject *Dtool_TextAssembler_max_rows_Getter(PyObject *self, void *) {
  const TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int TextAssembler::get_max_rows(void) const
  int return_value = (*(const TextAssembler*)local_this).get_max_rows();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextAssembler_max_rows_Setter(PyObject *self, PyObject *arg, void *) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.max_rows")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete max_rows attribute");
    return -1;
  }
  // 1-inline void TextAssembler::set_max_rows(int max_rows)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_max_rows((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_rows(const TextAssembler self, int max_rows)\n");
  }
  return -1;
}

static PyObject *Dtool_TextAssembler_dynamic_merge_Getter(PyObject *self, void *) {
  const TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool TextAssembler::get_dynamic_merge(void) const
  bool return_value = (*(const TextAssembler*)local_this).get_dynamic_merge();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextAssembler_dynamic_merge_Setter(PyObject *self, PyObject *arg, void *) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.dynamic_merge")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete dynamic_merge attribute");
    return -1;
  }
  // 1-inline void TextAssembler::set_dynamic_merge(bool dynamic_merge)
  (*local_this).set_dynamic_merge((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_dynamic_merge(const TextAssembler self, bool dynamic_merge)\n");
  }
  return -1;
}

static PyObject *Dtool_TextAssembler_multiline_mode_Getter(PyObject *self, void *) {
  const TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool TextAssembler::get_multiline_mode(void) const
  bool return_value = (*(const TextAssembler*)local_this).get_multiline_mode();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextAssembler_multiline_mode_Setter(PyObject *self, PyObject *arg, void *) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.multiline_mode")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete multiline_mode attribute");
    return -1;
  }
  // 1-inline void TextAssembler::set_multiline_mode(bool flag)
  (*local_this).set_multiline_mode((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_multiline_mode(const TextAssembler self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_TextAssembler_properties_Getter(PyObject *self, void *) {
  const TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextAssembler, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline TextProperties const &TextAssembler::get_properties(void) const
  TextProperties const *return_value = &((*(const TextAssembler*)local_this).get_properties());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextProperties, false, true);
}

static int Dtool_TextAssembler_properties_Setter(PyObject *self, PyObject *arg, void *) {
  TextAssembler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextAssembler, (void **)&local_this, "TextAssembler.properties")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete properties attribute");
    return -1;
  }
  // 1-inline void TextAssembler::set_properties(TextProperties const &properties)
  TextProperties const *arg_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextProperties, 1, "TextAssembler.set_properties", true, true);
  if (arg_this != NULL) {
    (*local_this).set_properties(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_properties(const TextAssembler self, const TextProperties properties)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * TextAssembler::TextAssembler(TextAssembler const &copy)
 * TextAssembler::TextAssembler(TextEncoder *encoder)
 */
static int Dtool_Init_TextAssembler(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "TextAssembler() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 TextAssembler::TextAssembler(TextAssembler const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:TextAssembler", (char **)keyword_list, &param0)) {
      TextAssembler const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TextAssembler, (void **)&param0_this);
      if (param0_this != NULL) {
        TextAssembler *return_value = new TextAssembler(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextAssembler, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 TextAssembler::TextAssembler(TextEncoder *encoder)
    PyObject *param0;
    static const char *keyword_list[] = {"encoder", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:TextAssembler", (char **)keyword_list, &param0)) {
      TextEncoder *param0_this = (TextEncoder *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_TextEncoder, 0, "TextAssembler.TextAssembler", false, false);
      if (param0_this != NULL) {
        TextAssembler *return_value = new TextAssembler(param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextAssembler, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 TextAssembler::TextAssembler(TextAssembler const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:TextAssembler", (char **)keyword_list, &param0)) {
      TextAssembler const *param0_this;
      bool param0_manage = false;
      if (Dtool_ConstCoerce_TextAssembler(param0, param0_this, param0_manage)) {
        TextAssembler *return_value = new TextAssembler(*param0_this);
        if (param0_manage) {
          delete param0_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextAssembler, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: TextAssembler::TextAssembler(TextEncoder *encoder)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TextAssembler(const TextAssembler copy)\n"
      "TextAssembler(TextEncoder encoder)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_TextAssembler(PyObject *args, TextAssembler const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_TextAssembler, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-TextAssembler::TextAssembler(TextEncoder *encoder)
    TextEncoder *arg_this = (TextEncoder *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextEncoder, 0, "TextAssembler.TextAssembler", false, false);
    if (arg_this != NULL) {
      TextAssembler *return_value = new TextAssembler(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_TextAssembler(PyObject *args, TextAssembler *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_TextAssembler, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-TextAssembler::TextAssembler(TextEncoder *encoder)
    TextEncoder *arg_this = (TextEncoder *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextEncoder, 0, "TextAssembler.TextAssembler", false, false);
    if (arg_this != NULL) {
      TextAssembler *return_value = new TextAssembler(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_TextAssembler(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TextAssembler) {
    printf("TextAssembler ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TextAssembler *local_this = (TextAssembler *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TextAssembler) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TextAssembler(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TextAssembler) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class TextNode
 */
/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_line_height(void) const
 */
static PyObject *Dtool_TextNode_get_line_height_361(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextNode::get_line_height(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_line_height();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_line_height_361_comment =
  "C++ Interface:\n"
  "get_line_height(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of units high each line of text is.  This is based on\n"
  " * the font.  Note that it is possible for the text to include nested font\n"
  " * change commands, in which case the value of this method is questionable.\n"
  " */";
#else
static const char *Dtool_TextNode_get_line_height_361_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_max_rows(int max_rows)
 */
static PyObject *Dtool_TextNode_set_max_rows_362(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_max_rows")) {
    return NULL;
  }
  // 1-inline void TextNode::set_max_rows(int max_rows)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_max_rows((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_rows(const TextNode self, int max_rows)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_max_rows_362_comment =
  "C++ Interface:\n"
  "set_max_rows(const TextNode self, int max_rows)\n"
  "\n"
  "/**\n"
  " * Sets the maximum number of rows that may be formatted by the TextNode.  If\n"
  " * more text than this is attempted, it will be truncated and has_overflow()\n"
  " * will return true.\n"
  " */";
#else
static const char *Dtool_TextNode_set_max_rows_362_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_max_rows(void)
 */
static PyObject *Dtool_TextNode_clear_max_rows_363(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_max_rows")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_max_rows(void)
  (*local_this).clear_max_rows();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_max_rows_363_comment =
  "C++ Interface:\n"
  "clear_max_rows(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Resets the TextNode's default behavior of not limiting the number of rows\n"
  " * of text.\n"
  " */";
#else
static const char *Dtool_TextNode_clear_max_rows_363_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::has_max_rows(void) const
 */
static PyObject *Dtool_TextNode_has_max_rows_364(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextNode::has_max_rows(void) const
  bool return_value = (*(const TextNode*)local_this).has_max_rows();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_has_max_rows_364_comment =
  "C++ Interface:\n"
  "has_max_rows(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if a limit on the height of the TextNode has been set via\n"
  " * set_max_rows(), false otherwise.\n"
  " */";
#else
static const char *Dtool_TextNode_has_max_rows_364_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int TextNode::get_max_rows(void) const
 */
static PyObject *Dtool_TextNode_get_max_rows_365(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int TextNode::get_max_rows(void) const
  int return_value = (*(const TextNode*)local_this).get_max_rows();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_max_rows_365_comment =
  "C++ Interface:\n"
  "get_max_rows(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the limit on the height of the TextNode specified by\n"
  " * set_max_rows().\n"
  " */";
#else
static const char *Dtool_TextNode_get_max_rows_365_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::has_overflow(void) const
 */
static PyObject *Dtool_TextNode_has_overflow_366(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextNode::has_overflow(void) const
  bool return_value = (*(const TextNode*)local_this).has_overflow();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_has_overflow_366_comment =
  "C++ Interface:\n"
  "has_overflow(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the last text set on the text node exceeded the max_rows\n"
  " * constraint, or false if it all fit.\n"
  " */";
#else
static const char *Dtool_TextNode_has_overflow_366_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_frame_color(LColor const &frame_color)
 * inline void TextNode::set_frame_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
 */
static PyObject *Dtool_TextNode_set_frame_color_367(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_frame_color")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "frame_color");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'frame_color' (pos 1) not found");
      }
      // 1-inline void TextNode::set_frame_color(LColor const &frame_color)
      LVecBase4f arg_local;
      LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_frame_color", "LVecBase4f");
      }
      (*local_this).set_frame_color(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void TextNode::set_frame_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"r", "g", "b", "a", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_frame_color", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_frame_color((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_frame_color() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_color(const TextNode self, const LVecBase4f frame_color)\n"
      "set_frame_color(const TextNode self, float r, float g, float b, float a)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_frame_color_367_comment =
  "C++ Interface:\n"
  "set_frame_color(const TextNode self, const LVecBase4f frame_color)\n"
  "set_frame_color(const TextNode self, float r, float g, float b, float a)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_set_frame_color_367_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor TextNode::get_frame_color(void) const
 */
static PyObject *Dtool_TextNode_get_frame_color_368(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor TextNode::get_frame_color(void) const
  LColor *return_value = new LColor((*(const TextNode*)local_this).get_frame_color());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_frame_color_368_comment =
  "C++ Interface:\n"
  "get_frame_color(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_get_frame_color_368_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_card_border(PN_stdfloat size, PN_stdfloat uv_portion)
 */
static PyObject *Dtool_TextNode_set_card_border_369(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_card_border")) {
    return NULL;
  }
  // 1-inline void TextNode::set_card_border(PN_stdfloat size, PN_stdfloat uv_portion)
  float param1;
  float param2;
  static const char *keyword_list[] = {"size", "uv_portion", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_card_border", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_card_border((PN_stdfloat)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_card_border(const TextNode self, float size, float uv_portion)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_card_border_369_comment =
  "C++ Interface:\n"
  "set_card_border(const TextNode self, float size, float uv_portion)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_set_card_border_369_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_card_border(void)
 */
static PyObject *Dtool_TextNode_clear_card_border_370(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_card_border")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_card_border(void)
  (*local_this).clear_card_border();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_card_border_370_comment =
  "C++ Interface:\n"
  "clear_card_border(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_card_border_370_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_card_border_size(void) const
 */
static PyObject *Dtool_TextNode_get_card_border_size_371(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextNode::get_card_border_size(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_card_border_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_card_border_size_371_comment =
  "C++ Interface:\n"
  "get_card_border_size(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_get_card_border_size_371_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_card_border_uv_portion(void) const
 */
static PyObject *Dtool_TextNode_get_card_border_uv_portion_372(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextNode::get_card_border_uv_portion(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_card_border_uv_portion();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_card_border_uv_portion_372_comment =
  "C++ Interface:\n"
  "get_card_border_uv_portion(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_get_card_border_uv_portion_372_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::has_card_border(void) const
 */
static PyObject *Dtool_TextNode_has_card_border_373(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextNode::has_card_border(void) const
  bool return_value = (*(const TextNode*)local_this).has_card_border();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_has_card_border_373_comment =
  "C++ Interface:\n"
  "has_card_border(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_has_card_border_373_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_card_color(LColor const &card_color)
 * inline void TextNode::set_card_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
 */
static PyObject *Dtool_TextNode_set_card_color_374(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_card_color")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "card_color");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'card_color' (pos 1) not found");
      }
      // 1-inline void TextNode::set_card_color(LColor const &card_color)
      LVecBase4f arg_local;
      LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_card_color", "LVecBase4f");
      }
      (*local_this).set_card_color(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void TextNode::set_card_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"r", "g", "b", "a", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_card_color", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_card_color((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_card_color() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_card_color(const TextNode self, const LVecBase4f card_color)\n"
      "set_card_color(const TextNode self, float r, float g, float b, float a)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_card_color_374_comment =
  "C++ Interface:\n"
  "set_card_color(const TextNode self, const LVecBase4f card_color)\n"
  "set_card_color(const TextNode self, float r, float g, float b, float a)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_set_card_color_374_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor TextNode::get_card_color(void) const
 */
static PyObject *Dtool_TextNode_get_card_color_375(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor TextNode::get_card_color(void) const
  LColor *return_value = new LColor((*(const TextNode*)local_this).get_card_color());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_card_color_375_comment =
  "C++ Interface:\n"
  "get_card_color(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_get_card_color_375_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_card_texture(Texture *card_texture)
 */
static PyObject *Dtool_TextNode_set_card_texture_376(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_card_texture")) {
    return NULL;
  }
  // 1-inline void TextNode::set_card_texture(Texture *card_texture)
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "TextNode.set_card_texture", false, true);
  if (arg_this != NULL) {
    (*local_this).set_card_texture(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_card_texture(const TextNode self, Texture card_texture)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_card_texture_376_comment =
  "C++ Interface:\n"
  "set_card_texture(const TextNode self, Texture card_texture)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_set_card_texture_376_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_card_texture(void)
 */
static PyObject *Dtool_TextNode_clear_card_texture_377(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_card_texture")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_card_texture(void)
  (*local_this).clear_card_texture();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_card_texture_377_comment =
  "C++ Interface:\n"
  "clear_card_texture(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_card_texture_377_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::has_card_texture(void) const
 */
static PyObject *Dtool_TextNode_has_card_texture_378(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextNode::has_card_texture(void) const
  bool return_value = (*(const TextNode*)local_this).has_card_texture();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_has_card_texture_378_comment =
  "C++ Interface:\n"
  "has_card_texture(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_has_card_texture_378_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Texture *TextNode::get_card_texture(void) const
 */
static PyObject *Dtool_TextNode_get_card_texture_379(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Texture *TextNode::get_card_texture(void) const
  Texture *return_value = (*(const TextNode*)local_this).get_card_texture();
  if (return_value != (Texture *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (Texture *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_card_texture_379_comment =
  "C++ Interface:\n"
  "get_card_texture(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_get_card_texture_379_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_frame_as_margin(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 */
static PyObject *Dtool_TextNode_set_frame_as_margin_380(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_frame_as_margin")) {
    return NULL;
  }
  // 1-inline void TextNode::set_frame_as_margin(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"left", "right", "bottom", "top", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_frame_as_margin", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).set_frame_as_margin((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_as_margin(const TextNode self, float left, float right, float bottom, float top)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_frame_as_margin_380_comment =
  "C++ Interface:\n"
  "set_frame_as_margin(const TextNode self, float left, float right, float bottom, float top)\n"
  "\n"
  "/**\n"
  " * Specifies that a border will be drawn around the text when it is next\n"
  " * created.  The parameters are the amount of additional padding to insert\n"
  " * between the frame and the text in each dimension, and all should generally\n"
  " * be positive.\n"
  " */";
#else
static const char *Dtool_TextNode_set_frame_as_margin_380_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_frame_actual(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 */
static PyObject *Dtool_TextNode_set_frame_actual_381(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_frame_actual")) {
    return NULL;
  }
  // 1-inline void TextNode::set_frame_actual(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"left", "right", "bottom", "top", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_frame_actual", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).set_frame_actual((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_actual(const TextNode self, float left, float right, float bottom, float top)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_frame_actual_381_comment =
  "C++ Interface:\n"
  "set_frame_actual(const TextNode self, float left, float right, float bottom, float top)\n"
  "\n"
  "/**\n"
  " * Similar to set_frame_as_margin, except the frame is specified in actual\n"
  " * coordinate units (relative to the text's origin), irrespective of the size\n"
  " * of the text.  The left and bottom coordinates should generally be negative,\n"
  " * while the right and top coordinates should generally be positive.\n"
  " */";
#else
static const char *Dtool_TextNode_set_frame_actual_381_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_frame(void)
 */
static PyObject *Dtool_TextNode_clear_frame_382(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_frame")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_frame(void)
  (*local_this).clear_frame();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_frame_382_comment =
  "C++ Interface:\n"
  "clear_frame(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Specifies that a border will not be drawn around the text.\n"
  " */";
#else
static const char *Dtool_TextNode_clear_frame_382_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::has_frame(void) const
 */
static PyObject *Dtool_TextNode_has_frame_383(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextNode::has_frame(void) const
  bool return_value = (*(const TextNode*)local_this).has_frame();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_has_frame_383_comment =
  "C++ Interface:\n"
  "has_frame(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_has_frame_383_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::is_frame_as_margin(void) const
 */
static PyObject *Dtool_TextNode_is_frame_as_margin_384(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextNode::is_frame_as_margin(void) const
  bool return_value = (*(const TextNode*)local_this).is_frame_as_margin();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_is_frame_as_margin_384_comment =
  "C++ Interface:\n"
  "is_frame_as_margin(TextNode self)\n"
  "\n"
  "/**\n"
  " * If this is true, the frame was set via a call to set_frame_as_margin(), and\n"
  " * the dimension of the frame as returned by get_frame_as_set() represent a\n"
  " * margin all around the text.  If false, then the frame was set via a call to\n"
  " * set_frame_actual(), and the dimensions of the frame as returned by\n"
  " * get_frame_as_set() are relative to the text's origin.\n"
  " */";
#else
static const char *Dtool_TextNode_is_frame_as_margin_384_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 TextNode::get_frame_as_set(void) const
 */
static PyObject *Dtool_TextNode_get_frame_as_set_385(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4 TextNode::get_frame_as_set(void) const
  LVecBase4 *return_value = new LVecBase4((*(const TextNode*)local_this).get_frame_as_set());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_frame_as_set_385_comment =
  "C++ Interface:\n"
  "get_frame_as_set(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the dimensions of the frame as set by set_frame_as_margin() or\n"
  " * set_frame_actual().  Use is_frame_actual() to determine how to interpret\n"
  " * the values returned by this function.  It is an error to call this if\n"
  " * has_frame() is false.\n"
  " */";
#else
static const char *Dtool_TextNode_get_frame_as_set_385_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 TextNode::get_frame_actual(void) const
 */
static PyObject *Dtool_TextNode_get_frame_actual_386(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4 TextNode::get_frame_actual(void) const
  LVecBase4 *return_value = new LVecBase4((*(const TextNode*)local_this).get_frame_actual());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_frame_actual_386_comment =
  "C++ Interface:\n"
  "get_frame_actual(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the actual dimensions of the frame around the text.  If the frame\n"
  " * was set via set_frame_as_margin(), the result returned by this function\n"
  " * reflects the size of the current text; if the frame was set via\n"
  " * set_frame_actual(), this returns the values actually set.\n"
  " *\n"
  " * If the text has no frame at all, this returns the dimensions of the text\n"
  " * itself, as if the frame were set with a margin of 0, 0, 0, 0.\n"
  " */";
#else
static const char *Dtool_TextNode_get_frame_actual_386_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_frame_line_width(PN_stdfloat line_width)
 */
static PyObject *Dtool_TextNode_set_frame_line_width_387(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_frame_line_width")) {
    return NULL;
  }
  // 1-inline void TextNode::set_frame_line_width(PN_stdfloat line_width)
  if (PyNumber_Check(arg)) {
    (*local_this).set_frame_line_width((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_line_width(const TextNode self, float line_width)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_frame_line_width_387_comment =
  "C++ Interface:\n"
  "set_frame_line_width(const TextNode self, float line_width)\n"
  "\n"
  "/**\n"
  " * Specifies the thickness of the lines that will be used to draw the frame.\n"
  " */";
#else
static const char *Dtool_TextNode_set_frame_line_width_387_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_frame_line_width(void) const
 */
static PyObject *Dtool_TextNode_get_frame_line_width_388(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextNode::get_frame_line_width(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_frame_line_width();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_frame_line_width_388_comment =
  "C++ Interface:\n"
  "get_frame_line_width(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the thickness of the lines that will be used to draw the frame.\n"
  " */";
#else
static const char *Dtool_TextNode_get_frame_line_width_388_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_frame_corners(bool corners)
 */
static PyObject *Dtool_TextNode_set_frame_corners_389(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_frame_corners")) {
    return NULL;
  }
  // 1-inline void TextNode::set_frame_corners(bool corners)
  (*local_this).set_frame_corners((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_corners(const TextNode self, bool corners)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_frame_corners_389_comment =
  "C++ Interface:\n"
  "set_frame_corners(const TextNode self, bool corners)\n"
  "\n"
  "/**\n"
  " * Enables or disables the drawing of corners for the frame.  These are extra\n"
  " * points drawn at each of the four corners, to soften the ugly edges\n"
  " * generated when the line width is greater than one.\n"
  " */";
#else
static const char *Dtool_TextNode_set_frame_corners_389_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::get_frame_corners(void) const
 */
static PyObject *Dtool_TextNode_get_frame_corners_390(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextNode::get_frame_corners(void) const
  bool return_value = (*(const TextNode*)local_this).get_frame_corners();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_frame_corners_390_comment =
  "C++ Interface:\n"
  "get_frame_corners(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_get_frame_corners_390_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_card_as_margin(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 */
static PyObject *Dtool_TextNode_set_card_as_margin_391(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_card_as_margin")) {
    return NULL;
  }
  // 1-inline void TextNode::set_card_as_margin(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"left", "right", "bottom", "top", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_card_as_margin", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).set_card_as_margin((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_card_as_margin(const TextNode self, float left, float right, float bottom, float top)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_card_as_margin_391_comment =
  "C++ Interface:\n"
  "set_card_as_margin(const TextNode self, float left, float right, float bottom, float top)\n"
  "\n"
  "/**\n"
  " * Specifies that a (possibly opaque or semitransparent) card will be held\n"
  " * behind the text when it is next created.  Like set_frame_as_margin, the\n"
  " * parameters are the amount of additional padding to insert around the text\n"
  " * in each dimension, and all should generally be positive.\n"
  " */";
#else
static const char *Dtool_TextNode_set_card_as_margin_391_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_card_actual(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 */
static PyObject *Dtool_TextNode_set_card_actual_392(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_card_actual")) {
    return NULL;
  }
  // 1-inline void TextNode::set_card_actual(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"left", "right", "bottom", "top", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_card_actual", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).set_card_actual((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_card_actual(const TextNode self, float left, float right, float bottom, float top)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_card_actual_392_comment =
  "C++ Interface:\n"
  "set_card_actual(const TextNode self, float left, float right, float bottom, float top)\n"
  "\n"
  "/**\n"
  " * Similar to set_card_as_margin, except the card is specified in actual\n"
  " * coordinate units (relative to the text's origin), irrespective of the size\n"
  " * of the text.  The left and bottom coordinates should generally be negative,\n"
  " * while the right and top coordinates should generally be positive.\n"
  " */";
#else
static const char *Dtool_TextNode_set_card_actual_392_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_card_decal(bool card_decal)
 */
static PyObject *Dtool_TextNode_set_card_decal_393(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_card_decal")) {
    return NULL;
  }
  // 1-inline void TextNode::set_card_decal(bool card_decal)
  (*local_this).set_card_decal((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_card_decal(const TextNode self, bool card_decal)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_card_decal_393_comment =
  "C++ Interface:\n"
  "set_card_decal(const TextNode self, bool card_decal)\n"
  "\n"
  "/**\n"
  " * Sets the card_decal flag.  When this is true, the text is decalled onto the\n"
  " * card, which is necessary if the TextNode is to be rendered in the 3-d world\n"
  " * without putting it in a bin.\n"
  " */";
#else
static const char *Dtool_TextNode_set_card_decal_393_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_card(void)
 */
static PyObject *Dtool_TextNode_clear_card_394(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_card")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_card(void)
  (*local_this).clear_card();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_card_394_comment =
  "C++ Interface:\n"
  "clear_card(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Specifies that a card will not be drawn behind the text.\n"
  " */";
#else
static const char *Dtool_TextNode_clear_card_394_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::has_card(void) const
 */
static PyObject *Dtool_TextNode_has_card_395(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextNode::has_card(void) const
  bool return_value = (*(const TextNode*)local_this).has_card();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_has_card_395_comment =
  "C++ Interface:\n"
  "has_card(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_has_card_395_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::get_card_decal(void) const
 */
static PyObject *Dtool_TextNode_get_card_decal_396(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextNode::get_card_decal(void) const
  bool return_value = (*(const TextNode*)local_this).get_card_decal();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_card_decal_396_comment =
  "C++ Interface:\n"
  "get_card_decal(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the card_decal flag.  See set_card_decal().\n"
  " */";
#else
static const char *Dtool_TextNode_get_card_decal_396_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextNode::is_card_as_margin(void) const
 */
static PyObject *Dtool_TextNode_is_card_as_margin_397(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextNode::is_card_as_margin(void) const
  bool return_value = (*(const TextNode*)local_this).is_card_as_margin();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_is_card_as_margin_397_comment =
  "C++ Interface:\n"
  "is_card_as_margin(TextNode self)\n"
  "\n"
  "/**\n"
  " * If this is true, the card was set via a call to set_card_as_margin(), and\n"
  " * the dimension of the card as returned by get_card_as_set() represent a\n"
  " * margin all around the text.  If false, then the card was set via a call to\n"
  " * set_card_actual(), and the dimensions of the card as returned by\n"
  " * get_card_as_set() are relative to the text's origin.\n"
  " */";
#else
static const char *Dtool_TextNode_is_card_as_margin_397_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 TextNode::get_card_as_set(void) const
 */
static PyObject *Dtool_TextNode_get_card_as_set_398(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4 TextNode::get_card_as_set(void) const
  LVecBase4 *return_value = new LVecBase4((*(const TextNode*)local_this).get_card_as_set());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_card_as_set_398_comment =
  "C++ Interface:\n"
  "get_card_as_set(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the dimensions of the card as set by set_card_as_margin() or\n"
  " * set_card_actual().  Use is_card_actual() to determine how to interpret the\n"
  " * values returned by this function.  It is an error to call this if\n"
  " * has_card() is false.\n"
  " */";
#else
static const char *Dtool_TextNode_get_card_as_set_398_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 TextNode::get_card_actual(void) const
 */
static PyObject *Dtool_TextNode_get_card_actual_399(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4 TextNode::get_card_actual(void) const
  LVecBase4 *return_value = new LVecBase4((*(const TextNode*)local_this).get_card_actual());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_card_actual_399_comment =
  "C++ Interface:\n"
  "get_card_actual(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the actual dimensions of the card around the text.  If the card was\n"
  " * set via set_card_as_margin(), the result returned by this function reflects\n"
  " * the size of the current text; if the card was set via set_card_actual(),\n"
  " * this returns the values actually set.\n"
  " *\n"
  " * If the text has no card at all, this returns the dimensions of the text\n"
  " * itself, as if the card were set with a margin of 0, 0, 0, 0.\n"
  " */";
#else
static const char *Dtool_TextNode_get_card_actual_399_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 TextNode::get_card_transformed(void) const
 */
static PyObject *Dtool_TextNode_get_card_transformed_400(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4 TextNode::get_card_transformed(void) const
  LVecBase4 *return_value = new LVecBase4((*(const TextNode*)local_this).get_card_transformed());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_card_transformed_400_comment =
  "C++ Interface:\n"
  "get_card_transformed(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the actual card dimensions, transformed by the matrix set by\n"
  " * set_transform().  This returns the card dimensions in actual coordinates as\n"
  " * seen by the rest of the world.  Also see get_upper_left_3d() and\n"
  " * get_lower_right_3d().\n"
  " */";
#else
static const char *Dtool_TextNode_get_card_transformed_400_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_transform(LMatrix4 const &transform)
 */
static PyObject *Dtool_TextNode_set_transform_401(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_transform")) {
    return NULL;
  }
  // 1-inline void TextNode::set_transform(LMatrix4 const &transform)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_transform", "LMatrix4f");
  }
  (*local_this).set_transform(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_transform(const TextNode self, const LMatrix4f transform)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_transform_401_comment =
  "C++ Interface:\n"
  "set_transform(const TextNode self, const LMatrix4f transform)\n"
  "\n"
  "/**\n"
  " * Sets an additional transform that is applied to the entire text paragraph.\n"
  " */";
#else
static const char *Dtool_TextNode_set_transform_401_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 TextNode::get_transform(void) const
 */
static PyObject *Dtool_TextNode_get_transform_402(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4 TextNode::get_transform(void) const
  LMatrix4 *return_value = new LMatrix4((*(const TextNode*)local_this).get_transform());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_transform_402_comment =
  "C++ Interface:\n"
  "get_transform(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_get_transform_402_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_coordinate_system(CoordinateSystem cs)
 */
static PyObject *Dtool_TextNode_set_coordinate_system_403(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_coordinate_system")) {
    return NULL;
  }
  // 1-inline void TextNode::set_coordinate_system(CoordinateSystem cs)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_coordinate_system((CoordinateSystem)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_coordinate_system(const TextNode self, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_coordinate_system_403_comment =
  "C++ Interface:\n"
  "set_coordinate_system(const TextNode self, int cs)\n"
  "\n"
  "/**\n"
  " * Specifies the coordinate system in which the text will be generated.\n"
  " */";
#else
static const char *Dtool_TextNode_set_coordinate_system_403_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CoordinateSystem TextNode::get_coordinate_system(void) const
 */
static PyObject *Dtool_TextNode_get_coordinate_system_404(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CoordinateSystem TextNode::get_coordinate_system(void) const
  CoordinateSystem return_value = (*(const TextNode*)local_this).get_coordinate_system();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_coordinate_system_404_comment =
  "C++ Interface:\n"
  "get_coordinate_system(TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_get_coordinate_system_404_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_usage_hint(GeomEnums::UsageHint usage_hint)
 */
static PyObject *Dtool_TextNode_set_usage_hint_405(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_usage_hint")) {
    return NULL;
  }
  // 1-inline void TextNode::set_usage_hint(GeomEnums::UsageHint usage_hint)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_usage_hint((GeomEnums::UsageHint)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_usage_hint(const TextNode self, int usage_hint)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_usage_hint_405_comment =
  "C++ Interface:\n"
  "set_usage_hint(const TextNode self, int usage_hint)\n"
  "\n"
  "/**\n"
  " * Specifies the UsageHint that will be applied to generated geometry.  The\n"
  " * default is UH_static, which is probably the right setting, but if you know\n"
  " * the TextNode's geometry will have a short lifespan, it may be better to set\n"
  " * it to UH_stream.  See geomEnums.h.\n"
  " */";
#else
static const char *Dtool_TextNode_set_usage_hint_405_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline GeomEnums::UsageHint TextNode::get_usage_hint(void) const
 */
static PyObject *Dtool_TextNode_get_usage_hint_406(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline GeomEnums::UsageHint TextNode::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = (*(const TextNode*)local_this).get_usage_hint();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_usage_hint_406_comment =
  "C++ Interface:\n"
  "get_usage_hint(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the UsageHint that will be applied to generated geometry.  See\n"
  " * set_usage_hint().\n"
  " */";
#else
static const char *Dtool_TextNode_get_usage_hint_406_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_flatten_flags(int flatten_flags)
 */
static PyObject *Dtool_TextNode_set_flatten_flags_407(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_flatten_flags")) {
    return NULL;
  }
  // 1-inline void TextNode::set_flatten_flags(int flatten_flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_flatten_flags((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_flatten_flags(const TextNode self, int flatten_flags)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_flatten_flags_407_comment =
  "C++ Interface:\n"
  "set_flatten_flags(const TextNode self, int flatten_flags)\n"
  "\n"
  "/**\n"
  " * Sets the flatten flags.  This should be a union of the\n"
  " * TextNode::FlattenFlags options.  This controls the degree of flattening\n"
  " * performed on the TextNode's internal geometry (i.e.  the scene graph\n"
  " * returned by generate()) each time the text is changed.  In general, more\n"
  " * flattening means a more optimal result, but it will take more time to\n"
  " * generate.\n"
  " *\n"
  " * The choice may be any of these three:\n"
  " *\n"
  " * FF_none - No flatten operation is called.  The letters are left as\n"
  " * independent Geoms.\n"
  " *\n"
  " * FF_light - A flatten_light() operation is called.  The attributes are\n"
  " * applied to the vertices, but no nodes are removed.\n"
  " *\n"
  " * FF_medium - A flatten_medium() operation is called.  The attributes are\n"
  " * applied to the vertices, and a few trivial nodes are removed.\n"
  " *\n"
  " * FF_strong - A flatten_strong() operation is called.  The attributes are\n"
  " * applied to the vertices, and the resulting nodes are aggressively combined\n"
  " * into as few nodes as possible.\n"
  " *\n"
  " * In addition to the above choices, you may optionally include the following\n"
  " * flag:\n"
  " *\n"
  " * FF_dynamic_merge - Copy the geoms into a single GeomVertexData as we go,\n"
  " * instead of relying on the flatten operation at the end.  This pre-flattens\n"
  " * the text considerably, and may obviate the need for flatten altogether; it\n"
  " * also tends to improve performance considerably even if you do call flatten.\n"
  " * However, it is not as fast as not calling flatten at all.\n"
  " *\n"
  " * The default is taken from the text-flatten and text-dynamic-merge config\n"
  " * variables.\n"
  " */";
#else
static const char *Dtool_TextNode_set_flatten_flags_407_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int TextNode::get_flatten_flags(void) const
 */
static PyObject *Dtool_TextNode_get_flatten_flags_408(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int TextNode::get_flatten_flags(void) const
  int return_value = (*(const TextNode*)local_this).get_flatten_flags();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_flatten_flags_408_comment =
  "C++ Interface:\n"
  "get_flatten_flags(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the flatten flags.  See set_flatten_flags().\n"
  " */";
#else
static const char *Dtool_TextNode_get_flatten_flags_408_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_font(TextFont *font)
 */
static PyObject *Dtool_TextNode_set_font_409(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_font")) {
    return NULL;
  }
  // 1-inline void TextNode::set_font(TextFont *font)
  TextFont *arg_this = (TextFont *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextFont, 1, "TextNode.set_font", false, true);
  if (arg_this != NULL) {
    (*local_this).set_font(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_font(const TextNode self, TextFont font)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_font_409_comment =
  "C++ Interface:\n"
  "set_font(const TextNode self, TextFont font)\n"
  "\n"
  "/**\n"
  " * Sets the font that will be used when making text.  If this is set to NULL,\n"
  " * the default font will be used, which can be set via set_default_font().\n"
  " */";
#else
static const char *Dtool_TextNode_set_font_409_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_font(void)
 */
static PyObject *Dtool_TextNode_clear_font_410(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_font")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_font(void)
  (*local_this).clear_font();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_font_410_comment =
  "C++ Interface:\n"
  "clear_font(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Resets the font to the default font.\n"
  " */";
#else
static const char *Dtool_TextNode_clear_font_410_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_small_caps(bool small_caps)
 */
static PyObject *Dtool_TextNode_set_small_caps_411(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_small_caps")) {
    return NULL;
  }
  // 1-inline void TextNode::set_small_caps(bool small_caps)
  (*local_this).set_small_caps((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_small_caps(const TextNode self, bool small_caps)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_small_caps_411_comment =
  "C++ Interface:\n"
  "set_small_caps(const TextNode self, bool small_caps)\n"
  "\n"
  "/**\n"
  " * Sets the small_caps flag.  When this is set, lowercase letters are\n"
  " * generated as scaled-down versions of their uppercase equivalents.  This is\n"
  " * particularly useful to set for fonts that do not have lowercase letters.\n"
  " *\n"
  " * It is also a good idea to set this for a (dynamic) font that has already\n"
  " * implemented lowercase letters as scaled-down versions of their uppercase\n"
  " * equivalents, since without this flag the texture memory may needlessly\n"
  " * duplicate equivalent glyphs for upper and lowercase letters.  Setting this\n"
  " * flag causes the texture memory to share the mixed-case letters.\n"
  " *\n"
  " * The amount by which the lowercase letters are scaled is specified by\n"
  " * set_small_caps_scale().\n"
  " */";
#else
static const char *Dtool_TextNode_set_small_caps_411_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_small_caps(void)
 */
static PyObject *Dtool_TextNode_clear_small_caps_412(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_small_caps")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_small_caps(void)
  (*local_this).clear_small_caps();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_small_caps_412_comment =
  "C++ Interface:\n"
  "clear_small_caps(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_small_caps_412_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_small_caps_scale(PN_stdfloat small_caps_scale)
 */
static PyObject *Dtool_TextNode_set_small_caps_scale_413(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_small_caps_scale")) {
    return NULL;
  }
  // 1-inline void TextNode::set_small_caps_scale(PN_stdfloat small_caps_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_small_caps_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_small_caps_scale(const TextNode self, float small_caps_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_small_caps_scale_413_comment =
  "C++ Interface:\n"
  "set_small_caps_scale(const TextNode self, float small_caps_scale)\n"
  "\n"
  "/**\n"
  " * Sets the scale factor applied to lowercase letters from their uppercase\n"
  " * equivalents, when the small_caps flag is in effect.  See set_small_caps().\n"
  " * Normally, this will be a number less than one.\n"
  " */";
#else
static const char *Dtool_TextNode_set_small_caps_scale_413_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_small_caps_scale(void)
 */
static PyObject *Dtool_TextNode_clear_small_caps_scale_414(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_small_caps_scale")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_small_caps_scale(void)
  (*local_this).clear_small_caps_scale();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_small_caps_scale_414_comment =
  "C++ Interface:\n"
  "clear_small_caps_scale(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_small_caps_scale_414_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_slant(PN_stdfloat slant)
 */
static PyObject *Dtool_TextNode_set_slant_415(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_slant")) {
    return NULL;
  }
  // 1-inline void TextNode::set_slant(PN_stdfloat slant)
  if (PyNumber_Check(arg)) {
    (*local_this).set_slant((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_slant(const TextNode self, float slant)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_slant_415_comment =
  "C++ Interface:\n"
  "set_slant(const TextNode self, float slant)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_set_slant_415_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_slant(void)
 */
static PyObject *Dtool_TextNode_clear_slant_416(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_slant")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_slant(void)
  (*local_this).clear_slant();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_slant_416_comment =
  "C++ Interface:\n"
  "clear_slant(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_slant_416_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_align(TextProperties::Alignment align_type)
 */
static PyObject *Dtool_TextNode_set_align_417(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_align")) {
    return NULL;
  }
  // 1-inline void TextNode::set_align(TextProperties::Alignment align_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_align((TextProperties::Alignment)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_align(const TextNode self, int align_type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_align_417_comment =
  "C++ Interface:\n"
  "set_align(const TextNode self, int align_type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_set_align_417_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_align(void)
 */
static PyObject *Dtool_TextNode_clear_align_418(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_align")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_align(void)
  (*local_this).clear_align();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_align_418_comment =
  "C++ Interface:\n"
  "clear_align(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_align_418_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_indent(PN_stdfloat indent)
 */
static PyObject *Dtool_TextNode_set_indent_419(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_indent")) {
    return NULL;
  }
  // 1-inline void TextNode::set_indent(PN_stdfloat indent)
  if (PyNumber_Check(arg)) {
    (*local_this).set_indent((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_indent(const TextNode self, float indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_indent_419_comment =
  "C++ Interface:\n"
  "set_indent(const TextNode self, float indent)\n"
  "\n"
  "/**\n"
  " * Specifies the amount of extra space that is inserted before the first\n"
  " * character of each line.  This can be thought of as a left margin.\n"
  " */";
#else
static const char *Dtool_TextNode_set_indent_419_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_indent(void)
 */
static PyObject *Dtool_TextNode_clear_indent_420(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_indent")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_indent(void)
  (*local_this).clear_indent();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_indent_420_comment =
  "C++ Interface:\n"
  "clear_indent(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_indent_420_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_wordwrap(PN_stdfloat wordwrap)
 */
static PyObject *Dtool_TextNode_set_wordwrap_421(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_wordwrap")) {
    return NULL;
  }
  // 1-inline void TextNode::set_wordwrap(PN_stdfloat wordwrap)
  if (PyNumber_Check(arg)) {
    (*local_this).set_wordwrap((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wordwrap(const TextNode self, float wordwrap)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_wordwrap_421_comment =
  "C++ Interface:\n"
  "set_wordwrap(const TextNode self, float wordwrap)\n"
  "\n"
  "/**\n"
  " * Sets the text up to automatically wordwrap when it exceeds the indicated\n"
  " * width.  This can be thought of as a right margin or margin width.\n"
  " */";
#else
static const char *Dtool_TextNode_set_wordwrap_421_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_wordwrap(void)
 */
static PyObject *Dtool_TextNode_clear_wordwrap_422(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_wordwrap")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_wordwrap(void)
  (*local_this).clear_wordwrap();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_wordwrap_422_comment =
  "C++ Interface:\n"
  "clear_wordwrap(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Removes the wordwrap setting from the TextNode.  Text will be as wide as it\n"
  " * is.\n"
  " */";
#else
static const char *Dtool_TextNode_clear_wordwrap_422_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_text_color(LColor const &text_color)
 * inline void TextNode::set_text_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
 */
static PyObject *Dtool_TextNode_set_text_color_423(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_text_color")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "text_color");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'text_color' (pos 1) not found");
      }
      // 1-inline void TextNode::set_text_color(LColor const &text_color)
      LVecBase4f arg_local;
      LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_text_color", "LVecBase4f");
      }
      (*local_this).set_text_color(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void TextNode::set_text_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"r", "g", "b", "a", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_text_color", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_text_color((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_text_color() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_text_color(const TextNode self, const LVecBase4f text_color)\n"
      "set_text_color(const TextNode self, float r, float g, float b, float a)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_text_color_423_comment =
  "C++ Interface:\n"
  "set_text_color(const TextNode self, const LVecBase4f text_color)\n"
  "set_text_color(const TextNode self, float r, float g, float b, float a)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_set_text_color_423_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_text_color(void)
 */
static PyObject *Dtool_TextNode_clear_text_color_424(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_text_color")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_text_color(void)
  (*local_this).clear_text_color();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_text_color_424_comment =
  "C++ Interface:\n"
  "clear_text_color(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Removes the text color specification; the text will be colored whatever it\n"
  " * was in the source font file.\n"
  " */";
#else
static const char *Dtool_TextNode_clear_text_color_424_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_shadow_color(LColor const &shadow_color)
 * inline void TextNode::set_shadow_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
 */
static PyObject *Dtool_TextNode_set_shadow_color_425(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_shadow_color")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "shadow_color");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'shadow_color' (pos 1) not found");
      }
      // 1-inline void TextNode::set_shadow_color(LColor const &shadow_color)
      LVecBase4f arg_local;
      LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_shadow_color", "LVecBase4f");
      }
      (*local_this).set_shadow_color(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void TextNode::set_shadow_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"r", "g", "b", "a", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_shadow_color", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_shadow_color((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_shadow_color() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow_color(const TextNode self, const LVecBase4f shadow_color)\n"
      "set_shadow_color(const TextNode self, float r, float g, float b, float a)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_shadow_color_425_comment =
  "C++ Interface:\n"
  "set_shadow_color(const TextNode self, const LVecBase4f shadow_color)\n"
  "set_shadow_color(const TextNode self, float r, float g, float b, float a)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_set_shadow_color_425_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_shadow_color(void)
 */
static PyObject *Dtool_TextNode_clear_shadow_color_426(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_shadow_color")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_shadow_color(void)
  (*local_this).clear_shadow_color();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_shadow_color_426_comment =
  "C++ Interface:\n"
  "clear_shadow_color(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_shadow_color_426_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_shadow(LVecBase2 const &shadow_offset)
 * inline void TextNode::set_shadow(PN_stdfloat xoffset, PN_stdfloat yoffset)
 */
static PyObject *Dtool_TextNode_set_shadow_427(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_shadow")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "shadow_offset");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'shadow_offset' (pos 1) not found");
      }
      // 1-inline void TextNode::set_shadow(LVecBase2 const &shadow_offset)
      LVecBase2f arg_local;
      LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_shadow", "LVecBase2f");
      }
      (*local_this).set_shadow(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 2:
    {
      // 1-inline void TextNode::set_shadow(PN_stdfloat xoffset, PN_stdfloat yoffset)
      float param1;
      float param2;
      static const char *keyword_list[] = {"xoffset", "yoffset", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_shadow", (char **)keyword_list, &param1, &param2)) {
        (*local_this).set_shadow((PN_stdfloat)param1, (PN_stdfloat)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_shadow() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow(const TextNode self, const LVecBase2f shadow_offset)\n"
      "set_shadow(const TextNode self, float xoffset, float yoffset)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_shadow_427_comment =
  "C++ Interface:\n"
  "set_shadow(const TextNode self, const LVecBase2f shadow_offset)\n"
  "set_shadow(const TextNode self, float xoffset, float yoffset)\n"
  "\n"
  "/**\n"
  " * Specifies that the text should be drawn with a shadow, by creating a second\n"
  " * copy of the text and offsetting it slightly behind the first.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies that the text should be drawn with a shadow, by creating a second\n"
  " * copy of the text and offsetting it slightly behind the first.\n"
  " */";
#else
static const char *Dtool_TextNode_set_shadow_427_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_shadow(void)
 */
static PyObject *Dtool_TextNode_clear_shadow_428(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_shadow")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_shadow(void)
  (*local_this).clear_shadow();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_shadow_428_comment =
  "C++ Interface:\n"
  "clear_shadow(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Specifies that a shadow will not be drawn behind the text.\n"
  " */";
#else
static const char *Dtool_TextNode_clear_shadow_428_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_bin(std::string const &bin)
 */
static PyObject *Dtool_TextNode_set_bin_429(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_bin")) {
    return NULL;
  }
  // 1-inline void TextNode::set_bin(std::string const &bin)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_bin(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bin(const TextNode self, str bin)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_bin_429_comment =
  "C++ Interface:\n"
  "set_bin(const TextNode self, str bin)\n"
  "\n"
  "/**\n"
  " * Names the GeomBin that the TextNode geometry should be assigned to.  If\n"
  " * this is set, then a GeomBinTransition will be created to explicitly place\n"
  " * each component in the named bin.\n"
  " *\n"
  " * The draw_order value will also be passed to each GeomBinTransition as\n"
  " * appropriate; this is particularly useful if this names a GeomBinFixed, e.g.\n"
  " * \"fixed\".\n"
  " */";
#else
static const char *Dtool_TextNode_set_bin_429_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_bin(void)
 */
static PyObject *Dtool_TextNode_clear_bin_430(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_bin")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_bin(void)
  (*local_this).clear_bin();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_bin_430_comment =
  "C++ Interface:\n"
  "clear_bin(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Removes the effect of a previous call to set_bin().  Text will be drawn in\n"
  " * whatever bin it would like to be drawn in, with no explicit ordering.\n"
  " */";
#else
static const char *Dtool_TextNode_clear_bin_430_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int TextNode::set_draw_order(int draw_order)
 */
static PyObject *Dtool_TextNode_set_draw_order_431(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_draw_order")) {
    return NULL;
  }
  // 1-inline int TextNode::set_draw_order(int draw_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*local_this).set_draw_order((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_draw_order(const TextNode self, int draw_order)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_draw_order_431_comment =
  "C++ Interface:\n"
  "set_draw_order(const TextNode self, int draw_order)\n"
  "\n"
  "/**\n"
  " * Sets the drawing order of text created by the TextMaker.  This is actually\n"
  " * the draw order of the card and frame.  The shadow is drawn at\n"
  " * _draw_order+1, and the text at _draw_order+2.\n"
  " *\n"
  " * This affects the sorting order assigned to the arcs as they are created,\n"
  " * and also is passed to whatever bin may be assigned via set_bin().\n"
  " *\n"
  " * The return value is the first unused draw_order number, e.g.  _draw_order +\n"
  " * 3.\n"
  " */";
#else
static const char *Dtool_TextNode_set_draw_order_431_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_draw_order(void)
 */
static PyObject *Dtool_TextNode_clear_draw_order_432(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_draw_order")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_draw_order(void)
  (*local_this).clear_draw_order();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_draw_order_432_comment =
  "C++ Interface:\n"
  "clear_draw_order(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_draw_order_432_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_tab_width(PN_stdfloat tab_width)
 */
static PyObject *Dtool_TextNode_set_tab_width_433(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_tab_width")) {
    return NULL;
  }
  // 1-inline void TextNode::set_tab_width(PN_stdfloat tab_width)
  if (PyNumber_Check(arg)) {
    (*local_this).set_tab_width((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tab_width(const TextNode self, float tab_width)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_tab_width_433_comment =
  "C++ Interface:\n"
  "set_tab_width(const TextNode self, float tab_width)\n"
  "\n"
  "/**\n"
  " * Sets the width of each tab stop, in screen units.  A tab character embedded\n"
  " * in the text will advance the horizontal position to the next tab stop.\n"
  " */";
#else
static const char *Dtool_TextNode_set_tab_width_433_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_tab_width(void)
 */
static PyObject *Dtool_TextNode_clear_tab_width_434(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_tab_width")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_tab_width(void)
  (*local_this).clear_tab_width();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_tab_width_434_comment =
  "C++ Interface:\n"
  "clear_tab_width(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_tab_width_434_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_glyph_scale(PN_stdfloat glyph_scale)
 */
static PyObject *Dtool_TextNode_set_glyph_scale_435(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_glyph_scale")) {
    return NULL;
  }
  // 1-inline void TextNode::set_glyph_scale(PN_stdfloat glyph_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_glyph_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_glyph_scale(const TextNode self, float glyph_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_glyph_scale_435_comment =
  "C++ Interface:\n"
  "set_glyph_scale(const TextNode self, float glyph_scale)\n"
  "\n"
  "/**\n"
  " * Specifies the factor by which to scale each letter of the text as it is\n"
  " * placed.  This can be used (possibly in conjunction with set_glyph_shift())\n"
  " * to implement superscripting or subscripting.\n"
  " */";
#else
static const char *Dtool_TextNode_set_glyph_scale_435_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_glyph_scale(void)
 */
static PyObject *Dtool_TextNode_clear_glyph_scale_436(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_glyph_scale")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_glyph_scale(void)
  (*local_this).clear_glyph_scale();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_glyph_scale_436_comment =
  "C++ Interface:\n"
  "clear_glyph_scale(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_glyph_scale_436_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_glyph_shift(PN_stdfloat glyph_shift)
 */
static PyObject *Dtool_TextNode_set_glyph_shift_437(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_glyph_shift")) {
    return NULL;
  }
  // 1-inline void TextNode::set_glyph_shift(PN_stdfloat glyph_shift)
  if (PyNumber_Check(arg)) {
    (*local_this).set_glyph_shift((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_glyph_shift(const TextNode self, float glyph_shift)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_glyph_shift_437_comment =
  "C++ Interface:\n"
  "set_glyph_shift(const TextNode self, float glyph_shift)\n"
  "\n"
  "/**\n"
  " * Specifies a vertical amount to shift each letter of the text as it is\n"
  " * placed.  This can be used (possibly in conjunction with set_glyph_scale())\n"
  " * to implement superscripting or subscripting.\n"
  " */";
#else
static const char *Dtool_TextNode_set_glyph_shift_437_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_glyph_shift(void)
 */
static PyObject *Dtool_TextNode_clear_glyph_shift_438(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_glyph_shift")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_glyph_shift(void)
  (*local_this).clear_glyph_shift();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_glyph_shift_438_comment =
  "C++ Interface:\n"
  "clear_glyph_shift(const TextNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_clear_glyph_shift_438_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_text(std::string const &text)
 * inline void TextNode::set_text(std::string const &text, TextEncoder::Encoding encoding)
 */
static PyObject *Dtool_TextNode_set_text_439(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_text")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "text");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'text' (pos 1) not found");
      }
      // 1-inline void TextNode::set_text(std::string const &text)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        (*local_this).set_text(std::string(param1_str, param1_len));
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void TextNode::set_text(std::string const &text, TextEncoder::Encoding encoding)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      int param2;
      static const char *keyword_list[] = {"text", "encoding", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:set_text", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
        (*local_this).set_text(std::string(param1_str, param1_len), (TextEncoder::Encoding)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_text() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_text(const TextNode self, str text)\n"
      "set_text(const TextNode self, str text, int encoding)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_text_439_comment =
  "C++ Interface:\n"
  "set_text(const TextNode self, str text)\n"
  "set_text(const TextNode self, str text, int encoding)\n"
  "\n"
  "// These methods are inherited from TextEncoder, but we override here so we\n"
  "// can flag the TextNode as dirty when they have been changed.\n"
  "\n"
  "// These methods are inherited from TextEncoder, but we override here so we\n"
  "// can flag the TextNode as dirty when they have been changed.\n"
  "\n"
  "/**\n"
  " * Changes the text that is displayed under the TextNode.\n"
  " */\n"
  "\n"
  "/**\n"
  " * The two-parameter version of set_text() accepts an explicit encoding; the\n"
  " * text is immediately decoded and stored as a wide-character string.\n"
  " * Subsequent calls to get_text() will return the same text re-encoded using\n"
  " * whichever encoding is specified by set_encoding().\n"
  " */";
#else
static const char *Dtool_TextNode_set_text_439_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::clear_text(void)
 */
static PyObject *Dtool_TextNode_clear_text_440(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.clear_text")) {
    return NULL;
  }
  // 1-inline void TextNode::clear_text(void)
  (*local_this).clear_text();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_clear_text_440_comment =
  "C++ Interface:\n"
  "clear_text(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Removes the text from the TextNode.\n"
  " */";
#else
static const char *Dtool_TextNode_clear_text_440_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::append_text(std::string const &text)
 */
static PyObject *Dtool_TextNode_append_text_441(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.append_text")) {
    return NULL;
  }
  // 1-inline void TextNode::append_text(std::string const &text)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).append_text(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_text(const TextNode self, str text)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_append_text_441_comment =
  "C++ Interface:\n"
  "append_text(const TextNode self, str text)\n"
  "\n"
  "/**\n"
  " * Appends the indicates string to the end of the stored text.\n"
  " */";
#else
static const char *Dtool_TextNode_append_text_441_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::append_unicode_char(wchar_t character)
 */
static PyObject *Dtool_TextNode_append_unicode_char_442(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.append_unicode_char")) {
    return NULL;
  }
  // 1-inline void TextNode::append_unicode_char(wchar_t character)
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
  #else
  PyUnicodeObject *param1;
  #endif
  if (PyArg_Parse(arg, "U:append_unicode_char", &param1)) {
    wchar_t param1_chars[2];
    if (PyUnicode_AsWideChar(param1, param1_chars, 2) == 1) {
      (*local_this).append_unicode_char(param1_chars[0]);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_unicode_char(const TextNode self, unicode char character)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_append_unicode_char_442_comment =
  "C++ Interface:\n"
  "append_unicode_char(const TextNode self, unicode char character)\n"
  "\n"
  "/**\n"
  " * Appends a single character to the end of the stored text.  This may be a\n"
  " * wide character, up to 16 bits in Unicode.\n"
  " */";
#else
static const char *Dtool_TextNode_append_unicode_char_442_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string TextNode::get_wordwrapped_text(void) const
 */
static PyObject *Dtool_TextNode_get_wordwrapped_text_443(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string TextNode::get_wordwrapped_text(void) const
  std::string return_value = (*(const TextNode*)local_this).get_wordwrapped_text();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_wordwrapped_text_443_comment =
  "C++ Interface:\n"
  "get_wordwrapped_text(TextNode self)\n"
  "\n"
  "// After the text has been set, you can query this to determine how it will\n"
  "// be wordwrapped.\n"
  "\n"
  "/**\n"
  " * Returns a string that represents the contents of the text, as it has been\n"
  " * formatted by wordwrap rules.\n"
  " *\n"
  " * In earlier versions, this did not contain any embedded special characters\n"
  " * like \\1 or \\3; now it does.\n"
  " */";
#else
static const char *Dtool_TextNode_get_wordwrapped_text_443_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::calc_width(std::string const &line) const
 * PN_stdfloat TextNode::calc_width(std::wstring const &line) const
 * PN_stdfloat TextNode::calc_width(wchar_t character) const
 */
static PyObject *Dtool_TextNode_calc_width_444(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 PN_stdfloat TextNode::calc_width(std::wstring const &line) const
    #if PY_VERSION_HEX >= 0x03020000
    PyObject *param1;
    #else
    PyUnicodeObject *param1;
    #endif
    if (PyArg_Parse(arg, "U:calc_width", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
      Py_ssize_t param1_len;
      wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
      Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
      wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
      PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
      PN_stdfloat return_value = (*(const TextNode*)local_this).calc_width(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
      PyMem_Free(param1_str);
#endif
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 inline PN_stdfloat TextNode::calc_width(std::string const &line) const
    char *param1_str = NULL;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      PN_stdfloat return_value = (*(const TextNode*)local_this).calc_width(std::string(param1_str, param1_len));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 PN_stdfloat TextNode::calc_width(wchar_t character) const
    #if PY_VERSION_HEX >= 0x03020000
    PyObject *param1;
    #else
    PyUnicodeObject *param1;
    #endif
    if (PyArg_Parse(arg, "U:calc_width", &param1)) {
      wchar_t param1_chars[2];
      if (PyUnicode_AsWideChar(param1, param1_chars, 2) == 1) {
        PN_stdfloat return_value = (*(const TextNode*)local_this).calc_width(param1_chars[0]);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: PN_stdfloat TextNode::calc_width(std::wstring const &line) const
  // No coercion possible: inline PN_stdfloat TextNode::calc_width(std::string const &line) const
  // No coercion possible: PN_stdfloat TextNode::calc_width(wchar_t character) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_width(TextNode self, unicode line)\n"
      "calc_width(TextNode self, str line)\n"
      "calc_width(TextNode self, unicode char character)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_calc_width_444_comment =
  "C++ Interface:\n"
  "calc_width(TextNode self, unicode line)\n"
  "calc_width(TextNode self, str line)\n"
  "calc_width(TextNode self, unicode char character)\n"
  "\n"
  "// These methods calculate the width of a single character or a line of text\n"
  "// in the current font.\n"
  "\n"
  "/**\n"
  " * Returns the width of a line of text of arbitrary characters.  The line\n"
  " * should not include the newline character.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the width of a single character of the font, or 0.0 if the\n"
  " * character is not known.  This may be a wide character (greater than 255).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the width of a line of text of arbitrary characters.  The line\n"
  " * should not include the newline character or any embedded control characters\n"
  " * like \\1 or \\3.\n"
  " */";
#else
static const char *Dtool_TextNode_calc_width_444_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool TextNode::has_exact_character(wchar_t character) const
 */
static PyObject *Dtool_TextNode_has_exact_character_445(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool TextNode::has_exact_character(wchar_t character) const
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
  #else
  PyUnicodeObject *param1;
  #endif
  if (PyArg_Parse(arg, "U:has_exact_character", &param1)) {
    wchar_t param1_chars[2];
    if (PyUnicode_AsWideChar(param1, param1_chars, 2) == 1) {
      bool return_value = (*(const TextNode*)local_this).has_exact_character(param1_chars[0]);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_exact_character(TextNode self, unicode char character)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_has_exact_character_445_comment =
  "C++ Interface:\n"
  "has_exact_character(TextNode self, unicode char character)\n"
  "\n"
  "/**\n"
  " * Returns true if the named character exists in the font exactly as named,\n"
  " * false otherwise.  Note that because Panda can assemble glyphs together\n"
  " * automatically using cheesy accent marks, this is not a reliable indicator\n"
  " * of whether a suitable glyph can be rendered for the character.  For that,\n"
  " * use has_character() instead.\n"
  " *\n"
  " * This returns true for whitespace and Unicode whitespace characters (if they\n"
  " * exist in the font), but returns false for characters that would render with\n"
  " * the \"invalid glyph\".  It also returns false for characters that would be\n"
  " * synthesized within Panda, but see has_character().\n"
  " */";
#else
static const char *Dtool_TextNode_has_exact_character_445_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool TextNode::has_character(wchar_t character) const
 */
static PyObject *Dtool_TextNode_has_character_446(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool TextNode::has_character(wchar_t character) const
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
  #else
  PyUnicodeObject *param1;
  #endif
  if (PyArg_Parse(arg, "U:has_character", &param1)) {
    wchar_t param1_chars[2];
    if (PyUnicode_AsWideChar(param1, param1_chars, 2) == 1) {
      bool return_value = (*(const TextNode*)local_this).has_character(param1_chars[0]);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_character(TextNode self, unicode char character)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_has_character_446_comment =
  "C++ Interface:\n"
  "has_character(TextNode self, unicode char character)\n"
  "\n"
  "/**\n"
  " * Returns true if the named character exists in the font or can be\n"
  " * synthesized by Panda, false otherwise.  (Panda can synthesize some accented\n"
  " * characters by combining similar-looking glyphs from the font.)\n"
  " *\n"
  " * This returns true for whitespace and Unicode whitespace characters (if they\n"
  " * exist in the font), but returns false for characters that would render with\n"
  " * the \"invalid glyph\".\n"
  " */";
#else
static const char *Dtool_TextNode_has_character_446_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool TextNode::is_whitespace(wchar_t character) const
 */
static PyObject *Dtool_TextNode_is_whitespace_447(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool TextNode::is_whitespace(wchar_t character) const
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
  #else
  PyUnicodeObject *param1;
  #endif
  if (PyArg_Parse(arg, "U:is_whitespace", &param1)) {
    wchar_t param1_chars[2];
    if (PyUnicode_AsWideChar(param1, param1_chars, 2) == 1) {
      bool return_value = (*(const TextNode*)local_this).is_whitespace(param1_chars[0]);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_whitespace(TextNode self, unicode char character)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_is_whitespace_447_comment =
  "C++ Interface:\n"
  "is_whitespace(TextNode self, unicode char character)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated character represents whitespace in the font,\n"
  " * or false if anything visible will be rendered for it.\n"
  " *\n"
  " * This returns true for whitespace and Unicode whitespace characters (if they\n"
  " * exist in the font), and returns false for any other characters, including\n"
  " * characters that do not exist in the font (these would be rendered with the\n"
  " * \"invalid glyph\", which is visible).\n"
  " *\n"
  " * Note that this function can be reliably used to identify Unicode whitespace\n"
  " * characters only if the font has all of the whitespace characters defined.\n"
  " * It will return false for any character not in the font, even if it is an\n"
  " * official Unicode whitespace character.\n"
  " */";
#else
static const char *Dtool_TextNode_is_whitespace_447_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::set_wtext(std::wstring const &wtext)
 */
static PyObject *Dtool_TextNode_set_wtext_448(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.set_wtext")) {
    return NULL;
  }
  // 1-inline void TextNode::set_wtext(std::wstring const &wtext)
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
  #else
  PyUnicodeObject *param1;
  #endif
  if (PyArg_Parse(arg, "U:set_wtext", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    (*local_this).set_wtext(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wtext(const TextNode self, unicode wtext)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_set_wtext_448_comment =
  "C++ Interface:\n"
  "set_wtext(const TextNode self, unicode wtext)\n"
  "\n"
  "// Direct support for wide-character strings.\n"
  "\n"
  "/**\n"
  " * Changes the text that is displayed under the TextNode, with a wide text.\n"
  " * This automatically sets the string reported by get_text() to the 8-bit\n"
  " * encoded version of the same string.\n"
  " */";
#else
static const char *Dtool_TextNode_set_wtext_448_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::append_wtext(std::wstring const &text)
 */
static PyObject *Dtool_TextNode_append_wtext_449(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.append_wtext")) {
    return NULL;
  }
  // 1-inline void TextNode::append_wtext(std::wstring const &text)
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
  #else
  PyUnicodeObject *param1;
  #endif
  if (PyArg_Parse(arg, "U:append_wtext", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    (*local_this).append_wtext(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_wtext(const TextNode self, unicode text)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_append_wtext_449_comment =
  "C++ Interface:\n"
  "append_wtext(const TextNode self, unicode text)\n"
  "\n"
  "/**\n"
  " * Appends the indicates string to the end of the stored wide-character text.\n"
  " */";
#else
static const char *Dtool_TextNode_append_wtext_449_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::wstring TextNode::get_wordwrapped_wtext(void) const
 */
static PyObject *Dtool_TextNode_get_wordwrapped_wtext_450(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::wstring TextNode::get_wordwrapped_wtext(void) const
  std::wstring return_value = (*(const TextNode*)local_this).get_wordwrapped_wtext();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_wordwrapped_wtext_450_comment =
  "C++ Interface:\n"
  "get_wordwrapped_wtext(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns a wstring that represents the contents of the text, as it has been\n"
  " * formatted by wordwrap rules.\n"
  " *\n"
  " * In earlier versions, this did not contain any embedded special characters\n"
  " * like \\1 or \\3; now it does.\n"
  " */";
#else
static const char *Dtool_TextNode_get_wordwrapped_wtext_450_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void TextNode::output(ostream &out) const
 */
static PyObject *Dtool_TextNode_output_451(PyObject *self, PyObject *arg) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void TextNode::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "TextNode.output", false, true);
  if (arg_this != NULL) {
    (*(const TextNode*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(TextNode self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_output_451_comment =
  "C++ Interface:\n"
  "output(TextNode self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_output_451_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void TextNode::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_TextNode_write_452(PyObject *self, PyObject *args, PyObject *kwds) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void TextNode::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "TextNode.write", false, true);
    if (param1_this != NULL) {
      (*(const TextNode*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(TextNode self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextNode_write_452_comment =
  "C++ Interface:\n"
  "write(TextNode self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextNode_write_452_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_left(void) const
 */
static PyObject *Dtool_TextNode_get_left_453(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextNode::get_left(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_left();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_left_453_comment =
  "C++ Interface:\n"
  "get_left(TextNode self)\n"
  "\n"
  "// The following functions return information about the text that was last\n"
  "// built (and is currently visible).\n"
  "\n"
  "/**\n"
  " * Returns the leftmost extent of the text in local 2-d coordinates,\n"
  " * unmodified by the set_transform() matrix.\n"
  " */";
#else
static const char *Dtool_TextNode_get_left_453_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_right(void) const
 */
static PyObject *Dtool_TextNode_get_right_454(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextNode::get_right(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_right();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_right_454_comment =
  "C++ Interface:\n"
  "get_right(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the rightmost extent of the text in local 2-d coordinates,\n"
  " * unmodified by the set_transform() matrix.\n"
  " */";
#else
static const char *Dtool_TextNode_get_right_454_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_bottom(void) const
 */
static PyObject *Dtool_TextNode_get_bottom_455(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextNode::get_bottom(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_bottom();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_bottom_455_comment =
  "C++ Interface:\n"
  "get_bottom(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the bottommost extent of the text in local 2-d coordinates,\n"
  " * unmodified by the set_transform() matrix.\n"
  " */";
#else
static const char *Dtool_TextNode_get_bottom_455_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_top(void) const
 */
static PyObject *Dtool_TextNode_get_top_456(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextNode::get_top(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_top();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_top_456_comment =
  "C++ Interface:\n"
  "get_top(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the topmost extent of the text in local 2-d coordinates, unmodified\n"
  " * by the set_transform() matrix.\n"
  " */";
#else
static const char *Dtool_TextNode_get_top_456_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_height(void) const
 */
static PyObject *Dtool_TextNode_get_height_457(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextNode::get_height(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_height();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_height_457_comment =
  "C++ Interface:\n"
  "get_height(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the net height of the text in local 2-d coordinates.\n"
  " */";
#else
static const char *Dtool_TextNode_get_height_457_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TextNode::get_width(void) const
 */
static PyObject *Dtool_TextNode_get_width_458(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TextNode::get_width(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_width();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_width_458_comment =
  "C++ Interface:\n"
  "get_width(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the net width of the text in local 2-d coordinates.\n"
  " */";
#else
static const char *Dtool_TextNode_get_width_458_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 TextNode::get_upper_left_3d(void) const
 */
static PyObject *Dtool_TextNode_get_upper_left_3d_459(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 TextNode::get_upper_left_3d(void) const
  LPoint3 *return_value = new LPoint3((*(const TextNode*)local_this).get_upper_left_3d());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_upper_left_3d_459_comment =
  "C++ Interface:\n"
  "get_upper_left_3d(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the upper-left extent of the text object, after it has been\n"
  " * transformed into 3-d space by applying the set_transform() matrix.\n"
  " */";
#else
static const char *Dtool_TextNode_get_upper_left_3d_459_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 TextNode::get_lower_right_3d(void) const
 */
static PyObject *Dtool_TextNode_get_lower_right_3d_460(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 TextNode::get_lower_right_3d(void) const
  LPoint3 *return_value = new LPoint3((*(const TextNode*)local_this).get_lower_right_3d());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_lower_right_3d_460_comment =
  "C++ Interface:\n"
  "get_lower_right_3d(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the lower-right extent of the text object, after it has been\n"
  " * transformed into 3-d space by applying the set_transform() matrix.\n"
  " */";
#else
static const char *Dtool_TextNode_get_lower_right_3d_460_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int TextNode::get_num_rows(void) const
 */
static PyObject *Dtool_TextNode_get_num_rows_461(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int TextNode::get_num_rows(void) const
  int return_value = (*(const TextNode*)local_this).get_num_rows();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_num_rows_461_comment =
  "C++ Interface:\n"
  "get_num_rows(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of rows of text that were generated.  This counts word-\n"
  " * wrapped rows as well as rows generated due to embedded newlines.\n"
  " */";
#else
static const char *Dtool_TextNode_get_num_rows_461_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< PandaNode > TextNode::generate(void)
 */
static PyObject *Dtool_TextNode_generate_462(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.generate")) {
    return NULL;
  }
  // 1-PointerTo< PandaNode > TextNode::generate(void)
  PointerTo< PandaNode > return_value = (*local_this).generate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  PandaNode *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PandaNode, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextNode_generate_462_comment =
  "C++ Interface:\n"
  "generate(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Generates the text, according to the parameters indicated within the\n"
  " * TextNode, and returns a Node that may be parented within the tree to\n"
  " * represent it.\n"
  " */";
#else
static const char *Dtool_TextNode_generate_462_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::update(void)
 */
static PyObject *Dtool_TextNode_update_463(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.update")) {
    return NULL;
  }
  // 1-inline void TextNode::update(void)
  (*local_this).update();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_update_463_comment =
  "C++ Interface:\n"
  "update(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Can be called after the TextNode has been fully configured, to force the\n"
  " * node to recompute its text immediately, rather than waiting for it to be\n"
  " * drawn.  This call is optional.\n"
  " */";
#else
static const char *Dtool_TextNode_update_463_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextNode::force_update(void)
 */
static PyObject *Dtool_TextNode_force_update_464(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.force_update")) {
    return NULL;
  }
  // 1-inline void TextNode::force_update(void)
  (*local_this).force_update();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextNode_force_update_464_comment =
  "C++ Interface:\n"
  "force_update(const TextNode self)\n"
  "\n"
  "/**\n"
  " * Forces the TextNode to recompute itself now, even if it believes nothing\n"
  " * has changed.  Normally, this should not need to be called, but it may be\n"
  " * useful if some properties change outside of the TextNode's knowledge (for\n"
  " * instance, within the font).\n"
  " */";
#else
static const char *Dtool_TextNode_force_update_464_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PandaNode *TextNode::get_internal_geom(void) const
 */
static PyObject *Dtool_TextNode_get_internal_geom_465(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-PandaNode *TextNode::get_internal_geom(void) const
  PandaNode *return_value = (*(const TextNode*)local_this).get_internal_geom();
  if (return_value != (PandaNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PandaNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_internal_geom_465_comment =
  "C++ Interface:\n"
  "get_internal_geom(TextNode self)\n"
  "\n"
  "/**\n"
  " * Returns the actual node that is used internally to render the text, if the\n"
  " * TextNode is parented within the scene graph.\n"
  " *\n"
  " * In general, you should not call this method.  Call generate() instead if\n"
  " * you want to get a handle to geometry that represents the text.  This method\n"
  " * is provided as a debugging aid only.\n"
  " */";
#else
static const char *Dtool_TextNode_get_internal_geom_465_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TextNode::get_class_type(void)
 */
static PyObject *Dtool_TextNode_get_class_type_547(PyObject *, PyObject *) {
  // 1-static TypeHandle TextNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(TextNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_get_class_type_547_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TextNode_get_class_type_547_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PandaNode *TextNode::upcast_to_PandaNode(void)
 */
static PyObject *Dtool_TextNode_upcast_to_PandaNode_351(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.upcast_to_PandaNode")) {
    return NULL;
  }
  // 1-PandaNode *TextNode::upcast_to_PandaNode(void)
  PandaNode *return_value = (PandaNode *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextNode_upcast_to_PandaNode_351_comment =
  "C++ Interface:\n"
  "upcast_to_PandaNode(const TextNode self)\n"
  "\n"
  "upcast from TextNode to PandaNode";
#else
static const char *Dtool_TextNode_upcast_to_PandaNode_351_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TextEncoder *TextNode::upcast_to_TextEncoder(void)
 */
static PyObject *Dtool_TextNode_upcast_to_TextEncoder_354(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.upcast_to_TextEncoder")) {
    return NULL;
  }
  // 1-TextEncoder *TextNode::upcast_to_TextEncoder(void)
  TextEncoder *return_value = (TextEncoder *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextEncoder, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_upcast_to_TextEncoder_354_comment =
  "C++ Interface:\n"
  "upcast_to_TextEncoder(const TextNode self)\n"
  "\n"
  "upcast from TextNode to TextEncoder";
#else
static const char *Dtool_TextNode_upcast_to_TextEncoder_354_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TextProperties *TextNode::upcast_to_TextProperties(void)
 */
static PyObject *Dtool_TextNode_upcast_to_TextProperties_356(PyObject *self, PyObject *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.upcast_to_TextProperties")) {
    return NULL;
  }
  // 1-TextProperties *TextNode::upcast_to_TextProperties(void)
  TextProperties *return_value = (TextProperties *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextProperties, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TextNode_upcast_to_TextProperties_356_comment =
  "C++ Interface:\n"
  "upcast_to_TextProperties(const TextNode self)\n"
  "\n"
  "upcast from TextNode to TextProperties";
#else
static const char *Dtool_TextNode_upcast_to_TextProperties_356_comment = NULL;
#endif

static PyObject *Dtool_TextNode_max_rows_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int TextNode::get_max_rows(void) const
  int return_value = (*(const TextNode*)local_this).get_max_rows();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_max_rows_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.max_rows")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete max_rows attribute");
    return -1;
  }
  // 1-inline void TextNode::set_max_rows(int max_rows)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_max_rows((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_rows(const TextNode self, int max_rows)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_frame_color_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LColor TextNode::get_frame_color(void) const
  LColor *return_value = new LColor((*(const TextNode*)local_this).get_frame_color());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_TextNode_frame_color_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.frame_color")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete frame_color attribute");
    return -1;
  }
  // 1-inline void TextNode::set_frame_color(LColor const &frame_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_frame_color", "LVecBase4f");
    return -1;
  }
  (*local_this).set_frame_color(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_frame_color(const TextNode self, const LVecBase4f frame_color)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_card_color_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LColor TextNode::get_card_color(void) const
  LColor *return_value = new LColor((*(const TextNode*)local_this).get_card_color());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_TextNode_card_color_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.card_color")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete card_color attribute");
    return -1;
  }
  // 1-inline void TextNode::set_card_color(LColor const &card_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_card_color", "LVecBase4f");
    return -1;
  }
  (*local_this).set_card_color(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_card_color(const TextNode self, const LVecBase4f card_color)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_card_texture_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline Texture *TextNode::get_card_texture(void) const
  Texture *return_value = (*(const TextNode*)local_this).get_card_texture();
  if (return_value != (Texture *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (Texture *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_TextNode_card_texture_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.card_texture")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete card_texture attribute");
    return -1;
  }
  // 1-inline void TextNode::set_card_texture(Texture *card_texture)
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "TextNode.set_card_texture", false, true);
  if (arg_this != NULL) {
    (*local_this).set_card_texture(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_card_texture(const TextNode self, Texture card_texture)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_frame_line_width_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat TextNode::get_frame_line_width(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_frame_line_width();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_frame_line_width_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.frame_line_width")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete frame_line_width attribute");
    return -1;
  }
  // 1-inline void TextNode::set_frame_line_width(PN_stdfloat line_width)
  if (PyNumber_Check(arg)) {
    (*local_this).set_frame_line_width((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_frame_line_width(const TextNode self, float line_width)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_frame_corners_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool TextNode::get_frame_corners(void) const
  bool return_value = (*(const TextNode*)local_this).get_frame_corners();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_frame_corners_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.frame_corners")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete frame_corners attribute");
    return -1;
  }
  // 1-inline void TextNode::set_frame_corners(bool corners)
  (*local_this).set_frame_corners((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_frame_corners(const TextNode self, bool corners)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_transform_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LMatrix4 TextNode::get_transform(void) const
  LMatrix4 *return_value = new LMatrix4((*(const TextNode*)local_this).get_transform());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
}

static int Dtool_TextNode_transform_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.transform")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete transform attribute");
    return -1;
  }
  // 1-inline void TextNode::set_transform(LMatrix4 const &transform)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_transform", "LMatrix4f");
    return -1;
  }
  (*local_this).set_transform(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_transform(const TextNode self, const LMatrix4f transform)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_coordinate_system_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline CoordinateSystem TextNode::get_coordinate_system(void) const
  CoordinateSystem return_value = (*(const TextNode*)local_this).get_coordinate_system();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_coordinate_system_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.coordinate_system")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete coordinate_system attribute");
    return -1;
  }
  // 1-inline void TextNode::set_coordinate_system(CoordinateSystem cs)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_coordinate_system((CoordinateSystem)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_coordinate_system(const TextNode self, int cs)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_usage_hint_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline GeomEnums::UsageHint TextNode::get_usage_hint(void) const
  GeomEnums::UsageHint return_value = (*(const TextNode*)local_this).get_usage_hint();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_usage_hint_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.usage_hint")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete usage_hint attribute");
    return -1;
  }
  // 1-inline void TextNode::set_usage_hint(GeomEnums::UsageHint usage_hint)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_usage_hint((GeomEnums::UsageHint)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_usage_hint(const TextNode self, int usage_hint)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_flatten_flags_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int TextNode::get_flatten_flags(void) const
  int return_value = (*(const TextNode*)local_this).get_flatten_flags();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_flatten_flags_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.flatten_flags")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete flatten_flags attribute");
    return -1;
  }
  // 1-inline void TextNode::set_flatten_flags(int flatten_flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_flatten_flags((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_flatten_flags(const TextNode self, int flatten_flags)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_text_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string TextNode::get_text(void) const
  std::string return_value = (*(const TextNode*)local_this).get_text();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_text_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.text")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete text attribute");
    return -1;
  }
  // 1-inline void TextNode::set_text(std::string const &text)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_text(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_text(const TextNode self, str text)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_font_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_font()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline TextFont *TextNode::get_font(void) const
  TextFont *return_value = (*(const TextNode*)local_this).get_font();
  if (return_value != (TextFont *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (TextFont *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextFont, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_TextNode_font_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.font")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete font attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_font();
    return 0;
  }
  // 1-inline void TextNode::set_font(TextFont *font)
  TextFont *arg_this = (TextFont *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextFont, 1, "TextNode.set_font", false, true);
  if (arg_this != NULL) {
    (*local_this).set_font(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_font(const TextNode self, TextFont font)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_small_caps_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_small_caps()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool TextNode::get_small_caps(void) const
  bool return_value = (*(const TextNode*)local_this).get_small_caps();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_small_caps_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.small_caps")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete small_caps attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_small_caps();
    return 0;
  }
  // 1-inline void TextNode::set_small_caps(bool small_caps)
  (*local_this).set_small_caps((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_small_caps(const TextNode self, bool small_caps)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_small_caps_scale_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_small_caps_scale()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextNode::get_small_caps_scale(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_small_caps_scale();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_small_caps_scale_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.small_caps_scale")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete small_caps_scale attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_small_caps_scale();
    return 0;
  }
  // 1-inline void TextNode::set_small_caps_scale(PN_stdfloat small_caps_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_small_caps_scale((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_small_caps_scale(const TextNode self, float small_caps_scale)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_slant_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_slant()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextNode::get_slant(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_slant();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_slant_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.slant")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete slant attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_slant();
    return 0;
  }
  // 1-inline void TextNode::set_slant(PN_stdfloat slant)
  if (PyNumber_Check(arg)) {
    (*local_this).set_slant((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_slant(const TextNode self, float slant)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_underscore_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_underscore()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool TextNode::get_underscore(void) const
  bool return_value = (*(const TextNode*)local_this).get_underscore();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_underscore_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.underscore")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete underscore attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_underscore();
    return 0;
  }
  // 1-inline void TextNode::set_underscore(bool underscore)
  (*local_this).set_underscore((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_underscore(const TextNode self, bool underscore)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_underscore_height_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_underscore_height()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextNode::get_underscore_height(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_underscore_height();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_underscore_height_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.underscore_height")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete underscore_height attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_underscore_height();
    return 0;
  }
  // 1-inline void TextNode::set_underscore_height(PN_stdfloat underscore_height)
  if (PyNumber_Check(arg)) {
    (*local_this).set_underscore_height((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_underscore_height(const TextNode self, float underscore_height)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_align_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_align()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline TextProperties::Alignment TextNode::get_align(void) const
  TextProperties::Alignment return_value = (*(const TextNode*)local_this).get_align();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_align_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.align")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete align attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_align();
    return 0;
  }
  // 1-inline void TextNode::set_align(TextProperties::Alignment align_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_align((TextProperties::Alignment)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_align(const TextNode self, int align_type)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_indent_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_indent()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextNode::get_indent(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_indent();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_indent_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.indent")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete indent attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_indent();
    return 0;
  }
  // 1-inline void TextNode::set_indent(PN_stdfloat indent)
  if (PyNumber_Check(arg)) {
    (*local_this).set_indent((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_indent(const TextNode self, float indent)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_wordwrap_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_wordwrap()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextNode::get_wordwrap(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_wordwrap();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_wordwrap_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.wordwrap")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete wordwrap attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_wordwrap();
    return 0;
  }
  // 1-inline void TextNode::set_wordwrap(PN_stdfloat wordwrap)
  if (PyNumber_Check(arg)) {
    (*local_this).set_wordwrap((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_wordwrap(const TextNode self, float wordwrap)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_preserve_trailing_whitespace_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_preserve_trailing_whitespace()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool TextNode::get_preserve_trailing_whitespace(void) const
  bool return_value = (*(const TextNode*)local_this).get_preserve_trailing_whitespace();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_preserve_trailing_whitespace_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.preserve_trailing_whitespace")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete preserve_trailing_whitespace attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_preserve_trailing_whitespace();
    return 0;
  }
  // 1-inline void TextNode::set_preserve_trailing_whitespace(bool preserve_trailing_whitespace)
  (*local_this).set_preserve_trailing_whitespace((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_preserve_trailing_whitespace(const TextNode self, bool preserve_trailing_whitespace)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_text_color_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_text_color()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor TextNode::get_text_color(void) const
  LColor *return_value = new LColor((*(const TextNode*)local_this).get_text_color());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_TextNode_text_color_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.text_color")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete text_color attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_text_color();
    return 0;
  }
  // 1-inline void TextNode::set_text_color(LColor const &text_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_text_color", "LVecBase4f");
    return -1;
  }
  (*local_this).set_text_color(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_text_color(const TextNode self, const LVecBase4f text_color)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_shadow_color_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_shadow_color()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor TextNode::get_shadow_color(void) const
  LColor *return_value = new LColor((*(const TextNode*)local_this).get_shadow_color());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_TextNode_shadow_color_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.shadow_color")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete shadow_color attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_shadow_color();
    return 0;
  }
  // 1-inline void TextNode::set_shadow_color(LColor const &shadow_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_shadow_color", "LVecBase4f");
    return -1;
  }
  (*local_this).set_shadow_color(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_shadow_color(const TextNode self, const LVecBase4f shadow_color)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_shadow_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_shadow()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LVector2 TextNode::get_shadow(void) const
  LVector2 *return_value = new LVector2((*(const TextNode*)local_this).get_shadow());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

static int Dtool_TextNode_shadow_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.shadow")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete shadow attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_shadow();
    return 0;
  }
  // 1-inline void TextNode::set_shadow(LVecBase2 const &shadow_offset)
  LVecBase2f arg_local;
  LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TextNode.set_shadow", "LVecBase2f");
    return -1;
  }
  (*local_this).set_shadow(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_shadow(const TextNode self, const LVecBase2f shadow_offset)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_bin_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_bin()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline std::string const &TextNode::get_bin(void) const
  std::string const &return_value = (*(const TextNode*)local_this).get_bin();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_bin_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.bin")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete bin attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_bin();
    return 0;
  }
  // 1-inline void TextNode::set_bin(std::string const &bin)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_bin(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bin(const TextNode self, str bin)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_draw_order_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_draw_order()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline int TextNode::get_draw_order(void) const
  int return_value = (*(const TextNode*)local_this).get_draw_order();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_draw_order_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.draw_order")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete draw_order attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_draw_order();
    return 0;
  }
  // 1-inline int TextNode::set_draw_order(int draw_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    int return_value = (*local_this).set_draw_order((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return return_value;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_draw_order(const TextNode self, int draw_order)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_tab_width_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_tab_width()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextNode::get_tab_width(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_tab_width();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_tab_width_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.tab_width")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete tab_width attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_tab_width();
    return 0;
  }
  // 1-inline void TextNode::set_tab_width(PN_stdfloat tab_width)
  if (PyNumber_Check(arg)) {
    (*local_this).set_tab_width((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_tab_width(const TextNode self, float tab_width)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_glyph_scale_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_glyph_scale()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextNode::get_glyph_scale(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_glyph_scale();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_glyph_scale_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.glyph_scale")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete glyph_scale attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_glyph_scale();
    return 0;
  }
  // 1-inline void TextNode::set_glyph_scale(PN_stdfloat glyph_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_glyph_scale((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_glyph_scale(const TextNode self, float glyph_scale)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_glyph_shift_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_glyph_shift()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextNode::get_glyph_shift(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_glyph_shift();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_glyph_shift_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.glyph_shift")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete glyph_shift attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_glyph_shift();
    return 0;
  }
  // 1-inline void TextNode::set_glyph_shift(PN_stdfloat glyph_shift)
  if (PyNumber_Check(arg)) {
    (*local_this).set_glyph_shift((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_glyph_shift(const TextNode self, float glyph_shift)\n");
  }
  return -1;
}

static PyObject *Dtool_TextNode_text_scale_Getter(PyObject *self, void *) {
  const TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_text_scale()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PN_stdfloat TextNode::get_text_scale(void) const
  PN_stdfloat return_value = (*(const TextNode*)local_this).get_text_scale();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TextNode_text_scale_Setter(PyObject *self, PyObject *arg, void *) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextNode, (void **)&local_this, "TextNode.text_scale")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete text_scale attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_text_scale();
    return 0;
  }
  // 1-inline void TextNode::set_text_scale(PN_stdfloat text_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_text_scale((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_text_scale(const TextNode self, float text_scale)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * TextNode::TextNode(std::string const &name)
 * TextNode::TextNode(std::string const &name, TextProperties const &copy)
 */
static int Dtool_Init_TextNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "name");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
        return -1;
      }
      // 1-TextNode::TextNode(std::string const &name)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        TextNode *return_value = new TextNode(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextNode, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-TextNode::TextNode(std::string const &name, TextProperties const &copy)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      static const char *keyword_list[] = {"name", "copy", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:TextNode", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
        TextProperties const *param1_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TextProperties, 1, "TextNode.TextNode", true, true);
        if (param1_this != NULL) {
          TextNode *return_value = new TextNode(std::string(param0_str, param0_len), *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextNode, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TextNode() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TextNode(str name)\n"
      "TextNode(str name, const TextProperties copy)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_TextNode(PyObject *args, CPT(TextNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_TextNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-TextNode::TextNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      TextNode *return_value = new TextNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-TextNode::TextNode(std::string const &name, TextProperties const &copy)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "s#O:TextNode", &param0_str, &param0_len, &param1)) {
        TextProperties const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_TextProperties, (void **)&param1_this);
        if (param1_this != NULL) {
          TextNode *return_value = new TextNode(std::string(param0_str, param0_len), *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_TextNode(PyObject *args, PT(TextNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_TextNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-TextNode::TextNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      TextNode *return_value = new TextNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-TextNode::TextNode(std::string const &name, TextProperties const &copy)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "s#O:TextNode", &param0_str, &param0_len, &param1)) {
        TextProperties const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_TextProperties, (void **)&param1_this);
        if (param1_this != NULL) {
          TextNode *return_value = new TextNode(std::string(param0_str, param0_len), *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_TextNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TextNode) {
    printf("TextNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TextNode *local_this = (TextNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TextNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TextEncoder) {
    return (TextEncoder *) local_this;
  }
  if (requested_type == Dtool_Ptr_TextProperties) {
    return (TextProperties *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TextNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TextNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (TextNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (TextNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TextNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TextEncoder) {
    TextEncoder* other_this = (TextEncoder*)from_this;
    return (TextNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TextProperties) {
    TextProperties* other_this = (TextProperties*)from_this;
    return (TextNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TextNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (TextNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (TextNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for TextGlyph (TextGlyph)
 */
static PyMethodDef Dtool_Methods_TextGlyph[] = {
  {"get_character", &Dtool_TextGlyph_get_character_3, METH_NOARGS, (const char *)Dtool_TextGlyph_get_character_3_comment},
  {"getCharacter", &Dtool_TextGlyph_get_character_3, METH_NOARGS, (const char *)Dtool_TextGlyph_get_character_3_comment},
  {"has_quad", &Dtool_TextGlyph_has_quad_4, METH_NOARGS, (const char *)Dtool_TextGlyph_has_quad_4_comment},
  {"hasQuad", &Dtool_TextGlyph_has_quad_4, METH_NOARGS, (const char *)Dtool_TextGlyph_has_quad_4_comment},
  {"get_quad", (PyCFunction) &Dtool_TextGlyph_get_quad_5, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextGlyph_get_quad_5_comment},
  {"getQuad", (PyCFunction) &Dtool_TextGlyph_get_quad_5, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextGlyph_get_quad_5_comment},
  {"get_state", &Dtool_TextGlyph_get_state_6, METH_NOARGS, (const char *)Dtool_TextGlyph_get_state_6_comment},
  {"getState", &Dtool_TextGlyph_get_state_6, METH_NOARGS, (const char *)Dtool_TextGlyph_get_state_6_comment},
  {"get_advance", &Dtool_TextGlyph_get_advance_7, METH_NOARGS, (const char *)Dtool_TextGlyph_get_advance_7_comment},
  {"getAdvance", &Dtool_TextGlyph_get_advance_7, METH_NOARGS, (const char *)Dtool_TextGlyph_get_advance_7_comment},
  {"is_whitespace", &Dtool_TextGlyph_is_whitespace_17, METH_NOARGS, (const char *)Dtool_TextGlyph_is_whitespace_17_comment},
  {"isWhitespace", &Dtool_TextGlyph_is_whitespace_17, METH_NOARGS, (const char *)Dtool_TextGlyph_is_whitespace_17_comment},
  {"get_geom", &Dtool_TextGlyph_get_geom_18, METH_O, (const char *)Dtool_TextGlyph_get_geom_18_comment},
  {"getGeom", &Dtool_TextGlyph_get_geom_18, METH_O, (const char *)Dtool_TextGlyph_get_geom_18_comment},
  {"get_class_type", &Dtool_TextGlyph_get_class_type_19, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextGlyph_get_class_type_19_comment},
  {"getClassType", &Dtool_TextGlyph_get_class_type_19, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextGlyph_get_class_type_19_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_TextGlyph[] = {
  {(char *)"character", &Dtool_TextGlyph_character_Getter, NULL, NULL, NULL},
  {(char *)"state", &Dtool_TextGlyph_state_Getter, NULL, NULL, NULL},
  {(char *)"advance", &Dtool_TextGlyph_advance_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_TextGlyph = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TextGlyph = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_TextGlyph = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_TextGlyph = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_TextGlyph = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.TextGlyph",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TextGlyph,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TextGlyph,
    &Dtool_SequenceMethods_TextGlyph,
    &Dtool_MappingMethods_TextGlyph,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_TextGlyph,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A representation of a single glyph (character) from a font.  This is a\n"
    " * piece of renderable geometry of some kind.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TextGlyph,
    0, // tp_members
    Dtool_Properties_TextGlyph,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TextGlyph,
    PyType_GenericAlloc,
    Dtool_new_TextGlyph,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextGlyph,
  Dtool_UpcastInterface_TextGlyph,
  Dtool_DowncastInterface_TextGlyph,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_TextGlyph(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_TextGlyph._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_TextGlyph._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TextGlyph) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextGlyph)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextGlyph);
  }
}

/**
 * Python method tables for TextFont (TextFont)
 */
static PyMethodDef Dtool_Methods_TextFont[] = {
  {"make_copy", &Dtool_TextFont_make_copy_28, METH_NOARGS, (const char *)Dtool_TextFont_make_copy_28_comment},
  {"makeCopy", &Dtool_TextFont_make_copy_28, METH_NOARGS, (const char *)Dtool_TextFont_make_copy_28_comment},
  {"is_valid", &Dtool_TextFont_is_valid_29, METH_NOARGS, (const char *)Dtool_TextFont_is_valid_29_comment},
  {"isValid", &Dtool_TextFont_is_valid_29, METH_NOARGS, (const char *)Dtool_TextFont_is_valid_29_comment},
  {"get_line_height", &Dtool_TextFont_get_line_height_31, METH_NOARGS, (const char *)Dtool_TextFont_get_line_height_31_comment},
  {"getLineHeight", &Dtool_TextFont_get_line_height_31, METH_NOARGS, (const char *)Dtool_TextFont_get_line_height_31_comment},
  {"set_line_height", &Dtool_TextFont_set_line_height_32, METH_O, (const char *)Dtool_TextFont_set_line_height_32_comment},
  {"setLineHeight", &Dtool_TextFont_set_line_height_32, METH_O, (const char *)Dtool_TextFont_set_line_height_32_comment},
  {"get_space_advance", &Dtool_TextFont_get_space_advance_36, METH_NOARGS, (const char *)Dtool_TextFont_get_space_advance_36_comment},
  {"getSpaceAdvance", &Dtool_TextFont_get_space_advance_36, METH_NOARGS, (const char *)Dtool_TextFont_get_space_advance_36_comment},
  {"set_space_advance", &Dtool_TextFont_set_space_advance_37, METH_O, (const char *)Dtool_TextFont_set_space_advance_37_comment},
  {"setSpaceAdvance", &Dtool_TextFont_set_space_advance_37, METH_O, (const char *)Dtool_TextFont_set_space_advance_37_comment},
  {"get_glyph", &Dtool_TextFont_get_glyph_39, METH_O, (const char *)Dtool_TextFont_get_glyph_39_comment},
  {"getGlyph", &Dtool_TextFont_get_glyph_39, METH_O, (const char *)Dtool_TextFont_get_glyph_39_comment},
  {"write", (PyCFunction) &Dtool_TextFont_write_40, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextFont_write_40_comment},
  {"get_class_type", &Dtool_TextFont_get_class_type_41, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextFont_get_class_type_41_comment},
  {"getClassType", &Dtool_TextFont_get_class_type_41, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextFont_get_class_type_41_comment},
  {"upcast_to_TypedReferenceCount", &Dtool_TextFont_upcast_to_TypedReferenceCount_21, METH_NOARGS, (const char *)Dtool_TextFont_upcast_to_TypedReferenceCount_21_comment},
  {"upcastToTypedReferenceCount", &Dtool_TextFont_upcast_to_TypedReferenceCount_21, METH_NOARGS, (const char *)Dtool_TextFont_upcast_to_TypedReferenceCount_21_comment},
  {"upcast_to_Namable", &Dtool_TextFont_upcast_to_Namable_24, METH_NOARGS, (const char *)Dtool_TextFont_upcast_to_Namable_24_comment},
  {"upcastToNamable", &Dtool_TextFont_upcast_to_Namable_24, METH_NOARGS, (const char *)Dtool_TextFont_upcast_to_Namable_24_comment},
  {"downcast_to_DynamicTextFont", &Dtool_TextFont_downcast_to_DynamicTextFont_67, METH_NOARGS, (const char *)Dtool_TextFont_downcast_to_DynamicTextFont_67_comment},
  {"downcastToDynamicTextFont", &Dtool_TextFont_downcast_to_DynamicTextFont_67, METH_NOARGS, (const char *)Dtool_TextFont_downcast_to_DynamicTextFont_67_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TextFont slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_TextFont_operator_typecast_bool_30_nb_bool(PyObject *self) {
  TextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextFont, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
//  A __str__ function
//     TextFont
//////////////////
static PyObject *Dtool_Str_TextFont(PyObject *self) {
  TextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextFont, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_TextFont[] = {
  {(char *)"valid", &Dtool_TextFont_valid_Getter, NULL, NULL, NULL},
  {(char *)"line_height", &Dtool_TextFont_line_height_Getter, &Dtool_TextFont_line_height_Setter, NULL, NULL},
  {(char *)"space_advance", &Dtool_TextFont_space_advance_Getter, &Dtool_TextFont_space_advance_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_TextFont = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  &Dtool_TextFont_operator_typecast_bool_30_nb_bool,
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TextFont = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_TextFont = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_TextFont = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_TextFont = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.TextFont",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TextFont,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TextFont,
    &Dtool_SequenceMethods_TextFont,
    &Dtool_MappingMethods_TextFont,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_TextFont,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_TextFont,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An encapsulation of a font; i.e.  a set of glyphs that may be assembled\n"
    " * together by a TextNode to represent a string of text.\n"
    " *\n"
    " * This is just an abstract interface; see StaticTextFont or DynamicTextFont\n"
    " * for an actual implementation.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TextFont,
    0, // tp_members
    Dtool_Properties_TextFont,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TextFont,
    PyType_GenericAlloc,
    Dtool_new_TextFont,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextFont,
  Dtool_UpcastInterface_TextFont,
  Dtool_DowncastInterface_TextFont,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_TextFont(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    assert(Dtool_Ptr_Namable != NULL);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(NULL);
    Dtool_TextFont._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    PyObject *dict = _PyDict_NewPresized(15);
    Dtool_TextFont._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum TextFont::RenderMode;
    PyDict_SetItemString(dict, "RM_texture", Dtool_WrapValue(TextFont::RM_texture));
    PyDict_SetItemString(dict, "RMTexture", Dtool_WrapValue(TextFont::RM_texture));
    PyDict_SetItemString(dict, "RM_wireframe", Dtool_WrapValue(TextFont::RM_wireframe));
    PyDict_SetItemString(dict, "RMWireframe", Dtool_WrapValue(TextFont::RM_wireframe));
    PyDict_SetItemString(dict, "RM_polygon", Dtool_WrapValue(TextFont::RM_polygon));
    PyDict_SetItemString(dict, "RMPolygon", Dtool_WrapValue(TextFont::RM_polygon));
    PyDict_SetItemString(dict, "RM_extruded", Dtool_WrapValue(TextFont::RM_extruded));
    PyDict_SetItemString(dict, "RMExtruded", Dtool_WrapValue(TextFont::RM_extruded));
    PyDict_SetItemString(dict, "RM_solid", Dtool_WrapValue(TextFont::RM_solid));
    PyDict_SetItemString(dict, "RMSolid", Dtool_WrapValue(TextFont::RM_solid));
    PyDict_SetItemString(dict, "RM_distance_field", Dtool_WrapValue(TextFont::RM_distance_field));
    PyDict_SetItemString(dict, "RMDistanceField", Dtool_WrapValue(TextFont::RM_distance_field));
    PyDict_SetItemString(dict, "RM_invalid", Dtool_WrapValue(TextFont::RM_invalid));
    PyDict_SetItemString(dict, "RMInvalid", Dtool_WrapValue(TextFont::RM_invalid));
    if (PyType_Ready((PyTypeObject *)&Dtool_TextFont) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextFont)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextFont);
  }
}

/**
 * Python method tables for DynamicTextGlyph (DynamicTextGlyph)
 */
static PyMethodDef Dtool_Methods_DynamicTextGlyph[] = {
  {"get_page", &Dtool_DynamicTextGlyph_get_page_43, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_page_43_comment},
  {"getPage", &Dtool_DynamicTextGlyph_get_page_43, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_page_43_comment},
  {"intersects", (PyCFunction) &Dtool_DynamicTextGlyph_intersects_55, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DynamicTextGlyph_intersects_55_comment},
  {"get_left", &Dtool_DynamicTextGlyph_get_left_56, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_left_56_comment},
  {"getLeft", &Dtool_DynamicTextGlyph_get_left_56, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_left_56_comment},
  {"get_bottom", &Dtool_DynamicTextGlyph_get_bottom_57, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_bottom_57_comment},
  {"getBottom", &Dtool_DynamicTextGlyph_get_bottom_57, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_bottom_57_comment},
  {"get_right", &Dtool_DynamicTextGlyph_get_right_58, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_right_58_comment},
  {"getRight", &Dtool_DynamicTextGlyph_get_right_58, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_right_58_comment},
  {"get_top", &Dtool_DynamicTextGlyph_get_top_59, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_top_59_comment},
  {"getTop", &Dtool_DynamicTextGlyph_get_top_59, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_top_59_comment},
  {"get_uv_left", &Dtool_DynamicTextGlyph_get_uv_left_60, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_uv_left_60_comment},
  {"getUvLeft", &Dtool_DynamicTextGlyph_get_uv_left_60, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_uv_left_60_comment},
  {"get_uv_bottom", &Dtool_DynamicTextGlyph_get_uv_bottom_61, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_uv_bottom_61_comment},
  {"getUvBottom", &Dtool_DynamicTextGlyph_get_uv_bottom_61, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_uv_bottom_61_comment},
  {"get_uv_right", &Dtool_DynamicTextGlyph_get_uv_right_62, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_uv_right_62_comment},
  {"getUvRight", &Dtool_DynamicTextGlyph_get_uv_right_62, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_uv_right_62_comment},
  {"get_uv_top", &Dtool_DynamicTextGlyph_get_uv_top_63, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_uv_top_63_comment},
  {"getUvTop", &Dtool_DynamicTextGlyph_get_uv_top_63, METH_NOARGS, (const char *)Dtool_DynamicTextGlyph_get_uv_top_63_comment},
  {"get_class_type", &Dtool_DynamicTextGlyph_get_class_type_64, METH_NOARGS | METH_STATIC, (const char *)Dtool_DynamicTextGlyph_get_class_type_64_comment},
  {"getClassType", &Dtool_DynamicTextGlyph_get_class_type_64, METH_NOARGS | METH_STATIC, (const char *)Dtool_DynamicTextGlyph_get_class_type_64_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_DynamicTextGlyph[] = {
  {(char *)"page", &Dtool_DynamicTextGlyph_page_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_DynamicTextGlyph = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DynamicTextGlyph = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DynamicTextGlyph = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DynamicTextGlyph = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DynamicTextGlyph = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.DynamicTextGlyph",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DynamicTextGlyph,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DynamicTextGlyph,
    &Dtool_SequenceMethods_DynamicTextGlyph,
    &Dtool_MappingMethods_DynamicTextGlyph,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DynamicTextGlyph,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A specialization on TextGlyph that is generated and stored by a\n"
    " * DynamicTextFont.  This keeps some additional information, such as where the\n"
    " * glyph appears on a texture map.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DynamicTextGlyph,
    0, // tp_members
    Dtool_Properties_DynamicTextGlyph,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DynamicTextGlyph,
    PyType_GenericAlloc,
    Dtool_new_DynamicTextGlyph,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DynamicTextGlyph,
  Dtool_UpcastInterface_DynamicTextGlyph,
  Dtool_DowncastInterface_DynamicTextGlyph,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DynamicTextGlyph(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TextGlyph(NULL);
    Dtool_DynamicTextGlyph._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TextGlyph);
    PyObject *dict = PyDict_New();
    Dtool_DynamicTextGlyph._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DynamicTextGlyph) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DynamicTextGlyph)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DynamicTextGlyph);
  }
}

/**
 * Python method tables for DynamicTextPage (DynamicTextPage)
 */
static PyMethodDef Dtool_Methods_DynamicTextPage[] = {
  {"get_size", &Dtool_DynamicTextPage_get_size_48, METH_NOARGS, (const char *)Dtool_DynamicTextPage_get_size_48_comment},
  {"getSize", &Dtool_DynamicTextPage_get_size_48, METH_NOARGS, (const char *)Dtool_DynamicTextPage_get_size_48_comment},
  {"get_x_size", &Dtool_DynamicTextPage_get_x_size_49, METH_NOARGS, (const char *)Dtool_DynamicTextPage_get_x_size_49_comment},
  {"getXSize", &Dtool_DynamicTextPage_get_x_size_49, METH_NOARGS, (const char *)Dtool_DynamicTextPage_get_x_size_49_comment},
  {"get_y_size", &Dtool_DynamicTextPage_get_y_size_50, METH_NOARGS, (const char *)Dtool_DynamicTextPage_get_y_size_50_comment},
  {"getYSize", &Dtool_DynamicTextPage_get_y_size_50, METH_NOARGS, (const char *)Dtool_DynamicTextPage_get_y_size_50_comment},
  {"is_empty", &Dtool_DynamicTextPage_is_empty_51, METH_NOARGS, (const char *)Dtool_DynamicTextPage_is_empty_51_comment},
  {"isEmpty", &Dtool_DynamicTextPage_is_empty_51, METH_NOARGS, (const char *)Dtool_DynamicTextPage_is_empty_51_comment},
  {"get_class_type", &Dtool_DynamicTextPage_get_class_type_52, METH_NOARGS | METH_STATIC, (const char *)Dtool_DynamicTextPage_get_class_type_52_comment},
  {"getClassType", &Dtool_DynamicTextPage_get_class_type_52, METH_NOARGS | METH_STATIC, (const char *)Dtool_DynamicTextPage_get_class_type_52_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DynamicTextPage = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DynamicTextPage = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DynamicTextPage = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DynamicTextPage = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DynamicTextPage = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.DynamicTextPage",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DynamicTextPage,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DynamicTextPage,
    &Dtool_SequenceMethods_DynamicTextPage,
    &Dtool_MappingMethods_DynamicTextPage,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DynamicTextPage,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A single \"page\" of a DynamicTextFont.  This is a single texture that holds\n"
    " * a number of glyphs for rendering.  The font starts out with one page, and\n"
    " * will add more as it needs them.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DynamicTextPage,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DynamicTextPage,
    PyType_GenericAlloc,
    Dtool_new_DynamicTextPage,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DynamicTextPage,
  Dtool_UpcastInterface_DynamicTextPage,
  Dtool_DowncastInterface_DynamicTextPage,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DynamicTextPage(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Texture != NULL);
    assert(Dtool_Ptr_Texture->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Texture->_Dtool_ModuleClassInit(NULL);
    Dtool_DynamicTextPage._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Texture);
    PyObject *dict = PyDict_New();
    Dtool_DynamicTextPage._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DynamicTextPage) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DynamicTextPage)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DynamicTextPage);
  }
}

/**
 * Python method tables for DynamicTextFont (DynamicTextFont)
 */
static PyMethodDef Dtool_Methods_DynamicTextFont[] = {
  {"make_copy", &Dtool_DynamicTextFont_make_copy_73, METH_NOARGS, (const char *)Dtool_DynamicTextFont_make_copy_73_comment},
  {"makeCopy", &Dtool_DynamicTextFont_make_copy_73, METH_NOARGS, (const char *)Dtool_DynamicTextFont_make_copy_73_comment},
  {"get_name", &Dtool_DynamicTextFont_get_name_74, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_name_74_comment},
  {"getName", &Dtool_DynamicTextFont_get_name_74, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_name_74_comment},
  {"set_point_size", &Dtool_DynamicTextFont_set_point_size_75, METH_O, (const char *)Dtool_DynamicTextFont_set_point_size_75_comment},
  {"setPointSize", &Dtool_DynamicTextFont_set_point_size_75, METH_O, (const char *)Dtool_DynamicTextFont_set_point_size_75_comment},
  {"get_point_size", &Dtool_DynamicTextFont_get_point_size_76, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_point_size_76_comment},
  {"getPointSize", &Dtool_DynamicTextFont_get_point_size_76, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_point_size_76_comment},
  {"set_pixels_per_unit", &Dtool_DynamicTextFont_set_pixels_per_unit_78, METH_O, (const char *)Dtool_DynamicTextFont_set_pixels_per_unit_78_comment},
  {"setPixelsPerUnit", &Dtool_DynamicTextFont_set_pixels_per_unit_78, METH_O, (const char *)Dtool_DynamicTextFont_set_pixels_per_unit_78_comment},
  {"get_pixels_per_unit", &Dtool_DynamicTextFont_get_pixels_per_unit_79, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_pixels_per_unit_79_comment},
  {"getPixelsPerUnit", &Dtool_DynamicTextFont_get_pixels_per_unit_79, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_pixels_per_unit_79_comment},
  {"set_scale_factor", &Dtool_DynamicTextFont_set_scale_factor_81, METH_O, (const char *)Dtool_DynamicTextFont_set_scale_factor_81_comment},
  {"setScaleFactor", &Dtool_DynamicTextFont_set_scale_factor_81, METH_O, (const char *)Dtool_DynamicTextFont_set_scale_factor_81_comment},
  {"get_scale_factor", &Dtool_DynamicTextFont_get_scale_factor_82, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_scale_factor_82_comment},
  {"getScaleFactor", &Dtool_DynamicTextFont_get_scale_factor_82, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_scale_factor_82_comment},
  {"set_native_antialias", &Dtool_DynamicTextFont_set_native_antialias_84, METH_O, (const char *)Dtool_DynamicTextFont_set_native_antialias_84_comment},
  {"setNativeAntialias", &Dtool_DynamicTextFont_set_native_antialias_84, METH_O, (const char *)Dtool_DynamicTextFont_set_native_antialias_84_comment},
  {"get_native_antialias", &Dtool_DynamicTextFont_get_native_antialias_85, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_native_antialias_85_comment},
  {"getNativeAntialias", &Dtool_DynamicTextFont_get_native_antialias_85, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_native_antialias_85_comment},
  {"get_font_pixel_size", &Dtool_DynamicTextFont_get_font_pixel_size_87, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_font_pixel_size_87_comment},
  {"getFontPixelSize", &Dtool_DynamicTextFont_get_font_pixel_size_87, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_font_pixel_size_87_comment},
  {"get_line_height", &Dtool_DynamicTextFont_get_line_height_89, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_line_height_89_comment},
  {"getLineHeight", &Dtool_DynamicTextFont_get_line_height_89, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_line_height_89_comment},
  {"get_space_advance", &Dtool_DynamicTextFont_get_space_advance_90, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_space_advance_90_comment},
  {"getSpaceAdvance", &Dtool_DynamicTextFont_get_space_advance_90, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_space_advance_90_comment},
  {"set_texture_margin", &Dtool_DynamicTextFont_set_texture_margin_91, METH_O, (const char *)Dtool_DynamicTextFont_set_texture_margin_91_comment},
  {"setTextureMargin", &Dtool_DynamicTextFont_set_texture_margin_91, METH_O, (const char *)Dtool_DynamicTextFont_set_texture_margin_91_comment},
  {"get_texture_margin", &Dtool_DynamicTextFont_get_texture_margin_92, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_texture_margin_92_comment},
  {"getTextureMargin", &Dtool_DynamicTextFont_get_texture_margin_92, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_texture_margin_92_comment},
  {"set_poly_margin", &Dtool_DynamicTextFont_set_poly_margin_93, METH_O, (const char *)Dtool_DynamicTextFont_set_poly_margin_93_comment},
  {"setPolyMargin", &Dtool_DynamicTextFont_set_poly_margin_93, METH_O, (const char *)Dtool_DynamicTextFont_set_poly_margin_93_comment},
  {"get_poly_margin", &Dtool_DynamicTextFont_get_poly_margin_94, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_poly_margin_94_comment},
  {"getPolyMargin", &Dtool_DynamicTextFont_get_poly_margin_94, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_poly_margin_94_comment},
  {"set_page_size", (PyCFunction) &Dtool_DynamicTextFont_set_page_size_97, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DynamicTextFont_set_page_size_97_comment},
  {"setPageSize", (PyCFunction) &Dtool_DynamicTextFont_set_page_size_97, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DynamicTextFont_set_page_size_97_comment},
  {"get_page_size", &Dtool_DynamicTextFont_get_page_size_98, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_page_size_98_comment},
  {"getPageSize", &Dtool_DynamicTextFont_get_page_size_98, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_page_size_98_comment},
  {"get_page_x_size", &Dtool_DynamicTextFont_get_page_x_size_99, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_page_x_size_99_comment},
  {"getPageXSize", &Dtool_DynamicTextFont_get_page_x_size_99, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_page_x_size_99_comment},
  {"get_page_y_size", &Dtool_DynamicTextFont_get_page_y_size_100, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_page_y_size_100_comment},
  {"getPageYSize", &Dtool_DynamicTextFont_get_page_y_size_100, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_page_y_size_100_comment},
  {"set_minfilter", &Dtool_DynamicTextFont_set_minfilter_104, METH_O, (const char *)Dtool_DynamicTextFont_set_minfilter_104_comment},
  {"setMinfilter", &Dtool_DynamicTextFont_set_minfilter_104, METH_O, (const char *)Dtool_DynamicTextFont_set_minfilter_104_comment},
  {"get_minfilter", &Dtool_DynamicTextFont_get_minfilter_105, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_minfilter_105_comment},
  {"getMinfilter", &Dtool_DynamicTextFont_get_minfilter_105, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_minfilter_105_comment},
  {"set_magfilter", &Dtool_DynamicTextFont_set_magfilter_106, METH_O, (const char *)Dtool_DynamicTextFont_set_magfilter_106_comment},
  {"setMagfilter", &Dtool_DynamicTextFont_set_magfilter_106, METH_O, (const char *)Dtool_DynamicTextFont_set_magfilter_106_comment},
  {"get_magfilter", &Dtool_DynamicTextFont_get_magfilter_107, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_magfilter_107_comment},
  {"getMagfilter", &Dtool_DynamicTextFont_get_magfilter_107, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_magfilter_107_comment},
  {"set_anisotropic_degree", &Dtool_DynamicTextFont_set_anisotropic_degree_108, METH_O, (const char *)Dtool_DynamicTextFont_set_anisotropic_degree_108_comment},
  {"setAnisotropicDegree", &Dtool_DynamicTextFont_set_anisotropic_degree_108, METH_O, (const char *)Dtool_DynamicTextFont_set_anisotropic_degree_108_comment},
  {"get_anisotropic_degree", &Dtool_DynamicTextFont_get_anisotropic_degree_109, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_anisotropic_degree_109_comment},
  {"getAnisotropicDegree", &Dtool_DynamicTextFont_get_anisotropic_degree_109, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_anisotropic_degree_109_comment},
  {"set_render_mode", &Dtool_DynamicTextFont_set_render_mode_115, METH_O, (const char *)Dtool_DynamicTextFont_set_render_mode_115_comment},
  {"setRenderMode", &Dtool_DynamicTextFont_set_render_mode_115, METH_O, (const char *)Dtool_DynamicTextFont_set_render_mode_115_comment},
  {"get_render_mode", &Dtool_DynamicTextFont_get_render_mode_116, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_render_mode_116_comment},
  {"getRenderMode", &Dtool_DynamicTextFont_get_render_mode_116, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_render_mode_116_comment},
  {"set_fg", &Dtool_DynamicTextFont_set_fg_118, METH_O, (const char *)Dtool_DynamicTextFont_set_fg_118_comment},
  {"setFg", &Dtool_DynamicTextFont_set_fg_118, METH_O, (const char *)Dtool_DynamicTextFont_set_fg_118_comment},
  {"get_fg", &Dtool_DynamicTextFont_get_fg_119, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_fg_119_comment},
  {"getFg", &Dtool_DynamicTextFont_get_fg_119, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_fg_119_comment},
  {"set_bg", &Dtool_DynamicTextFont_set_bg_120, METH_O, (const char *)Dtool_DynamicTextFont_set_bg_120_comment},
  {"setBg", &Dtool_DynamicTextFont_set_bg_120, METH_O, (const char *)Dtool_DynamicTextFont_set_bg_120_comment},
  {"get_bg", &Dtool_DynamicTextFont_get_bg_121, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_bg_121_comment},
  {"getBg", &Dtool_DynamicTextFont_get_bg_121, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_bg_121_comment},
  {"set_outline", (PyCFunction) &Dtool_DynamicTextFont_set_outline_122, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DynamicTextFont_set_outline_122_comment},
  {"setOutline", (PyCFunction) &Dtool_DynamicTextFont_set_outline_122, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DynamicTextFont_set_outline_122_comment},
  {"get_outline_color", &Dtool_DynamicTextFont_get_outline_color_123, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_outline_color_123_comment},
  {"getOutlineColor", &Dtool_DynamicTextFont_get_outline_color_123, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_outline_color_123_comment},
  {"get_outline_width", &Dtool_DynamicTextFont_get_outline_width_124, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_outline_width_124_comment},
  {"getOutlineWidth", &Dtool_DynamicTextFont_get_outline_width_124, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_outline_width_124_comment},
  {"get_outline_feather", &Dtool_DynamicTextFont_get_outline_feather_125, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_outline_feather_125_comment},
  {"getOutlineFeather", &Dtool_DynamicTextFont_get_outline_feather_125, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_outline_feather_125_comment},
  {"get_tex_format", &Dtool_DynamicTextFont_get_tex_format_126, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_tex_format_126_comment},
  {"getTexFormat", &Dtool_DynamicTextFont_get_tex_format_126, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_tex_format_126_comment},
  {"get_num_pages", &Dtool_DynamicTextFont_get_num_pages_135, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_num_pages_135_comment},
  {"getNumPages", &Dtool_DynamicTextFont_get_num_pages_135, METH_NOARGS, (const char *)Dtool_DynamicTextFont_get_num_pages_135_comment},
  {"get_page", &Dtool_DynamicTextFont_get_page_136, METH_O, (const char *)Dtool_DynamicTextFont_get_page_136_comment},
  {"getPage", &Dtool_DynamicTextFont_get_page_136, METH_O, (const char *)Dtool_DynamicTextFont_get_page_136_comment},
  {"garbage_collect", &Dtool_DynamicTextFont_garbage_collect_139, METH_NOARGS, (const char *)Dtool_DynamicTextFont_garbage_collect_139_comment},
  {"garbageCollect", &Dtool_DynamicTextFont_garbage_collect_139, METH_NOARGS, (const char *)Dtool_DynamicTextFont_garbage_collect_139_comment},
  {"clear", &Dtool_DynamicTextFont_clear_140, METH_NOARGS, (const char *)Dtool_DynamicTextFont_clear_140_comment},
  {"write", (PyCFunction) &Dtool_DynamicTextFont_write_141, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DynamicTextFont_write_141_comment},
  {"get_class_type", &Dtool_DynamicTextFont_get_class_type_142, METH_NOARGS | METH_STATIC, (const char *)Dtool_DynamicTextFont_get_class_type_142_comment},
  {"getClassType", &Dtool_DynamicTextFont_get_class_type_142, METH_NOARGS | METH_STATIC, (const char *)Dtool_DynamicTextFont_get_class_type_142_comment},
  {"upcast_to_TextFont", &Dtool_DynamicTextFont_upcast_to_TextFont_66, METH_NOARGS, (const char *)Dtool_DynamicTextFont_upcast_to_TextFont_66_comment},
  {"upcastToTextFont", &Dtool_DynamicTextFont_upcast_to_TextFont_66, METH_NOARGS, (const char *)Dtool_DynamicTextFont_upcast_to_TextFont_66_comment},
  {"upcast_to_FreetypeFont", &Dtool_DynamicTextFont_upcast_to_FreetypeFont_69, METH_NOARGS, (const char *)Dtool_DynamicTextFont_upcast_to_FreetypeFont_69_comment},
  {"upcastToFreetypeFont", &Dtool_DynamicTextFont_upcast_to_FreetypeFont_69, METH_NOARGS, (const char *)Dtool_DynamicTextFont_upcast_to_FreetypeFont_69_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_pages", (PyCFunction) &MakeSeq_DynamicTextFont_get_pages, METH_NOARGS, NULL},
  { "getPages", (PyCFunction) &MakeSeq_DynamicTextFont_get_pages, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     DynamicTextFont
//////////////////
static PyObject *Dtool_Str_DynamicTextFont(PyObject *self) {
  DynamicTextFont *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DynamicTextFont, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_DynamicTextFont[] = {
  {(char *)"point_size", &Dtool_DynamicTextFont_point_size_Getter, &Dtool_DynamicTextFont_point_size_Setter, NULL, NULL},
  {(char *)"pixels_per_unit", &Dtool_DynamicTextFont_pixels_per_unit_Getter, &Dtool_DynamicTextFont_pixels_per_unit_Setter, NULL, NULL},
  {(char *)"scale_factor", &Dtool_DynamicTextFont_scale_factor_Getter, &Dtool_DynamicTextFont_scale_factor_Setter, NULL, NULL},
  {(char *)"native_antialias", &Dtool_DynamicTextFont_native_antialias_Getter, &Dtool_DynamicTextFont_native_antialias_Setter, NULL, NULL},
  {(char *)"font_pixel_size", &Dtool_DynamicTextFont_font_pixel_size_Getter, NULL, NULL, NULL},
  {(char *)"texture_margin", &Dtool_DynamicTextFont_texture_margin_Getter, &Dtool_DynamicTextFont_texture_margin_Setter, NULL, NULL},
  {(char *)"poly_margin", &Dtool_DynamicTextFont_poly_margin_Getter, &Dtool_DynamicTextFont_poly_margin_Setter, NULL, NULL},
  {(char *)"page_size", &Dtool_DynamicTextFont_page_size_Getter, &Dtool_DynamicTextFont_page_size_Setter, NULL, NULL},
  {(char *)"minfilter", &Dtool_DynamicTextFont_minfilter_Getter, &Dtool_DynamicTextFont_minfilter_Setter, NULL, NULL},
  {(char *)"magfilter", &Dtool_DynamicTextFont_magfilter_Getter, &Dtool_DynamicTextFont_magfilter_Setter, NULL, NULL},
  {(char *)"anisotropic_degree", &Dtool_DynamicTextFont_anisotropic_degree_Getter, &Dtool_DynamicTextFont_anisotropic_degree_Setter, NULL, NULL},
  {(char *)"render_mode", &Dtool_DynamicTextFont_render_mode_Getter, &Dtool_DynamicTextFont_render_mode_Setter, NULL, NULL},
  {(char *)"fg", &Dtool_DynamicTextFont_fg_Getter, &Dtool_DynamicTextFont_fg_Setter, NULL, NULL},
  {(char *)"bg", &Dtool_DynamicTextFont_bg_Getter, &Dtool_DynamicTextFont_bg_Setter, NULL, NULL},
  {(char *)"tex_format", &Dtool_DynamicTextFont_tex_format_Getter, NULL, NULL, NULL},
  {(char *)"pages", &Dtool_DynamicTextFont_pages_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_DynamicTextFont = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DynamicTextFont = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DynamicTextFont = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DynamicTextFont = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DynamicTextFont = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.DynamicTextFont",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DynamicTextFont,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DynamicTextFont,
    &Dtool_SequenceMethods_DynamicTextFont,
    &Dtool_MappingMethods_DynamicTextFont,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_DynamicTextFont,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DynamicTextFont,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A DynamicTextFont is a special TextFont object that rasterizes its glyphs\n"
    " * from a standard font file (e.g.  a TTF file) on the fly.  It requires the\n"
    " * FreeType 2.0 library (or any higher, backward-compatible version).\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DynamicTextFont,
    0, // tp_members
    Dtool_Properties_DynamicTextFont,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DynamicTextFont,
    PyType_GenericAlloc,
    Dtool_new_DynamicTextFont,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DynamicTextFont,
  Dtool_UpcastInterface_DynamicTextFont,
  Dtool_DowncastInterface_DynamicTextFont,
  (CoerceFunction)Dtool_ConstCoerce_DynamicTextFont,
  (CoerceFunction)Dtool_Coerce_DynamicTextFont,
};

static void Dtool_PyModuleClassInit_DynamicTextFont(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TextFont(NULL);
    assert(Dtool_Ptr_FreetypeFont != NULL);
    assert(Dtool_Ptr_FreetypeFont->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_FreetypeFont->_Dtool_ModuleClassInit(NULL);
    Dtool_DynamicTextFont._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_TextFont, (PyTypeObject *)Dtool_Ptr_FreetypeFont);
    PyObject *dict = PyDict_New();
    Dtool_DynamicTextFont._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DynamicTextFont) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DynamicTextFont)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DynamicTextFont);
  }
}

/**
 * Python method tables for FontPool (FontPool)
 */
static PyMethodDef Dtool_Methods_FontPool[] = {
  {"has_font", &Dtool_FontPool_has_font_144, METH_O | METH_STATIC, (const char *)Dtool_FontPool_has_font_144_comment},
  {"hasFont", &Dtool_FontPool_has_font_144, METH_O | METH_STATIC, (const char *)Dtool_FontPool_has_font_144_comment},
  {"verify_font", &Dtool_FontPool_verify_font_145, METH_O | METH_STATIC, (const char *)Dtool_FontPool_verify_font_145_comment},
  {"verifyFont", &Dtool_FontPool_verify_font_145, METH_O | METH_STATIC, (const char *)Dtool_FontPool_verify_font_145_comment},
  {"load_font", &Dtool_FontPool_load_font_146, METH_O | METH_STATIC, (const char *)Dtool_FontPool_load_font_146_comment},
  {"loadFont", &Dtool_FontPool_load_font_146, METH_O | METH_STATIC, (const char *)Dtool_FontPool_load_font_146_comment},
  {"add_font", (PyCFunction) &Dtool_FontPool_add_font_147, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_FontPool_add_font_147_comment},
  {"addFont", (PyCFunction) &Dtool_FontPool_add_font_147, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_FontPool_add_font_147_comment},
  {"release_font", &Dtool_FontPool_release_font_148, METH_O | METH_STATIC, (const char *)Dtool_FontPool_release_font_148_comment},
  {"releaseFont", &Dtool_FontPool_release_font_148, METH_O | METH_STATIC, (const char *)Dtool_FontPool_release_font_148_comment},
  {"release_all_fonts", &Dtool_FontPool_release_all_fonts_149, METH_NOARGS | METH_STATIC, (const char *)Dtool_FontPool_release_all_fonts_149_comment},
  {"releaseAllFonts", &Dtool_FontPool_release_all_fonts_149, METH_NOARGS | METH_STATIC, (const char *)Dtool_FontPool_release_all_fonts_149_comment},
  {"garbage_collect", &Dtool_FontPool_garbage_collect_150, METH_NOARGS | METH_STATIC, (const char *)Dtool_FontPool_garbage_collect_150_comment},
  {"garbageCollect", &Dtool_FontPool_garbage_collect_150, METH_NOARGS | METH_STATIC, (const char *)Dtool_FontPool_garbage_collect_150_comment},
  {"list_contents", &Dtool_FontPool_list_contents_151, METH_O | METH_STATIC, (const char *)Dtool_FontPool_list_contents_151_comment},
  {"listContents", &Dtool_FontPool_list_contents_151, METH_O | METH_STATIC, (const char *)Dtool_FontPool_list_contents_151_comment},
  {"write", &Dtool_FontPool_write_152, METH_O | METH_STATIC, (const char *)Dtool_FontPool_write_152_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     FontPool
//////////////////
static PyObject *Dtool_Str_FontPool(PyObject *self) {
  FontPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FontPool, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_FontPool = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_FontPool = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.FontPool",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_FontPool,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_FontPool,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_FontPool,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the preferred interface for loading fonts for the TextNode system.\n"
    " * It is similar to ModelPool and TexturePool in that it unifies references to\n"
    " * the same filename.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_FontPool,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_FontPool,
    PyType_GenericAlloc,
    Dtool_new_FontPool,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FontPool,
  Dtool_UpcastInterface_FontPool,
  Dtool_DowncastInterface_FontPool,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_FontPool(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_FontPool._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_FontPool._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_FontPool) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FontPool)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FontPool);
  }
}

/**
 * Python method tables for GeomTextGlyph (GeomTextGlyph)
 */
static PyMethodDef Dtool_Methods_GeomTextGlyph[] = {
  {"get_class_type", &Dtool_GeomTextGlyph_get_class_type_156, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomTextGlyph_get_class_type_156_comment},
  {"getClassType", &Dtool_GeomTextGlyph_get_class_type_156, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeomTextGlyph_get_class_type_156_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_GeomTextGlyph = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomTextGlyph = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_GeomTextGlyph = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_GeomTextGlyph = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_GeomTextGlyph = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.GeomTextGlyph",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomTextGlyph,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_GeomTextGlyph,
    &Dtool_SequenceMethods_GeomTextGlyph,
    &Dtool_MappingMethods_GeomTextGlyph,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_GeomTextGlyph,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a specialization on Geom for containing a primitive intended to\n"
    " * represent a TextGlyph.  Its sole purpose is to maintain the geom count on\n"
    " * the glyph, so we can determine the actual usage count on a dynamic glyph\n"
    " * (and thus know when it is safe to recycle the glyph).\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_GeomTextGlyph,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_GeomTextGlyph,
    PyType_GenericAlloc,
    Dtool_new_GeomTextGlyph,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomTextGlyph,
  Dtool_UpcastInterface_GeomTextGlyph,
  Dtool_DowncastInterface_GeomTextGlyph,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_GeomTextGlyph(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Geom != NULL);
    assert(Dtool_Ptr_Geom->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Geom->_Dtool_ModuleClassInit(NULL);
    Dtool_GeomTextGlyph._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Geom);
    PyObject *dict = PyDict_New();
    Dtool_GeomTextGlyph._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomTextGlyph) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomTextGlyph)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomTextGlyph);
  }
}

/**
 * Python method tables for StaticTextFont (StaticTextFont)
 */
static PyMethodDef Dtool_Methods_StaticTextFont[] = {
  {"get_class_type", &Dtool_StaticTextFont_get_class_type_159, METH_NOARGS | METH_STATIC, (const char *)Dtool_StaticTextFont_get_class_type_159_comment},
  {"getClassType", &Dtool_StaticTextFont_get_class_type_159, METH_NOARGS | METH_STATIC, (const char *)Dtool_StaticTextFont_get_class_type_159_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_StaticTextFont = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_StaticTextFont = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_StaticTextFont = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_StaticTextFont = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_StaticTextFont = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.StaticTextFont",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_StaticTextFont,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_StaticTextFont,
    &Dtool_SequenceMethods_StaticTextFont,
    &Dtool_MappingMethods_StaticTextFont,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_StaticTextFont,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A StaticTextFont is loaded up from a model that was previously generated\n"
    " * via egg-mkfont, and contains all of its glyphs already generated and\n"
    " * available for use.  It doesn't require linking with any external libraries\n"
    " * like FreeType.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_StaticTextFont,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_StaticTextFont,
    PyType_GenericAlloc,
    Dtool_new_StaticTextFont,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_StaticTextFont,
  Dtool_UpcastInterface_StaticTextFont,
  Dtool_DowncastInterface_StaticTextFont,
  (CoerceFunction)Dtool_ConstCoerce_StaticTextFont,
  (CoerceFunction)Dtool_Coerce_StaticTextFont,
};

static void Dtool_PyModuleClassInit_StaticTextFont(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TextFont(NULL);
    Dtool_StaticTextFont._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TextFont);
    PyObject *dict = PyDict_New();
    Dtool_StaticTextFont._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_StaticTextFont) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(StaticTextFont)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_StaticTextFont);
  }
}

/**
 * Python method tables for TextProperties (TextProperties)
 */
static PyMethodDef Dtool_Methods_TextProperties[] = {
  {"assign", &Dtool_TextProperties_operator_164, METH_O, (const char *)Dtool_TextProperties_operator_164_comment},
  {"clear", &Dtool_TextProperties_clear_167, METH_NOARGS, (const char *)Dtool_TextProperties_clear_167_comment},
  {"is_any_specified", &Dtool_TextProperties_is_any_specified_168, METH_NOARGS, (const char *)Dtool_TextProperties_is_any_specified_168_comment},
  {"isAnySpecified", &Dtool_TextProperties_is_any_specified_168, METH_NOARGS, (const char *)Dtool_TextProperties_is_any_specified_168_comment},
  {"set_default_font", &Dtool_TextProperties_set_default_font_169, METH_O | METH_STATIC, (const char *)Dtool_TextProperties_set_default_font_169_comment},
  {"setDefaultFont", &Dtool_TextProperties_set_default_font_169, METH_O | METH_STATIC, (const char *)Dtool_TextProperties_set_default_font_169_comment},
  {"get_default_font", &Dtool_TextProperties_get_default_font_170, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextProperties_get_default_font_170_comment},
  {"getDefaultFont", &Dtool_TextProperties_get_default_font_170, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextProperties_get_default_font_170_comment},
  {"set_font", &Dtool_TextProperties_set_font_171, METH_O, (const char *)Dtool_TextProperties_set_font_171_comment},
  {"setFont", &Dtool_TextProperties_set_font_171, METH_O, (const char *)Dtool_TextProperties_set_font_171_comment},
  {"clear_font", &Dtool_TextProperties_clear_font_172, METH_NOARGS, (const char *)Dtool_TextProperties_clear_font_172_comment},
  {"clearFont", &Dtool_TextProperties_clear_font_172, METH_NOARGS, (const char *)Dtool_TextProperties_clear_font_172_comment},
  {"has_font", &Dtool_TextProperties_has_font_173, METH_NOARGS, (const char *)Dtool_TextProperties_has_font_173_comment},
  {"hasFont", &Dtool_TextProperties_has_font_173, METH_NOARGS, (const char *)Dtool_TextProperties_has_font_173_comment},
  {"get_font", &Dtool_TextProperties_get_font_174, METH_NOARGS, (const char *)Dtool_TextProperties_get_font_174_comment},
  {"getFont", &Dtool_TextProperties_get_font_174, METH_NOARGS, (const char *)Dtool_TextProperties_get_font_174_comment},
  {"set_small_caps", &Dtool_TextProperties_set_small_caps_175, METH_O, (const char *)Dtool_TextProperties_set_small_caps_175_comment},
  {"setSmallCaps", &Dtool_TextProperties_set_small_caps_175, METH_O, (const char *)Dtool_TextProperties_set_small_caps_175_comment},
  {"clear_small_caps", &Dtool_TextProperties_clear_small_caps_176, METH_NOARGS, (const char *)Dtool_TextProperties_clear_small_caps_176_comment},
  {"clearSmallCaps", &Dtool_TextProperties_clear_small_caps_176, METH_NOARGS, (const char *)Dtool_TextProperties_clear_small_caps_176_comment},
  {"has_small_caps", &Dtool_TextProperties_has_small_caps_177, METH_NOARGS, (const char *)Dtool_TextProperties_has_small_caps_177_comment},
  {"hasSmallCaps", &Dtool_TextProperties_has_small_caps_177, METH_NOARGS, (const char *)Dtool_TextProperties_has_small_caps_177_comment},
  {"get_small_caps", &Dtool_TextProperties_get_small_caps_178, METH_NOARGS, (const char *)Dtool_TextProperties_get_small_caps_178_comment},
  {"getSmallCaps", &Dtool_TextProperties_get_small_caps_178, METH_NOARGS, (const char *)Dtool_TextProperties_get_small_caps_178_comment},
  {"set_small_caps_scale", &Dtool_TextProperties_set_small_caps_scale_179, METH_O, (const char *)Dtool_TextProperties_set_small_caps_scale_179_comment},
  {"setSmallCapsScale", &Dtool_TextProperties_set_small_caps_scale_179, METH_O, (const char *)Dtool_TextProperties_set_small_caps_scale_179_comment},
  {"clear_small_caps_scale", &Dtool_TextProperties_clear_small_caps_scale_180, METH_NOARGS, (const char *)Dtool_TextProperties_clear_small_caps_scale_180_comment},
  {"clearSmallCapsScale", &Dtool_TextProperties_clear_small_caps_scale_180, METH_NOARGS, (const char *)Dtool_TextProperties_clear_small_caps_scale_180_comment},
  {"has_small_caps_scale", &Dtool_TextProperties_has_small_caps_scale_181, METH_NOARGS, (const char *)Dtool_TextProperties_has_small_caps_scale_181_comment},
  {"hasSmallCapsScale", &Dtool_TextProperties_has_small_caps_scale_181, METH_NOARGS, (const char *)Dtool_TextProperties_has_small_caps_scale_181_comment},
  {"get_small_caps_scale", &Dtool_TextProperties_get_small_caps_scale_182, METH_NOARGS, (const char *)Dtool_TextProperties_get_small_caps_scale_182_comment},
  {"getSmallCapsScale", &Dtool_TextProperties_get_small_caps_scale_182, METH_NOARGS, (const char *)Dtool_TextProperties_get_small_caps_scale_182_comment},
  {"set_slant", &Dtool_TextProperties_set_slant_183, METH_O, (const char *)Dtool_TextProperties_set_slant_183_comment},
  {"setSlant", &Dtool_TextProperties_set_slant_183, METH_O, (const char *)Dtool_TextProperties_set_slant_183_comment},
  {"clear_slant", &Dtool_TextProperties_clear_slant_184, METH_NOARGS, (const char *)Dtool_TextProperties_clear_slant_184_comment},
  {"clearSlant", &Dtool_TextProperties_clear_slant_184, METH_NOARGS, (const char *)Dtool_TextProperties_clear_slant_184_comment},
  {"has_slant", &Dtool_TextProperties_has_slant_185, METH_NOARGS, (const char *)Dtool_TextProperties_has_slant_185_comment},
  {"hasSlant", &Dtool_TextProperties_has_slant_185, METH_NOARGS, (const char *)Dtool_TextProperties_has_slant_185_comment},
  {"get_slant", &Dtool_TextProperties_get_slant_186, METH_NOARGS, (const char *)Dtool_TextProperties_get_slant_186_comment},
  {"getSlant", &Dtool_TextProperties_get_slant_186, METH_NOARGS, (const char *)Dtool_TextProperties_get_slant_186_comment},
  {"set_underscore", &Dtool_TextProperties_set_underscore_187, METH_O, (const char *)Dtool_TextProperties_set_underscore_187_comment},
  {"setUnderscore", &Dtool_TextProperties_set_underscore_187, METH_O, (const char *)Dtool_TextProperties_set_underscore_187_comment},
  {"clear_underscore", &Dtool_TextProperties_clear_underscore_188, METH_NOARGS, (const char *)Dtool_TextProperties_clear_underscore_188_comment},
  {"clearUnderscore", &Dtool_TextProperties_clear_underscore_188, METH_NOARGS, (const char *)Dtool_TextProperties_clear_underscore_188_comment},
  {"has_underscore", &Dtool_TextProperties_has_underscore_189, METH_NOARGS, (const char *)Dtool_TextProperties_has_underscore_189_comment},
  {"hasUnderscore", &Dtool_TextProperties_has_underscore_189, METH_NOARGS, (const char *)Dtool_TextProperties_has_underscore_189_comment},
  {"get_underscore", &Dtool_TextProperties_get_underscore_190, METH_NOARGS, (const char *)Dtool_TextProperties_get_underscore_190_comment},
  {"getUnderscore", &Dtool_TextProperties_get_underscore_190, METH_NOARGS, (const char *)Dtool_TextProperties_get_underscore_190_comment},
  {"set_underscore_height", &Dtool_TextProperties_set_underscore_height_191, METH_O, (const char *)Dtool_TextProperties_set_underscore_height_191_comment},
  {"setUnderscoreHeight", &Dtool_TextProperties_set_underscore_height_191, METH_O, (const char *)Dtool_TextProperties_set_underscore_height_191_comment},
  {"clear_underscore_height", &Dtool_TextProperties_clear_underscore_height_192, METH_NOARGS, (const char *)Dtool_TextProperties_clear_underscore_height_192_comment},
  {"clearUnderscoreHeight", &Dtool_TextProperties_clear_underscore_height_192, METH_NOARGS, (const char *)Dtool_TextProperties_clear_underscore_height_192_comment},
  {"has_underscore_height", &Dtool_TextProperties_has_underscore_height_193, METH_NOARGS, (const char *)Dtool_TextProperties_has_underscore_height_193_comment},
  {"hasUnderscoreHeight", &Dtool_TextProperties_has_underscore_height_193, METH_NOARGS, (const char *)Dtool_TextProperties_has_underscore_height_193_comment},
  {"get_underscore_height", &Dtool_TextProperties_get_underscore_height_194, METH_NOARGS, (const char *)Dtool_TextProperties_get_underscore_height_194_comment},
  {"getUnderscoreHeight", &Dtool_TextProperties_get_underscore_height_194, METH_NOARGS, (const char *)Dtool_TextProperties_get_underscore_height_194_comment},
  {"set_align", &Dtool_TextProperties_set_align_195, METH_O, (const char *)Dtool_TextProperties_set_align_195_comment},
  {"setAlign", &Dtool_TextProperties_set_align_195, METH_O, (const char *)Dtool_TextProperties_set_align_195_comment},
  {"clear_align", &Dtool_TextProperties_clear_align_196, METH_NOARGS, (const char *)Dtool_TextProperties_clear_align_196_comment},
  {"clearAlign", &Dtool_TextProperties_clear_align_196, METH_NOARGS, (const char *)Dtool_TextProperties_clear_align_196_comment},
  {"has_align", &Dtool_TextProperties_has_align_197, METH_NOARGS, (const char *)Dtool_TextProperties_has_align_197_comment},
  {"hasAlign", &Dtool_TextProperties_has_align_197, METH_NOARGS, (const char *)Dtool_TextProperties_has_align_197_comment},
  {"get_align", &Dtool_TextProperties_get_align_198, METH_NOARGS, (const char *)Dtool_TextProperties_get_align_198_comment},
  {"getAlign", &Dtool_TextProperties_get_align_198, METH_NOARGS, (const char *)Dtool_TextProperties_get_align_198_comment},
  {"set_indent", &Dtool_TextProperties_set_indent_199, METH_O, (const char *)Dtool_TextProperties_set_indent_199_comment},
  {"setIndent", &Dtool_TextProperties_set_indent_199, METH_O, (const char *)Dtool_TextProperties_set_indent_199_comment},
  {"clear_indent", &Dtool_TextProperties_clear_indent_200, METH_NOARGS, (const char *)Dtool_TextProperties_clear_indent_200_comment},
  {"clearIndent", &Dtool_TextProperties_clear_indent_200, METH_NOARGS, (const char *)Dtool_TextProperties_clear_indent_200_comment},
  {"has_indent", &Dtool_TextProperties_has_indent_201, METH_NOARGS, (const char *)Dtool_TextProperties_has_indent_201_comment},
  {"hasIndent", &Dtool_TextProperties_has_indent_201, METH_NOARGS, (const char *)Dtool_TextProperties_has_indent_201_comment},
  {"get_indent", &Dtool_TextProperties_get_indent_202, METH_NOARGS, (const char *)Dtool_TextProperties_get_indent_202_comment},
  {"getIndent", &Dtool_TextProperties_get_indent_202, METH_NOARGS, (const char *)Dtool_TextProperties_get_indent_202_comment},
  {"set_wordwrap", &Dtool_TextProperties_set_wordwrap_203, METH_O, (const char *)Dtool_TextProperties_set_wordwrap_203_comment},
  {"setWordwrap", &Dtool_TextProperties_set_wordwrap_203, METH_O, (const char *)Dtool_TextProperties_set_wordwrap_203_comment},
  {"clear_wordwrap", &Dtool_TextProperties_clear_wordwrap_204, METH_NOARGS, (const char *)Dtool_TextProperties_clear_wordwrap_204_comment},
  {"clearWordwrap", &Dtool_TextProperties_clear_wordwrap_204, METH_NOARGS, (const char *)Dtool_TextProperties_clear_wordwrap_204_comment},
  {"has_wordwrap", &Dtool_TextProperties_has_wordwrap_205, METH_NOARGS, (const char *)Dtool_TextProperties_has_wordwrap_205_comment},
  {"hasWordwrap", &Dtool_TextProperties_has_wordwrap_205, METH_NOARGS, (const char *)Dtool_TextProperties_has_wordwrap_205_comment},
  {"get_wordwrap", &Dtool_TextProperties_get_wordwrap_206, METH_NOARGS, (const char *)Dtool_TextProperties_get_wordwrap_206_comment},
  {"getWordwrap", &Dtool_TextProperties_get_wordwrap_206, METH_NOARGS, (const char *)Dtool_TextProperties_get_wordwrap_206_comment},
  {"set_preserve_trailing_whitespace", &Dtool_TextProperties_set_preserve_trailing_whitespace_207, METH_O, (const char *)Dtool_TextProperties_set_preserve_trailing_whitespace_207_comment},
  {"setPreserveTrailingWhitespace", &Dtool_TextProperties_set_preserve_trailing_whitespace_207, METH_O, (const char *)Dtool_TextProperties_set_preserve_trailing_whitespace_207_comment},
  {"clear_preserve_trailing_whitespace", &Dtool_TextProperties_clear_preserve_trailing_whitespace_208, METH_NOARGS, (const char *)Dtool_TextProperties_clear_preserve_trailing_whitespace_208_comment},
  {"clearPreserveTrailingWhitespace", &Dtool_TextProperties_clear_preserve_trailing_whitespace_208, METH_NOARGS, (const char *)Dtool_TextProperties_clear_preserve_trailing_whitespace_208_comment},
  {"has_preserve_trailing_whitespace", &Dtool_TextProperties_has_preserve_trailing_whitespace_209, METH_NOARGS, (const char *)Dtool_TextProperties_has_preserve_trailing_whitespace_209_comment},
  {"hasPreserveTrailingWhitespace", &Dtool_TextProperties_has_preserve_trailing_whitespace_209, METH_NOARGS, (const char *)Dtool_TextProperties_has_preserve_trailing_whitespace_209_comment},
  {"get_preserve_trailing_whitespace", &Dtool_TextProperties_get_preserve_trailing_whitespace_210, METH_NOARGS, (const char *)Dtool_TextProperties_get_preserve_trailing_whitespace_210_comment},
  {"getPreserveTrailingWhitespace", &Dtool_TextProperties_get_preserve_trailing_whitespace_210, METH_NOARGS, (const char *)Dtool_TextProperties_get_preserve_trailing_whitespace_210_comment},
  {"set_text_color", (PyCFunction) &Dtool_TextProperties_set_text_color_211, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextProperties_set_text_color_211_comment},
  {"setTextColor", (PyCFunction) &Dtool_TextProperties_set_text_color_211, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextProperties_set_text_color_211_comment},
  {"clear_text_color", &Dtool_TextProperties_clear_text_color_212, METH_NOARGS, (const char *)Dtool_TextProperties_clear_text_color_212_comment},
  {"clearTextColor", &Dtool_TextProperties_clear_text_color_212, METH_NOARGS, (const char *)Dtool_TextProperties_clear_text_color_212_comment},
  {"has_text_color", &Dtool_TextProperties_has_text_color_213, METH_NOARGS, (const char *)Dtool_TextProperties_has_text_color_213_comment},
  {"hasTextColor", &Dtool_TextProperties_has_text_color_213, METH_NOARGS, (const char *)Dtool_TextProperties_has_text_color_213_comment},
  {"get_text_color", &Dtool_TextProperties_get_text_color_214, METH_NOARGS, (const char *)Dtool_TextProperties_get_text_color_214_comment},
  {"getTextColor", &Dtool_TextProperties_get_text_color_214, METH_NOARGS, (const char *)Dtool_TextProperties_get_text_color_214_comment},
  {"set_shadow_color", (PyCFunction) &Dtool_TextProperties_set_shadow_color_215, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextProperties_set_shadow_color_215_comment},
  {"setShadowColor", (PyCFunction) &Dtool_TextProperties_set_shadow_color_215, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextProperties_set_shadow_color_215_comment},
  {"clear_shadow_color", &Dtool_TextProperties_clear_shadow_color_216, METH_NOARGS, (const char *)Dtool_TextProperties_clear_shadow_color_216_comment},
  {"clearShadowColor", &Dtool_TextProperties_clear_shadow_color_216, METH_NOARGS, (const char *)Dtool_TextProperties_clear_shadow_color_216_comment},
  {"has_shadow_color", &Dtool_TextProperties_has_shadow_color_217, METH_NOARGS, (const char *)Dtool_TextProperties_has_shadow_color_217_comment},
  {"hasShadowColor", &Dtool_TextProperties_has_shadow_color_217, METH_NOARGS, (const char *)Dtool_TextProperties_has_shadow_color_217_comment},
  {"get_shadow_color", &Dtool_TextProperties_get_shadow_color_218, METH_NOARGS, (const char *)Dtool_TextProperties_get_shadow_color_218_comment},
  {"getShadowColor", &Dtool_TextProperties_get_shadow_color_218, METH_NOARGS, (const char *)Dtool_TextProperties_get_shadow_color_218_comment},
  {"set_shadow", (PyCFunction) &Dtool_TextProperties_set_shadow_219, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextProperties_set_shadow_219_comment},
  {"setShadow", (PyCFunction) &Dtool_TextProperties_set_shadow_219, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextProperties_set_shadow_219_comment},
  {"clear_shadow", &Dtool_TextProperties_clear_shadow_220, METH_NOARGS, (const char *)Dtool_TextProperties_clear_shadow_220_comment},
  {"clearShadow", &Dtool_TextProperties_clear_shadow_220, METH_NOARGS, (const char *)Dtool_TextProperties_clear_shadow_220_comment},
  {"has_shadow", &Dtool_TextProperties_has_shadow_221, METH_NOARGS, (const char *)Dtool_TextProperties_has_shadow_221_comment},
  {"hasShadow", &Dtool_TextProperties_has_shadow_221, METH_NOARGS, (const char *)Dtool_TextProperties_has_shadow_221_comment},
  {"get_shadow", &Dtool_TextProperties_get_shadow_222, METH_NOARGS, (const char *)Dtool_TextProperties_get_shadow_222_comment},
  {"getShadow", &Dtool_TextProperties_get_shadow_222, METH_NOARGS, (const char *)Dtool_TextProperties_get_shadow_222_comment},
  {"set_bin", &Dtool_TextProperties_set_bin_223, METH_O, (const char *)Dtool_TextProperties_set_bin_223_comment},
  {"setBin", &Dtool_TextProperties_set_bin_223, METH_O, (const char *)Dtool_TextProperties_set_bin_223_comment},
  {"clear_bin", &Dtool_TextProperties_clear_bin_224, METH_NOARGS, (const char *)Dtool_TextProperties_clear_bin_224_comment},
  {"clearBin", &Dtool_TextProperties_clear_bin_224, METH_NOARGS, (const char *)Dtool_TextProperties_clear_bin_224_comment},
  {"has_bin", &Dtool_TextProperties_has_bin_225, METH_NOARGS, (const char *)Dtool_TextProperties_has_bin_225_comment},
  {"hasBin", &Dtool_TextProperties_has_bin_225, METH_NOARGS, (const char *)Dtool_TextProperties_has_bin_225_comment},
  {"get_bin", &Dtool_TextProperties_get_bin_226, METH_NOARGS, (const char *)Dtool_TextProperties_get_bin_226_comment},
  {"getBin", &Dtool_TextProperties_get_bin_226, METH_NOARGS, (const char *)Dtool_TextProperties_get_bin_226_comment},
  {"set_draw_order", &Dtool_TextProperties_set_draw_order_227, METH_O, (const char *)Dtool_TextProperties_set_draw_order_227_comment},
  {"setDrawOrder", &Dtool_TextProperties_set_draw_order_227, METH_O, (const char *)Dtool_TextProperties_set_draw_order_227_comment},
  {"clear_draw_order", &Dtool_TextProperties_clear_draw_order_228, METH_NOARGS, (const char *)Dtool_TextProperties_clear_draw_order_228_comment},
  {"clearDrawOrder", &Dtool_TextProperties_clear_draw_order_228, METH_NOARGS, (const char *)Dtool_TextProperties_clear_draw_order_228_comment},
  {"has_draw_order", &Dtool_TextProperties_has_draw_order_229, METH_NOARGS, (const char *)Dtool_TextProperties_has_draw_order_229_comment},
  {"hasDrawOrder", &Dtool_TextProperties_has_draw_order_229, METH_NOARGS, (const char *)Dtool_TextProperties_has_draw_order_229_comment},
  {"get_draw_order", &Dtool_TextProperties_get_draw_order_230, METH_NOARGS, (const char *)Dtool_TextProperties_get_draw_order_230_comment},
  {"getDrawOrder", &Dtool_TextProperties_get_draw_order_230, METH_NOARGS, (const char *)Dtool_TextProperties_get_draw_order_230_comment},
  {"set_tab_width", &Dtool_TextProperties_set_tab_width_231, METH_O, (const char *)Dtool_TextProperties_set_tab_width_231_comment},
  {"setTabWidth", &Dtool_TextProperties_set_tab_width_231, METH_O, (const char *)Dtool_TextProperties_set_tab_width_231_comment},
  {"clear_tab_width", &Dtool_TextProperties_clear_tab_width_232, METH_NOARGS, (const char *)Dtool_TextProperties_clear_tab_width_232_comment},
  {"clearTabWidth", &Dtool_TextProperties_clear_tab_width_232, METH_NOARGS, (const char *)Dtool_TextProperties_clear_tab_width_232_comment},
  {"has_tab_width", &Dtool_TextProperties_has_tab_width_233, METH_NOARGS, (const char *)Dtool_TextProperties_has_tab_width_233_comment},
  {"hasTabWidth", &Dtool_TextProperties_has_tab_width_233, METH_NOARGS, (const char *)Dtool_TextProperties_has_tab_width_233_comment},
  {"get_tab_width", &Dtool_TextProperties_get_tab_width_234, METH_NOARGS, (const char *)Dtool_TextProperties_get_tab_width_234_comment},
  {"getTabWidth", &Dtool_TextProperties_get_tab_width_234, METH_NOARGS, (const char *)Dtool_TextProperties_get_tab_width_234_comment},
  {"set_glyph_scale", &Dtool_TextProperties_set_glyph_scale_235, METH_O, (const char *)Dtool_TextProperties_set_glyph_scale_235_comment},
  {"setGlyphScale", &Dtool_TextProperties_set_glyph_scale_235, METH_O, (const char *)Dtool_TextProperties_set_glyph_scale_235_comment},
  {"clear_glyph_scale", &Dtool_TextProperties_clear_glyph_scale_236, METH_NOARGS, (const char *)Dtool_TextProperties_clear_glyph_scale_236_comment},
  {"clearGlyphScale", &Dtool_TextProperties_clear_glyph_scale_236, METH_NOARGS, (const char *)Dtool_TextProperties_clear_glyph_scale_236_comment},
  {"has_glyph_scale", &Dtool_TextProperties_has_glyph_scale_237, METH_NOARGS, (const char *)Dtool_TextProperties_has_glyph_scale_237_comment},
  {"hasGlyphScale", &Dtool_TextProperties_has_glyph_scale_237, METH_NOARGS, (const char *)Dtool_TextProperties_has_glyph_scale_237_comment},
  {"get_glyph_scale", &Dtool_TextProperties_get_glyph_scale_238, METH_NOARGS, (const char *)Dtool_TextProperties_get_glyph_scale_238_comment},
  {"getGlyphScale", &Dtool_TextProperties_get_glyph_scale_238, METH_NOARGS, (const char *)Dtool_TextProperties_get_glyph_scale_238_comment},
  {"set_glyph_shift", &Dtool_TextProperties_set_glyph_shift_239, METH_O, (const char *)Dtool_TextProperties_set_glyph_shift_239_comment},
  {"setGlyphShift", &Dtool_TextProperties_set_glyph_shift_239, METH_O, (const char *)Dtool_TextProperties_set_glyph_shift_239_comment},
  {"clear_glyph_shift", &Dtool_TextProperties_clear_glyph_shift_240, METH_NOARGS, (const char *)Dtool_TextProperties_clear_glyph_shift_240_comment},
  {"clearGlyphShift", &Dtool_TextProperties_clear_glyph_shift_240, METH_NOARGS, (const char *)Dtool_TextProperties_clear_glyph_shift_240_comment},
  {"has_glyph_shift", &Dtool_TextProperties_has_glyph_shift_241, METH_NOARGS, (const char *)Dtool_TextProperties_has_glyph_shift_241_comment},
  {"hasGlyphShift", &Dtool_TextProperties_has_glyph_shift_241, METH_NOARGS, (const char *)Dtool_TextProperties_has_glyph_shift_241_comment},
  {"get_glyph_shift", &Dtool_TextProperties_get_glyph_shift_242, METH_NOARGS, (const char *)Dtool_TextProperties_get_glyph_shift_242_comment},
  {"getGlyphShift", &Dtool_TextProperties_get_glyph_shift_242, METH_NOARGS, (const char *)Dtool_TextProperties_get_glyph_shift_242_comment},
  {"set_text_scale", &Dtool_TextProperties_set_text_scale_243, METH_O, (const char *)Dtool_TextProperties_set_text_scale_243_comment},
  {"setTextScale", &Dtool_TextProperties_set_text_scale_243, METH_O, (const char *)Dtool_TextProperties_set_text_scale_243_comment},
  {"clear_text_scale", &Dtool_TextProperties_clear_text_scale_244, METH_NOARGS, (const char *)Dtool_TextProperties_clear_text_scale_244_comment},
  {"clearTextScale", &Dtool_TextProperties_clear_text_scale_244, METH_NOARGS, (const char *)Dtool_TextProperties_clear_text_scale_244_comment},
  {"has_text_scale", &Dtool_TextProperties_has_text_scale_245, METH_NOARGS, (const char *)Dtool_TextProperties_has_text_scale_245_comment},
  {"hasTextScale", &Dtool_TextProperties_has_text_scale_245, METH_NOARGS, (const char *)Dtool_TextProperties_has_text_scale_245_comment},
  {"get_text_scale", &Dtool_TextProperties_get_text_scale_246, METH_NOARGS, (const char *)Dtool_TextProperties_get_text_scale_246_comment},
  {"getTextScale", &Dtool_TextProperties_get_text_scale_246, METH_NOARGS, (const char *)Dtool_TextProperties_get_text_scale_246_comment},
  {"add_properties", &Dtool_TextProperties_add_properties_247, METH_O, (const char *)Dtool_TextProperties_add_properties_247_comment},
  {"addProperties", &Dtool_TextProperties_add_properties_247, METH_O, (const char *)Dtool_TextProperties_add_properties_247_comment},
  {"write", (PyCFunction) &Dtool_TextProperties_write_248, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextProperties_write_248_comment},
  {"get_class_type", &Dtool_TextProperties_get_class_type_274, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextProperties_get_class_type_274_comment},
  {"getClassType", &Dtool_TextProperties_get_class_type_274, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextProperties_get_class_type_274_comment},
  {"downcast_to_TextNode", &Dtool_TextProperties_downcast_to_TextNode_357, METH_NOARGS, (const char *)Dtool_TextProperties_downcast_to_TextNode_357_comment},
  {"downcastToTextNode", &Dtool_TextProperties_downcast_to_TextNode_357, METH_NOARGS, (const char *)Dtool_TextProperties_downcast_to_TextNode_357_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     TextProperties
//////////////////
static PyObject *Dtool_Str_TextProperties(PyObject *self) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     TextProperties
//////////////////
static PyObject *Dtool_RichCompare_TextProperties(PyObject *self, PyObject *arg, int op) {
  TextProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextProperties, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-bool TextProperties::operator ==(TextProperties const &other) const
      TextProperties const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TextProperties, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const TextProperties*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool TextProperties::operator !=(TextProperties const &other) const
      TextProperties const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TextProperties, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const TextProperties*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_TextProperties[] = {
  {(char *)"font", &Dtool_TextProperties_font_Getter, &Dtool_TextProperties_font_Setter, NULL, NULL},
  {(char *)"small_caps", &Dtool_TextProperties_small_caps_Getter, &Dtool_TextProperties_small_caps_Setter, NULL, NULL},
  {(char *)"small_caps_scale", &Dtool_TextProperties_small_caps_scale_Getter, &Dtool_TextProperties_small_caps_scale_Setter, NULL, NULL},
  {(char *)"slant", &Dtool_TextProperties_slant_Getter, &Dtool_TextProperties_slant_Setter, NULL, NULL},
  {(char *)"underscore", &Dtool_TextProperties_underscore_Getter, &Dtool_TextProperties_underscore_Setter, NULL, NULL},
  {(char *)"underscore_height", &Dtool_TextProperties_underscore_height_Getter, &Dtool_TextProperties_underscore_height_Setter, NULL, NULL},
  {(char *)"align", &Dtool_TextProperties_align_Getter, &Dtool_TextProperties_align_Setter, NULL, NULL},
  {(char *)"indent", &Dtool_TextProperties_indent_Getter, &Dtool_TextProperties_indent_Setter, NULL, NULL},
  {(char *)"wordwrap", &Dtool_TextProperties_wordwrap_Getter, &Dtool_TextProperties_wordwrap_Setter, NULL, NULL},
  {(char *)"preserve_trailing_whitespace", &Dtool_TextProperties_preserve_trailing_whitespace_Getter, &Dtool_TextProperties_preserve_trailing_whitespace_Setter, NULL, NULL},
  {(char *)"text_color", &Dtool_TextProperties_text_color_Getter, &Dtool_TextProperties_text_color_Setter, NULL, NULL},
  {(char *)"shadow_color", &Dtool_TextProperties_shadow_color_Getter, &Dtool_TextProperties_shadow_color_Setter, NULL, NULL},
  {(char *)"shadow", &Dtool_TextProperties_shadow_Getter, &Dtool_TextProperties_shadow_Setter, NULL, NULL},
  {(char *)"bin", &Dtool_TextProperties_bin_Getter, &Dtool_TextProperties_bin_Setter, NULL, NULL},
  {(char *)"draw_order", &Dtool_TextProperties_draw_order_Getter, &Dtool_TextProperties_draw_order_Setter, NULL, NULL},
  {(char *)"tab_width", &Dtool_TextProperties_tab_width_Getter, &Dtool_TextProperties_tab_width_Setter, NULL, NULL},
  {(char *)"glyph_scale", &Dtool_TextProperties_glyph_scale_Getter, &Dtool_TextProperties_glyph_scale_Setter, NULL, NULL},
  {(char *)"glyph_shift", &Dtool_TextProperties_glyph_shift_Getter, &Dtool_TextProperties_glyph_shift_Setter, NULL, NULL},
  {(char *)"text_scale", &Dtool_TextProperties_text_scale_Getter, &Dtool_TextProperties_text_scale_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_TextProperties = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_TextProperties = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.TextProperties",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TextProperties,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &DTOOL_PyObject_ComparePointers,
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TextProperties,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Str_TextProperties,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This defines the set of visual properties that may be assigned to the\n"
    " * individual characters of the text.  (Properties which affect the overall\n"
    " * block of text can only be specified on the TextNode directly).\n"
    " *\n"
    " * Typically, there is just one set of properties on a given block of text,\n"
    " * which is set directly on the TextNode (TextNode inherits from\n"
    " * TextProperties). That makes all of the text within a particular block have\n"
    " * the same appearance.\n"
    " *\n"
    " * This separate class exists in order to implement multiple different kinds\n"
    " * of text appearing within one block.  The text string itself may reference a\n"
    " * TextProperties structure by name using the \\1 and \\2 tokens embedded within\n"
    " * the string; each nested TextProperties structure modifies the appearance of\n"
    " * subsequent text within the block.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_TextProperties,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TextProperties,
    0, // tp_members
    Dtool_Properties_TextProperties,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TextProperties,
    PyType_GenericAlloc,
    Dtool_new_TextProperties,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextProperties,
  Dtool_UpcastInterface_TextProperties,
  Dtool_DowncastInterface_TextProperties,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_TextProperties(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TextProperties._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(13);
    Dtool_TextProperties._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum TextProperties::Alignment;
    PyDict_SetItemString(dict, "A_left", Dtool_WrapValue(TextProperties::A_left));
    PyDict_SetItemString(dict, "ALeft", Dtool_WrapValue(TextProperties::A_left));
    PyDict_SetItemString(dict, "A_right", Dtool_WrapValue(TextProperties::A_right));
    PyDict_SetItemString(dict, "ARight", Dtool_WrapValue(TextProperties::A_right));
    PyDict_SetItemString(dict, "A_center", Dtool_WrapValue(TextProperties::A_center));
    PyDict_SetItemString(dict, "ACenter", Dtool_WrapValue(TextProperties::A_center));
    PyDict_SetItemString(dict, "A_boxed_left", Dtool_WrapValue(TextProperties::A_boxed_left));
    PyDict_SetItemString(dict, "ABoxedLeft", Dtool_WrapValue(TextProperties::A_boxed_left));
    PyDict_SetItemString(dict, "A_boxed_right", Dtool_WrapValue(TextProperties::A_boxed_right));
    PyDict_SetItemString(dict, "ABoxedRight", Dtool_WrapValue(TextProperties::A_boxed_right));
    PyDict_SetItemString(dict, "A_boxed_center", Dtool_WrapValue(TextProperties::A_boxed_center));
    PyDict_SetItemString(dict, "ABoxedCenter", Dtool_WrapValue(TextProperties::A_boxed_center));
    if (PyType_Ready((PyTypeObject *)&Dtool_TextProperties) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextProperties)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextProperties);
  }
}

/**
 * Python method tables for TextGraphic (TextGraphic)
 */
static PyMethodDef Dtool_Methods_TextGraphic[] = {
  {"get_model", &Dtool_TextGraphic_get_model_278, METH_NOARGS, (const char *)Dtool_TextGraphic_get_model_278_comment},
  {"getModel", &Dtool_TextGraphic_get_model_278, METH_NOARGS, (const char *)Dtool_TextGraphic_get_model_278_comment},
  {"set_model", &Dtool_TextGraphic_set_model_279, METH_O, (const char *)Dtool_TextGraphic_set_model_279_comment},
  {"setModel", &Dtool_TextGraphic_set_model_279, METH_O, (const char *)Dtool_TextGraphic_set_model_279_comment},
  {"get_frame", &Dtool_TextGraphic_get_frame_282, METH_NOARGS, (const char *)Dtool_TextGraphic_get_frame_282_comment},
  {"getFrame", &Dtool_TextGraphic_get_frame_282, METH_NOARGS, (const char *)Dtool_TextGraphic_get_frame_282_comment},
  {"set_frame", (PyCFunction) &Dtool_TextGraphic_set_frame_283, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextGraphic_set_frame_283_comment},
  {"setFrame", (PyCFunction) &Dtool_TextGraphic_set_frame_283, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextGraphic_set_frame_283_comment},
  {"get_instance_flag", &Dtool_TextGraphic_get_instance_flag_286, METH_NOARGS, (const char *)Dtool_TextGraphic_get_instance_flag_286_comment},
  {"getInstanceFlag", &Dtool_TextGraphic_get_instance_flag_286, METH_NOARGS, (const char *)Dtool_TextGraphic_get_instance_flag_286_comment},
  {"set_instance_flag", &Dtool_TextGraphic_set_instance_flag_287, METH_O, (const char *)Dtool_TextGraphic_set_instance_flag_287_comment},
  {"setInstanceFlag", &Dtool_TextGraphic_set_instance_flag_287, METH_O, (const char *)Dtool_TextGraphic_set_instance_flag_287_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_TextGraphic[] = {
  {(char *)"model", &Dtool_TextGraphic_model_Getter, &Dtool_TextGraphic_model_Setter, NULL, NULL},
  {(char *)"frame", &Dtool_TextGraphic_frame_Getter, &Dtool_TextGraphic_frame_Setter, NULL, NULL},
  {(char *)"instance_flag", &Dtool_TextGraphic_instance_flag_Getter, &Dtool_TextGraphic_instance_flag_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_TextGraphic = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_TextGraphic = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.TextGraphic",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TextGraphic,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TextGraphic,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This defines a special model that has been constructed for the purposes of\n"
    " * embedding an arbitrary graphic image within a text paragraph.\n"
    " *\n"
    " * It can be any arbitrary model, though it should be built along the same\n"
    " * scale as the text, and it should probably be at least mostly two-\n"
    " * dimensional.  Typically, this means it should be constructed in the X-Z\n"
    " * plane, and it should have a maximum vertical (Z) height of 1.0.\n"
    " *\n"
    " * The frame specifies an arbitrary bounding volume in the form (left, right,\n"
    " * bottom, top).  This indicates the amount of space that will be reserved\n"
    " * within the paragraph.  The actual model is not actually required to fit\n"
    " * within this rectangle, but if it does not, it may visually overlap with\n"
    " * nearby text.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TextGraphic,
    0, // tp_members
    Dtool_Properties_TextGraphic,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TextGraphic,
    PyType_GenericAlloc,
    Dtool_new_TextGraphic,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextGraphic,
  Dtool_UpcastInterface_TextGraphic,
  Dtool_DowncastInterface_TextGraphic,
  (CoerceFunction)Dtool_ConstCoerce_TextGraphic,
  (CoerceFunction)Dtool_Coerce_TextGraphic,
};

static void Dtool_PyModuleClassInit_TextGraphic(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TextGraphic._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_TextGraphic._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TextGraphic) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextGraphic)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextGraphic);
  }
}

/**
 * Python method tables for TextPropertiesManager (TextPropertiesManager)
 */
static PyMethodDef Dtool_Methods_TextPropertiesManager[] = {
  {"set_properties", (PyCFunction) &Dtool_TextPropertiesManager_set_properties_291, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextPropertiesManager_set_properties_291_comment},
  {"setProperties", (PyCFunction) &Dtool_TextPropertiesManager_set_properties_291, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextPropertiesManager_set_properties_291_comment},
  {"get_properties", &Dtool_TextPropertiesManager_get_properties_292, METH_O, (const char *)Dtool_TextPropertiesManager_get_properties_292_comment},
  {"getProperties", &Dtool_TextPropertiesManager_get_properties_292, METH_O, (const char *)Dtool_TextPropertiesManager_get_properties_292_comment},
  {"has_properties", &Dtool_TextPropertiesManager_has_properties_293, METH_O, (const char *)Dtool_TextPropertiesManager_has_properties_293_comment},
  {"hasProperties", &Dtool_TextPropertiesManager_has_properties_293, METH_O, (const char *)Dtool_TextPropertiesManager_has_properties_293_comment},
  {"clear_properties", &Dtool_TextPropertiesManager_clear_properties_294, METH_O, (const char *)Dtool_TextPropertiesManager_clear_properties_294_comment},
  {"clearProperties", &Dtool_TextPropertiesManager_clear_properties_294, METH_O, (const char *)Dtool_TextPropertiesManager_clear_properties_294_comment},
  {"set_graphic", (PyCFunction) &Dtool_TextPropertiesManager_set_graphic_295, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextPropertiesManager_set_graphic_295_comment},
  {"setGraphic", (PyCFunction) &Dtool_TextPropertiesManager_set_graphic_295, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextPropertiesManager_set_graphic_295_comment},
  {"get_graphic", &Dtool_TextPropertiesManager_get_graphic_296, METH_O, (const char *)Dtool_TextPropertiesManager_get_graphic_296_comment},
  {"getGraphic", &Dtool_TextPropertiesManager_get_graphic_296, METH_O, (const char *)Dtool_TextPropertiesManager_get_graphic_296_comment},
  {"has_graphic", &Dtool_TextPropertiesManager_has_graphic_297, METH_O, (const char *)Dtool_TextPropertiesManager_has_graphic_297_comment},
  {"hasGraphic", &Dtool_TextPropertiesManager_has_graphic_297, METH_O, (const char *)Dtool_TextPropertiesManager_has_graphic_297_comment},
  {"clear_graphic", &Dtool_TextPropertiesManager_clear_graphic_298, METH_O, (const char *)Dtool_TextPropertiesManager_clear_graphic_298_comment},
  {"clearGraphic", &Dtool_TextPropertiesManager_clear_graphic_298, METH_O, (const char *)Dtool_TextPropertiesManager_clear_graphic_298_comment},
  {"write", (PyCFunction) &Dtool_TextPropertiesManager_write_299, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextPropertiesManager_write_299_comment},
  {"get_global_ptr", &Dtool_TextPropertiesManager_get_global_ptr_300, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextPropertiesManager_get_global_ptr_300_comment},
  {"getGlobalPtr", &Dtool_TextPropertiesManager_get_global_ptr_300, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextPropertiesManager_get_global_ptr_300_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     TextPropertiesManager
//////////////////
static PyObject *Dtool_Str_TextPropertiesManager(PyObject *self) {
  TextPropertiesManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextPropertiesManager, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_TextPropertiesManager = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_TextPropertiesManager = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.TextPropertiesManager",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TextPropertiesManager,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TextPropertiesManager,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_TextPropertiesManager,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This defines all of the TextProperties structures that might be referenced\n"
    " * by name from an embedded text string.\n"
    " *\n"
    " * A text string, as rendered by a TextNode, can contain embedded references\n"
    " * to one of the TextProperties defined here, by enclosing the name between \\1\n"
    " * (ASCII 0x01) characters; this causes a \"push\" to the named state.  All text\n"
    " * following the closing \\1 character will then be rendered in the new state.\n"
    " * The next \\2 (ASCII 0x02) character will then restore the previous state for\n"
    " * subsequent text.\n"
    " *\n"
    " * For instance, \"x\\1up\\1n\\2 + y\" indicates that the character \"x\" will be\n"
    " * rendered in the normal state, the character \"n\" will be rendered in the\n"
    " * \"up\" state, and then \" + y\" will be rendered in the normal state again.\n"
    " *\n"
    " * This can also be used to define arbitrary models that can serve as embedded\n"
    " * graphic images in a text paragraph.  This works similarly; the convention\n"
    " * is to create a TextGraphic that describes the graphic image, and then\n"
    " * associate it here via the set_graphic() call.  Then \"\\5name\\5\" will embed\n"
    " * the named graphic.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TextPropertiesManager,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TextPropertiesManager,
    PyType_GenericAlloc,
    Dtool_new_TextPropertiesManager,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextPropertiesManager,
  Dtool_UpcastInterface_TextPropertiesManager,
  Dtool_DowncastInterface_TextPropertiesManager,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_TextPropertiesManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TextPropertiesManager._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_TextPropertiesManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TextPropertiesManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextPropertiesManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextPropertiesManager);
  }
}

/**
 * Python method tables for TextAssembler (TextAssembler)
 */
static PyMethodDef Dtool_Methods_TextAssembler[] = {
  {"assign", &Dtool_TextAssembler_operator_303, METH_O, (const char *)Dtool_TextAssembler_operator_303_comment},
  {"clear", &Dtool_TextAssembler_clear_305, METH_NOARGS, (const char *)Dtool_TextAssembler_clear_305_comment},
  {"set_usage_hint", &Dtool_TextAssembler_set_usage_hint_306, METH_O, (const char *)Dtool_TextAssembler_set_usage_hint_306_comment},
  {"setUsageHint", &Dtool_TextAssembler_set_usage_hint_306, METH_O, (const char *)Dtool_TextAssembler_set_usage_hint_306_comment},
  {"get_usage_hint", &Dtool_TextAssembler_get_usage_hint_307, METH_NOARGS, (const char *)Dtool_TextAssembler_get_usage_hint_307_comment},
  {"getUsageHint", &Dtool_TextAssembler_get_usage_hint_307, METH_NOARGS, (const char *)Dtool_TextAssembler_get_usage_hint_307_comment},
  {"set_max_rows", &Dtool_TextAssembler_set_max_rows_308, METH_O, (const char *)Dtool_TextAssembler_set_max_rows_308_comment},
  {"setMaxRows", &Dtool_TextAssembler_set_max_rows_308, METH_O, (const char *)Dtool_TextAssembler_set_max_rows_308_comment},
  {"get_max_rows", &Dtool_TextAssembler_get_max_rows_309, METH_NOARGS, (const char *)Dtool_TextAssembler_get_max_rows_309_comment},
  {"getMaxRows", &Dtool_TextAssembler_get_max_rows_309, METH_NOARGS, (const char *)Dtool_TextAssembler_get_max_rows_309_comment},
  {"set_dynamic_merge", &Dtool_TextAssembler_set_dynamic_merge_310, METH_O, (const char *)Dtool_TextAssembler_set_dynamic_merge_310_comment},
  {"setDynamicMerge", &Dtool_TextAssembler_set_dynamic_merge_310, METH_O, (const char *)Dtool_TextAssembler_set_dynamic_merge_310_comment},
  {"get_dynamic_merge", &Dtool_TextAssembler_get_dynamic_merge_311, METH_NOARGS, (const char *)Dtool_TextAssembler_get_dynamic_merge_311_comment},
  {"getDynamicMerge", &Dtool_TextAssembler_get_dynamic_merge_311, METH_NOARGS, (const char *)Dtool_TextAssembler_get_dynamic_merge_311_comment},
  {"set_multiline_mode", &Dtool_TextAssembler_set_multiline_mode_312, METH_O, (const char *)Dtool_TextAssembler_set_multiline_mode_312_comment},
  {"setMultilineMode", &Dtool_TextAssembler_set_multiline_mode_312, METH_O, (const char *)Dtool_TextAssembler_set_multiline_mode_312_comment},
  {"get_multiline_mode", &Dtool_TextAssembler_get_multiline_mode_313, METH_NOARGS, (const char *)Dtool_TextAssembler_get_multiline_mode_313_comment},
  {"getMultilineMode", &Dtool_TextAssembler_get_multiline_mode_313, METH_NOARGS, (const char *)Dtool_TextAssembler_get_multiline_mode_313_comment},
  {"set_properties", &Dtool_TextAssembler_set_properties_314, METH_O, (const char *)Dtool_TextAssembler_set_properties_314_comment},
  {"setProperties", &Dtool_TextAssembler_set_properties_314, METH_O, (const char *)Dtool_TextAssembler_set_properties_314_comment},
  {"get_properties", (PyCFunction) &Dtool_TextAssembler_get_properties_315, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_properties_315_comment},
  {"getProperties", (PyCFunction) &Dtool_TextAssembler_get_properties_315, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_properties_315_comment},
  {"set_wtext", &Dtool_TextAssembler_set_wtext_316, METH_O, (const char *)Dtool_TextAssembler_set_wtext_316_comment},
  {"setWtext", &Dtool_TextAssembler_set_wtext_316, METH_O, (const char *)Dtool_TextAssembler_set_wtext_316_comment},
  {"set_wsubstr", (PyCFunction) &Dtool_TextAssembler_set_wsubstr_317, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_set_wsubstr_317_comment},
  {"setWsubstr", (PyCFunction) &Dtool_TextAssembler_set_wsubstr_317, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_set_wsubstr_317_comment},
  {"get_plain_wtext", &Dtool_TextAssembler_get_plain_wtext_318, METH_NOARGS, (const char *)Dtool_TextAssembler_get_plain_wtext_318_comment},
  {"getPlainWtext", &Dtool_TextAssembler_get_plain_wtext_318, METH_NOARGS, (const char *)Dtool_TextAssembler_get_plain_wtext_318_comment},
  {"get_wordwrapped_plain_wtext", &Dtool_TextAssembler_get_wordwrapped_plain_wtext_319, METH_NOARGS, (const char *)Dtool_TextAssembler_get_wordwrapped_plain_wtext_319_comment},
  {"getWordwrappedPlainWtext", &Dtool_TextAssembler_get_wordwrapped_plain_wtext_319, METH_NOARGS, (const char *)Dtool_TextAssembler_get_wordwrapped_plain_wtext_319_comment},
  {"get_wtext", &Dtool_TextAssembler_get_wtext_320, METH_NOARGS, (const char *)Dtool_TextAssembler_get_wtext_320_comment},
  {"getWtext", &Dtool_TextAssembler_get_wtext_320, METH_NOARGS, (const char *)Dtool_TextAssembler_get_wtext_320_comment},
  {"get_wordwrapped_wtext", &Dtool_TextAssembler_get_wordwrapped_wtext_321, METH_NOARGS, (const char *)Dtool_TextAssembler_get_wordwrapped_wtext_321_comment},
  {"getWordwrappedWtext", &Dtool_TextAssembler_get_wordwrapped_wtext_321, METH_NOARGS, (const char *)Dtool_TextAssembler_get_wordwrapped_wtext_321_comment},
  {"calc_r", &Dtool_TextAssembler_calc_r_323, METH_O, (const char *)Dtool_TextAssembler_calc_r_323_comment},
  {"calcR", &Dtool_TextAssembler_calc_r_323, METH_O, (const char *)Dtool_TextAssembler_calc_r_323_comment},
  {"calc_c", &Dtool_TextAssembler_calc_c_324, METH_O, (const char *)Dtool_TextAssembler_calc_c_324_comment},
  {"calcC", &Dtool_TextAssembler_calc_c_324, METH_O, (const char *)Dtool_TextAssembler_calc_c_324_comment},
  {"calc_index", (PyCFunction) &Dtool_TextAssembler_calc_index_325, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_calc_index_325_comment},
  {"calcIndex", (PyCFunction) &Dtool_TextAssembler_calc_index_325, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_calc_index_325_comment},
  {"get_num_characters", &Dtool_TextAssembler_get_num_characters_326, METH_NOARGS, (const char *)Dtool_TextAssembler_get_num_characters_326_comment},
  {"getNumCharacters", &Dtool_TextAssembler_get_num_characters_326, METH_NOARGS, (const char *)Dtool_TextAssembler_get_num_characters_326_comment},
  {"get_character", (PyCFunction) &Dtool_TextAssembler_get_character_327, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_character_327_comment},
  {"getCharacter", (PyCFunction) &Dtool_TextAssembler_get_character_327, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_character_327_comment},
  {"get_graphic", (PyCFunction) &Dtool_TextAssembler_get_graphic_328, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_graphic_328_comment},
  {"getGraphic", (PyCFunction) &Dtool_TextAssembler_get_graphic_328, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_graphic_328_comment},
  {"get_width", (PyCFunction) &Dtool_TextAssembler_get_width_329, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_width_329_comment},
  {"getWidth", (PyCFunction) &Dtool_TextAssembler_get_width_329, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_width_329_comment},
  {"get_num_rows", &Dtool_TextAssembler_get_num_rows_330, METH_NOARGS, (const char *)Dtool_TextAssembler_get_num_rows_330_comment},
  {"getNumRows", &Dtool_TextAssembler_get_num_rows_330, METH_NOARGS, (const char *)Dtool_TextAssembler_get_num_rows_330_comment},
  {"get_num_cols", &Dtool_TextAssembler_get_num_cols_331, METH_O, (const char *)Dtool_TextAssembler_get_num_cols_331_comment},
  {"getNumCols", &Dtool_TextAssembler_get_num_cols_331, METH_O, (const char *)Dtool_TextAssembler_get_num_cols_331_comment},
  {"get_xpos", (PyCFunction) &Dtool_TextAssembler_get_xpos_332, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_xpos_332_comment},
  {"getXpos", (PyCFunction) &Dtool_TextAssembler_get_xpos_332, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_xpos_332_comment},
  {"get_ypos", (PyCFunction) &Dtool_TextAssembler_get_ypos_333, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_ypos_333_comment},
  {"getYpos", (PyCFunction) &Dtool_TextAssembler_get_ypos_333, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextAssembler_get_ypos_333_comment},
  {"assemble_text", &Dtool_TextAssembler_assemble_text_334, METH_NOARGS, (const char *)Dtool_TextAssembler_assemble_text_334_comment},
  {"assembleText", &Dtool_TextAssembler_assemble_text_334, METH_NOARGS, (const char *)Dtool_TextAssembler_assemble_text_334_comment},
  {"get_ul", &Dtool_TextAssembler_get_ul_335, METH_NOARGS, (const char *)Dtool_TextAssembler_get_ul_335_comment},
  {"getUl", &Dtool_TextAssembler_get_ul_335, METH_NOARGS, (const char *)Dtool_TextAssembler_get_ul_335_comment},
  {"get_lr", &Dtool_TextAssembler_get_lr_336, METH_NOARGS, (const char *)Dtool_TextAssembler_get_lr_336_comment},
  {"getLr", &Dtool_TextAssembler_get_lr_336, METH_NOARGS, (const char *)Dtool_TextAssembler_get_lr_336_comment},
  {"calc_width", (PyCFunction) &Dtool_TextAssembler_calc_width_337, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextAssembler_calc_width_337_comment},
  {"calcWidth", (PyCFunction) &Dtool_TextAssembler_calc_width_337, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextAssembler_calc_width_337_comment},
  {"has_exact_character", (PyCFunction) &Dtool_TextAssembler_has_exact_character_338, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextAssembler_has_exact_character_338_comment},
  {"hasExactCharacter", (PyCFunction) &Dtool_TextAssembler_has_exact_character_338, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextAssembler_has_exact_character_338_comment},
  {"has_character", (PyCFunction) &Dtool_TextAssembler_has_character_339, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextAssembler_has_character_339_comment},
  {"hasCharacter", (PyCFunction) &Dtool_TextAssembler_has_character_339, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextAssembler_has_character_339_comment},
  {"is_whitespace", (PyCFunction) &Dtool_TextAssembler_is_whitespace_340, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextAssembler_is_whitespace_340_comment},
  {"isWhitespace", (PyCFunction) &Dtool_TextAssembler_is_whitespace_340, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextAssembler_is_whitespace_340_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_TextAssembler[] = {
  {(char *)"usage_hint", &Dtool_TextAssembler_usage_hint_Getter, &Dtool_TextAssembler_usage_hint_Setter, NULL, NULL},
  {(char *)"max_rows", &Dtool_TextAssembler_max_rows_Getter, &Dtool_TextAssembler_max_rows_Setter, NULL, NULL},
  {(char *)"dynamic_merge", &Dtool_TextAssembler_dynamic_merge_Getter, &Dtool_TextAssembler_dynamic_merge_Setter, NULL, NULL},
  {(char *)"multiline_mode", &Dtool_TextAssembler_multiline_mode_Getter, &Dtool_TextAssembler_multiline_mode_Setter, NULL, NULL},
  {(char *)"properties", &Dtool_TextAssembler_properties_Getter, &Dtool_TextAssembler_properties_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_TextAssembler = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_TextAssembler = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.TextAssembler",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TextAssembler,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TextAssembler,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is not normally used directly by user code, but is used by the\n"
    " * TextNode to lay out a block of text and convert it into rows of Geoms\n"
    " * according to the TextProperties.  However, user code may take advantage of\n"
    " * it, if desired, for very low-level text operations.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TextAssembler,
    0, // tp_members
    Dtool_Properties_TextAssembler,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TextAssembler,
    PyType_GenericAlloc,
    Dtool_new_TextAssembler,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextAssembler,
  Dtool_UpcastInterface_TextAssembler,
  Dtool_DowncastInterface_TextAssembler,
  (CoerceFunction)Dtool_ConstCoerce_TextAssembler,
  (CoerceFunction)Dtool_Coerce_TextAssembler,
};

static void Dtool_PyModuleClassInit_TextAssembler(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TextAssembler._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_TextAssembler._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TextAssembler) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextAssembler)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextAssembler);
  }
}

/**
 * Python method tables for TextNode (TextNode)
 */
static PyMethodDef Dtool_Methods_TextNode[] = {
  {"get_line_height", &Dtool_TextNode_get_line_height_361, METH_NOARGS, (const char *)Dtool_TextNode_get_line_height_361_comment},
  {"getLineHeight", &Dtool_TextNode_get_line_height_361, METH_NOARGS, (const char *)Dtool_TextNode_get_line_height_361_comment},
  {"set_max_rows", &Dtool_TextNode_set_max_rows_362, METH_O, (const char *)Dtool_TextNode_set_max_rows_362_comment},
  {"setMaxRows", &Dtool_TextNode_set_max_rows_362, METH_O, (const char *)Dtool_TextNode_set_max_rows_362_comment},
  {"clear_max_rows", &Dtool_TextNode_clear_max_rows_363, METH_NOARGS, (const char *)Dtool_TextNode_clear_max_rows_363_comment},
  {"clearMaxRows", &Dtool_TextNode_clear_max_rows_363, METH_NOARGS, (const char *)Dtool_TextNode_clear_max_rows_363_comment},
  {"has_max_rows", &Dtool_TextNode_has_max_rows_364, METH_NOARGS, (const char *)Dtool_TextNode_has_max_rows_364_comment},
  {"hasMaxRows", &Dtool_TextNode_has_max_rows_364, METH_NOARGS, (const char *)Dtool_TextNode_has_max_rows_364_comment},
  {"get_max_rows", &Dtool_TextNode_get_max_rows_365, METH_NOARGS, (const char *)Dtool_TextNode_get_max_rows_365_comment},
  {"getMaxRows", &Dtool_TextNode_get_max_rows_365, METH_NOARGS, (const char *)Dtool_TextNode_get_max_rows_365_comment},
  {"has_overflow", &Dtool_TextNode_has_overflow_366, METH_NOARGS, (const char *)Dtool_TextNode_has_overflow_366_comment},
  {"hasOverflow", &Dtool_TextNode_has_overflow_366, METH_NOARGS, (const char *)Dtool_TextNode_has_overflow_366_comment},
  {"set_frame_color", (PyCFunction) &Dtool_TextNode_set_frame_color_367, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_frame_color_367_comment},
  {"setFrameColor", (PyCFunction) &Dtool_TextNode_set_frame_color_367, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_frame_color_367_comment},
  {"get_frame_color", &Dtool_TextNode_get_frame_color_368, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_color_368_comment},
  {"getFrameColor", &Dtool_TextNode_get_frame_color_368, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_color_368_comment},
  {"set_card_border", (PyCFunction) &Dtool_TextNode_set_card_border_369, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_card_border_369_comment},
  {"setCardBorder", (PyCFunction) &Dtool_TextNode_set_card_border_369, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_card_border_369_comment},
  {"clear_card_border", &Dtool_TextNode_clear_card_border_370, METH_NOARGS, (const char *)Dtool_TextNode_clear_card_border_370_comment},
  {"clearCardBorder", &Dtool_TextNode_clear_card_border_370, METH_NOARGS, (const char *)Dtool_TextNode_clear_card_border_370_comment},
  {"get_card_border_size", &Dtool_TextNode_get_card_border_size_371, METH_NOARGS, (const char *)Dtool_TextNode_get_card_border_size_371_comment},
  {"getCardBorderSize", &Dtool_TextNode_get_card_border_size_371, METH_NOARGS, (const char *)Dtool_TextNode_get_card_border_size_371_comment},
  {"get_card_border_uv_portion", &Dtool_TextNode_get_card_border_uv_portion_372, METH_NOARGS, (const char *)Dtool_TextNode_get_card_border_uv_portion_372_comment},
  {"getCardBorderUvPortion", &Dtool_TextNode_get_card_border_uv_portion_372, METH_NOARGS, (const char *)Dtool_TextNode_get_card_border_uv_portion_372_comment},
  {"has_card_border", &Dtool_TextNode_has_card_border_373, METH_NOARGS, (const char *)Dtool_TextNode_has_card_border_373_comment},
  {"hasCardBorder", &Dtool_TextNode_has_card_border_373, METH_NOARGS, (const char *)Dtool_TextNode_has_card_border_373_comment},
  {"set_card_color", (PyCFunction) &Dtool_TextNode_set_card_color_374, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_card_color_374_comment},
  {"setCardColor", (PyCFunction) &Dtool_TextNode_set_card_color_374, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_card_color_374_comment},
  {"get_card_color", &Dtool_TextNode_get_card_color_375, METH_NOARGS, (const char *)Dtool_TextNode_get_card_color_375_comment},
  {"getCardColor", &Dtool_TextNode_get_card_color_375, METH_NOARGS, (const char *)Dtool_TextNode_get_card_color_375_comment},
  {"set_card_texture", &Dtool_TextNode_set_card_texture_376, METH_O, (const char *)Dtool_TextNode_set_card_texture_376_comment},
  {"setCardTexture", &Dtool_TextNode_set_card_texture_376, METH_O, (const char *)Dtool_TextNode_set_card_texture_376_comment},
  {"clear_card_texture", &Dtool_TextNode_clear_card_texture_377, METH_NOARGS, (const char *)Dtool_TextNode_clear_card_texture_377_comment},
  {"clearCardTexture", &Dtool_TextNode_clear_card_texture_377, METH_NOARGS, (const char *)Dtool_TextNode_clear_card_texture_377_comment},
  {"has_card_texture", &Dtool_TextNode_has_card_texture_378, METH_NOARGS, (const char *)Dtool_TextNode_has_card_texture_378_comment},
  {"hasCardTexture", &Dtool_TextNode_has_card_texture_378, METH_NOARGS, (const char *)Dtool_TextNode_has_card_texture_378_comment},
  {"get_card_texture", &Dtool_TextNode_get_card_texture_379, METH_NOARGS, (const char *)Dtool_TextNode_get_card_texture_379_comment},
  {"getCardTexture", &Dtool_TextNode_get_card_texture_379, METH_NOARGS, (const char *)Dtool_TextNode_get_card_texture_379_comment},
  {"set_frame_as_margin", (PyCFunction) &Dtool_TextNode_set_frame_as_margin_380, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_frame_as_margin_380_comment},
  {"setFrameAsMargin", (PyCFunction) &Dtool_TextNode_set_frame_as_margin_380, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_frame_as_margin_380_comment},
  {"set_frame_actual", (PyCFunction) &Dtool_TextNode_set_frame_actual_381, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_frame_actual_381_comment},
  {"setFrameActual", (PyCFunction) &Dtool_TextNode_set_frame_actual_381, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_frame_actual_381_comment},
  {"clear_frame", &Dtool_TextNode_clear_frame_382, METH_NOARGS, (const char *)Dtool_TextNode_clear_frame_382_comment},
  {"clearFrame", &Dtool_TextNode_clear_frame_382, METH_NOARGS, (const char *)Dtool_TextNode_clear_frame_382_comment},
  {"has_frame", &Dtool_TextNode_has_frame_383, METH_NOARGS, (const char *)Dtool_TextNode_has_frame_383_comment},
  {"hasFrame", &Dtool_TextNode_has_frame_383, METH_NOARGS, (const char *)Dtool_TextNode_has_frame_383_comment},
  {"is_frame_as_margin", &Dtool_TextNode_is_frame_as_margin_384, METH_NOARGS, (const char *)Dtool_TextNode_is_frame_as_margin_384_comment},
  {"isFrameAsMargin", &Dtool_TextNode_is_frame_as_margin_384, METH_NOARGS, (const char *)Dtool_TextNode_is_frame_as_margin_384_comment},
  {"get_frame_as_set", &Dtool_TextNode_get_frame_as_set_385, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_as_set_385_comment},
  {"getFrameAsSet", &Dtool_TextNode_get_frame_as_set_385, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_as_set_385_comment},
  {"get_frame_actual", &Dtool_TextNode_get_frame_actual_386, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_actual_386_comment},
  {"getFrameActual", &Dtool_TextNode_get_frame_actual_386, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_actual_386_comment},
  {"set_frame_line_width", &Dtool_TextNode_set_frame_line_width_387, METH_O, (const char *)Dtool_TextNode_set_frame_line_width_387_comment},
  {"setFrameLineWidth", &Dtool_TextNode_set_frame_line_width_387, METH_O, (const char *)Dtool_TextNode_set_frame_line_width_387_comment},
  {"get_frame_line_width", &Dtool_TextNode_get_frame_line_width_388, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_line_width_388_comment},
  {"getFrameLineWidth", &Dtool_TextNode_get_frame_line_width_388, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_line_width_388_comment},
  {"set_frame_corners", &Dtool_TextNode_set_frame_corners_389, METH_O, (const char *)Dtool_TextNode_set_frame_corners_389_comment},
  {"setFrameCorners", &Dtool_TextNode_set_frame_corners_389, METH_O, (const char *)Dtool_TextNode_set_frame_corners_389_comment},
  {"get_frame_corners", &Dtool_TextNode_get_frame_corners_390, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_corners_390_comment},
  {"getFrameCorners", &Dtool_TextNode_get_frame_corners_390, METH_NOARGS, (const char *)Dtool_TextNode_get_frame_corners_390_comment},
  {"set_card_as_margin", (PyCFunction) &Dtool_TextNode_set_card_as_margin_391, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_card_as_margin_391_comment},
  {"setCardAsMargin", (PyCFunction) &Dtool_TextNode_set_card_as_margin_391, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_card_as_margin_391_comment},
  {"set_card_actual", (PyCFunction) &Dtool_TextNode_set_card_actual_392, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_card_actual_392_comment},
  {"setCardActual", (PyCFunction) &Dtool_TextNode_set_card_actual_392, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_card_actual_392_comment},
  {"set_card_decal", &Dtool_TextNode_set_card_decal_393, METH_O, (const char *)Dtool_TextNode_set_card_decal_393_comment},
  {"setCardDecal", &Dtool_TextNode_set_card_decal_393, METH_O, (const char *)Dtool_TextNode_set_card_decal_393_comment},
  {"clear_card", &Dtool_TextNode_clear_card_394, METH_NOARGS, (const char *)Dtool_TextNode_clear_card_394_comment},
  {"clearCard", &Dtool_TextNode_clear_card_394, METH_NOARGS, (const char *)Dtool_TextNode_clear_card_394_comment},
  {"has_card", &Dtool_TextNode_has_card_395, METH_NOARGS, (const char *)Dtool_TextNode_has_card_395_comment},
  {"hasCard", &Dtool_TextNode_has_card_395, METH_NOARGS, (const char *)Dtool_TextNode_has_card_395_comment},
  {"get_card_decal", &Dtool_TextNode_get_card_decal_396, METH_NOARGS, (const char *)Dtool_TextNode_get_card_decal_396_comment},
  {"getCardDecal", &Dtool_TextNode_get_card_decal_396, METH_NOARGS, (const char *)Dtool_TextNode_get_card_decal_396_comment},
  {"is_card_as_margin", &Dtool_TextNode_is_card_as_margin_397, METH_NOARGS, (const char *)Dtool_TextNode_is_card_as_margin_397_comment},
  {"isCardAsMargin", &Dtool_TextNode_is_card_as_margin_397, METH_NOARGS, (const char *)Dtool_TextNode_is_card_as_margin_397_comment},
  {"get_card_as_set", &Dtool_TextNode_get_card_as_set_398, METH_NOARGS, (const char *)Dtool_TextNode_get_card_as_set_398_comment},
  {"getCardAsSet", &Dtool_TextNode_get_card_as_set_398, METH_NOARGS, (const char *)Dtool_TextNode_get_card_as_set_398_comment},
  {"get_card_actual", &Dtool_TextNode_get_card_actual_399, METH_NOARGS, (const char *)Dtool_TextNode_get_card_actual_399_comment},
  {"getCardActual", &Dtool_TextNode_get_card_actual_399, METH_NOARGS, (const char *)Dtool_TextNode_get_card_actual_399_comment},
  {"get_card_transformed", &Dtool_TextNode_get_card_transformed_400, METH_NOARGS, (const char *)Dtool_TextNode_get_card_transformed_400_comment},
  {"getCardTransformed", &Dtool_TextNode_get_card_transformed_400, METH_NOARGS, (const char *)Dtool_TextNode_get_card_transformed_400_comment},
  {"set_transform", &Dtool_TextNode_set_transform_401, METH_O, (const char *)Dtool_TextNode_set_transform_401_comment},
  {"setTransform", &Dtool_TextNode_set_transform_401, METH_O, (const char *)Dtool_TextNode_set_transform_401_comment},
  {"get_transform", &Dtool_TextNode_get_transform_402, METH_NOARGS, (const char *)Dtool_TextNode_get_transform_402_comment},
  {"getTransform", &Dtool_TextNode_get_transform_402, METH_NOARGS, (const char *)Dtool_TextNode_get_transform_402_comment},
  {"set_coordinate_system", &Dtool_TextNode_set_coordinate_system_403, METH_O, (const char *)Dtool_TextNode_set_coordinate_system_403_comment},
  {"setCoordinateSystem", &Dtool_TextNode_set_coordinate_system_403, METH_O, (const char *)Dtool_TextNode_set_coordinate_system_403_comment},
  {"get_coordinate_system", &Dtool_TextNode_get_coordinate_system_404, METH_NOARGS, (const char *)Dtool_TextNode_get_coordinate_system_404_comment},
  {"getCoordinateSystem", &Dtool_TextNode_get_coordinate_system_404, METH_NOARGS, (const char *)Dtool_TextNode_get_coordinate_system_404_comment},
  {"set_usage_hint", &Dtool_TextNode_set_usage_hint_405, METH_O, (const char *)Dtool_TextNode_set_usage_hint_405_comment},
  {"setUsageHint", &Dtool_TextNode_set_usage_hint_405, METH_O, (const char *)Dtool_TextNode_set_usage_hint_405_comment},
  {"get_usage_hint", &Dtool_TextNode_get_usage_hint_406, METH_NOARGS, (const char *)Dtool_TextNode_get_usage_hint_406_comment},
  {"getUsageHint", &Dtool_TextNode_get_usage_hint_406, METH_NOARGS, (const char *)Dtool_TextNode_get_usage_hint_406_comment},
  {"set_flatten_flags", &Dtool_TextNode_set_flatten_flags_407, METH_O, (const char *)Dtool_TextNode_set_flatten_flags_407_comment},
  {"setFlattenFlags", &Dtool_TextNode_set_flatten_flags_407, METH_O, (const char *)Dtool_TextNode_set_flatten_flags_407_comment},
  {"get_flatten_flags", &Dtool_TextNode_get_flatten_flags_408, METH_NOARGS, (const char *)Dtool_TextNode_get_flatten_flags_408_comment},
  {"getFlattenFlags", &Dtool_TextNode_get_flatten_flags_408, METH_NOARGS, (const char *)Dtool_TextNode_get_flatten_flags_408_comment},
  {"set_font", &Dtool_TextNode_set_font_409, METH_O, (const char *)Dtool_TextNode_set_font_409_comment},
  {"setFont", &Dtool_TextNode_set_font_409, METH_O, (const char *)Dtool_TextNode_set_font_409_comment},
  {"clear_font", &Dtool_TextNode_clear_font_410, METH_NOARGS, (const char *)Dtool_TextNode_clear_font_410_comment},
  {"clearFont", &Dtool_TextNode_clear_font_410, METH_NOARGS, (const char *)Dtool_TextNode_clear_font_410_comment},
  {"set_small_caps", &Dtool_TextNode_set_small_caps_411, METH_O, (const char *)Dtool_TextNode_set_small_caps_411_comment},
  {"setSmallCaps", &Dtool_TextNode_set_small_caps_411, METH_O, (const char *)Dtool_TextNode_set_small_caps_411_comment},
  {"clear_small_caps", &Dtool_TextNode_clear_small_caps_412, METH_NOARGS, (const char *)Dtool_TextNode_clear_small_caps_412_comment},
  {"clearSmallCaps", &Dtool_TextNode_clear_small_caps_412, METH_NOARGS, (const char *)Dtool_TextNode_clear_small_caps_412_comment},
  {"set_small_caps_scale", &Dtool_TextNode_set_small_caps_scale_413, METH_O, (const char *)Dtool_TextNode_set_small_caps_scale_413_comment},
  {"setSmallCapsScale", &Dtool_TextNode_set_small_caps_scale_413, METH_O, (const char *)Dtool_TextNode_set_small_caps_scale_413_comment},
  {"clear_small_caps_scale", &Dtool_TextNode_clear_small_caps_scale_414, METH_NOARGS, (const char *)Dtool_TextNode_clear_small_caps_scale_414_comment},
  {"clearSmallCapsScale", &Dtool_TextNode_clear_small_caps_scale_414, METH_NOARGS, (const char *)Dtool_TextNode_clear_small_caps_scale_414_comment},
  {"set_slant", &Dtool_TextNode_set_slant_415, METH_O, (const char *)Dtool_TextNode_set_slant_415_comment},
  {"setSlant", &Dtool_TextNode_set_slant_415, METH_O, (const char *)Dtool_TextNode_set_slant_415_comment},
  {"clear_slant", &Dtool_TextNode_clear_slant_416, METH_NOARGS, (const char *)Dtool_TextNode_clear_slant_416_comment},
  {"clearSlant", &Dtool_TextNode_clear_slant_416, METH_NOARGS, (const char *)Dtool_TextNode_clear_slant_416_comment},
  {"set_align", &Dtool_TextNode_set_align_417, METH_O, (const char *)Dtool_TextNode_set_align_417_comment},
  {"setAlign", &Dtool_TextNode_set_align_417, METH_O, (const char *)Dtool_TextNode_set_align_417_comment},
  {"clear_align", &Dtool_TextNode_clear_align_418, METH_NOARGS, (const char *)Dtool_TextNode_clear_align_418_comment},
  {"clearAlign", &Dtool_TextNode_clear_align_418, METH_NOARGS, (const char *)Dtool_TextNode_clear_align_418_comment},
  {"set_indent", &Dtool_TextNode_set_indent_419, METH_O, (const char *)Dtool_TextNode_set_indent_419_comment},
  {"setIndent", &Dtool_TextNode_set_indent_419, METH_O, (const char *)Dtool_TextNode_set_indent_419_comment},
  {"clear_indent", &Dtool_TextNode_clear_indent_420, METH_NOARGS, (const char *)Dtool_TextNode_clear_indent_420_comment},
  {"clearIndent", &Dtool_TextNode_clear_indent_420, METH_NOARGS, (const char *)Dtool_TextNode_clear_indent_420_comment},
  {"set_wordwrap", &Dtool_TextNode_set_wordwrap_421, METH_O, (const char *)Dtool_TextNode_set_wordwrap_421_comment},
  {"setWordwrap", &Dtool_TextNode_set_wordwrap_421, METH_O, (const char *)Dtool_TextNode_set_wordwrap_421_comment},
  {"clear_wordwrap", &Dtool_TextNode_clear_wordwrap_422, METH_NOARGS, (const char *)Dtool_TextNode_clear_wordwrap_422_comment},
  {"clearWordwrap", &Dtool_TextNode_clear_wordwrap_422, METH_NOARGS, (const char *)Dtool_TextNode_clear_wordwrap_422_comment},
  {"set_text_color", (PyCFunction) &Dtool_TextNode_set_text_color_423, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_text_color_423_comment},
  {"setTextColor", (PyCFunction) &Dtool_TextNode_set_text_color_423, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_text_color_423_comment},
  {"clear_text_color", &Dtool_TextNode_clear_text_color_424, METH_NOARGS, (const char *)Dtool_TextNode_clear_text_color_424_comment},
  {"clearTextColor", &Dtool_TextNode_clear_text_color_424, METH_NOARGS, (const char *)Dtool_TextNode_clear_text_color_424_comment},
  {"set_shadow_color", (PyCFunction) &Dtool_TextNode_set_shadow_color_425, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_shadow_color_425_comment},
  {"setShadowColor", (PyCFunction) &Dtool_TextNode_set_shadow_color_425, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_shadow_color_425_comment},
  {"clear_shadow_color", &Dtool_TextNode_clear_shadow_color_426, METH_NOARGS, (const char *)Dtool_TextNode_clear_shadow_color_426_comment},
  {"clearShadowColor", &Dtool_TextNode_clear_shadow_color_426, METH_NOARGS, (const char *)Dtool_TextNode_clear_shadow_color_426_comment},
  {"set_shadow", (PyCFunction) &Dtool_TextNode_set_shadow_427, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_shadow_427_comment},
  {"setShadow", (PyCFunction) &Dtool_TextNode_set_shadow_427, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_shadow_427_comment},
  {"clear_shadow", &Dtool_TextNode_clear_shadow_428, METH_NOARGS, (const char *)Dtool_TextNode_clear_shadow_428_comment},
  {"clearShadow", &Dtool_TextNode_clear_shadow_428, METH_NOARGS, (const char *)Dtool_TextNode_clear_shadow_428_comment},
  {"set_bin", &Dtool_TextNode_set_bin_429, METH_O, (const char *)Dtool_TextNode_set_bin_429_comment},
  {"setBin", &Dtool_TextNode_set_bin_429, METH_O, (const char *)Dtool_TextNode_set_bin_429_comment},
  {"clear_bin", &Dtool_TextNode_clear_bin_430, METH_NOARGS, (const char *)Dtool_TextNode_clear_bin_430_comment},
  {"clearBin", &Dtool_TextNode_clear_bin_430, METH_NOARGS, (const char *)Dtool_TextNode_clear_bin_430_comment},
  {"set_draw_order", &Dtool_TextNode_set_draw_order_431, METH_O, (const char *)Dtool_TextNode_set_draw_order_431_comment},
  {"setDrawOrder", &Dtool_TextNode_set_draw_order_431, METH_O, (const char *)Dtool_TextNode_set_draw_order_431_comment},
  {"clear_draw_order", &Dtool_TextNode_clear_draw_order_432, METH_NOARGS, (const char *)Dtool_TextNode_clear_draw_order_432_comment},
  {"clearDrawOrder", &Dtool_TextNode_clear_draw_order_432, METH_NOARGS, (const char *)Dtool_TextNode_clear_draw_order_432_comment},
  {"set_tab_width", &Dtool_TextNode_set_tab_width_433, METH_O, (const char *)Dtool_TextNode_set_tab_width_433_comment},
  {"setTabWidth", &Dtool_TextNode_set_tab_width_433, METH_O, (const char *)Dtool_TextNode_set_tab_width_433_comment},
  {"clear_tab_width", &Dtool_TextNode_clear_tab_width_434, METH_NOARGS, (const char *)Dtool_TextNode_clear_tab_width_434_comment},
  {"clearTabWidth", &Dtool_TextNode_clear_tab_width_434, METH_NOARGS, (const char *)Dtool_TextNode_clear_tab_width_434_comment},
  {"set_glyph_scale", &Dtool_TextNode_set_glyph_scale_435, METH_O, (const char *)Dtool_TextNode_set_glyph_scale_435_comment},
  {"setGlyphScale", &Dtool_TextNode_set_glyph_scale_435, METH_O, (const char *)Dtool_TextNode_set_glyph_scale_435_comment},
  {"clear_glyph_scale", &Dtool_TextNode_clear_glyph_scale_436, METH_NOARGS, (const char *)Dtool_TextNode_clear_glyph_scale_436_comment},
  {"clearGlyphScale", &Dtool_TextNode_clear_glyph_scale_436, METH_NOARGS, (const char *)Dtool_TextNode_clear_glyph_scale_436_comment},
  {"set_glyph_shift", &Dtool_TextNode_set_glyph_shift_437, METH_O, (const char *)Dtool_TextNode_set_glyph_shift_437_comment},
  {"setGlyphShift", &Dtool_TextNode_set_glyph_shift_437, METH_O, (const char *)Dtool_TextNode_set_glyph_shift_437_comment},
  {"clear_glyph_shift", &Dtool_TextNode_clear_glyph_shift_438, METH_NOARGS, (const char *)Dtool_TextNode_clear_glyph_shift_438_comment},
  {"clearGlyphShift", &Dtool_TextNode_clear_glyph_shift_438, METH_NOARGS, (const char *)Dtool_TextNode_clear_glyph_shift_438_comment},
  {"set_text", (PyCFunction) &Dtool_TextNode_set_text_439, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_text_439_comment},
  {"setText", (PyCFunction) &Dtool_TextNode_set_text_439, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_set_text_439_comment},
  {"clear_text", &Dtool_TextNode_clear_text_440, METH_NOARGS, (const char *)Dtool_TextNode_clear_text_440_comment},
  {"clearText", &Dtool_TextNode_clear_text_440, METH_NOARGS, (const char *)Dtool_TextNode_clear_text_440_comment},
  {"append_text", &Dtool_TextNode_append_text_441, METH_O, (const char *)Dtool_TextNode_append_text_441_comment},
  {"appendText", &Dtool_TextNode_append_text_441, METH_O, (const char *)Dtool_TextNode_append_text_441_comment},
  {"append_unicode_char", &Dtool_TextNode_append_unicode_char_442, METH_O, (const char *)Dtool_TextNode_append_unicode_char_442_comment},
  {"appendUnicodeChar", &Dtool_TextNode_append_unicode_char_442, METH_O, (const char *)Dtool_TextNode_append_unicode_char_442_comment},
  {"get_wordwrapped_text", &Dtool_TextNode_get_wordwrapped_text_443, METH_NOARGS, (const char *)Dtool_TextNode_get_wordwrapped_text_443_comment},
  {"getWordwrappedText", &Dtool_TextNode_get_wordwrapped_text_443, METH_NOARGS, (const char *)Dtool_TextNode_get_wordwrapped_text_443_comment},
  {"calc_width", &Dtool_TextNode_calc_width_444, METH_O, (const char *)Dtool_TextNode_calc_width_444_comment},
  {"calcWidth", &Dtool_TextNode_calc_width_444, METH_O, (const char *)Dtool_TextNode_calc_width_444_comment},
  {"has_exact_character", &Dtool_TextNode_has_exact_character_445, METH_O, (const char *)Dtool_TextNode_has_exact_character_445_comment},
  {"hasExactCharacter", &Dtool_TextNode_has_exact_character_445, METH_O, (const char *)Dtool_TextNode_has_exact_character_445_comment},
  {"has_character", &Dtool_TextNode_has_character_446, METH_O, (const char *)Dtool_TextNode_has_character_446_comment},
  {"hasCharacter", &Dtool_TextNode_has_character_446, METH_O, (const char *)Dtool_TextNode_has_character_446_comment},
  {"is_whitespace", &Dtool_TextNode_is_whitespace_447, METH_O, (const char *)Dtool_TextNode_is_whitespace_447_comment},
  {"isWhitespace", &Dtool_TextNode_is_whitespace_447, METH_O, (const char *)Dtool_TextNode_is_whitespace_447_comment},
  {"set_wtext", &Dtool_TextNode_set_wtext_448, METH_O, (const char *)Dtool_TextNode_set_wtext_448_comment},
  {"setWtext", &Dtool_TextNode_set_wtext_448, METH_O, (const char *)Dtool_TextNode_set_wtext_448_comment},
  {"append_wtext", &Dtool_TextNode_append_wtext_449, METH_O, (const char *)Dtool_TextNode_append_wtext_449_comment},
  {"appendWtext", &Dtool_TextNode_append_wtext_449, METH_O, (const char *)Dtool_TextNode_append_wtext_449_comment},
  {"get_wordwrapped_wtext", &Dtool_TextNode_get_wordwrapped_wtext_450, METH_NOARGS, (const char *)Dtool_TextNode_get_wordwrapped_wtext_450_comment},
  {"getWordwrappedWtext", &Dtool_TextNode_get_wordwrapped_wtext_450, METH_NOARGS, (const char *)Dtool_TextNode_get_wordwrapped_wtext_450_comment},
  {"output", &Dtool_TextNode_output_451, METH_O, (const char *)Dtool_TextNode_output_451_comment},
  {"write", (PyCFunction) &Dtool_TextNode_write_452, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextNode_write_452_comment},
  {"get_left", &Dtool_TextNode_get_left_453, METH_NOARGS, (const char *)Dtool_TextNode_get_left_453_comment},
  {"getLeft", &Dtool_TextNode_get_left_453, METH_NOARGS, (const char *)Dtool_TextNode_get_left_453_comment},
  {"get_right", &Dtool_TextNode_get_right_454, METH_NOARGS, (const char *)Dtool_TextNode_get_right_454_comment},
  {"getRight", &Dtool_TextNode_get_right_454, METH_NOARGS, (const char *)Dtool_TextNode_get_right_454_comment},
  {"get_bottom", &Dtool_TextNode_get_bottom_455, METH_NOARGS, (const char *)Dtool_TextNode_get_bottom_455_comment},
  {"getBottom", &Dtool_TextNode_get_bottom_455, METH_NOARGS, (const char *)Dtool_TextNode_get_bottom_455_comment},
  {"get_top", &Dtool_TextNode_get_top_456, METH_NOARGS, (const char *)Dtool_TextNode_get_top_456_comment},
  {"getTop", &Dtool_TextNode_get_top_456, METH_NOARGS, (const char *)Dtool_TextNode_get_top_456_comment},
  {"get_height", &Dtool_TextNode_get_height_457, METH_NOARGS, (const char *)Dtool_TextNode_get_height_457_comment},
  {"getHeight", &Dtool_TextNode_get_height_457, METH_NOARGS, (const char *)Dtool_TextNode_get_height_457_comment},
  {"get_width", &Dtool_TextNode_get_width_458, METH_NOARGS, (const char *)Dtool_TextNode_get_width_458_comment},
  {"getWidth", &Dtool_TextNode_get_width_458, METH_NOARGS, (const char *)Dtool_TextNode_get_width_458_comment},
  {"get_upper_left_3d", &Dtool_TextNode_get_upper_left_3d_459, METH_NOARGS, (const char *)Dtool_TextNode_get_upper_left_3d_459_comment},
  {"getUpperLeft3d", &Dtool_TextNode_get_upper_left_3d_459, METH_NOARGS, (const char *)Dtool_TextNode_get_upper_left_3d_459_comment},
  {"get_lower_right_3d", &Dtool_TextNode_get_lower_right_3d_460, METH_NOARGS, (const char *)Dtool_TextNode_get_lower_right_3d_460_comment},
  {"getLowerRight3d", &Dtool_TextNode_get_lower_right_3d_460, METH_NOARGS, (const char *)Dtool_TextNode_get_lower_right_3d_460_comment},
  {"get_num_rows", &Dtool_TextNode_get_num_rows_461, METH_NOARGS, (const char *)Dtool_TextNode_get_num_rows_461_comment},
  {"getNumRows", &Dtool_TextNode_get_num_rows_461, METH_NOARGS, (const char *)Dtool_TextNode_get_num_rows_461_comment},
  {"generate", &Dtool_TextNode_generate_462, METH_NOARGS, (const char *)Dtool_TextNode_generate_462_comment},
  {"update", &Dtool_TextNode_update_463, METH_NOARGS, (const char *)Dtool_TextNode_update_463_comment},
  {"force_update", &Dtool_TextNode_force_update_464, METH_NOARGS, (const char *)Dtool_TextNode_force_update_464_comment},
  {"forceUpdate", &Dtool_TextNode_force_update_464, METH_NOARGS, (const char *)Dtool_TextNode_force_update_464_comment},
  {"get_internal_geom", &Dtool_TextNode_get_internal_geom_465, METH_NOARGS, (const char *)Dtool_TextNode_get_internal_geom_465_comment},
  {"getInternalGeom", &Dtool_TextNode_get_internal_geom_465, METH_NOARGS, (const char *)Dtool_TextNode_get_internal_geom_465_comment},
  {"get_class_type", &Dtool_TextNode_get_class_type_547, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextNode_get_class_type_547_comment},
  {"getClassType", &Dtool_TextNode_get_class_type_547, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextNode_get_class_type_547_comment},
  {"upcast_to_PandaNode", &Dtool_TextNode_upcast_to_PandaNode_351, METH_NOARGS, (const char *)Dtool_TextNode_upcast_to_PandaNode_351_comment},
  {"upcastToPandaNode", &Dtool_TextNode_upcast_to_PandaNode_351, METH_NOARGS, (const char *)Dtool_TextNode_upcast_to_PandaNode_351_comment},
  {"upcast_to_TextEncoder", &Dtool_TextNode_upcast_to_TextEncoder_354, METH_NOARGS, (const char *)Dtool_TextNode_upcast_to_TextEncoder_354_comment},
  {"upcastToTextEncoder", &Dtool_TextNode_upcast_to_TextEncoder_354, METH_NOARGS, (const char *)Dtool_TextNode_upcast_to_TextEncoder_354_comment},
  {"upcast_to_TextProperties", &Dtool_TextNode_upcast_to_TextProperties_356, METH_NOARGS, (const char *)Dtool_TextNode_upcast_to_TextProperties_356_comment},
  {"upcastToTextProperties", &Dtool_TextNode_upcast_to_TextProperties_356, METH_NOARGS, (const char *)Dtool_TextNode_upcast_to_TextProperties_356_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     TextNode
//////////////////
static PyObject *Dtool_Repr_TextNode(PyObject *self) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     TextNode
//////////////////
static PyObject *Dtool_Str_TextNode(PyObject *self) {
  TextNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextNode, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_TextNode[] = {
  {(char *)"max_rows", &Dtool_TextNode_max_rows_Getter, &Dtool_TextNode_max_rows_Setter, NULL, NULL},
  {(char *)"frame_color", &Dtool_TextNode_frame_color_Getter, &Dtool_TextNode_frame_color_Setter, NULL, NULL},
  {(char *)"card_color", &Dtool_TextNode_card_color_Getter, &Dtool_TextNode_card_color_Setter, NULL, NULL},
  {(char *)"card_texture", &Dtool_TextNode_card_texture_Getter, &Dtool_TextNode_card_texture_Setter, NULL, NULL},
  {(char *)"frame_line_width", &Dtool_TextNode_frame_line_width_Getter, &Dtool_TextNode_frame_line_width_Setter, NULL, NULL},
  {(char *)"frame_corners", &Dtool_TextNode_frame_corners_Getter, &Dtool_TextNode_frame_corners_Setter, NULL, NULL},
  {(char *)"transform", &Dtool_TextNode_transform_Getter, &Dtool_TextNode_transform_Setter, NULL, NULL},
  {(char *)"coordinate_system", &Dtool_TextNode_coordinate_system_Getter, &Dtool_TextNode_coordinate_system_Setter, NULL, NULL},
  {(char *)"usage_hint", &Dtool_TextNode_usage_hint_Getter, &Dtool_TextNode_usage_hint_Setter, NULL, NULL},
  {(char *)"flatten_flags", &Dtool_TextNode_flatten_flags_Getter, &Dtool_TextNode_flatten_flags_Setter, NULL, NULL},
  {(char *)"text", &Dtool_TextNode_text_Getter, &Dtool_TextNode_text_Setter, NULL, NULL},
  {(char *)"font", &Dtool_TextNode_font_Getter, &Dtool_TextNode_font_Setter, NULL, NULL},
  {(char *)"small_caps", &Dtool_TextNode_small_caps_Getter, &Dtool_TextNode_small_caps_Setter, NULL, NULL},
  {(char *)"small_caps_scale", &Dtool_TextNode_small_caps_scale_Getter, &Dtool_TextNode_small_caps_scale_Setter, NULL, NULL},
  {(char *)"slant", &Dtool_TextNode_slant_Getter, &Dtool_TextNode_slant_Setter, NULL, NULL},
  {(char *)"underscore", &Dtool_TextNode_underscore_Getter, &Dtool_TextNode_underscore_Setter, NULL, NULL},
  {(char *)"underscore_height", &Dtool_TextNode_underscore_height_Getter, &Dtool_TextNode_underscore_height_Setter, NULL, NULL},
  {(char *)"align", &Dtool_TextNode_align_Getter, &Dtool_TextNode_align_Setter, NULL, NULL},
  {(char *)"indent", &Dtool_TextNode_indent_Getter, &Dtool_TextNode_indent_Setter, NULL, NULL},
  {(char *)"wordwrap", &Dtool_TextNode_wordwrap_Getter, &Dtool_TextNode_wordwrap_Setter, NULL, NULL},
  {(char *)"preserve_trailing_whitespace", &Dtool_TextNode_preserve_trailing_whitespace_Getter, &Dtool_TextNode_preserve_trailing_whitespace_Setter, NULL, NULL},
  {(char *)"text_color", &Dtool_TextNode_text_color_Getter, &Dtool_TextNode_text_color_Setter, NULL, NULL},
  {(char *)"shadow_color", &Dtool_TextNode_shadow_color_Getter, &Dtool_TextNode_shadow_color_Setter, NULL, NULL},
  {(char *)"shadow", &Dtool_TextNode_shadow_Getter, &Dtool_TextNode_shadow_Setter, NULL, NULL},
  {(char *)"bin", &Dtool_TextNode_bin_Getter, &Dtool_TextNode_bin_Setter, NULL, NULL},
  {(char *)"draw_order", &Dtool_TextNode_draw_order_Getter, &Dtool_TextNode_draw_order_Setter, NULL, NULL},
  {(char *)"tab_width", &Dtool_TextNode_tab_width_Getter, &Dtool_TextNode_tab_width_Setter, NULL, NULL},
  {(char *)"glyph_scale", &Dtool_TextNode_glyph_scale_Getter, &Dtool_TextNode_glyph_scale_Setter, NULL, NULL},
  {(char *)"glyph_shift", &Dtool_TextNode_glyph_shift_Getter, &Dtool_TextNode_glyph_shift_Setter, NULL, NULL},
  {(char *)"text_scale", &Dtool_TextNode_text_scale_Getter, &Dtool_TextNode_text_scale_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_TextNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TextNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_TextNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_TextNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_TextNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.TextNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TextNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_TextNode,
    &Dtool_NumberMethods_TextNode,
    &Dtool_SequenceMethods_TextNode,
    &Dtool_MappingMethods_TextNode,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_TextNode,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_TextNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The primary interface to this module.  This class does basic text assembly;\n"
    " * given a string of text and a TextFont object, it creates a piece of\n"
    " * geometry that may be placed in the 3-d or 2-d world to represent the\n"
    " * indicated text.\n"
    " *\n"
    " * The TextNode may be used in one of two ways.  Naively, it may simply be\n"
    " * parented directly into the scene graph and rendered as if it were a\n"
    " * GeomNode; in this mode, the actual polygon geometry that renders the text\n"
    " * is not directly visible or accessible, but remains hidden within the\n"
    " * TextNode.\n"
    " *\n"
    " * The second way TextNode may be used is as a text generator.  To use it in\n"
    " * this way, do not parent the TextNode to the scene graph; instead, set the\n"
    " * properties of the text and call generate() to return an ordinary node,\n"
    " * containing ordinary geometry, which you may use however you like.  Each\n"
    " * time you call generate() a new node is returned.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TextNode,
    0, // tp_members
    Dtool_Properties_TextNode,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TextNode,
    PyType_GenericAlloc,
    Dtool_new_TextNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextNode,
  Dtool_UpcastInterface_TextNode,
  Dtool_DowncastInterface_TextNode,
  (CoerceFunction)Dtool_ConstCoerce_TextNode,
  (CoerceFunction)Dtool_Coerce_TextNode,
};

static void Dtool_PyModuleClassInit_TextNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    assert(Dtool_Ptr_TextEncoder != NULL);
    assert(Dtool_Ptr_TextEncoder->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TextEncoder->_Dtool_ModuleClassInit(NULL);
    Dtool_PyModuleClassInit_TextProperties(NULL);
    Dtool_TextNode._PyType.tp_bases = PyTuple_Pack(3, (PyTypeObject *)Dtool_Ptr_PandaNode, (PyTypeObject *)Dtool_Ptr_TextEncoder, (PyTypeObject *)&Dtool_TextProperties);
    PyObject *dict = _PyDict_NewPresized(11);
    Dtool_TextNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum TextNode::FlattenFlags;
    PyDict_SetItemString(dict, "FF_none", Dtool_WrapValue(TextNode::FF_none));
    PyDict_SetItemString(dict, "FFNone", Dtool_WrapValue(TextNode::FF_none));
    PyDict_SetItemString(dict, "FF_light", Dtool_WrapValue(TextNode::FF_light));
    PyDict_SetItemString(dict, "FFLight", Dtool_WrapValue(TextNode::FF_light));
    PyDict_SetItemString(dict, "FF_medium", Dtool_WrapValue(TextNode::FF_medium));
    PyDict_SetItemString(dict, "FFMedium", Dtool_WrapValue(TextNode::FF_medium));
    PyDict_SetItemString(dict, "FF_strong", Dtool_WrapValue(TextNode::FF_strong));
    PyDict_SetItemString(dict, "FFStrong", Dtool_WrapValue(TextNode::FF_strong));
    PyDict_SetItemString(dict, "FF_dynamic_merge", Dtool_WrapValue(TextNode::FF_dynamic_merge));
    PyDict_SetItemString(dict, "FFDynamicMerge", Dtool_WrapValue(TextNode::FF_dynamic_merge));
    if (PyType_Ready((PyTypeObject *)&Dtool_TextNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextNode);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3text_RegisterTypes() {
  Dtool_TextGlyph._type = TextGlyph::get_class_type();
  RegisterRuntimeTypedClass(Dtool_TextGlyph);
  Dtool_TextFont._type = TextFont::get_class_type();
  RegisterRuntimeTypedClass(Dtool_TextFont);
  Dtool_DynamicTextGlyph._type = DynamicTextGlyph::get_class_type();
  RegisterRuntimeTypedClass(Dtool_DynamicTextGlyph);
  Dtool_DynamicTextPage._type = DynamicTextPage::get_class_type();
  RegisterRuntimeTypedClass(Dtool_DynamicTextPage);
  Dtool_DynamicTextFont._type = DynamicTextFont::get_class_type();
  RegisterRuntimeTypedClass(Dtool_DynamicTextFont);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("FontPool", Dtool_FontPool);
#endif
  Dtool_GeomTextGlyph._type = GeomTextGlyph::get_class_type();
  RegisterRuntimeTypedClass(Dtool_GeomTextGlyph);
  Dtool_StaticTextFont._type = StaticTextFont::get_class_type();
  RegisterRuntimeTypedClass(Dtool_StaticTextFont);
  Dtool_TextProperties._type = TextProperties::get_class_type();
  RegisterRuntimeTypedClass(Dtool_TextProperties);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("TextGraphic", Dtool_TextGraphic);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("TextPropertiesManager", Dtool_TextPropertiesManager);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("TextAssembler", Dtool_TextAssembler);
#endif
  Dtool_TextNode._type = TextNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_TextNode);
}

void Dtool_libp3text_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_Filename = LookupRuntimeTypedClass(Filename::get_class_type());
  Dtool_Ptr_TextEncoder = LookupNamedClass("TextEncoder");
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_TypedWritableReferenceCount = LookupRuntimeTypedClass(TypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_TypedWritable = LookupRuntimeTypedClass(TypedWritable::get_class_type());
  Dtool_Ptr_CachedTypedWritableReferenceCount = LookupRuntimeTypedClass(CachedTypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_LVecBase4f = LookupRuntimeTypedClass(LVecBase4f::get_class_type());
  Dtool_Ptr_LPoint3f = LookupRuntimeTypedClass(LPoint3f::get_class_type());
  Dtool_Ptr_LMatrix4f = LookupRuntimeTypedClass(LMatrix4f::get_class_type());
  Dtool_Ptr_LVecBase2f = LookupRuntimeTypedClass(LVecBase2f::get_class_type());
  Dtool_Ptr_LVecBase2i = LookupRuntimeTypedClass(LVecBase2i::get_class_type());
  Dtool_Ptr_LVector2f = LookupRuntimeTypedClass(LVector2f::get_class_type());
  Dtool_Ptr_CopyOnWriteObject = LookupRuntimeTypedClass(CopyOnWriteObject::get_class_type());
  Dtool_Ptr_GeomEnums = LookupNamedClass("GeomEnums");
  Dtool_Ptr_Texture = LookupRuntimeTypedClass(Texture::get_class_type());
  Dtool_Ptr_Geom = LookupRuntimeTypedClass(Geom::get_class_type());
  Dtool_Ptr_RenderState = LookupRuntimeTypedClass(RenderState::get_class_type());
  Dtool_Ptr_FreetypeFont = LookupNamedClass("FreetypeFont");
  Dtool_Ptr_PandaNode = LookupRuntimeTypedClass(PandaNode::get_class_type());
  Dtool_Ptr_NodePath = LookupRuntimeTypedClass(NodePath::get_class_type());
#endif
}

void Dtool_libp3text_BuildInstants(PyObject *module) {
  (void) module;
  // TextGlyph
  Dtool_PyModuleClassInit_TextGlyph(module);
  PyModule_AddObject(module, "TextGlyph", (PyObject *)&Dtool_TextGlyph);
  // TextFont
  Dtool_PyModuleClassInit_TextFont(module);
  PyModule_AddObject(module, "TextFont", (PyObject *)&Dtool_TextFont);
  // DynamicTextGlyph
  Dtool_PyModuleClassInit_DynamicTextGlyph(module);
  PyModule_AddObject(module, "DynamicTextGlyph", (PyObject *)&Dtool_DynamicTextGlyph);
  // DynamicTextPage
  Dtool_PyModuleClassInit_DynamicTextPage(module);
  PyModule_AddObject(module, "DynamicTextPage", (PyObject *)&Dtool_DynamicTextPage);
  // DynamicTextFont
  Dtool_PyModuleClassInit_DynamicTextFont(module);
  PyModule_AddObject(module, "DynamicTextFont", (PyObject *)&Dtool_DynamicTextFont);
  // FontPool
  Dtool_PyModuleClassInit_FontPool(module);
  PyModule_AddObject(module, "FontPool", (PyObject *)&Dtool_FontPool);
  // GeomTextGlyph
  Dtool_PyModuleClassInit_GeomTextGlyph(module);
  PyModule_AddObject(module, "GeomTextGlyph", (PyObject *)&Dtool_GeomTextGlyph);
  // StaticTextFont
  Dtool_PyModuleClassInit_StaticTextFont(module);
  PyModule_AddObject(module, "StaticTextFont", (PyObject *)&Dtool_StaticTextFont);
  // TextProperties
  Dtool_PyModuleClassInit_TextProperties(module);
  PyModule_AddObject(module, "TextProperties", (PyObject *)&Dtool_TextProperties);
  // TextGraphic
  Dtool_PyModuleClassInit_TextGraphic(module);
  PyModule_AddObject(module, "TextGraphic", (PyObject *)&Dtool_TextGraphic);
  // TextPropertiesManager
  Dtool_PyModuleClassInit_TextPropertiesManager(module);
  PyModule_AddObject(module, "TextPropertiesManager", (PyObject *)&Dtool_TextPropertiesManager);
  // TextAssembler
  Dtool_PyModuleClassInit_TextAssembler(module);
  PyModule_AddObject(module, "TextAssembler", (PyObject *)&Dtool_TextAssembler);
  // TextNode
  Dtool_PyModuleClassInit_TextNode(module);
  PyModule_AddObject(module, "TextNode", (PyObject *)&Dtool_TextNode);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3text_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478213063,  /* file_identifier */
  "libp3text",  /* library_name */
  "z_GL",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3text.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  1045  /* next_index */
};

Configure(_in_configure_libp3text);
ConfigureFn(_in_configure_libp3text) {
  interrogate_request_module(&_in_module_def);
}

