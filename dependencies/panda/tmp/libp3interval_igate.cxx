/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir direct/src/interval -Idirect/src/interval -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3interval_igate.cxx -od built/pandac/input/libp3interval.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Idirect/src/interval -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.direct -library libp3interval cConstrainHprInterval.h cConstrainPosHprInterval.h cConstrainPosInterval.h cConstrainTransformInterval.h cConstraintInterval.h cInterval.h cIntervalManager.h cLerpAnimEffectInterval.h cLerpInterval.h cLerpNodePathInterval.h cMetaInterval.h config_interval.h hideInterval.h lerp_helpers.h lerpblend.h p3interval_composite1.cxx showInterval.h waitInterval.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3interval
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "animControl.h"
#include "cConstrainHprInterval.h"
#include "cConstrainPosHprInterval.h"
#include "cConstrainPosInterval.h"
#include "cConstrainTransformInterval.h"
#include "cConstraintInterval.h"
#include "cInterval.h"
#include "cIntervalManager.h"
#include "cLerpAnimEffectInterval.h"
#include "cLerpInterval.h"
#include "cLerpNodePathInterval.h"
#include "cMetaInterval.h"
#include "config_interval.h"
#include "directbase.h"
#include "hideInterval.h"
#include "lerp_helpers.h"
#include "lerpblend.h"
#include "lquaternion.h"
#include "lvecBase3.h"
#include <math.h>
#include "nodePath.h"
#include "pdeque.h"
#include "plist.h"
#include "pmap.h"
#include "pmutex.h"
#include "pointerTo.h"
#include "pset.h"
#include "pvector.h"
#include "showInterval.h"
#include "textureStage.h"
#include "typedReferenceCount.h"
#include "vector_int.h"
#include "waitInterval.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class CInterval
 */
typedef CInterval CInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CInterval, CInterval_localtype, CInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CInterval = &Dtool_CInterval;
static void Dtool_PyModuleClassInit_CInterval(PyObject *module);

/**
 * Forward declarations for top-level class CIntervalManager
 */
typedef CIntervalManager CIntervalManager_localtype;
Define_Module_Class(panda3d.direct, CIntervalManager, CIntervalManager_localtype, CIntervalManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CIntervalManager = &Dtool_CIntervalManager;
static void Dtool_PyModuleClassInit_CIntervalManager(PyObject *module);

/**
 * Forward declarations for top-level class CConstraintInterval
 */
typedef CConstraintInterval CConstraintInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CConstraintInterval, CConstraintInterval_localtype, CConstraintInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CConstraintInterval = &Dtool_CConstraintInterval;
static void Dtool_PyModuleClassInit_CConstraintInterval(PyObject *module);

/**
 * Forward declarations for top-level class CConstrainHprInterval
 */
typedef CConstrainHprInterval CConstrainHprInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CConstrainHprInterval, CConstrainHprInterval_localtype, CConstrainHprInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CConstrainHprInterval = &Dtool_CConstrainHprInterval;
static void Dtool_PyModuleClassInit_CConstrainHprInterval(PyObject *module);
bool Dtool_ConstCoerce_CConstrainHprInterval(PyObject *args, CPT(CConstrainHprInterval) &coerced);
bool Dtool_Coerce_CConstrainHprInterval(PyObject *args, PT(CConstrainHprInterval) &coerced);

/**
 * Forward declarations for top-level class CConstrainPosHprInterval
 */
typedef CConstrainPosHprInterval CConstrainPosHprInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CConstrainPosHprInterval, CConstrainPosHprInterval_localtype, CConstrainPosHprInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CConstrainPosHprInterval = &Dtool_CConstrainPosHprInterval;
static void Dtool_PyModuleClassInit_CConstrainPosHprInterval(PyObject *module);
bool Dtool_ConstCoerce_CConstrainPosHprInterval(PyObject *args, CPT(CConstrainPosHprInterval) &coerced);
bool Dtool_Coerce_CConstrainPosHprInterval(PyObject *args, PT(CConstrainPosHprInterval) &coerced);

/**
 * Forward declarations for top-level class CConstrainPosInterval
 */
typedef CConstrainPosInterval CConstrainPosInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CConstrainPosInterval, CConstrainPosInterval_localtype, CConstrainPosInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CConstrainPosInterval = &Dtool_CConstrainPosInterval;
static void Dtool_PyModuleClassInit_CConstrainPosInterval(PyObject *module);
bool Dtool_ConstCoerce_CConstrainPosInterval(PyObject *args, CPT(CConstrainPosInterval) &coerced);
bool Dtool_Coerce_CConstrainPosInterval(PyObject *args, PT(CConstrainPosInterval) &coerced);

/**
 * Forward declarations for top-level class CConstrainTransformInterval
 */
typedef CConstrainTransformInterval CConstrainTransformInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CConstrainTransformInterval, CConstrainTransformInterval_localtype, CConstrainTransformInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CConstrainTransformInterval = &Dtool_CConstrainTransformInterval;
static void Dtool_PyModuleClassInit_CConstrainTransformInterval(PyObject *module);
bool Dtool_ConstCoerce_CConstrainTransformInterval(PyObject *args, CPT(CConstrainTransformInterval) &coerced);
bool Dtool_Coerce_CConstrainTransformInterval(PyObject *args, PT(CConstrainTransformInterval) &coerced);

/**
 * Forward declarations for top-level class CLerpInterval
 */
typedef CLerpInterval CLerpInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CLerpInterval, CLerpInterval_localtype, CLerpInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CLerpInterval = &Dtool_CLerpInterval;
static void Dtool_PyModuleClassInit_CLerpInterval(PyObject *module);

/**
 * Forward declarations for top-level class CLerpAnimEffectInterval
 */
typedef CLerpAnimEffectInterval CLerpAnimEffectInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CLerpAnimEffectInterval, CLerpAnimEffectInterval_localtype, CLerpAnimEffectInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CLerpAnimEffectInterval = &Dtool_CLerpAnimEffectInterval;
static void Dtool_PyModuleClassInit_CLerpAnimEffectInterval(PyObject *module);
bool Dtool_ConstCoerce_CLerpAnimEffectInterval(PyObject *args, CPT(CLerpAnimEffectInterval) &coerced);
bool Dtool_Coerce_CLerpAnimEffectInterval(PyObject *args, PT(CLerpAnimEffectInterval) &coerced);

/**
 * Forward declarations for top-level class CLerpNodePathInterval
 */
typedef CLerpNodePathInterval CLerpNodePathInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CLerpNodePathInterval, CLerpNodePathInterval_localtype, CLerpNodePathInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CLerpNodePathInterval = &Dtool_CLerpNodePathInterval;
static void Dtool_PyModuleClassInit_CLerpNodePathInterval(PyObject *module);
bool Dtool_ConstCoerce_CLerpNodePathInterval(PyObject *args, CPT(CLerpNodePathInterval) &coerced);
bool Dtool_Coerce_CLerpNodePathInterval(PyObject *args, PT(CLerpNodePathInterval) &coerced);

/**
 * Forward declarations for top-level class CMetaInterval
 */
typedef CMetaInterval CMetaInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CMetaInterval, CMetaInterval_localtype, CMetaInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CMetaInterval = &Dtool_CMetaInterval;
static void Dtool_PyModuleClassInit_CMetaInterval(PyObject *module);
bool Dtool_ConstCoerce_CMetaInterval(PyObject *args, CPT(CMetaInterval) &coerced);
bool Dtool_Coerce_CMetaInterval(PyObject *args, PT(CMetaInterval) &coerced);

/**
 * Forward declarations for top-level class HideInterval
 */
typedef HideInterval HideInterval_localtype;
Define_Module_ClassRef(panda3d.direct, HideInterval, HideInterval_localtype, HideInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_HideInterval = &Dtool_HideInterval;
static void Dtool_PyModuleClassInit_HideInterval(PyObject *module);
bool Dtool_ConstCoerce_HideInterval(PyObject *args, CPT(HideInterval) &coerced);
bool Dtool_Coerce_HideInterval(PyObject *args, PT(HideInterval) &coerced);

/**
 * Forward declarations for top-level class LerpBlendType
 */
typedef LerpBlendType LerpBlendType_localtype;
Define_Module_ClassRef(panda3d.direct, LerpBlendType, LerpBlendType_localtype, LerpBlendType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LerpBlendType = &Dtool_LerpBlendType;
static void Dtool_PyModuleClassInit_LerpBlendType(PyObject *module);

/**
 * Forward declarations for top-level class EaseInBlendType
 */
typedef EaseInBlendType EaseInBlendType_localtype;
Define_Module_ClassRef(panda3d.direct, EaseInBlendType, EaseInBlendType_localtype, EaseInBlendType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EaseInBlendType = &Dtool_EaseInBlendType;
static void Dtool_PyModuleClassInit_EaseInBlendType(PyObject *module);

/**
 * Forward declarations for top-level class EaseOutBlendType
 */
typedef EaseOutBlendType EaseOutBlendType_localtype;
Define_Module_ClassRef(panda3d.direct, EaseOutBlendType, EaseOutBlendType_localtype, EaseOutBlendType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EaseOutBlendType = &Dtool_EaseOutBlendType;
static void Dtool_PyModuleClassInit_EaseOutBlendType(PyObject *module);

/**
 * Forward declarations for top-level class EaseInOutBlendType
 */
typedef EaseInOutBlendType EaseInOutBlendType_localtype;
Define_Module_ClassRef(panda3d.direct, EaseInOutBlendType, EaseInOutBlendType_localtype, EaseInOutBlendType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EaseInOutBlendType = &Dtool_EaseInOutBlendType;
static void Dtool_PyModuleClassInit_EaseInOutBlendType(PyObject *module);

/**
 * Forward declarations for top-level class NoBlendType
 */
typedef NoBlendType NoBlendType_localtype;
Define_Module_ClassRef(panda3d.direct, NoBlendType, NoBlendType_localtype, NoBlendType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NoBlendType = &Dtool_NoBlendType;
static void Dtool_PyModuleClassInit_NoBlendType(PyObject *module);

/**
 * Forward declarations for top-level class ShowInterval
 */
typedef ShowInterval ShowInterval_localtype;
Define_Module_ClassRef(panda3d.direct, ShowInterval, ShowInterval_localtype, ShowInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShowInterval = &Dtool_ShowInterval;
static void Dtool_PyModuleClassInit_ShowInterval(PyObject *module);
bool Dtool_ConstCoerce_ShowInterval(PyObject *args, CPT(ShowInterval) &coerced);
bool Dtool_Coerce_ShowInterval(PyObject *args, PT(ShowInterval) &coerced);

/**
 * Forward declarations for top-level class WaitInterval
 */
typedef WaitInterval WaitInterval_localtype;
Define_Module_ClassRef(panda3d.direct, WaitInterval, WaitInterval_localtype, WaitInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_WaitInterval = &Dtool_WaitInterval;
static void Dtool_PyModuleClassInit_WaitInterval(PyObject *module);
bool Dtool_ConstCoerce_WaitInterval(PyObject *args, CPT(WaitInterval) &coerced);
bool Dtool_Coerce_WaitInterval(PyObject *args, PT(WaitInterval) &coerced);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// LVecBase2f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase2f;
inline static LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced) {
  nassertr(Dtool_Ptr_LVecBase2f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase2f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase2f *(*)(PyObject *, LVecBase2f &))Dtool_Ptr_LVecBase2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2f = &Dtool_LVecBase2f;
extern LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4f;
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3f;
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LQuaternionf
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LQuaternionf;
inline static LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced) {
  nassertr(Dtool_Ptr_LQuaternionf != NULL, NULL);
  nassertr(Dtool_Ptr_LQuaternionf->_Dtool_Coerce != NULL, NULL);
  return ((LQuaternionf *(*)(PyObject *, LQuaternionf &))Dtool_Ptr_LQuaternionf->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LQuaternionf;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LQuaternionf = &Dtool_LQuaternionf;
extern LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced);
#endif
// TextureStage
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TextureStage;
#else
extern struct Dtool_PyTypedObject Dtool_TextureStage;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureStage = &Dtool_TextureStage;
#endif
// EventQueue
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_EventQueue;
#else
extern struct Dtool_PyTypedObject Dtool_EventQueue;
static struct Dtool_PyTypedObject *const Dtool_Ptr_EventQueue = &Dtool_EventQueue;
#endif
// NodePath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePath;
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// AnimControl
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_AnimControl;
#else
extern struct Dtool_PyTypedObject Dtool_AnimControl;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimControl = &Dtool_AnimControl;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class CInterval
 */
/**
 * Python function wrapper for:
 * inline std::string const &CInterval::get_name(void) const
 */
static PyObject *Dtool_CInterval_get_name_3(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &CInterval::get_name(void) const
  std::string const &return_value = (*(const CInterval*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_name_3_comment =
  "C++ Interface:\n"
  "get_name(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the interval's name.\n"
  " */";
#else
static const char *Dtool_CInterval_get_name_3_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double CInterval::get_duration(void) const
 */
static PyObject *Dtool_CInterval_get_duration_4(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double CInterval::get_duration(void) const
  double return_value = (*(const CInterval*)local_this).get_duration();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_duration_4_comment =
  "C++ Interface:\n"
  "get_duration(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the duration of the interval in seconds.\n"
  " */";
#else
static const char *Dtool_CInterval_get_duration_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CInterval::get_open_ended(void) const
 */
static PyObject *Dtool_CInterval_get_open_ended_5(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CInterval::get_open_ended(void) const
  bool return_value = (*(const CInterval*)local_this).get_open_ended();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_open_ended_5_comment =
  "C++ Interface:\n"
  "get_open_ended(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the state of the \"open_ended\" flag.  This is primarily intended for\n"
  " * instantaneous intervals like FunctionIntervals; it indicates true if the\n"
  " * interval has some lasting effect that should be applied even if the\n"
  " * interval doesn't get started until after its finish time, or false if the\n"
  " * interval is a transitive thing that doesn't need to be called late.\n"
  " */";
#else
static const char *Dtool_CInterval_get_open_ended_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CInterval::State CInterval::get_state(void) const
 */
static PyObject *Dtool_CInterval_get_state_8(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CInterval::State CInterval::get_state(void) const
  CInterval::State return_value = (*(const CInterval*)local_this).get_state();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_state_8_comment =
  "C++ Interface:\n"
  "get_state(CInterval self)\n"
  "\n"
  "/**\n"
  " * Indicates the state the interval believes it is in: whether it has been\n"
  " * started, is currently in the middle, or has been finalized.\n"
  " */";
#else
static const char *Dtool_CInterval_get_state_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CInterval::is_stopped(void) const
 */
static PyObject *Dtool_CInterval_is_stopped_9(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CInterval::is_stopped(void) const
  bool return_value = (*(const CInterval*)local_this).is_stopped();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_is_stopped_9_comment =
  "C++ Interface:\n"
  "is_stopped(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns true if the interval is in either its initial or final states (but\n"
  " * not in a running or paused state).\n"
  " */";
#else
static const char *Dtool_CInterval_is_stopped_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CInterval::set_done_event(std::string const &event)
 */
static PyObject *Dtool_CInterval_set_done_event_10(PyObject *self, PyObject *arg) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.set_done_event")) {
    return NULL;
  }
  // 1-inline void CInterval::set_done_event(std::string const &event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_done_event(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_done_event(const CInterval self, str event)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_set_done_event_10_comment =
  "C++ Interface:\n"
  "set_done_event(const CInterval self, str event)\n"
  "\n"
  "/**\n"
  " * Sets the event that is generated whenever the interval reaches its final\n"
  " * state, whether it is explicitly finished or whether it gets there on its\n"
  " * own.\n"
  " */";
#else
static const char *Dtool_CInterval_set_done_event_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &CInterval::get_done_event(void) const
 */
static PyObject *Dtool_CInterval_get_done_event_11(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &CInterval::get_done_event(void) const
  std::string const &return_value = (*(const CInterval*)local_this).get_done_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_done_event_11_comment =
  "C++ Interface:\n"
  "get_done_event(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the event that is generated whenever the interval reaches its final\n"
  " * state, whether it is explicitly finished or whether it gets there on its\n"
  " * own.\n"
  " */";
#else
static const char *Dtool_CInterval_get_done_event_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CInterval::set_t(double t)
 */
static PyObject *Dtool_CInterval_set_t_12(PyObject *self, PyObject *arg) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.set_t")) {
    return NULL;
  }
  // 1-void CInterval::set_t(double t)
  if (PyNumber_Check(arg)) {
    (*local_this).set_t(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_t(const CInterval self, double t)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_set_t_12_comment =
  "C++ Interface:\n"
  "set_t(const CInterval self, double t)\n"
  "\n"
  "/**\n"
  " * Explicitly sets the time within the interval.  Normally, you would use\n"
  " * start() .. finish() to let the time play normally, but this may be used to\n"
  " * set the time to some particular value.\n"
  " */";
#else
static const char *Dtool_CInterval_set_t_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double CInterval::get_t(void) const
 */
static PyObject *Dtool_CInterval_get_t_13(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double CInterval::get_t(void) const
  double return_value = (*(const CInterval*)local_this).get_t();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_t_13_comment =
  "C++ Interface:\n"
  "get_t(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the current time of the interval: the last value of t passed to\n"
  " * priv_initialize(), priv_step(), or priv_finalize().\n"
  " */";
#else
static const char *Dtool_CInterval_get_t_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CInterval::set_auto_pause(bool auto_pause)
 */
static PyObject *Dtool_CInterval_set_auto_pause_14(PyObject *self, PyObject *arg) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.set_auto_pause")) {
    return NULL;
  }
  // 1-inline void CInterval::set_auto_pause(bool auto_pause)
  (*local_this).set_auto_pause((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_pause(const CInterval self, bool auto_pause)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_set_auto_pause_14_comment =
  "C++ Interface:\n"
  "set_auto_pause(const CInterval self, bool auto_pause)\n"
  "\n"
  "/**\n"
  " * Changes the state of the 'auto_pause' flag.  If this is true, the interval\n"
  " * may be arbitrarily interrupted when the system needs to reset due to some\n"
  " * external event by calling CIntervalManager::interrupt().  If this is false\n"
  " * (the default), the interval must always be explicitly finished or paused.\n"
  " */";
#else
static const char *Dtool_CInterval_set_auto_pause_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CInterval::get_auto_pause(void) const
 */
static PyObject *Dtool_CInterval_get_auto_pause_15(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CInterval::get_auto_pause(void) const
  bool return_value = (*(const CInterval*)local_this).get_auto_pause();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_auto_pause_15_comment =
  "C++ Interface:\n"
  "get_auto_pause(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the state of the 'auto_pause' flag.  See set_auto_pause().\n"
  " */";
#else
static const char *Dtool_CInterval_get_auto_pause_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CInterval::set_auto_finish(bool auto_finish)
 */
static PyObject *Dtool_CInterval_set_auto_finish_16(PyObject *self, PyObject *arg) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.set_auto_finish")) {
    return NULL;
  }
  // 1-inline void CInterval::set_auto_finish(bool auto_finish)
  (*local_this).set_auto_finish((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_finish(const CInterval self, bool auto_finish)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_set_auto_finish_16_comment =
  "C++ Interface:\n"
  "set_auto_finish(const CInterval self, bool auto_finish)\n"
  "\n"
  "/**\n"
  " * Changes the state of the 'auto_finish' flag.  If this is true, the interval\n"
  " * may be arbitrarily finished when the system needs to reset due to some\n"
  " * external event by calling CIntervalManager::interrupt().  If this is false\n"
  " * (the default), the interval must always be explicitly finished or paused.\n"
  " */";
#else
static const char *Dtool_CInterval_set_auto_finish_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CInterval::get_auto_finish(void) const
 */
static PyObject *Dtool_CInterval_get_auto_finish_17(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CInterval::get_auto_finish(void) const
  bool return_value = (*(const CInterval*)local_this).get_auto_finish();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_auto_finish_17_comment =
  "C++ Interface:\n"
  "get_auto_finish(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the state of the 'auto_finish' flag.  See set_auto_finish().\n"
  " */";
#else
static const char *Dtool_CInterval_get_auto_finish_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CInterval::set_wants_t_callback(bool wants_t_callback)
 */
static PyObject *Dtool_CInterval_set_wants_t_callback_18(PyObject *self, PyObject *arg) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.set_wants_t_callback")) {
    return NULL;
  }
  // 1-inline void CInterval::set_wants_t_callback(bool wants_t_callback)
  (*local_this).set_wants_t_callback((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wants_t_callback(const CInterval self, bool wants_t_callback)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_set_wants_t_callback_18_comment =
  "C++ Interface:\n"
  "set_wants_t_callback(const CInterval self, bool wants_t_callback)\n"
  "\n"
  "/**\n"
  " * Changes the state of the 'wants_t_callback' flag.  If this is true, the\n"
  " * interval will be returned by CIntervalManager::get_event() each time the\n"
  " * interval's time value has been changed, regardless of whether it has any\n"
  " * external events.\n"
  " */";
#else
static const char *Dtool_CInterval_set_wants_t_callback_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CInterval::get_wants_t_callback(void) const
 */
static PyObject *Dtool_CInterval_get_wants_t_callback_19(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CInterval::get_wants_t_callback(void) const
  bool return_value = (*(const CInterval*)local_this).get_wants_t_callback();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_wants_t_callback_19_comment =
  "C++ Interface:\n"
  "get_wants_t_callback(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the state of the 'wants_t_callback' flag.  See\n"
  " * set_wants_t_callback().\n"
  " */";
#else
static const char *Dtool_CInterval_get_wants_t_callback_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CInterval::set_manager(CIntervalManager *manager)
 */
static PyObject *Dtool_CInterval_set_manager_20(PyObject *self, PyObject *arg) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.set_manager")) {
    return NULL;
  }
  // 1-inline void CInterval::set_manager(CIntervalManager *manager)
  CIntervalManager *arg_this = (CIntervalManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CIntervalManager, 1, "CInterval.set_manager", false, true);
  if (arg_this != NULL) {
    (*local_this).set_manager(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_manager(const CInterval self, CIntervalManager manager)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_set_manager_20_comment =
  "C++ Interface:\n"
  "set_manager(const CInterval self, CIntervalManager manager)\n"
  "\n"
  "/**\n"
  " * Indicates the CIntervalManager object which will be responsible for playing\n"
  " * this interval.  This defaults to the global CIntervalManager; you should\n"
  " * need to change this only if you have special requirements for playing this\n"
  " * interval.\n"
  " */";
#else
static const char *Dtool_CInterval_set_manager_20_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CIntervalManager *CInterval::get_manager(void) const
 */
static PyObject *Dtool_CInterval_get_manager_21(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CIntervalManager *CInterval::get_manager(void) const
  CIntervalManager *return_value = (*(const CInterval*)local_this).get_manager();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_CIntervalManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_manager_21_comment =
  "C++ Interface:\n"
  "get_manager(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the CIntervalManager object which will be responsible for playing\n"
  " * this interval.  Note that this can only return a C++ object; if the\n"
  " * particular CIntervalManager object has been extended in the scripting\n"
  " * language, this will return the encapsulated C++ object, not the full\n"
  " * extended object.\n"
  " */";
#else
static const char *Dtool_CInterval_get_manager_21_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CInterval::start(double start_t = 0.0, double end_t = -1.0, double play_rate = 1.0)
 */
static PyObject *Dtool_CInterval_start_22(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.start")) {
    return NULL;
  }
  // 1-void CInterval::start(double start_t = 0.0, double end_t = -1.0, double play_rate = 1.0)
  double param1 = 0.0;
  double param2 = -1.0;
  double param3 = 1.0;
  static const char *keyword_list[] = {"start_t", "end_t", "play_rate", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|ddd:start", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).start((double)param1, (double)param2, (double)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "start(const CInterval self, double start_t, double end_t, double play_rate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_start_22_comment =
  "C++ Interface:\n"
  "start(const CInterval self, double start_t, double end_t, double play_rate)\n"
  "\n"
  "/**\n"
  " * Starts the interval playing by registering it with the current\n"
  " * CIntervalManager.  The interval will play to the end and stop.\n"
  " *\n"
  " * If end_t is less than zero, it indicates the end of the interval.\n"
  " */";
#else
static const char *Dtool_CInterval_start_22_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CInterval::loop(double start_t = 0.0, double end_t = -1.0, double play_rate = 1.0)
 */
static PyObject *Dtool_CInterval_loop_23(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.loop")) {
    return NULL;
  }
  // 1-void CInterval::loop(double start_t = 0.0, double end_t = -1.0, double play_rate = 1.0)
  double param1 = 0.0;
  double param2 = -1.0;
  double param3 = 1.0;
  static const char *keyword_list[] = {"start_t", "end_t", "play_rate", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|ddd:loop", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).loop((double)param1, (double)param2, (double)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "loop(const CInterval self, double start_t, double end_t, double play_rate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_loop_23_comment =
  "C++ Interface:\n"
  "loop(const CInterval self, double start_t, double end_t, double play_rate)\n"
  "\n"
  "/**\n"
  " * Starts the interval playing by registering it with the current\n"
  " * CIntervalManager.  The interval will play until it is interrupted with\n"
  " * finish() or pause(), looping back to start_t when it reaches end_t.\n"
  " *\n"
  " * If end_t is less than zero, it indicates the end of the interval.\n"
  " */";
#else
static const char *Dtool_CInterval_loop_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double CInterval::pause(void)
 */
static PyObject *Dtool_CInterval_pause_24(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.pause")) {
    return NULL;
  }
  // 1-double CInterval::pause(void)
  double return_value = (*local_this).pause();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_pause_24_comment =
  "C++ Interface:\n"
  "pause(const CInterval self)\n"
  "\n"
  "/**\n"
  " * Stops the interval from playing but leaves it in its current state.  It may\n"
  " * later be resumed from this point by calling resume().\n"
  " */";
#else
static const char *Dtool_CInterval_pause_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CInterval::resume(void)
 * void CInterval::resume(double start_t)
 */
static PyObject *Dtool_CInterval_resume_25(PyObject *self, PyObject *args) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.resume")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-void CInterval::resume(void)
      (*local_this).resume();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void CInterval::resume(double start_t)
      if (PyNumber_Check(arg)) {
        (*local_this).resume(PyFloat_AsDouble(arg));
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "resume() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "resume(const CInterval self)\n"
      "resume(const CInterval self, double start_t)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_resume_25_comment =
  "C++ Interface:\n"
  "resume(const CInterval self)\n"
  "resume(const CInterval self, double start_t)\n"
  "\n"
  "/**\n"
  " * Restarts the interval from its current point after a previous call to\n"
  " * pause().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Restarts the interval from the indicated point after a previous call to\n"
  " * pause().\n"
  " */";
#else
static const char *Dtool_CInterval_resume_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CInterval::resume_until(double end_t)
 */
static PyObject *Dtool_CInterval_resume_until_26(PyObject *self, PyObject *arg) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.resume_until")) {
    return NULL;
  }
  // 1-void CInterval::resume_until(double end_t)
  if (PyNumber_Check(arg)) {
    (*local_this).resume_until(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "resume_until(const CInterval self, double end_t)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_resume_until_26_comment =
  "C++ Interface:\n"
  "resume_until(const CInterval self, double end_t)\n"
  "\n"
  "/**\n"
  " * Restarts the interval from the current point after a previous call to\n"
  " * pause() (or a previous play-to-point-and-stop), to play until the indicated\n"
  " * point and then stop.\n"
  " */";
#else
static const char *Dtool_CInterval_resume_until_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CInterval::finish(void)
 */
static PyObject *Dtool_CInterval_finish_27(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.finish")) {
    return NULL;
  }
  // 1-void CInterval::finish(void)
  (*local_this).finish();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterval_finish_27_comment =
  "C++ Interface:\n"
  "finish(const CInterval self)\n"
  "\n"
  "/**\n"
  " * Stops the interval from playing and sets it to its final state.\n"
  " */";
#else
static const char *Dtool_CInterval_finish_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CInterval::clear_to_initial(void)
 */
static PyObject *Dtool_CInterval_clear_to_initial_28(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.clear_to_initial")) {
    return NULL;
  }
  // 1-void CInterval::clear_to_initial(void)
  (*local_this).clear_to_initial();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterval_clear_to_initial_28_comment =
  "C++ Interface:\n"
  "clear_to_initial(const CInterval self)\n"
  "\n"
  "/**\n"
  " * Pauses the interval, if it is playing, and resets its state to its initial\n"
  " * state, abandoning any state changes already in progress in the middle of\n"
  " * the interval.  Calling this is like pausing the interval and discarding it,\n"
  " * creating a new one in its place.\n"
  " */";
#else
static const char *Dtool_CInterval_clear_to_initial_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CInterval::is_playing(void) const
 */
static PyObject *Dtool_CInterval_is_playing_29(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool CInterval::is_playing(void) const
  bool return_value = (*(const CInterval*)local_this).is_playing();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_is_playing_29_comment =
  "C++ Interface:\n"
  "is_playing(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns true if the interval is currently playing, false otherwise.\n"
  " */";
#else
static const char *Dtool_CInterval_is_playing_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double CInterval::get_play_rate(void) const
 */
static PyObject *Dtool_CInterval_get_play_rate_30(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-double CInterval::get_play_rate(void) const
  double return_value = (*(const CInterval*)local_this).get_play_rate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_play_rate_30_comment =
  "C++ Interface:\n"
  "get_play_rate(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the play rate as set by the last call to start(), loop(), or\n"
  " * set_play_rate().\n"
  " */";
#else
static const char *Dtool_CInterval_get_play_rate_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CInterval::set_play_rate(double play_rate)
 */
static PyObject *Dtool_CInterval_set_play_rate_31(PyObject *self, PyObject *arg) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.set_play_rate")) {
    return NULL;
  }
  // 1-void CInterval::set_play_rate(double play_rate)
  if (PyNumber_Check(arg)) {
    (*local_this).set_play_rate(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_play_rate(const CInterval self, double play_rate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_set_play_rate_31_comment =
  "C++ Interface:\n"
  "set_play_rate(const CInterval self, double play_rate)\n"
  "\n"
  "/**\n"
  " * Changes the play rate of the interval.  If the interval is already started,\n"
  " * this changes its speed on-the-fly.  Note that since play_rate is a\n"
  " * parameter to start() and loop(), the next call to start() or loop() will\n"
  " * reset this parameter.\n"
  " */";
#else
static const char *Dtool_CInterval_set_play_rate_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CInterval::priv_do_event(double t, CInterval::EventType event)
 */
static PyObject *Dtool_CInterval_priv_do_event_32(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.priv_do_event")) {
    return NULL;
  }
  // 1-void CInterval::priv_do_event(double t, CInterval::EventType event)
  double param1;
  int param2;
  static const char *keyword_list[] = {"t", "event", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "di:priv_do_event", (char **)keyword_list, &param1, &param2)) {
    (*local_this).priv_do_event((double)param1, (CInterval::EventType)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "priv_do_event(const CInterval self, double t, int event)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_priv_do_event_32_comment =
  "C++ Interface:\n"
  "priv_do_event(const CInterval self, double t, int event)\n"
  "\n"
  "// These cannot be declared private because they must be accessible to\n"
  "// Python, but the method names are prefixed with priv_ to remind you that\n"
  "// you probably don't want to be using them directly.\n"
  "\n"
  "/**\n"
  " * Calls the appropriate event function indicated by the EventType.\n"
  " */";
#else
static const char *Dtool_CInterval_priv_do_event_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::priv_initialize(double t)
 */
static PyObject *Dtool_CInterval_priv_initialize_33(PyObject *self, PyObject *arg) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.priv_initialize")) {
    return NULL;
  }
  // 1-virtual void CInterval::priv_initialize(double t)
  if (PyNumber_Check(arg)) {
    (*local_this).priv_initialize(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "priv_initialize(const CInterval self, double t)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_priv_initialize_33_comment =
  "C++ Interface:\n"
  "priv_initialize(const CInterval self, double t)\n"
  "\n"
  "/**\n"
  " * This replaces the first call to priv_step(), and indicates that the\n"
  " * interval has just begun.  This may be overridden by derived classes that\n"
  " * need to do some explicit initialization on the first call.\n"
  " */";
#else
static const char *Dtool_CInterval_priv_initialize_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::priv_instant(void)
 */
static PyObject *Dtool_CInterval_priv_instant_34(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.priv_instant")) {
    return NULL;
  }
  // 1-virtual void CInterval::priv_instant(void)
  (*local_this).priv_instant();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterval_priv_instant_34_comment =
  "C++ Interface:\n"
  "priv_instant(const CInterval self)\n"
  "\n"
  "/**\n"
  " * This is called in lieu of priv_initialize() .. priv_step() ..\n"
  " * priv_finalize(), when everything is to happen within one frame.  The\n"
  " * interval should initialize itself, then leave itself in the final state.\n"
  " */";
#else
static const char *Dtool_CInterval_priv_instant_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::priv_step(double t)
 */
static PyObject *Dtool_CInterval_priv_step_35(PyObject *self, PyObject *arg) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.priv_step")) {
    return NULL;
  }
  // 1-virtual void CInterval::priv_step(double t)
  if (PyNumber_Check(arg)) {
    (*local_this).priv_step(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "priv_step(const CInterval self, double t)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_priv_step_35_comment =
  "C++ Interface:\n"
  "priv_step(const CInterval self, double t)\n"
  "\n"
  "/**\n"
  " * Advances the time on the interval.  The time may either increase (the\n"
  " * normal case) or decrease (e.g.  if the interval is being played by a\n"
  " * slider).\n"
  " */";
#else
static const char *Dtool_CInterval_priv_step_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::priv_finalize(void)
 */
static PyObject *Dtool_CInterval_priv_finalize_36(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.priv_finalize")) {
    return NULL;
  }
  // 1-virtual void CInterval::priv_finalize(void)
  (*local_this).priv_finalize();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterval_priv_finalize_36_comment =
  "C++ Interface:\n"
  "priv_finalize(const CInterval self)\n"
  "\n"
  "/**\n"
  " * This is called to stop an interval, forcing it to whatever state it would\n"
  " * be after it played all the way through.  It's generally invoked by\n"
  " * set_final_t().\n"
  " */";
#else
static const char *Dtool_CInterval_priv_finalize_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::priv_reverse_initialize(double t)
 */
static PyObject *Dtool_CInterval_priv_reverse_initialize_37(PyObject *self, PyObject *arg) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.priv_reverse_initialize")) {
    return NULL;
  }
  // 1-virtual void CInterval::priv_reverse_initialize(double t)
  if (PyNumber_Check(arg)) {
    (*local_this).priv_reverse_initialize(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "priv_reverse_initialize(const CInterval self, double t)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_priv_reverse_initialize_37_comment =
  "C++ Interface:\n"
  "priv_reverse_initialize(const CInterval self, double t)\n"
  "\n"
  "/**\n"
  " * Similar to priv_initialize(), but this is called when the interval is being\n"
  " * played backwards; it indicates that the interval should start at the\n"
  " * finishing state and undo any intervening intervals.\n"
  " */";
#else
static const char *Dtool_CInterval_priv_reverse_initialize_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::priv_reverse_instant(void)
 */
static PyObject *Dtool_CInterval_priv_reverse_instant_38(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.priv_reverse_instant")) {
    return NULL;
  }
  // 1-virtual void CInterval::priv_reverse_instant(void)
  (*local_this).priv_reverse_instant();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterval_priv_reverse_instant_38_comment =
  "C++ Interface:\n"
  "priv_reverse_instant(const CInterval self)\n"
  "\n"
  "/**\n"
  " * This is called in lieu of priv_reverse_initialize() .. priv_step() ..\n"
  " * priv_reverse_finalize(), when everything is to happen within one frame.\n"
  " * The interval should initialize itself, then leave itself in the initial\n"
  " * state.\n"
  " */";
#else
static const char *Dtool_CInterval_priv_reverse_instant_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::priv_reverse_finalize(void)
 */
static PyObject *Dtool_CInterval_priv_reverse_finalize_39(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.priv_reverse_finalize")) {
    return NULL;
  }
  // 1-virtual void CInterval::priv_reverse_finalize(void)
  (*local_this).priv_reverse_finalize();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterval_priv_reverse_finalize_39_comment =
  "C++ Interface:\n"
  "priv_reverse_finalize(const CInterval self)\n"
  "\n"
  "/**\n"
  " * Called generally following a priv_reverse_initialize(), this indicates the\n"
  " * interval should set itself to the initial state.\n"
  " */";
#else
static const char *Dtool_CInterval_priv_reverse_finalize_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::priv_interrupt(void)
 */
static PyObject *Dtool_CInterval_priv_interrupt_40(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.priv_interrupt")) {
    return NULL;
  }
  // 1-virtual void CInterval::priv_interrupt(void)
  (*local_this).priv_interrupt();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterval_priv_interrupt_40_comment =
  "C++ Interface:\n"
  "priv_interrupt(const CInterval self)\n"
  "\n"
  "/**\n"
  " * This is called while the interval is playing to indicate that it is about\n"
  " * to be interrupted; that is, priv_step() will not be called for a length of\n"
  " * time.  But the interval should remain in its current state in anticipation\n"
  " * of being eventually restarted when the calls to priv_step() eventually\n"
  " * resume.\n"
  " *\n"
  " * The purpose of this function is to allow self-running intervals like sound\n"
  " * intervals to stop the actual sound playback during the pause.\n"
  " */";
#else
static const char *Dtool_CInterval_priv_interrupt_40_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::output(ostream &out) const
 */
static PyObject *Dtool_CInterval_output_41(PyObject *self, PyObject *arg) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void CInterval::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "CInterval.output", false, true);
  if (arg_this != NULL) {
    (*(const CInterval*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CInterval self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_output_41_comment =
  "C++ Interface:\n"
  "output(CInterval self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CInterval_output_41_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::write(ostream &out, int indent_level) const
 */
static PyObject *Dtool_CInterval_write_42(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void CInterval::write(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "CInterval.write", false, true);
    if (param1_this != NULL) {
      (*(const CInterval*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(CInterval self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_write_42_comment =
  "C++ Interface:\n"
  "write(CInterval self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CInterval_write_42_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CInterval::setup_play(double start_time, double end_time, double play_rate, bool do_loop)
 */
static PyObject *Dtool_CInterval_setup_play_43(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.setup_play")) {
    return NULL;
  }
  // 1-void CInterval::setup_play(double start_time, double end_time, double play_rate, bool do_loop)
  double param1;
  double param2;
  double param3;
  PyObject *param4;
  static const char *keyword_list[] = {"start_time", "end_time", "play_rate", "do_loop", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dddO:setup_play", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).setup_play((double)param1, (double)param2, (double)param3, (PyObject_IsTrue(param4) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_play(const CInterval self, double start_time, double end_time, double play_rate, bool do_loop)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_setup_play_43_comment =
  "C++ Interface:\n"
  "setup_play(const CInterval self, double start_time, double end_time, double play_rate, bool do_loop)\n"
  "\n"
  "/**\n"
  " * Called to prepare the interval for automatic timed playback, e.g.  via a\n"
  " * Python task.  The interval will be played from start_t to end_t, at a time\n"
  " * factor specified by play_rate.  start_t must always be less than end_t\n"
  " * (except for the exception for end_t == -1, below), but if play_rate is\n"
  " * negative the interval will be played backwards.\n"
  " *\n"
  " * Specify end_t of -1 to play the entire interval from start_t.\n"
  " *\n"
  " * Call step_play() repeatedly to execute the interval.\n"
  " */";
#else
static const char *Dtool_CInterval_setup_play_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CInterval::setup_resume(void)
 */
static PyObject *Dtool_CInterval_setup_resume_44(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.setup_resume")) {
    return NULL;
  }
  // 1-void CInterval::setup_resume(void)
  (*local_this).setup_resume();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterval_setup_resume_44_comment =
  "C++ Interface:\n"
  "setup_resume(const CInterval self)\n"
  "\n"
  "/**\n"
  " * Called to prepare the interval for restarting at the current point within\n"
  " * the interval after an interruption.\n"
  " */";
#else
static const char *Dtool_CInterval_setup_resume_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CInterval::setup_resume_until(double end_t)
 */
static PyObject *Dtool_CInterval_setup_resume_until_45(PyObject *self, PyObject *arg) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.setup_resume_until")) {
    return NULL;
  }
  // 1-void CInterval::setup_resume_until(double end_t)
  if (PyNumber_Check(arg)) {
    (*local_this).setup_resume_until(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_resume_until(const CInterval self, double end_t)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_setup_resume_until_45_comment =
  "C++ Interface:\n"
  "setup_resume_until(const CInterval self, double end_t)\n"
  "\n"
  "/**\n"
  " * Called to prepare the interval for restarting from the current point after\n"
  " * a previous call to pause() (or a previous play-to-point-and-stop), to play\n"
  " * until the indicated point and then stop.\n"
  " */";
#else
static const char *Dtool_CInterval_setup_resume_until_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CInterval::step_play(void)
 */
static PyObject *Dtool_CInterval_step_play_46(PyObject *self, PyObject *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.step_play")) {
    return NULL;
  }
  // 1-bool CInterval::step_play(void)
  bool return_value = (*local_this).step_play();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_step_play_46_comment =
  "C++ Interface:\n"
  "step_play(const CInterval self)\n"
  "\n"
  "/**\n"
  " * Should be called once per frame to execute the automatic timed playback\n"
  " * begun with setup_play().\n"
  " *\n"
  " * Returns true if the interval should continue, false if it is done and\n"
  " * should stop.\n"
  " */";
#else
static const char *Dtool_CInterval_step_play_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CInterval::get_class_type(void)
 */
static PyObject *Dtool_CInterval_get_class_type_83(PyObject *, PyObject *) {
  // 1-static TypeHandle CInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CInterval::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_class_type_83_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CInterval_get_class_type_83_comment = NULL;
#endif

static PyObject *Dtool_CInterval_name_Getter(PyObject *self, void *) {
  const CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &CInterval::get_name(void) const
  std::string const &return_value = (*(const CInterval*)local_this).get_name();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CInterval_duration_Getter(PyObject *self, void *) {
  const CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double CInterval::get_duration(void) const
  double return_value = (*(const CInterval*)local_this).get_duration();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CInterval_open_ended_Getter(PyObject *self, void *) {
  const CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool CInterval::get_open_ended(void) const
  bool return_value = (*(const CInterval*)local_this).get_open_ended();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CInterval_state_Getter(PyObject *self, void *) {
  const CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline CInterval::State CInterval::get_state(void) const
  CInterval::State return_value = (*(const CInterval*)local_this).get_state();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CInterval_stopped_Getter(PyObject *self, void *) {
  const CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool CInterval::is_stopped(void) const
  bool return_value = (*(const CInterval*)local_this).is_stopped();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CInterval_done_event_Getter(PyObject *self, void *) {
  const CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &CInterval::get_done_event(void) const
  std::string const &return_value = (*(const CInterval*)local_this).get_done_event();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CInterval_done_event_Setter(PyObject *self, PyObject *arg, void *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.done_event")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete done_event attribute");
    return -1;
  }
  // 1-inline void CInterval::set_done_event(std::string const &event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_done_event(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_done_event(const CInterval self, str event)\n");
  }
  return -1;
}

static PyObject *Dtool_CInterval_t_Getter(PyObject *self, void *) {
  const CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double CInterval::get_t(void) const
  double return_value = (*(const CInterval*)local_this).get_t();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CInterval_t_Setter(PyObject *self, PyObject *arg, void *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.t")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete t attribute");
    return -1;
  }
  // 1-void CInterval::set_t(double t)
  if (PyNumber_Check(arg)) {
    (*local_this).set_t(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_t(const CInterval self, double t)\n");
  }
  return -1;
}

static PyObject *Dtool_CInterval_auto_pause_Getter(PyObject *self, void *) {
  const CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool CInterval::get_auto_pause(void) const
  bool return_value = (*(const CInterval*)local_this).get_auto_pause();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CInterval_auto_pause_Setter(PyObject *self, PyObject *arg, void *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.auto_pause")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete auto_pause attribute");
    return -1;
  }
  // 1-inline void CInterval::set_auto_pause(bool auto_pause)
  (*local_this).set_auto_pause((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_auto_pause(const CInterval self, bool auto_pause)\n");
  }
  return -1;
}

static PyObject *Dtool_CInterval_auto_finish_Getter(PyObject *self, void *) {
  const CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool CInterval::get_auto_finish(void) const
  bool return_value = (*(const CInterval*)local_this).get_auto_finish();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CInterval_auto_finish_Setter(PyObject *self, PyObject *arg, void *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.auto_finish")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete auto_finish attribute");
    return -1;
  }
  // 1-inline void CInterval::set_auto_finish(bool auto_finish)
  (*local_this).set_auto_finish((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_auto_finish(const CInterval self, bool auto_finish)\n");
  }
  return -1;
}

static PyObject *Dtool_CInterval_manager_Getter(PyObject *self, void *) {
  const CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline CIntervalManager *CInterval::get_manager(void) const
  CIntervalManager *return_value = (*(const CInterval*)local_this).get_manager();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_CIntervalManager, false, false);
}

static int Dtool_CInterval_manager_Setter(PyObject *self, PyObject *arg, void *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.manager")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete manager attribute");
    return -1;
  }
  // 1-inline void CInterval::set_manager(CIntervalManager *manager)
  CIntervalManager *arg_this = (CIntervalManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CIntervalManager, 1, "CInterval.set_manager", false, true);
  if (arg_this != NULL) {
    (*local_this).set_manager(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_manager(const CInterval self, CIntervalManager manager)\n");
  }
  return -1;
}

static PyObject *Dtool_CInterval_play_rate_Getter(PyObject *self, void *) {
  const CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }

  // 1-double CInterval::get_play_rate(void) const
  double return_value = (*(const CInterval*)local_this).get_play_rate();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CInterval_play_rate_Setter(PyObject *self, PyObject *arg, void *) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.play_rate")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete play_rate attribute");
    return -1;
  }
  // 1-void CInterval::set_play_rate(double play_rate)
  if (PyNumber_Check(arg)) {
    (*local_this).set_play_rate(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_play_rate(const CInterval self, double play_rate)\n");
  }
  return -1;
}

static PyObject *Dtool_CInterval_playing_Getter(PyObject *self, void *) {
  const CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }

  // 1-bool CInterval::is_playing(void) const
  bool return_value = (*(const CInterval*)local_this).is_playing();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline CInterval::CInterval(CInterval const &) = default
 */
static int Dtool_Init_CInterval(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CInterval() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline CInterval::CInterval(CInterval const &) = default
  CInterval const *arg_this = (CInterval *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CInterval, 0, "CInterval.CInterval", true, true);
  if (arg_this != NULL) {
    CInterval *return_value = new CInterval(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CInterval, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CInterval(const CInterval param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CInterval) {
    printf("CInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CInterval *local_this = (CInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CInterval*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CIntervalManager
 */
/**
 * Python function wrapper for:
 * inline void CIntervalManager::set_event_queue(EventQueue *event_queue)
 */
static PyObject *Dtool_CIntervalManager_set_event_queue_66(PyObject *self, PyObject *arg) {
  CIntervalManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CIntervalManager, (void **)&local_this, "CIntervalManager.set_event_queue")) {
    return NULL;
  }
  // 1-inline void CIntervalManager::set_event_queue(EventQueue *event_queue)
  EventQueue *arg_this = (EventQueue *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EventQueue, 1, "CIntervalManager.set_event_queue", false, true);
  if (arg_this != NULL) {
    (*local_this).set_event_queue(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_event_queue(const CIntervalManager self, EventQueue event_queue)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_set_event_queue_66_comment =
  "C++ Interface:\n"
  "set_event_queue(const CIntervalManager self, EventQueue event_queue)\n"
  "\n"
  "/**\n"
  " * Specifies a custom event queue to be used for throwing done events from\n"
  " * intervals as they finish.  If this is not specified, the global event queue\n"
  " * is used.\n"
  " *\n"
  " * The caller maintains ownership of the EventQueue object; it is the caller's\n"
  " * responsibility to ensure that the supplied EventQueue does not destruct\n"
  " * during the lifetime of the CIntervalManager.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_set_event_queue_66_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EventQueue *CIntervalManager::get_event_queue(void) const
 */
static PyObject *Dtool_CIntervalManager_get_event_queue_67(PyObject *self, PyObject *) {
  CIntervalManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CIntervalManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EventQueue *CIntervalManager::get_event_queue(void) const
  EventQueue *return_value = (*(const CIntervalManager*)local_this).get_event_queue();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EventQueue, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_get_event_queue_67_comment =
  "C++ Interface:\n"
  "get_event_queue(CIntervalManager self)\n"
  "\n"
  "/**\n"
  " * Returns the custom event queue to be used for throwing done events from\n"
  " * intervals as they finish.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_get_event_queue_67_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int CIntervalManager::add_c_interval(CInterval *interval, bool external)
 */
static PyObject *Dtool_CIntervalManager_add_c_interval_68(PyObject *self, PyObject *args, PyObject *kwds) {
  CIntervalManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CIntervalManager, (void **)&local_this, "CIntervalManager.add_c_interval")) {
    return NULL;
  }
  // 1-int CIntervalManager::add_c_interval(CInterval *interval, bool external)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"interval", "external", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_c_interval", (char **)keyword_list, &param1, &param2)) {
    CInterval *param1_this = (CInterval *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_CInterval, 1, "CIntervalManager.add_c_interval", false, true);
    if (param1_this != NULL) {
      int return_value = (*local_this).add_c_interval(param1_this, (PyObject_IsTrue(param2) != 0));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_c_interval(const CIntervalManager self, CInterval interval, bool external)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_add_c_interval_68_comment =
  "C++ Interface:\n"
  "add_c_interval(const CIntervalManager self, CInterval interval, bool external)\n"
  "\n"
  "/**\n"
  " * Adds the interval to the manager, and returns a unique index for the\n"
  " * interval.  This index will be unique among all the currently added\n"
  " * intervals, but not unique across all intervals ever added to the manager.\n"
  " * The maximum index value will never exceed the maximum number of intervals\n"
  " * added at any given time.\n"
  " *\n"
  " * If the external flag is true, the interval is understood to also be stored\n"
  " * in the scripting language data structures.  In this case, it will be\n"
  " * available for information returned by get_next_event() and\n"
  " * get_next_removal().  If external is false, the interval's index will never\n"
  " * be returned by these two functions.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_add_c_interval_68_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int CIntervalManager::find_c_interval(std::string const &name) const
 */
static PyObject *Dtool_CIntervalManager_find_c_interval_69(PyObject *self, PyObject *arg) {
  CIntervalManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CIntervalManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-int CIntervalManager::find_c_interval(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    int return_value = (*(const CIntervalManager*)local_this).find_c_interval(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_c_interval(CIntervalManager self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_find_c_interval_69_comment =
  "C++ Interface:\n"
  "find_c_interval(CIntervalManager self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the index associated with the named interval, if there is such an\n"
  " * interval, or -1 if there is not.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_find_c_interval_69_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CInterval *CIntervalManager::get_c_interval(int index) const
 */
static PyObject *Dtool_CIntervalManager_get_c_interval_70(PyObject *self, PyObject *arg) {
  CIntervalManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CIntervalManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-CInterval *CIntervalManager::get_c_interval(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    CInterval *return_value = (*(const CIntervalManager*)local_this).get_c_interval((int)arg_val);
    if (return_value != (CInterval *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (CInterval *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CInterval, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_c_interval(CIntervalManager self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_get_c_interval_70_comment =
  "C++ Interface:\n"
  "get_c_interval(CIntervalManager self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the interval associated with the given index.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_get_c_interval_70_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CIntervalManager::remove_c_interval(int index)
 */
static PyObject *Dtool_CIntervalManager_remove_c_interval_71(PyObject *self, PyObject *arg) {
  CIntervalManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CIntervalManager, (void **)&local_this, "CIntervalManager.remove_c_interval")) {
    return NULL;
  }
  // 1-void CIntervalManager::remove_c_interval(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).remove_c_interval((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_c_interval(const CIntervalManager self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_remove_c_interval_71_comment =
  "C++ Interface:\n"
  "remove_c_interval(const CIntervalManager self, int index)\n"
  "\n"
  "/**\n"
  " * Removes the indicated interval from the queue immediately.  It will not be\n"
  " * returned from get_next_removal(), and none of its pending events, if any,\n"
  " * will be returned by get_next_event().\n"
  " */";
#else
static const char *Dtool_CIntervalManager_remove_c_interval_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int CIntervalManager::interrupt(void)
 */
static PyObject *Dtool_CIntervalManager_interrupt_72(PyObject *self, PyObject *) {
  CIntervalManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CIntervalManager, (void **)&local_this, "CIntervalManager.interrupt")) {
    return NULL;
  }
  // 1-int CIntervalManager::interrupt(void)
  int return_value = (*local_this).interrupt();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_interrupt_72_comment =
  "C++ Interface:\n"
  "interrupt(const CIntervalManager self)\n"
  "\n"
  "/**\n"
  " * Pauses or finishes (removes from the active queue) all intervals tagged\n"
  " * with auto_pause or auto_finish set to true.  These are intervals that\n"
  " * someone fired up but won't necessarily expect to clean up; they can be\n"
  " * interrupted at will when necessary.\n"
  " *\n"
  " * Returns the number of intervals affected.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_interrupt_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int CIntervalManager::get_num_intervals(void) const
 */
static PyObject *Dtool_CIntervalManager_get_num_intervals_73(PyObject *self, PyObject *) {
  CIntervalManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CIntervalManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-int CIntervalManager::get_num_intervals(void) const
  int return_value = (*(const CIntervalManager*)local_this).get_num_intervals();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_get_num_intervals_73_comment =
  "C++ Interface:\n"
  "get_num_intervals(CIntervalManager self)\n"
  "\n"
  "/**\n"
  " * Returns the number of currently active intervals.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_get_num_intervals_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int CIntervalManager::get_max_index(void) const
 */
static PyObject *Dtool_CIntervalManager_get_max_index_74(PyObject *self, PyObject *) {
  CIntervalManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CIntervalManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-int CIntervalManager::get_max_index(void) const
  int return_value = (*(const CIntervalManager*)local_this).get_max_index();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_get_max_index_74_comment =
  "C++ Interface:\n"
  "get_max_index(CIntervalManager self)\n"
  "\n"
  "/**\n"
  " * Returns one more than the largest interval index number in the manager.  If\n"
  " * you walk through all the values between (0, get_max_index()] and call\n"
  " * get_c_interval() on each number, you will retrieve all of the managed\n"
  " * intervals (and possibly a number of NULL pointers as well).\n"
  " */";
#else
static const char *Dtool_CIntervalManager_get_max_index_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CIntervalManager::step(void)
 */
static PyObject *Dtool_CIntervalManager_step_75(PyObject *self, PyObject *) {
  CIntervalManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CIntervalManager, (void **)&local_this, "CIntervalManager.step")) {
    return NULL;
  }
  // 1-void CIntervalManager::step(void)
  (*local_this).step();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_step_75_comment =
  "C++ Interface:\n"
  "step(const CIntervalManager self)\n"
  "\n"
  "/**\n"
  " * This should be called every frame to do the processing for all the active\n"
  " * intervals.  It will call step_play() for each interval that has been added\n"
  " * and that has not yet been removed.\n"
  " *\n"
  " * After each call to step(), the scripting language should call\n"
  " * get_next_event() and get_next_removal() repeatedly to process all the high-\n"
  " * level (e.g.  Python-interval-based) events and to manage the high-level\n"
  " * list of intervals.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_step_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int CIntervalManager::get_next_event(void)
 */
static PyObject *Dtool_CIntervalManager_get_next_event_76(PyObject *self, PyObject *) {
  CIntervalManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CIntervalManager, (void **)&local_this, "CIntervalManager.get_next_event")) {
    return NULL;
  }
  // 1-int CIntervalManager::get_next_event(void)
  int return_value = (*local_this).get_next_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_get_next_event_76_comment =
  "C++ Interface:\n"
  "get_next_event(const CIntervalManager self)\n"
  "\n"
  "/**\n"
  " * This should be called by the scripting language after each call to step().\n"
  " * It returns the index number of the next interval that has events requiring\n"
  " * servicing by the scripting language, or -1 if no more intervals have any\n"
  " * events pending.\n"
  " *\n"
  " * If this function returns something other than -1, it is the scripting\n"
  " * language's responsibility to query the indicated interval for its next\n"
  " * event via get_event_index(), and eventually pop_event().\n"
  " *\n"
  " * Then get_next_event() should be called again until it returns -1.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_get_next_event_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int CIntervalManager::get_next_removal(void)
 */
static PyObject *Dtool_CIntervalManager_get_next_removal_77(PyObject *self, PyObject *) {
  CIntervalManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CIntervalManager, (void **)&local_this, "CIntervalManager.get_next_removal")) {
    return NULL;
  }
  // 1-int CIntervalManager::get_next_removal(void)
  int return_value = (*local_this).get_next_removal();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_get_next_removal_77_comment =
  "C++ Interface:\n"
  "get_next_removal(const CIntervalManager self)\n"
  "\n"
  "/**\n"
  " * This should be called by the scripting language after each call to step().\n"
  " * It returns the index number of an interval that was recently removed, or -1\n"
  " * if no intervals were removed.\n"
  " *\n"
  " * If this returns something other than -1, the scripting language should\n"
  " * clean up its own data structures accordingly, and then call\n"
  " * get_next_removal() again.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_get_next_removal_77_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CIntervalManager::output(ostream &out) const
 */
static PyObject *Dtool_CIntervalManager_output_78(PyObject *self, PyObject *arg) {
  CIntervalManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CIntervalManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-void CIntervalManager::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "CIntervalManager.output", false, true);
  if (arg_this != NULL) {
    (*(const CIntervalManager*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CIntervalManager self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_output_78_comment =
  "C++ Interface:\n"
  "output(CIntervalManager self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CIntervalManager_output_78_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CIntervalManager::write(ostream &out) const
 */
static PyObject *Dtool_CIntervalManager_write_79(PyObject *self, PyObject *arg) {
  CIntervalManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CIntervalManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-void CIntervalManager::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "CIntervalManager.write", false, true);
  if (arg_this != NULL) {
    (*(const CIntervalManager*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(CIntervalManager self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_write_79_comment =
  "C++ Interface:\n"
  "write(CIntervalManager self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CIntervalManager_write_79_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static CIntervalManager *CIntervalManager::get_global_ptr(void)
 */
static PyObject *Dtool_CIntervalManager_get_global_ptr_80(PyObject *, PyObject *) {
  // 1-static CIntervalManager *CIntervalManager::get_global_ptr(void)
  CIntervalManager *return_value = CIntervalManager::get_global_ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_CIntervalManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_get_global_ptr_80_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns the pointer to the one global CIntervalManager object.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_get_global_ptr_80_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CIntervalManager::CIntervalManager(void)
 */
static int Dtool_Init_CIntervalManager(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CIntervalManager() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-CIntervalManager::CIntervalManager(void)
  CIntervalManager *return_value = new CIntervalManager();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CIntervalManager, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CIntervalManager()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CIntervalManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CIntervalManager) {
    printf("CIntervalManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CIntervalManager *local_this = (CIntervalManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CIntervalManager) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CIntervalManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CIntervalManager) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CConstraintInterval
 */
/**
 * Python function wrapper for:
 * static TypeHandle CConstraintInterval::get_class_type(void)
 */
static PyObject *Dtool_CConstraintInterval_get_class_type_89(PyObject *, PyObject *) {
  // 1-static TypeHandle CConstraintInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CConstraintInterval::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CConstraintInterval_get_class_type_89_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CConstraintInterval_get_class_type_89_comment = NULL;
#endif

static PyObject *Dtool_CConstraintInterval_bogus_variable_Getter(PyObject *self, void *) {
  const CConstraintInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConstraintInterval, (void **)&local_this)) {
    return NULL;
  }

  // 1-bool CConstraintInterval::get_bogus_variable(void) const
  bool return_value = ((const CConstraintInterval*)local_this)->bogus_variable;
  return Dtool_WrapValue(return_value);
}

static int Dtool_CConstraintInterval_bogus_variable_Setter(PyObject *self, PyObject *arg, void *) {
  CConstraintInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConstraintInterval, (void **)&local_this, "CConstraintInterval.bogus_variable")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete bogus_variable attribute");
    return -1;
  }
  // 1-void CConstraintInterval::set_bogus_variable(bool value)
  (local_this)->bogus_variable = (PyObject_IsTrue(arg) != 0);
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bogus_variable(const CConstraintInterval self, bool value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline CConstraintInterval::CConstraintInterval(CConstraintInterval const &) = default
 */
static int Dtool_Init_CConstraintInterval(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CConstraintInterval() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline CConstraintInterval::CConstraintInterval(CConstraintInterval const &) = default
  CConstraintInterval const *arg_this = (CConstraintInterval *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CConstraintInterval, 0, "CConstraintInterval.CConstraintInterval", true, true);
  if (arg_this != NULL) {
    CConstraintInterval *return_value = new CConstraintInterval(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstraintInterval, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CConstraintInterval(const CConstraintInterval param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CConstraintInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CConstraintInterval) {
    printf("CConstraintInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CConstraintInterval *local_this = (CConstraintInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CConstraintInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CConstraintInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CConstraintInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (CConstraintInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CConstraintInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CConstraintInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CConstraintInterval*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CConstrainHprInterval
 */
/**
 * Python function wrapper for:
 * inline NodePath const &CConstrainHprInterval::get_node(void) const
 */
static PyObject *Dtool_CConstrainHprInterval_get_node_94(PyObject *self, PyObject *) {
  CConstrainHprInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConstrainHprInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath const &CConstrainHprInterval::get_node(void) const
  NodePath const *return_value = &((*(const CConstrainHprInterval*)local_this).get_node());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainHprInterval_get_node_94_comment =
  "C++ Interface:\n"
  "get_node(CConstrainHprInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the \"source\" node.\n"
  " */";
#else
static const char *Dtool_CConstrainHprInterval_get_node_94_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &CConstrainHprInterval::get_target(void) const
 */
static PyObject *Dtool_CConstrainHprInterval_get_target_95(PyObject *self, PyObject *) {
  CConstrainHprInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConstrainHprInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath const &CConstrainHprInterval::get_target(void) const
  NodePath const *return_value = &((*(const CConstrainHprInterval*)local_this).get_target());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainHprInterval_get_target_95_comment =
  "C++ Interface:\n"
  "get_target(CConstrainHprInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the \"target\" node.\n"
  " */";
#else
static const char *Dtool_CConstrainHprInterval_get_target_95_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CConstrainHprInterval::get_class_type(void)
 */
static PyObject *Dtool_CConstrainHprInterval_get_class_type_96(PyObject *, PyObject *) {
  // 1-static TypeHandle CConstrainHprInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CConstrainHprInterval::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainHprInterval_get_class_type_96_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CConstrainHprInterval_get_class_type_96_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CConstrainHprInterval::CConstrainHprInterval(CConstrainHprInterval const &) = default
 * CConstrainHprInterval::CConstrainHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const hprOffset = LVector3::zero())
 */
static int Dtool_Init_CConstrainHprInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline CConstrainHprInterval::CConstrainHprInterval(CConstrainHprInterval const &) = default
      CPT(CConstrainHprInterval) arg_this;
      if (!Dtool_ConstCoerce_CConstrainHprInterval(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "CConstrainHprInterval.CConstrainHprInterval", "CConstrainHprInterval");
        return -1;
      }
      CConstrainHprInterval *return_value = new CConstrainHprInterval(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainHprInterval, true, false);
    }
    break;
  case 5:
    {
      // 1-CConstrainHprInterval::CConstrainHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const hprOffset)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      double param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      static const char *keyword_list[] = {"name", "duration", "node", "target", "wrt", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#dOOO:CConstrainHprInterval", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "CConstrainHprInterval.CConstrainHprInterval", true, true);
        NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "CConstrainHprInterval.CConstrainHprInterval", true, true);
        if (param2_this != NULL && param3_this != NULL) {
          CConstrainHprInterval *return_value = new CConstrainHprInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainHprInterval, true, false);
        }
      }
    }
    break;
  case 6:
    {
      // 1-CConstrainHprInterval::CConstrainHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const hprOffset)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      double param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      PyObject *param5;
      static const char *keyword_list[] = {"name", "duration", "node", "target", "wrt", "hprOffset", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#dOOOO:CConstrainHprInterval", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5)) {
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "CConstrainHprInterval.CConstrainHprInterval", true, true);
        NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "CConstrainHprInterval.CConstrainHprInterval", true, true);
        LVecBase3f param5_local;
        LVecBase3 const *param5_this = Dtool_Coerce_LVecBase3f(param5, param5_local);
        if (!(param5_this != NULL)) {
          Dtool_Raise_ArgTypeError(param5, 5, "CConstrainHprInterval.CConstrainHprInterval", "LVecBase3f");
          return -1;
        }
        if (param2_this != NULL && param3_this != NULL) {
          CConstrainHprInterval *return_value = new CConstrainHprInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0), *param5_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainHprInterval, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CConstrainHprInterval() takes 1, 5 or 6 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CConstrainHprInterval(const CConstrainHprInterval param0)\n"
      "CConstrainHprInterval(str name, double duration, const NodePath node, const NodePath target, bool wrt)\n"
      "CConstrainHprInterval(str name, double duration, const NodePath node, const NodePath target, bool wrt, LVecBase3f hprOffset)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CConstrainHprInterval(PyObject *args, CPT(CConstrainHprInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CConstrainHprInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 5: {
        // 1-CConstrainHprInterval::CConstrainHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const hprOffset)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        double param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        if (PyArg_ParseTuple(args, "s#dOOO:CConstrainHprInterval", &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
          NodePath const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_NodePath, (void **)&param2_this);
          NodePath const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_NodePath, (void **)&param3_this);
          if (param2_this != NULL && param3_this != NULL) {
            CConstrainHprInterval *return_value = new CConstrainHprInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 6: {
        // 1-CConstrainHprInterval::CConstrainHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const hprOffset)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        double param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        PyObject *param5;
        if (PyArg_ParseTuple(args, "s#dOOOO:CConstrainHprInterval", &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5)) {
          NodePath const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_NodePath, (void **)&param2_this);
          NodePath const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_NodePath, (void **)&param3_this);
          LVecBase3 const *param5_this;
          DTOOL_Call_ExtractThisPointerForType(param5, Dtool_Ptr_LVecBase3f, (void **)&param5_this);
          if (param2_this != NULL && param3_this != NULL && param5_this != NULL) {
            CConstrainHprInterval *return_value = new CConstrainHprInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0), *param5_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_CConstrainHprInterval(PyObject *args, PT(CConstrainHprInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CConstrainHprInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 5: {
        // 1-CConstrainHprInterval::CConstrainHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const hprOffset)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        double param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        if (PyArg_ParseTuple(args, "s#dOOO:CConstrainHprInterval", &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
          NodePath const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_NodePath, (void **)&param2_this);
          NodePath const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_NodePath, (void **)&param3_this);
          if (param2_this != NULL && param3_this != NULL) {
            CConstrainHprInterval *return_value = new CConstrainHprInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 6: {
        // 1-CConstrainHprInterval::CConstrainHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const hprOffset)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        double param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        PyObject *param5;
        if (PyArg_ParseTuple(args, "s#dOOOO:CConstrainHprInterval", &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5)) {
          NodePath const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_NodePath, (void **)&param2_this);
          NodePath const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_NodePath, (void **)&param3_this);
          LVecBase3 const *param5_this;
          DTOOL_Call_ExtractThisPointerForType(param5, Dtool_Ptr_LVecBase3f, (void **)&param5_this);
          if (param2_this != NULL && param3_this != NULL && param5_this != NULL) {
            CConstrainHprInterval *return_value = new CConstrainHprInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0), *param5_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_CConstrainHprInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CConstrainHprInterval) {
    printf("CConstrainHprInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CConstrainHprInterval *local_this = (CConstrainHprInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CConstrainHprInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CConstraintInterval) {
    return (CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CConstrainHprInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CConstrainHprInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CConstraintInterval) {
    CConstraintInterval* other_this = (CConstraintInterval*)from_this;
    return (CConstrainHprInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (CConstrainHprInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CConstrainHprInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CConstrainHprInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CConstrainHprInterval*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CConstrainPosHprInterval
 */
/**
 * Python function wrapper for:
 * inline NodePath const &CConstrainPosHprInterval::get_node(void) const
 */
static PyObject *Dtool_CConstrainPosHprInterval_get_node_100(PyObject *self, PyObject *) {
  CConstrainPosHprInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConstrainPosHprInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath const &CConstrainPosHprInterval::get_node(void) const
  NodePath const *return_value = &((*(const CConstrainPosHprInterval*)local_this).get_node());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainPosHprInterval_get_node_100_comment =
  "C++ Interface:\n"
  "get_node(CConstrainPosHprInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the \"source\" node.\n"
  " */";
#else
static const char *Dtool_CConstrainPosHprInterval_get_node_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &CConstrainPosHprInterval::get_target(void) const
 */
static PyObject *Dtool_CConstrainPosHprInterval_get_target_101(PyObject *self, PyObject *) {
  CConstrainPosHprInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConstrainPosHprInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath const &CConstrainPosHprInterval::get_target(void) const
  NodePath const *return_value = &((*(const CConstrainPosHprInterval*)local_this).get_target());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainPosHprInterval_get_target_101_comment =
  "C++ Interface:\n"
  "get_target(CConstrainPosHprInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the \"target\" node.\n"
  " */";
#else
static const char *Dtool_CConstrainPosHprInterval_get_target_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CConstrainPosHprInterval::get_class_type(void)
 */
static PyObject *Dtool_CConstrainPosHprInterval_get_class_type_102(PyObject *, PyObject *) {
  // 1-static TypeHandle CConstrainPosHprInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CConstrainPosHprInterval::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainPosHprInterval_get_class_type_102_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CConstrainPosHprInterval_get_class_type_102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CConstrainPosHprInterval::CConstrainPosHprInterval(CConstrainPosHprInterval const &) = default
 * CConstrainPosHprInterval::CConstrainPosHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset = LVector3::zero(), LVecBase3 const hprOffset = LVector3::zero())
 */
static int Dtool_Init_CConstrainPosHprInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline CConstrainPosHprInterval::CConstrainPosHprInterval(CConstrainPosHprInterval const &) = default
      CPT(CConstrainPosHprInterval) arg_this;
      if (!Dtool_ConstCoerce_CConstrainPosHprInterval(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "CConstrainPosHprInterval.CConstrainPosHprInterval", "CConstrainPosHprInterval");
        return -1;
      }
      CConstrainPosHprInterval *return_value = new CConstrainPosHprInterval(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainPosHprInterval, true, false);
    }
    break;
  case 5:
    {
      // 1-CConstrainPosHprInterval::CConstrainPosHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset, LVecBase3 const hprOffset)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      double param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      static const char *keyword_list[] = {"name", "duration", "node", "target", "wrt", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#dOOO:CConstrainPosHprInterval", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "CConstrainPosHprInterval.CConstrainPosHprInterval", true, true);
        NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "CConstrainPosHprInterval.CConstrainPosHprInterval", true, true);
        if (param2_this != NULL && param3_this != NULL) {
          CConstrainPosHprInterval *return_value = new CConstrainPosHprInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainPosHprInterval, true, false);
        }
      }
    }
    break;
  case 6:
    {
      // 1-CConstrainPosHprInterval::CConstrainPosHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset, LVecBase3 const hprOffset)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      double param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      PyObject *param5;
      static const char *keyword_list[] = {"name", "duration", "node", "target", "wrt", "posOffset", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#dOOOO:CConstrainPosHprInterval", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5)) {
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "CConstrainPosHprInterval.CConstrainPosHprInterval", true, true);
        NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "CConstrainPosHprInterval.CConstrainPosHprInterval", true, true);
        LVecBase3f param5_local;
        LVecBase3 const *param5_this = Dtool_Coerce_LVecBase3f(param5, param5_local);
        if (!(param5_this != NULL)) {
          Dtool_Raise_ArgTypeError(param5, 5, "CConstrainPosHprInterval.CConstrainPosHprInterval", "LVecBase3f");
          return -1;
        }
        if (param2_this != NULL && param3_this != NULL) {
          CConstrainPosHprInterval *return_value = new CConstrainPosHprInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0), *param5_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainPosHprInterval, true, false);
        }
      }
    }
    break;
  case 7:
    {
      // 1-CConstrainPosHprInterval::CConstrainPosHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset, LVecBase3 const hprOffset)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      double param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      PyObject *param5;
      PyObject *param6;
      static const char *keyword_list[] = {"name", "duration", "node", "target", "wrt", "posOffset", "hprOffset", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#dOOOOO:CConstrainPosHprInterval", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5, &param6)) {
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "CConstrainPosHprInterval.CConstrainPosHprInterval", true, true);
        NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "CConstrainPosHprInterval.CConstrainPosHprInterval", true, true);
        LVecBase3f param5_local;
        LVecBase3 const *param5_this = Dtool_Coerce_LVecBase3f(param5, param5_local);
        if (!(param5_this != NULL)) {
          Dtool_Raise_ArgTypeError(param5, 5, "CConstrainPosHprInterval.CConstrainPosHprInterval", "LVecBase3f");
          return -1;
        }
        LVecBase3f param6_local;
        LVecBase3 const *param6_this = Dtool_Coerce_LVecBase3f(param6, param6_local);
        if (!(param6_this != NULL)) {
          Dtool_Raise_ArgTypeError(param6, 6, "CConstrainPosHprInterval.CConstrainPosHprInterval", "LVecBase3f");
          return -1;
        }
        if (param2_this != NULL && param3_this != NULL) {
          CConstrainPosHprInterval *return_value = new CConstrainPosHprInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0), *param5_this, *param6_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainPosHprInterval, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CConstrainPosHprInterval() takes 1, 5, 6 or 7 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CConstrainPosHprInterval(const CConstrainPosHprInterval param0)\n"
      "CConstrainPosHprInterval(str name, double duration, const NodePath node, const NodePath target, bool wrt)\n"
      "CConstrainPosHprInterval(str name, double duration, const NodePath node, const NodePath target, bool wrt, LVecBase3f posOffset)\n"
      "CConstrainPosHprInterval(str name, double duration, const NodePath node, const NodePath target, bool wrt, LVecBase3f posOffset, LVecBase3f hprOffset)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CConstrainPosHprInterval(PyObject *args, CPT(CConstrainPosHprInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CConstrainPosHprInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 5: {
        // 1-CConstrainPosHprInterval::CConstrainPosHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset, LVecBase3 const hprOffset)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        double param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        if (PyArg_ParseTuple(args, "s#dOOO:CConstrainPosHprInterval", &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
          NodePath const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_NodePath, (void **)&param2_this);
          NodePath const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_NodePath, (void **)&param3_this);
          if (param2_this != NULL && param3_this != NULL) {
            CConstrainPosHprInterval *return_value = new CConstrainPosHprInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 6: {
        // 1-CConstrainPosHprInterval::CConstrainPosHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset, LVecBase3 const hprOffset)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        double param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        PyObject *param5;
        if (PyArg_ParseTuple(args, "s#dOOOO:CConstrainPosHprInterval", &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5)) {
          NodePath const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_NodePath, (void **)&param2_this);
          NodePath const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_NodePath, (void **)&param3_this);
          LVecBase3 const *param5_this;
          DTOOL_Call_ExtractThisPointerForType(param5, Dtool_Ptr_LVecBase3f, (void **)&param5_this);
          if (param2_this != NULL && param3_this != NULL && param5_this != NULL) {
            CConstrainPosHprInterval *return_value = new CConstrainPosHprInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0), *param5_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 7: {
        // 1-CConstrainPosHprInterval::CConstrainPosHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset, LVecBase3 const hprOffset)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        double param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        PyObject *param5;
        PyObject *param6;
        if (PyArg_ParseTuple(args, "s#dOOOOO:CConstrainPosHprInterval", &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5, &param6)) {
          NodePath const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_NodePath, (void **)&param2_this);
          NodePath const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_NodePath, (void **)&param3_this);
          LVecBase3 const *param5_this;
          DTOOL_Call_ExtractThisPointerForType(param5, Dtool_Ptr_LVecBase3f, (void **)&param5_this);
          LVecBase3 const *param6_this;
          DTOOL_Call_ExtractThisPointerForType(param6, Dtool_Ptr_LVecBase3f, (void **)&param6_this);
          if (param2_this != NULL && param3_this != NULL && param5_this != NULL && param6_this != NULL) {
            CConstrainPosHprInterval *return_value = new CConstrainPosHprInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0), *param5_this, *param6_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_CConstrainPosHprInterval(PyObject *args, PT(CConstrainPosHprInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CConstrainPosHprInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 5: {
        // 1-CConstrainPosHprInterval::CConstrainPosHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset, LVecBase3 const hprOffset)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        double param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        if (PyArg_ParseTuple(args, "s#dOOO:CConstrainPosHprInterval", &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
          NodePath const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_NodePath, (void **)&param2_this);
          NodePath const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_NodePath, (void **)&param3_this);
          if (param2_this != NULL && param3_this != NULL) {
            CConstrainPosHprInterval *return_value = new CConstrainPosHprInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 6: {
        // 1-CConstrainPosHprInterval::CConstrainPosHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset, LVecBase3 const hprOffset)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        double param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        PyObject *param5;
        if (PyArg_ParseTuple(args, "s#dOOOO:CConstrainPosHprInterval", &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5)) {
          NodePath const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_NodePath, (void **)&param2_this);
          NodePath const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_NodePath, (void **)&param3_this);
          LVecBase3 const *param5_this;
          DTOOL_Call_ExtractThisPointerForType(param5, Dtool_Ptr_LVecBase3f, (void **)&param5_this);
          if (param2_this != NULL && param3_this != NULL && param5_this != NULL) {
            CConstrainPosHprInterval *return_value = new CConstrainPosHprInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0), *param5_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 7: {
        // 1-CConstrainPosHprInterval::CConstrainPosHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset, LVecBase3 const hprOffset)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        double param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        PyObject *param5;
        PyObject *param6;
        if (PyArg_ParseTuple(args, "s#dOOOOO:CConstrainPosHprInterval", &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5, &param6)) {
          NodePath const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_NodePath, (void **)&param2_this);
          NodePath const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_NodePath, (void **)&param3_this);
          LVecBase3 const *param5_this;
          DTOOL_Call_ExtractThisPointerForType(param5, Dtool_Ptr_LVecBase3f, (void **)&param5_this);
          LVecBase3 const *param6_this;
          DTOOL_Call_ExtractThisPointerForType(param6, Dtool_Ptr_LVecBase3f, (void **)&param6_this);
          if (param2_this != NULL && param3_this != NULL && param5_this != NULL && param6_this != NULL) {
            CConstrainPosHprInterval *return_value = new CConstrainPosHprInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0), *param5_this, *param6_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_CConstrainPosHprInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CConstrainPosHprInterval) {
    printf("CConstrainPosHprInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CConstrainPosHprInterval *local_this = (CConstrainPosHprInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CConstrainPosHprInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CConstraintInterval) {
    return (CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CConstrainPosHprInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CConstrainPosHprInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CConstraintInterval) {
    CConstraintInterval* other_this = (CConstraintInterval*)from_this;
    return (CConstrainPosHprInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (CConstrainPosHprInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CConstrainPosHprInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CConstrainPosHprInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CConstrainPosHprInterval*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CConstrainPosInterval
 */
/**
 * Python function wrapper for:
 * inline NodePath const &CConstrainPosInterval::get_node(void) const
 */
static PyObject *Dtool_CConstrainPosInterval_get_node_106(PyObject *self, PyObject *) {
  CConstrainPosInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConstrainPosInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath const &CConstrainPosInterval::get_node(void) const
  NodePath const *return_value = &((*(const CConstrainPosInterval*)local_this).get_node());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainPosInterval_get_node_106_comment =
  "C++ Interface:\n"
  "get_node(CConstrainPosInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the \"source\" node.\n"
  " */";
#else
static const char *Dtool_CConstrainPosInterval_get_node_106_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &CConstrainPosInterval::get_target(void) const
 */
static PyObject *Dtool_CConstrainPosInterval_get_target_107(PyObject *self, PyObject *) {
  CConstrainPosInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConstrainPosInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath const &CConstrainPosInterval::get_target(void) const
  NodePath const *return_value = &((*(const CConstrainPosInterval*)local_this).get_target());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainPosInterval_get_target_107_comment =
  "C++ Interface:\n"
  "get_target(CConstrainPosInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the \"target\" node.\n"
  " */";
#else
static const char *Dtool_CConstrainPosInterval_get_target_107_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CConstrainPosInterval::get_class_type(void)
 */
static PyObject *Dtool_CConstrainPosInterval_get_class_type_108(PyObject *, PyObject *) {
  // 1-static TypeHandle CConstrainPosInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CConstrainPosInterval::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainPosInterval_get_class_type_108_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CConstrainPosInterval_get_class_type_108_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CConstrainPosInterval::CConstrainPosInterval(CConstrainPosInterval const &) = default
 * CConstrainPosInterval::CConstrainPosInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset = LVector3::zero())
 */
static int Dtool_Init_CConstrainPosInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline CConstrainPosInterval::CConstrainPosInterval(CConstrainPosInterval const &) = default
      CPT(CConstrainPosInterval) arg_this;
      if (!Dtool_ConstCoerce_CConstrainPosInterval(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "CConstrainPosInterval.CConstrainPosInterval", "CConstrainPosInterval");
        return -1;
      }
      CConstrainPosInterval *return_value = new CConstrainPosInterval(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainPosInterval, true, false);
    }
    break;
  case 5:
    {
      // 1-CConstrainPosInterval::CConstrainPosInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      double param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      static const char *keyword_list[] = {"name", "duration", "node", "target", "wrt", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#dOOO:CConstrainPosInterval", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "CConstrainPosInterval.CConstrainPosInterval", true, true);
        NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "CConstrainPosInterval.CConstrainPosInterval", true, true);
        if (param2_this != NULL && param3_this != NULL) {
          CConstrainPosInterval *return_value = new CConstrainPosInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainPosInterval, true, false);
        }
      }
    }
    break;
  case 6:
    {
      // 1-CConstrainPosInterval::CConstrainPosInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      double param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      PyObject *param5;
      static const char *keyword_list[] = {"name", "duration", "node", "target", "wrt", "posOffset", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#dOOOO:CConstrainPosInterval", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5)) {
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "CConstrainPosInterval.CConstrainPosInterval", true, true);
        NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "CConstrainPosInterval.CConstrainPosInterval", true, true);
        LVecBase3f param5_local;
        LVecBase3 const *param5_this = Dtool_Coerce_LVecBase3f(param5, param5_local);
        if (!(param5_this != NULL)) {
          Dtool_Raise_ArgTypeError(param5, 5, "CConstrainPosInterval.CConstrainPosInterval", "LVecBase3f");
          return -1;
        }
        if (param2_this != NULL && param3_this != NULL) {
          CConstrainPosInterval *return_value = new CConstrainPosInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0), *param5_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainPosInterval, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CConstrainPosInterval() takes 1, 5 or 6 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CConstrainPosInterval(const CConstrainPosInterval param0)\n"
      "CConstrainPosInterval(str name, double duration, const NodePath node, const NodePath target, bool wrt)\n"
      "CConstrainPosInterval(str name, double duration, const NodePath node, const NodePath target, bool wrt, LVecBase3f posOffset)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CConstrainPosInterval(PyObject *args, CPT(CConstrainPosInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CConstrainPosInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 5: {
        // 1-CConstrainPosInterval::CConstrainPosInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        double param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        if (PyArg_ParseTuple(args, "s#dOOO:CConstrainPosInterval", &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
          NodePath const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_NodePath, (void **)&param2_this);
          NodePath const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_NodePath, (void **)&param3_this);
          if (param2_this != NULL && param3_this != NULL) {
            CConstrainPosInterval *return_value = new CConstrainPosInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 6: {
        // 1-CConstrainPosInterval::CConstrainPosInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        double param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        PyObject *param5;
        if (PyArg_ParseTuple(args, "s#dOOOO:CConstrainPosInterval", &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5)) {
          NodePath const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_NodePath, (void **)&param2_this);
          NodePath const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_NodePath, (void **)&param3_this);
          LVecBase3 const *param5_this;
          DTOOL_Call_ExtractThisPointerForType(param5, Dtool_Ptr_LVecBase3f, (void **)&param5_this);
          if (param2_this != NULL && param3_this != NULL && param5_this != NULL) {
            CConstrainPosInterval *return_value = new CConstrainPosInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0), *param5_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_CConstrainPosInterval(PyObject *args, PT(CConstrainPosInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CConstrainPosInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 5: {
        // 1-CConstrainPosInterval::CConstrainPosInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        double param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        if (PyArg_ParseTuple(args, "s#dOOO:CConstrainPosInterval", &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
          NodePath const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_NodePath, (void **)&param2_this);
          NodePath const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_NodePath, (void **)&param3_this);
          if (param2_this != NULL && param3_this != NULL) {
            CConstrainPosInterval *return_value = new CConstrainPosInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 6: {
        // 1-CConstrainPosInterval::CConstrainPosInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        double param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        PyObject *param5;
        if (PyArg_ParseTuple(args, "s#dOOOO:CConstrainPosInterval", &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5)) {
          NodePath const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_NodePath, (void **)&param2_this);
          NodePath const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_NodePath, (void **)&param3_this);
          LVecBase3 const *param5_this;
          DTOOL_Call_ExtractThisPointerForType(param5, Dtool_Ptr_LVecBase3f, (void **)&param5_this);
          if (param2_this != NULL && param3_this != NULL && param5_this != NULL) {
            CConstrainPosInterval *return_value = new CConstrainPosInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0), *param5_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_CConstrainPosInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CConstrainPosInterval) {
    printf("CConstrainPosInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CConstrainPosInterval *local_this = (CConstrainPosInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CConstrainPosInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CConstraintInterval) {
    return (CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CConstrainPosInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CConstrainPosInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CConstraintInterval) {
    CConstraintInterval* other_this = (CConstraintInterval*)from_this;
    return (CConstrainPosInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (CConstrainPosInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CConstrainPosInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CConstrainPosInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CConstrainPosInterval*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CConstrainTransformInterval
 */
/**
 * Python function wrapper for:
 * inline NodePath const &CConstrainTransformInterval::get_node(void) const
 */
static PyObject *Dtool_CConstrainTransformInterval_get_node_112(PyObject *self, PyObject *) {
  CConstrainTransformInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConstrainTransformInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath const &CConstrainTransformInterval::get_node(void) const
  NodePath const *return_value = &((*(const CConstrainTransformInterval*)local_this).get_node());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainTransformInterval_get_node_112_comment =
  "C++ Interface:\n"
  "get_node(CConstrainTransformInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the \"source\" node.\n"
  " */";
#else
static const char *Dtool_CConstrainTransformInterval_get_node_112_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &CConstrainTransformInterval::get_target(void) const
 */
static PyObject *Dtool_CConstrainTransformInterval_get_target_113(PyObject *self, PyObject *) {
  CConstrainTransformInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConstrainTransformInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath const &CConstrainTransformInterval::get_target(void) const
  NodePath const *return_value = &((*(const CConstrainTransformInterval*)local_this).get_target());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainTransformInterval_get_target_113_comment =
  "C++ Interface:\n"
  "get_target(CConstrainTransformInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the \"target\" node.\n"
  " */";
#else
static const char *Dtool_CConstrainTransformInterval_get_target_113_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CConstrainTransformInterval::get_class_type(void)
 */
static PyObject *Dtool_CConstrainTransformInterval_get_class_type_114(PyObject *, PyObject *) {
  // 1-static TypeHandle CConstrainTransformInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CConstrainTransformInterval::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainTransformInterval_get_class_type_114_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CConstrainTransformInterval_get_class_type_114_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CConstrainTransformInterval::CConstrainTransformInterval(CConstrainTransformInterval const &) = default
 * CConstrainTransformInterval::CConstrainTransformInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt)
 */
static int Dtool_Init_CConstrainTransformInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline CConstrainTransformInterval::CConstrainTransformInterval(CConstrainTransformInterval const &) = default
      CPT(CConstrainTransformInterval) arg_this;
      if (!Dtool_ConstCoerce_CConstrainTransformInterval(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "CConstrainTransformInterval.CConstrainTransformInterval", "CConstrainTransformInterval");
        return -1;
      }
      CConstrainTransformInterval *return_value = new CConstrainTransformInterval(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainTransformInterval, true, false);
    }
    break;
  case 5:
    {
      // 1-CConstrainTransformInterval::CConstrainTransformInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      double param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      static const char *keyword_list[] = {"name", "duration", "node", "target", "wrt", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#dOOO:CConstrainTransformInterval", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "CConstrainTransformInterval.CConstrainTransformInterval", true, true);
        NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "CConstrainTransformInterval.CConstrainTransformInterval", true, true);
        if (param2_this != NULL && param3_this != NULL) {
          CConstrainTransformInterval *return_value = new CConstrainTransformInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainTransformInterval, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CConstrainTransformInterval() takes 1 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CConstrainTransformInterval(const CConstrainTransformInterval param0)\n"
      "CConstrainTransformInterval(str name, double duration, const NodePath node, const NodePath target, bool wrt)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CConstrainTransformInterval(PyObject *args, CPT(CConstrainTransformInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CConstrainTransformInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 5) {
      // 1-CConstrainTransformInterval::CConstrainTransformInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      double param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      if (PyArg_ParseTuple(args, "s#dOOO:CConstrainTransformInterval", &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
        NodePath const *param2_this;
        DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_NodePath, (void **)&param2_this);
        NodePath const *param3_this;
        DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_NodePath, (void **)&param3_this);
        if (param2_this != NULL && param3_this != NULL) {
          CConstrainTransformInterval *return_value = new CConstrainTransformInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_CConstrainTransformInterval(PyObject *args, PT(CConstrainTransformInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CConstrainTransformInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 5) {
      // 1-CConstrainTransformInterval::CConstrainTransformInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      double param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      if (PyArg_ParseTuple(args, "s#dOOO:CConstrainTransformInterval", &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
        NodePath const *param2_this;
        DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_NodePath, (void **)&param2_this);
        NodePath const *param3_this;
        DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_NodePath, (void **)&param3_this);
        if (param2_this != NULL && param3_this != NULL) {
          CConstrainTransformInterval *return_value = new CConstrainTransformInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_CConstrainTransformInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CConstrainTransformInterval) {
    printf("CConstrainTransformInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CConstrainTransformInterval *local_this = (CConstrainTransformInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CConstrainTransformInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CConstraintInterval) {
    return (CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CConstrainTransformInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CConstrainTransformInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CConstraintInterval) {
    CConstraintInterval* other_this = (CConstraintInterval*)from_this;
    return (CConstrainTransformInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (CConstrainTransformInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CConstrainTransformInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CConstrainTransformInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CConstrainTransformInterval*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CLerpInterval
 */
/**
 * Python function wrapper for:
 * inline CLerpInterval::BlendType CLerpInterval::get_blend_type(void) const
 */
static PyObject *Dtool_CLerpInterval_get_blend_type_118(PyObject *self, PyObject *) {
  CLerpInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CLerpInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CLerpInterval::BlendType CLerpInterval::get_blend_type(void) const
  CLerpInterval::BlendType return_value = (*(const CLerpInterval*)local_this).get_blend_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CLerpInterval_get_blend_type_118_comment =
  "C++ Interface:\n"
  "get_blend_type(CLerpInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the blend type specified for the interval.  This controls how the\n"
  " * linear interpolation behaves near the beginning and end of the lerp period.\n"
  " */";
#else
static const char *Dtool_CLerpInterval_get_blend_type_118_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static CLerpInterval::BlendType CLerpInterval::string_blend_type(std::string const &blend_type)
 */
static PyObject *Dtool_CLerpInterval_string_blend_type_119(PyObject *, PyObject *arg) {
  // 1-static CLerpInterval::BlendType CLerpInterval::string_blend_type(std::string const &blend_type)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    CLerpInterval::BlendType return_value = CLerpInterval::string_blend_type(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_blend_type(str blend_type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpInterval_string_blend_type_119_comment =
  "C++ Interface:\n"
  "string_blend_type(str blend_type)\n"
  "\n"
  "/**\n"
  " * Returns the BlendType enumerated value corresponding to the indicated\n"
  " * string, or BT_invalid if the string doesn't match anything.\n"
  " */";
#else
static const char *Dtool_CLerpInterval_string_blend_type_119_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CLerpInterval::get_class_type(void)
 */
static PyObject *Dtool_CLerpInterval_get_class_type_120(PyObject *, PyObject *) {
  // 1-static TypeHandle CLerpInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CLerpInterval::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CLerpInterval_get_class_type_120_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CLerpInterval_get_class_type_120_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CLerpInterval::CLerpInterval(CLerpInterval const &) = default
 */
static int Dtool_Init_CLerpInterval(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CLerpInterval() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline CLerpInterval::CLerpInterval(CLerpInterval const &) = default
  CLerpInterval const *arg_this = (CLerpInterval *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CLerpInterval, 0, "CLerpInterval.CLerpInterval", true, true);
  if (arg_this != NULL) {
    CLerpInterval *return_value = new CLerpInterval(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CLerpInterval, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CLerpInterval(const CLerpInterval param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CLerpInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CLerpInterval) {
    printf("CLerpInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CLerpInterval *local_this = (CLerpInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CLerpInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CLerpInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CLerpInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (CLerpInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CLerpInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CLerpInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CLerpInterval*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CLerpAnimEffectInterval
 */
/**
 * Python function wrapper for:
 * inline void CLerpAnimEffectInterval::add_control(AnimControl *control, std::string const &name, float begin_effect, float end_effect)
 */
static PyObject *Dtool_CLerpAnimEffectInterval_add_control_125(PyObject *self, PyObject *args, PyObject *kwds) {
  CLerpAnimEffectInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpAnimEffectInterval, (void **)&local_this, "CLerpAnimEffectInterval.add_control")) {
    return NULL;
  }
  // 1-inline void CLerpAnimEffectInterval::add_control(AnimControl *control, std::string const &name, float begin_effect, float end_effect)
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  float param3;
  float param4;
  static const char *keyword_list[] = {"control", "name", "begin_effect", "end_effect", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#ff:add_control", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3, &param4)) {
    AnimControl *param1_this = (AnimControl *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_AnimControl, 1, "CLerpAnimEffectInterval.add_control", false, true);
    if (param1_this != NULL) {
      (*local_this).add_control(param1_this, std::string(param2_str, param2_len), (float)param3, (float)param4);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_control(const CLerpAnimEffectInterval self, AnimControl control, str name, float begin_effect, float end_effect)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpAnimEffectInterval_add_control_125_comment =
  "C++ Interface:\n"
  "add_control(const CLerpAnimEffectInterval self, AnimControl control, str name, float begin_effect, float end_effect)\n"
  "\n"
  "/**\n"
  " * Adds another AnimControl to the list of AnimControls affected by the lerp.\n"
  " * This control will be lerped from begin_effect to end_effect over the period\n"
  " * of the lerp.\n"
  " *\n"
  " * The AnimControl name parameter is only used when formatting the interval\n"
  " * for output.\n"
  " */";
#else
static const char *Dtool_CLerpAnimEffectInterval_add_control_125_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CLerpAnimEffectInterval::get_class_type(void)
 */
static PyObject *Dtool_CLerpAnimEffectInterval_get_class_type_126(PyObject *, PyObject *) {
  // 1-static TypeHandle CLerpAnimEffectInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CLerpAnimEffectInterval::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CLerpAnimEffectInterval_get_class_type_126_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CLerpAnimEffectInterval_get_class_type_126_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CLerpAnimEffectInterval::CLerpAnimEffectInterval(CLerpAnimEffectInterval const &) = default
 * inline CLerpAnimEffectInterval::CLerpAnimEffectInterval(std::string const &name, double duration, CLerpInterval::BlendType blend_type)
 */
static int Dtool_Init_CLerpAnimEffectInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline CLerpAnimEffectInterval::CLerpAnimEffectInterval(CLerpAnimEffectInterval const &) = default
      CPT(CLerpAnimEffectInterval) arg_this;
      if (!Dtool_ConstCoerce_CLerpAnimEffectInterval(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "CLerpAnimEffectInterval.CLerpAnimEffectInterval", "CLerpAnimEffectInterval");
        return -1;
      }
      CLerpAnimEffectInterval *return_value = new CLerpAnimEffectInterval(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CLerpAnimEffectInterval, true, false);
    }
    break;
  case 3:
    {
      // 1-inline CLerpAnimEffectInterval::CLerpAnimEffectInterval(std::string const &name, double duration, CLerpInterval::BlendType blend_type)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      double param1;
      int param2;
      static const char *keyword_list[] = {"name", "duration", "blend_type", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#di:CLerpAnimEffectInterval", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2)) {
        CLerpAnimEffectInterval *return_value = new CLerpAnimEffectInterval(std::string(param0_str, param0_len), (double)param1, (CLerpInterval::BlendType)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CLerpAnimEffectInterval, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CLerpAnimEffectInterval() takes 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CLerpAnimEffectInterval(const CLerpAnimEffectInterval param0)\n"
      "CLerpAnimEffectInterval(str name, double duration, int blend_type)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CLerpAnimEffectInterval(PyObject *args, CPT(CLerpAnimEffectInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CLerpAnimEffectInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline CLerpAnimEffectInterval::CLerpAnimEffectInterval(std::string const &name, double duration, CLerpInterval::BlendType blend_type)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      double param1;
      int param2;
      if (PyArg_ParseTuple(args, "s#di:CLerpAnimEffectInterval", &param0_str, &param0_len, &param1, &param2)) {
        CLerpAnimEffectInterval *return_value = new CLerpAnimEffectInterval(std::string(param0_str, param0_len), (double)param1, (CLerpInterval::BlendType)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_CLerpAnimEffectInterval(PyObject *args, PT(CLerpAnimEffectInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CLerpAnimEffectInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline CLerpAnimEffectInterval::CLerpAnimEffectInterval(std::string const &name, double duration, CLerpInterval::BlendType blend_type)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      double param1;
      int param2;
      if (PyArg_ParseTuple(args, "s#di:CLerpAnimEffectInterval", &param0_str, &param0_len, &param1, &param2)) {
        CLerpAnimEffectInterval *return_value = new CLerpAnimEffectInterval(std::string(param0_str, param0_len), (double)param1, (CLerpInterval::BlendType)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_CLerpAnimEffectInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CLerpAnimEffectInterval) {
    printf("CLerpAnimEffectInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CLerpAnimEffectInterval *local_this = (CLerpAnimEffectInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CLerpAnimEffectInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *)(CLerpInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_CLerpInterval) {
    return (CLerpInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *)(CLerpInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *)(CLerpInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *)(CLerpInterval *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CLerpAnimEffectInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CLerpAnimEffectInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (CLerpAnimEffectInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_CLerpInterval) {
    CLerpInterval* other_this = (CLerpInterval*)from_this;
    return (CLerpAnimEffectInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CLerpAnimEffectInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CLerpAnimEffectInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CLerpAnimEffectInterval*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CLerpNodePathInterval
 */
/**
 * Python function wrapper for:
 * inline NodePath const &CLerpNodePathInterval::get_node(void) const
 */
static PyObject *Dtool_CLerpNodePathInterval_get_node_130(PyObject *self, PyObject *) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CLerpNodePathInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath const &CLerpNodePathInterval::get_node(void) const
  NodePath const *return_value = &((*(const CLerpNodePathInterval*)local_this).get_node());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_get_node_130_comment =
  "C++ Interface:\n"
  "get_node(CLerpNodePathInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the node being lerped.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_get_node_130_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &CLerpNodePathInterval::get_other(void) const
 */
static PyObject *Dtool_CLerpNodePathInterval_get_other_131(PyObject *self, PyObject *) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CLerpNodePathInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath const &CLerpNodePathInterval::get_other(void) const
  NodePath const *return_value = &((*(const CLerpNodePathInterval*)local_this).get_other());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_get_other_131_comment =
  "C++ Interface:\n"
  "get_other(CLerpNodePathInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the \"other\" node, which the lerped node is being moved relative to.\n"
  " * If this is an empty node path, the lerped node is being moved in its own\n"
  " * coordinate system.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_get_other_131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_pos(LVecBase3 const &pos)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_pos_132(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_pos")) {
    return NULL;
  }
  // 1-inline void CLerpNodePathInterval::set_start_pos(LVecBase3 const &pos)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_start_pos", "LVecBase3f");
  }
  (*local_this).set_start_pos(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_pos(const CLerpNodePathInterval self, const LVecBase3f pos)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_pos_132_comment =
  "C++ Interface:\n"
  "set_start_pos(const CLerpNodePathInterval self, const LVecBase3f pos)\n"
  "\n"
  "/**\n"
  " * Indicates the initial position of the lerped node.  This is meaningful only\n"
  " * if set_end_pos() is also called.  This parameter is optional; if\n"
  " * unspecified, the value will be taken from the node's actual position at the\n"
  " * time the lerp is performed.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_pos_132_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_pos(LVecBase3 const &pos)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_pos_133(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_pos")) {
    return NULL;
  }
  // 1-inline void CLerpNodePathInterval::set_end_pos(LVecBase3 const &pos)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_end_pos", "LVecBase3f");
  }
  (*local_this).set_end_pos(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_pos(const CLerpNodePathInterval self, const LVecBase3f pos)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_pos_133_comment =
  "C++ Interface:\n"
  "set_end_pos(const CLerpNodePathInterval self, const LVecBase3f pos)\n"
  "\n"
  "/**\n"
  " * Indicates that the position of the node should be lerped, and specifies the\n"
  " * final position of the node.  This should be called before\n"
  " * priv_initialize().  If this is not called, the node's position will not be\n"
  " * affected by the lerp.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_pos_133_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_hpr(LVecBase3 const &hpr)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_hpr_134(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_hpr")) {
    return NULL;
  }
  // 1-inline void CLerpNodePathInterval::set_start_hpr(LVecBase3 const &hpr)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_start_hpr", "LVecBase3f");
  }
  (*local_this).set_start_hpr(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_hpr(const CLerpNodePathInterval self, const LVecBase3f hpr)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_hpr_134_comment =
  "C++ Interface:\n"
  "set_start_hpr(const CLerpNodePathInterval self, const LVecBase3f hpr)\n"
  "\n"
  "/**\n"
  " * Indicates the initial rotation of the lerped node.  This is meaningful only\n"
  " * if either set_end_hpr() or set_end_quat() is also called.  This parameter\n"
  " * is optional; if unspecified, the value will be taken from the node's actual\n"
  " * rotation at the time the lerp is performed.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_hpr_134_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_hpr(LQuaternion const &quat)
 * inline void CLerpNodePathInterval::set_end_hpr(LVecBase3 const &hpr)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_hpr_135(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_hpr")) {
    return NULL;
  }
  {
    // -2 inline void CLerpNodePathInterval::set_end_hpr(LQuaternion const &quat)
    LQuaternion const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LQuaternionf, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_end_hpr(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_end_hpr(LVecBase3 const &hpr)
    LVecBase3 const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_end_hpr(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_end_hpr(LQuaternion const &quat)
    LQuaternionf arg_local;
    LQuaternion const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_end_hpr(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_end_hpr(LVecBase3 const &hpr)
    LVecBase3f arg_local;
    LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_end_hpr(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_hpr(const CLerpNodePathInterval self, const LQuaternionf quat)\n"
      "set_end_hpr(const CLerpNodePathInterval self, const LVecBase3f hpr)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_hpr_135_comment =
  "C++ Interface:\n"
  "set_end_hpr(const CLerpNodePathInterval self, const LQuaternionf quat)\n"
  "set_end_hpr(const CLerpNodePathInterval self, const LVecBase3f hpr)\n"
  "\n"
  "/**\n"
  " * Indicates that the rotation of the node should be lerped, and specifies the\n"
  " * final rotation of the node.  This should be called before\n"
  " * priv_initialize().\n"
  " *\n"
  " * This replaces a previous call to set_end_quat().  If neither set_end_hpr()\n"
  " * nor set_end_quat() is called, the node's rotation will not be affected by\n"
  " * the lerp.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Indicates that the rotation of the node should be lerped, and specifies the\n"
  " * final rotation of the node.  This should be called before\n"
  " * priv_initialize().\n"
  " *\n"
  " * This special function is overloaded to accept a quaternion, even though the\n"
  " * function name is set_end_hpr().  The quaternion will be implicitly\n"
  " * converted to a HPR trio, and the lerp will be performed in HPR space,\n"
  " * componentwise.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_hpr_135_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_quat(LQuaternion const &quat)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_quat_136(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_quat")) {
    return NULL;
  }
  // 1-inline void CLerpNodePathInterval::set_start_quat(LQuaternion const &quat)
  LQuaternionf arg_local;
  LQuaternion const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_start_quat", "LQuaternionf");
  }
  (*local_this).set_start_quat(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_quat(const CLerpNodePathInterval self, const LQuaternionf quat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_quat_136_comment =
  "C++ Interface:\n"
  "set_start_quat(const CLerpNodePathInterval self, const LQuaternionf quat)\n"
  "\n"
  "/**\n"
  " * Indicates the initial rotation of the lerped node.  This is meaningful only\n"
  " * if either set_end_quat() or set_end_hpr() is also called.  This parameter\n"
  " * is optional; if unspecified, the value will be taken from the node's actual\n"
  " * rotation at the time the lerp is performed.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_quat_136_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_quat(LQuaternion const &quat)
 * inline void CLerpNodePathInterval::set_end_quat(LVecBase3 const &hpr)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_quat_137(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_quat")) {
    return NULL;
  }
  {
    // -2 inline void CLerpNodePathInterval::set_end_quat(LVecBase3 const &hpr)
    LVecBase3 const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_end_quat(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_end_quat(LQuaternion const &quat)
    LQuaternion const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LQuaternionf, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_end_quat(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_end_quat(LVecBase3 const &hpr)
    LVecBase3f arg_local;
    LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_end_quat(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_end_quat(LQuaternion const &quat)
    LQuaternionf arg_local;
    LQuaternion const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_end_quat(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_quat(const CLerpNodePathInterval self, const LVecBase3f hpr)\n"
      "set_end_quat(const CLerpNodePathInterval self, const LQuaternionf quat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_quat_137_comment =
  "C++ Interface:\n"
  "set_end_quat(const CLerpNodePathInterval self, const LVecBase3f hpr)\n"
  "set_end_quat(const CLerpNodePathInterval self, const LQuaternionf quat)\n"
  "\n"
  "/**\n"
  " * Indicates that the rotation of the node should be lerped, and specifies the\n"
  " * final rotation of the node.  This should be called before\n"
  " * priv_initialize().\n"
  " *\n"
  " * This replaces a previous call to set_end_hpr().  If neither set_end_quat()\n"
  " * nor set_end_hpr() is called, the node's rotation will not be affected by\n"
  " * the lerp.\n"
  " *\n"
  " * This special function is overloaded to accept a HPR trio, even though the\n"
  " * function name is set_end_quat().  The HPR will be implicitly converted to a\n"
  " * quaternion, and the lerp will be performed in quaternion space, as a\n"
  " * spherical lerp.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Indicates that the rotation of the node should be lerped, and specifies the\n"
  " * final rotation of the node.  This should be called before\n"
  " * priv_initialize().\n"
  " *\n"
  " * This replaces a previous call to set_end_hpr().  If neither set_end_quat()\n"
  " * nor set_end_hpr() is called, the node's rotation will not be affected by\n"
  " * the lerp.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_quat_137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_scale(LVecBase3 const &scale)
 * inline void CLerpNodePathInterval::set_start_scale(PN_stdfloat scale)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_scale_138(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_scale")) {
    return NULL;
  }
  {
    // -2 inline void CLerpNodePathInterval::set_start_scale(LVecBase3 const &scale)
    LVecBase3 const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_start_scale(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_start_scale(PN_stdfloat scale)
    if (PyNumber_Check(arg)) {
      (*local_this).set_start_scale((PN_stdfloat)PyFloat_AsDouble(arg));
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_start_scale(LVecBase3 const &scale)
    LVecBase3f arg_local;
    LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_start_scale(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: inline void CLerpNodePathInterval::set_start_scale(PN_stdfloat scale)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_scale(const CLerpNodePathInterval self, const LVecBase3f scale)\n"
      "set_start_scale(const CLerpNodePathInterval self, float scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_scale_138_comment =
  "C++ Interface:\n"
  "set_start_scale(const CLerpNodePathInterval self, const LVecBase3f scale)\n"
  "set_start_scale(const CLerpNodePathInterval self, float scale)\n"
  "\n"
  "/**\n"
  " * Indicates the initial scale of the lerped node.  This is meaningful only if\n"
  " * set_end_scale() is also called.  This parameter is optional; if\n"
  " * unspecified, the value will be taken from the node's actual scale at the\n"
  " * time the lerp is performed.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Indicates the initial scale of the lerped node.  This is meaningful only if\n"
  " * set_end_scale() is also called.  This parameter is optional; if\n"
  " * unspecified, the value will be taken from the node's actual scale at the\n"
  " * time the lerp is performed.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_scale_138_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_scale(LVecBase3 const &scale)
 * inline void CLerpNodePathInterval::set_end_scale(PN_stdfloat scale)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_scale_139(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_scale")) {
    return NULL;
  }
  {
    // -2 inline void CLerpNodePathInterval::set_end_scale(LVecBase3 const &scale)
    LVecBase3 const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_end_scale(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_end_scale(PN_stdfloat scale)
    if (PyNumber_Check(arg)) {
      (*local_this).set_end_scale((PN_stdfloat)PyFloat_AsDouble(arg));
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_end_scale(LVecBase3 const &scale)
    LVecBase3f arg_local;
    LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_end_scale(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: inline void CLerpNodePathInterval::set_end_scale(PN_stdfloat scale)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_scale(const CLerpNodePathInterval self, const LVecBase3f scale)\n"
      "set_end_scale(const CLerpNodePathInterval self, float scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_scale_139_comment =
  "C++ Interface:\n"
  "set_end_scale(const CLerpNodePathInterval self, const LVecBase3f scale)\n"
  "set_end_scale(const CLerpNodePathInterval self, float scale)\n"
  "\n"
  "/**\n"
  " * Indicates that the scale of the node should be lerped, and specifies the\n"
  " * final scale of the node.  This should be called before priv_initialize().\n"
  " * If this is not called, the node's scale will not be affected by the lerp.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Indicates that the scale of the node should be lerped, and specifies the\n"
  " * final scale of the node.  This should be called before priv_initialize().\n"
  " * If this is not called, the node's scale will not be affected by the lerp.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_scale_139_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_shear(LVecBase3 const &shear)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_shear_140(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_shear")) {
    return NULL;
  }
  // 1-inline void CLerpNodePathInterval::set_start_shear(LVecBase3 const &shear)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_start_shear", "LVecBase3f");
  }
  (*local_this).set_start_shear(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_shear(const CLerpNodePathInterval self, const LVecBase3f shear)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_shear_140_comment =
  "C++ Interface:\n"
  "set_start_shear(const CLerpNodePathInterval self, const LVecBase3f shear)\n"
  "\n"
  "/**\n"
  " * Indicates the initial shear of the lerped node.  This is meaningful only if\n"
  " * set_end_shear() is also called.  This parameter is optional; if\n"
  " * unspecified, the value will be taken from the node's actual shear at the\n"
  " * time the lerp is performed.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_shear_140_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_shear(LVecBase3 const &shear)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_shear_141(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_shear")) {
    return NULL;
  }
  // 1-inline void CLerpNodePathInterval::set_end_shear(LVecBase3 const &shear)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_end_shear", "LVecBase3f");
  }
  (*local_this).set_end_shear(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_shear(const CLerpNodePathInterval self, const LVecBase3f shear)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_shear_141_comment =
  "C++ Interface:\n"
  "set_end_shear(const CLerpNodePathInterval self, const LVecBase3f shear)\n"
  "\n"
  "/**\n"
  " * Indicates that the shear of the node should be lerped, and specifies the\n"
  " * final shear of the node.  This should be called before priv_initialize().\n"
  " * If this is not called, the node's shear will not be affected by the lerp.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_shear_141_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_color(LVecBase4 const &color)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_color_142(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_color")) {
    return NULL;
  }
  // 1-inline void CLerpNodePathInterval::set_start_color(LVecBase4 const &color)
  LVecBase4f arg_local;
  LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_start_color", "LVecBase4f");
  }
  (*local_this).set_start_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_color(const CLerpNodePathInterval self, const LVecBase4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_color_142_comment =
  "C++ Interface:\n"
  "set_start_color(const CLerpNodePathInterval self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Indicates the initial color of the lerped node.  This is meaningful only if\n"
  " * set_end_color() is also called.  This parameter is optional; if\n"
  " * unspecified, the value will be taken from the node's actual color at the\n"
  " * time the lerp is performed.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_color_142_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_color(LVecBase4 const &color)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_color_143(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_color")) {
    return NULL;
  }
  // 1-inline void CLerpNodePathInterval::set_end_color(LVecBase4 const &color)
  LVecBase4f arg_local;
  LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_end_color", "LVecBase4f");
  }
  (*local_this).set_end_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_color(const CLerpNodePathInterval self, const LVecBase4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_color_143_comment =
  "C++ Interface:\n"
  "set_end_color(const CLerpNodePathInterval self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Indicates that the color of the node should be lerped, and specifies the\n"
  " * final color of the node.  This should be called before priv_initialize().\n"
  " * If this is not called, the node's color will not be affected by the lerp.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_color_143_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_color_scale(LVecBase4 const &color_scale)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_color_scale_144(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_color_scale")) {
    return NULL;
  }
  // 1-inline void CLerpNodePathInterval::set_start_color_scale(LVecBase4 const &color_scale)
  LVecBase4f arg_local;
  LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_start_color_scale", "LVecBase4f");
  }
  (*local_this).set_start_color_scale(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_color_scale(const CLerpNodePathInterval self, const LVecBase4f color_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_color_scale_144_comment =
  "C++ Interface:\n"
  "set_start_color_scale(const CLerpNodePathInterval self, const LVecBase4f color_scale)\n"
  "\n"
  "/**\n"
  " * Indicates the initial color scale of the lerped node.  This is meaningful\n"
  " * only if set_end_color_scale() is also called.  This parameter is optional;\n"
  " * if unspecified, the value will be taken from the node's actual color scale\n"
  " * at the time the lerp is performed.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_color_scale_144_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_color_scale(LVecBase4 const &color_scale)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_color_scale_145(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_color_scale")) {
    return NULL;
  }
  // 1-inline void CLerpNodePathInterval::set_end_color_scale(LVecBase4 const &color_scale)
  LVecBase4f arg_local;
  LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_end_color_scale", "LVecBase4f");
  }
  (*local_this).set_end_color_scale(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_color_scale(const CLerpNodePathInterval self, const LVecBase4f color_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_color_scale_145_comment =
  "C++ Interface:\n"
  "set_end_color_scale(const CLerpNodePathInterval self, const LVecBase4f color_scale)\n"
  "\n"
  "/**\n"
  " * Indicates that the color scale of the node should be lerped, and specifies\n"
  " * the final color scale of the node.  This should be called before\n"
  " * priv_initialize().  If this is not called, the node's color scale will not\n"
  " * be affected by the lerp.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_color_scale_145_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_texture_stage(TextureStage *stage)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_texture_stage_146(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_texture_stage")) {
    return NULL;
  }
  // 1-inline void CLerpNodePathInterval::set_texture_stage(TextureStage *stage)
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "CLerpNodePathInterval.set_texture_stage", false, true);
  if (arg_this != NULL) {
    (*local_this).set_texture_stage(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture_stage(const CLerpNodePathInterval self, TextureStage stage)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_texture_stage_146_comment =
  "C++ Interface:\n"
  "set_texture_stage(const CLerpNodePathInterval self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Indicates the texture stage that is adjusted by tex_offset, tex_rotate,\n"
  " * and/or tex_scale.  If this is not set, the default is the default texture\n"
  " * stage.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_texture_stage_146_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_tex_offset(LVecBase2 const &tex_offset)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_tex_offset_147(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_tex_offset")) {
    return NULL;
  }
  // 1-inline void CLerpNodePathInterval::set_start_tex_offset(LVecBase2 const &tex_offset)
  LVecBase2f arg_local;
  LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_start_tex_offset", "LVecBase2f");
  }
  (*local_this).set_start_tex_offset(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_tex_offset(const CLerpNodePathInterval self, const LVecBase2f tex_offset)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_tex_offset_147_comment =
  "C++ Interface:\n"
  "set_start_tex_offset(const CLerpNodePathInterval self, const LVecBase2f tex_offset)\n"
  "\n"
  "/**\n"
  " * Indicates the initial UV offset of the lerped node.  This is meaningful\n"
  " * only if set_end_tex_offset() is also called.  This parameter is optional;\n"
  " * if unspecified, the value will be taken from the node's actual UV offset at\n"
  " * the time the lerp is performed.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_tex_offset_147_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_tex_offset(LVecBase2 const &tex_offset)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_tex_offset_148(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_tex_offset")) {
    return NULL;
  }
  // 1-inline void CLerpNodePathInterval::set_end_tex_offset(LVecBase2 const &tex_offset)
  LVecBase2f arg_local;
  LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_end_tex_offset", "LVecBase2f");
  }
  (*local_this).set_end_tex_offset(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_tex_offset(const CLerpNodePathInterval self, const LVecBase2f tex_offset)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_tex_offset_148_comment =
  "C++ Interface:\n"
  "set_end_tex_offset(const CLerpNodePathInterval self, const LVecBase2f tex_offset)\n"
  "\n"
  "/**\n"
  " * Indicates that the UV offset of the node should be lerped, and specifies\n"
  " * the final UV offset of the node.  This should be called before\n"
  " * priv_initialize().  If this is not called, the node's UV offset will not be\n"
  " * affected by the lerp.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_tex_offset_148_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_tex_rotate(PN_stdfloat tex_rotate)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_tex_rotate_149(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_tex_rotate")) {
    return NULL;
  }
  // 1-inline void CLerpNodePathInterval::set_start_tex_rotate(PN_stdfloat tex_rotate)
  if (PyNumber_Check(arg)) {
    (*local_this).set_start_tex_rotate((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_tex_rotate(const CLerpNodePathInterval self, float tex_rotate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_tex_rotate_149_comment =
  "C++ Interface:\n"
  "set_start_tex_rotate(const CLerpNodePathInterval self, float tex_rotate)\n"
  "\n"
  "/**\n"
  " * Indicates the initial UV rotate of the lerped node.  This is meaningful\n"
  " * only if set_end_tex_rotate() is also called.  This parameter is optional;\n"
  " * if unspecified, the value will be taken from the node's actual UV rotate at\n"
  " * the time the lerp is performed.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_tex_rotate_149_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_tex_rotate(PN_stdfloat tex_rotate)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_tex_rotate_150(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_tex_rotate")) {
    return NULL;
  }
  // 1-inline void CLerpNodePathInterval::set_end_tex_rotate(PN_stdfloat tex_rotate)
  if (PyNumber_Check(arg)) {
    (*local_this).set_end_tex_rotate((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_tex_rotate(const CLerpNodePathInterval self, float tex_rotate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_tex_rotate_150_comment =
  "C++ Interface:\n"
  "set_end_tex_rotate(const CLerpNodePathInterval self, float tex_rotate)\n"
  "\n"
  "/**\n"
  " * Indicates that the UV rotate of the node should be lerped, and specifies\n"
  " * the final UV rotate of the node.  This should be called before\n"
  " * priv_initialize().  If this is not called, the node's UV rotate will not be\n"
  " * affected by the lerp.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_tex_rotate_150_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_tex_scale(LVecBase2 const &tex_scale)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_tex_scale_151(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_tex_scale")) {
    return NULL;
  }
  // 1-inline void CLerpNodePathInterval::set_start_tex_scale(LVecBase2 const &tex_scale)
  LVecBase2f arg_local;
  LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_start_tex_scale", "LVecBase2f");
  }
  (*local_this).set_start_tex_scale(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_tex_scale(const CLerpNodePathInterval self, const LVecBase2f tex_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_tex_scale_151_comment =
  "C++ Interface:\n"
  "set_start_tex_scale(const CLerpNodePathInterval self, const LVecBase2f tex_scale)\n"
  "\n"
  "/**\n"
  " * Indicates the initial UV scale of the lerped node.  This is meaningful only\n"
  " * if set_end_tex_scale() is also called.  This parameter is optional; if\n"
  " * unspecified, the value will be taken from the node's actual UV scale at the\n"
  " * time the lerp is performed.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_tex_scale_151_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_tex_scale(LVecBase2 const &tex_scale)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_tex_scale_152(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_tex_scale")) {
    return NULL;
  }
  // 1-inline void CLerpNodePathInterval::set_end_tex_scale(LVecBase2 const &tex_scale)
  LVecBase2f arg_local;
  LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_end_tex_scale", "LVecBase2f");
  }
  (*local_this).set_end_tex_scale(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_tex_scale(const CLerpNodePathInterval self, const LVecBase2f tex_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_tex_scale_152_comment =
  "C++ Interface:\n"
  "set_end_tex_scale(const CLerpNodePathInterval self, const LVecBase2f tex_scale)\n"
  "\n"
  "/**\n"
  " * Indicates that the UV scale of the node should be lerped, and specifies the\n"
  " * final UV scale of the node.  This should be called before\n"
  " * priv_initialize().  If this is not called, the node's UV scale will not be\n"
  " * affected by the lerp.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_tex_scale_152_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_override(int override)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_override_153(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_override")) {
    return NULL;
  }
  // 1-inline void CLerpNodePathInterval::set_override(int override)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_override((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_override(const CLerpNodePathInterval self, int override)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_override_153_comment =
  "C++ Interface:\n"
  "set_override(const CLerpNodePathInterval self, int override)\n"
  "\n"
  "/**\n"
  " * Changes the override value that will be associated with any state changes\n"
  " * applied by the lerp.  If this lerp is changing state (for instance, a color\n"
  " * lerp or a tex matrix lerp), then the new attributes created by this lerp\n"
  " * will be assigned the indicated override value when they are applied to the\n"
  " * node.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_override_153_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int CLerpNodePathInterval::get_override(void) const
 */
static PyObject *Dtool_CLerpNodePathInterval_get_override_154(PyObject *self, PyObject *) {
  CLerpNodePathInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CLerpNodePathInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int CLerpNodePathInterval::get_override(void) const
  int return_value = (*(const CLerpNodePathInterval*)local_this).get_override();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_get_override_154_comment =
  "C++ Interface:\n"
  "get_override(CLerpNodePathInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the override value that will be associated with any state changes\n"
  " * applied by the lerp.  See set_override().\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_get_override_154_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CLerpNodePathInterval::get_class_type(void)
 */
static PyObject *Dtool_CLerpNodePathInterval_get_class_type_155(PyObject *, PyObject *) {
  // 1-static TypeHandle CLerpNodePathInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CLerpNodePathInterval::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_get_class_type_155_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CLerpNodePathInterval_get_class_type_155_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CLerpNodePathInterval::CLerpNodePathInterval(CLerpNodePathInterval const &) = default
 * CLerpNodePathInterval::CLerpNodePathInterval(std::string const &name, double duration, CLerpInterval::BlendType blend_type, bool bake_in_start, bool fluid, NodePath const &node, NodePath const &other)
 */
static int Dtool_Init_CLerpNodePathInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline CLerpNodePathInterval::CLerpNodePathInterval(CLerpNodePathInterval const &) = default
      CPT(CLerpNodePathInterval) arg_this;
      if (!Dtool_ConstCoerce_CLerpNodePathInterval(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "CLerpNodePathInterval.CLerpNodePathInterval", "CLerpNodePathInterval");
        return -1;
      }
      CLerpNodePathInterval *return_value = new CLerpNodePathInterval(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CLerpNodePathInterval, true, false);
    }
    break;
  case 7:
    {
      // 1-CLerpNodePathInterval::CLerpNodePathInterval(std::string const &name, double duration, CLerpInterval::BlendType blend_type, bool bake_in_start, bool fluid, NodePath const &node, NodePath const &other)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      double param1;
      int param2;
      PyObject *param3;
      PyObject *param4;
      PyObject *param5;
      PyObject *param6;
      static const char *keyword_list[] = {"name", "duration", "blend_type", "bake_in_start", "fluid", "node", "other", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#diOOOO:CLerpNodePathInterval", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5, &param6)) {
        NodePath const *param5_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param5, Dtool_Ptr_NodePath, 5, "CLerpNodePathInterval.CLerpNodePathInterval", true, true);
        NodePath const *param6_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param6, Dtool_Ptr_NodePath, 6, "CLerpNodePathInterval.CLerpNodePathInterval", true, true);
        if (param5_this != NULL && param6_this != NULL) {
          CLerpNodePathInterval *return_value = new CLerpNodePathInterval(std::string(param0_str, param0_len), (double)param1, (CLerpInterval::BlendType)param2, (PyObject_IsTrue(param3) != 0), (PyObject_IsTrue(param4) != 0), *param5_this, *param6_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CLerpNodePathInterval, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CLerpNodePathInterval() takes 1 or 7 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CLerpNodePathInterval(const CLerpNodePathInterval param0)\n"
      "CLerpNodePathInterval(str name, double duration, int blend_type, bool bake_in_start, bool fluid, const NodePath node, const NodePath other)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CLerpNodePathInterval(PyObject *args, CPT(CLerpNodePathInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CLerpNodePathInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 7) {
      // 1-CLerpNodePathInterval::CLerpNodePathInterval(std::string const &name, double duration, CLerpInterval::BlendType blend_type, bool bake_in_start, bool fluid, NodePath const &node, NodePath const &other)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      double param1;
      int param2;
      PyObject *param3;
      PyObject *param4;
      PyObject *param5;
      PyObject *param6;
      if (PyArg_ParseTuple(args, "s#diOOOO:CLerpNodePathInterval", &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5, &param6)) {
        NodePath const *param5_this;
        DTOOL_Call_ExtractThisPointerForType(param5, Dtool_Ptr_NodePath, (void **)&param5_this);
        NodePath const *param6_this;
        DTOOL_Call_ExtractThisPointerForType(param6, Dtool_Ptr_NodePath, (void **)&param6_this);
        if (param5_this != NULL && param6_this != NULL) {
          CLerpNodePathInterval *return_value = new CLerpNodePathInterval(std::string(param0_str, param0_len), (double)param1, (CLerpInterval::BlendType)param2, (PyObject_IsTrue(param3) != 0), (PyObject_IsTrue(param4) != 0), *param5_this, *param6_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_CLerpNodePathInterval(PyObject *args, PT(CLerpNodePathInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CLerpNodePathInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 7) {
      // 1-CLerpNodePathInterval::CLerpNodePathInterval(std::string const &name, double duration, CLerpInterval::BlendType blend_type, bool bake_in_start, bool fluid, NodePath const &node, NodePath const &other)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      double param1;
      int param2;
      PyObject *param3;
      PyObject *param4;
      PyObject *param5;
      PyObject *param6;
      if (PyArg_ParseTuple(args, "s#diOOOO:CLerpNodePathInterval", &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5, &param6)) {
        NodePath const *param5_this;
        DTOOL_Call_ExtractThisPointerForType(param5, Dtool_Ptr_NodePath, (void **)&param5_this);
        NodePath const *param6_this;
        DTOOL_Call_ExtractThisPointerForType(param6, Dtool_Ptr_NodePath, (void **)&param6_this);
        if (param5_this != NULL && param6_this != NULL) {
          CLerpNodePathInterval *return_value = new CLerpNodePathInterval(std::string(param0_str, param0_len), (double)param1, (CLerpInterval::BlendType)param2, (PyObject_IsTrue(param3) != 0), (PyObject_IsTrue(param4) != 0), *param5_this, *param6_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_CLerpNodePathInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CLerpNodePathInterval) {
    printf("CLerpNodePathInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CLerpNodePathInterval *local_this = (CLerpNodePathInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CLerpNodePathInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *)(CLerpInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_CLerpInterval) {
    return (CLerpInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *)(CLerpInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *)(CLerpInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *)(CLerpInterval *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CLerpNodePathInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CLerpNodePathInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (CLerpNodePathInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_CLerpInterval) {
    CLerpInterval* other_this = (CLerpInterval*)from_this;
    return (CLerpNodePathInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CLerpNodePathInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CLerpNodePathInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CLerpNodePathInterval*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CMetaInterval
 */
/**
 * Python function wrapper for:
 * inline void CMetaInterval::set_precision(double precision)
 */
static PyObject *Dtool_CMetaInterval_set_precision_160(PyObject *self, PyObject *arg) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CMetaInterval, (void **)&local_this, "CMetaInterval.set_precision")) {
    return NULL;
  }
  // 1-inline void CMetaInterval::set_precision(double precision)
  if (PyNumber_Check(arg)) {
    (*local_this).set_precision(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_precision(const CMetaInterval self, double precision)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_set_precision_160_comment =
  "C++ Interface:\n"
  "set_precision(const CMetaInterval self, double precision)\n"
  "\n"
  "/**\n"
  " * Indicates the precision with which time measurements are compared.  For\n"
  " * numerical accuracy, all floating-point time values are converted to integer\n"
  " * values internally by scaling by the precision factor.  The larger the\n"
  " * number given here, the smaller the delta of time that can be\n"
  " * differentiated; the limit is the maximum integer that can be represented in\n"
  " * the system.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_set_precision_160_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double CMetaInterval::get_precision(void) const
 */
static PyObject *Dtool_CMetaInterval_get_precision_161(PyObject *self, PyObject *) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CMetaInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double CMetaInterval::get_precision(void) const
  double return_value = (*(const CMetaInterval*)local_this).get_precision();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_precision_161_comment =
  "C++ Interface:\n"
  "get_precision(CMetaInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the precision with which time measurements are compared.  See\n"
  " * set_precision().\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_precision_161_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CMetaInterval::clear_intervals(void)
 */
static PyObject *Dtool_CMetaInterval_clear_intervals_162(PyObject *self, PyObject *) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CMetaInterval, (void **)&local_this, "CMetaInterval.clear_intervals")) {
    return NULL;
  }
  // 1-void CMetaInterval::clear_intervals(void)
  (*local_this).clear_intervals();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_clear_intervals_162_comment =
  "C++ Interface:\n"
  "clear_intervals(const CMetaInterval self)\n"
  "\n"
  "/**\n"
  " * Resets the list of intervals and prepares for receiving a new list.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_clear_intervals_162_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int CMetaInterval::push_level(std::string const &name, double rel_time, CMetaInterval::RelativeStart rel_to)
 */
static PyObject *Dtool_CMetaInterval_push_level_163(PyObject *self, PyObject *args, PyObject *kwds) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CMetaInterval, (void **)&local_this, "CMetaInterval.push_level")) {
    return NULL;
  }
  // 1-int CMetaInterval::push_level(std::string const &name, double rel_time, CMetaInterval::RelativeStart rel_to)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  double param2;
  int param3;
  static const char *keyword_list[] = {"name", "rel_time", "rel_to", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#di:push_level", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
    int return_value = (*local_this).push_level(std::string(param1_str, param1_len), (double)param2, (CMetaInterval::RelativeStart)param3);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_level(const CMetaInterval self, str name, double rel_time, int rel_to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_push_level_163_comment =
  "C++ Interface:\n"
  "push_level(const CMetaInterval self, str name, double rel_time, int rel_to)\n"
  "\n"
  "/**\n"
  " * Marks the beginning of a nested level of child intervals.  Within the\n"
  " * nested level, a RelativeStart time of RS_level_begin refers to the start of\n"
  " * the level, and the first interval added within the level is always relative\n"
  " * to the start of the level.\n"
  " *\n"
  " * The return value is the index of the def entry created by this push.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_push_level_163_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int CMetaInterval::add_c_interval(CInterval *c_interval, double rel_time = 0.0, CMetaInterval::RelativeStart rel_to = ::CMetaInterval::RS_previous_end)
 */
static PyObject *Dtool_CMetaInterval_add_c_interval_164(PyObject *self, PyObject *args, PyObject *kwds) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CMetaInterval, (void **)&local_this, "CMetaInterval.add_c_interval")) {
    return NULL;
  }
  // 1-int CMetaInterval::add_c_interval(CInterval *c_interval, double rel_time = 0.0, CMetaInterval::RelativeStart rel_to = ::CMetaInterval::RS_previous_end)
  PyObject *param1;
  double param2 = 0.0;
  int param3 = CMetaInterval::RS_previous_end;
  static const char *keyword_list[] = {"c_interval", "rel_time", "rel_to", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|di:add_c_interval", (char **)keyword_list, &param1, &param2, &param3)) {
    CInterval *param1_this = (CInterval *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_CInterval, 1, "CMetaInterval.add_c_interval", false, true);
    if (param1_this != NULL) {
      int return_value = (*local_this).add_c_interval(param1_this, (double)param2, (CMetaInterval::RelativeStart)param3);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_c_interval(const CMetaInterval self, CInterval c_interval, double rel_time, int rel_to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_add_c_interval_164_comment =
  "C++ Interface:\n"
  "add_c_interval(const CMetaInterval self, CInterval c_interval, double rel_time, int rel_to)\n"
  "\n"
  "/**\n"
  " * Adds a new CInterval to the list.  The interval will be played when the\n"
  " * indicated time (relative to the given point) has been reached.\n"
  " *\n"
  " * The return value is the index of the def entry representing the new\n"
  " * interval.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_add_c_interval_164_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int CMetaInterval::add_ext_index(int ext_index, std::string const &name, double duration, bool open_ended, double rel_time, CMetaInterval::RelativeStart rel_to)
 */
static PyObject *Dtool_CMetaInterval_add_ext_index_165(PyObject *self, PyObject *args, PyObject *kwds) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CMetaInterval, (void **)&local_this, "CMetaInterval.add_ext_index")) {
    return NULL;
  }
  // 1-int CMetaInterval::add_ext_index(int ext_index, std::string const &name, double duration, bool open_ended, double rel_time, CMetaInterval::RelativeStart rel_to)
  int param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  double param3;
  PyObject *param4;
  double param5;
  int param6;
  static const char *keyword_list[] = {"ext_index", "name", "duration", "open_ended", "rel_time", "rel_to", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "is#dOdi:add_ext_index", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3, &param4, &param5, &param6)) {
    int return_value = (*local_this).add_ext_index((int)param1, std::string(param2_str, param2_len), (double)param3, (PyObject_IsTrue(param4) != 0), (double)param5, (CMetaInterval::RelativeStart)param6);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_ext_index(const CMetaInterval self, int ext_index, str name, double duration, bool open_ended, double rel_time, int rel_to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_add_ext_index_165_comment =
  "C++ Interface:\n"
  "add_ext_index(const CMetaInterval self, int ext_index, str name, double duration, bool open_ended, double rel_time, int rel_to)\n"
  "\n"
  "/**\n"
  " * Adds a new external interval to the list.  This represents some object in\n"
  " * the external scripting language that has properties similar to a CInterval\n"
  " * (for instance, a Python Interval object).\n"
  " *\n"
  " * The CMetaInterval object cannot play this external interval directly, but\n"
  " * it records a placeholder for it and will ask the scripting language to play\n"
  " * it when it is time, via is_event_ready() and related methods.\n"
  " *\n"
  " * The ext_index number itself is simply a handle that the scripting language\n"
  " * makes up and associates with its interval object somehow.  The\n"
  " * CMetaInterval object does not attempt to interpret this value.\n"
  " *\n"
  " * The return value is the index of the def entry representing the new\n"
  " * interval.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_add_ext_index_165_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int CMetaInterval::pop_level(double duration = -1.0)
 */
static PyObject *Dtool_CMetaInterval_pop_level_166(PyObject *self, PyObject *args, PyObject *kwds) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CMetaInterval, (void **)&local_this, "CMetaInterval.pop_level")) {
    return NULL;
  }
  // 1-int CMetaInterval::pop_level(double duration = -1.0)
  double param1 = -1.0;
  static const char *keyword_list[] = {"duration", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|d:pop_level", (char **)keyword_list, &param1)) {
    int return_value = (*local_this).pop_level((double)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pop_level(const CMetaInterval self, double duration)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_pop_level_166_comment =
  "C++ Interface:\n"
  "pop_level(const CMetaInterval self, double duration)\n"
  "\n"
  "/**\n"
  " * Finishes a level marked by a previous call to push_level(), and returns to\n"
  " * the previous level.\n"
  " *\n"
  " * If the duration is not negative, it represents a phony duration to assign\n"
  " * to the level, for the purposes of sequencing later intervals.  Otherwise,\n"
  " * the level's duration is computed based on the intervals within the level.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_pop_level_166_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CMetaInterval::set_interval_start_time(std::string const &name, double rel_time, CMetaInterval::RelativeStart rel_to = ::CMetaInterval::RS_level_begin)
 */
static PyObject *Dtool_CMetaInterval_set_interval_start_time_167(PyObject *self, PyObject *args, PyObject *kwds) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CMetaInterval, (void **)&local_this, "CMetaInterval.set_interval_start_time")) {
    return NULL;
  }
  // 1-bool CMetaInterval::set_interval_start_time(std::string const &name, double rel_time, CMetaInterval::RelativeStart rel_to = ::CMetaInterval::RS_level_begin)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  double param2;
  int param3 = CMetaInterval::RS_level_begin;
  static const char *keyword_list[] = {"name", "rel_time", "rel_to", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#d|i:set_interval_start_time", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
    bool return_value = (*local_this).set_interval_start_time(std::string(param1_str, param1_len), (double)param2, (CMetaInterval::RelativeStart)param3);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_interval_start_time(const CMetaInterval self, str name, double rel_time, int rel_to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_set_interval_start_time_167_comment =
  "C++ Interface:\n"
  "set_interval_start_time(const CMetaInterval self, str name, double rel_time, int rel_to)\n"
  "\n"
  "/**\n"
  " * Adjusts the start time of the child interval with the given name, if found.\n"
  " * This may be either a C++ interval added via add_c_interval(), or an\n"
  " * external interval added via add_ext_index(); the name must match exactly.\n"
  " *\n"
  " * If the interval is found, its start time is adjusted, and all subsequent\n"
  " * intervals are adjusting accordingly, and true is returned.  If a matching\n"
  " * interval is not found, nothing is changed and false is returned.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_set_interval_start_time_167_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double CMetaInterval::get_interval_start_time(std::string const &name) const
 */
static PyObject *Dtool_CMetaInterval_get_interval_start_time_168(PyObject *self, PyObject *arg) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CMetaInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-double CMetaInterval::get_interval_start_time(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    double return_value = (*(const CMetaInterval*)local_this).get_interval_start_time(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_interval_start_time(CMetaInterval self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_interval_start_time_168_comment =
  "C++ Interface:\n"
  "get_interval_start_time(CMetaInterval self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the actual start time, relative to the beginning of the interval,\n"
  " * of the child interval with the given name, if found, or -1 if the interval\n"
  " * is not found.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_interval_start_time_168_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double CMetaInterval::get_interval_end_time(std::string const &name) const
 */
static PyObject *Dtool_CMetaInterval_get_interval_end_time_169(PyObject *self, PyObject *arg) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CMetaInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-double CMetaInterval::get_interval_end_time(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    double return_value = (*(const CMetaInterval*)local_this).get_interval_end_time(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_interval_end_time(CMetaInterval self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_interval_end_time_169_comment =
  "C++ Interface:\n"
  "get_interval_end_time(CMetaInterval self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the actual end time, relative to the beginning of the interval, of\n"
  " * the child interval with the given name, if found, or -1 if the interval is\n"
  " * not found.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_interval_end_time_169_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int CMetaInterval::get_num_defs(void) const
 */
static PyObject *Dtool_CMetaInterval_get_num_defs_171(PyObject *self, PyObject *) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CMetaInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int CMetaInterval::get_num_defs(void) const
  int return_value = (*(const CMetaInterval*)local_this).get_num_defs();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_num_defs_171_comment =
  "C++ Interface:\n"
  "get_num_defs(CMetaInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the number of interval and push/pop definitions that have been\n"
  " * added to the meta interval.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_num_defs_171_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CMetaInterval::DefType CMetaInterval::get_def_type(int n) const
 */
static PyObject *Dtool_CMetaInterval_get_def_type_172(PyObject *self, PyObject *arg) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CMetaInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CMetaInterval::DefType CMetaInterval::get_def_type(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    CMetaInterval::DefType return_value = (*(const CMetaInterval*)local_this).get_def_type((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_def_type(CMetaInterval self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_def_type_172_comment =
  "C++ Interface:\n"
  "get_def_type(CMetaInterval self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the type of the nth interval definition that has been added.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_def_type_172_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CInterval *CMetaInterval::get_c_interval(int n) const
 */
static PyObject *Dtool_CMetaInterval_get_c_interval_173(PyObject *self, PyObject *arg) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CMetaInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CInterval *CMetaInterval::get_c_interval(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    CInterval *return_value = (*(const CMetaInterval*)local_this).get_c_interval((int)arg_val);
    if (return_value != (CInterval *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (CInterval *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CInterval, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_c_interval(CMetaInterval self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_c_interval_173_comment =
  "C++ Interface:\n"
  "get_c_interval(CMetaInterval self, int n)\n"
  "\n"
  "/**\n"
  " * Return the CInterval pointer associated with the nth interval definition.\n"
  " * It is only valid to call this if get_def_type(n) returns DT_c_interval.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_c_interval_173_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int CMetaInterval::get_ext_index(int n) const
 */
static PyObject *Dtool_CMetaInterval_get_ext_index_174(PyObject *self, PyObject *arg) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CMetaInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int CMetaInterval::get_ext_index(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const CMetaInterval*)local_this).get_ext_index((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_ext_index(CMetaInterval self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_ext_index_174_comment =
  "C++ Interface:\n"
  "get_ext_index(CMetaInterval self, int n)\n"
  "\n"
  "/**\n"
  " * Return the external interval index number associated with the nth interval\n"
  " * definition.  It is only valid to call this if get_def_type(n) returns\n"
  " * DT_ext_index.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_ext_index_174_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CMetaInterval::is_event_ready(void)
 */
static PyObject *Dtool_CMetaInterval_is_event_ready_175(PyObject *self, PyObject *) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CMetaInterval, (void **)&local_this, "CMetaInterval.is_event_ready")) {
    return NULL;
  }
  // 1-inline bool CMetaInterval::is_event_ready(void)
  bool return_value = (*local_this).is_event_ready();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_is_event_ready_175_comment =
  "C++ Interface:\n"
  "is_event_ready(const CMetaInterval self)\n"
  "\n"
  "/**\n"
  " * Returns true if a recent call to priv_initialize(), priv_step(), or\n"
  " * priv_finalize() has left some external intervals ready to play.  If this\n"
  " * returns true, call get_event_index(), get_event_t(), and pop_event() to\n"
  " * retrieve the relevant information.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_is_event_ready_175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int CMetaInterval::get_event_index(void) const
 */
static PyObject *Dtool_CMetaInterval_get_event_index_176(PyObject *self, PyObject *) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CMetaInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int CMetaInterval::get_event_index(void) const
  int return_value = (*(const CMetaInterval*)local_this).get_event_index();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_event_index_176_comment =
  "C++ Interface:\n"
  "get_event_index(CMetaInterval self)\n"
  "\n"
  "/**\n"
  " * If a previous call to is_event_ready() returned true, this returns the\n"
  " * index number (added via add_event_index()) of the external interval that\n"
  " * needs to be played.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_event_index_176_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double CMetaInterval::get_event_t(void) const
 */
static PyObject *Dtool_CMetaInterval_get_event_t_177(PyObject *self, PyObject *) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CMetaInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double CMetaInterval::get_event_t(void) const
  double return_value = (*(const CMetaInterval*)local_this).get_event_t();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_event_t_177_comment =
  "C++ Interface:\n"
  "get_event_t(CMetaInterval self)\n"
  "\n"
  "/**\n"
  " * If a previous call to is_event_ready() returned true, this returns the t\n"
  " * value that should be fed to the given interval.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_event_t_177_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CInterval::EventType CMetaInterval::get_event_type(void) const
 */
static PyObject *Dtool_CMetaInterval_get_event_type_178(PyObject *self, PyObject *) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CMetaInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CInterval::EventType CMetaInterval::get_event_type(void) const
  CInterval::EventType return_value = (*(const CMetaInterval*)local_this).get_event_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_event_type_178_comment =
  "C++ Interface:\n"
  "get_event_type(CMetaInterval self)\n"
  "\n"
  "/**\n"
  " * If a previous call to is_event_ready() returned true, this returns the type\n"
  " * of the event (initialize, step, finalize, etc.) for the given interval.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_event_type_178_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CMetaInterval::pop_event(void)
 */
static PyObject *Dtool_CMetaInterval_pop_event_179(PyObject *self, PyObject *) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CMetaInterval, (void **)&local_this, "CMetaInterval.pop_event")) {
    return NULL;
  }
  // 1-void CMetaInterval::pop_event(void)
  (*local_this).pop_event();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_pop_event_179_comment =
  "C++ Interface:\n"
  "pop_event(const CMetaInterval self)\n"
  "\n"
  "/**\n"
  " * Acknowledges that the external interval on the top of the queue has been\n"
  " * extracted, and is about to be serviced by the scripting language.  This\n"
  " * prepares the interval so the next call to is_event_ready() will return\n"
  " * information about the next external interval on the queue, if any.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_pop_event_179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CMetaInterval::timeline(ostream &out) const
 */
static PyObject *Dtool_CMetaInterval_timeline_180(PyObject *self, PyObject *arg) {
  CMetaInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CMetaInterval, (void **)&local_this)) {
    return NULL;
  }
  // 1-void CMetaInterval::timeline(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "CMetaInterval.timeline", false, true);
  if (arg_this != NULL) {
    (*(const CMetaInterval*)local_this).timeline(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "timeline(CMetaInterval self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_timeline_180_comment =
  "C++ Interface:\n"
  "timeline(CMetaInterval self, ostream out)\n"
  "\n"
  "/**\n"
  " * Outputs a list of all events in the order in which they occur.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_timeline_180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CMetaInterval::get_class_type(void)
 */
static PyObject *Dtool_CMetaInterval_get_class_type_181(PyObject *, PyObject *) {
  // 1-static TypeHandle CMetaInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CMetaInterval::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_class_type_181_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CMetaInterval_get_class_type_181_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CMetaInterval::CMetaInterval(CMetaInterval const &) = default
 * CMetaInterval::CMetaInterval(std::string const &name)
 */
static int Dtool_Init_CMetaInterval(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CMetaInterval() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline CMetaInterval::CMetaInterval(CMetaInterval const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:CMetaInterval", (char **)keyword_list, &param0)) {
      CMetaInterval const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_CMetaInterval, (void **)&param0_this);
      if (param0_this != NULL) {
        CMetaInterval *return_value = new CMetaInterval(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CMetaInterval, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 CMetaInterval::CMetaInterval(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:CMetaInterval", (char **)keyword_list, &param0_str, &param0_len)) {
      CMetaInterval *return_value = new CMetaInterval(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CMetaInterval, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline CMetaInterval::CMetaInterval(CMetaInterval const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:CMetaInterval", (char **)keyword_list, &param0)) {
      CPT(CMetaInterval) param0_this;
      if (Dtool_ConstCoerce_CMetaInterval(param0, param0_this)) {
        CMetaInterval *return_value = new CMetaInterval(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CMetaInterval, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: CMetaInterval::CMetaInterval(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CMetaInterval(const CMetaInterval param0)\n"
      "CMetaInterval(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CMetaInterval(PyObject *args, CPT(CMetaInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CMetaInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CMetaInterval::CMetaInterval(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      CMetaInterval *return_value = new CMetaInterval(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_CMetaInterval(PyObject *args, PT(CMetaInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CMetaInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CMetaInterval::CMetaInterval(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      CMetaInterval *return_value = new CMetaInterval(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_CMetaInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CMetaInterval) {
    printf("CMetaInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CMetaInterval *local_this = (CMetaInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CMetaInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CMetaInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CMetaInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (CMetaInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CMetaInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CMetaInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CMetaInterval*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class HideInterval
 */
/**
 * Python function wrapper for:
 * static TypeHandle HideInterval::get_class_type(void)
 */
static PyObject *Dtool_HideInterval_get_class_type_184(PyObject *, PyObject *) {
  // 1-static TypeHandle HideInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(HideInterval::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_HideInterval_get_class_type_184_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_HideInterval_get_class_type_184_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline HideInterval::HideInterval(HideInterval const &) = default
 * HideInterval::HideInterval(NodePath const &node, std::string const &name = string())
 */
static int Dtool_Init_HideInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    // -2 HideInterval::HideInterval(NodePath const &node, std::string const &name = string())
    PyObject *param0;
    const char *param1_str = "";
    Py_ssize_t param1_len = 0;
    static const char *keyword_list[] = {"node", "name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:HideInterval", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
      NodePath const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_NodePath, (void **)&param0_this);
      if (param0_this != NULL) {
        HideInterval *return_value = new HideInterval(*param0_this, std::string(param1_str, param1_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HideInterval, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: HideInterval::HideInterval(NodePath const &node, std::string const &name = string())
  {
    // -2 inline HideInterval::HideInterval(HideInterval const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:HideInterval", (char **)keyword_list, &param0)) {
      CPT(HideInterval) param0_this;
      if (Dtool_ConstCoerce_HideInterval(param0, param0_this)) {
        HideInterval *return_value = new HideInterval(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HideInterval, true, false);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "HideInterval(const NodePath node, str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_HideInterval(PyObject *args, CPT(HideInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_HideInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-HideInterval::HideInterval(NodePath const &node, std::string const &name)
    NodePath const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_NodePath, (void **)&arg_this);
    if (arg_this != NULL) {
      HideInterval *return_value = new HideInterval(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-HideInterval::HideInterval(NodePath const &node, std::string const &name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:HideInterval", &param0, &param1_str, &param1_len)) {
        NodePath const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_NodePath, (void **)&param0_this);
        if (param0_this != NULL) {
          HideInterval *return_value = new HideInterval(*param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_HideInterval(PyObject *args, PT(HideInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_HideInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-HideInterval::HideInterval(NodePath const &node, std::string const &name)
    NodePath const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_NodePath, (void **)&arg_this);
    if (arg_this != NULL) {
      HideInterval *return_value = new HideInterval(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-HideInterval::HideInterval(NodePath const &node, std::string const &name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:HideInterval", &param0, &param1_str, &param1_len)) {
        NodePath const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_NodePath, (void **)&param0_this);
        if (param0_this != NULL) {
          HideInterval *return_value = new HideInterval(*param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_HideInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_HideInterval) {
    printf("HideInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  HideInterval *local_this = (HideInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_HideInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_HideInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_HideInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (HideInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (HideInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (HideInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (HideInterval*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LerpBlendType
 */
/**
 * Python function wrapper for:
 * static TypeHandle LerpBlendType::get_class_type(void)
 */
static PyObject *Dtool_LerpBlendType_get_class_type_188(PyObject *, PyObject *) {
  // 1-static TypeHandle LerpBlendType::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LerpBlendType::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LerpBlendType_get_class_type_188_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "// now for typehandle stuff";
#else
static const char *Dtool_LerpBlendType_get_class_type_188_comment = NULL;
#endif

static int Dtool_Init_LerpBlendType(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LerpBlendType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LerpBlendType) {
    printf("LerpBlendType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LerpBlendType *local_this = (LerpBlendType *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LerpBlendType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LerpBlendType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LerpBlendType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LerpBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LerpBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LerpBlendType*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EaseInBlendType
 */
/**
 * Python function wrapper for:
 * static TypeHandle EaseInBlendType::get_class_type(void)
 */
static PyObject *Dtool_EaseInBlendType_get_class_type_191(PyObject *, PyObject *) {
  // 1-static TypeHandle EaseInBlendType::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EaseInBlendType::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EaseInBlendType_get_class_type_191_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "// now for typehandle stuff";
#else
static const char *Dtool_EaseInBlendType_get_class_type_191_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EaseInBlendType::EaseInBlendType(void)
 */
static int Dtool_Init_EaseInBlendType(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "EaseInBlendType() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-EaseInBlendType::EaseInBlendType(void)
  EaseInBlendType *return_value = new EaseInBlendType();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EaseInBlendType, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EaseInBlendType()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EaseInBlendType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EaseInBlendType) {
    printf("EaseInBlendType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EaseInBlendType *local_this = (EaseInBlendType *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EaseInBlendType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LerpBlendType) {
    return (LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EaseInBlendType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EaseInBlendType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LerpBlendType) {
    LerpBlendType* other_this = (LerpBlendType*)from_this;
    return (EaseInBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EaseInBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EaseInBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EaseInBlendType*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EaseOutBlendType
 */
/**
 * Python function wrapper for:
 * static TypeHandle EaseOutBlendType::get_class_type(void)
 */
static PyObject *Dtool_EaseOutBlendType_get_class_type_194(PyObject *, PyObject *) {
  // 1-static TypeHandle EaseOutBlendType::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EaseOutBlendType::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EaseOutBlendType_get_class_type_194_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "// now for typehandle stuff";
#else
static const char *Dtool_EaseOutBlendType_get_class_type_194_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EaseOutBlendType::EaseOutBlendType(void)
 */
static int Dtool_Init_EaseOutBlendType(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "EaseOutBlendType() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-EaseOutBlendType::EaseOutBlendType(void)
  EaseOutBlendType *return_value = new EaseOutBlendType();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EaseOutBlendType, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EaseOutBlendType()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EaseOutBlendType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EaseOutBlendType) {
    printf("EaseOutBlendType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EaseOutBlendType *local_this = (EaseOutBlendType *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EaseOutBlendType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LerpBlendType) {
    return (LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EaseOutBlendType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EaseOutBlendType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LerpBlendType) {
    LerpBlendType* other_this = (LerpBlendType*)from_this;
    return (EaseOutBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EaseOutBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EaseOutBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EaseOutBlendType*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EaseInOutBlendType
 */
/**
 * Python function wrapper for:
 * static TypeHandle EaseInOutBlendType::get_class_type(void)
 */
static PyObject *Dtool_EaseInOutBlendType_get_class_type_197(PyObject *, PyObject *) {
  // 1-static TypeHandle EaseInOutBlendType::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EaseInOutBlendType::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EaseInOutBlendType_get_class_type_197_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "// now for typehandle stuff";
#else
static const char *Dtool_EaseInOutBlendType_get_class_type_197_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EaseInOutBlendType::EaseInOutBlendType(void)
 */
static int Dtool_Init_EaseInOutBlendType(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "EaseInOutBlendType() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-EaseInOutBlendType::EaseInOutBlendType(void)
  EaseInOutBlendType *return_value = new EaseInOutBlendType();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EaseInOutBlendType, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EaseInOutBlendType()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EaseInOutBlendType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EaseInOutBlendType) {
    printf("EaseInOutBlendType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EaseInOutBlendType *local_this = (EaseInOutBlendType *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EaseInOutBlendType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LerpBlendType) {
    return (LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EaseInOutBlendType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EaseInOutBlendType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LerpBlendType) {
    LerpBlendType* other_this = (LerpBlendType*)from_this;
    return (EaseInOutBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EaseInOutBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EaseInOutBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EaseInOutBlendType*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class NoBlendType
 */
/**
 * Python function wrapper for:
 * static TypeHandle NoBlendType::get_class_type(void)
 */
static PyObject *Dtool_NoBlendType_get_class_type_200(PyObject *, PyObject *) {
  // 1-static TypeHandle NoBlendType::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(NoBlendType::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NoBlendType_get_class_type_200_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "// now for typehandle stuff";
#else
static const char *Dtool_NoBlendType_get_class_type_200_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NoBlendType::NoBlendType(void)
 */
static int Dtool_Init_NoBlendType(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "NoBlendType() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-NoBlendType::NoBlendType(void)
  NoBlendType *return_value = new NoBlendType();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NoBlendType, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NoBlendType()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_NoBlendType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_NoBlendType) {
    printf("NoBlendType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  NoBlendType *local_this = (NoBlendType *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_NoBlendType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LerpBlendType) {
    return (LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_NoBlendType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_NoBlendType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LerpBlendType) {
    LerpBlendType* other_this = (LerpBlendType*)from_this;
    return (NoBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (NoBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (NoBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (NoBlendType*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ShowInterval
 */
/**
 * Python function wrapper for:
 * static TypeHandle ShowInterval::get_class_type(void)
 */
static PyObject *Dtool_ShowInterval_get_class_type_203(PyObject *, PyObject *) {
  // 1-static TypeHandle ShowInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ShowInterval::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ShowInterval_get_class_type_203_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ShowInterval_get_class_type_203_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ShowInterval::ShowInterval(NodePath const &node, std::string const &name = string())
 * inline ShowInterval::ShowInterval(ShowInterval const &) = default
 */
static int Dtool_Init_ShowInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    // -2 ShowInterval::ShowInterval(NodePath const &node, std::string const &name = string())
    PyObject *param0;
    const char *param1_str = "";
    Py_ssize_t param1_len = 0;
    static const char *keyword_list[] = {"node", "name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:ShowInterval", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
      NodePath const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_NodePath, (void **)&param0_this);
      if (param0_this != NULL) {
        ShowInterval *return_value = new ShowInterval(*param0_this, std::string(param1_str, param1_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShowInterval, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ShowInterval::ShowInterval(NodePath const &node, std::string const &name = string())
  {
    // -2 inline ShowInterval::ShowInterval(ShowInterval const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ShowInterval", (char **)keyword_list, &param0)) {
      CPT(ShowInterval) param0_this;
      if (Dtool_ConstCoerce_ShowInterval(param0, param0_this)) {
        ShowInterval *return_value = new ShowInterval(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShowInterval, true, false);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ShowInterval(const NodePath node, str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ShowInterval(PyObject *args, CPT(ShowInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ShowInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ShowInterval::ShowInterval(NodePath const &node, std::string const &name)
    NodePath const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_NodePath, (void **)&arg_this);
    if (arg_this != NULL) {
      ShowInterval *return_value = new ShowInterval(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-ShowInterval::ShowInterval(NodePath const &node, std::string const &name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:ShowInterval", &param0, &param1_str, &param1_len)) {
        NodePath const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_NodePath, (void **)&param0_this);
        if (param0_this != NULL) {
          ShowInterval *return_value = new ShowInterval(*param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_ShowInterval(PyObject *args, PT(ShowInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ShowInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ShowInterval::ShowInterval(NodePath const &node, std::string const &name)
    NodePath const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_NodePath, (void **)&arg_this);
    if (arg_this != NULL) {
      ShowInterval *return_value = new ShowInterval(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-ShowInterval::ShowInterval(NodePath const &node, std::string const &name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:ShowInterval", &param0, &param1_str, &param1_len)) {
        NodePath const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_NodePath, (void **)&param0_this);
        if (param0_this != NULL) {
          ShowInterval *return_value = new ShowInterval(*param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ShowInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ShowInterval) {
    printf("ShowInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ShowInterval *local_this = (ShowInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ShowInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ShowInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ShowInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (ShowInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ShowInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ShowInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (ShowInterval*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class WaitInterval
 */
/**
 * Python function wrapper for:
 * static TypeHandle WaitInterval::get_class_type(void)
 */
static PyObject *Dtool_WaitInterval_get_class_type_207(PyObject *, PyObject *) {
  // 1-static TypeHandle WaitInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(WaitInterval::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_WaitInterval_get_class_type_207_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_WaitInterval_get_class_type_207_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline WaitInterval::WaitInterval(WaitInterval const &) = default
 * inline WaitInterval::WaitInterval(double duration)
 */
static int Dtool_Init_WaitInterval(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "WaitInterval() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline WaitInterval::WaitInterval(WaitInterval const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:WaitInterval", (char **)keyword_list, &param0)) {
      WaitInterval const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_WaitInterval, (void **)&param0_this);
      if (param0_this != NULL) {
        WaitInterval *return_value = new WaitInterval(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WaitInterval, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline WaitInterval::WaitInterval(double duration)
    double param0;
    static const char *keyword_list[] = {"duration", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "d:WaitInterval", (char **)keyword_list, &param0)) {
      WaitInterval *return_value = new WaitInterval((double)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WaitInterval, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline WaitInterval::WaitInterval(WaitInterval const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:WaitInterval", (char **)keyword_list, &param0)) {
      CPT(WaitInterval) param0_this;
      if (Dtool_ConstCoerce_WaitInterval(param0, param0_this)) {
        WaitInterval *return_value = new WaitInterval(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WaitInterval, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: inline WaitInterval::WaitInterval(double duration)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "WaitInterval(const WaitInterval param0)\n"
      "WaitInterval(double duration)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_WaitInterval(PyObject *args, CPT(WaitInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_WaitInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline WaitInterval::WaitInterval(double duration)
    if (PyNumber_Check(arg)) {
      WaitInterval *return_value = new WaitInterval(PyFloat_AsDouble(arg));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_WaitInterval(PyObject *args, PT(WaitInterval) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_WaitInterval, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline WaitInterval::WaitInterval(double duration)
    if (PyNumber_Check(arg)) {
      WaitInterval *return_value = new WaitInterval(PyFloat_AsDouble(arg));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_WaitInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_WaitInterval) {
    printf("WaitInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  WaitInterval *local_this = (WaitInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_WaitInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_WaitInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_WaitInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (WaitInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (WaitInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (WaitInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (WaitInterval*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for CInterval (CInterval)
 */
static PyMethodDef Dtool_Methods_CInterval[] = {
  {"get_name", &Dtool_CInterval_get_name_3, METH_NOARGS, (const char *)Dtool_CInterval_get_name_3_comment},
  {"getName", &Dtool_CInterval_get_name_3, METH_NOARGS, (const char *)Dtool_CInterval_get_name_3_comment},
  {"get_duration", &Dtool_CInterval_get_duration_4, METH_NOARGS, (const char *)Dtool_CInterval_get_duration_4_comment},
  {"getDuration", &Dtool_CInterval_get_duration_4, METH_NOARGS, (const char *)Dtool_CInterval_get_duration_4_comment},
  {"get_open_ended", &Dtool_CInterval_get_open_ended_5, METH_NOARGS, (const char *)Dtool_CInterval_get_open_ended_5_comment},
  {"getOpenEnded", &Dtool_CInterval_get_open_ended_5, METH_NOARGS, (const char *)Dtool_CInterval_get_open_ended_5_comment},
  {"get_state", &Dtool_CInterval_get_state_8, METH_NOARGS, (const char *)Dtool_CInterval_get_state_8_comment},
  {"getState", &Dtool_CInterval_get_state_8, METH_NOARGS, (const char *)Dtool_CInterval_get_state_8_comment},
  {"is_stopped", &Dtool_CInterval_is_stopped_9, METH_NOARGS, (const char *)Dtool_CInterval_is_stopped_9_comment},
  {"isStopped", &Dtool_CInterval_is_stopped_9, METH_NOARGS, (const char *)Dtool_CInterval_is_stopped_9_comment},
  {"set_done_event", &Dtool_CInterval_set_done_event_10, METH_O, (const char *)Dtool_CInterval_set_done_event_10_comment},
  {"setDoneEvent", &Dtool_CInterval_set_done_event_10, METH_O, (const char *)Dtool_CInterval_set_done_event_10_comment},
  {"get_done_event", &Dtool_CInterval_get_done_event_11, METH_NOARGS, (const char *)Dtool_CInterval_get_done_event_11_comment},
  {"getDoneEvent", &Dtool_CInterval_get_done_event_11, METH_NOARGS, (const char *)Dtool_CInterval_get_done_event_11_comment},
  {"set_t", &Dtool_CInterval_set_t_12, METH_O, (const char *)Dtool_CInterval_set_t_12_comment},
  {"setT", &Dtool_CInterval_set_t_12, METH_O, (const char *)Dtool_CInterval_set_t_12_comment},
  {"get_t", &Dtool_CInterval_get_t_13, METH_NOARGS, (const char *)Dtool_CInterval_get_t_13_comment},
  {"getT", &Dtool_CInterval_get_t_13, METH_NOARGS, (const char *)Dtool_CInterval_get_t_13_comment},
  {"set_auto_pause", &Dtool_CInterval_set_auto_pause_14, METH_O, (const char *)Dtool_CInterval_set_auto_pause_14_comment},
  {"setAutoPause", &Dtool_CInterval_set_auto_pause_14, METH_O, (const char *)Dtool_CInterval_set_auto_pause_14_comment},
  {"get_auto_pause", &Dtool_CInterval_get_auto_pause_15, METH_NOARGS, (const char *)Dtool_CInterval_get_auto_pause_15_comment},
  {"getAutoPause", &Dtool_CInterval_get_auto_pause_15, METH_NOARGS, (const char *)Dtool_CInterval_get_auto_pause_15_comment},
  {"set_auto_finish", &Dtool_CInterval_set_auto_finish_16, METH_O, (const char *)Dtool_CInterval_set_auto_finish_16_comment},
  {"setAutoFinish", &Dtool_CInterval_set_auto_finish_16, METH_O, (const char *)Dtool_CInterval_set_auto_finish_16_comment},
  {"get_auto_finish", &Dtool_CInterval_get_auto_finish_17, METH_NOARGS, (const char *)Dtool_CInterval_get_auto_finish_17_comment},
  {"getAutoFinish", &Dtool_CInterval_get_auto_finish_17, METH_NOARGS, (const char *)Dtool_CInterval_get_auto_finish_17_comment},
  {"set_wants_t_callback", &Dtool_CInterval_set_wants_t_callback_18, METH_O, (const char *)Dtool_CInterval_set_wants_t_callback_18_comment},
  {"setWantsTCallback", &Dtool_CInterval_set_wants_t_callback_18, METH_O, (const char *)Dtool_CInterval_set_wants_t_callback_18_comment},
  {"get_wants_t_callback", &Dtool_CInterval_get_wants_t_callback_19, METH_NOARGS, (const char *)Dtool_CInterval_get_wants_t_callback_19_comment},
  {"getWantsTCallback", &Dtool_CInterval_get_wants_t_callback_19, METH_NOARGS, (const char *)Dtool_CInterval_get_wants_t_callback_19_comment},
  {"set_manager", &Dtool_CInterval_set_manager_20, METH_O, (const char *)Dtool_CInterval_set_manager_20_comment},
  {"setManager", &Dtool_CInterval_set_manager_20, METH_O, (const char *)Dtool_CInterval_set_manager_20_comment},
  {"get_manager", &Dtool_CInterval_get_manager_21, METH_NOARGS, (const char *)Dtool_CInterval_get_manager_21_comment},
  {"getManager", &Dtool_CInterval_get_manager_21, METH_NOARGS, (const char *)Dtool_CInterval_get_manager_21_comment},
  {"start", (PyCFunction) &Dtool_CInterval_start_22, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterval_start_22_comment},
  {"loop", (PyCFunction) &Dtool_CInterval_loop_23, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterval_loop_23_comment},
  {"pause", &Dtool_CInterval_pause_24, METH_NOARGS, (const char *)Dtool_CInterval_pause_24_comment},
  {"resume", &Dtool_CInterval_resume_25, METH_VARARGS, (const char *)Dtool_CInterval_resume_25_comment},
  {"resume_until", &Dtool_CInterval_resume_until_26, METH_O, (const char *)Dtool_CInterval_resume_until_26_comment},
  {"resumeUntil", &Dtool_CInterval_resume_until_26, METH_O, (const char *)Dtool_CInterval_resume_until_26_comment},
  {"finish", &Dtool_CInterval_finish_27, METH_NOARGS, (const char *)Dtool_CInterval_finish_27_comment},
  {"clear_to_initial", &Dtool_CInterval_clear_to_initial_28, METH_NOARGS, (const char *)Dtool_CInterval_clear_to_initial_28_comment},
  {"clearToInitial", &Dtool_CInterval_clear_to_initial_28, METH_NOARGS, (const char *)Dtool_CInterval_clear_to_initial_28_comment},
  {"is_playing", &Dtool_CInterval_is_playing_29, METH_NOARGS, (const char *)Dtool_CInterval_is_playing_29_comment},
  {"isPlaying", &Dtool_CInterval_is_playing_29, METH_NOARGS, (const char *)Dtool_CInterval_is_playing_29_comment},
  {"get_play_rate", &Dtool_CInterval_get_play_rate_30, METH_NOARGS, (const char *)Dtool_CInterval_get_play_rate_30_comment},
  {"getPlayRate", &Dtool_CInterval_get_play_rate_30, METH_NOARGS, (const char *)Dtool_CInterval_get_play_rate_30_comment},
  {"set_play_rate", &Dtool_CInterval_set_play_rate_31, METH_O, (const char *)Dtool_CInterval_set_play_rate_31_comment},
  {"setPlayRate", &Dtool_CInterval_set_play_rate_31, METH_O, (const char *)Dtool_CInterval_set_play_rate_31_comment},
  {"priv_do_event", (PyCFunction) &Dtool_CInterval_priv_do_event_32, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterval_priv_do_event_32_comment},
  {"privDoEvent", (PyCFunction) &Dtool_CInterval_priv_do_event_32, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterval_priv_do_event_32_comment},
  {"priv_initialize", &Dtool_CInterval_priv_initialize_33, METH_O, (const char *)Dtool_CInterval_priv_initialize_33_comment},
  {"privInitialize", &Dtool_CInterval_priv_initialize_33, METH_O, (const char *)Dtool_CInterval_priv_initialize_33_comment},
  {"priv_instant", &Dtool_CInterval_priv_instant_34, METH_NOARGS, (const char *)Dtool_CInterval_priv_instant_34_comment},
  {"privInstant", &Dtool_CInterval_priv_instant_34, METH_NOARGS, (const char *)Dtool_CInterval_priv_instant_34_comment},
  {"priv_step", &Dtool_CInterval_priv_step_35, METH_O, (const char *)Dtool_CInterval_priv_step_35_comment},
  {"privStep", &Dtool_CInterval_priv_step_35, METH_O, (const char *)Dtool_CInterval_priv_step_35_comment},
  {"priv_finalize", &Dtool_CInterval_priv_finalize_36, METH_NOARGS, (const char *)Dtool_CInterval_priv_finalize_36_comment},
  {"privFinalize", &Dtool_CInterval_priv_finalize_36, METH_NOARGS, (const char *)Dtool_CInterval_priv_finalize_36_comment},
  {"priv_reverse_initialize", &Dtool_CInterval_priv_reverse_initialize_37, METH_O, (const char *)Dtool_CInterval_priv_reverse_initialize_37_comment},
  {"privReverseInitialize", &Dtool_CInterval_priv_reverse_initialize_37, METH_O, (const char *)Dtool_CInterval_priv_reverse_initialize_37_comment},
  {"priv_reverse_instant", &Dtool_CInterval_priv_reverse_instant_38, METH_NOARGS, (const char *)Dtool_CInterval_priv_reverse_instant_38_comment},
  {"privReverseInstant", &Dtool_CInterval_priv_reverse_instant_38, METH_NOARGS, (const char *)Dtool_CInterval_priv_reverse_instant_38_comment},
  {"priv_reverse_finalize", &Dtool_CInterval_priv_reverse_finalize_39, METH_NOARGS, (const char *)Dtool_CInterval_priv_reverse_finalize_39_comment},
  {"privReverseFinalize", &Dtool_CInterval_priv_reverse_finalize_39, METH_NOARGS, (const char *)Dtool_CInterval_priv_reverse_finalize_39_comment},
  {"priv_interrupt", &Dtool_CInterval_priv_interrupt_40, METH_NOARGS, (const char *)Dtool_CInterval_priv_interrupt_40_comment},
  {"privInterrupt", &Dtool_CInterval_priv_interrupt_40, METH_NOARGS, (const char *)Dtool_CInterval_priv_interrupt_40_comment},
  {"output", &Dtool_CInterval_output_41, METH_O, (const char *)Dtool_CInterval_output_41_comment},
  {"write", (PyCFunction) &Dtool_CInterval_write_42, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterval_write_42_comment},
  {"setup_play", (PyCFunction) &Dtool_CInterval_setup_play_43, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterval_setup_play_43_comment},
  {"setupPlay", (PyCFunction) &Dtool_CInterval_setup_play_43, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterval_setup_play_43_comment},
  {"setup_resume", &Dtool_CInterval_setup_resume_44, METH_NOARGS, (const char *)Dtool_CInterval_setup_resume_44_comment},
  {"setupResume", &Dtool_CInterval_setup_resume_44, METH_NOARGS, (const char *)Dtool_CInterval_setup_resume_44_comment},
  {"setup_resume_until", &Dtool_CInterval_setup_resume_until_45, METH_O, (const char *)Dtool_CInterval_setup_resume_until_45_comment},
  {"setupResumeUntil", &Dtool_CInterval_setup_resume_until_45, METH_O, (const char *)Dtool_CInterval_setup_resume_until_45_comment},
  {"step_play", &Dtool_CInterval_step_play_46, METH_NOARGS, (const char *)Dtool_CInterval_step_play_46_comment},
  {"stepPlay", &Dtool_CInterval_step_play_46, METH_NOARGS, (const char *)Dtool_CInterval_step_play_46_comment},
  {"get_class_type", &Dtool_CInterval_get_class_type_83, METH_NOARGS | METH_STATIC, (const char *)Dtool_CInterval_get_class_type_83_comment},
  {"getClassType", &Dtool_CInterval_get_class_type_83, METH_NOARGS | METH_STATIC, (const char *)Dtool_CInterval_get_class_type_83_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     CInterval
//////////////////
static PyObject *Dtool_Repr_CInterval(PyObject *self) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     CInterval
//////////////////
static PyObject *Dtool_Str_CInterval(PyObject *self) {
  CInterval *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_CInterval[] = {
  {(char *)"name", &Dtool_CInterval_name_Getter, NULL, NULL, NULL},
  {(char *)"duration", &Dtool_CInterval_duration_Getter, NULL, NULL, NULL},
  {(char *)"open_ended", &Dtool_CInterval_open_ended_Getter, NULL, NULL, NULL},
  {(char *)"state", &Dtool_CInterval_state_Getter, NULL, NULL, NULL},
  {(char *)"stopped", &Dtool_CInterval_stopped_Getter, NULL, NULL, NULL},
  {(char *)"done_event", &Dtool_CInterval_done_event_Getter, &Dtool_CInterval_done_event_Setter, NULL, NULL},
  {(char *)"t", &Dtool_CInterval_t_Getter, &Dtool_CInterval_t_Setter, NULL, NULL},
  {(char *)"auto_pause", &Dtool_CInterval_auto_pause_Getter, &Dtool_CInterval_auto_pause_Setter, NULL, NULL},
  {(char *)"auto_finish", &Dtool_CInterval_auto_finish_Getter, &Dtool_CInterval_auto_finish_Setter, NULL, NULL},
  {(char *)"manager", &Dtool_CInterval_manager_Getter, &Dtool_CInterval_manager_Setter, NULL, NULL},
  {(char *)"play_rate", &Dtool_CInterval_play_rate_Getter, &Dtool_CInterval_play_rate_Setter, NULL, NULL},
  {(char *)"playing", &Dtool_CInterval_playing_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CInterval = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CInterval = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CInterval = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CInterval = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CInterval = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.CInterval",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CInterval,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_CInterval,
    &Dtool_NumberMethods_CInterval,
    &Dtool_SequenceMethods_CInterval,
    &Dtool_MappingMethods_CInterval,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_CInterval,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The base class for timeline components.  A CInterval represents a single\n"
    " * action, event, or collection of nested intervals that will be performed at\n"
    " * some specific time or over a period of time.\n"
    " *\n"
    " * This is essentially similar to the Python \"Interval\" class, but it is\n"
    " * implemented in C++ (hence the name). Intervals that may be implemented in\n"
    " * C++ will inherit from this class; Intervals that must be implemented in\n"
    " * Python will inherit from the similar Python class.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CInterval,
    0, // tp_members
    Dtool_Properties_CInterval,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CInterval,
    PyType_GenericAlloc,
    Dtool_new_CInterval,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CInterval,
  Dtool_UpcastInterface_CInterval,
  Dtool_DowncastInterface_CInterval,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_CInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = _PyDict_NewPresized(25);
    Dtool_CInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum CInterval::EventType;
    PyDict_SetItemString(dict, "ET_initialize", Dtool_WrapValue(CInterval::ET_initialize));
    PyDict_SetItemString(dict, "ETInitialize", Dtool_WrapValue(CInterval::ET_initialize));
    PyDict_SetItemString(dict, "ET_instant", Dtool_WrapValue(CInterval::ET_instant));
    PyDict_SetItemString(dict, "ETInstant", Dtool_WrapValue(CInterval::ET_instant));
    PyDict_SetItemString(dict, "ET_step", Dtool_WrapValue(CInterval::ET_step));
    PyDict_SetItemString(dict, "ETStep", Dtool_WrapValue(CInterval::ET_step));
    PyDict_SetItemString(dict, "ET_finalize", Dtool_WrapValue(CInterval::ET_finalize));
    PyDict_SetItemString(dict, "ETFinalize", Dtool_WrapValue(CInterval::ET_finalize));
    PyDict_SetItemString(dict, "ET_reverse_initialize", Dtool_WrapValue(CInterval::ET_reverse_initialize));
    PyDict_SetItemString(dict, "ETReverseInitialize", Dtool_WrapValue(CInterval::ET_reverse_initialize));
    PyDict_SetItemString(dict, "ET_reverse_instant", Dtool_WrapValue(CInterval::ET_reverse_instant));
    PyDict_SetItemString(dict, "ETReverseInstant", Dtool_WrapValue(CInterval::ET_reverse_instant));
    PyDict_SetItemString(dict, "ET_reverse_finalize", Dtool_WrapValue(CInterval::ET_reverse_finalize));
    PyDict_SetItemString(dict, "ETReverseFinalize", Dtool_WrapValue(CInterval::ET_reverse_finalize));
    PyDict_SetItemString(dict, "ET_interrupt", Dtool_WrapValue(CInterval::ET_interrupt));
    PyDict_SetItemString(dict, "ETInterrupt", Dtool_WrapValue(CInterval::ET_interrupt));
    // enum CInterval::State;
    PyDict_SetItemString(dict, "S_initial", Dtool_WrapValue(CInterval::S_initial));
    PyDict_SetItemString(dict, "SInitial", Dtool_WrapValue(CInterval::S_initial));
    PyDict_SetItemString(dict, "S_started", Dtool_WrapValue(CInterval::S_started));
    PyDict_SetItemString(dict, "SStarted", Dtool_WrapValue(CInterval::S_started));
    PyDict_SetItemString(dict, "S_paused", Dtool_WrapValue(CInterval::S_paused));
    PyDict_SetItemString(dict, "SPaused", Dtool_WrapValue(CInterval::S_paused));
    PyDict_SetItemString(dict, "S_final", Dtool_WrapValue(CInterval::S_final));
    PyDict_SetItemString(dict, "SFinal", Dtool_WrapValue(CInterval::S_final));
    if (PyType_Ready((PyTypeObject *)&Dtool_CInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CInterval);
  }
}

/**
 * Python method tables for CIntervalManager (CIntervalManager)
 */
static PyMethodDef Dtool_Methods_CIntervalManager[] = {
  {"set_event_queue", &Dtool_CIntervalManager_set_event_queue_66, METH_O, (const char *)Dtool_CIntervalManager_set_event_queue_66_comment},
  {"setEventQueue", &Dtool_CIntervalManager_set_event_queue_66, METH_O, (const char *)Dtool_CIntervalManager_set_event_queue_66_comment},
  {"get_event_queue", &Dtool_CIntervalManager_get_event_queue_67, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_event_queue_67_comment},
  {"getEventQueue", &Dtool_CIntervalManager_get_event_queue_67, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_event_queue_67_comment},
  {"add_c_interval", (PyCFunction) &Dtool_CIntervalManager_add_c_interval_68, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CIntervalManager_add_c_interval_68_comment},
  {"addCInterval", (PyCFunction) &Dtool_CIntervalManager_add_c_interval_68, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CIntervalManager_add_c_interval_68_comment},
  {"find_c_interval", &Dtool_CIntervalManager_find_c_interval_69, METH_O, (const char *)Dtool_CIntervalManager_find_c_interval_69_comment},
  {"findCInterval", &Dtool_CIntervalManager_find_c_interval_69, METH_O, (const char *)Dtool_CIntervalManager_find_c_interval_69_comment},
  {"get_c_interval", &Dtool_CIntervalManager_get_c_interval_70, METH_O, (const char *)Dtool_CIntervalManager_get_c_interval_70_comment},
  {"getCInterval", &Dtool_CIntervalManager_get_c_interval_70, METH_O, (const char *)Dtool_CIntervalManager_get_c_interval_70_comment},
  {"remove_c_interval", &Dtool_CIntervalManager_remove_c_interval_71, METH_O, (const char *)Dtool_CIntervalManager_remove_c_interval_71_comment},
  {"removeCInterval", &Dtool_CIntervalManager_remove_c_interval_71, METH_O, (const char *)Dtool_CIntervalManager_remove_c_interval_71_comment},
  {"interrupt", &Dtool_CIntervalManager_interrupt_72, METH_NOARGS, (const char *)Dtool_CIntervalManager_interrupt_72_comment},
  {"get_num_intervals", &Dtool_CIntervalManager_get_num_intervals_73, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_num_intervals_73_comment},
  {"getNumIntervals", &Dtool_CIntervalManager_get_num_intervals_73, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_num_intervals_73_comment},
  {"get_max_index", &Dtool_CIntervalManager_get_max_index_74, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_max_index_74_comment},
  {"getMaxIndex", &Dtool_CIntervalManager_get_max_index_74, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_max_index_74_comment},
  {"step", &Dtool_CIntervalManager_step_75, METH_NOARGS, (const char *)Dtool_CIntervalManager_step_75_comment},
  {"get_next_event", &Dtool_CIntervalManager_get_next_event_76, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_next_event_76_comment},
  {"getNextEvent", &Dtool_CIntervalManager_get_next_event_76, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_next_event_76_comment},
  {"get_next_removal", &Dtool_CIntervalManager_get_next_removal_77, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_next_removal_77_comment},
  {"getNextRemoval", &Dtool_CIntervalManager_get_next_removal_77, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_next_removal_77_comment},
  {"output", &Dtool_CIntervalManager_output_78, METH_O, (const char *)Dtool_CIntervalManager_output_78_comment},
  {"write", &Dtool_CIntervalManager_write_79, METH_O, (const char *)Dtool_CIntervalManager_write_79_comment},
  {"get_global_ptr", &Dtool_CIntervalManager_get_global_ptr_80, METH_NOARGS | METH_STATIC, (const char *)Dtool_CIntervalManager_get_global_ptr_80_comment},
  {"getGlobalPtr", &Dtool_CIntervalManager_get_global_ptr_80, METH_NOARGS | METH_STATIC, (const char *)Dtool_CIntervalManager_get_global_ptr_80_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     CIntervalManager
//////////////////
static PyObject *Dtool_Repr_CIntervalManager(PyObject *self) {
  CIntervalManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CIntervalManager, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     CIntervalManager
//////////////////
static PyObject *Dtool_Str_CIntervalManager(PyObject *self) {
  CIntervalManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CIntervalManager, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_CIntervalManager = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_CIntervalManager = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.CIntervalManager",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CIntervalManager,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_CIntervalManager,
    &Dtool_NumberMethods_CIntervalManager,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_CIntervalManager,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This object holds a number of currently-playing intervals and is\n"
    " * responsible for advancing them each frame as needed.\n"
    " *\n"
    " * There is normally only one IntervalManager object in the world, and it is\n"
    " * the responsibility of the scripting language to call step() on this object\n"
    " * once each frame, and to then process the events indicated by\n"
    " * get_next_event().\n"
    " *\n"
    " * It is also possible to create multiple IntervalManager objects for special\n"
    " * needs.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CIntervalManager,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CIntervalManager,
    PyType_GenericAlloc,
    Dtool_new_CIntervalManager,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CIntervalManager,
  Dtool_UpcastInterface_CIntervalManager,
  Dtool_DowncastInterface_CIntervalManager,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CIntervalManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_CIntervalManager._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_CIntervalManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CIntervalManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CIntervalManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CIntervalManager);
  }
}

/**
 * Python method tables for CConstraintInterval (CConstraintInterval)
 */
static PyMethodDef Dtool_Methods_CConstraintInterval[] = {
  {"get_class_type", &Dtool_CConstraintInterval_get_class_type_89, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstraintInterval_get_class_type_89_comment},
  {"getClassType", &Dtool_CConstraintInterval_get_class_type_89, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstraintInterval_get_class_type_89_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_CConstraintInterval[] = {
  {(char *)"bogus_variable", &Dtool_CConstraintInterval_bogus_variable_Getter, &Dtool_CConstraintInterval_bogus_variable_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CConstraintInterval = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CConstraintInterval = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CConstraintInterval = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CConstraintInterval = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CConstraintInterval = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.CConstraintInterval",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CConstraintInterval,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CConstraintInterval,
    &Dtool_SequenceMethods_CConstraintInterval,
    &Dtool_MappingMethods_CConstraintInterval,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CConstraintInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The base class for a family of intervals that constrain some property to a\n"
    " * value over time.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CConstraintInterval,
    0, // tp_members
    Dtool_Properties_CConstraintInterval,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CConstraintInterval,
    PyType_GenericAlloc,
    Dtool_new_CConstraintInterval,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CConstraintInterval,
  Dtool_UpcastInterface_CConstraintInterval,
  Dtool_DowncastInterface_CConstraintInterval,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CConstraintInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CInterval(NULL);
    Dtool_CConstraintInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CInterval);
    PyObject *dict = PyDict_New();
    Dtool_CConstraintInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CConstraintInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CConstraintInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CConstraintInterval);
  }
}

/**
 * Python method tables for CConstrainHprInterval (CConstrainHprInterval)
 */
static PyMethodDef Dtool_Methods_CConstrainHprInterval[] = {
  {"get_node", &Dtool_CConstrainHprInterval_get_node_94, METH_NOARGS, (const char *)Dtool_CConstrainHprInterval_get_node_94_comment},
  {"getNode", &Dtool_CConstrainHprInterval_get_node_94, METH_NOARGS, (const char *)Dtool_CConstrainHprInterval_get_node_94_comment},
  {"get_target", &Dtool_CConstrainHprInterval_get_target_95, METH_NOARGS, (const char *)Dtool_CConstrainHprInterval_get_target_95_comment},
  {"getTarget", &Dtool_CConstrainHprInterval_get_target_95, METH_NOARGS, (const char *)Dtool_CConstrainHprInterval_get_target_95_comment},
  {"get_class_type", &Dtool_CConstrainHprInterval_get_class_type_96, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstrainHprInterval_get_class_type_96_comment},
  {"getClassType", &Dtool_CConstrainHprInterval_get_class_type_96, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstrainHprInterval_get_class_type_96_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CConstrainHprInterval = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CConstrainHprInterval = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CConstrainHprInterval = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CConstrainHprInterval = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CConstrainHprInterval = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.CConstrainHprInterval",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CConstrainHprInterval,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CConstrainHprInterval,
    &Dtool_SequenceMethods_CConstrainHprInterval,
    &Dtool_MappingMethods_CConstrainHprInterval,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CConstrainHprInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A constraint interval that will constrain the orientation of one node to\n"
    " * the orientation of another.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CConstrainHprInterval,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CConstrainHprInterval,
    PyType_GenericAlloc,
    Dtool_new_CConstrainHprInterval,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CConstrainHprInterval,
  Dtool_UpcastInterface_CConstrainHprInterval,
  Dtool_DowncastInterface_CConstrainHprInterval,
  (CoerceFunction)Dtool_ConstCoerce_CConstrainHprInterval,
  (CoerceFunction)Dtool_Coerce_CConstrainHprInterval,
};

static void Dtool_PyModuleClassInit_CConstrainHprInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CConstraintInterval(NULL);
    Dtool_CConstrainHprInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CConstraintInterval);
    PyObject *dict = PyDict_New();
    Dtool_CConstrainHprInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CConstrainHprInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CConstrainHprInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CConstrainHprInterval);
  }
}

/**
 * Python method tables for CConstrainPosHprInterval (CConstrainPosHprInterval)
 */
static PyMethodDef Dtool_Methods_CConstrainPosHprInterval[] = {
  {"get_node", &Dtool_CConstrainPosHprInterval_get_node_100, METH_NOARGS, (const char *)Dtool_CConstrainPosHprInterval_get_node_100_comment},
  {"getNode", &Dtool_CConstrainPosHprInterval_get_node_100, METH_NOARGS, (const char *)Dtool_CConstrainPosHprInterval_get_node_100_comment},
  {"get_target", &Dtool_CConstrainPosHprInterval_get_target_101, METH_NOARGS, (const char *)Dtool_CConstrainPosHprInterval_get_target_101_comment},
  {"getTarget", &Dtool_CConstrainPosHprInterval_get_target_101, METH_NOARGS, (const char *)Dtool_CConstrainPosHprInterval_get_target_101_comment},
  {"get_class_type", &Dtool_CConstrainPosHprInterval_get_class_type_102, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstrainPosHprInterval_get_class_type_102_comment},
  {"getClassType", &Dtool_CConstrainPosHprInterval_get_class_type_102, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstrainPosHprInterval_get_class_type_102_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CConstrainPosHprInterval = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CConstrainPosHprInterval = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CConstrainPosHprInterval = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CConstrainPosHprInterval = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CConstrainPosHprInterval = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.CConstrainPosHprInterval",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CConstrainPosHprInterval,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CConstrainPosHprInterval,
    &Dtool_SequenceMethods_CConstrainPosHprInterval,
    &Dtool_MappingMethods_CConstrainPosHprInterval,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CConstrainPosHprInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A constraint interval that will constrain the position and orientation of\n"
    " * one node to the position and orientation of another.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CConstrainPosHprInterval,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CConstrainPosHprInterval,
    PyType_GenericAlloc,
    Dtool_new_CConstrainPosHprInterval,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CConstrainPosHprInterval,
  Dtool_UpcastInterface_CConstrainPosHprInterval,
  Dtool_DowncastInterface_CConstrainPosHprInterval,
  (CoerceFunction)Dtool_ConstCoerce_CConstrainPosHprInterval,
  (CoerceFunction)Dtool_Coerce_CConstrainPosHprInterval,
};

static void Dtool_PyModuleClassInit_CConstrainPosHprInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CConstraintInterval(NULL);
    Dtool_CConstrainPosHprInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CConstraintInterval);
    PyObject *dict = PyDict_New();
    Dtool_CConstrainPosHprInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CConstrainPosHprInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CConstrainPosHprInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CConstrainPosHprInterval);
  }
}

/**
 * Python method tables for CConstrainPosInterval (CConstrainPosInterval)
 */
static PyMethodDef Dtool_Methods_CConstrainPosInterval[] = {
  {"get_node", &Dtool_CConstrainPosInterval_get_node_106, METH_NOARGS, (const char *)Dtool_CConstrainPosInterval_get_node_106_comment},
  {"getNode", &Dtool_CConstrainPosInterval_get_node_106, METH_NOARGS, (const char *)Dtool_CConstrainPosInterval_get_node_106_comment},
  {"get_target", &Dtool_CConstrainPosInterval_get_target_107, METH_NOARGS, (const char *)Dtool_CConstrainPosInterval_get_target_107_comment},
  {"getTarget", &Dtool_CConstrainPosInterval_get_target_107, METH_NOARGS, (const char *)Dtool_CConstrainPosInterval_get_target_107_comment},
  {"get_class_type", &Dtool_CConstrainPosInterval_get_class_type_108, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstrainPosInterval_get_class_type_108_comment},
  {"getClassType", &Dtool_CConstrainPosInterval_get_class_type_108, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstrainPosInterval_get_class_type_108_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CConstrainPosInterval = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CConstrainPosInterval = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CConstrainPosInterval = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CConstrainPosInterval = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CConstrainPosInterval = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.CConstrainPosInterval",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CConstrainPosInterval,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CConstrainPosInterval,
    &Dtool_SequenceMethods_CConstrainPosInterval,
    &Dtool_MappingMethods_CConstrainPosInterval,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CConstrainPosInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A constraint interval that will constrain the position of one node to the\n"
    " * position of another.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CConstrainPosInterval,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CConstrainPosInterval,
    PyType_GenericAlloc,
    Dtool_new_CConstrainPosInterval,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CConstrainPosInterval,
  Dtool_UpcastInterface_CConstrainPosInterval,
  Dtool_DowncastInterface_CConstrainPosInterval,
  (CoerceFunction)Dtool_ConstCoerce_CConstrainPosInterval,
  (CoerceFunction)Dtool_Coerce_CConstrainPosInterval,
};

static void Dtool_PyModuleClassInit_CConstrainPosInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CConstraintInterval(NULL);
    Dtool_CConstrainPosInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CConstraintInterval);
    PyObject *dict = PyDict_New();
    Dtool_CConstrainPosInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CConstrainPosInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CConstrainPosInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CConstrainPosInterval);
  }
}

/**
 * Python method tables for CConstrainTransformInterval (CConstrainTransformInterval)
 */
static PyMethodDef Dtool_Methods_CConstrainTransformInterval[] = {
  {"get_node", &Dtool_CConstrainTransformInterval_get_node_112, METH_NOARGS, (const char *)Dtool_CConstrainTransformInterval_get_node_112_comment},
  {"getNode", &Dtool_CConstrainTransformInterval_get_node_112, METH_NOARGS, (const char *)Dtool_CConstrainTransformInterval_get_node_112_comment},
  {"get_target", &Dtool_CConstrainTransformInterval_get_target_113, METH_NOARGS, (const char *)Dtool_CConstrainTransformInterval_get_target_113_comment},
  {"getTarget", &Dtool_CConstrainTransformInterval_get_target_113, METH_NOARGS, (const char *)Dtool_CConstrainTransformInterval_get_target_113_comment},
  {"get_class_type", &Dtool_CConstrainTransformInterval_get_class_type_114, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstrainTransformInterval_get_class_type_114_comment},
  {"getClassType", &Dtool_CConstrainTransformInterval_get_class_type_114, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstrainTransformInterval_get_class_type_114_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CConstrainTransformInterval = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CConstrainTransformInterval = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CConstrainTransformInterval = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CConstrainTransformInterval = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CConstrainTransformInterval = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.CConstrainTransformInterval",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CConstrainTransformInterval,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CConstrainTransformInterval,
    &Dtool_SequenceMethods_CConstrainTransformInterval,
    &Dtool_MappingMethods_CConstrainTransformInterval,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CConstrainTransformInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A constraint interval that will constrain the transform of one node to the\n"
    " * transform of another.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CConstrainTransformInterval,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CConstrainTransformInterval,
    PyType_GenericAlloc,
    Dtool_new_CConstrainTransformInterval,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CConstrainTransformInterval,
  Dtool_UpcastInterface_CConstrainTransformInterval,
  Dtool_DowncastInterface_CConstrainTransformInterval,
  (CoerceFunction)Dtool_ConstCoerce_CConstrainTransformInterval,
  (CoerceFunction)Dtool_Coerce_CConstrainTransformInterval,
};

static void Dtool_PyModuleClassInit_CConstrainTransformInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CConstraintInterval(NULL);
    Dtool_CConstrainTransformInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CConstraintInterval);
    PyObject *dict = PyDict_New();
    Dtool_CConstrainTransformInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CConstrainTransformInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CConstrainTransformInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CConstrainTransformInterval);
  }
}

/**
 * Python method tables for CLerpInterval (CLerpInterval)
 */
static PyMethodDef Dtool_Methods_CLerpInterval[] = {
  {"get_blend_type", &Dtool_CLerpInterval_get_blend_type_118, METH_NOARGS, (const char *)Dtool_CLerpInterval_get_blend_type_118_comment},
  {"getBlendType", &Dtool_CLerpInterval_get_blend_type_118, METH_NOARGS, (const char *)Dtool_CLerpInterval_get_blend_type_118_comment},
  {"string_blend_type", &Dtool_CLerpInterval_string_blend_type_119, METH_O | METH_STATIC, (const char *)Dtool_CLerpInterval_string_blend_type_119_comment},
  {"stringBlendType", &Dtool_CLerpInterval_string_blend_type_119, METH_O | METH_STATIC, (const char *)Dtool_CLerpInterval_string_blend_type_119_comment},
  {"get_class_type", &Dtool_CLerpInterval_get_class_type_120, METH_NOARGS | METH_STATIC, (const char *)Dtool_CLerpInterval_get_class_type_120_comment},
  {"getClassType", &Dtool_CLerpInterval_get_class_type_120, METH_NOARGS | METH_STATIC, (const char *)Dtool_CLerpInterval_get_class_type_120_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CLerpInterval = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CLerpInterval = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CLerpInterval = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CLerpInterval = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CLerpInterval = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.CLerpInterval",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CLerpInterval,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CLerpInterval,
    &Dtool_SequenceMethods_CLerpInterval,
    &Dtool_MappingMethods_CLerpInterval,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CLerpInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The base class for a family of intervals that linearly interpolate one or\n"
    " * more numeric values over time.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CLerpInterval,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CLerpInterval,
    PyType_GenericAlloc,
    Dtool_new_CLerpInterval,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CLerpInterval,
  Dtool_UpcastInterface_CLerpInterval,
  Dtool_DowncastInterface_CLerpInterval,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CLerpInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CInterval(NULL);
    Dtool_CLerpInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CInterval);
    PyObject *dict = _PyDict_NewPresized(11);
    Dtool_CLerpInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum CLerpInterval::BlendType;
    PyDict_SetItemString(dict, "BT_no_blend", Dtool_WrapValue(CLerpInterval::BT_no_blend));
    PyDict_SetItemString(dict, "BTNoBlend", Dtool_WrapValue(CLerpInterval::BT_no_blend));
    PyDict_SetItemString(dict, "BT_ease_in", Dtool_WrapValue(CLerpInterval::BT_ease_in));
    PyDict_SetItemString(dict, "BTEaseIn", Dtool_WrapValue(CLerpInterval::BT_ease_in));
    PyDict_SetItemString(dict, "BT_ease_out", Dtool_WrapValue(CLerpInterval::BT_ease_out));
    PyDict_SetItemString(dict, "BTEaseOut", Dtool_WrapValue(CLerpInterval::BT_ease_out));
    PyDict_SetItemString(dict, "BT_ease_in_out", Dtool_WrapValue(CLerpInterval::BT_ease_in_out));
    PyDict_SetItemString(dict, "BTEaseInOut", Dtool_WrapValue(CLerpInterval::BT_ease_in_out));
    PyDict_SetItemString(dict, "BT_invalid", Dtool_WrapValue(CLerpInterval::BT_invalid));
    PyDict_SetItemString(dict, "BTInvalid", Dtool_WrapValue(CLerpInterval::BT_invalid));
    if (PyType_Ready((PyTypeObject *)&Dtool_CLerpInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CLerpInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CLerpInterval);
  }
}

/**
 * Python method tables for CLerpAnimEffectInterval (CLerpAnimEffectInterval)
 */
static PyMethodDef Dtool_Methods_CLerpAnimEffectInterval[] = {
  {"add_control", (PyCFunction) &Dtool_CLerpAnimEffectInterval_add_control_125, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CLerpAnimEffectInterval_add_control_125_comment},
  {"addControl", (PyCFunction) &Dtool_CLerpAnimEffectInterval_add_control_125, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CLerpAnimEffectInterval_add_control_125_comment},
  {"get_class_type", &Dtool_CLerpAnimEffectInterval_get_class_type_126, METH_NOARGS | METH_STATIC, (const char *)Dtool_CLerpAnimEffectInterval_get_class_type_126_comment},
  {"getClassType", &Dtool_CLerpAnimEffectInterval_get_class_type_126, METH_NOARGS | METH_STATIC, (const char *)Dtool_CLerpAnimEffectInterval_get_class_type_126_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CLerpAnimEffectInterval = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CLerpAnimEffectInterval = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CLerpAnimEffectInterval = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CLerpAnimEffectInterval = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CLerpAnimEffectInterval = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.CLerpAnimEffectInterval",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CLerpAnimEffectInterval,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CLerpAnimEffectInterval,
    &Dtool_SequenceMethods_CLerpAnimEffectInterval,
    &Dtool_MappingMethods_CLerpAnimEffectInterval,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CLerpAnimEffectInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This interval lerps between different amounts of control effects for\n"
    " * various AnimControls that might be playing on an actor.  It's used to\n"
    " * change the blending amount between multiple animations.\n"
    " *\n"
    " * The idea is to start all the animations playing first, then use a\n"
    " * CLerpAnimEffectInterval to adjust the degree to which each animation\n"
    " * affects the actor.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CLerpAnimEffectInterval,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CLerpAnimEffectInterval,
    PyType_GenericAlloc,
    Dtool_new_CLerpAnimEffectInterval,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CLerpAnimEffectInterval,
  Dtool_UpcastInterface_CLerpAnimEffectInterval,
  Dtool_DowncastInterface_CLerpAnimEffectInterval,
  (CoerceFunction)Dtool_ConstCoerce_CLerpAnimEffectInterval,
  (CoerceFunction)Dtool_Coerce_CLerpAnimEffectInterval,
};

static void Dtool_PyModuleClassInit_CLerpAnimEffectInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CLerpInterval(NULL);
    Dtool_CLerpAnimEffectInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CLerpInterval);
    PyObject *dict = PyDict_New();
    Dtool_CLerpAnimEffectInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CLerpAnimEffectInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CLerpAnimEffectInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CLerpAnimEffectInterval);
  }
}

/**
 * Python method tables for CLerpNodePathInterval (CLerpNodePathInterval)
 */
static PyMethodDef Dtool_Methods_CLerpNodePathInterval[] = {
  {"get_node", &Dtool_CLerpNodePathInterval_get_node_130, METH_NOARGS, (const char *)Dtool_CLerpNodePathInterval_get_node_130_comment},
  {"getNode", &Dtool_CLerpNodePathInterval_get_node_130, METH_NOARGS, (const char *)Dtool_CLerpNodePathInterval_get_node_130_comment},
  {"get_other", &Dtool_CLerpNodePathInterval_get_other_131, METH_NOARGS, (const char *)Dtool_CLerpNodePathInterval_get_other_131_comment},
  {"getOther", &Dtool_CLerpNodePathInterval_get_other_131, METH_NOARGS, (const char *)Dtool_CLerpNodePathInterval_get_other_131_comment},
  {"set_start_pos", &Dtool_CLerpNodePathInterval_set_start_pos_132, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_pos_132_comment},
  {"setStartPos", &Dtool_CLerpNodePathInterval_set_start_pos_132, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_pos_132_comment},
  {"set_end_pos", &Dtool_CLerpNodePathInterval_set_end_pos_133, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_pos_133_comment},
  {"setEndPos", &Dtool_CLerpNodePathInterval_set_end_pos_133, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_pos_133_comment},
  {"set_start_hpr", &Dtool_CLerpNodePathInterval_set_start_hpr_134, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_hpr_134_comment},
  {"setStartHpr", &Dtool_CLerpNodePathInterval_set_start_hpr_134, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_hpr_134_comment},
  {"set_end_hpr", &Dtool_CLerpNodePathInterval_set_end_hpr_135, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_hpr_135_comment},
  {"setEndHpr", &Dtool_CLerpNodePathInterval_set_end_hpr_135, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_hpr_135_comment},
  {"set_start_quat", &Dtool_CLerpNodePathInterval_set_start_quat_136, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_quat_136_comment},
  {"setStartQuat", &Dtool_CLerpNodePathInterval_set_start_quat_136, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_quat_136_comment},
  {"set_end_quat", &Dtool_CLerpNodePathInterval_set_end_quat_137, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_quat_137_comment},
  {"setEndQuat", &Dtool_CLerpNodePathInterval_set_end_quat_137, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_quat_137_comment},
  {"set_start_scale", &Dtool_CLerpNodePathInterval_set_start_scale_138, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_scale_138_comment},
  {"setStartScale", &Dtool_CLerpNodePathInterval_set_start_scale_138, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_scale_138_comment},
  {"set_end_scale", &Dtool_CLerpNodePathInterval_set_end_scale_139, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_scale_139_comment},
  {"setEndScale", &Dtool_CLerpNodePathInterval_set_end_scale_139, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_scale_139_comment},
  {"set_start_shear", &Dtool_CLerpNodePathInterval_set_start_shear_140, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_shear_140_comment},
  {"setStartShear", &Dtool_CLerpNodePathInterval_set_start_shear_140, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_shear_140_comment},
  {"set_end_shear", &Dtool_CLerpNodePathInterval_set_end_shear_141, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_shear_141_comment},
  {"setEndShear", &Dtool_CLerpNodePathInterval_set_end_shear_141, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_shear_141_comment},
  {"set_start_color", &Dtool_CLerpNodePathInterval_set_start_color_142, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_color_142_comment},
  {"setStartColor", &Dtool_CLerpNodePathInterval_set_start_color_142, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_color_142_comment},
  {"set_end_color", &Dtool_CLerpNodePathInterval_set_end_color_143, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_color_143_comment},
  {"setEndColor", &Dtool_CLerpNodePathInterval_set_end_color_143, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_color_143_comment},
  {"set_start_color_scale", &Dtool_CLerpNodePathInterval_set_start_color_scale_144, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_color_scale_144_comment},
  {"setStartColorScale", &Dtool_CLerpNodePathInterval_set_start_color_scale_144, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_color_scale_144_comment},
  {"set_end_color_scale", &Dtool_CLerpNodePathInterval_set_end_color_scale_145, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_color_scale_145_comment},
  {"setEndColorScale", &Dtool_CLerpNodePathInterval_set_end_color_scale_145, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_color_scale_145_comment},
  {"set_texture_stage", &Dtool_CLerpNodePathInterval_set_texture_stage_146, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_texture_stage_146_comment},
  {"setTextureStage", &Dtool_CLerpNodePathInterval_set_texture_stage_146, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_texture_stage_146_comment},
  {"set_start_tex_offset", &Dtool_CLerpNodePathInterval_set_start_tex_offset_147, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_tex_offset_147_comment},
  {"setStartTexOffset", &Dtool_CLerpNodePathInterval_set_start_tex_offset_147, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_tex_offset_147_comment},
  {"set_end_tex_offset", &Dtool_CLerpNodePathInterval_set_end_tex_offset_148, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_tex_offset_148_comment},
  {"setEndTexOffset", &Dtool_CLerpNodePathInterval_set_end_tex_offset_148, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_tex_offset_148_comment},
  {"set_start_tex_rotate", &Dtool_CLerpNodePathInterval_set_start_tex_rotate_149, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_tex_rotate_149_comment},
  {"setStartTexRotate", &Dtool_CLerpNodePathInterval_set_start_tex_rotate_149, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_tex_rotate_149_comment},
  {"set_end_tex_rotate", &Dtool_CLerpNodePathInterval_set_end_tex_rotate_150, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_tex_rotate_150_comment},
  {"setEndTexRotate", &Dtool_CLerpNodePathInterval_set_end_tex_rotate_150, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_tex_rotate_150_comment},
  {"set_start_tex_scale", &Dtool_CLerpNodePathInterval_set_start_tex_scale_151, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_tex_scale_151_comment},
  {"setStartTexScale", &Dtool_CLerpNodePathInterval_set_start_tex_scale_151, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_tex_scale_151_comment},
  {"set_end_tex_scale", &Dtool_CLerpNodePathInterval_set_end_tex_scale_152, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_tex_scale_152_comment},
  {"setEndTexScale", &Dtool_CLerpNodePathInterval_set_end_tex_scale_152, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_tex_scale_152_comment},
  {"set_override", &Dtool_CLerpNodePathInterval_set_override_153, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_override_153_comment},
  {"setOverride", &Dtool_CLerpNodePathInterval_set_override_153, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_override_153_comment},
  {"get_override", &Dtool_CLerpNodePathInterval_get_override_154, METH_NOARGS, (const char *)Dtool_CLerpNodePathInterval_get_override_154_comment},
  {"getOverride", &Dtool_CLerpNodePathInterval_get_override_154, METH_NOARGS, (const char *)Dtool_CLerpNodePathInterval_get_override_154_comment},
  {"get_class_type", &Dtool_CLerpNodePathInterval_get_class_type_155, METH_NOARGS | METH_STATIC, (const char *)Dtool_CLerpNodePathInterval_get_class_type_155_comment},
  {"getClassType", &Dtool_CLerpNodePathInterval_get_class_type_155, METH_NOARGS | METH_STATIC, (const char *)Dtool_CLerpNodePathInterval_get_class_type_155_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CLerpNodePathInterval = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CLerpNodePathInterval = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CLerpNodePathInterval = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CLerpNodePathInterval = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CLerpNodePathInterval = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.CLerpNodePathInterval",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CLerpNodePathInterval,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CLerpNodePathInterval,
    &Dtool_SequenceMethods_CLerpNodePathInterval,
    &Dtool_MappingMethods_CLerpNodePathInterval,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CLerpNodePathInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An interval that lerps one or more properties (like pos, hpr, etc.) on a\n"
    " * NodePath over time.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CLerpNodePathInterval,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CLerpNodePathInterval,
    PyType_GenericAlloc,
    Dtool_new_CLerpNodePathInterval,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CLerpNodePathInterval,
  Dtool_UpcastInterface_CLerpNodePathInterval,
  Dtool_DowncastInterface_CLerpNodePathInterval,
  (CoerceFunction)Dtool_ConstCoerce_CLerpNodePathInterval,
  (CoerceFunction)Dtool_Coerce_CLerpNodePathInterval,
};

static void Dtool_PyModuleClassInit_CLerpNodePathInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CLerpInterval(NULL);
    Dtool_CLerpNodePathInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CLerpInterval);
    PyObject *dict = PyDict_New();
    Dtool_CLerpNodePathInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CLerpNodePathInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CLerpNodePathInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CLerpNodePathInterval);
  }
}

/**
 * Python method tables for CMetaInterval (CMetaInterval)
 */
static PyMethodDef Dtool_Methods_CMetaInterval[] = {
  {"set_precision", &Dtool_CMetaInterval_set_precision_160, METH_O, (const char *)Dtool_CMetaInterval_set_precision_160_comment},
  {"setPrecision", &Dtool_CMetaInterval_set_precision_160, METH_O, (const char *)Dtool_CMetaInterval_set_precision_160_comment},
  {"get_precision", &Dtool_CMetaInterval_get_precision_161, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_precision_161_comment},
  {"getPrecision", &Dtool_CMetaInterval_get_precision_161, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_precision_161_comment},
  {"clear_intervals", &Dtool_CMetaInterval_clear_intervals_162, METH_NOARGS, (const char *)Dtool_CMetaInterval_clear_intervals_162_comment},
  {"clearIntervals", &Dtool_CMetaInterval_clear_intervals_162, METH_NOARGS, (const char *)Dtool_CMetaInterval_clear_intervals_162_comment},
  {"push_level", (PyCFunction) &Dtool_CMetaInterval_push_level_163, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_push_level_163_comment},
  {"pushLevel", (PyCFunction) &Dtool_CMetaInterval_push_level_163, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_push_level_163_comment},
  {"add_c_interval", (PyCFunction) &Dtool_CMetaInterval_add_c_interval_164, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_add_c_interval_164_comment},
  {"addCInterval", (PyCFunction) &Dtool_CMetaInterval_add_c_interval_164, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_add_c_interval_164_comment},
  {"add_ext_index", (PyCFunction) &Dtool_CMetaInterval_add_ext_index_165, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_add_ext_index_165_comment},
  {"addExtIndex", (PyCFunction) &Dtool_CMetaInterval_add_ext_index_165, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_add_ext_index_165_comment},
  {"pop_level", (PyCFunction) &Dtool_CMetaInterval_pop_level_166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_pop_level_166_comment},
  {"popLevel", (PyCFunction) &Dtool_CMetaInterval_pop_level_166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_pop_level_166_comment},
  {"set_interval_start_time", (PyCFunction) &Dtool_CMetaInterval_set_interval_start_time_167, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_set_interval_start_time_167_comment},
  {"setIntervalStartTime", (PyCFunction) &Dtool_CMetaInterval_set_interval_start_time_167, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_set_interval_start_time_167_comment},
  {"get_interval_start_time", &Dtool_CMetaInterval_get_interval_start_time_168, METH_O, (const char *)Dtool_CMetaInterval_get_interval_start_time_168_comment},
  {"getIntervalStartTime", &Dtool_CMetaInterval_get_interval_start_time_168, METH_O, (const char *)Dtool_CMetaInterval_get_interval_start_time_168_comment},
  {"get_interval_end_time", &Dtool_CMetaInterval_get_interval_end_time_169, METH_O, (const char *)Dtool_CMetaInterval_get_interval_end_time_169_comment},
  {"getIntervalEndTime", &Dtool_CMetaInterval_get_interval_end_time_169, METH_O, (const char *)Dtool_CMetaInterval_get_interval_end_time_169_comment},
  {"get_num_defs", &Dtool_CMetaInterval_get_num_defs_171, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_num_defs_171_comment},
  {"getNumDefs", &Dtool_CMetaInterval_get_num_defs_171, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_num_defs_171_comment},
  {"get_def_type", &Dtool_CMetaInterval_get_def_type_172, METH_O, (const char *)Dtool_CMetaInterval_get_def_type_172_comment},
  {"getDefType", &Dtool_CMetaInterval_get_def_type_172, METH_O, (const char *)Dtool_CMetaInterval_get_def_type_172_comment},
  {"get_c_interval", &Dtool_CMetaInterval_get_c_interval_173, METH_O, (const char *)Dtool_CMetaInterval_get_c_interval_173_comment},
  {"getCInterval", &Dtool_CMetaInterval_get_c_interval_173, METH_O, (const char *)Dtool_CMetaInterval_get_c_interval_173_comment},
  {"get_ext_index", &Dtool_CMetaInterval_get_ext_index_174, METH_O, (const char *)Dtool_CMetaInterval_get_ext_index_174_comment},
  {"getExtIndex", &Dtool_CMetaInterval_get_ext_index_174, METH_O, (const char *)Dtool_CMetaInterval_get_ext_index_174_comment},
  {"is_event_ready", &Dtool_CMetaInterval_is_event_ready_175, METH_NOARGS, (const char *)Dtool_CMetaInterval_is_event_ready_175_comment},
  {"isEventReady", &Dtool_CMetaInterval_is_event_ready_175, METH_NOARGS, (const char *)Dtool_CMetaInterval_is_event_ready_175_comment},
  {"get_event_index", &Dtool_CMetaInterval_get_event_index_176, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_event_index_176_comment},
  {"getEventIndex", &Dtool_CMetaInterval_get_event_index_176, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_event_index_176_comment},
  {"get_event_t", &Dtool_CMetaInterval_get_event_t_177, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_event_t_177_comment},
  {"getEventT", &Dtool_CMetaInterval_get_event_t_177, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_event_t_177_comment},
  {"get_event_type", &Dtool_CMetaInterval_get_event_type_178, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_event_type_178_comment},
  {"getEventType", &Dtool_CMetaInterval_get_event_type_178, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_event_type_178_comment},
  {"pop_event", &Dtool_CMetaInterval_pop_event_179, METH_NOARGS, (const char *)Dtool_CMetaInterval_pop_event_179_comment},
  {"popEvent", &Dtool_CMetaInterval_pop_event_179, METH_NOARGS, (const char *)Dtool_CMetaInterval_pop_event_179_comment},
  {"timeline", &Dtool_CMetaInterval_timeline_180, METH_O, (const char *)Dtool_CMetaInterval_timeline_180_comment},
  {"get_class_type", &Dtool_CMetaInterval_get_class_type_181, METH_NOARGS | METH_STATIC, (const char *)Dtool_CMetaInterval_get_class_type_181_comment},
  {"getClassType", &Dtool_CMetaInterval_get_class_type_181, METH_NOARGS | METH_STATIC, (const char *)Dtool_CMetaInterval_get_class_type_181_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CMetaInterval = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CMetaInterval = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CMetaInterval = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CMetaInterval = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CMetaInterval = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.CMetaInterval",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CMetaInterval,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CMetaInterval,
    &Dtool_SequenceMethods_CMetaInterval,
    &Dtool_MappingMethods_CMetaInterval,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CMetaInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This interval contains a list of nested intervals, each of which has its\n"
    " * own begin and end times.  Some of them may overlap and some of them may\n"
    " * not.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CMetaInterval,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CMetaInterval,
    PyType_GenericAlloc,
    Dtool_new_CMetaInterval,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CMetaInterval,
  Dtool_UpcastInterface_CMetaInterval,
  Dtool_DowncastInterface_CMetaInterval,
  (CoerceFunction)Dtool_ConstCoerce_CMetaInterval,
  (CoerceFunction)Dtool_Coerce_CMetaInterval,
};

static void Dtool_PyModuleClassInit_CMetaInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CInterval(NULL);
    Dtool_CMetaInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CInterval);
    PyObject *dict = _PyDict_NewPresized(15);
    Dtool_CMetaInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum CMetaInterval::RelativeStart;
    PyDict_SetItemString(dict, "RS_previous_end", Dtool_WrapValue(CMetaInterval::RS_previous_end));
    PyDict_SetItemString(dict, "RSPreviousEnd", Dtool_WrapValue(CMetaInterval::RS_previous_end));
    PyDict_SetItemString(dict, "RS_previous_begin", Dtool_WrapValue(CMetaInterval::RS_previous_begin));
    PyDict_SetItemString(dict, "RSPreviousBegin", Dtool_WrapValue(CMetaInterval::RS_previous_begin));
    PyDict_SetItemString(dict, "RS_level_begin", Dtool_WrapValue(CMetaInterval::RS_level_begin));
    PyDict_SetItemString(dict, "RSLevelBegin", Dtool_WrapValue(CMetaInterval::RS_level_begin));
    // enum CMetaInterval::DefType;
    PyDict_SetItemString(dict, "DT_c_interval", Dtool_WrapValue(CMetaInterval::DT_c_interval));
    PyDict_SetItemString(dict, "DTCInterval", Dtool_WrapValue(CMetaInterval::DT_c_interval));
    PyDict_SetItemString(dict, "DT_ext_index", Dtool_WrapValue(CMetaInterval::DT_ext_index));
    PyDict_SetItemString(dict, "DTExtIndex", Dtool_WrapValue(CMetaInterval::DT_ext_index));
    PyDict_SetItemString(dict, "DT_push_level", Dtool_WrapValue(CMetaInterval::DT_push_level));
    PyDict_SetItemString(dict, "DTPushLevel", Dtool_WrapValue(CMetaInterval::DT_push_level));
    PyDict_SetItemString(dict, "DT_pop_level", Dtool_WrapValue(CMetaInterval::DT_pop_level));
    PyDict_SetItemString(dict, "DTPopLevel", Dtool_WrapValue(CMetaInterval::DT_pop_level));
    if (PyType_Ready((PyTypeObject *)&Dtool_CMetaInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CMetaInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CMetaInterval);
  }
}

/**
 * Python method tables for HideInterval (HideInterval)
 */
static PyMethodDef Dtool_Methods_HideInterval[] = {
  {"get_class_type", &Dtool_HideInterval_get_class_type_184, METH_NOARGS | METH_STATIC, (const char *)Dtool_HideInterval_get_class_type_184_comment},
  {"getClassType", &Dtool_HideInterval_get_class_type_184, METH_NOARGS | METH_STATIC, (const char *)Dtool_HideInterval_get_class_type_184_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_HideInterval = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_HideInterval = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_HideInterval = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_HideInterval = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_HideInterval = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.HideInterval",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_HideInterval,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_HideInterval,
    &Dtool_SequenceMethods_HideInterval,
    &Dtool_MappingMethods_HideInterval,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_HideInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An interval that calls NodePath::hide().\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_HideInterval,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_HideInterval,
    PyType_GenericAlloc,
    Dtool_new_HideInterval,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_HideInterval,
  Dtool_UpcastInterface_HideInterval,
  Dtool_DowncastInterface_HideInterval,
  (CoerceFunction)Dtool_ConstCoerce_HideInterval,
  (CoerceFunction)Dtool_Coerce_HideInterval,
};

static void Dtool_PyModuleClassInit_HideInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CInterval(NULL);
    Dtool_HideInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CInterval);
    PyObject *dict = PyDict_New();
    Dtool_HideInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_HideInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(HideInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_HideInterval);
  }
}

/**
 * Python method tables for LerpBlendType (LerpBlendType)
 */
static PyMethodDef Dtool_Methods_LerpBlendType[] = {
  {"get_class_type", &Dtool_LerpBlendType_get_class_type_188, METH_NOARGS | METH_STATIC, (const char *)Dtool_LerpBlendType_get_class_type_188_comment},
  {"getClassType", &Dtool_LerpBlendType_get_class_type_188, METH_NOARGS | METH_STATIC, (const char *)Dtool_LerpBlendType_get_class_type_188_comment},
  {NULL, NULL, 0, NULL}
};

/**
 * Python function wrapper for:
 * virtual PN_stdfloat LerpBlendType::operator ()(PN_stdfloat ) = 0
 */
static PyObject *Dtool_LerpBlendType_operator_187(PyObject *self, PyObject *args, PyObject *kwds)
 {
  LerpBlendType *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LerpBlendType, (void **)&local_this, "LerpBlendType.__call__")) {
    return NULL;
  }
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("function takes exactly 1 argument");
#else
    return PyErr_Format(PyExc_TypeError,
                        "__call__() takes exactly 1 argument (%d given)",
                        parameter_count);
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    return Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
  }
  // 1-virtual PN_stdfloat LerpBlendType::operator ()(PN_stdfloat ) = 0
  if (PyNumber_Check(arg)) {
    PN_stdfloat return_value = (*local_this).operator ()((PN_stdfloat)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__call__(const LerpBlendType self, float param0)\n");
  }
  return NULL;
}

static PyNumberMethods Dtool_NumberMethods_LerpBlendType = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LerpBlendType = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LerpBlendType = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LerpBlendType = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LerpBlendType = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.LerpBlendType",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LerpBlendType,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LerpBlendType,
    &Dtool_SequenceMethods_LerpBlendType,
    &Dtool_MappingMethods_LerpBlendType,
    0, // tp_hash
    &Dtool_LerpBlendType_operator_187,
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LerpBlendType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LerpBlendType,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LerpBlendType,
    PyType_GenericAlloc,
    Dtool_new_LerpBlendType,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LerpBlendType,
  Dtool_UpcastInterface_LerpBlendType,
  Dtool_DowncastInterface_LerpBlendType,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LerpBlendType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_LerpBlendType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_LerpBlendType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LerpBlendType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LerpBlendType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LerpBlendType);
  }
}

/**
 * Python method tables for EaseInBlendType (EaseInBlendType)
 */
static PyMethodDef Dtool_Methods_EaseInBlendType[] = {
  {"get_class_type", &Dtool_EaseInBlendType_get_class_type_191, METH_NOARGS | METH_STATIC, (const char *)Dtool_EaseInBlendType_get_class_type_191_comment},
  {"getClassType", &Dtool_EaseInBlendType_get_class_type_191, METH_NOARGS | METH_STATIC, (const char *)Dtool_EaseInBlendType_get_class_type_191_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EaseInBlendType = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EaseInBlendType = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EaseInBlendType = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EaseInBlendType = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EaseInBlendType = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.EaseInBlendType",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EaseInBlendType,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EaseInBlendType,
    &Dtool_SequenceMethods_EaseInBlendType,
    &Dtool_MappingMethods_EaseInBlendType,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EaseInBlendType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EaseInBlendType,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EaseInBlendType,
    PyType_GenericAlloc,
    Dtool_new_EaseInBlendType,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EaseInBlendType,
  Dtool_UpcastInterface_EaseInBlendType,
  Dtool_DowncastInterface_EaseInBlendType,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_EaseInBlendType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LerpBlendType(NULL);
    Dtool_EaseInBlendType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LerpBlendType);
    PyObject *dict = PyDict_New();
    Dtool_EaseInBlendType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EaseInBlendType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EaseInBlendType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EaseInBlendType);
  }
}

/**
 * Python method tables for EaseOutBlendType (EaseOutBlendType)
 */
static PyMethodDef Dtool_Methods_EaseOutBlendType[] = {
  {"get_class_type", &Dtool_EaseOutBlendType_get_class_type_194, METH_NOARGS | METH_STATIC, (const char *)Dtool_EaseOutBlendType_get_class_type_194_comment},
  {"getClassType", &Dtool_EaseOutBlendType_get_class_type_194, METH_NOARGS | METH_STATIC, (const char *)Dtool_EaseOutBlendType_get_class_type_194_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EaseOutBlendType = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EaseOutBlendType = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EaseOutBlendType = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EaseOutBlendType = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EaseOutBlendType = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.EaseOutBlendType",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EaseOutBlendType,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EaseOutBlendType,
    &Dtool_SequenceMethods_EaseOutBlendType,
    &Dtool_MappingMethods_EaseOutBlendType,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EaseOutBlendType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EaseOutBlendType,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EaseOutBlendType,
    PyType_GenericAlloc,
    Dtool_new_EaseOutBlendType,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EaseOutBlendType,
  Dtool_UpcastInterface_EaseOutBlendType,
  Dtool_DowncastInterface_EaseOutBlendType,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_EaseOutBlendType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LerpBlendType(NULL);
    Dtool_EaseOutBlendType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LerpBlendType);
    PyObject *dict = PyDict_New();
    Dtool_EaseOutBlendType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EaseOutBlendType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EaseOutBlendType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EaseOutBlendType);
  }
}

/**
 * Python method tables for EaseInOutBlendType (EaseInOutBlendType)
 */
static PyMethodDef Dtool_Methods_EaseInOutBlendType[] = {
  {"get_class_type", &Dtool_EaseInOutBlendType_get_class_type_197, METH_NOARGS | METH_STATIC, (const char *)Dtool_EaseInOutBlendType_get_class_type_197_comment},
  {"getClassType", &Dtool_EaseInOutBlendType_get_class_type_197, METH_NOARGS | METH_STATIC, (const char *)Dtool_EaseInOutBlendType_get_class_type_197_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EaseInOutBlendType = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EaseInOutBlendType = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EaseInOutBlendType = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EaseInOutBlendType = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EaseInOutBlendType = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.EaseInOutBlendType",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EaseInOutBlendType,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EaseInOutBlendType,
    &Dtool_SequenceMethods_EaseInOutBlendType,
    &Dtool_MappingMethods_EaseInOutBlendType,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EaseInOutBlendType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EaseInOutBlendType,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EaseInOutBlendType,
    PyType_GenericAlloc,
    Dtool_new_EaseInOutBlendType,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EaseInOutBlendType,
  Dtool_UpcastInterface_EaseInOutBlendType,
  Dtool_DowncastInterface_EaseInOutBlendType,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_EaseInOutBlendType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LerpBlendType(NULL);
    Dtool_EaseInOutBlendType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LerpBlendType);
    PyObject *dict = PyDict_New();
    Dtool_EaseInOutBlendType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EaseInOutBlendType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EaseInOutBlendType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EaseInOutBlendType);
  }
}

/**
 * Python method tables for NoBlendType (NoBlendType)
 */
static PyMethodDef Dtool_Methods_NoBlendType[] = {
  {"get_class_type", &Dtool_NoBlendType_get_class_type_200, METH_NOARGS | METH_STATIC, (const char *)Dtool_NoBlendType_get_class_type_200_comment},
  {"getClassType", &Dtool_NoBlendType_get_class_type_200, METH_NOARGS | METH_STATIC, (const char *)Dtool_NoBlendType_get_class_type_200_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_NoBlendType = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NoBlendType = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_NoBlendType = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_NoBlendType = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_NoBlendType = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.NoBlendType",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_NoBlendType,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_NoBlendType,
    &Dtool_SequenceMethods_NoBlendType,
    &Dtool_MappingMethods_NoBlendType,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_NoBlendType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_NoBlendType,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_NoBlendType,
    PyType_GenericAlloc,
    Dtool_new_NoBlendType,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NoBlendType,
  Dtool_UpcastInterface_NoBlendType,
  Dtool_DowncastInterface_NoBlendType,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_NoBlendType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LerpBlendType(NULL);
    Dtool_NoBlendType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LerpBlendType);
    PyObject *dict = PyDict_New();
    Dtool_NoBlendType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NoBlendType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NoBlendType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NoBlendType);
  }
}

/**
 * Python method tables for ShowInterval (ShowInterval)
 */
static PyMethodDef Dtool_Methods_ShowInterval[] = {
  {"get_class_type", &Dtool_ShowInterval_get_class_type_203, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShowInterval_get_class_type_203_comment},
  {"getClassType", &Dtool_ShowInterval_get_class_type_203, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShowInterval_get_class_type_203_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ShowInterval = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ShowInterval = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ShowInterval = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ShowInterval = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ShowInterval = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.ShowInterval",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ShowInterval,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ShowInterval,
    &Dtool_SequenceMethods_ShowInterval,
    &Dtool_MappingMethods_ShowInterval,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ShowInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An interval that calls NodePath::show().\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ShowInterval,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ShowInterval,
    PyType_GenericAlloc,
    Dtool_new_ShowInterval,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShowInterval,
  Dtool_UpcastInterface_ShowInterval,
  Dtool_DowncastInterface_ShowInterval,
  (CoerceFunction)Dtool_ConstCoerce_ShowInterval,
  (CoerceFunction)Dtool_Coerce_ShowInterval,
};

static void Dtool_PyModuleClassInit_ShowInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CInterval(NULL);
    Dtool_ShowInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CInterval);
    PyObject *dict = PyDict_New();
    Dtool_ShowInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ShowInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShowInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShowInterval);
  }
}

/**
 * Python method tables for WaitInterval (WaitInterval)
 */
static PyMethodDef Dtool_Methods_WaitInterval[] = {
  {"get_class_type", &Dtool_WaitInterval_get_class_type_207, METH_NOARGS | METH_STATIC, (const char *)Dtool_WaitInterval_get_class_type_207_comment},
  {"getClassType", &Dtool_WaitInterval_get_class_type_207, METH_NOARGS | METH_STATIC, (const char *)Dtool_WaitInterval_get_class_type_207_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_WaitInterval = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_WaitInterval = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_WaitInterval = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_WaitInterval = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_WaitInterval = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.WaitInterval",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_WaitInterval,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_WaitInterval,
    &Dtool_SequenceMethods_WaitInterval,
    &Dtool_MappingMethods_WaitInterval,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_WaitInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This interval does absolutely nothing, and is mainly useful for marking\n"
    " * time between other intervals within a sequence.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_WaitInterval,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_WaitInterval,
    PyType_GenericAlloc,
    Dtool_new_WaitInterval,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_WaitInterval,
  Dtool_UpcastInterface_WaitInterval,
  Dtool_DowncastInterface_WaitInterval,
  (CoerceFunction)Dtool_ConstCoerce_WaitInterval,
  (CoerceFunction)Dtool_Coerce_WaitInterval,
};

static void Dtool_PyModuleClassInit_WaitInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CInterval(NULL);
    Dtool_WaitInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CInterval);
    PyObject *dict = PyDict_New();
    Dtool_WaitInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_WaitInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(WaitInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_WaitInterval);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3interval_RegisterTypes() {
  Dtool_CInterval._type = CInterval::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CInterval);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("CIntervalManager", Dtool_CIntervalManager);
#endif
  Dtool_CConstraintInterval._type = CConstraintInterval::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CConstraintInterval);
  Dtool_CConstrainHprInterval._type = CConstrainHprInterval::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CConstrainHprInterval);
  Dtool_CConstrainPosHprInterval._type = CConstrainPosHprInterval::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CConstrainPosHprInterval);
  Dtool_CConstrainPosInterval._type = CConstrainPosInterval::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CConstrainPosInterval);
  Dtool_CConstrainTransformInterval._type = CConstrainTransformInterval::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CConstrainTransformInterval);
  Dtool_CLerpInterval._type = CLerpInterval::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CLerpInterval);
  Dtool_CLerpAnimEffectInterval._type = CLerpAnimEffectInterval::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CLerpAnimEffectInterval);
  Dtool_CLerpNodePathInterval._type = CLerpNodePathInterval::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CLerpNodePathInterval);
  Dtool_CMetaInterval._type = CMetaInterval::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CMetaInterval);
  Dtool_HideInterval._type = HideInterval::get_class_type();
  RegisterRuntimeTypedClass(Dtool_HideInterval);
  Dtool_LerpBlendType._type = LerpBlendType::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LerpBlendType);
  Dtool_EaseInBlendType._type = EaseInBlendType::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EaseInBlendType);
  Dtool_EaseOutBlendType._type = EaseOutBlendType::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EaseOutBlendType);
  Dtool_EaseInOutBlendType._type = EaseInOutBlendType::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EaseInOutBlendType);
  Dtool_NoBlendType._type = NoBlendType::get_class_type();
  RegisterRuntimeTypedClass(Dtool_NoBlendType);
  Dtool_ShowInterval._type = ShowInterval::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ShowInterval);
  Dtool_WaitInterval._type = WaitInterval::get_class_type();
  RegisterRuntimeTypedClass(Dtool_WaitInterval);
}

void Dtool_libp3interval_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_LVecBase2f = LookupRuntimeTypedClass(LVecBase2f::get_class_type());
  Dtool_Ptr_LVecBase4f = LookupRuntimeTypedClass(LVecBase4f::get_class_type());
  Dtool_Ptr_LVecBase3f = LookupRuntimeTypedClass(LVecBase3f::get_class_type());
  Dtool_Ptr_LQuaternionf = LookupRuntimeTypedClass(LQuaternionf::get_class_type());
  Dtool_Ptr_TextureStage = LookupRuntimeTypedClass(TextureStage::get_class_type());
  Dtool_Ptr_EventQueue = LookupNamedClass("EventQueue");
  Dtool_Ptr_NodePath = LookupRuntimeTypedClass(NodePath::get_class_type());
  Dtool_Ptr_AnimControl = LookupRuntimeTypedClass(AnimControl::get_class_type());
#endif
}

void Dtool_libp3interval_BuildInstants(PyObject *module) {
  (void) module;
  // CInterval
  Dtool_PyModuleClassInit_CInterval(module);
  PyModule_AddObject(module, "CInterval", (PyObject *)&Dtool_CInterval);
  // CIntervalManager
  Dtool_PyModuleClassInit_CIntervalManager(module);
  PyModule_AddObject(module, "CIntervalManager", (PyObject *)&Dtool_CIntervalManager);
  // CConstraintInterval
  Dtool_PyModuleClassInit_CConstraintInterval(module);
  PyModule_AddObject(module, "CConstraintInterval", (PyObject *)&Dtool_CConstraintInterval);
  // CConstrainHprInterval
  Dtool_PyModuleClassInit_CConstrainHprInterval(module);
  PyModule_AddObject(module, "CConstrainHprInterval", (PyObject *)&Dtool_CConstrainHprInterval);
  // CConstrainPosHprInterval
  Dtool_PyModuleClassInit_CConstrainPosHprInterval(module);
  PyModule_AddObject(module, "CConstrainPosHprInterval", (PyObject *)&Dtool_CConstrainPosHprInterval);
  // CConstrainPosInterval
  Dtool_PyModuleClassInit_CConstrainPosInterval(module);
  PyModule_AddObject(module, "CConstrainPosInterval", (PyObject *)&Dtool_CConstrainPosInterval);
  // CConstrainTransformInterval
  Dtool_PyModuleClassInit_CConstrainTransformInterval(module);
  PyModule_AddObject(module, "CConstrainTransformInterval", (PyObject *)&Dtool_CConstrainTransformInterval);
  // CLerpInterval
  Dtool_PyModuleClassInit_CLerpInterval(module);
  PyModule_AddObject(module, "CLerpInterval", (PyObject *)&Dtool_CLerpInterval);
  // CLerpAnimEffectInterval
  Dtool_PyModuleClassInit_CLerpAnimEffectInterval(module);
  PyModule_AddObject(module, "CLerpAnimEffectInterval", (PyObject *)&Dtool_CLerpAnimEffectInterval);
  // CLerpNodePathInterval
  Dtool_PyModuleClassInit_CLerpNodePathInterval(module);
  PyModule_AddObject(module, "CLerpNodePathInterval", (PyObject *)&Dtool_CLerpNodePathInterval);
  // CMetaInterval
  Dtool_PyModuleClassInit_CMetaInterval(module);
  PyModule_AddObject(module, "CMetaInterval", (PyObject *)&Dtool_CMetaInterval);
  // HideInterval
  Dtool_PyModuleClassInit_HideInterval(module);
  PyModule_AddObject(module, "HideInterval", (PyObject *)&Dtool_HideInterval);
  // LerpBlendType
  Dtool_PyModuleClassInit_LerpBlendType(module);
  PyModule_AddObject(module, "LerpBlendType", (PyObject *)&Dtool_LerpBlendType);
  // EaseInBlendType
  Dtool_PyModuleClassInit_EaseInBlendType(module);
  PyModule_AddObject(module, "EaseInBlendType", (PyObject *)&Dtool_EaseInBlendType);
  // EaseOutBlendType
  Dtool_PyModuleClassInit_EaseOutBlendType(module);
  PyModule_AddObject(module, "EaseOutBlendType", (PyObject *)&Dtool_EaseOutBlendType);
  // EaseInOutBlendType
  Dtool_PyModuleClassInit_EaseInOutBlendType(module);
  PyModule_AddObject(module, "EaseInOutBlendType", (PyObject *)&Dtool_EaseInOutBlendType);
  // NoBlendType
  Dtool_PyModuleClassInit_NoBlendType(module);
  PyModule_AddObject(module, "NoBlendType", (PyObject *)&Dtool_NoBlendType);
  // ShowInterval
  Dtool_PyModuleClassInit_ShowInterval(module);
  PyModule_AddObject(module, "ShowInterval", (PyObject *)&Dtool_ShowInterval);
  // WaitInterval
  Dtool_PyModuleClassInit_WaitInterval(module);
  PyModule_AddObject(module, "WaitInterval", (PyObject *)&Dtool_WaitInterval);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3interval_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478214714,  /* file_identifier */
  "libp3interval",  /* library_name */
  "ceEZ",  /* library_hash_name */
  "panda3d.direct",  /* module_name */
  "libp3interval.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  456  /* next_index */
};

Configure(_in_configure_libp3interval);
ConfigureFn(_in_configure_libp3interval) {
  interrogate_request_module(&_in_module_def);
}

