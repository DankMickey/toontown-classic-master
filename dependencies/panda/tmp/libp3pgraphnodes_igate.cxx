/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/pgraphnodes -Ipanda/src/pgraphnodes -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3pgraphnodes_igate.cxx -od built/pandac/input/libp3pgraphnodes.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/pgraphnodes -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3pgraphnodes ambientLight.h callbackNode.h computeNode.h config_pgraphnodes.h directionalLight.h fadeLodNode.h fadeLodNodeData.h lightLensNode.h lightNode.h lodNode.h lodNodeType.h nodeCullCallbackData.h p3pgraphnodes_composite1.cxx p3pgraphnodes_composite2.cxx pointLight.h sceneGraphAnalyzer.h selectiveChildNode.h sequenceNode.h shaderGenerator.h sphereLight.h spotlight.h switchNode.h uvScrollNode.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3pgraphnodes
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "ambientLight.h"
#include "auxSceneData.h"
#include "callbackData.h"
#include "callbackNode.h"
#include "callbackObject.h"
#include "computeNode.h"
#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "configVariableEnum.h"
#include "configVariableInt.h"
#include "configVariableString.h"
#include "config_pgraphnodes.h"
#include "cullTraverser.h"
#include "cullTraverserData.h"
#include "dconfig.h"
#include "directionalLight.h"
#include "fadeLodNode.h"
#include "fadeLodNodeData.h"
#include "lightLensNode.h"
#include "lightNode.h"
#include "lodNode.h"
#include "lodNodeType.h"
#include "nodeCullCallbackData.h"
#include "notifyCategoryProxy.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "pointLight.h"
#include "pointerTo.h"
#include "sceneGraphAnalyzer.h"
#include "selectiveChildNode.h"
#include "sequenceNode.h"
#include "shaderGenerator.h"
#include "sphereLight.h"
#include "spotlight.h"
#include "switchNode.h"
#include "uvScrollNode.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class LightNode
 */
typedef LightNode LightNode_localtype;
Define_Module_ClassRef(panda3d.core, LightNode, LightNode_localtype, LightNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LightNode = &Dtool_LightNode;
static void Dtool_PyModuleClassInit_LightNode(PyObject *module);
bool Dtool_ConstCoerce_LightNode(PyObject *args, CPT(LightNode) &coerced);
bool Dtool_Coerce_LightNode(PyObject *args, PT(LightNode) &coerced);

/**
 * Forward declarations for top-level class AmbientLight
 */
typedef AmbientLight AmbientLight_localtype;
Define_Module_ClassRef(panda3d.core, AmbientLight, AmbientLight_localtype, AmbientLight);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AmbientLight = &Dtool_AmbientLight;
static void Dtool_PyModuleClassInit_AmbientLight(PyObject *module);
bool Dtool_ConstCoerce_AmbientLight(PyObject *args, CPT(AmbientLight) &coerced);
bool Dtool_Coerce_AmbientLight(PyObject *args, PT(AmbientLight) &coerced);

/**
 * Forward declarations for top-level class CallbackNode
 */
typedef CallbackNode CallbackNode_localtype;
Define_Module_ClassRef(panda3d.core, CallbackNode, CallbackNode_localtype, CallbackNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackNode = &Dtool_CallbackNode;
static void Dtool_PyModuleClassInit_CallbackNode(PyObject *module);
bool Dtool_ConstCoerce_CallbackNode(PyObject *args, CPT(CallbackNode) &coerced);
bool Dtool_Coerce_CallbackNode(PyObject *args, PT(CallbackNode) &coerced);

/**
 * Forward declarations for top-level class ComputeNode
 */
typedef ComputeNode ComputeNode_localtype;
Define_Module_ClassRef(panda3d.core, ComputeNode, ComputeNode_localtype, ComputeNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ComputeNode = &Dtool_ComputeNode;
static void Dtool_PyModuleClassInit_ComputeNode(PyObject *module);
bool Dtool_ConstCoerce_ComputeNode(PyObject *args, CPT(ComputeNode) &coerced);
bool Dtool_Coerce_ComputeNode(PyObject *args, PT(ComputeNode) &coerced);

/**
 * Forward declarations for top-level class LightLensNode
 */
typedef LightLensNode LightLensNode_localtype;
Define_Module_ClassRef(panda3d.core, LightLensNode, LightLensNode_localtype, LightLensNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LightLensNode = &Dtool_LightLensNode;
static void Dtool_PyModuleClassInit_LightLensNode(PyObject *module);
bool Dtool_ConstCoerce_LightLensNode(PyObject *args, CPT(LightLensNode) &coerced);
bool Dtool_Coerce_LightLensNode(PyObject *args, PT(LightLensNode) &coerced);

/**
 * Forward declarations for top-level class DirectionalLight
 */
typedef DirectionalLight DirectionalLight_localtype;
Define_Module_ClassRef(panda3d.core, DirectionalLight, DirectionalLight_localtype, DirectionalLight);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DirectionalLight = &Dtool_DirectionalLight;
static void Dtool_PyModuleClassInit_DirectionalLight(PyObject *module);
bool Dtool_ConstCoerce_DirectionalLight(PyObject *args, CPT(DirectionalLight) &coerced);
bool Dtool_Coerce_DirectionalLight(PyObject *args, PT(DirectionalLight) &coerced);

/**
 * Forward declarations for top-level class LODNode
 */
typedef LODNode LODNode_localtype;
Define_Module_ClassRef(panda3d.core, LODNode, LODNode_localtype, LODNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LODNode = &Dtool_LODNode;
static void Dtool_PyModuleClassInit_LODNode(PyObject *module);
bool Dtool_ConstCoerce_LODNode(PyObject *args, CPT(LODNode) &coerced);
bool Dtool_Coerce_LODNode(PyObject *args, PT(LODNode) &coerced);

/**
 * Forward declarations for top-level class FadeLODNode
 */
typedef FadeLODNode FadeLODNode_localtype;
Define_Module_ClassRef(panda3d.core, FadeLODNode, FadeLODNode_localtype, FadeLODNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FadeLODNode = &Dtool_FadeLODNode;
static void Dtool_PyModuleClassInit_FadeLODNode(PyObject *module);
bool Dtool_ConstCoerce_FadeLODNode(PyObject *args, CPT(FadeLODNode) &coerced);
bool Dtool_Coerce_FadeLODNode(PyObject *args, PT(FadeLODNode) &coerced);

/**
 * Forward declarations for top-level class NodeCullCallbackData
 */
typedef NodeCullCallbackData NodeCullCallbackData_localtype;
Define_Module_Class(panda3d.core, NodeCullCallbackData, NodeCullCallbackData_localtype, NodeCullCallbackData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodeCullCallbackData = &Dtool_NodeCullCallbackData;
static void Dtool_PyModuleClassInit_NodeCullCallbackData(PyObject *module);

/**
 * Forward declarations for top-level class PointLight
 */
typedef PointLight PointLight_localtype;
Define_Module_ClassRef(panda3d.core, PointLight, PointLight_localtype, PointLight);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointLight = &Dtool_PointLight;
static void Dtool_PyModuleClassInit_PointLight(PyObject *module);
bool Dtool_ConstCoerce_PointLight(PyObject *args, CPT(PointLight) &coerced);
bool Dtool_Coerce_PointLight(PyObject *args, PT(PointLight) &coerced);

/**
 * Forward declarations for top-level class SelectiveChildNode
 */
typedef SelectiveChildNode SelectiveChildNode_localtype;
Define_Module_ClassRef(panda3d.core, SelectiveChildNode, SelectiveChildNode_localtype, SelectiveChildNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SelectiveChildNode = &Dtool_SelectiveChildNode;
static void Dtool_PyModuleClassInit_SelectiveChildNode(PyObject *module);
bool Dtool_ConstCoerce_SelectiveChildNode(PyObject *args, CPT(SelectiveChildNode) &coerced);
bool Dtool_Coerce_SelectiveChildNode(PyObject *args, PT(SelectiveChildNode) &coerced);

/**
 * Forward declarations for top-level class SequenceNode
 */
typedef SequenceNode SequenceNode_localtype;
Define_Module_ClassRef(panda3d.core, SequenceNode, SequenceNode_localtype, SequenceNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SequenceNode = &Dtool_SequenceNode;
static void Dtool_PyModuleClassInit_SequenceNode(PyObject *module);
bool Dtool_ConstCoerce_SequenceNode(PyObject *args, CPT(SequenceNode) &coerced);
bool Dtool_Coerce_SequenceNode(PyObject *args, PT(SequenceNode) &coerced);

/**
 * Forward declarations for top-level class ShaderGenerator
 */
typedef ShaderGenerator ShaderGenerator_localtype;
Define_Module_ClassRef(panda3d.core, ShaderGenerator, ShaderGenerator_localtype, ShaderGenerator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderGenerator = &Dtool_ShaderGenerator;
static void Dtool_PyModuleClassInit_ShaderGenerator(PyObject *module);
bool Dtool_ConstCoerce_ShaderGenerator(PyObject *args, CPT(ShaderGenerator) &coerced);
bool Dtool_Coerce_ShaderGenerator(PyObject *args, PT(ShaderGenerator) &coerced);

/**
 * Forward declarations for top-level class SphereLight
 */
typedef SphereLight SphereLight_localtype;
Define_Module_ClassRef(panda3d.core, SphereLight, SphereLight_localtype, SphereLight);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SphereLight = &Dtool_SphereLight;
static void Dtool_PyModuleClassInit_SphereLight(PyObject *module);
bool Dtool_ConstCoerce_SphereLight(PyObject *args, CPT(SphereLight) &coerced);
bool Dtool_Coerce_SphereLight(PyObject *args, PT(SphereLight) &coerced);

/**
 * Forward declarations for top-level class Spotlight
 */
typedef Spotlight Spotlight_localtype;
Define_Module_ClassRef(panda3d.core, Spotlight, Spotlight_localtype, Spotlight);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Spotlight = &Dtool_Spotlight;
static void Dtool_PyModuleClassInit_Spotlight(PyObject *module);
bool Dtool_ConstCoerce_Spotlight(PyObject *args, CPT(Spotlight) &coerced);
bool Dtool_Coerce_Spotlight(PyObject *args, PT(Spotlight) &coerced);

/**
 * Forward declarations for top-level class SwitchNode
 */
typedef SwitchNode SwitchNode_localtype;
Define_Module_ClassRef(panda3d.core, SwitchNode, SwitchNode_localtype, SwitchNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SwitchNode = &Dtool_SwitchNode;
static void Dtool_PyModuleClassInit_SwitchNode(PyObject *module);
bool Dtool_ConstCoerce_SwitchNode(PyObject *args, CPT(SwitchNode) &coerced);
bool Dtool_Coerce_SwitchNode(PyObject *args, PT(SwitchNode) &coerced);

/**
 * Forward declarations for top-level class UvScrollNode
 */
typedef UvScrollNode UvScrollNode_localtype;
Define_Module_ClassRef(panda3d.core, UvScrollNode, UvScrollNode_localtype, UvScrollNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UvScrollNode = &Dtool_UvScrollNode;
static void Dtool_PyModuleClassInit_UvScrollNode(PyObject *module);
bool Dtool_ConstCoerce_UvScrollNode(PyObject *args, CPT(UvScrollNode) &coerced);
bool Dtool_Coerce_UvScrollNode(PyObject *args, PT(UvScrollNode) &coerced);

/**
 * Forward declarations for top-level class SceneGraphAnalyzer
 */
typedef SceneGraphAnalyzer SceneGraphAnalyzer_localtype;
Define_Module_Class(panda3d.core, SceneGraphAnalyzer, SceneGraphAnalyzer_localtype, SceneGraphAnalyzer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SceneGraphAnalyzer = &Dtool_SceneGraphAnalyzer;
static void Dtool_PyModuleClassInit_SceneGraphAnalyzer(PyObject *module);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// LVecBase2i
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase2i;
inline static LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced) {
  nassertr(Dtool_Ptr_LVecBase2i != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase2i->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase2i *(*)(PyObject *, LVecBase2i &))Dtool_Ptr_LVecBase2i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2i = &Dtool_LVecBase2i;
extern LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3f;
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LVecBase3i
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3i;
inline static LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced) {
  nassertr(Dtool_Ptr_LVecBase3i != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3i->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3i *(*)(PyObject *, LVecBase3i &))Dtool_Ptr_LVecBase3i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3i = &Dtool_LVecBase3i;
extern LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced);
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVector3f;
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != NULL, NULL);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint3f;
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != NULL, NULL);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4f;
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritable;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// GeomVertexAnimationSpec
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GeomVertexAnimationSpec;
#else
extern struct Dtool_PyTypedObject Dtool_GeomVertexAnimationSpec;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomVertexAnimationSpec = &Dtool_GeomVertexAnimationSpec;
#endif
// GraphicsStateGuardianBase
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GraphicsStateGuardianBase;
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsStateGuardianBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsStateGuardianBase = &Dtool_GraphicsStateGuardianBase;
#endif
// RenderState
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_RenderState;
inline static bool Dtool_ConstCoerce_RenderState(PyObject *args, CPT(RenderState) &coerced) {
  nassertr(Dtool_Ptr_RenderState != NULL, false);
  nassertr(Dtool_Ptr_RenderState->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(RenderState) &))Dtool_Ptr_RenderState->_Dtool_ConstCoerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_RenderState;
static struct Dtool_PyTypedObject *const Dtool_Ptr_RenderState = &Dtool_RenderState;
extern bool Dtool_ConstCoerce_RenderState(PyObject *args, CPT(RenderState) &coerced);
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PandaNode;
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// Light
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Light;
#else
extern struct Dtool_PyTypedObject Dtool_Light;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Light = &Dtool_Light;
#endif
// CallbackObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_CallbackObject;
inline static bool Dtool_ConstCoerce_CallbackObject(PyObject *args, CPT(CallbackObject) &coerced) {
  nassertr(Dtool_Ptr_CallbackObject != NULL, false);
  nassertr(Dtool_Ptr_CallbackObject->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(CallbackObject) &))Dtool_Ptr_CallbackObject->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_CallbackObject(PyObject *args, PT(CallbackObject) &coerced) {
  nassertr(Dtool_Ptr_CallbackObject != NULL, false);
  nassertr(Dtool_Ptr_CallbackObject->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(CallbackObject) &))Dtool_Ptr_CallbackObject->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_CallbackObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackObject = &Dtool_CallbackObject;
extern bool Dtool_ConstCoerce_CallbackObject(PyObject *args, CPT(CallbackObject) &coerced);
extern bool Dtool_Coerce_CallbackObject(PyObject *args, PT(CallbackObject) &coerced);
#endif
// LensNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LensNode;
inline static bool Dtool_ConstCoerce_LensNode(PyObject *args, CPT(LensNode) &coerced) {
  nassertr(Dtool_Ptr_LensNode != NULL, false);
  nassertr(Dtool_Ptr_LensNode->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(LensNode) &))Dtool_Ptr_LensNode->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_LensNode(PyObject *args, PT(LensNode) &coerced) {
  nassertr(Dtool_Ptr_LensNode != NULL, false);
  nassertr(Dtool_Ptr_LensNode->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(LensNode) &))Dtool_Ptr_LensNode->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LensNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LensNode = &Dtool_LensNode;
extern bool Dtool_ConstCoerce_LensNode(PyObject *args, CPT(LensNode) &coerced);
extern bool Dtool_Coerce_LensNode(PyObject *args, PT(LensNode) &coerced);
#endif
// Texture
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Texture;
#else
extern struct Dtool_PyTypedObject Dtool_Texture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Texture = &Dtool_Texture;
#endif
// CallbackData
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_CallbackData;
#else
extern struct Dtool_PyTypedObject Dtool_CallbackData;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackData = &Dtool_CallbackData;
#endif
// CullTraverser
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_CullTraverser;
#else
extern struct Dtool_PyTypedObject Dtool_CullTraverser;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CullTraverser = &Dtool_CullTraverser;
#endif
// CullTraverserData
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_CullTraverserData;
#else
extern struct Dtool_PyTypedObject Dtool_CullTraverserData;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CullTraverserData = &Dtool_CullTraverserData;
#endif
// AnimInterface
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_AnimInterface;
#else
extern struct Dtool_PyTypedObject Dtool_AnimInterface;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimInterface = &Dtool_AnimInterface;
#endif
// ShaderAttrib
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ShaderAttrib;
inline static bool Dtool_ConstCoerce_ShaderAttrib(PyObject *args, CPT(ShaderAttrib) &coerced) {
  nassertr(Dtool_Ptr_ShaderAttrib != NULL, false);
  nassertr(Dtool_Ptr_ShaderAttrib->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(ShaderAttrib) &))Dtool_Ptr_ShaderAttrib->_Dtool_ConstCoerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_ShaderAttrib;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderAttrib = &Dtool_ShaderAttrib;
extern bool Dtool_ConstCoerce_ShaderAttrib(PyObject *args, CPT(ShaderAttrib) &coerced);
#endif
// Camera
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Camera;
#else
extern struct Dtool_PyTypedObject Dtool_Camera;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Camera = &Dtool_Camera;
#endif
// GraphicsOutputBase
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GraphicsOutputBase;
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsOutputBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsOutputBase = &Dtool_GraphicsOutputBase;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class LightNode
 */
/**
 * Python function wrapper for:
 * virtual void LightNode::output(ostream &out) const
 */
static PyObject *Dtool_LightNode_output_8(PyObject *self, PyObject *arg) {
  LightNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void LightNode::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LightNode.output", false, true);
  if (arg_this != NULL) {
    (*(const LightNode*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LightNode self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LightNode_output_8_comment =
  "C++ Interface:\n"
  "output(LightNode self, ostream out)\n"
  "\n"
  "// We have to explicitly publish these because they resolve the multiple\n"
  "// inheritance.\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LightNode_output_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void LightNode::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_LightNode_write_9(PyObject *self, PyObject *args, PyObject *kwds) {
  LightNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void LightNode::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "LightNode.write", false, true);
    if (param1_this != NULL) {
      (*(const LightNode*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(LightNode self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LightNode_write_9_comment =
  "C++ Interface:\n"
  "write(LightNode self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LightNode_write_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LightNode::get_class_type(void)
 */
static PyObject *Dtool_LightNode_get_class_type_10(PyObject *, PyObject *) {
  // 1-static TypeHandle LightNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LightNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LightNode_get_class_type_10_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LightNode_get_class_type_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Light *LightNode::upcast_to_Light(void)
 */
static PyObject *Dtool_LightNode_upcast_to_Light_3(PyObject *self, PyObject *) {
  LightNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightNode, (void **)&local_this, "LightNode.upcast_to_Light")) {
    return NULL;
  }
  // 1-Light *LightNode::upcast_to_Light(void)
  Light *return_value = (Light *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Light, false, false);
}

#ifndef NDEBUG
static const char *Dtool_LightNode_upcast_to_Light_3_comment =
  "C++ Interface:\n"
  "upcast_to_Light(const LightNode self)\n"
  "\n"
  "upcast from LightNode to Light";
#else
static const char *Dtool_LightNode_upcast_to_Light_3_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PandaNode *LightNode::upcast_to_PandaNode(void)
 */
static PyObject *Dtool_LightNode_upcast_to_PandaNode_6(PyObject *self, PyObject *) {
  LightNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightNode, (void **)&local_this, "LightNode.upcast_to_PandaNode")) {
    return NULL;
  }
  // 1-PandaNode *LightNode::upcast_to_PandaNode(void)
  PandaNode *return_value = (PandaNode *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LightNode_upcast_to_PandaNode_6_comment =
  "C++ Interface:\n"
  "upcast_to_PandaNode(const LightNode self)\n"
  "\n"
  "upcast from LightNode to PandaNode";
#else
static const char *Dtool_LightNode_upcast_to_PandaNode_6_comment = NULL;
#endif

static int Dtool_Init_LightNode(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_LightNode(PyObject *args, CPT(LightNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LightNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_LightNode(PyObject *args, PT(LightNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LightNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LightNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LightNode) {
    printf("LightNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LightNode *local_this = (LightNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LightNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Light) {
    return (Light *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LightNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LightNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Light) {
    Light* other_this = (Light*)from_this;
    return (LightNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (LightNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (LightNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LightNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LightNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (LightNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (LightNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AmbientLight
 */
/**
 * Python function wrapper for:
 * static TypeHandle AmbientLight::get_class_type(void)
 */
static PyObject *Dtool_AmbientLight_get_class_type_14(PyObject *, PyObject *) {
  // 1-static TypeHandle AmbientLight::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AmbientLight::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AmbientLight_get_class_type_14_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AmbientLight_get_class_type_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AmbientLight::AmbientLight(std::string const &name)
 */
static int Dtool_Init_AmbientLight(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "AmbientLight() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-AmbientLight::AmbientLight(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    AmbientLight *return_value = new AmbientLight(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AmbientLight, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AmbientLight(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_AmbientLight(PyObject *args, CPT(AmbientLight) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AmbientLight, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-AmbientLight::AmbientLight(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      AmbientLight *return_value = new AmbientLight(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_AmbientLight(PyObject *args, PT(AmbientLight) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AmbientLight, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-AmbientLight::AmbientLight(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      AmbientLight *return_value = new AmbientLight(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_AmbientLight(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AmbientLight) {
    printf("AmbientLight ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AmbientLight *local_this = (AmbientLight *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AmbientLight) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Light) {
    return (Light *)(LightNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_LightNode) {
    return (LightNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(LightNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(LightNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(LightNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LightNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LightNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(LightNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AmbientLight(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AmbientLight) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Light) {
    Light* other_this = (Light*)from_this;
    return (AmbientLight*)other_this;
  }
  if (from_type == Dtool_Ptr_LightNode) {
    LightNode* other_this = (LightNode*)from_this;
    return (AmbientLight*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AmbientLight*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (AmbientLight*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AmbientLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AmbientLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AmbientLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AmbientLight*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CallbackNode
 */
/**
 * Python function wrapper for:
 * inline void CallbackNode::set_cull_callback(CallbackObject *object)
 */
static PyObject *Dtool_CallbackNode_set_cull_callback_18(PyObject *self, PyObject *arg) {
  CallbackNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackNode, (void **)&local_this, "CallbackNode.set_cull_callback")) {
    return NULL;
  }
  // 1-inline void CallbackNode::set_cull_callback(CallbackObject *object)
  PT(CallbackObject) arg_this;
  if (!Dtool_Coerce_CallbackObject(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CallbackNode.set_cull_callback", "CallbackObject");
  }
  (*local_this).set_cull_callback(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cull_callback(const CallbackNode self, CallbackObject object)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CallbackNode_set_cull_callback_18_comment =
  "C++ Interface:\n"
  "set_cull_callback(const CallbackNode self, CallbackObject object)\n"
  "\n"
  "/**\n"
  " * Sets the CallbackObject that will be notified when this node is visited\n"
  " * during the cull traversal.  This callback will be made during the cull\n"
  " * thread.\n"
  " *\n"
  " * The cull traversal is responsible for determining which nodes are visible\n"
  " * and within the view frustum, and for accumulating state and transform, and\n"
  " * generally building up the list of CullableObjects that are to be eventually\n"
  " * passed to the draw traversal for rendering.\n"
  " *\n"
  " * At the time the cull traversal callback is made, the node has been\n"
  " * determined to be visible and it has passed the bounding-volume test, so it\n"
  " * lies within the view frustum.\n"
  " *\n"
  " * The callback is passed an instance of a NodeCullCallbackData, which\n"
  " * contains pointers to the CullTraverser and CullTraverserData--enough data\n"
  " * to examine the current node and its place within the scene graph.  The\n"
  " * callback *replaces* the normal cull behavior, so if your callback does\n"
  " * nothing, the cull traversal will not continue below this node.  If you wish\n"
  " * the cull traversal to continue to visit this node and below, you must call\n"
  " * cbdata->upcall() from your callback.\n"
  " */";
#else
static const char *Dtool_CallbackNode_set_cull_callback_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CallbackNode::clear_cull_callback(void)
 */
static PyObject *Dtool_CallbackNode_clear_cull_callback_19(PyObject *self, PyObject *) {
  CallbackNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackNode, (void **)&local_this, "CallbackNode.clear_cull_callback")) {
    return NULL;
  }
  // 1-inline void CallbackNode::clear_cull_callback(void)
  (*local_this).clear_cull_callback();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CallbackNode_clear_cull_callback_19_comment =
  "C++ Interface:\n"
  "clear_cull_callback(const CallbackNode self)\n"
  "\n"
  "/**\n"
  " * Removes the callback set by an earlier call to set_cull_callback().\n"
  " */";
#else
static const char *Dtool_CallbackNode_clear_cull_callback_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CallbackObject *CallbackNode::get_cull_callback(void) const
 */
static PyObject *Dtool_CallbackNode_get_cull_callback_20(PyObject *self, PyObject *) {
  CallbackNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CallbackNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CallbackObject *CallbackNode::get_cull_callback(void) const
  CallbackObject *return_value = (*(const CallbackNode*)local_this).get_cull_callback();
  if (return_value != (CallbackObject *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (CallbackObject *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CallbackObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CallbackNode_get_cull_callback_20_comment =
  "C++ Interface:\n"
  "get_cull_callback(CallbackNode self)\n"
  "\n"
  "/**\n"
  " * Returns the CallbackObject set by set_cull_callback().\n"
  " */";
#else
static const char *Dtool_CallbackNode_get_cull_callback_20_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CallbackNode::set_draw_callback(CallbackObject *object)
 */
static PyObject *Dtool_CallbackNode_set_draw_callback_24(PyObject *self, PyObject *arg) {
  CallbackNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackNode, (void **)&local_this, "CallbackNode.set_draw_callback")) {
    return NULL;
  }
  // 1-inline void CallbackNode::set_draw_callback(CallbackObject *object)
  PT(CallbackObject) arg_this;
  if (!Dtool_Coerce_CallbackObject(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CallbackNode.set_draw_callback", "CallbackObject");
  }
  (*local_this).set_draw_callback(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_draw_callback(const CallbackNode self, CallbackObject object)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CallbackNode_set_draw_callback_24_comment =
  "C++ Interface:\n"
  "set_draw_callback(const CallbackNode self, CallbackObject object)\n"
  "\n"
  "/**\n"
  " * Sets the CallbackObject that will be notified when this node is visited\n"
  " * during the draw traversal.  This callback will be made during the draw\n"
  " * thread.\n"
  " *\n"
  " * The draw traversal is responsible for actually issuing the commands to the\n"
  " * graphics engine to draw primitives.  Its job is to walk through the list of\n"
  " * CullableObjects build up by the cull traversal, as quickly as possible,\n"
  " * issuing the appropriate commands to draw each one.\n"
  " *\n"
  " * At the time the draw traversal callback is made, the graphics state has\n"
  " * been loaded with the correct modelview transform and render state, and the\n"
  " * primitives (if any) in this node are ready to be drawn.\n"
  " *\n"
  " * The callback is passed an instance of a GeomDrawCallbackData, which\n"
  " * contains pointers to the current state and transform, as well as the\n"
  " * current GSG.  There is a Geom pointer as well, but it will always be NULL\n"
  " * to this callback, since the CallbackNode does not itself contain any Geoms.\n"
  " */";
#else
static const char *Dtool_CallbackNode_set_draw_callback_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CallbackNode::clear_draw_callback(void)
 */
static PyObject *Dtool_CallbackNode_clear_draw_callback_25(PyObject *self, PyObject *) {
  CallbackNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackNode, (void **)&local_this, "CallbackNode.clear_draw_callback")) {
    return NULL;
  }
  // 1-inline void CallbackNode::clear_draw_callback(void)
  (*local_this).clear_draw_callback();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CallbackNode_clear_draw_callback_25_comment =
  "C++ Interface:\n"
  "clear_draw_callback(const CallbackNode self)\n"
  "\n"
  "/**\n"
  " * Removes the callback set by an earlier call to set_draw_callback().\n"
  " */";
#else
static const char *Dtool_CallbackNode_clear_draw_callback_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CallbackObject *CallbackNode::get_draw_callback(void) const
 */
static PyObject *Dtool_CallbackNode_get_draw_callback_26(PyObject *self, PyObject *) {
  CallbackNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CallbackNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CallbackObject *CallbackNode::get_draw_callback(void) const
  CallbackObject *return_value = (*(const CallbackNode*)local_this).get_draw_callback();
  if (return_value != (CallbackObject *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (CallbackObject *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CallbackObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CallbackNode_get_draw_callback_26_comment =
  "C++ Interface:\n"
  "get_draw_callback(CallbackNode self)\n"
  "\n"
  "/**\n"
  " * Returns the CallbackObject set by set_draw_callback().\n"
  " */";
#else
static const char *Dtool_CallbackNode_get_draw_callback_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CallbackNode::get_class_type(void)
 */
static PyObject *Dtool_CallbackNode_get_class_type_28(PyObject *, PyObject *) {
  // 1-static TypeHandle CallbackNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CallbackNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CallbackNode_get_class_type_28_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CallbackNode_get_class_type_28_comment = NULL;
#endif

static PyObject *Dtool_CallbackNode_cull_callback_Getter(PyObject *self, void *) {
  const CallbackNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CallbackNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline CallbackObject *CallbackNode::get_cull_callback(void) const
  CallbackObject *return_value = (*(const CallbackNode*)local_this).get_cull_callback();
  if (return_value != (CallbackObject *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (CallbackObject *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CallbackObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_CallbackNode_cull_callback_Setter(PyObject *self, PyObject *arg, void *) {
  CallbackNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackNode, (void **)&local_this, "CallbackNode.cull_callback")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete cull_callback attribute");
    return -1;
  }
  // 1-inline void CallbackNode::set_cull_callback(CallbackObject *object)
  PT(CallbackObject) arg_this;
  if (!Dtool_Coerce_CallbackObject(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CallbackNode.set_cull_callback", "CallbackObject");
    return -1;
  }
  (*local_this).set_cull_callback(MOVE(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cull_callback(const CallbackNode self, CallbackObject object)\n");
  }
  return -1;
}

static PyObject *Dtool_CallbackNode_draw_callback_Getter(PyObject *self, void *) {
  const CallbackNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CallbackNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline CallbackObject *CallbackNode::get_draw_callback(void) const
  CallbackObject *return_value = (*(const CallbackNode*)local_this).get_draw_callback();
  if (return_value != (CallbackObject *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (CallbackObject *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CallbackObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_CallbackNode_draw_callback_Setter(PyObject *self, PyObject *arg, void *) {
  CallbackNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackNode, (void **)&local_this, "CallbackNode.draw_callback")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete draw_callback attribute");
    return -1;
  }
  // 1-inline void CallbackNode::set_draw_callback(CallbackObject *object)
  PT(CallbackObject) arg_this;
  if (!Dtool_Coerce_CallbackObject(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CallbackNode.set_draw_callback", "CallbackObject");
    return -1;
  }
  (*local_this).set_draw_callback(MOVE(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_draw_callback(const CallbackNode self, CallbackObject object)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * CallbackNode::CallbackNode(std::string const &name)
 */
static int Dtool_Init_CallbackNode(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CallbackNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-CallbackNode::CallbackNode(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    CallbackNode *return_value = new CallbackNode(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CallbackNode, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CallbackNode(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CallbackNode(PyObject *args, CPT(CallbackNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CallbackNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CallbackNode::CallbackNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      CallbackNode *return_value = new CallbackNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_CallbackNode(PyObject *args, PT(CallbackNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CallbackNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CallbackNode::CallbackNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      CallbackNode *return_value = new CallbackNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_CallbackNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CallbackNode) {
    printf("CallbackNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CallbackNode *local_this = (CallbackNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CallbackNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CallbackNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CallbackNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (CallbackNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (CallbackNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CallbackNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CallbackNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CallbackNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CallbackNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ComputeNode
 */
/**
 * Python function wrapper for:
 * inline void ComputeNode::add_dispatch(LVecBase3i const &num_groups)
 * inline void ComputeNode::add_dispatch(int num_groups_x, int num_groups_y, int num_groups_z)
 */
static PyObject *Dtool_ComputeNode_add_dispatch_32(PyObject *self, PyObject *args, PyObject *kwds) {
  ComputeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ComputeNode, (void **)&local_this, "ComputeNode.add_dispatch")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "num_groups");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'num_groups' (pos 1) not found");
      }
      // 1-inline void ComputeNode::add_dispatch(LVecBase3i const &num_groups)
      LVecBase3i arg_local;
      LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "ComputeNode.add_dispatch", "LVecBase3i");
      }
      (*local_this).add_dispatch(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void ComputeNode::add_dispatch(int num_groups_x, int num_groups_y, int num_groups_z)
      int param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"num_groups_x", "num_groups_y", "num_groups_z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:add_dispatch", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).add_dispatch((int)param1, (int)param2, (int)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_dispatch() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_dispatch(const ComputeNode self, const LVecBase3i num_groups)\n"
      "add_dispatch(const ComputeNode self, int num_groups_x, int num_groups_y, int num_groups_z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ComputeNode_add_dispatch_32_comment =
  "C++ Interface:\n"
  "add_dispatch(const ComputeNode self, const LVecBase3i num_groups)\n"
  "add_dispatch(const ComputeNode self, int num_groups_x, int num_groups_y, int num_groups_z)\n"
  "\n"
  "/**\n"
  " * Adds a dispatch command with the given number of work groups in the X, Y,\n"
  " * and Z dimensions.  Any of these values may be set to 1 if the respective\n"
  " * dimension should not be used.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a dispatch command with the given number of work groups in the X, Y,\n"
  " * and Z dimensions.  Any of these values may be set to 1 if the respective\n"
  " * dimension should not be used.\n"
  " */";
#else
static const char *Dtool_ComputeNode_add_dispatch_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ComputeNode::get_num_dispatches(void) const
 */
static PyObject *Dtool_ComputeNode_get_num_dispatches_33(PyObject *self, PyObject *) {
  ComputeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ComputeNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ComputeNode::get_num_dispatches(void) const
  std::size_t return_value = (*(const ComputeNode*)local_this).get_num_dispatches();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ComputeNode_get_num_dispatches_33_comment =
  "C++ Interface:\n"
  "get_num_dispatches(ComputeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of times add_dispatch has been called on this object.\n"
  " */";
#else
static const char *Dtool_ComputeNode_get_num_dispatches_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3i const &ComputeNode::get_dispatch(std::size_t i) const
 */
static PyObject *Dtool_ComputeNode_get_dispatch_34(PyObject *self, PyObject *arg) {
  ComputeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ComputeNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3i const &ComputeNode::get_dispatch(std::size_t i) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_dispatch", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    LVecBase3i const *return_value = &((*(const ComputeNode*)local_this).get_dispatch((std::size_t)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_dispatch(ComputeNode self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ComputeNode_get_dispatch_34_comment =
  "C++ Interface:\n"
  "get_dispatch(ComputeNode self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the group counts of the nth dispatch associated with this object.\n"
  " */";
#else
static const char *Dtool_ComputeNode_get_dispatch_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ComputeNode::set_dispatch(std::size_t i, LVecBase3i const &num_groups)
 */
static PyObject *Dtool_ComputeNode_set_dispatch_35(PyObject *self, PyObject *args, PyObject *kwds) {
  ComputeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ComputeNode, (void **)&local_this, "ComputeNode.set_dispatch")) {
    return NULL;
  }
  // 1-inline void ComputeNode::set_dispatch(std::size_t i, LVecBase3i const &num_groups)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"i", "num_groups", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_dispatch", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    LVecBase3i param2_local;
    LVecBase3i const *param2_this = Dtool_Coerce_LVecBase3i(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ComputeNode.set_dispatch", "LVecBase3i");
    }
    (*local_this).set_dispatch((std::size_t)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_dispatch(const ComputeNode self, int i, const LVecBase3i num_groups)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ComputeNode_set_dispatch_35_comment =
  "C++ Interface:\n"
  "set_dispatch(const ComputeNode self, int i, const LVecBase3i num_groups)\n"
  "\n"
  "/**\n"
  " * Sets the group counts of the nth dispatch associated with this object.\n"
  " */";
#else
static const char *Dtool_ComputeNode_set_dispatch_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ComputeNode::remove_dispatch(std::size_t i)
 */
static PyObject *Dtool_ComputeNode_remove_dispatch_36(PyObject *self, PyObject *arg) {
  ComputeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ComputeNode, (void **)&local_this, "ComputeNode.remove_dispatch")) {
    return NULL;
  }
  // 1-inline void ComputeNode::remove_dispatch(std::size_t i)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:remove_dispatch", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).remove_dispatch((std::size_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_dispatch(const ComputeNode self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ComputeNode_remove_dispatch_36_comment =
  "C++ Interface:\n"
  "remove_dispatch(const ComputeNode self, int i)\n"
  "\n"
  "/**\n"
  " * Erases the given dispatch index from the list.\n"
  " */";
#else
static const char *Dtool_ComputeNode_remove_dispatch_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ComputeNode::clear_dispatches(void)
 */
static PyObject *Dtool_ComputeNode_clear_dispatches_37(PyObject *self, PyObject *) {
  ComputeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ComputeNode, (void **)&local_this, "ComputeNode.clear_dispatches")) {
    return NULL;
  }
  // 1-inline void ComputeNode::clear_dispatches(void)
  (*local_this).clear_dispatches();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ComputeNode_clear_dispatches_37_comment =
  "C++ Interface:\n"
  "clear_dispatches(const ComputeNode self)\n"
  "\n"
  "/**\n"
  " * Removes all dispatch commands.\n"
  " */";
#else
static const char *Dtool_ComputeNode_clear_dispatches_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ComputeNode::get_class_type(void)
 */
static PyObject *Dtool_ComputeNode_get_class_type_42(PyObject *, PyObject *) {
  // 1-static TypeHandle ComputeNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ComputeNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ComputeNode_get_class_type_42_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ComputeNode_get_class_type_42_comment = NULL;
#endif

/**
 * sequence length function for property ComputeNode::dispatches
 */
static Py_ssize_t Dtool_ComputeNode_dispatches_Len(PyObject *self) {
  ComputeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ComputeNode, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_dispatches();
}

/**
 * sequence getter for property ComputeNode::dispatches
 */
static PyObject *Dtool_ComputeNode_dispatches_Getitem(PyObject *self, Py_ssize_t index) {
  ComputeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ComputeNode, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_dispatches()) {
    PyErr_SetString(PyExc_IndexError, "ComputeNode.dispatches[] index out of range");
    return NULL;
  }
  // 1-inline LVecBase3i const &ComputeNode::get_dispatch(std::size_t i) const
  LVecBase3i const *return_value = &((*(const ComputeNode*)local_this).get_dispatch(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_dispatch(ComputeNode self, index)\n");
  }
}

static int Dtool_ComputeNode_dispatches_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  ComputeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ComputeNode, (void **)&local_this, "ComputeNode.dispatches")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    local_this->remove_dispatch(index);
    return 0;
  }
  // 1-inline void ComputeNode::set_dispatch(std::size_t i, LVecBase3i const &num_groups)
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 2, "ComputeNode.set_dispatch", "LVecBase3i");
    return -1;
  }
  (*local_this).set_dispatch(index, *arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_dispatch(const ComputeNode self, index, const LVecBase3i num_groups)\n");
  }
  return -1;
}

static PyObject *Dtool_ComputeNode_dispatches_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_ComputeNode_dispatches_Len;
  wrap->_getitem_func = &Dtool_ComputeNode_dispatches_Getitem;
  wrap->_setitem_func = &Dtool_ComputeNode_dispatches_Setitem;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * ComputeNode::ComputeNode(std::string const &name)
 */
static int Dtool_Init_ComputeNode(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ComputeNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-ComputeNode::ComputeNode(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    ComputeNode *return_value = new ComputeNode(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ComputeNode, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ComputeNode(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ComputeNode(PyObject *args, CPT(ComputeNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ComputeNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ComputeNode::ComputeNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ComputeNode *return_value = new ComputeNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_ComputeNode(PyObject *args, PT(ComputeNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ComputeNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ComputeNode::ComputeNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ComputeNode *return_value = new ComputeNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ComputeNode_get_dispatches(PyObject *self, PyObject *) {
  ComputeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ComputeNode, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_dispatches();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ComputeNode_get_dispatch_34(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_ComputeNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ComputeNode) {
    printf("ComputeNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ComputeNode *local_this = (ComputeNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ComputeNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ComputeNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ComputeNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ComputeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (ComputeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ComputeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ComputeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ComputeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ComputeNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LightLensNode
 */
/**
 * Python function wrapper for:
 * inline bool LightLensNode::is_shadow_caster(void)
 */
static PyObject *Dtool_LightLensNode_is_shadow_caster_52(PyObject *self, PyObject *) {
  LightLensNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightLensNode, (void **)&local_this, "LightLensNode.is_shadow_caster")) {
    return NULL;
  }
  // 1-inline bool LightLensNode::is_shadow_caster(void)
  bool return_value = (*local_this).is_shadow_caster();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_is_shadow_caster_52_comment =
  "C++ Interface:\n"
  "is_shadow_caster(const LightLensNode self)\n"
  "\n"
  "/**\n"
  " * Returns whether this light is configured to cast shadows or not.\n"
  " */";
#else
static const char *Dtool_LightLensNode_is_shadow_caster_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LightLensNode::set_shadow_caster(bool caster)
 * inline void LightLensNode::set_shadow_caster(bool caster, int buffer_xsize, int buffer_ysize, int sort = -10)
 */
static PyObject *Dtool_LightLensNode_set_shadow_caster_53(PyObject *self, PyObject *args, PyObject *kwds) {
  LightLensNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightLensNode, (void **)&local_this, "LightLensNode.set_shadow_caster")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "caster");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'caster' (pos 1) not found");
      }
      // 1-inline void LightLensNode::set_shadow_caster(bool caster)
      (*local_this).set_shadow_caster((PyObject_IsTrue(arg) != 0));
      return Dtool_Return_None();
    }
    break;
  case 3:
  case 4:
    {
      // 1-inline void LightLensNode::set_shadow_caster(bool caster, int buffer_xsize, int buffer_ysize, int sort = -10)
      PyObject *param1;
      int param2;
      int param3;
      int param4 = -10;
      static const char *keyword_list[] = {"caster", "buffer_xsize", "buffer_ysize", "sort", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|i:set_shadow_caster", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_shadow_caster((PyObject_IsTrue(param1) != 0), (int)param2, (int)param3, (int)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_shadow_caster() takes 2, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow_caster(const LightLensNode self, bool caster)\n"
      "set_shadow_caster(const LightLensNode self, bool caster, int buffer_xsize, int buffer_ysize, int sort)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_set_shadow_caster_53_comment =
  "C++ Interface:\n"
  "set_shadow_caster(const LightLensNode self, bool caster)\n"
  "set_shadow_caster(const LightLensNode self, bool caster, int buffer_xsize, int buffer_ysize, int sort)\n"
  "\n"
  "/**\n"
  " * Sets the flag indicating whether this light should cast shadows or not.\n"
  " * This is the variant without buffer size, meaning that the current buffer\n"
  " * size will be kept (512x512 is the default). Note that enabling shadows will\n"
  " * require the shader generator to be enabled on the scene.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the flag indicating whether this light should cast shadows or not.\n"
  " * The xsize and ysize parameters specify the size of the shadow buffer that\n"
  " * will be set up, the sort parameter specifies the sort.  Note that enabling\n"
  " * shadows will require the shader generator to be enabled on the scene.\n"
  " */";
#else
static const char *Dtool_LightLensNode_set_shadow_caster_53_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i LightLensNode::get_shadow_buffer_size(void) const
 */
static PyObject *Dtool_LightLensNode_get_shadow_buffer_size_54(PyObject *self, PyObject *) {
  LightLensNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightLensNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2i LightLensNode::get_shadow_buffer_size(void) const
  LVecBase2i *return_value = new LVecBase2i((*(const LightLensNode*)local_this).get_shadow_buffer_size());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_get_shadow_buffer_size_54_comment =
  "C++ Interface:\n"
  "get_shadow_buffer_size(LightLensNode self)\n"
  "\n"
  "/**\n"
  " * Returns the size of the shadow buffer to be created for this light source.\n"
  " */";
#else
static const char *Dtool_LightLensNode_get_shadow_buffer_size_54_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LightLensNode::set_shadow_buffer_size(LVecBase2i const &size)
 */
static PyObject *Dtool_LightLensNode_set_shadow_buffer_size_55(PyObject *self, PyObject *arg) {
  LightLensNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightLensNode, (void **)&local_this, "LightLensNode.set_shadow_buffer_size")) {
    return NULL;
  }
  // 1-inline void LightLensNode::set_shadow_buffer_size(LVecBase2i const &size)
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LightLensNode.set_shadow_buffer_size", "LVecBase2i");
  }
  (*local_this).set_shadow_buffer_size(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow_buffer_size(const LightLensNode self, const LVecBase2i size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_set_shadow_buffer_size_55_comment =
  "C++ Interface:\n"
  "set_shadow_buffer_size(const LightLensNode self, const LVecBase2i size)\n"
  "\n"
  "/**\n"
  " * Sets the size of the shadow buffer to be created for this light source.\n"
  " */";
#else
static const char *Dtool_LightLensNode_set_shadow_buffer_size_55_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsOutputBase *LightLensNode::get_shadow_buffer(GraphicsStateGuardianBase *gsg)
 */
static PyObject *Dtool_LightLensNode_get_shadow_buffer_56(PyObject *self, PyObject *arg) {
  LightLensNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightLensNode, (void **)&local_this, "LightLensNode.get_shadow_buffer")) {
    return NULL;
  }
  // 1-inline GraphicsOutputBase *LightLensNode::get_shadow_buffer(GraphicsStateGuardianBase *gsg)
  GraphicsStateGuardianBase *arg_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsStateGuardianBase, 1, "LightLensNode.get_shadow_buffer", false, true);
  if (arg_this != NULL) {
    GraphicsOutputBase *return_value = (*local_this).get_shadow_buffer(arg_this);
    if (return_value != (GraphicsOutputBase *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (GraphicsOutputBase *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutputBase, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_shadow_buffer(const LightLensNode self, GraphicsStateGuardianBase gsg)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_get_shadow_buffer_56_comment =
  "C++ Interface:\n"
  "get_shadow_buffer(const LightLensNode self, GraphicsStateGuardianBase gsg)\n"
  "\n"
  "/**\n"
  " * Returns the buffer that has been constructed for a given GSG, or NULL if no\n"
  " * such buffer has (yet) been constructed.  This should be used for debugging\n"
  " * only, you will not need to call this normally.\n"
  " */";
#else
static const char *Dtool_LightLensNode_get_shadow_buffer_56_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void LightLensNode::output(ostream &out) const
 */
static PyObject *Dtool_LightLensNode_output_61(PyObject *self, PyObject *arg) {
  LightLensNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightLensNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void LightLensNode::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LightLensNode.output", false, true);
  if (arg_this != NULL) {
    (*(const LightLensNode*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LightLensNode self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_output_61_comment =
  "C++ Interface:\n"
  "output(LightLensNode self, ostream out)\n"
  "\n"
  "// We have to explicitly publish these because they resolve the multiple\n"
  "// inheritance.\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LightLensNode_output_61_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void LightLensNode::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_LightLensNode_write_62(PyObject *self, PyObject *args, PyObject *kwds) {
  LightLensNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightLensNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void LightLensNode::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "LightLensNode.write", false, true);
    if (param1_this != NULL) {
      (*(const LightLensNode*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(LightLensNode self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_write_62_comment =
  "C++ Interface:\n"
  "write(LightLensNode self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LightLensNode_write_62_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LightLensNode::get_class_type(void)
 */
static PyObject *Dtool_LightLensNode_get_class_type_63(PyObject *, PyObject *) {
  // 1-static TypeHandle LightLensNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LightLensNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_get_class_type_63_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LightLensNode_get_class_type_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Light *LightLensNode::upcast_to_Light(void)
 */
static PyObject *Dtool_LightLensNode_upcast_to_Light_46(PyObject *self, PyObject *) {
  LightLensNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightLensNode, (void **)&local_this, "LightLensNode.upcast_to_Light")) {
    return NULL;
  }
  // 1-Light *LightLensNode::upcast_to_Light(void)
  Light *return_value = (Light *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Light, false, false);
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_upcast_to_Light_46_comment =
  "C++ Interface:\n"
  "upcast_to_Light(const LightLensNode self)\n"
  "\n"
  "upcast from LightLensNode to Light";
#else
static const char *Dtool_LightLensNode_upcast_to_Light_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Camera *LightLensNode::upcast_to_Camera(void)
 */
static PyObject *Dtool_LightLensNode_upcast_to_Camera_49(PyObject *self, PyObject *) {
  LightLensNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightLensNode, (void **)&local_this, "LightLensNode.upcast_to_Camera")) {
    return NULL;
  }
  // 1-Camera *LightLensNode::upcast_to_Camera(void)
  Camera *return_value = (Camera *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Camera, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_upcast_to_Camera_49_comment =
  "C++ Interface:\n"
  "upcast_to_Camera(const LightLensNode self)\n"
  "\n"
  "upcast from LightLensNode to Camera";
#else
static const char *Dtool_LightLensNode_upcast_to_Camera_49_comment = NULL;
#endif

static PyObject *Dtool_LightLensNode_shadow_caster_Getter(PyObject *self, void *) {
  LightLensNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightLensNode, (void **)&local_this, "LightLensNode.shadow_caster")) {
    return NULL;
  }

  // 1-inline bool LightLensNode::is_shadow_caster(void)
  bool return_value = (*local_this).is_shadow_caster();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_LightLensNode_shadow_buffer_size_Getter(PyObject *self, void *) {
  const LightLensNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightLensNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2i LightLensNode::get_shadow_buffer_size(void) const
  LVecBase2i *return_value = new LVecBase2i((*(const LightLensNode*)local_this).get_shadow_buffer_size());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

static int Dtool_LightLensNode_shadow_buffer_size_Setter(PyObject *self, PyObject *arg, void *) {
  LightLensNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightLensNode, (void **)&local_this, "LightLensNode.shadow_buffer_size")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete shadow_buffer_size attribute");
    return -1;
  }
  // 1-inline void LightLensNode::set_shadow_buffer_size(LVecBase2i const &size)
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LightLensNode.set_shadow_buffer_size", "LVecBase2i");
    return -1;
  }
  (*local_this).set_shadow_buffer_size(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_shadow_buffer_size(const LightLensNode self, const LVecBase2i size)\n");
  }
  return -1;
}

static int Dtool_Init_LightLensNode(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_LightLensNode(PyObject *args, CPT(LightLensNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LightLensNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_LightLensNode(PyObject *args, PT(LightLensNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LightLensNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LightLensNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LightLensNode) {
    printf("LightLensNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LightLensNode *local_this = (LightLensNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LightLensNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Camera) {
    return (Camera *) local_this;
  }
  if (requested_type == Dtool_Ptr_LensNode) {
    return (LensNode *)(Camera *) local_this;
  }
  if (requested_type == Dtool_Ptr_Light) {
    return (Light *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(LensNode *)(Camera *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(LensNode *)(Camera *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LightLensNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LightLensNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Camera) {
    Camera* other_this = (Camera*)from_this;
    return (LightLensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_LensNode) {
    LensNode* other_this = (LensNode*)from_this;
    return (LightLensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Light) {
    Light* other_this = (Light*)from_this;
    return (LightLensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (LightLensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (LightLensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LightLensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LightLensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (LightLensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (LightLensNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DirectionalLight
 */
/**
 * Python function wrapper for:
 * inline LColor const &DirectionalLight::get_specular_color(void) final
 */
static PyObject *Dtool_DirectionalLight_get_specular_color_66(PyObject *self, PyObject *) {
  DirectionalLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DirectionalLight, (void **)&local_this, "DirectionalLight.get_specular_color")) {
    return NULL;
  }
  // 1-inline LColor const &DirectionalLight::get_specular_color(void) final
  LColor const *return_value = &((*local_this).get_specular_color());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DirectionalLight_get_specular_color_66_comment =
  "C++ Interface:\n"
  "get_specular_color(const DirectionalLight self)\n"
  "\n"
  "/**\n"
  " * Returns the color of specular highlights generated by the light.  This is\n"
  " * usually the same as get_color().\n"
  " */";
#else
static const char *Dtool_DirectionalLight_get_specular_color_66_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DirectionalLight::set_specular_color(LColor const &color)
 */
static PyObject *Dtool_DirectionalLight_set_specular_color_67(PyObject *self, PyObject *arg) {
  DirectionalLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DirectionalLight, (void **)&local_this, "DirectionalLight.set_specular_color")) {
    return NULL;
  }
  // 1-inline void DirectionalLight::set_specular_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DirectionalLight.set_specular_color", "LVecBase4f");
  }
  (*local_this).set_specular_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_specular_color(const DirectionalLight self, const LVecBase4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DirectionalLight_set_specular_color_67_comment =
  "C++ Interface:\n"
  "set_specular_color(const DirectionalLight self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Sets the color of specular highlights generated by the light.\n"
  " */";
#else
static const char *Dtool_DirectionalLight_set_specular_color_67_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DirectionalLight::clear_specular_color(void)
 */
static PyObject *Dtool_DirectionalLight_clear_specular_color_68(PyObject *self, PyObject *) {
  DirectionalLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DirectionalLight, (void **)&local_this, "DirectionalLight.clear_specular_color")) {
    return NULL;
  }
  // 1-inline void DirectionalLight::clear_specular_color(void)
  (*local_this).clear_specular_color();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DirectionalLight_clear_specular_color_68_comment =
  "C++ Interface:\n"
  "clear_specular_color(const DirectionalLight self)\n"
  "\n"
  "/**\n"
  " * Clears a custom specular color setting, meaning that the specular color\n"
  " * will now come from the color.\n"
  " */";
#else
static const char *Dtool_DirectionalLight_clear_specular_color_68_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &DirectionalLight::get_point(void) const
 */
static PyObject *Dtool_DirectionalLight_get_point_74(PyObject *self, PyObject *) {
  DirectionalLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DirectionalLight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 const &DirectionalLight::get_point(void) const
  LPoint3 const *return_value = &((*(const DirectionalLight*)local_this).get_point());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DirectionalLight_get_point_74_comment =
  "C++ Interface:\n"
  "get_point(DirectionalLight self)\n"
  "\n"
  "/**\n"
  " * Returns the point in space at which the light is located.  This is local to\n"
  " * the coordinate space in which the light is assigned.\n"
  " *\n"
  " * This actually has no bearing on the visual effect of the light, since the\n"
  " * light is rendered as if it were infinitely far away.  This is only used to\n"
  " * create a visible representation of the light.\n"
  " */";
#else
static const char *Dtool_DirectionalLight_get_point_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DirectionalLight::set_point(LPoint3 const &point)
 */
static PyObject *Dtool_DirectionalLight_set_point_75(PyObject *self, PyObject *arg) {
  DirectionalLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DirectionalLight, (void **)&local_this, "DirectionalLight.set_point")) {
    return NULL;
  }
  // 1-inline void DirectionalLight::set_point(LPoint3 const &point)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DirectionalLight.set_point", "LPoint3f");
  }
  (*local_this).set_point(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point(const DirectionalLight self, const LPoint3f point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DirectionalLight_set_point_75_comment =
  "C++ Interface:\n"
  "set_point(const DirectionalLight self, const LPoint3f point)\n"
  "\n"
  "/**\n"
  " * Sets the point in space at which the light is located.\n"
  " */";
#else
static const char *Dtool_DirectionalLight_set_point_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 const &DirectionalLight::get_direction(void) const
 */
static PyObject *Dtool_DirectionalLight_get_direction_80(PyObject *self, PyObject *) {
  DirectionalLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DirectionalLight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3 const &DirectionalLight::get_direction(void) const
  LVector3 const *return_value = &((*(const DirectionalLight*)local_this).get_direction());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DirectionalLight_get_direction_80_comment =
  "C++ Interface:\n"
  "get_direction(DirectionalLight self)\n"
  "\n"
  "/**\n"
  " * Returns the direction in which the light is aimed.  This is local to the\n"
  " * coordinate space in which the light is assigned.\n"
  " */";
#else
static const char *Dtool_DirectionalLight_get_direction_80_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DirectionalLight::set_direction(LVector3 const &direction)
 */
static PyObject *Dtool_DirectionalLight_set_direction_81(PyObject *self, PyObject *arg) {
  DirectionalLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DirectionalLight, (void **)&local_this, "DirectionalLight.set_direction")) {
    return NULL;
  }
  // 1-inline void DirectionalLight::set_direction(LVector3 const &direction)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DirectionalLight.set_direction", "LVector3f");
  }
  (*local_this).set_direction(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_direction(const DirectionalLight self, const LVector3f direction)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DirectionalLight_set_direction_81_comment =
  "C++ Interface:\n"
  "set_direction(const DirectionalLight self, const LVector3f direction)\n"
  "\n"
  "/**\n"
  " * Sets the direction in which the light is aimed.\n"
  " */";
#else
static const char *Dtool_DirectionalLight_set_direction_81_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DirectionalLight::get_class_type(void)
 */
static PyObject *Dtool_DirectionalLight_get_class_type_86(PyObject *, PyObject *) {
  // 1-static TypeHandle DirectionalLight::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(DirectionalLight::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DirectionalLight_get_class_type_86_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DirectionalLight_get_class_type_86_comment = NULL;
#endif

static PyObject *Dtool_DirectionalLight_specular_color_Getter(PyObject *self, void *) {
  DirectionalLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DirectionalLight, (void **)&local_this, "DirectionalLight.specular_color")) {
    return NULL;
  }

  // 1-inline LColor const &DirectionalLight::get_specular_color(void) final
  LColor const *return_value = &((*local_this).get_specular_color());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_DirectionalLight_specular_color_Setter(PyObject *self, PyObject *arg, void *) {
  DirectionalLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DirectionalLight, (void **)&local_this, "DirectionalLight.specular_color")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete specular_color attribute");
    return -1;
  }
  // 1-inline void DirectionalLight::set_specular_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DirectionalLight.set_specular_color", "LVecBase4f");
    return -1;
  }
  (*local_this).set_specular_color(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_specular_color(const DirectionalLight self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_DirectionalLight_point_Getter(PyObject *self, void *) {
  const DirectionalLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DirectionalLight, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint3 const &DirectionalLight::get_point(void) const
  LPoint3 const *return_value = &((*(const DirectionalLight*)local_this).get_point());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_DirectionalLight_point_Setter(PyObject *self, PyObject *arg, void *) {
  DirectionalLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DirectionalLight, (void **)&local_this, "DirectionalLight.point")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete point attribute");
    return -1;
  }
  // 1-inline void DirectionalLight::set_point(LPoint3 const &point)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DirectionalLight.set_point", "LPoint3f");
    return -1;
  }
  (*local_this).set_point(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_point(const DirectionalLight self, const LPoint3f point)\n");
  }
  return -1;
}

static PyObject *Dtool_DirectionalLight_direction_Getter(PyObject *self, void *) {
  const DirectionalLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DirectionalLight, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector3 const &DirectionalLight::get_direction(void) const
  LVector3 const *return_value = &((*(const DirectionalLight*)local_this).get_direction());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

static int Dtool_DirectionalLight_direction_Setter(PyObject *self, PyObject *arg, void *) {
  DirectionalLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DirectionalLight, (void **)&local_this, "DirectionalLight.direction")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete direction attribute");
    return -1;
  }
  // 1-inline void DirectionalLight::set_direction(LVector3 const &direction)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DirectionalLight.set_direction", "LVector3f");
    return -1;
  }
  (*local_this).set_direction(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_direction(const DirectionalLight self, const LVector3f direction)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * DirectionalLight::DirectionalLight(std::string const &name)
 */
static int Dtool_Init_DirectionalLight(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "DirectionalLight() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-DirectionalLight::DirectionalLight(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    DirectionalLight *return_value = new DirectionalLight(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DirectionalLight, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DirectionalLight(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_DirectionalLight(PyObject *args, CPT(DirectionalLight) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_DirectionalLight, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-DirectionalLight::DirectionalLight(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      DirectionalLight *return_value = new DirectionalLight(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_DirectionalLight(PyObject *args, PT(DirectionalLight) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_DirectionalLight, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-DirectionalLight::DirectionalLight(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      DirectionalLight *return_value = new DirectionalLight(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_DirectionalLight(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DirectionalLight) {
    printf("DirectionalLight ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DirectionalLight *local_this = (DirectionalLight *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DirectionalLight) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Camera) {
    return (Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_LensNode) {
    return (LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Light) {
    return (Light *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_LightLensNode) {
    return (LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DirectionalLight(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DirectionalLight) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Camera) {
    Camera* other_this = (Camera*)from_this;
    return (DirectionalLight*)other_this;
  }
  if (from_type == Dtool_Ptr_LensNode) {
    LensNode* other_this = (LensNode*)from_this;
    return (DirectionalLight*)other_this;
  }
  if (from_type == Dtool_Ptr_Light) {
    Light* other_this = (Light*)from_this;
    return (DirectionalLight*)other_this;
  }
  if (from_type == Dtool_Ptr_LightLensNode) {
    LightLensNode* other_this = (LightLensNode*)from_this;
    return (DirectionalLight*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (DirectionalLight*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (DirectionalLight*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (DirectionalLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DirectionalLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (DirectionalLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (DirectionalLight*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LODNode
 */
/**
 * Python function wrapper for:
 * static PointerTo< LODNode > LODNode::make_default_lod(std::string const &name)
 */
static PyObject *Dtool_LODNode_make_default_lod_90(PyObject *, PyObject *arg) {
  // 1-static PointerTo< LODNode > LODNode::make_default_lod(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    PointerTo< LODNode > return_value = LODNode::make_default_lod(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    LODNode *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_LODNode, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_default_lod(str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_make_default_lod_90_comment =
  "C++ Interface:\n"
  "make_default_lod(str name)\n"
  "\n"
  "/**\n"
  " * Creates a new LODNode of the type specified by the default-lod-type config\n"
  " * variable.\n"
  " */";
#else
static const char *Dtool_LODNode_make_default_lod_90_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LODNode::add_switch(PN_stdfloat in, PN_stdfloat out)
 */
static PyObject *Dtool_LODNode_add_switch_91(PyObject *self, PyObject *args, PyObject *kwds) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.add_switch")) {
    return NULL;
  }
  // 1-inline void LODNode::add_switch(PN_stdfloat in, PN_stdfloat out)
  float param1;
  float param2;
  static const char *keyword_list[] = {"in", "out", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:add_switch", (char **)keyword_list, &param1, &param2)) {
    (*local_this).add_switch((PN_stdfloat)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_switch(const LODNode self, float in, float out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_add_switch_91_comment =
  "C++ Interface:\n"
  "add_switch(const LODNode self, float in, float out)\n"
  "\n"
  "/**\n"
  " * Adds a switch range to the LODNode.  This implies that the corresponding\n"
  " * child node has been parented to the node.\n"
  " *\n"
  " * The sense of in vs.  out distances is as if the object were coming towards\n"
  " * you from far away: it switches \"in\" at the far distance, and switches \"out\"\n"
  " * at the close distance.  Thus, \"in\" should be larger than \"out\".\n"
  " */";
#else
static const char *Dtool_LODNode_add_switch_91_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LODNode::set_switch(int index, PN_stdfloat in, PN_stdfloat out)
 */
static PyObject *Dtool_LODNode_set_switch_92(PyObject *self, PyObject *args, PyObject *kwds) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.set_switch")) {
    return NULL;
  }
  // 1-inline bool LODNode::set_switch(int index, PN_stdfloat in, PN_stdfloat out)
  int param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"index", "in", "out", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iff:set_switch", (char **)keyword_list, &param1, &param2, &param3)) {
    bool return_value = (*local_this).set_switch((int)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_switch(const LODNode self, int index, float in, float out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_set_switch_92_comment =
  "C++ Interface:\n"
  "set_switch(const LODNode self, int index, float in, float out)\n"
  "\n"
  "/**\n"
  " * Changes the switching range of a particular child of the LODNode.  See\n"
  " * add_switch().\n"
  " */";
#else
static const char *Dtool_LODNode_set_switch_92_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LODNode::clear_switches(void)
 */
static PyObject *Dtool_LODNode_clear_switches_93(PyObject *self, PyObject *) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.clear_switches")) {
    return NULL;
  }
  // 1-inline void LODNode::clear_switches(void)
  (*local_this).clear_switches();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LODNode_clear_switches_93_comment =
  "C++ Interface:\n"
  "clear_switches(const LODNode self)\n"
  "\n"
  "/**\n"
  " * Removes the set of switching ranges for the LODNode, presumably in\n"
  " * conjunction with removing all of its children.  See add_switch().\n"
  " */";
#else
static const char *Dtool_LODNode_clear_switches_93_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LODNode::get_num_switches(void) const
 */
static PyObject *Dtool_LODNode_get_num_switches_94(PyObject *self, PyObject *) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LODNode::get_num_switches(void) const
  int return_value = (*(const LODNode*)local_this).get_num_switches();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LODNode_get_num_switches_94_comment =
  "C++ Interface:\n"
  "get_num_switches(LODNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of switch ranges added to the LODNode.  This should\n"
  " * correspond to the number of children of the node in order for the LODNode\n"
  " * to function correctly.\n"
  " */";
#else
static const char *Dtool_LODNode_get_num_switches_94_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LODNode::get_in(int index) const
 */
static PyObject *Dtool_LODNode_get_in_95(PyObject *self, PyObject *arg) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat LODNode::get_in(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = (*(const LODNode*)local_this).get_in((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_in(LODNode self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_get_in_95_comment =
  "C++ Interface:\n"
  "get_in(LODNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the \"in\" distance of the indicated switch range.  This should be\n"
  " * larger than the \"out\" distance of the same range.\n"
  " */";
#else
static const char *Dtool_LODNode_get_in_95_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LODNode::get_out(int index) const
 */
static PyObject *Dtool_LODNode_get_out_97(PyObject *self, PyObject *arg) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat LODNode::get_out(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = (*(const LODNode*)local_this).get_out((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_out(LODNode self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_get_out_97_comment =
  "C++ Interface:\n"
  "get_out(LODNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the \"out\" distance of the indicated switch range.  This should be\n"
  " * smaller than the \"in\" distance of the same range.\n"
  " */";
#else
static const char *Dtool_LODNode_get_out_97_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LODNode::get_lowest_switch(void) const
 */
static PyObject *Dtool_LODNode_get_lowest_switch_99(PyObject *self, PyObject *) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LODNode::get_lowest_switch(void) const
  int return_value = (*(const LODNode*)local_this).get_lowest_switch();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LODNode_get_lowest_switch_99_comment =
  "C++ Interface:\n"
  "get_lowest_switch(LODNode self)\n"
  "\n"
  "/**\n"
  " * Returns the index number of the child with the lowest level of detail; that\n"
  " * is, the one that is designed to be seen from the farthest away.  This is\n"
  " * usually the first child, but it is not necessarily so.\n"
  " */";
#else
static const char *Dtool_LODNode_get_lowest_switch_99_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LODNode::get_highest_switch(void) const
 */
static PyObject *Dtool_LODNode_get_highest_switch_100(PyObject *self, PyObject *) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LODNode::get_highest_switch(void) const
  int return_value = (*(const LODNode*)local_this).get_highest_switch();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LODNode_get_highest_switch_100_comment =
  "C++ Interface:\n"
  "get_highest_switch(LODNode self)\n"
  "\n"
  "/**\n"
  " * Returns the index number of the child with the highest level of detail;\n"
  " * that is, the one that is designed to be seen from the closest to the\n"
  " * camera.  This is usually the last child, but it is not necessarily so.\n"
  " */";
#else
static const char *Dtool_LODNode_get_highest_switch_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LODNode::force_switch(int index)
 */
static PyObject *Dtool_LODNode_force_switch_101(PyObject *self, PyObject *arg) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.force_switch")) {
    return NULL;
  }
  // 1-inline void LODNode::force_switch(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).force_switch((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "force_switch(const LODNode self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_force_switch_101_comment =
  "C++ Interface:\n"
  "force_switch(const LODNode self, int index)\n"
  "\n"
  "/**\n"
  " * Forces the LODNode to show the indicated level instead of the level that\n"
  " * would normally be shown based on the distance from the camera.\n"
  " */";
#else
static const char *Dtool_LODNode_force_switch_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LODNode::clear_force_switch(void)
 */
static PyObject *Dtool_LODNode_clear_force_switch_102(PyObject *self, PyObject *) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.clear_force_switch")) {
    return NULL;
  }
  // 1-inline void LODNode::clear_force_switch(void)
  (*local_this).clear_force_switch();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LODNode_clear_force_switch_102_comment =
  "C++ Interface:\n"
  "clear_force_switch(const LODNode self)\n"
  "\n"
  "/**\n"
  " * Undoes the effect of a previous call to force_switch() and releases the\n"
  " * LODNode to once again display the normal level.\n"
  " */";
#else
static const char *Dtool_LODNode_clear_force_switch_102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LODNode::set_lod_scale(PN_stdfloat value)
 */
static PyObject *Dtool_LODNode_set_lod_scale_103(PyObject *self, PyObject *arg) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.set_lod_scale")) {
    return NULL;
  }
  // 1-inline void LODNode::set_lod_scale(PN_stdfloat value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_lod_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lod_scale(const LODNode self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_set_lod_scale_103_comment =
  "C++ Interface:\n"
  "set_lod_scale(const LODNode self, float value)\n"
  "\n"
  "// for performance tuning, increasing this value should improve performance\n"
  "// at the cost of model quality\n"
  "\n"
  "// for performance tuning, increasing this value should improve performance\n"
  "// at the cost of model quality\n"
  "\n"
  "/**\n"
  " * Sets the multiplier for lod distances.  A higher value means you'll see\n"
  " * farther switchs than normal\n"
  " */";
#else
static const char *Dtool_LODNode_set_lod_scale_103_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LODNode::get_lod_scale(void) const
 */
static PyObject *Dtool_LODNode_get_lod_scale_104(PyObject *self, PyObject *) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat LODNode::get_lod_scale(void) const
  PN_stdfloat return_value = (*(const LODNode*)local_this).get_lod_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LODNode_get_lod_scale_104_comment =
  "C++ Interface:\n"
  "get_lod_scale(LODNode self)\n"
  "\n"
  "/**\n"
  " * Returns the multiplier for lod distances\n"
  " */";
#else
static const char *Dtool_LODNode_get_lod_scale_104_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LODNode::set_center(LPoint3 const &center)
 */
static PyObject *Dtool_LODNode_set_center_105(PyObject *self, PyObject *arg) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.set_center")) {
    return NULL;
  }
  // 1-inline void LODNode::set_center(LPoint3 const &center)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LODNode.set_center", "LPoint3f");
  }
  (*local_this).set_center(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_center(const LODNode self, const LPoint3f center)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_set_center_105_comment =
  "C++ Interface:\n"
  "set_center(const LODNode self, const LPoint3f center)\n"
  "\n"
  "/**\n"
  " * Specifies the center of the LOD.  This is the point that is compared to the\n"
  " * camera (in camera space) to determine the particular LOD that should be\n"
  " * chosen.\n"
  " */";
#else
static const char *Dtool_LODNode_set_center_105_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &LODNode::get_center(void) const
 */
static PyObject *Dtool_LODNode_get_center_106(PyObject *self, PyObject *) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 const &LODNode::get_center(void) const
  LPoint3 const *return_value = &((*(const LODNode*)local_this).get_center());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LODNode_get_center_106_comment =
  "C++ Interface:\n"
  "get_center(LODNode self)\n"
  "\n"
  "/**\n"
  " * Returns the center of the LOD.  This is the point that is compared to the\n"
  " * camera (in camera space) to determine the particular LOD that should be\n"
  " * chosen.\n"
  " */";
#else
static const char *Dtool_LODNode_get_center_106_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LODNode::show_switch(int index)
 * void LODNode::show_switch(int index, LColor const &color)
 */
static PyObject *Dtool_LODNode_show_switch_116(PyObject *self, PyObject *args, PyObject *kwds) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.show_switch")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "index");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'index' (pos 1) not found");
      }
      // 1-void LODNode::show_switch(int index)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        (*local_this).show_switch((int)arg_val);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void LODNode::show_switch(int index, LColor const &color)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"index", "color", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:show_switch", (char **)keyword_list, &param1, &param2)) {
        LVecBase4f param2_local;
        LColor const *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "LODNode.show_switch", "LVecBase4f");
        }
        (*local_this).show_switch((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "show_switch() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "show_switch(const LODNode self, int index)\n"
      "show_switch(const LODNode self, int index, const LVecBase4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_show_switch_116_comment =
  "C++ Interface:\n"
  "show_switch(const LODNode self, int index)\n"
  "show_switch(const LODNode self, int index, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * This is provided as a debugging aid.  show_switch() will put the LODNode\n"
  " * into a special mode where rather than computing and drawing the appropriate\n"
  " * level of the LOD, a ring is drawn around the LODNode center indicating the\n"
  " * switch distances from the camera for the indicated level, and the geometry\n"
  " * of the indicated level is drawn in wireframe.\n"
  " *\n"
  " * Multiple different levels can be visualized this way at once.  Call\n"
  " * hide_switch() or hide_all_switches() to undo this mode and restore the\n"
  " * LODNode to its normal behavior.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This is provided as a debugging aid.  show_switch() will put the LODNode\n"
  " * into a special mode where rather than computing and drawing the appropriate\n"
  " * level of the LOD, a ring is drawn around the LODNode center indicating the\n"
  " * switch distances from the camera for the indicated level, and the geometry\n"
  " * of the indicated level is drawn in wireframe.\n"
  " *\n"
  " * Multiple different levels can be visualized this way at once.  Call\n"
  " * hide_switch() or hide_all_switches() to undo this mode and restore the\n"
  " * LODNode to its normal behavior.\n"
  " */";
#else
static const char *Dtool_LODNode_show_switch_116_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LODNode::hide_switch(int index)
 */
static PyObject *Dtool_LODNode_hide_switch_117(PyObject *self, PyObject *arg) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.hide_switch")) {
    return NULL;
  }
  // 1-void LODNode::hide_switch(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).hide_switch((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "hide_switch(const LODNode self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_hide_switch_117_comment =
  "C++ Interface:\n"
  "hide_switch(const LODNode self, int index)\n"
  "\n"
  "/**\n"
  " * Disables a previous call to show_switch().\n"
  " */";
#else
static const char *Dtool_LODNode_hide_switch_117_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LODNode::show_all_switches(void)
 */
static PyObject *Dtool_LODNode_show_all_switches_118(PyObject *self, PyObject *) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.show_all_switches")) {
    return NULL;
  }
  // 1-void LODNode::show_all_switches(void)
  (*local_this).show_all_switches();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LODNode_show_all_switches_118_comment =
  "C++ Interface:\n"
  "show_all_switches(const LODNode self)\n"
  "\n"
  "/**\n"
  " * Shows all levels in their default colors.\n"
  " */";
#else
static const char *Dtool_LODNode_show_all_switches_118_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LODNode::hide_all_switches(void)
 */
static PyObject *Dtool_LODNode_hide_all_switches_119(PyObject *self, PyObject *) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.hide_all_switches")) {
    return NULL;
  }
  // 1-void LODNode::hide_all_switches(void)
  (*local_this).hide_all_switches();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LODNode_hide_all_switches_119_comment =
  "C++ Interface:\n"
  "hide_all_switches(const LODNode self)\n"
  "\n"
  "/**\n"
  " * Hides all levels, restoring the LODNode to normal operation.\n"
  " */";
#else
static const char *Dtool_LODNode_hide_all_switches_119_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LODNode::is_any_shown(void) const
 */
static PyObject *Dtool_LODNode_is_any_shown_120(PyObject *self, PyObject *) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LODNode::is_any_shown(void) const
  bool return_value = (*(const LODNode*)local_this).is_any_shown();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LODNode_is_any_shown_120_comment =
  "C++ Interface:\n"
  "is_any_shown(LODNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if any switch has been shown with show_switch(), indicating\n"
  " * the LODNode is in debug show mode; or false if it is in the normal mode.\n"
  " */";
#else
static const char *Dtool_LODNode_is_any_shown_120_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool LODNode::verify_child_bounds(void) const
 */
static PyObject *Dtool_LODNode_verify_child_bounds_121(PyObject *self, PyObject *) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool LODNode::verify_child_bounds(void) const
  bool return_value = (*(const LODNode*)local_this).verify_child_bounds();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LODNode_verify_child_bounds_121_comment =
  "C++ Interface:\n"
  "verify_child_bounds(LODNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the bounding volumes for the geometry of each fhild node\n"
  " * entirely fits within the switch_in radius for that child, or false\n"
  " * otherwise.  It is almost always a mistake for the geometry of an LOD level\n"
  " * to be larger than its switch_in radius.\n"
  " */";
#else
static const char *Dtool_LODNode_verify_child_bounds_121_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LODNode::get_class_type(void)
 */
static PyObject *Dtool_LODNode_get_class_type_122(PyObject *, PyObject *) {
  // 1-static TypeHandle LODNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LODNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LODNode_get_class_type_122_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LODNode_get_class_type_122_comment = NULL;
#endif

/**
 * sequence length function for property LODNode::ins
 */
static Py_ssize_t Dtool_LODNode_ins_Len(PyObject *self) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_switches();
}

/**
 * sequence getter for property LODNode::ins
 */
static PyObject *Dtool_LODNode_ins_Getitem(PyObject *self, Py_ssize_t index) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_switches()) {
    PyErr_SetString(PyExc_IndexError, "LODNode.ins[] index out of range");
    return NULL;
  }
  // 1-inline PN_stdfloat LODNode::get_in(int index) const
  PN_stdfloat return_value = (*(const LODNode*)local_this).get_in(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_in(LODNode self, index)\n");
  }
}

static PyObject *Dtool_LODNode_ins_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_LODNode_ins_Len;
  wrap->_getitem_func = &Dtool_LODNode_ins_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * sequence length function for property LODNode::outs
 */
static Py_ssize_t Dtool_LODNode_outs_Len(PyObject *self) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_switches();
}

/**
 * sequence getter for property LODNode::outs
 */
static PyObject *Dtool_LODNode_outs_Getitem(PyObject *self, Py_ssize_t index) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_switches()) {
    PyErr_SetString(PyExc_IndexError, "LODNode.outs[] index out of range");
    return NULL;
  }
  // 1-inline PN_stdfloat LODNode::get_out(int index) const
  PN_stdfloat return_value = (*(const LODNode*)local_this).get_out(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_out(LODNode self, index)\n");
  }
}

static PyObject *Dtool_LODNode_outs_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_LODNode_outs_Len;
  wrap->_getitem_func = &Dtool_LODNode_outs_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

static PyObject *Dtool_LODNode_lowest_switch_Getter(PyObject *self, void *) {
  const LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int LODNode::get_lowest_switch(void) const
  int return_value = (*(const LODNode*)local_this).get_lowest_switch();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_LODNode_highest_switch_Getter(PyObject *self, void *) {
  const LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int LODNode::get_highest_switch(void) const
  int return_value = (*(const LODNode*)local_this).get_highest_switch();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_LODNode_lod_scale_Getter(PyObject *self, void *) {
  const LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat LODNode::get_lod_scale(void) const
  PN_stdfloat return_value = (*(const LODNode*)local_this).get_lod_scale();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LODNode_lod_scale_Setter(PyObject *self, PyObject *arg, void *) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.lod_scale")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete lod_scale attribute");
    return -1;
  }
  // 1-inline void LODNode::set_lod_scale(PN_stdfloat value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_lod_scale((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_lod_scale(const LODNode self, float value)\n");
  }
  return -1;
}

static PyObject *Dtool_LODNode_center_Getter(PyObject *self, void *) {
  const LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint3 const &LODNode::get_center(void) const
  LPoint3 const *return_value = &((*(const LODNode*)local_this).get_center());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_LODNode_center_Setter(PyObject *self, PyObject *arg, void *) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.center")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete center attribute");
    return -1;
  }
  // 1-inline void LODNode::set_center(LPoint3 const &center)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LODNode.set_center", "LPoint3f");
    return -1;
  }
  (*local_this).set_center(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_center(const LODNode self, const LPoint3f center)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline LODNode::LODNode(std::string const &name)
 */
static int Dtool_Init_LODNode(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "LODNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-inline LODNode::LODNode(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    LODNode *return_value = new LODNode(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LODNode, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LODNode(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LODNode(PyObject *args, CPT(LODNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LODNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline LODNode::LODNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      LODNode *return_value = new LODNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_LODNode(PyObject *args, PT(LODNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LODNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline LODNode::LODNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      LODNode *return_value = new LODNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LODNode_get_ins(PyObject *self, PyObject *) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_switches();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_LODNode_get_in_95(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LODNode_get_outs(PyObject *self, PyObject *) {
  LODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_switches();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_LODNode_get_out_97(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_LODNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LODNode) {
    printf("LODNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LODNode *local_this = (LODNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LODNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LODNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LODNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (LODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (LODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (LODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (LODNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class FadeLODNode
 */
/**
 * Python function wrapper for:
 * inline void FadeLODNode::set_fade_time(PN_stdfloat t)
 */
static PyObject *Dtool_FadeLODNode_set_fade_time_126(PyObject *self, PyObject *arg) {
  FadeLODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FadeLODNode, (void **)&local_this, "FadeLODNode.set_fade_time")) {
    return NULL;
  }
  // 1-inline void FadeLODNode::set_fade_time(PN_stdfloat t)
  if (PyNumber_Check(arg)) {
    (*local_this).set_fade_time((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fade_time(const FadeLODNode self, float t)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FadeLODNode_set_fade_time_126_comment =
  "C++ Interface:\n"
  "set_fade_time(const FadeLODNode self, float t)\n"
  "\n"
  "/**\n"
  " * set the time taken to complete an LOD switch\n"
  " */";
#else
static const char *Dtool_FadeLODNode_set_fade_time_126_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat FadeLODNode::get_fade_time(void) const
 */
static PyObject *Dtool_FadeLODNode_get_fade_time_127(PyObject *self, PyObject *) {
  FadeLODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FadeLODNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat FadeLODNode::get_fade_time(void) const
  PN_stdfloat return_value = (*(const FadeLODNode*)local_this).get_fade_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FadeLODNode_get_fade_time_127_comment =
  "C++ Interface:\n"
  "get_fade_time(FadeLODNode self)\n"
  "\n"
  "/**\n"
  " * get the time taken to complete an LOD switch\n"
  " */";
#else
static const char *Dtool_FadeLODNode_get_fade_time_127_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void FadeLODNode::set_fade_bin(std::string const &name, int draw_order)
 */
static PyObject *Dtool_FadeLODNode_set_fade_bin_129(PyObject *self, PyObject *args, PyObject *kwds) {
  FadeLODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FadeLODNode, (void **)&local_this, "FadeLODNode.set_fade_bin")) {
    return NULL;
  }
  // 1-void FadeLODNode::set_fade_bin(std::string const &name, int draw_order)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  int param2;
  static const char *keyword_list[] = {"name", "draw_order", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:set_fade_bin", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    (*local_this).set_fade_bin(std::string(param1_str, param1_len), (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fade_bin(const FadeLODNode self, str name, int draw_order)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FadeLODNode_set_fade_bin_129_comment =
  "C++ Interface:\n"
  "set_fade_bin(const FadeLODNode self, str name, int draw_order)\n"
  "\n"
  "/**\n"
  " * Specifies the cull bin and draw order that is assigned to the fading part\n"
  " * of the geometry during a transition.\n"
  " */";
#else
static const char *Dtool_FadeLODNode_set_fade_bin_129_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &FadeLODNode::get_fade_bin_name(void) const
 */
static PyObject *Dtool_FadeLODNode_get_fade_bin_name_130(PyObject *self, PyObject *) {
  FadeLODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FadeLODNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &FadeLODNode::get_fade_bin_name(void) const
  std::string const &return_value = (*(const FadeLODNode*)local_this).get_fade_bin_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FadeLODNode_get_fade_bin_name_130_comment =
  "C++ Interface:\n"
  "get_fade_bin_name(FadeLODNode self)\n"
  "\n"
  "/**\n"
  " * Returns the cull bin that is assigned to the fading part of the geometry\n"
  " * during a transition.\n"
  " */";
#else
static const char *Dtool_FadeLODNode_get_fade_bin_name_130_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int FadeLODNode::get_fade_bin_draw_order(void) const
 */
static PyObject *Dtool_FadeLODNode_get_fade_bin_draw_order_131(PyObject *self, PyObject *) {
  FadeLODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FadeLODNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int FadeLODNode::get_fade_bin_draw_order(void) const
  int return_value = (*(const FadeLODNode*)local_this).get_fade_bin_draw_order();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FadeLODNode_get_fade_bin_draw_order_131_comment =
  "C++ Interface:\n"
  "get_fade_bin_draw_order(FadeLODNode self)\n"
  "\n"
  "/**\n"
  " * Returns the draw order that is assigned (along with the bin name) to the\n"
  " * fading part of the geometry during a transition.\n"
  " */";
#else
static const char *Dtool_FadeLODNode_get_fade_bin_draw_order_131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void FadeLODNode::set_fade_state_override(int override)
 */
static PyObject *Dtool_FadeLODNode_set_fade_state_override_137(PyObject *self, PyObject *arg) {
  FadeLODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FadeLODNode, (void **)&local_this, "FadeLODNode.set_fade_state_override")) {
    return NULL;
  }
  // 1-void FadeLODNode::set_fade_state_override(int override)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_fade_state_override((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fade_state_override(const FadeLODNode self, int override)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FadeLODNode_set_fade_state_override_137_comment =
  "C++ Interface:\n"
  "set_fade_state_override(const FadeLODNode self, int override)\n"
  "\n"
  "/**\n"
  " * Specifies the override value that is applied to the state changes necessary\n"
  " * to apply the fade effect.  This should be larger than any attrib overrides\n"
  " * on the fading geometry.\n"
  " */";
#else
static const char *Dtool_FadeLODNode_set_fade_state_override_137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int FadeLODNode::get_fade_state_override(void) const
 */
static PyObject *Dtool_FadeLODNode_get_fade_state_override_138(PyObject *self, PyObject *) {
  FadeLODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FadeLODNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int FadeLODNode::get_fade_state_override(void) const
  int return_value = (*(const FadeLODNode*)local_this).get_fade_state_override();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FadeLODNode_get_fade_state_override_138_comment =
  "C++ Interface:\n"
  "get_fade_state_override(FadeLODNode self)\n"
  "\n"
  "/**\n"
  " * Returns the override value that is applied to the state changes necessary\n"
  " * to apply the fade effect.  This should be larger than any attrib overrides\n"
  " * on the fading geometry.\n"
  " */";
#else
static const char *Dtool_FadeLODNode_get_fade_state_override_138_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle FadeLODNode::get_class_type(void)
 */
static PyObject *Dtool_FadeLODNode_get_class_type_140(PyObject *, PyObject *) {
  // 1-static TypeHandle FadeLODNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(FadeLODNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_FadeLODNode_get_class_type_140_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_FadeLODNode_get_class_type_140_comment = NULL;
#endif

static PyObject *Dtool_FadeLODNode_fade_time_Getter(PyObject *self, void *) {
  const FadeLODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FadeLODNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat FadeLODNode::get_fade_time(void) const
  PN_stdfloat return_value = (*(const FadeLODNode*)local_this).get_fade_time();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FadeLODNode_fade_time_Setter(PyObject *self, PyObject *arg, void *) {
  FadeLODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FadeLODNode, (void **)&local_this, "FadeLODNode.fade_time")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete fade_time attribute");
    return -1;
  }
  // 1-inline void FadeLODNode::set_fade_time(PN_stdfloat t)
  if (PyNumber_Check(arg)) {
    (*local_this).set_fade_time((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_fade_time(const FadeLODNode self, float t)\n");
  }
  return -1;
}

static PyObject *Dtool_FadeLODNode_fade_bin_name_Getter(PyObject *self, void *) {
  const FadeLODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FadeLODNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &FadeLODNode::get_fade_bin_name(void) const
  std::string const &return_value = (*(const FadeLODNode*)local_this).get_fade_bin_name();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_FadeLODNode_fade_bin_draw_order_Getter(PyObject *self, void *) {
  const FadeLODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FadeLODNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int FadeLODNode::get_fade_bin_draw_order(void) const
  int return_value = (*(const FadeLODNode*)local_this).get_fade_bin_draw_order();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_FadeLODNode_fade_state_override_Getter(PyObject *self, void *) {
  const FadeLODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FadeLODNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int FadeLODNode::get_fade_state_override(void) const
  int return_value = (*(const FadeLODNode*)local_this).get_fade_state_override();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FadeLODNode_fade_state_override_Setter(PyObject *self, PyObject *arg, void *) {
  FadeLODNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FadeLODNode, (void **)&local_this, "FadeLODNode.fade_state_override")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete fade_state_override attribute");
    return -1;
  }
  // 1-void FadeLODNode::set_fade_state_override(int override)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_fade_state_override((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_fade_state_override(const FadeLODNode self, int override)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * FadeLODNode::FadeLODNode(std::string const &name)
 */
static int Dtool_Init_FadeLODNode(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "FadeLODNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-FadeLODNode::FadeLODNode(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    FadeLODNode *return_value = new FadeLODNode(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FadeLODNode, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "FadeLODNode(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_FadeLODNode(PyObject *args, CPT(FadeLODNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_FadeLODNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-FadeLODNode::FadeLODNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      FadeLODNode *return_value = new FadeLODNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_FadeLODNode(PyObject *args, PT(FadeLODNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_FadeLODNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-FadeLODNode::FadeLODNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      FadeLODNode *return_value = new FadeLODNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_FadeLODNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_FadeLODNode) {
    printf("FadeLODNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  FadeLODNode *local_this = (FadeLODNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_FadeLODNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LODNode) {
    return (LODNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(LODNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(LODNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(LODNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LODNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LODNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(LODNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_FadeLODNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_FadeLODNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LODNode) {
    LODNode* other_this = (LODNode*)from_this;
    return (FadeLODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (FadeLODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (FadeLODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (FadeLODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (FadeLODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (FadeLODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (FadeLODNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class NodeCullCallbackData
 */
/**
 * Python function wrapper for:
 * inline CullTraverser *NodeCullCallbackData::get_trav(void) const
 */
static PyObject *Dtool_NodeCullCallbackData_get_trav_144(PyObject *self, PyObject *) {
  NodeCullCallbackData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodeCullCallbackData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CullTraverser *NodeCullCallbackData::get_trav(void) const
  CullTraverser *return_value = (*(const NodeCullCallbackData*)local_this).get_trav();
  if (return_value != (CullTraverser *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (CullTraverser *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CullTraverser, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_NodeCullCallbackData_get_trav_144_comment =
  "C++ Interface:\n"
  "get_trav(NodeCullCallbackData self)\n"
  "\n"
  "/**\n"
  " * Returns the CullTraverser in use at the time of the callback.  This object\n"
  " * contains data that does not change during the traversal, such as the\n"
  " * DisplayRegion and Camera in use.\n"
  " */";
#else
static const char *Dtool_NodeCullCallbackData_get_trav_144_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CullTraverserData &NodeCullCallbackData::get_data(void) const
 */
static PyObject *Dtool_NodeCullCallbackData_get_data_145(PyObject *self, PyObject *) {
  NodeCullCallbackData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodeCullCallbackData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CullTraverserData &NodeCullCallbackData::get_data(void) const
  CullTraverserData *return_value = &((*(const NodeCullCallbackData*)local_this).get_data());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_CullTraverserData, false, false);
}

#ifndef NDEBUG
static const char *Dtool_NodeCullCallbackData_get_data_145_comment =
  "C++ Interface:\n"
  "get_data(NodeCullCallbackData self)\n"
  "\n"
  "/**\n"
  " * Returns the CullTraverserData in use at the time of the callback.  This\n"
  " * object contains data that changes at each node of the traversal, such as\n"
  " * the current node and the current net transform to that node.\n"
  " */";
#else
static const char *Dtool_NodeCullCallbackData_get_data_145_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle NodeCullCallbackData::get_class_type(void)
 */
static PyObject *Dtool_NodeCullCallbackData_get_class_type_146(PyObject *, PyObject *) {
  // 1-static TypeHandle NodeCullCallbackData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(NodeCullCallbackData::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NodeCullCallbackData_get_class_type_146_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_NodeCullCallbackData_get_class_type_146_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodeCullCallbackData::NodeCullCallbackData(NodeCullCallbackData const &) = default
 */
static int Dtool_Init_NodeCullCallbackData(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "NodeCullCallbackData() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline NodeCullCallbackData::NodeCullCallbackData(NodeCullCallbackData const &) = default
  NodeCullCallbackData const *arg_this = (NodeCullCallbackData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodeCullCallbackData, 0, "NodeCullCallbackData.NodeCullCallbackData", true, true);
  if (arg_this != NULL) {
    NodeCullCallbackData *return_value = new NodeCullCallbackData(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NodeCullCallbackData, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NodeCullCallbackData(const NodeCullCallbackData param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_NodeCullCallbackData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_NodeCullCallbackData) {
    printf("NodeCullCallbackData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  NodeCullCallbackData *local_this = (NodeCullCallbackData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_NodeCullCallbackData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CallbackData) {
    return (CallbackData *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(CallbackData *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_NodeCullCallbackData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_NodeCullCallbackData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CallbackData) {
    CallbackData* other_this = (CallbackData*)from_this;
    return (NodeCullCallbackData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (NodeCullCallbackData*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointLight
 */
/**
 * Python function wrapper for:
 * inline LColor const &PointLight::get_specular_color(void) final
 */
static PyObject *Dtool_PointLight_get_specular_color_151(PyObject *self, PyObject *) {
  PointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.get_specular_color")) {
    return NULL;
  }
  // 1-inline LColor const &PointLight::get_specular_color(void) final
  LColor const *return_value = &((*local_this).get_specular_color());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PointLight_get_specular_color_151_comment =
  "C++ Interface:\n"
  "get_specular_color(const PointLight self)\n"
  "\n"
  "/**\n"
  " * Returns the color of specular highlights generated by the light.  This is\n"
  " * usually the same as get_color().\n"
  " */";
#else
static const char *Dtool_PointLight_get_specular_color_151_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointLight::set_specular_color(LColor const &color)
 */
static PyObject *Dtool_PointLight_set_specular_color_152(PyObject *self, PyObject *arg) {
  PointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.set_specular_color")) {
    return NULL;
  }
  // 1-inline void PointLight::set_specular_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointLight.set_specular_color", "LVecBase4f");
  }
  (*local_this).set_specular_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_specular_color(const PointLight self, const LVecBase4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointLight_set_specular_color_152_comment =
  "C++ Interface:\n"
  "set_specular_color(const PointLight self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Sets the color of specular highlights generated by the light.\n"
  " */";
#else
static const char *Dtool_PointLight_set_specular_color_152_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointLight::clear_specular_color(void)
 */
static PyObject *Dtool_PointLight_clear_specular_color_153(PyObject *self, PyObject *) {
  PointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.clear_specular_color")) {
    return NULL;
  }
  // 1-inline void PointLight::clear_specular_color(void)
  (*local_this).clear_specular_color();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointLight_clear_specular_color_153_comment =
  "C++ Interface:\n"
  "clear_specular_color(const PointLight self)\n"
  "\n"
  "/**\n"
  " * Clears a custom specular color setting, meaning that the specular color\n"
  " * will now come from the color.\n"
  " */";
#else
static const char *Dtool_PointLight_clear_specular_color_153_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3 const &PointLight::get_attenuation(void) final
 */
static PyObject *Dtool_PointLight_get_attenuation_155(PyObject *self, PyObject *) {
  PointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.get_attenuation")) {
    return NULL;
  }
  // 1-inline LVecBase3 const &PointLight::get_attenuation(void) final
  LVecBase3 const *return_value = &((*local_this).get_attenuation());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PointLight_get_attenuation_155_comment =
  "C++ Interface:\n"
  "get_attenuation(const PointLight self)\n"
  "\n"
  "/**\n"
  " * Returns the terms of the attenuation equation for the light.  These are, in\n"
  " * order, the constant, linear, and quadratic terms based on the distance from\n"
  " * the point to the vertex.\n"
  " */";
#else
static const char *Dtool_PointLight_get_attenuation_155_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointLight::set_attenuation(LVecBase3 const &attenuation)
 */
static PyObject *Dtool_PointLight_set_attenuation_156(PyObject *self, PyObject *arg) {
  PointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.set_attenuation")) {
    return NULL;
  }
  // 1-inline void PointLight::set_attenuation(LVecBase3 const &attenuation)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointLight.set_attenuation", "LVecBase3f");
  }
  (*local_this).set_attenuation(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_attenuation(const PointLight self, const LVecBase3f attenuation)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointLight_set_attenuation_156_comment =
  "C++ Interface:\n"
  "set_attenuation(const PointLight self, const LVecBase3f attenuation)\n"
  "\n"
  "/**\n"
  " * Sets the terms of the attenuation equation for the light.  These are, in\n"
  " * order, the constant, linear, and quadratic terms based on the distance from\n"
  " * the point to the vertex.\n"
  " */";
#else
static const char *Dtool_PointLight_set_attenuation_156_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PointLight::get_max_distance(void) const
 */
static PyObject *Dtool_PointLight_get_max_distance_161(PyObject *self, PyObject *) {
  PointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointLight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat PointLight::get_max_distance(void) const
  PN_stdfloat return_value = (*(const PointLight*)local_this).get_max_distance();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointLight_get_max_distance_161_comment =
  "C++ Interface:\n"
  "get_max_distance(PointLight self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum distance at which the light has any effect, as previously\n"
  " * specified by set_max_distance.\n"
  " */";
#else
static const char *Dtool_PointLight_get_max_distance_161_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointLight::set_max_distance(PN_stdfloat max_distance)
 */
static PyObject *Dtool_PointLight_set_max_distance_162(PyObject *self, PyObject *arg) {
  PointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.set_max_distance")) {
    return NULL;
  }
  // 1-inline void PointLight::set_max_distance(PN_stdfloat max_distance)
  if (PyNumber_Check(arg)) {
    (*local_this).set_max_distance((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_distance(const PointLight self, float max_distance)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointLight_set_max_distance_162_comment =
  "C++ Interface:\n"
  "set_max_distance(const PointLight self, float max_distance)\n"
  "\n"
  "/**\n"
  " * Sets the radius of the light's sphere of influence.  Beyond this distance, the\n"
  " * light may be attenuated to zero, if this is supported by the shader.\n"
  " */";
#else
static const char *Dtool_PointLight_set_max_distance_162_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &PointLight::get_point(void) const
 */
static PyObject *Dtool_PointLight_get_point_164(PyObject *self, PyObject *) {
  PointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointLight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 const &PointLight::get_point(void) const
  LPoint3 const *return_value = &((*(const PointLight*)local_this).get_point());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PointLight_get_point_164_comment =
  "C++ Interface:\n"
  "get_point(PointLight self)\n"
  "\n"
  "/**\n"
  " * Returns the point in space at which the light is located.  This is local to\n"
  " * the coordinate space in which the light is assigned, and is usually 0.\n"
  " */";
#else
static const char *Dtool_PointLight_get_point_164_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointLight::set_point(LPoint3 const &point)
 */
static PyObject *Dtool_PointLight_set_point_165(PyObject *self, PyObject *arg) {
  PointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.set_point")) {
    return NULL;
  }
  // 1-inline void PointLight::set_point(LPoint3 const &point)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointLight.set_point", "LPoint3f");
  }
  (*local_this).set_point(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point(const PointLight self, const LPoint3f point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointLight_set_point_165_comment =
  "C++ Interface:\n"
  "set_point(const PointLight self, const LPoint3f point)\n"
  "\n"
  "/**\n"
  " * Sets the point in space at which the light is located.  Usually 0.\n"
  " */";
#else
static const char *Dtool_PointLight_set_point_165_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PointLight::get_class_type(void)
 */
static PyObject *Dtool_PointLight_get_class_type_167(PyObject *, PyObject *) {
  // 1-static TypeHandle PointLight::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PointLight::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PointLight_get_class_type_167_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PointLight_get_class_type_167_comment = NULL;
#endif

static PyObject *Dtool_PointLight_specular_color_Getter(PyObject *self, void *) {
  PointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.specular_color")) {
    return NULL;
  }

  // 1-inline LColor const &PointLight::get_specular_color(void) final
  LColor const *return_value = &((*local_this).get_specular_color());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_PointLight_specular_color_Setter(PyObject *self, PyObject *arg, void *) {
  PointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.specular_color")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete specular_color attribute");
    return -1;
  }
  // 1-inline void PointLight::set_specular_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "PointLight.set_specular_color", "LVecBase4f");
    return -1;
  }
  (*local_this).set_specular_color(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_specular_color(const PointLight self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_PointLight_attenuation_Getter(PyObject *self, void *) {
  PointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.attenuation")) {
    return NULL;
  }

  // 1-inline LVecBase3 const &PointLight::get_attenuation(void) final
  LVecBase3 const *return_value = &((*local_this).get_attenuation());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

static int Dtool_PointLight_attenuation_Setter(PyObject *self, PyObject *arg, void *) {
  PointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.attenuation")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete attenuation attribute");
    return -1;
  }
  // 1-inline void PointLight::set_attenuation(LVecBase3 const &attenuation)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "PointLight.set_attenuation", "LVecBase3f");
    return -1;
  }
  (*local_this).set_attenuation(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_attenuation(const PointLight self, const LVecBase3f attenuation)\n");
  }
  return -1;
}

static PyObject *Dtool_PointLight_max_distance_Getter(PyObject *self, void *) {
  const PointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointLight, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat PointLight::get_max_distance(void) const
  PN_stdfloat return_value = (*(const PointLight*)local_this).get_max_distance();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PointLight_max_distance_Setter(PyObject *self, PyObject *arg, void *) {
  PointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.max_distance")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete max_distance attribute");
    return -1;
  }
  // 1-inline void PointLight::set_max_distance(PN_stdfloat max_distance)
  if (PyNumber_Check(arg)) {
    (*local_this).set_max_distance((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_distance(const PointLight self, float max_distance)\n");
  }
  return -1;
}

static PyObject *Dtool_PointLight_point_Getter(PyObject *self, void *) {
  const PointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointLight, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint3 const &PointLight::get_point(void) const
  LPoint3 const *return_value = &((*(const PointLight*)local_this).get_point());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_PointLight_point_Setter(PyObject *self, PyObject *arg, void *) {
  PointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.point")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete point attribute");
    return -1;
  }
  // 1-inline void PointLight::set_point(LPoint3 const &point)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "PointLight.set_point", "LPoint3f");
    return -1;
  }
  (*local_this).set_point(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_point(const PointLight self, const LPoint3f point)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * PointLight::PointLight(std::string const &name)
 */
static int Dtool_Init_PointLight(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PointLight() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-PointLight::PointLight(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    PointLight *return_value = new PointLight(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointLight, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointLight(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PointLight(PyObject *args, CPT(PointLight) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointLight, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PointLight::PointLight(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PointLight *return_value = new PointLight(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_PointLight(PyObject *args, PT(PointLight) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointLight, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PointLight::PointLight(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PointLight *return_value = new PointLight(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_PointLight(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointLight) {
    printf("PointLight ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointLight *local_this = (PointLight *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointLight) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Camera) {
    return (Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_LensNode) {
    return (LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Light) {
    return (Light *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_LightLensNode) {
    return (LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointLight(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointLight) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Camera) {
    Camera* other_this = (Camera*)from_this;
    return (PointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_LensNode) {
    LensNode* other_this = (LensNode*)from_this;
    return (PointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_Light) {
    Light* other_this = (Light*)from_this;
    return (PointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_LightLensNode) {
    LightLensNode* other_this = (LightLensNode*)from_this;
    return (PointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (PointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PointLight*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class SelectiveChildNode
 */
/**
 * Python function wrapper for:
 * static TypeHandle SelectiveChildNode::get_class_type(void)
 */
static PyObject *Dtool_SelectiveChildNode_get_class_type_171(PyObject *, PyObject *) {
  // 1-static TypeHandle SelectiveChildNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(SelectiveChildNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SelectiveChildNode_get_class_type_171_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SelectiveChildNode_get_class_type_171_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * SequenceNode *SelectiveChildNode::downcast_to_SequenceNode(void)
 */
static PyObject *Dtool_SelectiveChildNode_downcast_to_SequenceNode_175(PyObject *self, PyObject *) {
  SelectiveChildNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SelectiveChildNode, (void **)&local_this, "SelectiveChildNode.downcast_to_SequenceNode")) {
    return NULL;
  }
  // 1-SequenceNode *SelectiveChildNode::downcast_to_SequenceNode(void)
  SequenceNode *return_value = (SequenceNode *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_SequenceNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_SelectiveChildNode_downcast_to_SequenceNode_175_comment =
  "C++ Interface:\n"
  "downcast_to_SequenceNode(const SelectiveChildNode self)\n"
  "\n"
  "downcast from SelectiveChildNode to SequenceNode";
#else
static const char *Dtool_SelectiveChildNode_downcast_to_SequenceNode_175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline SelectiveChildNode::SelectiveChildNode(std::string const &name)
 */
static int Dtool_Init_SelectiveChildNode(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "SelectiveChildNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-inline SelectiveChildNode::SelectiveChildNode(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    SelectiveChildNode *return_value = new SelectiveChildNode(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SelectiveChildNode, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SelectiveChildNode(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_SelectiveChildNode(PyObject *args, CPT(SelectiveChildNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SelectiveChildNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline SelectiveChildNode::SelectiveChildNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      SelectiveChildNode *return_value = new SelectiveChildNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_SelectiveChildNode(PyObject *args, PT(SelectiveChildNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SelectiveChildNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline SelectiveChildNode::SelectiveChildNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      SelectiveChildNode *return_value = new SelectiveChildNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_SelectiveChildNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SelectiveChildNode) {
    printf("SelectiveChildNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SelectiveChildNode *local_this = (SelectiveChildNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SelectiveChildNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SelectiveChildNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SelectiveChildNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (SelectiveChildNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (SelectiveChildNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SelectiveChildNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (SelectiveChildNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (SelectiveChildNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (SelectiveChildNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class SequenceNode
 */
/**
 * Python function wrapper for:
 * virtual int SequenceNode::get_num_frames(void) const
 */
static PyObject *Dtool_SequenceNode_get_num_frames_180(PyObject *self, PyObject *) {
  SequenceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SequenceNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual int SequenceNode::get_num_frames(void) const
  int return_value = (*(const SequenceNode*)local_this).get_num_frames();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SequenceNode_get_num_frames_180_comment =
  "C++ Interface:\n"
  "get_num_frames(SequenceNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of frames in the animation.  This is a property of the\n"
  " * animation and may not be directly adjusted by the user (although it may\n"
  " * change without warning with certain kinds of animations, since this is a\n"
  " * virtual method that may be overridden).\n"
  " */";
#else
static const char *Dtool_SequenceNode_get_num_frames_180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SequenceNode::set_frame_rate(double frame_rate)
 */
static PyObject *Dtool_SequenceNode_set_frame_rate_181(PyObject *self, PyObject *arg) {
  SequenceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SequenceNode, (void **)&local_this, "SequenceNode.set_frame_rate")) {
    return NULL;
  }
  // 1-inline void SequenceNode::set_frame_rate(double frame_rate)
  if (PyNumber_Check(arg)) {
    (*local_this).set_frame_rate(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_rate(const SequenceNode self, double frame_rate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SequenceNode_set_frame_rate_181_comment =
  "C++ Interface:\n"
  "set_frame_rate(const SequenceNode self, double frame_rate)\n"
  "\n"
  "/**\n"
  " * Changes the advertised frame rate of the SequenceNode.  This can be used in\n"
  " * conjunction with get_play_rate() to change the effective frame rate of the\n"
  " * node.\n"
  " */";
#else
static const char *Dtool_SequenceNode_set_frame_rate_181_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle SequenceNode::get_class_type(void)
 */
static PyObject *Dtool_SequenceNode_get_class_type_182(PyObject *, PyObject *) {
  // 1-static TypeHandle SequenceNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(SequenceNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SequenceNode_get_class_type_182_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SequenceNode_get_class_type_182_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * SelectiveChildNode *SequenceNode::upcast_to_SelectiveChildNode(void)
 */
static PyObject *Dtool_SequenceNode_upcast_to_SelectiveChildNode_174(PyObject *self, PyObject *) {
  SequenceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SequenceNode, (void **)&local_this, "SequenceNode.upcast_to_SelectiveChildNode")) {
    return NULL;
  }
  // 1-SelectiveChildNode *SequenceNode::upcast_to_SelectiveChildNode(void)
  SelectiveChildNode *return_value = (SelectiveChildNode *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_SelectiveChildNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_SequenceNode_upcast_to_SelectiveChildNode_174_comment =
  "C++ Interface:\n"
  "upcast_to_SelectiveChildNode(const SequenceNode self)\n"
  "\n"
  "upcast from SequenceNode to SelectiveChildNode";
#else
static const char *Dtool_SequenceNode_upcast_to_SelectiveChildNode_174_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AnimInterface *SequenceNode::upcast_to_AnimInterface(void)
 */
static PyObject *Dtool_SequenceNode_upcast_to_AnimInterface_177(PyObject *self, PyObject *) {
  SequenceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SequenceNode, (void **)&local_this, "SequenceNode.upcast_to_AnimInterface")) {
    return NULL;
  }
  // 1-AnimInterface *SequenceNode::upcast_to_AnimInterface(void)
  AnimInterface *return_value = (AnimInterface *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AnimInterface, false, false);
}

#ifndef NDEBUG
static const char *Dtool_SequenceNode_upcast_to_AnimInterface_177_comment =
  "C++ Interface:\n"
  "upcast_to_AnimInterface(const SequenceNode self)\n"
  "\n"
  "upcast from SequenceNode to AnimInterface";
#else
static const char *Dtool_SequenceNode_upcast_to_AnimInterface_177_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline SequenceNode::SequenceNode(std::string const &name)
 */
static int Dtool_Init_SequenceNode(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "SequenceNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-inline SequenceNode::SequenceNode(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    SequenceNode *return_value = new SequenceNode(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SequenceNode, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SequenceNode(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_SequenceNode(PyObject *args, CPT(SequenceNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SequenceNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline SequenceNode::SequenceNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      SequenceNode *return_value = new SequenceNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_SequenceNode(PyObject *args, PT(SequenceNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SequenceNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline SequenceNode::SequenceNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      SequenceNode *return_value = new SequenceNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_SequenceNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SequenceNode) {
    printf("SequenceNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SequenceNode *local_this = (SequenceNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SequenceNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimInterface) {
    return (AnimInterface *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_SelectiveChildNode) {
    return (SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SequenceNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SequenceNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimInterface) {
    AnimInterface* other_this = (AnimInterface*)from_this;
    return (SequenceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (SequenceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (SequenceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SequenceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_SelectiveChildNode) {
    SelectiveChildNode* other_this = (SelectiveChildNode*)from_this;
    return (SequenceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (SequenceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (SequenceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (SequenceNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ShaderGenerator
 */
/**
 * Python function wrapper for:
 * virtual ConstPointerTo< ShaderAttrib > ShaderGenerator::synthesize_shader(RenderState const *rs, GeomVertexAnimationSpec const &anim)
 */
static PyObject *Dtool_ShaderGenerator_synthesize_shader_187(PyObject *self, PyObject *args, PyObject *kwds) {
  ShaderGenerator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderGenerator, (void **)&local_this, "ShaderGenerator.synthesize_shader")) {
    return NULL;
  }
  // 1-virtual ConstPointerTo< ShaderAttrib > ShaderGenerator::synthesize_shader(RenderState const *rs, GeomVertexAnimationSpec const &anim)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"rs", "anim", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:synthesize_shader", (char **)keyword_list, &param1, &param2)) {
    CPT(RenderState) param1_this;
    if (!Dtool_ConstCoerce_RenderState(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "ShaderGenerator.synthesize_shader", "RenderState");
    }
    GeomVertexAnimationSpec const *param2_this = (GeomVertexAnimationSpec *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GeomVertexAnimationSpec, 2, "ShaderGenerator.synthesize_shader", true, true);
    if (param2_this != NULL) {
      ConstPointerTo< ShaderAttrib > return_value = (*local_this).synthesize_shader(MOVE(param1_this), *param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      // Transfer ownership of return_value.
      ShaderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = NULL;
      if (return_ptr == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_ShaderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "synthesize_shader(const ShaderGenerator self, const RenderState rs, const GeomVertexAnimationSpec anim)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ShaderGenerator_synthesize_shader_187_comment =
  "C++ Interface:\n"
  "synthesize_shader(const ShaderGenerator self, const RenderState rs, const GeomVertexAnimationSpec anim)\n"
  "\n"
  "/**\n"
  " * This is the routine that implements the next-gen fixed function pipeline by\n"
  " * synthesizing a shader.  It also takes care of setting up any buffers needed\n"
  " * to produce the requested effects.\n"
  " *\n"
  " * Currently supports: - flat colors - vertex colors - lighting - normal maps,\n"
  " * but not multiple - gloss maps, but not multiple - glow maps, but not\n"
  " * multiple - materials, but not updates to materials - 2D textures - all\n"
  " * texture stage modes, including combine modes - color scale attrib - light\n"
  " * ramps (for cartoon shading) - shadow mapping - most texgen modes -\n"
  " * texmatrix - 1D/2D/3D textures, cube textures, 2D tex arrays -\n"
  " * linear/exp/exp2 fog - animation\n"
  " *\n"
  " * Not yet supported: - dot3_rgb and dot3_rgba combine modes\n"
  " *\n"
  " * Potential optimizations - omit attenuation calculations if attenuation off\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderGenerator_synthesize_shader_187_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ShaderGenerator::get_class_type(void)
 */
static PyObject *Dtool_ShaderGenerator_get_class_type_188(PyObject *, PyObject *) {
  // 1-static TypeHandle ShaderGenerator::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ShaderGenerator::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ShaderGenerator_get_class_type_188_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ShaderGenerator_get_class_type_188_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ShaderGenerator::ShaderGenerator(GraphicsStateGuardianBase *gsg, GraphicsOutputBase *host)
 * inline ShaderGenerator::ShaderGenerator(ShaderGenerator const &) = default
 */
static int Dtool_Init_ShaderGenerator(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline ShaderGenerator::ShaderGenerator(ShaderGenerator const &) = default
      CPT(ShaderGenerator) arg_this;
      if (!Dtool_ConstCoerce_ShaderGenerator(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "ShaderGenerator.ShaderGenerator", "ShaderGenerator");
        return -1;
      }
      ShaderGenerator *return_value = new ShaderGenerator(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderGenerator, true, false);
    }
    break;
  case 2:
    {
      // 1-ShaderGenerator::ShaderGenerator(GraphicsStateGuardianBase *gsg, GraphicsOutputBase *host)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"gsg", "host", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:ShaderGenerator", (char **)keyword_list, &param0, &param1)) {
        GraphicsStateGuardianBase *param0_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GraphicsStateGuardianBase, 0, "ShaderGenerator.ShaderGenerator", false, true);
        GraphicsOutputBase *param1_this = (GraphicsOutputBase *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsOutputBase, 1, "ShaderGenerator.ShaderGenerator", false, true);
        if (param0_this != NULL && param1_this != NULL) {
          ShaderGenerator *return_value = new ShaderGenerator(param0_this, param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderGenerator, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ShaderGenerator() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ShaderGenerator(const ShaderGenerator param0)\n"
      "ShaderGenerator(GraphicsStateGuardianBase gsg, GraphicsOutputBase host)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ShaderGenerator(PyObject *args, CPT(ShaderGenerator) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ShaderGenerator, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-ShaderGenerator::ShaderGenerator(GraphicsStateGuardianBase *gsg, GraphicsOutputBase *host)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "ShaderGenerator", 2, 2, &param0, &param1)) {
        GraphicsStateGuardianBase *param0_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GraphicsStateGuardianBase, 0, "ShaderGenerator.ShaderGenerator", false, false);
        GraphicsOutputBase *param1_this = (GraphicsOutputBase *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsOutputBase, 1, "ShaderGenerator.ShaderGenerator", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          ShaderGenerator *return_value = new ShaderGenerator(param0_this, param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_ShaderGenerator(PyObject *args, PT(ShaderGenerator) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ShaderGenerator, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-ShaderGenerator::ShaderGenerator(GraphicsStateGuardianBase *gsg, GraphicsOutputBase *host)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "ShaderGenerator", 2, 2, &param0, &param1)) {
        GraphicsStateGuardianBase *param0_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GraphicsStateGuardianBase, 0, "ShaderGenerator.ShaderGenerator", false, false);
        GraphicsOutputBase *param1_this = (GraphicsOutputBase *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsOutputBase, 1, "ShaderGenerator.ShaderGenerator", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          ShaderGenerator *return_value = new ShaderGenerator(param0_this, param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ShaderGenerator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ShaderGenerator) {
    printf("ShaderGenerator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ShaderGenerator *local_this = (ShaderGenerator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ShaderGenerator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ShaderGenerator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ShaderGenerator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ShaderGenerator*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ShaderGenerator*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (ShaderGenerator*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class SphereLight
 */
/**
 * Python function wrapper for:
 * inline PN_stdfloat SphereLight::get_radius(void) const
 */
static PyObject *Dtool_SphereLight_get_radius_191(PyObject *self, PyObject *) {
  SphereLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SphereLight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat SphereLight::get_radius(void) const
  PN_stdfloat return_value = (*(const SphereLight*)local_this).get_radius();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SphereLight_get_radius_191_comment =
  "C++ Interface:\n"
  "get_radius(SphereLight self)\n"
  "\n"
  "/**\n"
  " * Returns the radius of the sphere.\n"
  " */";
#else
static const char *Dtool_SphereLight_get_radius_191_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SphereLight::set_radius(PN_stdfloat radius)
 */
static PyObject *Dtool_SphereLight_set_radius_192(PyObject *self, PyObject *arg) {
  SphereLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SphereLight, (void **)&local_this, "SphereLight.set_radius")) {
    return NULL;
  }
  // 1-inline void SphereLight::set_radius(PN_stdfloat radius)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const SphereLight self, float radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SphereLight_set_radius_192_comment =
  "C++ Interface:\n"
  "set_radius(const SphereLight self, float radius)\n"
  "\n"
  "/**\n"
  " * Sets the radius of the sphere.\n"
  " */";
#else
static const char *Dtool_SphereLight_set_radius_192_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle SphereLight::get_class_type(void)
 */
static PyObject *Dtool_SphereLight_get_class_type_194(PyObject *, PyObject *) {
  // 1-static TypeHandle SphereLight::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(SphereLight::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SphereLight_get_class_type_194_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SphereLight_get_class_type_194_comment = NULL;
#endif

static PyObject *Dtool_SphereLight_radius_Getter(PyObject *self, void *) {
  const SphereLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SphereLight, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat SphereLight::get_radius(void) const
  PN_stdfloat return_value = (*(const SphereLight*)local_this).get_radius();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_SphereLight_radius_Setter(PyObject *self, PyObject *arg, void *) {
  SphereLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SphereLight, (void **)&local_this, "SphereLight.radius")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete radius attribute");
    return -1;
  }
  // 1-inline void SphereLight::set_radius(PN_stdfloat radius)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_radius(const SphereLight self, float radius)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * SphereLight::SphereLight(std::string const &name)
 */
static int Dtool_Init_SphereLight(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "SphereLight() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-SphereLight::SphereLight(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    SphereLight *return_value = new SphereLight(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SphereLight, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SphereLight(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_SphereLight(PyObject *args, CPT(SphereLight) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SphereLight, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-SphereLight::SphereLight(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      SphereLight *return_value = new SphereLight(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_SphereLight(PyObject *args, PT(SphereLight) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SphereLight, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-SphereLight::SphereLight(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      SphereLight *return_value = new SphereLight(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_SphereLight(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SphereLight) {
    printf("SphereLight ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SphereLight *local_this = (SphereLight *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SphereLight) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Camera) {
    return (Camera *)(LightLensNode *)(PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_LensNode) {
    return (LensNode *)(Camera *)(LightLensNode *)(PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_Light) {
    return (Light *)(LightLensNode *)(PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_LightLensNode) {
    return (LightLensNode *)(PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *)(PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(LensNode *)(Camera *)(LightLensNode *)(PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointLight) {
    return (PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *)(PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *)(PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *)(PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *)(PointLight *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SphereLight(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SphereLight) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Camera) {
    Camera* other_this = (Camera*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_LensNode) {
    LensNode* other_this = (LensNode*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_Light) {
    Light* other_this = (Light*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_LightLensNode) {
    LightLensNode* other_this = (LightLensNode*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_PointLight) {
    PointLight* other_this = (PointLight*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (SphereLight*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Spotlight
 */
/**
 * Python function wrapper for:
 * inline PN_stdfloat Spotlight::get_exponent(void) final
 */
static PyObject *Dtool_Spotlight_get_exponent_198(PyObject *self, PyObject *) {
  Spotlight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.get_exponent")) {
    return NULL;
  }
  // 1-inline PN_stdfloat Spotlight::get_exponent(void) final
  PN_stdfloat return_value = (*local_this).get_exponent();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Spotlight_get_exponent_198_comment =
  "C++ Interface:\n"
  "get_exponent(const Spotlight self)\n"
  "\n"
  "/**\n"
  " * Returns the exponent that controls the amount of light falloff from the\n"
  " * center of the spotlight.  See set_exponent().\n"
  " */";
#else
static const char *Dtool_Spotlight_get_exponent_198_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Spotlight::set_exponent(PN_stdfloat exponent)
 */
static PyObject *Dtool_Spotlight_set_exponent_199(PyObject *self, PyObject *arg) {
  Spotlight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.set_exponent")) {
    return NULL;
  }
  // 1-inline void Spotlight::set_exponent(PN_stdfloat exponent)
  if (PyNumber_Check(arg)) {
    (*local_this).set_exponent((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_exponent(const Spotlight self, float exponent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Spotlight_set_exponent_199_comment =
  "C++ Interface:\n"
  "set_exponent(const Spotlight self, float exponent)\n"
  "\n"
  "/**\n"
  " * Sets the exponent that controls the amount of light falloff from the center\n"
  " * of the spotlight.  The light is attenuated by the cosine of the angle\n"
  " * between the direction of the light and the direction of the point being\n"
  " * lighted, raised to the power of this exponent.  Thus, higher exponents\n"
  " * result in a more focused light source, regardless of the field-of-view of\n"
  " * the lens.\n"
  " */";
#else
static const char *Dtool_Spotlight_set_exponent_199_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &Spotlight::get_specular_color(void) final
 */
static PyObject *Dtool_Spotlight_get_specular_color_201(PyObject *self, PyObject *) {
  Spotlight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.get_specular_color")) {
    return NULL;
  }
  // 1-inline LColor const &Spotlight::get_specular_color(void) final
  LColor const *return_value = &((*local_this).get_specular_color());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Spotlight_get_specular_color_201_comment =
  "C++ Interface:\n"
  "get_specular_color(const Spotlight self)\n"
  "\n"
  "/**\n"
  " * Returns the color of specular highlights generated by the light.  This is\n"
  " * usually the same as get_color().\n"
  " */";
#else
static const char *Dtool_Spotlight_get_specular_color_201_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Spotlight::set_specular_color(LColor const &color)
 */
static PyObject *Dtool_Spotlight_set_specular_color_202(PyObject *self, PyObject *arg) {
  Spotlight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.set_specular_color")) {
    return NULL;
  }
  // 1-inline void Spotlight::set_specular_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Spotlight.set_specular_color", "LVecBase4f");
  }
  (*local_this).set_specular_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_specular_color(const Spotlight self, const LVecBase4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Spotlight_set_specular_color_202_comment =
  "C++ Interface:\n"
  "set_specular_color(const Spotlight self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Sets the color of specular highlights generated by the light.\n"
  " */";
#else
static const char *Dtool_Spotlight_set_specular_color_202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Spotlight::clear_specular_color(void)
 */
static PyObject *Dtool_Spotlight_clear_specular_color_203(PyObject *self, PyObject *) {
  Spotlight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.clear_specular_color")) {
    return NULL;
  }
  // 1-inline void Spotlight::clear_specular_color(void)
  (*local_this).clear_specular_color();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Spotlight_clear_specular_color_203_comment =
  "C++ Interface:\n"
  "clear_specular_color(const Spotlight self)\n"
  "\n"
  "/**\n"
  " * Clears a custom specular color setting, meaning that the specular color\n"
  " * will now come from the color.\n"
  " */";
#else
static const char *Dtool_Spotlight_clear_specular_color_203_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3 const &Spotlight::get_attenuation(void) final
 */
static PyObject *Dtool_Spotlight_get_attenuation_205(PyObject *self, PyObject *) {
  Spotlight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.get_attenuation")) {
    return NULL;
  }
  // 1-inline LVecBase3 const &Spotlight::get_attenuation(void) final
  LVecBase3 const *return_value = &((*local_this).get_attenuation());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Spotlight_get_attenuation_205_comment =
  "C++ Interface:\n"
  "get_attenuation(const Spotlight self)\n"
  "\n"
  "/**\n"
  " * Returns the terms of the attenuation equation for the light.  These are, in\n"
  " * order, the constant, linear, and quadratic terms based on the distance from\n"
  " * the point to the vertex.\n"
  " */";
#else
static const char *Dtool_Spotlight_get_attenuation_205_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Spotlight::set_attenuation(LVecBase3 const &attenuation)
 */
static PyObject *Dtool_Spotlight_set_attenuation_206(PyObject *self, PyObject *arg) {
  Spotlight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.set_attenuation")) {
    return NULL;
  }
  // 1-inline void Spotlight::set_attenuation(LVecBase3 const &attenuation)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Spotlight.set_attenuation", "LVecBase3f");
  }
  (*local_this).set_attenuation(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_attenuation(const Spotlight self, const LVecBase3f attenuation)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Spotlight_set_attenuation_206_comment =
  "C++ Interface:\n"
  "set_attenuation(const Spotlight self, const LVecBase3f attenuation)\n"
  "\n"
  "/**\n"
  " * Sets the terms of the attenuation equation for the light.  These are, in\n"
  " * order, the constant, linear, and quadratic terms based on the distance from\n"
  " * the point to the vertex.\n"
  " */";
#else
static const char *Dtool_Spotlight_set_attenuation_206_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Spotlight::get_max_distance(void) const
 */
static PyObject *Dtool_Spotlight_get_max_distance_208(PyObject *self, PyObject *) {
  Spotlight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Spotlight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat Spotlight::get_max_distance(void) const
  PN_stdfloat return_value = (*(const Spotlight*)local_this).get_max_distance();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Spotlight_get_max_distance_208_comment =
  "C++ Interface:\n"
  "get_max_distance(Spotlight self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum distance at which the light has any effect, as previously\n"
  " * specified by set_max_distance.\n"
  " */";
#else
static const char *Dtool_Spotlight_get_max_distance_208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Spotlight::set_max_distance(PN_stdfloat max_distance)
 */
static PyObject *Dtool_Spotlight_set_max_distance_209(PyObject *self, PyObject *arg) {
  Spotlight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.set_max_distance")) {
    return NULL;
  }
  // 1-inline void Spotlight::set_max_distance(PN_stdfloat max_distance)
  if (PyNumber_Check(arg)) {
    (*local_this).set_max_distance((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_distance(const Spotlight self, float max_distance)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Spotlight_set_max_distance_209_comment =
  "C++ Interface:\n"
  "set_max_distance(const Spotlight self, float max_distance)\n"
  "\n"
  "/**\n"
  " * Sets the radius of the light's sphere of influence.  Beyond this distance, the\n"
  " * light may be attenuated to zero, if this is supported by the shader.\n"
  " */";
#else
static const char *Dtool_Spotlight_set_max_distance_209_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< Texture > Spotlight::make_spot(int pixel_width, PN_stdfloat full_radius, LColor &fg, LColor &bg)
 */
static PyObject *Dtool_Spotlight_make_spot_211(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< Texture > Spotlight::make_spot(int pixel_width, PN_stdfloat full_radius, LColor &fg, LColor &bg)
  int param0;
  float param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"pixel_width", "full_radius", "fg", "bg", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ifOO:make_spot", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    LVecBase4f param2_local;
    LColor *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Spotlight.make_spot", "LVecBase4f");
    }
    LVecBase4f param3_local;
    LColor *param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "Spotlight.make_spot", "LVecBase4f");
    }
    PointerTo< Texture > return_value = Spotlight::make_spot((int)param0, (PN_stdfloat)param1, *param2_this, *param3_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    Texture *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Texture, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_spot(int pixel_width, float full_radius, LVecBase4f fg, LVecBase4f bg)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Spotlight_make_spot_211_comment =
  "C++ Interface:\n"
  "make_spot(int pixel_width, float full_radius, LVecBase4f fg, LVecBase4f bg)\n"
  "\n"
  "/**\n"
  " * Returns a newly-generated Texture that renders a circular spot image as\n"
  " * might be cast from the spotlight.  This may be projected onto target\n"
  " * geometry (for instance, via NodePath::project_texture()) instead of\n"
  " * actually enabling the light itself, as a cheesy way to make a high-\n"
  " * resolution spot appear on the geometry.\n"
  " *\n"
  " * pixel_width specifies the height and width of the new texture in pixels,\n"
  " * full_radius is a value in the range 0..1 that indicates the relative size\n"
  " * of the fully bright center spot, and fg and bg are the colors of the\n"
  " * interior and exterior of the spot, respectively.\n"
  " */";
#else
static const char *Dtool_Spotlight_make_spot_211_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Spotlight::get_class_type(void)
 */
static PyObject *Dtool_Spotlight_get_class_type_212(PyObject *, PyObject *) {
  // 1-static TypeHandle Spotlight::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(Spotlight::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Spotlight_get_class_type_212_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Spotlight_get_class_type_212_comment = NULL;
#endif

static PyObject *Dtool_Spotlight_exponent_Getter(PyObject *self, void *) {
  Spotlight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.exponent")) {
    return NULL;
  }

  // 1-inline PN_stdfloat Spotlight::get_exponent(void) final
  PN_stdfloat return_value = (*local_this).get_exponent();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Spotlight_exponent_Setter(PyObject *self, PyObject *arg, void *) {
  Spotlight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.exponent")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete exponent attribute");
    return -1;
  }
  // 1-inline void Spotlight::set_exponent(PN_stdfloat exponent)
  if (PyNumber_Check(arg)) {
    (*local_this).set_exponent((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_exponent(const Spotlight self, float exponent)\n");
  }
  return -1;
}

static PyObject *Dtool_Spotlight_specular_color_Getter(PyObject *self, void *) {
  Spotlight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.specular_color")) {
    return NULL;
  }

  // 1-inline LColor const &Spotlight::get_specular_color(void) final
  LColor const *return_value = &((*local_this).get_specular_color());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_Spotlight_specular_color_Setter(PyObject *self, PyObject *arg, void *) {
  Spotlight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.specular_color")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete specular_color attribute");
    return -1;
  }
  // 1-inline void Spotlight::set_specular_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Spotlight.set_specular_color", "LVecBase4f");
    return -1;
  }
  (*local_this).set_specular_color(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_specular_color(const Spotlight self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_Spotlight_attenuation_Getter(PyObject *self, void *) {
  Spotlight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.attenuation")) {
    return NULL;
  }

  // 1-inline LVecBase3 const &Spotlight::get_attenuation(void) final
  LVecBase3 const *return_value = &((*local_this).get_attenuation());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

static int Dtool_Spotlight_attenuation_Setter(PyObject *self, PyObject *arg, void *) {
  Spotlight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.attenuation")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete attenuation attribute");
    return -1;
  }
  // 1-inline void Spotlight::set_attenuation(LVecBase3 const &attenuation)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Spotlight.set_attenuation", "LVecBase3f");
    return -1;
  }
  (*local_this).set_attenuation(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_attenuation(const Spotlight self, const LVecBase3f attenuation)\n");
  }
  return -1;
}

static PyObject *Dtool_Spotlight_max_distance_Getter(PyObject *self, void *) {
  const Spotlight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Spotlight, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat Spotlight::get_max_distance(void) const
  PN_stdfloat return_value = (*(const Spotlight*)local_this).get_max_distance();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Spotlight_max_distance_Setter(PyObject *self, PyObject *arg, void *) {
  Spotlight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.max_distance")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete max_distance attribute");
    return -1;
  }
  // 1-inline void Spotlight::set_max_distance(PN_stdfloat max_distance)
  if (PyNumber_Check(arg)) {
    (*local_this).set_max_distance((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_distance(const Spotlight self, float max_distance)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * Spotlight::Spotlight(std::string const &name)
 */
static int Dtool_Init_Spotlight(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Spotlight() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-Spotlight::Spotlight(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    Spotlight *return_value = new Spotlight(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Spotlight, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Spotlight(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Spotlight(PyObject *args, CPT(Spotlight) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Spotlight, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Spotlight::Spotlight(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      Spotlight *return_value = new Spotlight(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_Spotlight(PyObject *args, PT(Spotlight) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Spotlight, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Spotlight::Spotlight(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      Spotlight *return_value = new Spotlight(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_Spotlight(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Spotlight) {
    printf("Spotlight ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Spotlight *local_this = (Spotlight *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Spotlight) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Camera) {
    return (Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_LensNode) {
    return (LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Light) {
    return (Light *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_LightLensNode) {
    return (LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Spotlight(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Spotlight) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Camera) {
    Camera* other_this = (Camera*)from_this;
    return (Spotlight*)other_this;
  }
  if (from_type == Dtool_Ptr_LensNode) {
    LensNode* other_this = (LensNode*)from_this;
    return (Spotlight*)other_this;
  }
  if (from_type == Dtool_Ptr_Light) {
    Light* other_this = (Light*)from_this;
    return (Spotlight*)other_this;
  }
  if (from_type == Dtool_Ptr_LightLensNode) {
    LightLensNode* other_this = (LightLensNode*)from_this;
    return (Spotlight*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (Spotlight*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (Spotlight*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Spotlight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Spotlight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (Spotlight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (Spotlight*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class SwitchNode
 */
/**
 * Python function wrapper for:
 * inline void SwitchNode::set_visible_child(int index)
 */
static PyObject *Dtool_SwitchNode_set_visible_child_216(PyObject *self, PyObject *arg) {
  SwitchNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SwitchNode, (void **)&local_this, "SwitchNode.set_visible_child")) {
    return NULL;
  }
  // 1-inline void SwitchNode::set_visible_child(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_visible_child((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_visible_child(const SwitchNode self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SwitchNode_set_visible_child_216_comment =
  "C++ Interface:\n"
  "set_visible_child(const SwitchNode self, int index)\n"
  "\n"
  "/**\n"
  " * Specifies the particular child of this node, by index, that will be\n"
  " * visible.\n"
  " */";
#else
static const char *Dtool_SwitchNode_set_visible_child_216_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual int SwitchNode::get_visible_child(void) const
 */
static PyObject *Dtool_SwitchNode_get_visible_child_217(PyObject *self, PyObject *) {
  SwitchNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SwitchNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual int SwitchNode::get_visible_child(void) const
  int return_value = (*(const SwitchNode*)local_this).get_visible_child();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SwitchNode_get_visible_child_217_comment =
  "C++ Interface:\n"
  "get_visible_child(SwitchNode self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the child that should be visible.\n"
  " */";
#else
static const char *Dtool_SwitchNode_get_visible_child_217_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle SwitchNode::get_class_type(void)
 */
static PyObject *Dtool_SwitchNode_get_class_type_219(PyObject *, PyObject *) {
  // 1-static TypeHandle SwitchNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(SwitchNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SwitchNode_get_class_type_219_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SwitchNode_get_class_type_219_comment = NULL;
#endif

static PyObject *Dtool_SwitchNode_visible_child_Getter(PyObject *self, void *) {
  const SwitchNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SwitchNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-virtual int SwitchNode::get_visible_child(void) const
  int return_value = (*(const SwitchNode*)local_this).get_visible_child();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_SwitchNode_visible_child_Setter(PyObject *self, PyObject *arg, void *) {
  SwitchNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SwitchNode, (void **)&local_this, "SwitchNode.visible_child")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete visible_child attribute");
    return -1;
  }
  // 1-inline void SwitchNode::set_visible_child(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_visible_child((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_visible_child(const SwitchNode self, int index)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline SwitchNode::SwitchNode(std::string const &name)
 */
static int Dtool_Init_SwitchNode(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "SwitchNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-inline SwitchNode::SwitchNode(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    SwitchNode *return_value = new SwitchNode(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SwitchNode, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SwitchNode(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_SwitchNode(PyObject *args, CPT(SwitchNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SwitchNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline SwitchNode::SwitchNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      SwitchNode *return_value = new SwitchNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_SwitchNode(PyObject *args, PT(SwitchNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SwitchNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline SwitchNode::SwitchNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      SwitchNode *return_value = new SwitchNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_SwitchNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SwitchNode) {
    printf("SwitchNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SwitchNode *local_this = (SwitchNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SwitchNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_SelectiveChildNode) {
    return (SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SwitchNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SwitchNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (SwitchNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (SwitchNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SwitchNode*)other_this;
  }
  if (from_type == Dtool_Ptr_SelectiveChildNode) {
    SelectiveChildNode* other_this = (SelectiveChildNode*)from_this;
    return (SwitchNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (SwitchNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (SwitchNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (SwitchNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class UvScrollNode
 */
/**
 * Python function wrapper for:
 * inline void UvScrollNode::set_u_speed(PN_stdfloat u_speed)
 */
static PyObject *Dtool_UvScrollNode_set_u_speed_223(PyObject *self, PyObject *arg) {
  UvScrollNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UvScrollNode, (void **)&local_this, "UvScrollNode.set_u_speed")) {
    return NULL;
  }
  // 1-inline void UvScrollNode::set_u_speed(PN_stdfloat u_speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_u_speed((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_u_speed(const UvScrollNode self, float u_speed)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UvScrollNode_set_u_speed_223_comment =
  "C++ Interface:\n"
  "set_u_speed(const UvScrollNode self, float u_speed)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UvScrollNode_set_u_speed_223_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void UvScrollNode::set_v_speed(PN_stdfloat v_speed)
 */
static PyObject *Dtool_UvScrollNode_set_v_speed_224(PyObject *self, PyObject *arg) {
  UvScrollNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UvScrollNode, (void **)&local_this, "UvScrollNode.set_v_speed")) {
    return NULL;
  }
  // 1-inline void UvScrollNode::set_v_speed(PN_stdfloat v_speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_v_speed((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_v_speed(const UvScrollNode self, float v_speed)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UvScrollNode_set_v_speed_224_comment =
  "C++ Interface:\n"
  "set_v_speed(const UvScrollNode self, float v_speed)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UvScrollNode_set_v_speed_224_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void UvScrollNode::set_w_speed(PN_stdfloat w_speed)
 */
static PyObject *Dtool_UvScrollNode_set_w_speed_225(PyObject *self, PyObject *arg) {
  UvScrollNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UvScrollNode, (void **)&local_this, "UvScrollNode.set_w_speed")) {
    return NULL;
  }
  // 1-inline void UvScrollNode::set_w_speed(PN_stdfloat w_speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_w_speed((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_w_speed(const UvScrollNode self, float w_speed)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UvScrollNode_set_w_speed_225_comment =
  "C++ Interface:\n"
  "set_w_speed(const UvScrollNode self, float w_speed)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UvScrollNode_set_w_speed_225_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void UvScrollNode::set_r_speed(PN_stdfloat r_speed)
 */
static PyObject *Dtool_UvScrollNode_set_r_speed_226(PyObject *self, PyObject *arg) {
  UvScrollNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UvScrollNode, (void **)&local_this, "UvScrollNode.set_r_speed")) {
    return NULL;
  }
  // 1-inline void UvScrollNode::set_r_speed(PN_stdfloat r_speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_r_speed((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_r_speed(const UvScrollNode self, float r_speed)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UvScrollNode_set_r_speed_226_comment =
  "C++ Interface:\n"
  "set_r_speed(const UvScrollNode self, float r_speed)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UvScrollNode_set_r_speed_226_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat UvScrollNode::get_u_speed(void) const
 */
static PyObject *Dtool_UvScrollNode_get_u_speed_227(PyObject *self, PyObject *) {
  UvScrollNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UvScrollNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat UvScrollNode::get_u_speed(void) const
  PN_stdfloat return_value = (*(const UvScrollNode*)local_this).get_u_speed();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UvScrollNode_get_u_speed_227_comment =
  "C++ Interface:\n"
  "get_u_speed(UvScrollNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UvScrollNode_get_u_speed_227_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat UvScrollNode::get_v_speed(void) const
 */
static PyObject *Dtool_UvScrollNode_get_v_speed_228(PyObject *self, PyObject *) {
  UvScrollNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UvScrollNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat UvScrollNode::get_v_speed(void) const
  PN_stdfloat return_value = (*(const UvScrollNode*)local_this).get_v_speed();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UvScrollNode_get_v_speed_228_comment =
  "C++ Interface:\n"
  "get_v_speed(UvScrollNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UvScrollNode_get_v_speed_228_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat UvScrollNode::get_w_speed(void) const
 */
static PyObject *Dtool_UvScrollNode_get_w_speed_229(PyObject *self, PyObject *) {
  UvScrollNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UvScrollNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat UvScrollNode::get_w_speed(void) const
  PN_stdfloat return_value = (*(const UvScrollNode*)local_this).get_w_speed();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UvScrollNode_get_w_speed_229_comment =
  "C++ Interface:\n"
  "get_w_speed(UvScrollNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UvScrollNode_get_w_speed_229_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat UvScrollNode::get_r_speed(void) const
 */
static PyObject *Dtool_UvScrollNode_get_r_speed_230(PyObject *self, PyObject *) {
  UvScrollNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UvScrollNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat UvScrollNode::get_r_speed(void) const
  PN_stdfloat return_value = (*(const UvScrollNode*)local_this).get_r_speed();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UvScrollNode_get_r_speed_230_comment =
  "C++ Interface:\n"
  "get_r_speed(UvScrollNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UvScrollNode_get_r_speed_230_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle UvScrollNode::get_class_type(void)
 */
static PyObject *Dtool_UvScrollNode_get_class_type_235(PyObject *, PyObject *) {
  // 1-static TypeHandle UvScrollNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(UvScrollNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UvScrollNode_get_class_type_235_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_UvScrollNode_get_class_type_235_comment = NULL;
#endif

static PyObject *Dtool_UvScrollNode_u_speed_Getter(PyObject *self, void *) {
  const UvScrollNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UvScrollNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat UvScrollNode::get_u_speed(void) const
  PN_stdfloat return_value = (*(const UvScrollNode*)local_this).get_u_speed();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_UvScrollNode_u_speed_Setter(PyObject *self, PyObject *arg, void *) {
  UvScrollNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UvScrollNode, (void **)&local_this, "UvScrollNode.u_speed")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete u_speed attribute");
    return -1;
  }
  // 1-inline void UvScrollNode::set_u_speed(PN_stdfloat u_speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_u_speed((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_u_speed(const UvScrollNode self, float u_speed)\n");
  }
  return -1;
}

static PyObject *Dtool_UvScrollNode_v_speed_Getter(PyObject *self, void *) {
  const UvScrollNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UvScrollNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat UvScrollNode::get_v_speed(void) const
  PN_stdfloat return_value = (*(const UvScrollNode*)local_this).get_v_speed();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_UvScrollNode_v_speed_Setter(PyObject *self, PyObject *arg, void *) {
  UvScrollNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UvScrollNode, (void **)&local_this, "UvScrollNode.v_speed")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete v_speed attribute");
    return -1;
  }
  // 1-inline void UvScrollNode::set_v_speed(PN_stdfloat v_speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_v_speed((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_v_speed(const UvScrollNode self, float v_speed)\n");
  }
  return -1;
}

static PyObject *Dtool_UvScrollNode_w_speed_Getter(PyObject *self, void *) {
  const UvScrollNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UvScrollNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat UvScrollNode::get_w_speed(void) const
  PN_stdfloat return_value = (*(const UvScrollNode*)local_this).get_w_speed();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_UvScrollNode_w_speed_Setter(PyObject *self, PyObject *arg, void *) {
  UvScrollNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UvScrollNode, (void **)&local_this, "UvScrollNode.w_speed")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete w_speed attribute");
    return -1;
  }
  // 1-inline void UvScrollNode::set_w_speed(PN_stdfloat w_speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_w_speed((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_w_speed(const UvScrollNode self, float w_speed)\n");
  }
  return -1;
}

static PyObject *Dtool_UvScrollNode_r_speed_Getter(PyObject *self, void *) {
  const UvScrollNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UvScrollNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat UvScrollNode::get_r_speed(void) const
  PN_stdfloat return_value = (*(const UvScrollNode*)local_this).get_r_speed();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_UvScrollNode_r_speed_Setter(PyObject *self, PyObject *arg, void *) {
  UvScrollNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UvScrollNode, (void **)&local_this, "UvScrollNode.r_speed")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete r_speed attribute");
    return -1;
  }
  // 1-inline void UvScrollNode::set_r_speed(PN_stdfloat r_speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_r_speed((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_r_speed(const UvScrollNode self, float r_speed)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline UvScrollNode::UvScrollNode(std::string const &name)
 * inline UvScrollNode::UvScrollNode(std::string const &name, PN_stdfloat u_speed, PN_stdfloat v_speed, PN_stdfloat w_speed, PN_stdfloat r_speed)
 */
static int Dtool_Init_UvScrollNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "name");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
        return -1;
      }
      // 1-inline UvScrollNode::UvScrollNode(std::string const &name)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        UvScrollNode *return_value = new UvScrollNode(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UvScrollNode, true, false);
      }
    }
    break;
  case 5:
    {
      // 1-inline UvScrollNode::UvScrollNode(std::string const &name, PN_stdfloat u_speed, PN_stdfloat v_speed, PN_stdfloat w_speed, PN_stdfloat r_speed)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"name", "u_speed", "v_speed", "w_speed", "r_speed", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#ffff:UvScrollNode", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
        UvScrollNode *return_value = new UvScrollNode(std::string(param0_str, param0_len), (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UvScrollNode, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "UvScrollNode() takes 1 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UvScrollNode(str name)\n"
      "UvScrollNode(str name, float u_speed, float v_speed, float w_speed, float r_speed)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_UvScrollNode(PyObject *args, CPT(UvScrollNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_UvScrollNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline UvScrollNode::UvScrollNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      UvScrollNode *return_value = new UvScrollNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 5) {
      // 1-inline UvScrollNode::UvScrollNode(std::string const &name, PN_stdfloat u_speed, PN_stdfloat v_speed, PN_stdfloat w_speed, PN_stdfloat r_speed)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      float param1;
      float param2;
      float param3;
      float param4;
      if (PyArg_ParseTuple(args, "s#ffff:UvScrollNode", &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
        UvScrollNode *return_value = new UvScrollNode(std::string(param0_str, param0_len), (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_UvScrollNode(PyObject *args, PT(UvScrollNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_UvScrollNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline UvScrollNode::UvScrollNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      UvScrollNode *return_value = new UvScrollNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 5) {
      // 1-inline UvScrollNode::UvScrollNode(std::string const &name, PN_stdfloat u_speed, PN_stdfloat v_speed, PN_stdfloat w_speed, PN_stdfloat r_speed)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      float param1;
      float param2;
      float param3;
      float param4;
      if (PyArg_ParseTuple(args, "s#ffff:UvScrollNode", &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
        UvScrollNode *return_value = new UvScrollNode(std::string(param0_str, param0_len), (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_UvScrollNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_UvScrollNode) {
    printf("UvScrollNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  UvScrollNode *local_this = (UvScrollNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_UvScrollNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_UvScrollNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_UvScrollNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (UvScrollNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (UvScrollNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (UvScrollNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (UvScrollNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (UvScrollNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (UvScrollNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class SceneGraphAnalyzer
 */
/**
 * Python function wrapper for:
 * inline void SceneGraphAnalyzer::set_lod_mode(SceneGraphAnalyzer::LodMode lod_mode)
 */
static PyObject *Dtool_SceneGraphAnalyzer_set_lod_mode_241(PyObject *self, PyObject *arg) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphAnalyzer, (void **)&local_this, "SceneGraphAnalyzer.set_lod_mode")) {
    return NULL;
  }
  // 1-inline void SceneGraphAnalyzer::set_lod_mode(SceneGraphAnalyzer::LodMode lod_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_lod_mode((SceneGraphAnalyzer::LodMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lod_mode(const SceneGraphAnalyzer self, int lod_mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_set_lod_mode_241_comment =
  "C++ Interface:\n"
  "set_lod_mode(const SceneGraphAnalyzer self, int lod_mode)\n"
  "\n"
  "/**\n"
  " * Specifies the mode in which LODNodes are analyzed.\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_set_lod_mode_241_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline SceneGraphAnalyzer::LodMode SceneGraphAnalyzer::get_lod_mode(SceneGraphAnalyzer::LodMode lod_mode) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_lod_mode_242(PyObject *self, PyObject *arg) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline SceneGraphAnalyzer::LodMode SceneGraphAnalyzer::get_lod_mode(SceneGraphAnalyzer::LodMode lod_mode) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    SceneGraphAnalyzer::LodMode return_value = (*(const SceneGraphAnalyzer*)local_this).get_lod_mode((SceneGraphAnalyzer::LodMode)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_lod_mode(SceneGraphAnalyzer self, int lod_mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_lod_mode_242_comment =
  "C++ Interface:\n"
  "get_lod_mode(SceneGraphAnalyzer self, int lod_mode)\n"
  "\n"
  "/**\n"
  " * Returns the mode in which LODNodes are analyzed.\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_lod_mode_242_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void SceneGraphAnalyzer::clear(void)
 */
static PyObject *Dtool_SceneGraphAnalyzer_clear_243(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphAnalyzer, (void **)&local_this, "SceneGraphAnalyzer.clear")) {
    return NULL;
  }
  // 1-void SceneGraphAnalyzer::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_clear_243_comment =
  "C++ Interface:\n"
  "clear(const SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " * Resets all of the data in the analyzer in preparation for a new run.\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_clear_243_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void SceneGraphAnalyzer::add_node(PandaNode *node)
 */
static PyObject *Dtool_SceneGraphAnalyzer_add_node_244(PyObject *self, PyObject *arg) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphAnalyzer, (void **)&local_this, "SceneGraphAnalyzer.add_node")) {
    return NULL;
  }
  // 1-void SceneGraphAnalyzer::add_node(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "SceneGraphAnalyzer.add_node", false, true);
  if (arg_this != NULL) {
    (*local_this).add_node(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_node(const SceneGraphAnalyzer self, PandaNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_add_node_244_comment =
  "C++ Interface:\n"
  "add_node(const SceneGraphAnalyzer self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Adds a new node to the set of data for analysis.  Normally, this would only\n"
  " * be called once, and passed the top of the scene graph, but it's possible to\n"
  " * repeatedly pass in subgraphs to get an analysis of all the graphs together.\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_add_node_244_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void SceneGraphAnalyzer::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_write_245(PyObject *self, PyObject *args, PyObject *kwds) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-void SceneGraphAnalyzer::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "SceneGraphAnalyzer.write", false, true);
    if (param1_this != NULL) {
      (*(const SceneGraphAnalyzer*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(SceneGraphAnalyzer self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_write_245_comment =
  "C++ Interface:\n"
  "write(SceneGraphAnalyzer self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Describes all the data collected.\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_write_245_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_nodes(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_nodes_246(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_nodes(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_nodes();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_nodes_246_comment =
  "C++ Interface:\n"
  "get_num_nodes(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_nodes_246_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_instances(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_instances_247(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_instances(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_instances();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_instances_247_comment =
  "C++ Interface:\n"
  "get_num_instances(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_instances_247_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_transforms(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_transforms_248(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_transforms(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_transforms();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_transforms_248_comment =
  "C++ Interface:\n"
  "get_num_transforms(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_transforms_248_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_nodes_with_attribs(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_nodes_with_attribs_249(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_nodes_with_attribs(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_nodes_with_attribs();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_nodes_with_attribs_249_comment =
  "C++ Interface:\n"
  "get_num_nodes_with_attribs(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_nodes_with_attribs_249_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_lod_nodes(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_lod_nodes_250(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_lod_nodes(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_lod_nodes();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_lod_nodes_250_comment =
  "C++ Interface:\n"
  "get_num_lod_nodes(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_lod_nodes_250_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_geom_nodes(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_geom_nodes_251(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_geom_nodes(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_geom_nodes();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_geom_nodes_251_comment =
  "C++ Interface:\n"
  "get_num_geom_nodes(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_geom_nodes_251_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_geoms(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_geoms_252(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_geoms(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_geoms();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_geoms_252_comment =
  "C++ Interface:\n"
  "get_num_geoms(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_geoms_252_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_geom_vertex_datas(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_geom_vertex_datas_253(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_geom_vertex_datas(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_geom_vertex_datas();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_geom_vertex_datas_253_comment =
  "C++ Interface:\n"
  "get_num_geom_vertex_datas(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_geom_vertex_datas_253_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_geom_vertex_formats(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_geom_vertex_formats_254(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_geom_vertex_formats(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_geom_vertex_formats();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_geom_vertex_formats_254_comment =
  "C++ Interface:\n"
  "get_num_geom_vertex_formats(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_geom_vertex_formats_254_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t SceneGraphAnalyzer::get_vertex_data_size(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_vertex_data_size_255(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t SceneGraphAnalyzer::get_vertex_data_size(void) const
  std::size_t return_value = (*(const SceneGraphAnalyzer*)local_this).get_vertex_data_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_vertex_data_size_255_comment =
  "C++ Interface:\n"
  "get_vertex_data_size(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_vertex_data_size_255_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_vertices(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_vertices_256(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_vertices(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_vertices();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_vertices_256_comment =
  "C++ Interface:\n"
  "get_num_vertices(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_vertices_256_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_normals(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_normals_257(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_normals(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_normals();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_normals_257_comment =
  "C++ Interface:\n"
  "get_num_normals(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_normals_257_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_colors(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_colors_258(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_colors(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_colors();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_colors_258_comment =
  "C++ Interface:\n"
  "get_num_colors(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_colors_258_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_texcoords(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_texcoords_259(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_texcoords(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_texcoords();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_texcoords_259_comment =
  "C++ Interface:\n"
  "get_num_texcoords(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_texcoords_259_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_tris(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_tris_260(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_tris(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_tris();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_tris_260_comment =
  "C++ Interface:\n"
  "get_num_tris(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_tris_260_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_lines(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_lines_261(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_lines(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_lines();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_lines_261_comment =
  "C++ Interface:\n"
  "get_num_lines(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_lines_261_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_points(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_points_262(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_points(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_points();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_points_262_comment =
  "C++ Interface:\n"
  "get_num_points(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_points_262_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_patches(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_patches_263(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_patches(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_patches();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_patches_263_comment =
  "C++ Interface:\n"
  "get_num_patches(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_patches_263_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_individual_tris(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_individual_tris_264(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_individual_tris(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_individual_tris();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_individual_tris_264_comment =
  "C++ Interface:\n"
  "get_num_individual_tris(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_individual_tris_264_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_tristrips(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_tristrips_265(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_tristrips(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_tristrips();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_tristrips_265_comment =
  "C++ Interface:\n"
  "get_num_tristrips(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_tristrips_265_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_triangles_in_strips(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_triangles_in_strips_266(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_triangles_in_strips(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_triangles_in_strips();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_triangles_in_strips_266_comment =
  "C++ Interface:\n"
  "get_num_triangles_in_strips(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_triangles_in_strips_266_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_trifans(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_trifans_267(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_trifans(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_trifans();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_trifans_267_comment =
  "C++ Interface:\n"
  "get_num_trifans(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_trifans_267_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_triangles_in_fans(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_triangles_in_fans_268(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_triangles_in_fans(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_triangles_in_fans();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_triangles_in_fans_268_comment =
  "C++ Interface:\n"
  "get_num_triangles_in_fans(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_triangles_in_fans_268_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_vertices_in_patches(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_vertices_in_patches_269(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_vertices_in_patches(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_vertices_in_patches();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_vertices_in_patches_269_comment =
  "C++ Interface:\n"
  "get_num_vertices_in_patches(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_vertices_in_patches_269_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_texture_bytes(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_texture_bytes_270(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_texture_bytes(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_texture_bytes();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_texture_bytes_270_comment =
  "C++ Interface:\n"
  "get_texture_bytes(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_texture_bytes_270_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_long_normals(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_long_normals_271(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_long_normals(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_long_normals();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_long_normals_271_comment =
  "C++ Interface:\n"
  "get_num_long_normals(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_long_normals_271_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_short_normals(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_short_normals_272(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_short_normals(void) const
  int return_value = (*(const SceneGraphAnalyzer*)local_this).get_num_short_normals();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_short_normals_272_comment =
  "C++ Interface:\n"
  "get_num_short_normals(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_short_normals_272_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SceneGraphAnalyzer::get_total_normal_length(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_total_normal_length_273(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat SceneGraphAnalyzer::get_total_normal_length(void) const
  PN_stdfloat return_value = (*(const SceneGraphAnalyzer*)local_this).get_total_normal_length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_total_normal_length_273_comment =
  "C++ Interface:\n"
  "get_total_normal_length(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_total_normal_length_273_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * SceneGraphAnalyzer::SceneGraphAnalyzer(void)
 * inline SceneGraphAnalyzer::SceneGraphAnalyzer(SceneGraphAnalyzer const &) = default
 */
static int Dtool_Init_SceneGraphAnalyzer(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-SceneGraphAnalyzer::SceneGraphAnalyzer(void)
      SceneGraphAnalyzer *return_value = new SceneGraphAnalyzer();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SceneGraphAnalyzer, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline SceneGraphAnalyzer::SceneGraphAnalyzer(SceneGraphAnalyzer const &) = default
      SceneGraphAnalyzer const *arg_this = (SceneGraphAnalyzer *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SceneGraphAnalyzer, 0, "SceneGraphAnalyzer.SceneGraphAnalyzer", true, true);
      if (arg_this != NULL) {
        SceneGraphAnalyzer *return_value = new SceneGraphAnalyzer(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SceneGraphAnalyzer, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SceneGraphAnalyzer() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SceneGraphAnalyzer()\n"
      "SceneGraphAnalyzer(const SceneGraphAnalyzer param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SceneGraphAnalyzer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SceneGraphAnalyzer) {
    printf("SceneGraphAnalyzer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SceneGraphAnalyzer *local_this = (SceneGraphAnalyzer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SceneGraphAnalyzer) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SceneGraphAnalyzer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SceneGraphAnalyzer) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for LightNode (LightNode)
 */
static PyMethodDef Dtool_Methods_LightNode[] = {
  {"output", &Dtool_LightNode_output_8, METH_O, (const char *)Dtool_LightNode_output_8_comment},
  {"write", (PyCFunction) &Dtool_LightNode_write_9, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LightNode_write_9_comment},
  {"get_class_type", &Dtool_LightNode_get_class_type_10, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightNode_get_class_type_10_comment},
  {"getClassType", &Dtool_LightNode_get_class_type_10, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightNode_get_class_type_10_comment},
  {"upcast_to_Light", &Dtool_LightNode_upcast_to_Light_3, METH_NOARGS, (const char *)Dtool_LightNode_upcast_to_Light_3_comment},
  {"upcastToLight", &Dtool_LightNode_upcast_to_Light_3, METH_NOARGS, (const char *)Dtool_LightNode_upcast_to_Light_3_comment},
  {"upcast_to_PandaNode", &Dtool_LightNode_upcast_to_PandaNode_6, METH_NOARGS, (const char *)Dtool_LightNode_upcast_to_PandaNode_6_comment},
  {"upcastToPandaNode", &Dtool_LightNode_upcast_to_PandaNode_6, METH_NOARGS, (const char *)Dtool_LightNode_upcast_to_PandaNode_6_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     LightNode
//////////////////
static PyObject *Dtool_Repr_LightNode(PyObject *self) {
  LightNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightNode, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     LightNode
//////////////////
static PyObject *Dtool_Str_LightNode(PyObject *self) {
  LightNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightNode, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_LightNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LightNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LightNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LightNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LightNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LightNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LightNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_LightNode,
    &Dtool_NumberMethods_LightNode,
    &Dtool_SequenceMethods_LightNode,
    &Dtool_MappingMethods_LightNode,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_LightNode,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LightNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A derivative of Light and of PandaNode.  All kinds of Light except\n"
    " * Spotlight (which must inherit from LensNode instead) inherit from this\n"
    " * class.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LightNode,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LightNode,
    PyType_GenericAlloc,
    Dtool_new_LightNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LightNode,
  Dtool_UpcastInterface_LightNode,
  Dtool_DowncastInterface_LightNode,
  (CoerceFunction)Dtool_ConstCoerce_LightNode,
  (CoerceFunction)Dtool_Coerce_LightNode,
};

static void Dtool_PyModuleClassInit_LightNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Light != NULL);
    assert(Dtool_Ptr_Light->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Light->_Dtool_ModuleClassInit(NULL);
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_LightNode._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_Light, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_LightNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LightNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LightNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LightNode);
  }
}

/**
 * Python method tables for AmbientLight (AmbientLight)
 */
static PyMethodDef Dtool_Methods_AmbientLight[] = {
  {"get_class_type", &Dtool_AmbientLight_get_class_type_14, METH_NOARGS | METH_STATIC, (const char *)Dtool_AmbientLight_get_class_type_14_comment},
  {"getClassType", &Dtool_AmbientLight_get_class_type_14, METH_NOARGS | METH_STATIC, (const char *)Dtool_AmbientLight_get_class_type_14_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AmbientLight = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AmbientLight = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AmbientLight = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AmbientLight = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AmbientLight = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AmbientLight",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AmbientLight,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AmbientLight,
    &Dtool_SequenceMethods_AmbientLight,
    &Dtool_MappingMethods_AmbientLight,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AmbientLight,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A light source that seems to illuminate all points in space at once.  This\n"
    " * kind of light need not actually be part of the scene graph, since it has no\n"
    " * meaningful position.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AmbientLight,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AmbientLight,
    PyType_GenericAlloc,
    Dtool_new_AmbientLight,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AmbientLight,
  Dtool_UpcastInterface_AmbientLight,
  Dtool_DowncastInterface_AmbientLight,
  (CoerceFunction)Dtool_ConstCoerce_AmbientLight,
  (CoerceFunction)Dtool_Coerce_AmbientLight,
};

static void Dtool_PyModuleClassInit_AmbientLight(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LightNode(NULL);
    Dtool_AmbientLight._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LightNode);
    PyObject *dict = PyDict_New();
    Dtool_AmbientLight._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AmbientLight) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AmbientLight)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AmbientLight);
  }
}

/**
 * Python method tables for CallbackNode (CallbackNode)
 */
static PyMethodDef Dtool_Methods_CallbackNode[] = {
  {"set_cull_callback", &Dtool_CallbackNode_set_cull_callback_18, METH_O, (const char *)Dtool_CallbackNode_set_cull_callback_18_comment},
  {"setCullCallback", &Dtool_CallbackNode_set_cull_callback_18, METH_O, (const char *)Dtool_CallbackNode_set_cull_callback_18_comment},
  {"clear_cull_callback", &Dtool_CallbackNode_clear_cull_callback_19, METH_NOARGS, (const char *)Dtool_CallbackNode_clear_cull_callback_19_comment},
  {"clearCullCallback", &Dtool_CallbackNode_clear_cull_callback_19, METH_NOARGS, (const char *)Dtool_CallbackNode_clear_cull_callback_19_comment},
  {"get_cull_callback", &Dtool_CallbackNode_get_cull_callback_20, METH_NOARGS, (const char *)Dtool_CallbackNode_get_cull_callback_20_comment},
  {"getCullCallback", &Dtool_CallbackNode_get_cull_callback_20, METH_NOARGS, (const char *)Dtool_CallbackNode_get_cull_callback_20_comment},
  {"set_draw_callback", &Dtool_CallbackNode_set_draw_callback_24, METH_O, (const char *)Dtool_CallbackNode_set_draw_callback_24_comment},
  {"setDrawCallback", &Dtool_CallbackNode_set_draw_callback_24, METH_O, (const char *)Dtool_CallbackNode_set_draw_callback_24_comment},
  {"clear_draw_callback", &Dtool_CallbackNode_clear_draw_callback_25, METH_NOARGS, (const char *)Dtool_CallbackNode_clear_draw_callback_25_comment},
  {"clearDrawCallback", &Dtool_CallbackNode_clear_draw_callback_25, METH_NOARGS, (const char *)Dtool_CallbackNode_clear_draw_callback_25_comment},
  {"get_draw_callback", &Dtool_CallbackNode_get_draw_callback_26, METH_NOARGS, (const char *)Dtool_CallbackNode_get_draw_callback_26_comment},
  {"getDrawCallback", &Dtool_CallbackNode_get_draw_callback_26, METH_NOARGS, (const char *)Dtool_CallbackNode_get_draw_callback_26_comment},
  {"get_class_type", &Dtool_CallbackNode_get_class_type_28, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackNode_get_class_type_28_comment},
  {"getClassType", &Dtool_CallbackNode_get_class_type_28, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackNode_get_class_type_28_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_CallbackNode[] = {
  {(char *)"cull_callback", &Dtool_CallbackNode_cull_callback_Getter, &Dtool_CallbackNode_cull_callback_Setter, NULL, NULL},
  {(char *)"draw_callback", &Dtool_CallbackNode_draw_callback_Getter, &Dtool_CallbackNode_draw_callback_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CallbackNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CallbackNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CallbackNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CallbackNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CallbackNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CallbackNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CallbackNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CallbackNode,
    &Dtool_SequenceMethods_CallbackNode,
    &Dtool_MappingMethods_CallbackNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CallbackNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A special node that can issue arbitrary callbacks to user code, either\n"
    " * during the cull or draw traversals.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CallbackNode,
    0, // tp_members
    Dtool_Properties_CallbackNode,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CallbackNode,
    PyType_GenericAlloc,
    Dtool_new_CallbackNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CallbackNode,
  Dtool_UpcastInterface_CallbackNode,
  Dtool_DowncastInterface_CallbackNode,
  (CoerceFunction)Dtool_ConstCoerce_CallbackNode,
  (CoerceFunction)Dtool_Coerce_CallbackNode,
};

static void Dtool_PyModuleClassInit_CallbackNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_CallbackNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_CallbackNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CallbackNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CallbackNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CallbackNode);
  }
}

/**
 * Python method tables for ComputeNode (ComputeNode)
 */
static PyMethodDef Dtool_Methods_ComputeNode[] = {
  {"add_dispatch", (PyCFunction) &Dtool_ComputeNode_add_dispatch_32, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ComputeNode_add_dispatch_32_comment},
  {"addDispatch", (PyCFunction) &Dtool_ComputeNode_add_dispatch_32, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ComputeNode_add_dispatch_32_comment},
  {"get_num_dispatches", &Dtool_ComputeNode_get_num_dispatches_33, METH_NOARGS, (const char *)Dtool_ComputeNode_get_num_dispatches_33_comment},
  {"getNumDispatches", &Dtool_ComputeNode_get_num_dispatches_33, METH_NOARGS, (const char *)Dtool_ComputeNode_get_num_dispatches_33_comment},
  {"get_dispatch", &Dtool_ComputeNode_get_dispatch_34, METH_O, (const char *)Dtool_ComputeNode_get_dispatch_34_comment},
  {"getDispatch", &Dtool_ComputeNode_get_dispatch_34, METH_O, (const char *)Dtool_ComputeNode_get_dispatch_34_comment},
  {"set_dispatch", (PyCFunction) &Dtool_ComputeNode_set_dispatch_35, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ComputeNode_set_dispatch_35_comment},
  {"setDispatch", (PyCFunction) &Dtool_ComputeNode_set_dispatch_35, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ComputeNode_set_dispatch_35_comment},
  {"remove_dispatch", &Dtool_ComputeNode_remove_dispatch_36, METH_O, (const char *)Dtool_ComputeNode_remove_dispatch_36_comment},
  {"removeDispatch", &Dtool_ComputeNode_remove_dispatch_36, METH_O, (const char *)Dtool_ComputeNode_remove_dispatch_36_comment},
  {"clear_dispatches", &Dtool_ComputeNode_clear_dispatches_37, METH_NOARGS, (const char *)Dtool_ComputeNode_clear_dispatches_37_comment},
  {"clearDispatches", &Dtool_ComputeNode_clear_dispatches_37, METH_NOARGS, (const char *)Dtool_ComputeNode_clear_dispatches_37_comment},
  {"get_class_type", &Dtool_ComputeNode_get_class_type_42, METH_NOARGS | METH_STATIC, (const char *)Dtool_ComputeNode_get_class_type_42_comment},
  {"getClassType", &Dtool_ComputeNode_get_class_type_42, METH_NOARGS | METH_STATIC, (const char *)Dtool_ComputeNode_get_class_type_42_comment},
  {"get_dispatches", (PyCFunction) &MakeSeq_ComputeNode_get_dispatches, METH_NOARGS, NULL},
  { "getDispatches", (PyCFunction) &MakeSeq_ComputeNode_get_dispatches, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ComputeNode[] = {
  {(char *)"dispatches", &Dtool_ComputeNode_dispatches_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ComputeNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ComputeNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ComputeNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ComputeNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ComputeNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ComputeNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ComputeNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ComputeNode,
    &Dtool_SequenceMethods_ComputeNode,
    &Dtool_MappingMethods_ComputeNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ComputeNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A special node, the sole purpose of which is to invoke a dispatch operation\n"
    " * on the assigned compute shader.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ComputeNode,
    0, // tp_members
    Dtool_Properties_ComputeNode,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ComputeNode,
    PyType_GenericAlloc,
    Dtool_new_ComputeNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ComputeNode,
  Dtool_UpcastInterface_ComputeNode,
  Dtool_DowncastInterface_ComputeNode,
  (CoerceFunction)Dtool_ConstCoerce_ComputeNode,
  (CoerceFunction)Dtool_Coerce_ComputeNode,
};

static void Dtool_PyModuleClassInit_ComputeNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_ComputeNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_ComputeNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ComputeNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ComputeNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ComputeNode);
  }
}

/**
 * Python method tables for LightLensNode (LightLensNode)
 */
static PyMethodDef Dtool_Methods_LightLensNode[] = {
  {"is_shadow_caster", &Dtool_LightLensNode_is_shadow_caster_52, METH_NOARGS, (const char *)Dtool_LightLensNode_is_shadow_caster_52_comment},
  {"isShadowCaster", &Dtool_LightLensNode_is_shadow_caster_52, METH_NOARGS, (const char *)Dtool_LightLensNode_is_shadow_caster_52_comment},
  {"set_shadow_caster", (PyCFunction) &Dtool_LightLensNode_set_shadow_caster_53, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LightLensNode_set_shadow_caster_53_comment},
  {"setShadowCaster", (PyCFunction) &Dtool_LightLensNode_set_shadow_caster_53, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LightLensNode_set_shadow_caster_53_comment},
  {"get_shadow_buffer_size", &Dtool_LightLensNode_get_shadow_buffer_size_54, METH_NOARGS, (const char *)Dtool_LightLensNode_get_shadow_buffer_size_54_comment},
  {"getShadowBufferSize", &Dtool_LightLensNode_get_shadow_buffer_size_54, METH_NOARGS, (const char *)Dtool_LightLensNode_get_shadow_buffer_size_54_comment},
  {"set_shadow_buffer_size", &Dtool_LightLensNode_set_shadow_buffer_size_55, METH_O, (const char *)Dtool_LightLensNode_set_shadow_buffer_size_55_comment},
  {"setShadowBufferSize", &Dtool_LightLensNode_set_shadow_buffer_size_55, METH_O, (const char *)Dtool_LightLensNode_set_shadow_buffer_size_55_comment},
  {"get_shadow_buffer", &Dtool_LightLensNode_get_shadow_buffer_56, METH_O, (const char *)Dtool_LightLensNode_get_shadow_buffer_56_comment},
  {"getShadowBuffer", &Dtool_LightLensNode_get_shadow_buffer_56, METH_O, (const char *)Dtool_LightLensNode_get_shadow_buffer_56_comment},
  {"output", &Dtool_LightLensNode_output_61, METH_O, (const char *)Dtool_LightLensNode_output_61_comment},
  {"write", (PyCFunction) &Dtool_LightLensNode_write_62, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LightLensNode_write_62_comment},
  {"get_class_type", &Dtool_LightLensNode_get_class_type_63, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightLensNode_get_class_type_63_comment},
  {"getClassType", &Dtool_LightLensNode_get_class_type_63, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightLensNode_get_class_type_63_comment},
  {"upcast_to_Light", &Dtool_LightLensNode_upcast_to_Light_46, METH_NOARGS, (const char *)Dtool_LightLensNode_upcast_to_Light_46_comment},
  {"upcastToLight", &Dtool_LightLensNode_upcast_to_Light_46, METH_NOARGS, (const char *)Dtool_LightLensNode_upcast_to_Light_46_comment},
  {"upcast_to_Camera", &Dtool_LightLensNode_upcast_to_Camera_49, METH_NOARGS, (const char *)Dtool_LightLensNode_upcast_to_Camera_49_comment},
  {"upcastToCamera", &Dtool_LightLensNode_upcast_to_Camera_49, METH_NOARGS, (const char *)Dtool_LightLensNode_upcast_to_Camera_49_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     LightLensNode
//////////////////
static PyObject *Dtool_Repr_LightLensNode(PyObject *self) {
  LightLensNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightLensNode, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     LightLensNode
//////////////////
static PyObject *Dtool_Str_LightLensNode(PyObject *self) {
  LightLensNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightLensNode, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_LightLensNode[] = {
  {(char *)"shadow_caster", &Dtool_LightLensNode_shadow_caster_Getter, NULL, NULL, NULL},
  {(char *)"shadow_buffer_size", &Dtool_LightLensNode_shadow_buffer_size_Getter, &Dtool_LightLensNode_shadow_buffer_size_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LightLensNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LightLensNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LightLensNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LightLensNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LightLensNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LightLensNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LightLensNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_LightLensNode,
    &Dtool_NumberMethods_LightLensNode,
    &Dtool_SequenceMethods_LightLensNode,
    &Dtool_MappingMethods_LightLensNode,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_LightLensNode,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LightLensNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A derivative of Light and of Camera.  The name might be misleading: it does\n"
    " * not directly derive from LensNode, but through the Camera class.  The\n"
    " * Camera serves no purpose unless shadows are enabled.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LightLensNode,
    0, // tp_members
    Dtool_Properties_LightLensNode,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LightLensNode,
    PyType_GenericAlloc,
    Dtool_new_LightLensNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LightLensNode,
  Dtool_UpcastInterface_LightLensNode,
  Dtool_DowncastInterface_LightLensNode,
  (CoerceFunction)Dtool_ConstCoerce_LightLensNode,
  (CoerceFunction)Dtool_Coerce_LightLensNode,
};

static void Dtool_PyModuleClassInit_LightLensNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Light != NULL);
    assert(Dtool_Ptr_Light->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Light->_Dtool_ModuleClassInit(NULL);
    assert(Dtool_Ptr_Camera != NULL);
    assert(Dtool_Ptr_Camera->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Camera->_Dtool_ModuleClassInit(NULL);
    Dtool_LightLensNode._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_Light, (PyTypeObject *)Dtool_Ptr_Camera);
    PyObject *dict = PyDict_New();
    Dtool_LightLensNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LightLensNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LightLensNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LightLensNode);
  }
}

/**
 * Python method tables for DirectionalLight (DirectionalLight)
 */
static PyMethodDef Dtool_Methods_DirectionalLight[] = {
  {"get_specular_color", &Dtool_DirectionalLight_get_specular_color_66, METH_NOARGS, (const char *)Dtool_DirectionalLight_get_specular_color_66_comment},
  {"getSpecularColor", &Dtool_DirectionalLight_get_specular_color_66, METH_NOARGS, (const char *)Dtool_DirectionalLight_get_specular_color_66_comment},
  {"set_specular_color", &Dtool_DirectionalLight_set_specular_color_67, METH_O, (const char *)Dtool_DirectionalLight_set_specular_color_67_comment},
  {"setSpecularColor", &Dtool_DirectionalLight_set_specular_color_67, METH_O, (const char *)Dtool_DirectionalLight_set_specular_color_67_comment},
  {"clear_specular_color", &Dtool_DirectionalLight_clear_specular_color_68, METH_NOARGS, (const char *)Dtool_DirectionalLight_clear_specular_color_68_comment},
  {"clearSpecularColor", &Dtool_DirectionalLight_clear_specular_color_68, METH_NOARGS, (const char *)Dtool_DirectionalLight_clear_specular_color_68_comment},
  {"get_point", &Dtool_DirectionalLight_get_point_74, METH_NOARGS, (const char *)Dtool_DirectionalLight_get_point_74_comment},
  {"getPoint", &Dtool_DirectionalLight_get_point_74, METH_NOARGS, (const char *)Dtool_DirectionalLight_get_point_74_comment},
  {"set_point", &Dtool_DirectionalLight_set_point_75, METH_O, (const char *)Dtool_DirectionalLight_set_point_75_comment},
  {"setPoint", &Dtool_DirectionalLight_set_point_75, METH_O, (const char *)Dtool_DirectionalLight_set_point_75_comment},
  {"get_direction", &Dtool_DirectionalLight_get_direction_80, METH_NOARGS, (const char *)Dtool_DirectionalLight_get_direction_80_comment},
  {"getDirection", &Dtool_DirectionalLight_get_direction_80, METH_NOARGS, (const char *)Dtool_DirectionalLight_get_direction_80_comment},
  {"set_direction", &Dtool_DirectionalLight_set_direction_81, METH_O, (const char *)Dtool_DirectionalLight_set_direction_81_comment},
  {"setDirection", &Dtool_DirectionalLight_set_direction_81, METH_O, (const char *)Dtool_DirectionalLight_set_direction_81_comment},
  {"get_class_type", &Dtool_DirectionalLight_get_class_type_86, METH_NOARGS | METH_STATIC, (const char *)Dtool_DirectionalLight_get_class_type_86_comment},
  {"getClassType", &Dtool_DirectionalLight_get_class_type_86, METH_NOARGS | METH_STATIC, (const char *)Dtool_DirectionalLight_get_class_type_86_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_DirectionalLight[] = {
  {(char *)"specular_color", &Dtool_DirectionalLight_specular_color_Getter, &Dtool_DirectionalLight_specular_color_Setter, NULL, NULL},
  {(char *)"point", &Dtool_DirectionalLight_point_Getter, &Dtool_DirectionalLight_point_Setter, NULL, NULL},
  {(char *)"direction", &Dtool_DirectionalLight_direction_Getter, &Dtool_DirectionalLight_direction_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_DirectionalLight = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DirectionalLight = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DirectionalLight = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DirectionalLight = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DirectionalLight = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.DirectionalLight",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DirectionalLight,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DirectionalLight,
    &Dtool_SequenceMethods_DirectionalLight,
    &Dtool_MappingMethods_DirectionalLight,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DirectionalLight,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A light shining from infinitely far away in a particular direction, like\n"
    " * sunlight.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DirectionalLight,
    0, // tp_members
    Dtool_Properties_DirectionalLight,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DirectionalLight,
    PyType_GenericAlloc,
    Dtool_new_DirectionalLight,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DirectionalLight,
  Dtool_UpcastInterface_DirectionalLight,
  Dtool_DowncastInterface_DirectionalLight,
  (CoerceFunction)Dtool_ConstCoerce_DirectionalLight,
  (CoerceFunction)Dtool_Coerce_DirectionalLight,
};

static void Dtool_PyModuleClassInit_DirectionalLight(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LightLensNode(NULL);
    Dtool_DirectionalLight._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LightLensNode);
    PyObject *dict = PyDict_New();
    Dtool_DirectionalLight._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DirectionalLight) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DirectionalLight)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DirectionalLight);
  }
}

/**
 * Python method tables for LODNode (LODNode)
 */
static PyMethodDef Dtool_Methods_LODNode[] = {
  {"make_default_lod", &Dtool_LODNode_make_default_lod_90, METH_O | METH_STATIC, (const char *)Dtool_LODNode_make_default_lod_90_comment},
  {"makeDefaultLod", &Dtool_LODNode_make_default_lod_90, METH_O | METH_STATIC, (const char *)Dtool_LODNode_make_default_lod_90_comment},
  {"add_switch", (PyCFunction) &Dtool_LODNode_add_switch_91, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LODNode_add_switch_91_comment},
  {"addSwitch", (PyCFunction) &Dtool_LODNode_add_switch_91, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LODNode_add_switch_91_comment},
  {"set_switch", (PyCFunction) &Dtool_LODNode_set_switch_92, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LODNode_set_switch_92_comment},
  {"setSwitch", (PyCFunction) &Dtool_LODNode_set_switch_92, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LODNode_set_switch_92_comment},
  {"clear_switches", &Dtool_LODNode_clear_switches_93, METH_NOARGS, (const char *)Dtool_LODNode_clear_switches_93_comment},
  {"clearSwitches", &Dtool_LODNode_clear_switches_93, METH_NOARGS, (const char *)Dtool_LODNode_clear_switches_93_comment},
  {"get_num_switches", &Dtool_LODNode_get_num_switches_94, METH_NOARGS, (const char *)Dtool_LODNode_get_num_switches_94_comment},
  {"getNumSwitches", &Dtool_LODNode_get_num_switches_94, METH_NOARGS, (const char *)Dtool_LODNode_get_num_switches_94_comment},
  {"get_in", &Dtool_LODNode_get_in_95, METH_O, (const char *)Dtool_LODNode_get_in_95_comment},
  {"getIn", &Dtool_LODNode_get_in_95, METH_O, (const char *)Dtool_LODNode_get_in_95_comment},
  {"get_out", &Dtool_LODNode_get_out_97, METH_O, (const char *)Dtool_LODNode_get_out_97_comment},
  {"getOut", &Dtool_LODNode_get_out_97, METH_O, (const char *)Dtool_LODNode_get_out_97_comment},
  {"get_lowest_switch", &Dtool_LODNode_get_lowest_switch_99, METH_NOARGS, (const char *)Dtool_LODNode_get_lowest_switch_99_comment},
  {"getLowestSwitch", &Dtool_LODNode_get_lowest_switch_99, METH_NOARGS, (const char *)Dtool_LODNode_get_lowest_switch_99_comment},
  {"get_highest_switch", &Dtool_LODNode_get_highest_switch_100, METH_NOARGS, (const char *)Dtool_LODNode_get_highest_switch_100_comment},
  {"getHighestSwitch", &Dtool_LODNode_get_highest_switch_100, METH_NOARGS, (const char *)Dtool_LODNode_get_highest_switch_100_comment},
  {"force_switch", &Dtool_LODNode_force_switch_101, METH_O, (const char *)Dtool_LODNode_force_switch_101_comment},
  {"forceSwitch", &Dtool_LODNode_force_switch_101, METH_O, (const char *)Dtool_LODNode_force_switch_101_comment},
  {"clear_force_switch", &Dtool_LODNode_clear_force_switch_102, METH_NOARGS, (const char *)Dtool_LODNode_clear_force_switch_102_comment},
  {"clearForceSwitch", &Dtool_LODNode_clear_force_switch_102, METH_NOARGS, (const char *)Dtool_LODNode_clear_force_switch_102_comment},
  {"set_lod_scale", &Dtool_LODNode_set_lod_scale_103, METH_O, (const char *)Dtool_LODNode_set_lod_scale_103_comment},
  {"setLodScale", &Dtool_LODNode_set_lod_scale_103, METH_O, (const char *)Dtool_LODNode_set_lod_scale_103_comment},
  {"get_lod_scale", &Dtool_LODNode_get_lod_scale_104, METH_NOARGS, (const char *)Dtool_LODNode_get_lod_scale_104_comment},
  {"getLodScale", &Dtool_LODNode_get_lod_scale_104, METH_NOARGS, (const char *)Dtool_LODNode_get_lod_scale_104_comment},
  {"set_center", &Dtool_LODNode_set_center_105, METH_O, (const char *)Dtool_LODNode_set_center_105_comment},
  {"setCenter", &Dtool_LODNode_set_center_105, METH_O, (const char *)Dtool_LODNode_set_center_105_comment},
  {"get_center", &Dtool_LODNode_get_center_106, METH_NOARGS, (const char *)Dtool_LODNode_get_center_106_comment},
  {"getCenter", &Dtool_LODNode_get_center_106, METH_NOARGS, (const char *)Dtool_LODNode_get_center_106_comment},
  {"show_switch", (PyCFunction) &Dtool_LODNode_show_switch_116, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LODNode_show_switch_116_comment},
  {"showSwitch", (PyCFunction) &Dtool_LODNode_show_switch_116, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LODNode_show_switch_116_comment},
  {"hide_switch", &Dtool_LODNode_hide_switch_117, METH_O, (const char *)Dtool_LODNode_hide_switch_117_comment},
  {"hideSwitch", &Dtool_LODNode_hide_switch_117, METH_O, (const char *)Dtool_LODNode_hide_switch_117_comment},
  {"show_all_switches", &Dtool_LODNode_show_all_switches_118, METH_NOARGS, (const char *)Dtool_LODNode_show_all_switches_118_comment},
  {"showAllSwitches", &Dtool_LODNode_show_all_switches_118, METH_NOARGS, (const char *)Dtool_LODNode_show_all_switches_118_comment},
  {"hide_all_switches", &Dtool_LODNode_hide_all_switches_119, METH_NOARGS, (const char *)Dtool_LODNode_hide_all_switches_119_comment},
  {"hideAllSwitches", &Dtool_LODNode_hide_all_switches_119, METH_NOARGS, (const char *)Dtool_LODNode_hide_all_switches_119_comment},
  {"is_any_shown", &Dtool_LODNode_is_any_shown_120, METH_NOARGS, (const char *)Dtool_LODNode_is_any_shown_120_comment},
  {"isAnyShown", &Dtool_LODNode_is_any_shown_120, METH_NOARGS, (const char *)Dtool_LODNode_is_any_shown_120_comment},
  {"verify_child_bounds", &Dtool_LODNode_verify_child_bounds_121, METH_NOARGS, (const char *)Dtool_LODNode_verify_child_bounds_121_comment},
  {"verifyChildBounds", &Dtool_LODNode_verify_child_bounds_121, METH_NOARGS, (const char *)Dtool_LODNode_verify_child_bounds_121_comment},
  {"get_class_type", &Dtool_LODNode_get_class_type_122, METH_NOARGS | METH_STATIC, (const char *)Dtool_LODNode_get_class_type_122_comment},
  {"getClassType", &Dtool_LODNode_get_class_type_122, METH_NOARGS | METH_STATIC, (const char *)Dtool_LODNode_get_class_type_122_comment},
  {"get_ins", (PyCFunction) &MakeSeq_LODNode_get_ins, METH_NOARGS, NULL},
  { "getIns", (PyCFunction) &MakeSeq_LODNode_get_ins, METH_NOARGS, NULL},
  {"get_outs", (PyCFunction) &MakeSeq_LODNode_get_outs, METH_NOARGS, NULL},
  { "getOuts", (PyCFunction) &MakeSeq_LODNode_get_outs, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_LODNode[] = {
  {(char *)"ins", &Dtool_LODNode_ins_Getter, NULL, NULL, NULL},
  {(char *)"outs", &Dtool_LODNode_outs_Getter, NULL, NULL, NULL},
  {(char *)"lowest_switch", &Dtool_LODNode_lowest_switch_Getter, NULL, NULL, NULL},
  {(char *)"highest_switch", &Dtool_LODNode_highest_switch_Getter, NULL, NULL, NULL},
  {(char *)"lod_scale", &Dtool_LODNode_lod_scale_Getter, &Dtool_LODNode_lod_scale_Setter, NULL, NULL},
  {(char *)"center", &Dtool_LODNode_center_Getter, &Dtool_LODNode_center_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LODNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LODNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LODNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LODNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LODNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LODNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LODNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LODNode,
    &Dtool_SequenceMethods_LODNode,
    &Dtool_MappingMethods_LODNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LODNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A Level-of-Detail node.  This selects only one of its children for\n"
    " * rendering, according to the distance from the camera and the table\n"
    " * indicated in the associated LOD object.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LODNode,
    0, // tp_members
    Dtool_Properties_LODNode,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LODNode,
    PyType_GenericAlloc,
    Dtool_new_LODNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LODNode,
  Dtool_UpcastInterface_LODNode,
  Dtool_DowncastInterface_LODNode,
  (CoerceFunction)Dtool_ConstCoerce_LODNode,
  (CoerceFunction)Dtool_Coerce_LODNode,
};

static void Dtool_PyModuleClassInit_LODNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_LODNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_LODNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LODNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LODNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LODNode);
  }
}

/**
 * Python method tables for FadeLODNode (FadeLODNode)
 */
static PyMethodDef Dtool_Methods_FadeLODNode[] = {
  {"set_fade_time", &Dtool_FadeLODNode_set_fade_time_126, METH_O, (const char *)Dtool_FadeLODNode_set_fade_time_126_comment},
  {"setFadeTime", &Dtool_FadeLODNode_set_fade_time_126, METH_O, (const char *)Dtool_FadeLODNode_set_fade_time_126_comment},
  {"get_fade_time", &Dtool_FadeLODNode_get_fade_time_127, METH_NOARGS, (const char *)Dtool_FadeLODNode_get_fade_time_127_comment},
  {"getFadeTime", &Dtool_FadeLODNode_get_fade_time_127, METH_NOARGS, (const char *)Dtool_FadeLODNode_get_fade_time_127_comment},
  {"set_fade_bin", (PyCFunction) &Dtool_FadeLODNode_set_fade_bin_129, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FadeLODNode_set_fade_bin_129_comment},
  {"setFadeBin", (PyCFunction) &Dtool_FadeLODNode_set_fade_bin_129, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FadeLODNode_set_fade_bin_129_comment},
  {"get_fade_bin_name", &Dtool_FadeLODNode_get_fade_bin_name_130, METH_NOARGS, (const char *)Dtool_FadeLODNode_get_fade_bin_name_130_comment},
  {"getFadeBinName", &Dtool_FadeLODNode_get_fade_bin_name_130, METH_NOARGS, (const char *)Dtool_FadeLODNode_get_fade_bin_name_130_comment},
  {"get_fade_bin_draw_order", &Dtool_FadeLODNode_get_fade_bin_draw_order_131, METH_NOARGS, (const char *)Dtool_FadeLODNode_get_fade_bin_draw_order_131_comment},
  {"getFadeBinDrawOrder", &Dtool_FadeLODNode_get_fade_bin_draw_order_131, METH_NOARGS, (const char *)Dtool_FadeLODNode_get_fade_bin_draw_order_131_comment},
  {"set_fade_state_override", &Dtool_FadeLODNode_set_fade_state_override_137, METH_O, (const char *)Dtool_FadeLODNode_set_fade_state_override_137_comment},
  {"setFadeStateOverride", &Dtool_FadeLODNode_set_fade_state_override_137, METH_O, (const char *)Dtool_FadeLODNode_set_fade_state_override_137_comment},
  {"get_fade_state_override", &Dtool_FadeLODNode_get_fade_state_override_138, METH_NOARGS, (const char *)Dtool_FadeLODNode_get_fade_state_override_138_comment},
  {"getFadeStateOverride", &Dtool_FadeLODNode_get_fade_state_override_138, METH_NOARGS, (const char *)Dtool_FadeLODNode_get_fade_state_override_138_comment},
  {"get_class_type", &Dtool_FadeLODNode_get_class_type_140, METH_NOARGS | METH_STATIC, (const char *)Dtool_FadeLODNode_get_class_type_140_comment},
  {"getClassType", &Dtool_FadeLODNode_get_class_type_140, METH_NOARGS | METH_STATIC, (const char *)Dtool_FadeLODNode_get_class_type_140_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_FadeLODNode[] = {
  {(char *)"fade_time", &Dtool_FadeLODNode_fade_time_Getter, &Dtool_FadeLODNode_fade_time_Setter, NULL, NULL},
  {(char *)"fade_bin_name", &Dtool_FadeLODNode_fade_bin_name_Getter, NULL, NULL, NULL},
  {(char *)"fade_bin_draw_order", &Dtool_FadeLODNode_fade_bin_draw_order_Getter, NULL, NULL, NULL},
  {(char *)"fade_state_override", &Dtool_FadeLODNode_fade_state_override_Getter, &Dtool_FadeLODNode_fade_state_override_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_FadeLODNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_FadeLODNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_FadeLODNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_FadeLODNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_FadeLODNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.FadeLODNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_FadeLODNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_FadeLODNode,
    &Dtool_SequenceMethods_FadeLODNode,
    &Dtool_MappingMethods_FadeLODNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_FadeLODNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A Level-of-Detail node with alpha based switching.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_FadeLODNode,
    0, // tp_members
    Dtool_Properties_FadeLODNode,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_FadeLODNode,
    PyType_GenericAlloc,
    Dtool_new_FadeLODNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FadeLODNode,
  Dtool_UpcastInterface_FadeLODNode,
  Dtool_DowncastInterface_FadeLODNode,
  (CoerceFunction)Dtool_ConstCoerce_FadeLODNode,
  (CoerceFunction)Dtool_Coerce_FadeLODNode,
};

static void Dtool_PyModuleClassInit_FadeLODNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LODNode(NULL);
    Dtool_FadeLODNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LODNode);
    PyObject *dict = PyDict_New();
    Dtool_FadeLODNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_FadeLODNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FadeLODNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FadeLODNode);
  }
}

/**
 * Python method tables for NodeCullCallbackData (NodeCullCallbackData)
 */
static PyMethodDef Dtool_Methods_NodeCullCallbackData[] = {
  {"get_trav", &Dtool_NodeCullCallbackData_get_trav_144, METH_NOARGS, (const char *)Dtool_NodeCullCallbackData_get_trav_144_comment},
  {"getTrav", &Dtool_NodeCullCallbackData_get_trav_144, METH_NOARGS, (const char *)Dtool_NodeCullCallbackData_get_trav_144_comment},
  {"get_data", &Dtool_NodeCullCallbackData_get_data_145, METH_NOARGS, (const char *)Dtool_NodeCullCallbackData_get_data_145_comment},
  {"getData", &Dtool_NodeCullCallbackData_get_data_145, METH_NOARGS, (const char *)Dtool_NodeCullCallbackData_get_data_145_comment},
  {"get_class_type", &Dtool_NodeCullCallbackData_get_class_type_146, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodeCullCallbackData_get_class_type_146_comment},
  {"getClassType", &Dtool_NodeCullCallbackData_get_class_type_146, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodeCullCallbackData_get_class_type_146_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_NodeCullCallbackData = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NodeCullCallbackData = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_NodeCullCallbackData = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_NodeCullCallbackData = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_NodeCullCallbackData = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.NodeCullCallbackData",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_NodeCullCallbackData,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_NodeCullCallbackData,
    &Dtool_SequenceMethods_NodeCullCallbackData,
    &Dtool_MappingMethods_NodeCullCallbackData,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_NodeCullCallbackData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This kind of CallbackData is passed to the CallbackObject added to\n"
    " * CallbackNode:set_cull_callback().\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_NodeCullCallbackData,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_NodeCullCallbackData,
    PyType_GenericAlloc,
    Dtool_new_NodeCullCallbackData,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NodeCullCallbackData,
  Dtool_UpcastInterface_NodeCullCallbackData,
  Dtool_DowncastInterface_NodeCullCallbackData,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_NodeCullCallbackData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CallbackData != NULL);
    assert(Dtool_Ptr_CallbackData->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_CallbackData->_Dtool_ModuleClassInit(NULL);
    Dtool_NodeCullCallbackData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_CallbackData);
    PyObject *dict = PyDict_New();
    Dtool_NodeCullCallbackData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NodeCullCallbackData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NodeCullCallbackData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NodeCullCallbackData);
  }
}

/**
 * Python method tables for PointLight (PointLight)
 */
static PyMethodDef Dtool_Methods_PointLight[] = {
  {"get_specular_color", &Dtool_PointLight_get_specular_color_151, METH_NOARGS, (const char *)Dtool_PointLight_get_specular_color_151_comment},
  {"getSpecularColor", &Dtool_PointLight_get_specular_color_151, METH_NOARGS, (const char *)Dtool_PointLight_get_specular_color_151_comment},
  {"set_specular_color", &Dtool_PointLight_set_specular_color_152, METH_O, (const char *)Dtool_PointLight_set_specular_color_152_comment},
  {"setSpecularColor", &Dtool_PointLight_set_specular_color_152, METH_O, (const char *)Dtool_PointLight_set_specular_color_152_comment},
  {"clear_specular_color", &Dtool_PointLight_clear_specular_color_153, METH_NOARGS, (const char *)Dtool_PointLight_clear_specular_color_153_comment},
  {"clearSpecularColor", &Dtool_PointLight_clear_specular_color_153, METH_NOARGS, (const char *)Dtool_PointLight_clear_specular_color_153_comment},
  {"get_attenuation", &Dtool_PointLight_get_attenuation_155, METH_NOARGS, (const char *)Dtool_PointLight_get_attenuation_155_comment},
  {"getAttenuation", &Dtool_PointLight_get_attenuation_155, METH_NOARGS, (const char *)Dtool_PointLight_get_attenuation_155_comment},
  {"set_attenuation", &Dtool_PointLight_set_attenuation_156, METH_O, (const char *)Dtool_PointLight_set_attenuation_156_comment},
  {"setAttenuation", &Dtool_PointLight_set_attenuation_156, METH_O, (const char *)Dtool_PointLight_set_attenuation_156_comment},
  {"get_max_distance", &Dtool_PointLight_get_max_distance_161, METH_NOARGS, (const char *)Dtool_PointLight_get_max_distance_161_comment},
  {"getMaxDistance", &Dtool_PointLight_get_max_distance_161, METH_NOARGS, (const char *)Dtool_PointLight_get_max_distance_161_comment},
  {"set_max_distance", &Dtool_PointLight_set_max_distance_162, METH_O, (const char *)Dtool_PointLight_set_max_distance_162_comment},
  {"setMaxDistance", &Dtool_PointLight_set_max_distance_162, METH_O, (const char *)Dtool_PointLight_set_max_distance_162_comment},
  {"get_point", &Dtool_PointLight_get_point_164, METH_NOARGS, (const char *)Dtool_PointLight_get_point_164_comment},
  {"getPoint", &Dtool_PointLight_get_point_164, METH_NOARGS, (const char *)Dtool_PointLight_get_point_164_comment},
  {"set_point", &Dtool_PointLight_set_point_165, METH_O, (const char *)Dtool_PointLight_set_point_165_comment},
  {"setPoint", &Dtool_PointLight_set_point_165, METH_O, (const char *)Dtool_PointLight_set_point_165_comment},
  {"get_class_type", &Dtool_PointLight_get_class_type_167, METH_NOARGS | METH_STATIC, (const char *)Dtool_PointLight_get_class_type_167_comment},
  {"getClassType", &Dtool_PointLight_get_class_type_167, METH_NOARGS | METH_STATIC, (const char *)Dtool_PointLight_get_class_type_167_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_PointLight[] = {
  {(char *)"specular_color", &Dtool_PointLight_specular_color_Getter, &Dtool_PointLight_specular_color_Setter, NULL, NULL},
  {(char *)"attenuation", &Dtool_PointLight_attenuation_Getter, &Dtool_PointLight_attenuation_Setter, NULL, NULL},
  {(char *)"max_distance", &Dtool_PointLight_max_distance_Getter, &Dtool_PointLight_max_distance_Setter, NULL, NULL},
  {(char *)"point", &Dtool_PointLight_point_Getter, &Dtool_PointLight_point_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_PointLight = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointLight = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointLight = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointLight = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointLight = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointLight",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointLight,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointLight,
    &Dtool_SequenceMethods_PointLight,
    &Dtool_MappingMethods_PointLight,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointLight,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A light originating from a single point in space, and shining in all\n"
    " * directions.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointLight,
    0, // tp_members
    Dtool_Properties_PointLight,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointLight,
    PyType_GenericAlloc,
    Dtool_new_PointLight,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointLight,
  Dtool_UpcastInterface_PointLight,
  Dtool_DowncastInterface_PointLight,
  (CoerceFunction)Dtool_ConstCoerce_PointLight,
  (CoerceFunction)Dtool_Coerce_PointLight,
};

static void Dtool_PyModuleClassInit_PointLight(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LightLensNode(NULL);
    Dtool_PointLight._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LightLensNode);
    PyObject *dict = PyDict_New();
    Dtool_PointLight._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointLight) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointLight)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointLight);
  }
}

/**
 * Python method tables for SelectiveChildNode (SelectiveChildNode)
 */
static PyMethodDef Dtool_Methods_SelectiveChildNode[] = {
  {"get_class_type", &Dtool_SelectiveChildNode_get_class_type_171, METH_NOARGS | METH_STATIC, (const char *)Dtool_SelectiveChildNode_get_class_type_171_comment},
  {"getClassType", &Dtool_SelectiveChildNode_get_class_type_171, METH_NOARGS | METH_STATIC, (const char *)Dtool_SelectiveChildNode_get_class_type_171_comment},
  {"downcast_to_SequenceNode", &Dtool_SelectiveChildNode_downcast_to_SequenceNode_175, METH_NOARGS, (const char *)Dtool_SelectiveChildNode_downcast_to_SequenceNode_175_comment},
  {"downcastToSequenceNode", &Dtool_SelectiveChildNode_downcast_to_SequenceNode_175, METH_NOARGS, (const char *)Dtool_SelectiveChildNode_downcast_to_SequenceNode_175_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_SelectiveChildNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SelectiveChildNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_SelectiveChildNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_SelectiveChildNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_SelectiveChildNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.SelectiveChildNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SelectiveChildNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_SelectiveChildNode,
    &Dtool_SequenceMethods_SelectiveChildNode,
    &Dtool_MappingMethods_SelectiveChildNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_SelectiveChildNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for nodes like LODNode and SequenceNode that select only one\n"
    " * visible child at a time.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SelectiveChildNode,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SelectiveChildNode,
    PyType_GenericAlloc,
    Dtool_new_SelectiveChildNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SelectiveChildNode,
  Dtool_UpcastInterface_SelectiveChildNode,
  Dtool_DowncastInterface_SelectiveChildNode,
  (CoerceFunction)Dtool_ConstCoerce_SelectiveChildNode,
  (CoerceFunction)Dtool_Coerce_SelectiveChildNode,
};

static void Dtool_PyModuleClassInit_SelectiveChildNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_SelectiveChildNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_SelectiveChildNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SelectiveChildNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SelectiveChildNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SelectiveChildNode);
  }
}

/**
 * Python method tables for SequenceNode (SequenceNode)
 */
static PyMethodDef Dtool_Methods_SequenceNode[] = {
  {"get_num_frames", &Dtool_SequenceNode_get_num_frames_180, METH_NOARGS, (const char *)Dtool_SequenceNode_get_num_frames_180_comment},
  {"getNumFrames", &Dtool_SequenceNode_get_num_frames_180, METH_NOARGS, (const char *)Dtool_SequenceNode_get_num_frames_180_comment},
  {"set_frame_rate", &Dtool_SequenceNode_set_frame_rate_181, METH_O, (const char *)Dtool_SequenceNode_set_frame_rate_181_comment},
  {"setFrameRate", &Dtool_SequenceNode_set_frame_rate_181, METH_O, (const char *)Dtool_SequenceNode_set_frame_rate_181_comment},
  {"get_class_type", &Dtool_SequenceNode_get_class_type_182, METH_NOARGS | METH_STATIC, (const char *)Dtool_SequenceNode_get_class_type_182_comment},
  {"getClassType", &Dtool_SequenceNode_get_class_type_182, METH_NOARGS | METH_STATIC, (const char *)Dtool_SequenceNode_get_class_type_182_comment},
  {"upcast_to_SelectiveChildNode", &Dtool_SequenceNode_upcast_to_SelectiveChildNode_174, METH_NOARGS, (const char *)Dtool_SequenceNode_upcast_to_SelectiveChildNode_174_comment},
  {"upcastToSelectiveChildNode", &Dtool_SequenceNode_upcast_to_SelectiveChildNode_174, METH_NOARGS, (const char *)Dtool_SequenceNode_upcast_to_SelectiveChildNode_174_comment},
  {"upcast_to_AnimInterface", &Dtool_SequenceNode_upcast_to_AnimInterface_177, METH_NOARGS, (const char *)Dtool_SequenceNode_upcast_to_AnimInterface_177_comment},
  {"upcastToAnimInterface", &Dtool_SequenceNode_upcast_to_AnimInterface_177, METH_NOARGS, (const char *)Dtool_SequenceNode_upcast_to_AnimInterface_177_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_SequenceNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SequenceNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_SequenceNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_SequenceNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_SequenceNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.SequenceNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SequenceNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_SequenceNode,
    &Dtool_SequenceMethods_SequenceNode,
    &Dtool_MappingMethods_SequenceNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_SequenceNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A node that automatically cycles through rendering each one of its children\n"
    " * according to its frame rate.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SequenceNode,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SequenceNode,
    PyType_GenericAlloc,
    Dtool_new_SequenceNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SequenceNode,
  Dtool_UpcastInterface_SequenceNode,
  Dtool_DowncastInterface_SequenceNode,
  (CoerceFunction)Dtool_ConstCoerce_SequenceNode,
  (CoerceFunction)Dtool_Coerce_SequenceNode,
};

static void Dtool_PyModuleClassInit_SequenceNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_SelectiveChildNode(NULL);
    assert(Dtool_Ptr_AnimInterface != NULL);
    assert(Dtool_Ptr_AnimInterface->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_AnimInterface->_Dtool_ModuleClassInit(NULL);
    Dtool_SequenceNode._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_SelectiveChildNode, (PyTypeObject *)Dtool_Ptr_AnimInterface);
    PyObject *dict = PyDict_New();
    Dtool_SequenceNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SequenceNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SequenceNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SequenceNode);
  }
}

/**
 * Python method tables for ShaderGenerator (ShaderGenerator)
 */
static PyMethodDef Dtool_Methods_ShaderGenerator[] = {
  {"synthesize_shader", (PyCFunction) &Dtool_ShaderGenerator_synthesize_shader_187, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderGenerator_synthesize_shader_187_comment},
  {"synthesizeShader", (PyCFunction) &Dtool_ShaderGenerator_synthesize_shader_187, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderGenerator_synthesize_shader_187_comment},
  {"get_class_type", &Dtool_ShaderGenerator_get_class_type_188, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderGenerator_get_class_type_188_comment},
  {"getClassType", &Dtool_ShaderGenerator_get_class_type_188, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderGenerator_get_class_type_188_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ShaderGenerator = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ShaderGenerator = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ShaderGenerator = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ShaderGenerator = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ShaderGenerator = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ShaderGenerator",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ShaderGenerator,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ShaderGenerator,
    &Dtool_SequenceMethods_ShaderGenerator,
    &Dtool_MappingMethods_ShaderGenerator,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ShaderGenerator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The ShaderGenerator is a device that effectively replaces the classic fixed\n"
    " * function pipeline with a 'next-gen' fixed function pipeline.  The next-gen\n"
    " * fixed function pipeline supports features like normal mapping, gloss\n"
    " * mapping, cartoon lighting, and so forth.  It works by automatically\n"
    " * generating a shader from a given RenderState.\n"
    " *\n"
    " * Currently, there is one ShaderGenerator object per GraphicsStateGuardian.\n"
    " * It is our intent that in time, people will write classes that derive from\n"
    " * ShaderGenerator but which yield slightly different results.\n"
    " *\n"
    " * The ShaderGenerator owes its existence to the 'Bamboo Team' at Carnegie\n"
    " * Mellon's Entertainment Technology Center.  This is a group of students who,\n"
    " * as a semester project, decided that next-gen graphics should be accessible\n"
    " * to everyone, even if they don't know shader programming.  The group\n"
    " * consisted of:\n"
    " *\n"
    " * Aaron Lo, Programmer Heegun Lee, Programmer Erin Fernandez, Artist/Tester\n"
    " * Joe Grubb, Artist/Tester Ivan Ortega, Technical Artist/Tester\n"
    " *\n"
    " * Thanks to them!\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ShaderGenerator,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ShaderGenerator,
    PyType_GenericAlloc,
    Dtool_new_ShaderGenerator,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShaderGenerator,
  Dtool_UpcastInterface_ShaderGenerator,
  Dtool_DowncastInterface_ShaderGenerator,
  (CoerceFunction)Dtool_ConstCoerce_ShaderGenerator,
  (CoerceFunction)Dtool_Coerce_ShaderGenerator,
};

static void Dtool_PyModuleClassInit_ShaderGenerator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_ShaderGenerator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_ShaderGenerator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ShaderGenerator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShaderGenerator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShaderGenerator);
  }
}

/**
 * Python method tables for SphereLight (SphereLight)
 */
static PyMethodDef Dtool_Methods_SphereLight[] = {
  {"get_radius", &Dtool_SphereLight_get_radius_191, METH_NOARGS, (const char *)Dtool_SphereLight_get_radius_191_comment},
  {"getRadius", &Dtool_SphereLight_get_radius_191, METH_NOARGS, (const char *)Dtool_SphereLight_get_radius_191_comment},
  {"set_radius", &Dtool_SphereLight_set_radius_192, METH_O, (const char *)Dtool_SphereLight_set_radius_192_comment},
  {"setRadius", &Dtool_SphereLight_set_radius_192, METH_O, (const char *)Dtool_SphereLight_set_radius_192_comment},
  {"get_class_type", &Dtool_SphereLight_get_class_type_194, METH_NOARGS | METH_STATIC, (const char *)Dtool_SphereLight_get_class_type_194_comment},
  {"getClassType", &Dtool_SphereLight_get_class_type_194, METH_NOARGS | METH_STATIC, (const char *)Dtool_SphereLight_get_class_type_194_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_SphereLight[] = {
  {(char *)"radius", &Dtool_SphereLight_radius_Getter, &Dtool_SphereLight_radius_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_SphereLight = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SphereLight = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_SphereLight = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_SphereLight = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_SphereLight = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.SphereLight",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SphereLight,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_SphereLight,
    &Dtool_SequenceMethods_SphereLight,
    &Dtool_MappingMethods_SphereLight,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_SphereLight,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A sphere light is like a point light, except that it represents a sphere\n"
    " * with a radius, rather than being an infinitely thin point in space.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SphereLight,
    0, // tp_members
    Dtool_Properties_SphereLight,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SphereLight,
    PyType_GenericAlloc,
    Dtool_new_SphereLight,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SphereLight,
  Dtool_UpcastInterface_SphereLight,
  Dtool_DowncastInterface_SphereLight,
  (CoerceFunction)Dtool_ConstCoerce_SphereLight,
  (CoerceFunction)Dtool_Coerce_SphereLight,
};

static void Dtool_PyModuleClassInit_SphereLight(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointLight(NULL);
    Dtool_SphereLight._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointLight);
    PyObject *dict = PyDict_New();
    Dtool_SphereLight._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SphereLight) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SphereLight)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SphereLight);
  }
}

/**
 * Python method tables for Spotlight (Spotlight)
 */
static PyMethodDef Dtool_Methods_Spotlight[] = {
  {"get_exponent", &Dtool_Spotlight_get_exponent_198, METH_NOARGS, (const char *)Dtool_Spotlight_get_exponent_198_comment},
  {"getExponent", &Dtool_Spotlight_get_exponent_198, METH_NOARGS, (const char *)Dtool_Spotlight_get_exponent_198_comment},
  {"set_exponent", &Dtool_Spotlight_set_exponent_199, METH_O, (const char *)Dtool_Spotlight_set_exponent_199_comment},
  {"setExponent", &Dtool_Spotlight_set_exponent_199, METH_O, (const char *)Dtool_Spotlight_set_exponent_199_comment},
  {"get_specular_color", &Dtool_Spotlight_get_specular_color_201, METH_NOARGS, (const char *)Dtool_Spotlight_get_specular_color_201_comment},
  {"getSpecularColor", &Dtool_Spotlight_get_specular_color_201, METH_NOARGS, (const char *)Dtool_Spotlight_get_specular_color_201_comment},
  {"set_specular_color", &Dtool_Spotlight_set_specular_color_202, METH_O, (const char *)Dtool_Spotlight_set_specular_color_202_comment},
  {"setSpecularColor", &Dtool_Spotlight_set_specular_color_202, METH_O, (const char *)Dtool_Spotlight_set_specular_color_202_comment},
  {"clear_specular_color", &Dtool_Spotlight_clear_specular_color_203, METH_NOARGS, (const char *)Dtool_Spotlight_clear_specular_color_203_comment},
  {"clearSpecularColor", &Dtool_Spotlight_clear_specular_color_203, METH_NOARGS, (const char *)Dtool_Spotlight_clear_specular_color_203_comment},
  {"get_attenuation", &Dtool_Spotlight_get_attenuation_205, METH_NOARGS, (const char *)Dtool_Spotlight_get_attenuation_205_comment},
  {"getAttenuation", &Dtool_Spotlight_get_attenuation_205, METH_NOARGS, (const char *)Dtool_Spotlight_get_attenuation_205_comment},
  {"set_attenuation", &Dtool_Spotlight_set_attenuation_206, METH_O, (const char *)Dtool_Spotlight_set_attenuation_206_comment},
  {"setAttenuation", &Dtool_Spotlight_set_attenuation_206, METH_O, (const char *)Dtool_Spotlight_set_attenuation_206_comment},
  {"get_max_distance", &Dtool_Spotlight_get_max_distance_208, METH_NOARGS, (const char *)Dtool_Spotlight_get_max_distance_208_comment},
  {"getMaxDistance", &Dtool_Spotlight_get_max_distance_208, METH_NOARGS, (const char *)Dtool_Spotlight_get_max_distance_208_comment},
  {"set_max_distance", &Dtool_Spotlight_set_max_distance_209, METH_O, (const char *)Dtool_Spotlight_set_max_distance_209_comment},
  {"setMaxDistance", &Dtool_Spotlight_set_max_distance_209, METH_O, (const char *)Dtool_Spotlight_set_max_distance_209_comment},
  {"make_spot", (PyCFunction) &Dtool_Spotlight_make_spot_211, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Spotlight_make_spot_211_comment},
  {"makeSpot", (PyCFunction) &Dtool_Spotlight_make_spot_211, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Spotlight_make_spot_211_comment},
  {"get_class_type", &Dtool_Spotlight_get_class_type_212, METH_NOARGS | METH_STATIC, (const char *)Dtool_Spotlight_get_class_type_212_comment},
  {"getClassType", &Dtool_Spotlight_get_class_type_212, METH_NOARGS | METH_STATIC, (const char *)Dtool_Spotlight_get_class_type_212_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_Spotlight[] = {
  {(char *)"exponent", &Dtool_Spotlight_exponent_Getter, &Dtool_Spotlight_exponent_Setter, NULL, NULL},
  {(char *)"specular_color", &Dtool_Spotlight_specular_color_Getter, &Dtool_Spotlight_specular_color_Setter, NULL, NULL},
  {(char *)"attenuation", &Dtool_Spotlight_attenuation_Getter, &Dtool_Spotlight_attenuation_Setter, NULL, NULL},
  {(char *)"max_distance", &Dtool_Spotlight_max_distance_Getter, &Dtool_Spotlight_max_distance_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_Spotlight = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Spotlight = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Spotlight = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Spotlight = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Spotlight = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Spotlight",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Spotlight,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Spotlight,
    &Dtool_SequenceMethods_Spotlight,
    &Dtool_MappingMethods_Spotlight,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Spotlight,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A light originating from a single point in space, and shining in a\n"
    " * particular direction, with a cone-shaped falloff.\n"
    " *\n"
    " * The Spotlight frustum is defined using a Lens, so it can have any of the\n"
    " * properties that a camera lens can have.\n"
    " *\n"
    " * Note that the class is named Spotlight instead of SpotLight, because\n"
    " * \"spotlight\" is a single English word, instead of two words.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Spotlight,
    0, // tp_members
    Dtool_Properties_Spotlight,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Spotlight,
    PyType_GenericAlloc,
    Dtool_new_Spotlight,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Spotlight,
  Dtool_UpcastInterface_Spotlight,
  Dtool_DowncastInterface_Spotlight,
  (CoerceFunction)Dtool_ConstCoerce_Spotlight,
  (CoerceFunction)Dtool_Coerce_Spotlight,
};

static void Dtool_PyModuleClassInit_Spotlight(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LightLensNode(NULL);
    Dtool_Spotlight._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LightLensNode);
    PyObject *dict = PyDict_New();
    Dtool_Spotlight._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Spotlight) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Spotlight)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Spotlight);
  }
}

/**
 * Python method tables for SwitchNode (SwitchNode)
 */
static PyMethodDef Dtool_Methods_SwitchNode[] = {
  {"set_visible_child", &Dtool_SwitchNode_set_visible_child_216, METH_O, (const char *)Dtool_SwitchNode_set_visible_child_216_comment},
  {"setVisibleChild", &Dtool_SwitchNode_set_visible_child_216, METH_O, (const char *)Dtool_SwitchNode_set_visible_child_216_comment},
  {"get_visible_child", &Dtool_SwitchNode_get_visible_child_217, METH_NOARGS, (const char *)Dtool_SwitchNode_get_visible_child_217_comment},
  {"getVisibleChild", &Dtool_SwitchNode_get_visible_child_217, METH_NOARGS, (const char *)Dtool_SwitchNode_get_visible_child_217_comment},
  {"get_class_type", &Dtool_SwitchNode_get_class_type_219, METH_NOARGS | METH_STATIC, (const char *)Dtool_SwitchNode_get_class_type_219_comment},
  {"getClassType", &Dtool_SwitchNode_get_class_type_219, METH_NOARGS | METH_STATIC, (const char *)Dtool_SwitchNode_get_class_type_219_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_SwitchNode[] = {
  {(char *)"visible_child", &Dtool_SwitchNode_visible_child_Getter, &Dtool_SwitchNode_visible_child_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_SwitchNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SwitchNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_SwitchNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_SwitchNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_SwitchNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.SwitchNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SwitchNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_SwitchNode,
    &Dtool_SequenceMethods_SwitchNode,
    &Dtool_MappingMethods_SwitchNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_SwitchNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A node that renders only one of its children, according to the user's\n"
    " * indication.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SwitchNode,
    0, // tp_members
    Dtool_Properties_SwitchNode,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SwitchNode,
    PyType_GenericAlloc,
    Dtool_new_SwitchNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SwitchNode,
  Dtool_UpcastInterface_SwitchNode,
  Dtool_DowncastInterface_SwitchNode,
  (CoerceFunction)Dtool_ConstCoerce_SwitchNode,
  (CoerceFunction)Dtool_Coerce_SwitchNode,
};

static void Dtool_PyModuleClassInit_SwitchNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_SelectiveChildNode(NULL);
    Dtool_SwitchNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_SelectiveChildNode);
    PyObject *dict = PyDict_New();
    Dtool_SwitchNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SwitchNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SwitchNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SwitchNode);
  }
}

/**
 * Python method tables for UvScrollNode (UvScrollNode)
 */
static PyMethodDef Dtool_Methods_UvScrollNode[] = {
  {"set_u_speed", &Dtool_UvScrollNode_set_u_speed_223, METH_O, (const char *)Dtool_UvScrollNode_set_u_speed_223_comment},
  {"setUSpeed", &Dtool_UvScrollNode_set_u_speed_223, METH_O, (const char *)Dtool_UvScrollNode_set_u_speed_223_comment},
  {"set_v_speed", &Dtool_UvScrollNode_set_v_speed_224, METH_O, (const char *)Dtool_UvScrollNode_set_v_speed_224_comment},
  {"setVSpeed", &Dtool_UvScrollNode_set_v_speed_224, METH_O, (const char *)Dtool_UvScrollNode_set_v_speed_224_comment},
  {"set_w_speed", &Dtool_UvScrollNode_set_w_speed_225, METH_O, (const char *)Dtool_UvScrollNode_set_w_speed_225_comment},
  {"setWSpeed", &Dtool_UvScrollNode_set_w_speed_225, METH_O, (const char *)Dtool_UvScrollNode_set_w_speed_225_comment},
  {"set_r_speed", &Dtool_UvScrollNode_set_r_speed_226, METH_O, (const char *)Dtool_UvScrollNode_set_r_speed_226_comment},
  {"setRSpeed", &Dtool_UvScrollNode_set_r_speed_226, METH_O, (const char *)Dtool_UvScrollNode_set_r_speed_226_comment},
  {"get_u_speed", &Dtool_UvScrollNode_get_u_speed_227, METH_NOARGS, (const char *)Dtool_UvScrollNode_get_u_speed_227_comment},
  {"getUSpeed", &Dtool_UvScrollNode_get_u_speed_227, METH_NOARGS, (const char *)Dtool_UvScrollNode_get_u_speed_227_comment},
  {"get_v_speed", &Dtool_UvScrollNode_get_v_speed_228, METH_NOARGS, (const char *)Dtool_UvScrollNode_get_v_speed_228_comment},
  {"getVSpeed", &Dtool_UvScrollNode_get_v_speed_228, METH_NOARGS, (const char *)Dtool_UvScrollNode_get_v_speed_228_comment},
  {"get_w_speed", &Dtool_UvScrollNode_get_w_speed_229, METH_NOARGS, (const char *)Dtool_UvScrollNode_get_w_speed_229_comment},
  {"getWSpeed", &Dtool_UvScrollNode_get_w_speed_229, METH_NOARGS, (const char *)Dtool_UvScrollNode_get_w_speed_229_comment},
  {"get_r_speed", &Dtool_UvScrollNode_get_r_speed_230, METH_NOARGS, (const char *)Dtool_UvScrollNode_get_r_speed_230_comment},
  {"getRSpeed", &Dtool_UvScrollNode_get_r_speed_230, METH_NOARGS, (const char *)Dtool_UvScrollNode_get_r_speed_230_comment},
  {"get_class_type", &Dtool_UvScrollNode_get_class_type_235, METH_NOARGS | METH_STATIC, (const char *)Dtool_UvScrollNode_get_class_type_235_comment},
  {"getClassType", &Dtool_UvScrollNode_get_class_type_235, METH_NOARGS | METH_STATIC, (const char *)Dtool_UvScrollNode_get_class_type_235_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_UvScrollNode[] = {
  {(char *)"u_speed", &Dtool_UvScrollNode_u_speed_Getter, &Dtool_UvScrollNode_u_speed_Setter, NULL, NULL},
  {(char *)"v_speed", &Dtool_UvScrollNode_v_speed_Getter, &Dtool_UvScrollNode_v_speed_Setter, NULL, NULL},
  {(char *)"w_speed", &Dtool_UvScrollNode_w_speed_Getter, &Dtool_UvScrollNode_w_speed_Setter, NULL, NULL},
  {(char *)"r_speed", &Dtool_UvScrollNode_r_speed_Getter, &Dtool_UvScrollNode_r_speed_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_UvScrollNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_UvScrollNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_UvScrollNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_UvScrollNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_UvScrollNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.UvScrollNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_UvScrollNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_UvScrollNode,
    &Dtool_SequenceMethods_UvScrollNode,
    &Dtool_MappingMethods_UvScrollNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_UvScrollNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This node is placed at key points within the scene graph to animate uvs.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_UvScrollNode,
    0, // tp_members
    Dtool_Properties_UvScrollNode,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_UvScrollNode,
    PyType_GenericAlloc,
    Dtool_new_UvScrollNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UvScrollNode,
  Dtool_UpcastInterface_UvScrollNode,
  Dtool_DowncastInterface_UvScrollNode,
  (CoerceFunction)Dtool_ConstCoerce_UvScrollNode,
  (CoerceFunction)Dtool_Coerce_UvScrollNode,
};

static void Dtool_PyModuleClassInit_UvScrollNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_UvScrollNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_UvScrollNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_UvScrollNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UvScrollNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UvScrollNode);
  }
}

/**
 * Python method tables for SceneGraphAnalyzer (SceneGraphAnalyzer)
 */
static PyMethodDef Dtool_Methods_SceneGraphAnalyzer[] = {
  {"set_lod_mode", &Dtool_SceneGraphAnalyzer_set_lod_mode_241, METH_O, (const char *)Dtool_SceneGraphAnalyzer_set_lod_mode_241_comment},
  {"setLodMode", &Dtool_SceneGraphAnalyzer_set_lod_mode_241, METH_O, (const char *)Dtool_SceneGraphAnalyzer_set_lod_mode_241_comment},
  {"get_lod_mode", &Dtool_SceneGraphAnalyzer_get_lod_mode_242, METH_O, (const char *)Dtool_SceneGraphAnalyzer_get_lod_mode_242_comment},
  {"getLodMode", &Dtool_SceneGraphAnalyzer_get_lod_mode_242, METH_O, (const char *)Dtool_SceneGraphAnalyzer_get_lod_mode_242_comment},
  {"clear", &Dtool_SceneGraphAnalyzer_clear_243, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_clear_243_comment},
  {"add_node", &Dtool_SceneGraphAnalyzer_add_node_244, METH_O, (const char *)Dtool_SceneGraphAnalyzer_add_node_244_comment},
  {"addNode", &Dtool_SceneGraphAnalyzer_add_node_244, METH_O, (const char *)Dtool_SceneGraphAnalyzer_add_node_244_comment},
  {"write", (PyCFunction) &Dtool_SceneGraphAnalyzer_write_245, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SceneGraphAnalyzer_write_245_comment},
  {"get_num_nodes", &Dtool_SceneGraphAnalyzer_get_num_nodes_246, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_nodes_246_comment},
  {"getNumNodes", &Dtool_SceneGraphAnalyzer_get_num_nodes_246, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_nodes_246_comment},
  {"get_num_instances", &Dtool_SceneGraphAnalyzer_get_num_instances_247, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_instances_247_comment},
  {"getNumInstances", &Dtool_SceneGraphAnalyzer_get_num_instances_247, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_instances_247_comment},
  {"get_num_transforms", &Dtool_SceneGraphAnalyzer_get_num_transforms_248, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_transforms_248_comment},
  {"getNumTransforms", &Dtool_SceneGraphAnalyzer_get_num_transforms_248, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_transforms_248_comment},
  {"get_num_nodes_with_attribs", &Dtool_SceneGraphAnalyzer_get_num_nodes_with_attribs_249, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_nodes_with_attribs_249_comment},
  {"getNumNodesWithAttribs", &Dtool_SceneGraphAnalyzer_get_num_nodes_with_attribs_249, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_nodes_with_attribs_249_comment},
  {"get_num_lod_nodes", &Dtool_SceneGraphAnalyzer_get_num_lod_nodes_250, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_lod_nodes_250_comment},
  {"getNumLodNodes", &Dtool_SceneGraphAnalyzer_get_num_lod_nodes_250, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_lod_nodes_250_comment},
  {"get_num_geom_nodes", &Dtool_SceneGraphAnalyzer_get_num_geom_nodes_251, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_geom_nodes_251_comment},
  {"getNumGeomNodes", &Dtool_SceneGraphAnalyzer_get_num_geom_nodes_251, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_geom_nodes_251_comment},
  {"get_num_geoms", &Dtool_SceneGraphAnalyzer_get_num_geoms_252, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_geoms_252_comment},
  {"getNumGeoms", &Dtool_SceneGraphAnalyzer_get_num_geoms_252, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_geoms_252_comment},
  {"get_num_geom_vertex_datas", &Dtool_SceneGraphAnalyzer_get_num_geom_vertex_datas_253, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_geom_vertex_datas_253_comment},
  {"getNumGeomVertexDatas", &Dtool_SceneGraphAnalyzer_get_num_geom_vertex_datas_253, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_geom_vertex_datas_253_comment},
  {"get_num_geom_vertex_formats", &Dtool_SceneGraphAnalyzer_get_num_geom_vertex_formats_254, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_geom_vertex_formats_254_comment},
  {"getNumGeomVertexFormats", &Dtool_SceneGraphAnalyzer_get_num_geom_vertex_formats_254, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_geom_vertex_formats_254_comment},
  {"get_vertex_data_size", &Dtool_SceneGraphAnalyzer_get_vertex_data_size_255, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_vertex_data_size_255_comment},
  {"getVertexDataSize", &Dtool_SceneGraphAnalyzer_get_vertex_data_size_255, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_vertex_data_size_255_comment},
  {"get_num_vertices", &Dtool_SceneGraphAnalyzer_get_num_vertices_256, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_vertices_256_comment},
  {"getNumVertices", &Dtool_SceneGraphAnalyzer_get_num_vertices_256, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_vertices_256_comment},
  {"get_num_normals", &Dtool_SceneGraphAnalyzer_get_num_normals_257, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_normals_257_comment},
  {"getNumNormals", &Dtool_SceneGraphAnalyzer_get_num_normals_257, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_normals_257_comment},
  {"get_num_colors", &Dtool_SceneGraphAnalyzer_get_num_colors_258, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_colors_258_comment},
  {"getNumColors", &Dtool_SceneGraphAnalyzer_get_num_colors_258, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_colors_258_comment},
  {"get_num_texcoords", &Dtool_SceneGraphAnalyzer_get_num_texcoords_259, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_texcoords_259_comment},
  {"getNumTexcoords", &Dtool_SceneGraphAnalyzer_get_num_texcoords_259, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_texcoords_259_comment},
  {"get_num_tris", &Dtool_SceneGraphAnalyzer_get_num_tris_260, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_tris_260_comment},
  {"getNumTris", &Dtool_SceneGraphAnalyzer_get_num_tris_260, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_tris_260_comment},
  {"get_num_lines", &Dtool_SceneGraphAnalyzer_get_num_lines_261, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_lines_261_comment},
  {"getNumLines", &Dtool_SceneGraphAnalyzer_get_num_lines_261, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_lines_261_comment},
  {"get_num_points", &Dtool_SceneGraphAnalyzer_get_num_points_262, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_points_262_comment},
  {"getNumPoints", &Dtool_SceneGraphAnalyzer_get_num_points_262, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_points_262_comment},
  {"get_num_patches", &Dtool_SceneGraphAnalyzer_get_num_patches_263, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_patches_263_comment},
  {"getNumPatches", &Dtool_SceneGraphAnalyzer_get_num_patches_263, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_patches_263_comment},
  {"get_num_individual_tris", &Dtool_SceneGraphAnalyzer_get_num_individual_tris_264, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_individual_tris_264_comment},
  {"getNumIndividualTris", &Dtool_SceneGraphAnalyzer_get_num_individual_tris_264, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_individual_tris_264_comment},
  {"get_num_tristrips", &Dtool_SceneGraphAnalyzer_get_num_tristrips_265, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_tristrips_265_comment},
  {"getNumTristrips", &Dtool_SceneGraphAnalyzer_get_num_tristrips_265, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_tristrips_265_comment},
  {"get_num_triangles_in_strips", &Dtool_SceneGraphAnalyzer_get_num_triangles_in_strips_266, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_triangles_in_strips_266_comment},
  {"getNumTrianglesInStrips", &Dtool_SceneGraphAnalyzer_get_num_triangles_in_strips_266, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_triangles_in_strips_266_comment},
  {"get_num_trifans", &Dtool_SceneGraphAnalyzer_get_num_trifans_267, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_trifans_267_comment},
  {"getNumTrifans", &Dtool_SceneGraphAnalyzer_get_num_trifans_267, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_trifans_267_comment},
  {"get_num_triangles_in_fans", &Dtool_SceneGraphAnalyzer_get_num_triangles_in_fans_268, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_triangles_in_fans_268_comment},
  {"getNumTrianglesInFans", &Dtool_SceneGraphAnalyzer_get_num_triangles_in_fans_268, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_triangles_in_fans_268_comment},
  {"get_num_vertices_in_patches", &Dtool_SceneGraphAnalyzer_get_num_vertices_in_patches_269, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_vertices_in_patches_269_comment},
  {"getNumVerticesInPatches", &Dtool_SceneGraphAnalyzer_get_num_vertices_in_patches_269, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_vertices_in_patches_269_comment},
  {"get_texture_bytes", &Dtool_SceneGraphAnalyzer_get_texture_bytes_270, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_texture_bytes_270_comment},
  {"getTextureBytes", &Dtool_SceneGraphAnalyzer_get_texture_bytes_270, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_texture_bytes_270_comment},
  {"get_num_long_normals", &Dtool_SceneGraphAnalyzer_get_num_long_normals_271, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_long_normals_271_comment},
  {"getNumLongNormals", &Dtool_SceneGraphAnalyzer_get_num_long_normals_271, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_long_normals_271_comment},
  {"get_num_short_normals", &Dtool_SceneGraphAnalyzer_get_num_short_normals_272, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_short_normals_272_comment},
  {"getNumShortNormals", &Dtool_SceneGraphAnalyzer_get_num_short_normals_272, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_short_normals_272_comment},
  {"get_total_normal_length", &Dtool_SceneGraphAnalyzer_get_total_normal_length_273, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_total_normal_length_273_comment},
  {"getTotalNormalLength", &Dtool_SceneGraphAnalyzer_get_total_normal_length_273, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_total_normal_length_273_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     SceneGraphAnalyzer
//////////////////
static PyObject *Dtool_Str_SceneGraphAnalyzer(PyObject *self) {
  SceneGraphAnalyzer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_SceneGraphAnalyzer = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_SceneGraphAnalyzer = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.SceneGraphAnalyzer",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SceneGraphAnalyzer,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_SceneGraphAnalyzer,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_SceneGraphAnalyzer,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A handy class that can scrub over a scene graph and collect interesting\n"
    " * statistics on it.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SceneGraphAnalyzer,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SceneGraphAnalyzer,
    PyType_GenericAlloc,
    Dtool_new_SceneGraphAnalyzer,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SceneGraphAnalyzer,
  Dtool_UpcastInterface_SceneGraphAnalyzer,
  Dtool_DowncastInterface_SceneGraphAnalyzer,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_SceneGraphAnalyzer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_SceneGraphAnalyzer._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_SceneGraphAnalyzer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum SceneGraphAnalyzer::LodMode;
    PyDict_SetItemString(dict, "LM_lowest", Dtool_WrapValue(SceneGraphAnalyzer::LM_lowest));
    PyDict_SetItemString(dict, "LMLowest", Dtool_WrapValue(SceneGraphAnalyzer::LM_lowest));
    PyDict_SetItemString(dict, "LM_highest", Dtool_WrapValue(SceneGraphAnalyzer::LM_highest));
    PyDict_SetItemString(dict, "LMHighest", Dtool_WrapValue(SceneGraphAnalyzer::LM_highest));
    PyDict_SetItemString(dict, "LM_all", Dtool_WrapValue(SceneGraphAnalyzer::LM_all));
    PyDict_SetItemString(dict, "LMAll", Dtool_WrapValue(SceneGraphAnalyzer::LM_all));
    PyDict_SetItemString(dict, "LM_none", Dtool_WrapValue(SceneGraphAnalyzer::LM_none));
    PyDict_SetItemString(dict, "LMNone", Dtool_WrapValue(SceneGraphAnalyzer::LM_none));
    if (PyType_Ready((PyTypeObject *)&Dtool_SceneGraphAnalyzer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SceneGraphAnalyzer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SceneGraphAnalyzer);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3pgraphnodes_RegisterTypes() {
  Dtool_LightNode._type = LightNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LightNode);
  Dtool_AmbientLight._type = AmbientLight::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AmbientLight);
  Dtool_CallbackNode._type = CallbackNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CallbackNode);
  Dtool_ComputeNode._type = ComputeNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ComputeNode);
  Dtool_LightLensNode._type = LightLensNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LightLensNode);
  Dtool_DirectionalLight._type = DirectionalLight::get_class_type();
  RegisterRuntimeTypedClass(Dtool_DirectionalLight);
  Dtool_LODNode._type = LODNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LODNode);
  Dtool_FadeLODNode._type = FadeLODNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_FadeLODNode);
  Dtool_NodeCullCallbackData._type = NodeCullCallbackData::get_class_type();
  RegisterRuntimeTypedClass(Dtool_NodeCullCallbackData);
  Dtool_PointLight._type = PointLight::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PointLight);
  Dtool_SelectiveChildNode._type = SelectiveChildNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_SelectiveChildNode);
  Dtool_SequenceNode._type = SequenceNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_SequenceNode);
  Dtool_ShaderGenerator._type = ShaderGenerator::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ShaderGenerator);
  Dtool_SphereLight._type = SphereLight::get_class_type();
  RegisterRuntimeTypedClass(Dtool_SphereLight);
  Dtool_Spotlight._type = Spotlight::get_class_type();
  RegisterRuntimeTypedClass(Dtool_Spotlight);
  Dtool_SwitchNode._type = SwitchNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_SwitchNode);
  Dtool_UvScrollNode._type = UvScrollNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_UvScrollNode);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("SceneGraphAnalyzer", Dtool_SceneGraphAnalyzer);
#endif
}

void Dtool_libp3pgraphnodes_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_LVecBase2i = LookupRuntimeTypedClass(LVecBase2i::get_class_type());
  Dtool_Ptr_LVecBase3f = LookupRuntimeTypedClass(LVecBase3f::get_class_type());
  Dtool_Ptr_LVecBase3i = LookupRuntimeTypedClass(LVecBase3i::get_class_type());
  Dtool_Ptr_LVector3f = LookupRuntimeTypedClass(LVector3f::get_class_type());
  Dtool_Ptr_LPoint3f = LookupRuntimeTypedClass(LPoint3f::get_class_type());
  Dtool_Ptr_LVecBase4f = LookupRuntimeTypedClass(LVecBase4f::get_class_type());
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_TypedWritableReferenceCount = LookupRuntimeTypedClass(TypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_TypedWritable = LookupRuntimeTypedClass(TypedWritable::get_class_type());
  Dtool_Ptr_GeomVertexAnimationSpec = LookupNamedClass("GeomVertexAnimationSpec");
  Dtool_Ptr_GraphicsStateGuardianBase = LookupRuntimeTypedClass(GraphicsStateGuardianBase::get_class_type());
  Dtool_Ptr_RenderState = LookupRuntimeTypedClass(RenderState::get_class_type());
  Dtool_Ptr_PandaNode = LookupRuntimeTypedClass(PandaNode::get_class_type());
  Dtool_Ptr_Light = LookupRuntimeTypedClass(Light::get_class_type());
  Dtool_Ptr_CallbackObject = LookupRuntimeTypedClass(CallbackObject::get_class_type());
  Dtool_Ptr_LensNode = LookupRuntimeTypedClass(LensNode::get_class_type());
  Dtool_Ptr_Texture = LookupRuntimeTypedClass(Texture::get_class_type());
  Dtool_Ptr_CallbackData = LookupRuntimeTypedClass(CallbackData::get_class_type());
  Dtool_Ptr_CullTraverser = LookupRuntimeTypedClass(CullTraverser::get_class_type());
  Dtool_Ptr_CullTraverserData = LookupNamedClass("CullTraverserData");
  Dtool_Ptr_AnimInterface = LookupRuntimeTypedClass(AnimInterface::get_class_type());
  Dtool_Ptr_ShaderAttrib = LookupRuntimeTypedClass(ShaderAttrib::get_class_type());
  Dtool_Ptr_Camera = LookupRuntimeTypedClass(Camera::get_class_type());
  Dtool_Ptr_GraphicsOutputBase = LookupRuntimeTypedClass(GraphicsOutputBase::get_class_type());
#endif
}

void Dtool_libp3pgraphnodes_BuildInstants(PyObject *module) {
  (void) module;
  // enum LODNodeType
  PyModule_AddObject(module, "LNT_pop", Dtool_WrapValue(::LNT_pop));
  PyModule_AddObject(module, "LNTPop", Dtool_WrapValue(::LNT_pop));
  PyModule_AddObject(module, "LNT_fade", Dtool_WrapValue(::LNT_fade));
  PyModule_AddObject(module, "LNTFade", Dtool_WrapValue(::LNT_fade));
  // LightNode
  Dtool_PyModuleClassInit_LightNode(module);
  PyModule_AddObject(module, "LightNode", (PyObject *)&Dtool_LightNode);
  // AmbientLight
  Dtool_PyModuleClassInit_AmbientLight(module);
  PyModule_AddObject(module, "AmbientLight", (PyObject *)&Dtool_AmbientLight);
  // CallbackNode
  Dtool_PyModuleClassInit_CallbackNode(module);
  PyModule_AddObject(module, "CallbackNode", (PyObject *)&Dtool_CallbackNode);
  // ComputeNode
  Dtool_PyModuleClassInit_ComputeNode(module);
  PyModule_AddObject(module, "ComputeNode", (PyObject *)&Dtool_ComputeNode);
  // LightLensNode
  Dtool_PyModuleClassInit_LightLensNode(module);
  PyModule_AddObject(module, "LightLensNode", (PyObject *)&Dtool_LightLensNode);
  // DirectionalLight
  Dtool_PyModuleClassInit_DirectionalLight(module);
  PyModule_AddObject(module, "DirectionalLight", (PyObject *)&Dtool_DirectionalLight);
  // LODNode
  Dtool_PyModuleClassInit_LODNode(module);
  PyModule_AddObject(module, "LODNode", (PyObject *)&Dtool_LODNode);
  // FadeLODNode
  Dtool_PyModuleClassInit_FadeLODNode(module);
  PyModule_AddObject(module, "FadeLODNode", (PyObject *)&Dtool_FadeLODNode);
  // NodeCullCallbackData
  Dtool_PyModuleClassInit_NodeCullCallbackData(module);
  PyModule_AddObject(module, "NodeCullCallbackData", (PyObject *)&Dtool_NodeCullCallbackData);
  // PointLight
  Dtool_PyModuleClassInit_PointLight(module);
  PyModule_AddObject(module, "PointLight", (PyObject *)&Dtool_PointLight);
  // SelectiveChildNode
  Dtool_PyModuleClassInit_SelectiveChildNode(module);
  PyModule_AddObject(module, "SelectiveChildNode", (PyObject *)&Dtool_SelectiveChildNode);
  // SequenceNode
  Dtool_PyModuleClassInit_SequenceNode(module);
  PyModule_AddObject(module, "SequenceNode", (PyObject *)&Dtool_SequenceNode);
  // ShaderGenerator
  Dtool_PyModuleClassInit_ShaderGenerator(module);
  PyModule_AddObject(module, "ShaderGenerator", (PyObject *)&Dtool_ShaderGenerator);
  // SphereLight
  Dtool_PyModuleClassInit_SphereLight(module);
  PyModule_AddObject(module, "SphereLight", (PyObject *)&Dtool_SphereLight);
  // Spotlight
  Dtool_PyModuleClassInit_Spotlight(module);
  PyModule_AddObject(module, "Spotlight", (PyObject *)&Dtool_Spotlight);
  // SwitchNode
  Dtool_PyModuleClassInit_SwitchNode(module);
  PyModule_AddObject(module, "SwitchNode", (PyObject *)&Dtool_SwitchNode);
  // UvScrollNode
  Dtool_PyModuleClassInit_UvScrollNode(module);
  PyModule_AddObject(module, "UvScrollNode", (PyObject *)&Dtool_UvScrollNode);
  // SceneGraphAnalyzer
  Dtool_PyModuleClassInit_SceneGraphAnalyzer(module);
  PyModule_AddObject(module, "SceneGraphAnalyzer", (PyObject *)&Dtool_SceneGraphAnalyzer);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3pgraphnodes_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478211511,  /* file_identifier */
  "libp3pgraphnodes",  /* library_name */
  "Bgt0",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3pgraphnodes.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  541  /* next_index */
};

Configure(_in_configure_libp3pgraphnodes);
ConfigureFn(_in_configure_libp3pgraphnodes) {
  interrogate_request_module(&_in_module_def);
}

