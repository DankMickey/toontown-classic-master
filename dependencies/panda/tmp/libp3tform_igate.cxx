/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/tform -Ipanda/src/tform -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3tform_igate.cxx -od built/pandac/input/libp3tform.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/tform -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3tform buttonThrower.h config_tform.h driveInterface.h mouseInterfaceNode.h mouseSubregion.h mouseWatcher.h mouseWatcherBase.h mouseWatcherGroup.h mouseWatcherParameter.h mouseWatcherRegion.h p3tform_composite1.cxx p3tform_composite2.cxx trackball.h transform2sg.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3tform
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "bitArray.h"
#include "buttonEventList.h"
#include "buttonHandle.h"
#include "buttonThrower.h"
#include "clockObject.h"
#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "config_tform.h"
#include "dataNode.h"
#include "displayRegion.h"
#include "driveInterface.h"
#include "eventHandler.h"
#include "eventParameter.h"
#include "linmath_events.h"
#include "luse.h"
#include "modifierButtons.h"
#include "mouseInterfaceNode.h"
#include "mouseSubregion.h"
#include "mouseWatcher.h"
#include "mouseWatcherBase.h"
#include "mouseWatcherGroup.h"
#include "mouseWatcherParameter.h"
#include "mouseWatcherRegion.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "pmap.h"
#include "pointerEvent.h"
#include "pointerEventList.h"
#include "pointerTo.h"
#include "pvector.h"
#include "textEncoder.h"
#include "trackball.h"
#include "transform2sg.h"
#include "transformState.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class ButtonThrower
 */
typedef ButtonThrower ButtonThrower_localtype;
Define_Module_ClassRef(panda3d.core, ButtonThrower, ButtonThrower_localtype, ButtonThrower);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ButtonThrower = &Dtool_ButtonThrower;
static void Dtool_PyModuleClassInit_ButtonThrower(PyObject *module);
bool Dtool_ConstCoerce_ButtonThrower(PyObject *args, CPT(ButtonThrower) &coerced);
bool Dtool_Coerce_ButtonThrower(PyObject *args, PT(ButtonThrower) &coerced);

/**
 * Forward declarations for top-level class MouseInterfaceNode
 */
typedef MouseInterfaceNode MouseInterfaceNode_localtype;
Define_Module_ClassRef(panda3d.core, MouseInterfaceNode, MouseInterfaceNode_localtype, MouseInterfaceNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MouseInterfaceNode = &Dtool_MouseInterfaceNode;
static void Dtool_PyModuleClassInit_MouseInterfaceNode(PyObject *module);

/**
 * Forward declarations for top-level class DriveInterface
 */
typedef DriveInterface DriveInterface_localtype;
Define_Module_ClassRef(panda3d.core, DriveInterface, DriveInterface_localtype, DriveInterface);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DriveInterface = &Dtool_DriveInterface;
static void Dtool_PyModuleClassInit_DriveInterface(PyObject *module);
bool Dtool_ConstCoerce_DriveInterface(PyObject *args, CPT(DriveInterface) &coerced);
bool Dtool_Coerce_DriveInterface(PyObject *args, PT(DriveInterface) &coerced);

/**
 * Forward declarations for top-level class MouseSubregion
 */
typedef MouseSubregion MouseSubregion_localtype;
Define_Module_ClassRef(panda3d.core, MouseSubregion, MouseSubregion_localtype, MouseSubregion);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MouseSubregion = &Dtool_MouseSubregion;
static void Dtool_PyModuleClassInit_MouseSubregion(PyObject *module);
bool Dtool_ConstCoerce_MouseSubregion(PyObject *args, CPT(MouseSubregion) &coerced);
bool Dtool_Coerce_MouseSubregion(PyObject *args, PT(MouseSubregion) &coerced);

/**
 * Forward declarations for top-level class MouseWatcherRegion
 */
typedef MouseWatcherRegion MouseWatcherRegion_localtype;
Define_Module_ClassRef(panda3d.core, MouseWatcherRegion, MouseWatcherRegion_localtype, MouseWatcherRegion);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MouseWatcherRegion = &Dtool_MouseWatcherRegion;
static void Dtool_PyModuleClassInit_MouseWatcherRegion(PyObject *module);
bool Dtool_ConstCoerce_MouseWatcherRegion(PyObject *args, CPT(MouseWatcherRegion) &coerced);
bool Dtool_Coerce_MouseWatcherRegion(PyObject *args, PT(MouseWatcherRegion) &coerced);

/**
 * Forward declarations for top-level class MouseWatcherBase
 */
typedef MouseWatcherBase MouseWatcherBase_localtype;
Define_Module_Class(panda3d.core, MouseWatcherBase, MouseWatcherBase_localtype, MouseWatcherBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MouseWatcherBase = &Dtool_MouseWatcherBase;
static void Dtool_PyModuleClassInit_MouseWatcherBase(PyObject *module);

/**
 * Forward declarations for top-level class MouseWatcherGroup
 */
typedef MouseWatcherGroup MouseWatcherGroup_localtype;
Define_Module_ClassRef(panda3d.core, MouseWatcherGroup, MouseWatcherGroup_localtype, MouseWatcherGroup);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MouseWatcherGroup = &Dtool_MouseWatcherGroup;
static void Dtool_PyModuleClassInit_MouseWatcherGroup(PyObject *module);

/**
 * Forward declarations for top-level class MouseWatcher
 */
typedef MouseWatcher MouseWatcher_localtype;
Define_Module_ClassRef(panda3d.core, MouseWatcher, MouseWatcher_localtype, MouseWatcher);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MouseWatcher = &Dtool_MouseWatcher;
static void Dtool_PyModuleClassInit_MouseWatcher(PyObject *module);
bool Dtool_ConstCoerce_MouseWatcher(PyObject *args, CPT(MouseWatcher) &coerced);
bool Dtool_Coerce_MouseWatcher(PyObject *args, PT(MouseWatcher) &coerced);

/**
 * Forward declarations for top-level class MouseWatcherParameter
 */
typedef MouseWatcherParameter MouseWatcherParameter_localtype;
Define_Module_Class(panda3d.core, MouseWatcherParameter, MouseWatcherParameter_localtype, MouseWatcherParameter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MouseWatcherParameter = &Dtool_MouseWatcherParameter;
static void Dtool_PyModuleClassInit_MouseWatcherParameter(PyObject *module);

/**
 * Forward declarations for top-level class Trackball
 */
typedef Trackball Trackball_localtype;
Define_Module_ClassRef(panda3d.core, Trackball, Trackball_localtype, Trackball);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Trackball = &Dtool_Trackball;
static void Dtool_PyModuleClassInit_Trackball(PyObject *module);
bool Dtool_ConstCoerce_Trackball(PyObject *args, CPT(Trackball) &coerced);
bool Dtool_Coerce_Trackball(PyObject *args, PT(Trackball) &coerced);

/**
 * Forward declarations for top-level class Transform2SG
 */
typedef Transform2SG Transform2SG_localtype;
Define_Module_ClassRef(panda3d.core, Transform2SG, Transform2SG_localtype, Transform2SG);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Transform2SG = &Dtool_Transform2SG;
static void Dtool_PyModuleClassInit_Transform2SG(PyObject *module);
bool Dtool_ConstCoerce_Transform2SG(PyObject *args, CPT(Transform2SG) &coerced);
bool Dtool_Coerce_Transform2SG(PyObject *args, PT(Transform2SG) &coerced);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritable;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4f;
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LPoint2f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint2f;
inline static LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced) {
  nassertr(Dtool_Ptr_LPoint2f != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint2f->_Dtool_Coerce != NULL, NULL);
  return ((LPoint2f *(*)(PyObject *, LPoint2f &))Dtool_Ptr_LPoint2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2f = &Dtool_LPoint2f;
extern LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint3f;
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != NULL, NULL);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3f;
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix4f;
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// EventParameter
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_EventParameter;
inline static bool Dtool_ConstCoerce_EventParameter(PyObject *args, EventParameter const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_EventParameter != NULL, false);
  nassertr(Dtool_Ptr_EventParameter->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, EventParameter const *&, bool&))Dtool_Ptr_EventParameter->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_EventParameter(PyObject *args, EventParameter *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_EventParameter != NULL, false);
  nassertr(Dtool_Ptr_EventParameter->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, EventParameter *&, bool&))Dtool_Ptr_EventParameter->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_EventParameter;
static struct Dtool_PyTypedObject *const Dtool_Ptr_EventParameter = &Dtool_EventParameter;
extern bool Dtool_ConstCoerce_EventParameter(PyObject *args, EventParameter const *&coerced, bool &manage);
extern bool Dtool_Coerce_EventParameter(PyObject *args, EventParameter *&coerced, bool &manage);
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PandaNode;
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// DataNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_DataNode;
inline static bool Dtool_ConstCoerce_DataNode(PyObject *args, CPT(DataNode) &coerced) {
  nassertr(Dtool_Ptr_DataNode != NULL, false);
  nassertr(Dtool_Ptr_DataNode->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(DataNode) &))Dtool_Ptr_DataNode->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_DataNode(PyObject *args, PT(DataNode) &coerced) {
  nassertr(Dtool_Ptr_DataNode != NULL, false);
  nassertr(Dtool_Ptr_DataNode->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(DataNode) &))Dtool_Ptr_DataNode->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_DataNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DataNode = &Dtool_DataNode;
extern bool Dtool_ConstCoerce_DataNode(PyObject *args, CPT(DataNode) &coerced);
extern bool Dtool_Coerce_DataNode(PyObject *args, PT(DataNode) &coerced);
#endif
// ModifierButtons
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ModifierButtons;
#else
extern struct Dtool_PyTypedObject Dtool_ModifierButtons;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ModifierButtons = &Dtool_ModifierButtons;
#endif
// ButtonHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ButtonHandle;
inline static ButtonHandle *Dtool_Coerce_ButtonHandle(PyObject *args, ButtonHandle &coerced) {
  nassertr(Dtool_Ptr_ButtonHandle != NULL, NULL);
  nassertr(Dtool_Ptr_ButtonHandle->_Dtool_Coerce != NULL, NULL);
  return ((ButtonHandle *(*)(PyObject *, ButtonHandle &))Dtool_Ptr_ButtonHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_ButtonHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ButtonHandle = &Dtool_ButtonHandle;
extern ButtonHandle *Dtool_Coerce_ButtonHandle(PyObject *args, ButtonHandle &coerced);
#endif
// NodePath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePath;
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// EventHandler
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_EventHandler;
inline static bool Dtool_ConstCoerce_EventHandler(PyObject *args, EventHandler const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_EventHandler != NULL, false);
  nassertr(Dtool_Ptr_EventHandler->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, EventHandler const *&, bool&))Dtool_Ptr_EventHandler->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_EventHandler(PyObject *args, EventHandler *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_EventHandler != NULL, false);
  nassertr(Dtool_Ptr_EventHandler->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, EventHandler *&, bool&))Dtool_Ptr_EventHandler->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_EventHandler;
static struct Dtool_PyTypedObject *const Dtool_Ptr_EventHandler = &Dtool_EventHandler;
extern bool Dtool_ConstCoerce_EventHandler(PyObject *args, EventHandler const *&coerced, bool &manage);
extern bool Dtool_Coerce_EventHandler(PyObject *args, EventHandler *&coerced, bool &manage);
#endif
// PointerEventList
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PointerEventList;
#else
extern struct Dtool_PyTypedObject Dtool_PointerEventList;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerEventList = &Dtool_PointerEventList;
#endif
// GeomNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GeomNode;
#else
extern struct Dtool_PyTypedObject Dtool_GeomNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomNode = &Dtool_GeomNode;
#endif
// DisplayRegion
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_DisplayRegion;
#else
extern struct Dtool_PyTypedObject Dtool_DisplayRegion;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DisplayRegion = &Dtool_DisplayRegion;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class ButtonThrower
 */
/**
 * Python function wrapper for:
 * inline void ButtonThrower::set_button_down_event(std::string const &button_down_event)
 */
static PyObject *Dtool_ButtonThrower_set_button_down_event_4(PyObject *self, PyObject *arg) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.set_button_down_event")) {
    return NULL;
  }
  // 1-inline void ButtonThrower::set_button_down_event(std::string const &button_down_event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_button_down_event(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_button_down_event(const ButtonThrower self, str button_down_event)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_set_button_down_event_4_comment =
  "C++ Interface:\n"
  "set_button_down_event(const ButtonThrower self, str button_down_event)\n"
  "\n"
  "/**\n"
  " * Specifies the generic event that is generated (if any) each time a key or\n"
  " * button is depressed.  Unlike the specific events that are unique to each\n"
  " * key, this same event name is used for *all* button events, and the name of\n"
  " * the button pressed (possibly with modifier prefixes) will be sent as a\n"
  " * parameter.\n"
  " *\n"
  " * If this string is empty, no event is generated.  It is possible to generate\n"
  " * both generic events and specific events for the same button.\n"
  " *\n"
  " * See also set_keystroke_event().\n"
  " */";
#else
static const char *Dtool_ButtonThrower_set_button_down_event_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ButtonThrower::get_button_down_event(void) const
 */
static PyObject *Dtool_ButtonThrower_get_button_down_event_5(PyObject *self, PyObject *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &ButtonThrower::get_button_down_event(void) const
  std::string const &return_value = (*(const ButtonThrower*)local_this).get_button_down_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_get_button_down_event_5_comment =
  "C++ Interface:\n"
  "get_button_down_event(ButtonThrower self)\n"
  "\n"
  "/**\n"
  " * Returns the button_down_event that has been set on this ButtonThrower.  See\n"
  " * set_button_down_event().\n"
  " */";
#else
static const char *Dtool_ButtonThrower_get_button_down_event_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ButtonThrower::set_button_up_event(std::string const &button_up_event)
 */
static PyObject *Dtool_ButtonThrower_set_button_up_event_6(PyObject *self, PyObject *arg) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.set_button_up_event")) {
    return NULL;
  }
  // 1-inline void ButtonThrower::set_button_up_event(std::string const &button_up_event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_button_up_event(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_button_up_event(const ButtonThrower self, str button_up_event)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_set_button_up_event_6_comment =
  "C++ Interface:\n"
  "set_button_up_event(const ButtonThrower self, str button_up_event)\n"
  "\n"
  "/**\n"
  " * Specifies the generic event that is generated (if any) each time a key or\n"
  " * button is released.  See set_button_down_event().\n"
  " */";
#else
static const char *Dtool_ButtonThrower_set_button_up_event_6_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ButtonThrower::get_button_up_event(void) const
 */
static PyObject *Dtool_ButtonThrower_get_button_up_event_7(PyObject *self, PyObject *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &ButtonThrower::get_button_up_event(void) const
  std::string const &return_value = (*(const ButtonThrower*)local_this).get_button_up_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_get_button_up_event_7_comment =
  "C++ Interface:\n"
  "get_button_up_event(ButtonThrower self)\n"
  "\n"
  "/**\n"
  " * Returns the button_up_event that has been set on this ButtonThrower.  See\n"
  " * set_button_up_event().\n"
  " */";
#else
static const char *Dtool_ButtonThrower_get_button_up_event_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ButtonThrower::set_button_repeat_event(std::string const &button_repeat_event)
 */
static PyObject *Dtool_ButtonThrower_set_button_repeat_event_8(PyObject *self, PyObject *arg) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.set_button_repeat_event")) {
    return NULL;
  }
  // 1-inline void ButtonThrower::set_button_repeat_event(std::string const &button_repeat_event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_button_repeat_event(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_button_repeat_event(const ButtonThrower self, str button_repeat_event)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_set_button_repeat_event_8_comment =
  "C++ Interface:\n"
  "set_button_repeat_event(const ButtonThrower self, str button_repeat_event)\n"
  "\n"
  "/**\n"
  " * Specifies the generic event that is generated (if any) repeatedly while a\n"
  " * key or button is held down.  Unlike the specific events that are unique to\n"
  " * each key, this same event name is used for *all* button events, and the\n"
  " * name of the button pressed (possibly with modifier prefixes) will be sent\n"
  " * as a parameter.\n"
  " *\n"
  " * If this string is empty, no event is generated.  It is possible to generate\n"
  " * both generic events and specific events for the same button.\n"
  " *\n"
  " * See also set_keystroke_event().\n"
  " */";
#else
static const char *Dtool_ButtonThrower_set_button_repeat_event_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ButtonThrower::get_button_repeat_event(void) const
 */
static PyObject *Dtool_ButtonThrower_get_button_repeat_event_9(PyObject *self, PyObject *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &ButtonThrower::get_button_repeat_event(void) const
  std::string const &return_value = (*(const ButtonThrower*)local_this).get_button_repeat_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_get_button_repeat_event_9_comment =
  "C++ Interface:\n"
  "get_button_repeat_event(ButtonThrower self)\n"
  "\n"
  "/**\n"
  " * Returns the button_repeat_event that has been set on this ButtonThrower.\n"
  " * See set_button_repeat_event().\n"
  " */";
#else
static const char *Dtool_ButtonThrower_get_button_repeat_event_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ButtonThrower::set_keystroke_event(std::string const &keystroke_event)
 */
static PyObject *Dtool_ButtonThrower_set_keystroke_event_10(PyObject *self, PyObject *arg) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.set_keystroke_event")) {
    return NULL;
  }
  // 1-inline void ButtonThrower::set_keystroke_event(std::string const &keystroke_event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_keystroke_event(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_keystroke_event(const ButtonThrower self, str keystroke_event)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_set_keystroke_event_10_comment =
  "C++ Interface:\n"
  "set_keystroke_event(const ButtonThrower self, str keystroke_event)\n"
  "\n"
  "/**\n"
  " * Specifies the event that is generated (if any) for each keystroke that is\n"
  " * received.  A keystroke is different than a button event: it represents the\n"
  " * semantic meaning of the sequence of keys that have been pressed.  For\n"
  " * instance, pressing shift and 4 together will generate the button event\n"
  " * \"shift-4\", but it will generate the keystroke \"$\".\n"
  " *\n"
  " * If a key is held down, keyrepeat will cause the same keystroke event to be\n"
  " * generated repeatedly.  This is different from the corresponding down event,\n"
  " * which will only be generated once, followed by a number of button repeat\n"
  " * events.\n"
  " *\n"
  " * This event is generated with a single wstring parameter, which is a one-\n"
  " * character string that contains the keystroke generated.  If this event\n"
  " * string is empty, no event is generated.\n"
  " *\n"
  " * See also set_button_down_event().\n"
  " */";
#else
static const char *Dtool_ButtonThrower_set_keystroke_event_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ButtonThrower::get_keystroke_event(void) const
 */
static PyObject *Dtool_ButtonThrower_get_keystroke_event_11(PyObject *self, PyObject *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &ButtonThrower::get_keystroke_event(void) const
  std::string const &return_value = (*(const ButtonThrower*)local_this).get_keystroke_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_get_keystroke_event_11_comment =
  "C++ Interface:\n"
  "get_keystroke_event(ButtonThrower self)\n"
  "\n"
  "/**\n"
  " * Returns the keystroke_event that has been set on this ButtonThrower.  See\n"
  " * set_keystroke_event().\n"
  " */";
#else
static const char *Dtool_ButtonThrower_get_keystroke_event_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ButtonThrower::set_candidate_event(std::string const &candidate_event)
 */
static PyObject *Dtool_ButtonThrower_set_candidate_event_12(PyObject *self, PyObject *arg) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.set_candidate_event")) {
    return NULL;
  }
  // 1-inline void ButtonThrower::set_candidate_event(std::string const &candidate_event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_candidate_event(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_candidate_event(const ButtonThrower self, str candidate_event)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_set_candidate_event_12_comment =
  "C++ Interface:\n"
  "set_candidate_event(const ButtonThrower self, str candidate_event)\n"
  "\n"
  "/**\n"
  " * Specifies the event that is generated (if any) for each IME candidate\n"
  " * string event received.  Events of this nature are received only when the\n"
  " * user is entering data using a Microsoft Input Method Editor, typically used\n"
  " * for Asian languages such as Japanese or Korean.\n"
  " *\n"
  " * If you are designing a typing user interface, you should track this event\n"
  " * to support the use of the IME.  In response to this event, you should\n"
  " * display the candidate string in the entry box, with the appropriate\n"
  " * sections highlighted, so the user can scroll through the available choices.\n"
  " *\n"
  " * This event is generated with four parameters, in order: the candidate\n"
  " * string, the character at which to start the highlight, the character at\n"
  " * which to end the highlight, and the current cursor position.\n"
  " */";
#else
static const char *Dtool_ButtonThrower_set_candidate_event_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ButtonThrower::get_candidate_event(void) const
 */
static PyObject *Dtool_ButtonThrower_get_candidate_event_13(PyObject *self, PyObject *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &ButtonThrower::get_candidate_event(void) const
  std::string const &return_value = (*(const ButtonThrower*)local_this).get_candidate_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_get_candidate_event_13_comment =
  "C++ Interface:\n"
  "get_candidate_event(ButtonThrower self)\n"
  "\n"
  "/**\n"
  " * Returns the candidate_event that has been set on this ButtonThrower.  See\n"
  " * set_candidate_event().\n"
  " */";
#else
static const char *Dtool_ButtonThrower_get_candidate_event_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ButtonThrower::set_move_event(std::string const &move_event)
 */
static PyObject *Dtool_ButtonThrower_set_move_event_14(PyObject *self, PyObject *arg) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.set_move_event")) {
    return NULL;
  }
  // 1-inline void ButtonThrower::set_move_event(std::string const &move_event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_move_event(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_move_event(const ButtonThrower self, str move_event)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_set_move_event_14_comment =
  "C++ Interface:\n"
  "set_move_event(const ButtonThrower self, str move_event)\n"
  "\n"
  "/**\n"
  " * Specifies the event that is generated (if any) each time the mouse is moved\n"
  " * within the window.\n"
  " */";
#else
static const char *Dtool_ButtonThrower_set_move_event_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ButtonThrower::get_move_event(void) const
 */
static PyObject *Dtool_ButtonThrower_get_move_event_15(PyObject *self, PyObject *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &ButtonThrower::get_move_event(void) const
  std::string const &return_value = (*(const ButtonThrower*)local_this).get_move_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_get_move_event_15_comment =
  "C++ Interface:\n"
  "get_move_event(ButtonThrower self)\n"
  "\n"
  "/**\n"
  " * Returns the move_event that has been set on this ButtonThrower.  See\n"
  " * set_move_event().\n"
  " */";
#else
static const char *Dtool_ButtonThrower_get_move_event_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ButtonThrower::set_raw_button_down_event(std::string const &raw_button_down_event)
 */
static PyObject *Dtool_ButtonThrower_set_raw_button_down_event_16(PyObject *self, PyObject *arg) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.set_raw_button_down_event")) {
    return NULL;
  }
  // 1-inline void ButtonThrower::set_raw_button_down_event(std::string const &raw_button_down_event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_raw_button_down_event(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_raw_button_down_event(const ButtonThrower self, str raw_button_down_event)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_set_raw_button_down_event_16_comment =
  "C++ Interface:\n"
  "set_raw_button_down_event(const ButtonThrower self, str raw_button_down_event)\n"
  "\n"
  "/**\n"
  " * Like set_button_down_event, but uses the raw, untransformed scan key from\n"
  " * the operating system.  This uses buttons that are independent of the user's\n"
  " * selected keyboard layout.\n"
  " */";
#else
static const char *Dtool_ButtonThrower_set_raw_button_down_event_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ButtonThrower::get_raw_button_down_event(void) const
 */
static PyObject *Dtool_ButtonThrower_get_raw_button_down_event_17(PyObject *self, PyObject *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &ButtonThrower::get_raw_button_down_event(void) const
  std::string const &return_value = (*(const ButtonThrower*)local_this).get_raw_button_down_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_get_raw_button_down_event_17_comment =
  "C++ Interface:\n"
  "get_raw_button_down_event(ButtonThrower self)\n"
  "\n"
  "/**\n"
  " * Returns the raw_button_down_event that has been set on this ButtonThrower.\n"
  " * See set_raw_button_down_event().\n"
  " */";
#else
static const char *Dtool_ButtonThrower_get_raw_button_down_event_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ButtonThrower::set_raw_button_up_event(std::string const &raw_button_up_event)
 */
static PyObject *Dtool_ButtonThrower_set_raw_button_up_event_18(PyObject *self, PyObject *arg) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.set_raw_button_up_event")) {
    return NULL;
  }
  // 1-inline void ButtonThrower::set_raw_button_up_event(std::string const &raw_button_up_event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_raw_button_up_event(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_raw_button_up_event(const ButtonThrower self, str raw_button_up_event)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_set_raw_button_up_event_18_comment =
  "C++ Interface:\n"
  "set_raw_button_up_event(const ButtonThrower self, str raw_button_up_event)\n"
  "\n"
  "/**\n"
  " * Specifies the generic event that is generated (if any) each time a key or\n"
  " * button is released.  See set_raw_button_down_event().\n"
  " */";
#else
static const char *Dtool_ButtonThrower_set_raw_button_up_event_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ButtonThrower::get_raw_button_up_event(void) const
 */
static PyObject *Dtool_ButtonThrower_get_raw_button_up_event_19(PyObject *self, PyObject *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &ButtonThrower::get_raw_button_up_event(void) const
  std::string const &return_value = (*(const ButtonThrower*)local_this).get_raw_button_up_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_get_raw_button_up_event_19_comment =
  "C++ Interface:\n"
  "get_raw_button_up_event(ButtonThrower self)\n"
  "\n"
  "/**\n"
  " * Returns the raw_button_up_event that has been set on this ButtonThrower.\n"
  " * See set_raw_button_up_event().\n"
  " */";
#else
static const char *Dtool_ButtonThrower_get_raw_button_up_event_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ButtonThrower::set_prefix(std::string const &prefix)
 */
static PyObject *Dtool_ButtonThrower_set_prefix_31(PyObject *self, PyObject *arg) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.set_prefix")) {
    return NULL;
  }
  // 1-inline void ButtonThrower::set_prefix(std::string const &prefix)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_prefix(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_prefix(const ButtonThrower self, str prefix)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_set_prefix_31_comment =
  "C++ Interface:\n"
  "set_prefix(const ButtonThrower self, str prefix)\n"
  "\n"
  "/**\n"
  " * Sets the prefix which is prepended to all specific event names (that is,\n"
  " * event names generated from the button name itself, as opposed to the\n"
  " * generic event names like set_button_down_event) thrown by this object.\n"
  " */";
#else
static const char *Dtool_ButtonThrower_set_prefix_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ButtonThrower::get_prefix(void) const
 */
static PyObject *Dtool_ButtonThrower_get_prefix_32(PyObject *self, PyObject *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &ButtonThrower::get_prefix(void) const
  std::string const &return_value = (*(const ButtonThrower*)local_this).get_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_get_prefix_32_comment =
  "C++ Interface:\n"
  "get_prefix(ButtonThrower self)\n"
  "\n"
  "/**\n"
  " * Returns the prefix that has been set on this ButtonThrower.  See\n"
  " * set_prefix().\n"
  " */";
#else
static const char *Dtool_ButtonThrower_get_prefix_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ButtonThrower::set_specific_flag(bool specific_flag)
 */
static PyObject *Dtool_ButtonThrower_set_specific_flag_33(PyObject *self, PyObject *arg) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.set_specific_flag")) {
    return NULL;
  }
  // 1-inline void ButtonThrower::set_specific_flag(bool specific_flag)
  (*local_this).set_specific_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_specific_flag(const ButtonThrower self, bool specific_flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_set_specific_flag_33_comment =
  "C++ Interface:\n"
  "set_specific_flag(const ButtonThrower self, bool specific_flag)\n"
  "\n"
  "/**\n"
  " * Sets the flag that indicates whether specific events (events prefixed by\n"
  " * set_prefix, and based on the event name) should be generated at all.  This\n"
  " * is true by default, but may be disabled if you are only interested in the\n"
  " * generic events (for instance, events like set_button_down_event).\n"
  " */";
#else
static const char *Dtool_ButtonThrower_set_specific_flag_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ButtonThrower::get_specific_flag(void) const
 */
static PyObject *Dtool_ButtonThrower_get_specific_flag_34(PyObject *self, PyObject *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ButtonThrower::get_specific_flag(void) const
  bool return_value = (*(const ButtonThrower*)local_this).get_specific_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_get_specific_flag_34_comment =
  "C++ Interface:\n"
  "get_specific_flag(ButtonThrower self)\n"
  "\n"
  "/**\n"
  " * Returns the flag that indicates whether specific events should be\n"
  " * generated.  See set_specific_flag().\n"
  " */";
#else
static const char *Dtool_ButtonThrower_get_specific_flag_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ButtonThrower::set_time_flag(bool time_flag)
 */
static PyObject *Dtool_ButtonThrower_set_time_flag_38(PyObject *self, PyObject *arg) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.set_time_flag")) {
    return NULL;
  }
  // 1-inline void ButtonThrower::set_time_flag(bool time_flag)
  (*local_this).set_time_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_time_flag(const ButtonThrower self, bool time_flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_set_time_flag_38_comment =
  "C++ Interface:\n"
  "set_time_flag(const ButtonThrower self, bool time_flag)\n"
  "\n"
  "/**\n"
  " * Sets the flag that indicates whether the time of the button event should be\n"
  " * passed as a parameter or not.  When this is true, an additional parameter\n"
  " * is generated on each event (before all the parameters named by\n"
  " * add_parameter) that consists of a single double value, and reflects the\n"
  " * time the button was pressed or released, as a value from\n"
  " * ClockObject::get_global_clock().\n"
  " */";
#else
static const char *Dtool_ButtonThrower_set_time_flag_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ButtonThrower::get_time_flag(void) const
 */
static PyObject *Dtool_ButtonThrower_get_time_flag_39(PyObject *self, PyObject *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ButtonThrower::get_time_flag(void) const
  bool return_value = (*(const ButtonThrower*)local_this).get_time_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_get_time_flag_39_comment =
  "C++ Interface:\n"
  "get_time_flag(ButtonThrower self)\n"
  "\n"
  "/**\n"
  " * Returns the flag that indicates whether the time of the button event should\n"
  " * be passed as a parameter.\n"
  " */";
#else
static const char *Dtool_ButtonThrower_get_time_flag_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ButtonThrower::add_parameter(EventParameter const &obj)
 */
static PyObject *Dtool_ButtonThrower_add_parameter_41(PyObject *self, PyObject *arg) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.add_parameter")) {
    return NULL;
  }
  // 1-void ButtonThrower::add_parameter(EventParameter const &obj)
  EventParameter const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_EventParameter(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ButtonThrower.add_parameter", "EventParameter");
  }
  (*local_this).add_parameter(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_parameter(const ButtonThrower self, const EventParameter obj)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_add_parameter_41_comment =
  "C++ Interface:\n"
  "add_parameter(const ButtonThrower self, const EventParameter obj)\n"
  "\n"
  "/**\n"
  " * Adds the indicated parameter to the list of parameters that will be passed\n"
  " * with each event generated by this ButtonThrower.\n"
  " */";
#else
static const char *Dtool_ButtonThrower_add_parameter_41_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int ButtonThrower::get_num_parameters(void) const
 */
static PyObject *Dtool_ButtonThrower_get_num_parameters_42(PyObject *self, PyObject *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }
  // 1-int ButtonThrower::get_num_parameters(void) const
  int return_value = (*(const ButtonThrower*)local_this).get_num_parameters();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_get_num_parameters_42_comment =
  "C++ Interface:\n"
  "get_num_parameters(ButtonThrower self)\n"
  "\n"
  "/**\n"
  " * Returns the number of parameters that have been added to the list of\n"
  " * parameters to be passed with each event generated by this ButtonThrower.\n"
  " */";
#else
static const char *Dtool_ButtonThrower_get_num_parameters_42_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EventParameter ButtonThrower::get_parameter(int n) const
 */
static PyObject *Dtool_ButtonThrower_get_parameter_43(PyObject *self, PyObject *arg) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }
  // 1-EventParameter ButtonThrower::get_parameter(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    EventParameter *return_value = new EventParameter((*(const ButtonThrower*)local_this).get_parameter((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EventParameter, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parameter(ButtonThrower self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_get_parameter_43_comment =
  "C++ Interface:\n"
  "get_parameter(ButtonThrower self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth parameter that has been added to the list of parameters\n"
  " * passed with each event generated by this ButtonThrower.\n"
  " */";
#else
static const char *Dtool_ButtonThrower_get_parameter_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ModifierButtons const &ButtonThrower::get_modifier_buttons(void) const
 */
static PyObject *Dtool_ButtonThrower_get_modifier_buttons_47(PyObject *self, PyObject *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ModifierButtons const &ButtonThrower::get_modifier_buttons(void) const
  ModifierButtons const *return_value = &((*(const ButtonThrower*)local_this).get_modifier_buttons());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ModifierButtons, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_get_modifier_buttons_47_comment =
  "C++ Interface:\n"
  "get_modifier_buttons(ButtonThrower self)\n"
  "\n"
  "/**\n"
  " * Returns the set of ModifierButtons that the ButtonThrower will consider\n"
  " * important enough to prepend the event name with.  Normally, this set will\n"
  " * be empty, and the ButtonThrower will therefore ignore all ModifierButtons\n"
  " * attached to the key events, but if one or more buttons have been added to\n"
  " * this set, and those modifier buttons are set on the button event, then the\n"
  " * event name will be prepended with the names of the modifier buttons.\n"
  " */";
#else
static const char *Dtool_ButtonThrower_get_modifier_buttons_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ButtonThrower::set_modifier_buttons(ModifierButtons const &mods)
 */
static PyObject *Dtool_ButtonThrower_set_modifier_buttons_48(PyObject *self, PyObject *arg) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.set_modifier_buttons")) {
    return NULL;
  }
  // 1-inline void ButtonThrower::set_modifier_buttons(ModifierButtons const &mods)
  ModifierButtons const *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 1, "ButtonThrower.set_modifier_buttons", true, true);
  if (arg_this != NULL) {
    (*local_this).set_modifier_buttons(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_modifier_buttons(const ButtonThrower self, const ModifierButtons mods)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_set_modifier_buttons_48_comment =
  "C++ Interface:\n"
  "set_modifier_buttons(const ButtonThrower self, const ModifierButtons mods)\n"
  "\n"
  "/**\n"
  " * Changes the set of ModifierButtons that the ButtonThrower will consider\n"
  " * important enough to prepend the event name with.  Normally, this set will\n"
  " * be empty, and the ButtonThrower will therefore ignore all ModifierButtons\n"
  " * attached to the key events, but if one or more buttons have been added to\n"
  " * this set, then the event name will be prepended with the names of the\n"
  " * modifier buttons.\n"
  " *\n"
  " * It is recommended that you change this setting by first calling\n"
  " * get_modifier_buttons(), making adjustments, and passing the new value to\n"
  " * set_modifier_buttons().  This way the current state of the modifier buttons\n"
  " * will not be lost.\n"
  " */";
#else
static const char *Dtool_ButtonThrower_set_modifier_buttons_48_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ButtonThrower::set_throw_buttons_active(bool flag)
 */
static PyObject *Dtool_ButtonThrower_set_throw_buttons_active_52(PyObject *self, PyObject *arg) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.set_throw_buttons_active")) {
    return NULL;
  }
  // 1-inline void ButtonThrower::set_throw_buttons_active(bool flag)
  (*local_this).set_throw_buttons_active((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_throw_buttons_active(const ButtonThrower self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_set_throw_buttons_active_52_comment =
  "C++ Interface:\n"
  "set_throw_buttons_active(const ButtonThrower self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the flag that indicates whether the ButtonThrower will only process\n"
  " * events for the explicitly named buttons or not.  Normally this is false,\n"
  " * meaning all buttons are processed; set it true to indicate that only some\n"
  " * buttons should be processed.  See add_throw_button().\n"
  " */";
#else
static const char *Dtool_ButtonThrower_set_throw_buttons_active_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ButtonThrower::get_throw_buttons_active(void) const
 */
static PyObject *Dtool_ButtonThrower_get_throw_buttons_active_53(PyObject *self, PyObject *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ButtonThrower::get_throw_buttons_active(void) const
  bool return_value = (*(const ButtonThrower*)local_this).get_throw_buttons_active();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_get_throw_buttons_active_53_comment =
  "C++ Interface:\n"
  "get_throw_buttons_active(ButtonThrower self)\n"
  "\n"
  "/**\n"
  " * Returns the flag that indicates whether the ButtonThrower will only process\n"
  " * events for the explicitly named buttons or not.  See\n"
  " * set_throw_buttons_active().\n"
  " */";
#else
static const char *Dtool_ButtonThrower_get_throw_buttons_active_53_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ButtonThrower::add_throw_button(ModifierButtons const &mods, ButtonHandle const &button)
 */
static PyObject *Dtool_ButtonThrower_add_throw_button_55(PyObject *self, PyObject *args, PyObject *kwds) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.add_throw_button")) {
    return NULL;
  }
  // 1-bool ButtonThrower::add_throw_button(ModifierButtons const &mods, ButtonHandle const &button)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"mods", "button", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_throw_button", (char **)keyword_list, &param1, &param2)) {
    ModifierButtons const *param1_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ModifierButtons, 1, "ButtonThrower.add_throw_button", true, true);
    ButtonHandle param2_local;
    ButtonHandle const *param2_this = Dtool_Coerce_ButtonHandle(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ButtonThrower.add_throw_button", "ButtonHandle");
    }
    if (param1_this != NULL) {
      bool return_value = (*local_this).add_throw_button(*param1_this, *param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_throw_button(const ButtonThrower self, const ModifierButtons mods, const ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_add_throw_button_55_comment =
  "C++ Interface:\n"
  "add_throw_button(const ButtonThrower self, const ModifierButtons mods, const ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Adds a new button to the set of buttons that the ButtonThrower explicitly\n"
  " * processes.\n"
  " *\n"
  " * If set_throw_buttons_active is false (which is the default), the\n"
  " * ButtonThrower will process all buttons.  Otherwise, the ButtonThrower will\n"
  " * only process events for the button(s) explicitly named by this function;\n"
  " * buttons not on the list will be ignored by this object and passed on\n"
  " * downstream to the child node(s) in the data graph.  A button that *is* on\n"
  " * the list will be processed by the ButtonThrower and not passed on to the\n"
  " * child node(s).\n"
  " *\n"
  " * The return value is true if the button is added, or false if it was already\n"
  " * in the set.\n"
  " */";
#else
static const char *Dtool_ButtonThrower_add_throw_button_55_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ButtonThrower::remove_throw_button(ModifierButtons const &mods, ButtonHandle const &button)
 */
static PyObject *Dtool_ButtonThrower_remove_throw_button_56(PyObject *self, PyObject *args, PyObject *kwds) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.remove_throw_button")) {
    return NULL;
  }
  // 1-bool ButtonThrower::remove_throw_button(ModifierButtons const &mods, ButtonHandle const &button)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"mods", "button", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:remove_throw_button", (char **)keyword_list, &param1, &param2)) {
    ModifierButtons const *param1_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ModifierButtons, 1, "ButtonThrower.remove_throw_button", true, true);
    ButtonHandle param2_local;
    ButtonHandle const *param2_this = Dtool_Coerce_ButtonHandle(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ButtonThrower.remove_throw_button", "ButtonHandle");
    }
    if (param1_this != NULL) {
      bool return_value = (*local_this).remove_throw_button(*param1_this, *param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_throw_button(const ButtonThrower self, const ModifierButtons mods, const ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_remove_throw_button_56_comment =
  "C++ Interface:\n"
  "remove_throw_button(const ButtonThrower self, const ModifierButtons mods, const ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Removes the indicated button from the set of buttons that the ButtonThrower\n"
  " * explicitly processes.  See add_throw_button().\n"
  " *\n"
  " * The return value is true if the button is removed, or false if it was not\n"
  " * on the set.\n"
  " */";
#else
static const char *Dtool_ButtonThrower_remove_throw_button_56_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ButtonThrower::has_throw_button(ButtonHandle const &button) const
 * bool ButtonThrower::has_throw_button(ModifierButtons const &mods, ButtonHandle const &button) const
 */
static PyObject *Dtool_ButtonThrower_has_throw_button_57(PyObject *self, PyObject *args, PyObject *kwds) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "button");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'button' (pos 1) not found");
      }
      // 1-bool ButtonThrower::has_throw_button(ButtonHandle const &button) const
      ButtonHandle arg_local;
      ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "ButtonThrower.has_throw_button", "ButtonHandle");
      }
      bool return_value = (*(const ButtonThrower*)local_this).has_throw_button(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-bool ButtonThrower::has_throw_button(ModifierButtons const &mods, ButtonHandle const &button) const
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"mods", "button", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:has_throw_button", (char **)keyword_list, &param1, &param2)) {
        ModifierButtons const *param1_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ModifierButtons, 1, "ButtonThrower.has_throw_button", true, true);
        ButtonHandle param2_local;
        ButtonHandle const *param2_this = Dtool_Coerce_ButtonHandle(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "ButtonThrower.has_throw_button", "ButtonHandle");
        }
        if (param1_this != NULL) {
          bool return_value = (*(const ButtonThrower*)local_this).has_throw_button(*param1_this, *param2_this);
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "has_throw_button() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_throw_button(ButtonThrower self, const ButtonHandle button)\n"
      "has_throw_button(ButtonThrower self, const ModifierButtons mods, const ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_has_throw_button_57_comment =
  "C++ Interface:\n"
  "has_throw_button(ButtonThrower self, const ButtonHandle button)\n"
  "has_throw_button(ButtonThrower self, const ModifierButtons mods, const ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated button is on the set of buttons that will be\n"
  " * processed by the ButtonThrower, false otherwise.  See add_throw_button().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated button, in conjunction with any nonspecified\n"
  " * modifier buttons, is on the set of buttons that will be processed by the\n"
  " * ButtonThrower.  That is to say, returns true if this button was ever passed\n"
  " * as the second parameter add_throw_button(), regardless of what the first\n"
  " * parameter was.\n"
  " */";
#else
static const char *Dtool_ButtonThrower_has_throw_button_57_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ButtonThrower::clear_throw_buttons(void)
 */
static PyObject *Dtool_ButtonThrower_clear_throw_buttons_58(PyObject *self, PyObject *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.clear_throw_buttons")) {
    return NULL;
  }
  // 1-void ButtonThrower::clear_throw_buttons(void)
  (*local_this).clear_throw_buttons();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_clear_throw_buttons_58_comment =
  "C++ Interface:\n"
  "clear_throw_buttons(const ButtonThrower self)\n"
  "\n"
  "/**\n"
  " * Empties the set of buttons that were added via add_throw_button().  See\n"
  " * add_throw_button().\n"
  " */";
#else
static const char *Dtool_ButtonThrower_clear_throw_buttons_58_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ButtonThrower::get_class_type(void)
 */
static PyObject *Dtool_ButtonThrower_get_class_type_59(PyObject *, PyObject *) {
  // 1-static TypeHandle ButtonThrower::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ButtonThrower::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ButtonThrower_get_class_type_59_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ButtonThrower_get_class_type_59_comment = NULL;
#endif

static PyObject *Dtool_ButtonThrower_button_down_event_Getter(PyObject *self, void *) {
  const ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &ButtonThrower::get_button_down_event(void) const
  std::string const &return_value = (*(const ButtonThrower*)local_this).get_button_down_event();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ButtonThrower_button_down_event_Setter(PyObject *self, PyObject *arg, void *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.button_down_event")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete button_down_event attribute");
    return -1;
  }
  // 1-inline void ButtonThrower::set_button_down_event(std::string const &button_down_event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_button_down_event(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_button_down_event(const ButtonThrower self, str button_down_event)\n");
  }
  return -1;
}

static PyObject *Dtool_ButtonThrower_button_up_event_Getter(PyObject *self, void *) {
  const ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &ButtonThrower::get_button_up_event(void) const
  std::string const &return_value = (*(const ButtonThrower*)local_this).get_button_up_event();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ButtonThrower_button_up_event_Setter(PyObject *self, PyObject *arg, void *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.button_up_event")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete button_up_event attribute");
    return -1;
  }
  // 1-inline void ButtonThrower::set_button_up_event(std::string const &button_up_event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_button_up_event(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_button_up_event(const ButtonThrower self, str button_up_event)\n");
  }
  return -1;
}

static PyObject *Dtool_ButtonThrower_button_repeat_event_Getter(PyObject *self, void *) {
  const ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &ButtonThrower::get_button_repeat_event(void) const
  std::string const &return_value = (*(const ButtonThrower*)local_this).get_button_repeat_event();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ButtonThrower_button_repeat_event_Setter(PyObject *self, PyObject *arg, void *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.button_repeat_event")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete button_repeat_event attribute");
    return -1;
  }
  // 1-inline void ButtonThrower::set_button_repeat_event(std::string const &button_repeat_event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_button_repeat_event(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_button_repeat_event(const ButtonThrower self, str button_repeat_event)\n");
  }
  return -1;
}

static PyObject *Dtool_ButtonThrower_keystroke_event_Getter(PyObject *self, void *) {
  const ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &ButtonThrower::get_keystroke_event(void) const
  std::string const &return_value = (*(const ButtonThrower*)local_this).get_keystroke_event();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ButtonThrower_keystroke_event_Setter(PyObject *self, PyObject *arg, void *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.keystroke_event")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete keystroke_event attribute");
    return -1;
  }
  // 1-inline void ButtonThrower::set_keystroke_event(std::string const &keystroke_event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_keystroke_event(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_keystroke_event(const ButtonThrower self, str keystroke_event)\n");
  }
  return -1;
}

static PyObject *Dtool_ButtonThrower_candidate_event_Getter(PyObject *self, void *) {
  const ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &ButtonThrower::get_candidate_event(void) const
  std::string const &return_value = (*(const ButtonThrower*)local_this).get_candidate_event();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ButtonThrower_candidate_event_Setter(PyObject *self, PyObject *arg, void *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.candidate_event")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete candidate_event attribute");
    return -1;
  }
  // 1-inline void ButtonThrower::set_candidate_event(std::string const &candidate_event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_candidate_event(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_candidate_event(const ButtonThrower self, str candidate_event)\n");
  }
  return -1;
}

static PyObject *Dtool_ButtonThrower_move_event_Getter(PyObject *self, void *) {
  const ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &ButtonThrower::get_move_event(void) const
  std::string const &return_value = (*(const ButtonThrower*)local_this).get_move_event();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ButtonThrower_move_event_Setter(PyObject *self, PyObject *arg, void *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.move_event")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete move_event attribute");
    return -1;
  }
  // 1-inline void ButtonThrower::set_move_event(std::string const &move_event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_move_event(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_move_event(const ButtonThrower self, str move_event)\n");
  }
  return -1;
}

static PyObject *Dtool_ButtonThrower_raw_button_down_event_Getter(PyObject *self, void *) {
  const ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &ButtonThrower::get_raw_button_down_event(void) const
  std::string const &return_value = (*(const ButtonThrower*)local_this).get_raw_button_down_event();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ButtonThrower_raw_button_down_event_Setter(PyObject *self, PyObject *arg, void *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.raw_button_down_event")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete raw_button_down_event attribute");
    return -1;
  }
  // 1-inline void ButtonThrower::set_raw_button_down_event(std::string const &raw_button_down_event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_raw_button_down_event(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_raw_button_down_event(const ButtonThrower self, str raw_button_down_event)\n");
  }
  return -1;
}

static PyObject *Dtool_ButtonThrower_raw_button_up_event_Getter(PyObject *self, void *) {
  const ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &ButtonThrower::get_raw_button_up_event(void) const
  std::string const &return_value = (*(const ButtonThrower*)local_this).get_raw_button_up_event();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ButtonThrower_raw_button_up_event_Setter(PyObject *self, PyObject *arg, void *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.raw_button_up_event")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete raw_button_up_event attribute");
    return -1;
  }
  // 1-inline void ButtonThrower::set_raw_button_up_event(std::string const &raw_button_up_event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_raw_button_up_event(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_raw_button_up_event(const ButtonThrower self, str raw_button_up_event)\n");
  }
  return -1;
}

static PyObject *Dtool_ButtonThrower_prefix_Getter(PyObject *self, void *) {
  const ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &ButtonThrower::get_prefix(void) const
  std::string const &return_value = (*(const ButtonThrower*)local_this).get_prefix();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ButtonThrower_prefix_Setter(PyObject *self, PyObject *arg, void *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.prefix")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete prefix attribute");
    return -1;
  }
  // 1-inline void ButtonThrower::set_prefix(std::string const &prefix)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_prefix(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_prefix(const ButtonThrower self, str prefix)\n");
  }
  return -1;
}

static PyObject *Dtool_ButtonThrower_specific_flag_Getter(PyObject *self, void *) {
  const ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool ButtonThrower::get_specific_flag(void) const
  bool return_value = (*(const ButtonThrower*)local_this).get_specific_flag();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ButtonThrower_specific_flag_Setter(PyObject *self, PyObject *arg, void *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.specific_flag")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete specific_flag attribute");
    return -1;
  }
  // 1-inline void ButtonThrower::set_specific_flag(bool specific_flag)
  (*local_this).set_specific_flag((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_specific_flag(const ButtonThrower self, bool specific_flag)\n");
  }
  return -1;
}

static PyObject *Dtool_ButtonThrower_time_flag_Getter(PyObject *self, void *) {
  const ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool ButtonThrower::get_time_flag(void) const
  bool return_value = (*(const ButtonThrower*)local_this).get_time_flag();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ButtonThrower_time_flag_Setter(PyObject *self, PyObject *arg, void *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.time_flag")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete time_flag attribute");
    return -1;
  }
  // 1-inline void ButtonThrower::set_time_flag(bool time_flag)
  (*local_this).set_time_flag((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_time_flag(const ButtonThrower self, bool time_flag)\n");
  }
  return -1;
}

/**
 * sequence length function for property ButtonThrower::parameters
 */
static Py_ssize_t Dtool_ButtonThrower_parameters_Len(PyObject *self) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_parameters();
}

/**
 * sequence getter for property ButtonThrower::parameters
 */
static PyObject *Dtool_ButtonThrower_parameters_Getitem(PyObject *self, Py_ssize_t index) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_parameters()) {
    PyErr_SetString(PyExc_IndexError, "ButtonThrower.parameters[] index out of range");
    return NULL;
  }
  // 1-EventParameter ButtonThrower::get_parameter(int n) const
  EventParameter *return_value = new EventParameter((*(const ButtonThrower*)local_this).get_parameter(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EventParameter, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parameter(ButtonThrower self, index)\n");
  }
}

static PyObject *Dtool_ButtonThrower_parameters_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_ButtonThrower_parameters_Len;
  wrap->_getitem_func = &Dtool_ButtonThrower_parameters_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

static PyObject *Dtool_ButtonThrower_modifier_buttons_Getter(PyObject *self, void *) {
  const ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline ModifierButtons const &ButtonThrower::get_modifier_buttons(void) const
  ModifierButtons const *return_value = &((*(const ButtonThrower*)local_this).get_modifier_buttons());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ModifierButtons, false, true);
}

static int Dtool_ButtonThrower_modifier_buttons_Setter(PyObject *self, PyObject *arg, void *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.modifier_buttons")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete modifier_buttons attribute");
    return -1;
  }
  // 1-inline void ButtonThrower::set_modifier_buttons(ModifierButtons const &mods)
  ModifierButtons const *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 1, "ButtonThrower.set_modifier_buttons", true, true);
  if (arg_this != NULL) {
    (*local_this).set_modifier_buttons(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_modifier_buttons(const ButtonThrower self, const ModifierButtons mods)\n");
  }
  return -1;
}

static PyObject *Dtool_ButtonThrower_throw_buttons_active_Getter(PyObject *self, void *) {
  const ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool ButtonThrower::get_throw_buttons_active(void) const
  bool return_value = (*(const ButtonThrower*)local_this).get_throw_buttons_active();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ButtonThrower_throw_buttons_active_Setter(PyObject *self, PyObject *arg, void *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonThrower, (void **)&local_this, "ButtonThrower.throw_buttons_active")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete throw_buttons_active attribute");
    return -1;
  }
  // 1-inline void ButtonThrower::set_throw_buttons_active(bool flag)
  (*local_this).set_throw_buttons_active((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_throw_buttons_active(const ButtonThrower self, bool flag)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ButtonThrower::ButtonThrower(ButtonThrower const &) = default
 * ButtonThrower::ButtonThrower(std::string const &name)
 */
static int Dtool_Init_ButtonThrower(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ButtonThrower() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ButtonThrower::ButtonThrower(ButtonThrower const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ButtonThrower", (char **)keyword_list, &param0)) {
      ButtonThrower const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ButtonThrower, (void **)&param0_this);
      if (param0_this != NULL) {
        ButtonThrower *return_value = new ButtonThrower(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonThrower, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ButtonThrower::ButtonThrower(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ButtonThrower", (char **)keyword_list, &param0_str, &param0_len)) {
      ButtonThrower *return_value = new ButtonThrower(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonThrower, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline ButtonThrower::ButtonThrower(ButtonThrower const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ButtonThrower", (char **)keyword_list, &param0)) {
      CPT(ButtonThrower) param0_this;
      if (Dtool_ConstCoerce_ButtonThrower(param0, param0_this)) {
        ButtonThrower *return_value = new ButtonThrower(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonThrower, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ButtonThrower::ButtonThrower(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ButtonThrower(const ButtonThrower param0)\n"
      "ButtonThrower(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ButtonThrower(PyObject *args, CPT(ButtonThrower) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ButtonThrower, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ButtonThrower::ButtonThrower(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ButtonThrower *return_value = new ButtonThrower(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_ButtonThrower(PyObject *args, PT(ButtonThrower) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ButtonThrower, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ButtonThrower::ButtonThrower(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ButtonThrower *return_value = new ButtonThrower(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ButtonThrower_get_parameters(PyObject *self, PyObject *) {
  ButtonThrower *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonThrower, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_parameters();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ButtonThrower_get_parameter_43(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_ButtonThrower(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ButtonThrower) {
    printf("ButtonThrower ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ButtonThrower *local_this = (ButtonThrower *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ButtonThrower) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ButtonThrower(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ButtonThrower) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (ButtonThrower*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ButtonThrower*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (ButtonThrower*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ButtonThrower*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ButtonThrower*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ButtonThrower*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ButtonThrower*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MouseInterfaceNode
 */
/**
 * Python function wrapper for:
 * void MouseInterfaceNode::require_button(ButtonHandle const &button, bool is_down)
 */
static PyObject *Dtool_MouseInterfaceNode_require_button_61(PyObject *self, PyObject *args, PyObject *kwds) {
  MouseInterfaceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseInterfaceNode, (void **)&local_this, "MouseInterfaceNode.require_button")) {
    return NULL;
  }
  // 1-void MouseInterfaceNode::require_button(ButtonHandle const &button, bool is_down)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"button", "is_down", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:require_button", (char **)keyword_list, &param1, &param2)) {
    ButtonHandle param1_local;
    ButtonHandle const *param1_this = Dtool_Coerce_ButtonHandle(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "MouseInterfaceNode.require_button", "ButtonHandle");
    }
    (*local_this).require_button(*param1_this, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "require_button(const MouseInterfaceNode self, const ButtonHandle button, bool is_down)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseInterfaceNode_require_button_61_comment =
  "C++ Interface:\n"
  "require_button(const MouseInterfaceNode self, const ButtonHandle button, bool is_down)\n"
  "\n"
  "/**\n"
  " * Indicates that the indicated button must be in the required state (either\n"
  " * up or down) in order for this particular MouseInterfaceNode to do anything.\n"
  " * For instance, this may be called to make a Trackball object respect mouse\n"
  " * input only when the control key is held down.\n"
  " */";
#else
static const char *Dtool_MouseInterfaceNode_require_button_61_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MouseInterfaceNode::clear_button(ButtonHandle const &button)
 */
static PyObject *Dtool_MouseInterfaceNode_clear_button_62(PyObject *self, PyObject *arg) {
  MouseInterfaceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseInterfaceNode, (void **)&local_this, "MouseInterfaceNode.clear_button")) {
    return NULL;
  }
  // 1-void MouseInterfaceNode::clear_button(ButtonHandle const &button)
  ButtonHandle arg_local;
  ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "MouseInterfaceNode.clear_button", "ButtonHandle");
  }
  (*local_this).clear_button(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_button(const MouseInterfaceNode self, const ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseInterfaceNode_clear_button_62_comment =
  "C++ Interface:\n"
  "clear_button(const MouseInterfaceNode self, const ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Removes any requirement on the indicated button set by an earlier call to\n"
  " * require_button().\n"
  " */";
#else
static const char *Dtool_MouseInterfaceNode_clear_button_62_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MouseInterfaceNode::clear_all_buttons(void)
 */
static PyObject *Dtool_MouseInterfaceNode_clear_all_buttons_63(PyObject *self, PyObject *) {
  MouseInterfaceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseInterfaceNode, (void **)&local_this, "MouseInterfaceNode.clear_all_buttons")) {
    return NULL;
  }
  // 1-void MouseInterfaceNode::clear_all_buttons(void)
  (*local_this).clear_all_buttons();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MouseInterfaceNode_clear_all_buttons_63_comment =
  "C++ Interface:\n"
  "clear_all_buttons(const MouseInterfaceNode self)\n"
  "\n"
  "/**\n"
  " * Removes all requirements on buttons set by an earlier call to\n"
  " * require_button().\n"
  " */";
#else
static const char *Dtool_MouseInterfaceNode_clear_all_buttons_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MouseInterfaceNode::get_class_type(void)
 */
static PyObject *Dtool_MouseInterfaceNode_get_class_type_64(PyObject *, PyObject *) {
  // 1-static TypeHandle MouseInterfaceNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(MouseInterfaceNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseInterfaceNode_get_class_type_64_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MouseInterfaceNode_get_class_type_64_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline MouseInterfaceNode::MouseInterfaceNode(MouseInterfaceNode const &) = default
 */
static int Dtool_Init_MouseInterfaceNode(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "MouseInterfaceNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline MouseInterfaceNode::MouseInterfaceNode(MouseInterfaceNode const &) = default
  MouseInterfaceNode const *arg_this = (MouseInterfaceNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MouseInterfaceNode, 0, "MouseInterfaceNode.MouseInterfaceNode", true, true);
  if (arg_this != NULL) {
    MouseInterfaceNode *return_value = new MouseInterfaceNode(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MouseInterfaceNode, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MouseInterfaceNode(const MouseInterfaceNode param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_MouseInterfaceNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MouseInterfaceNode) {
    printf("MouseInterfaceNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MouseInterfaceNode *local_this = (MouseInterfaceNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MouseInterfaceNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MouseInterfaceNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MouseInterfaceNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (MouseInterfaceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MouseInterfaceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (MouseInterfaceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MouseInterfaceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MouseInterfaceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MouseInterfaceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MouseInterfaceNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DriveInterface
 */
/**
 * Python function wrapper for:
 * inline void DriveInterface::set_forward_speed(PN_stdfloat speed)
 */
static PyObject *Dtool_DriveInterface_set_forward_speed_68(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_forward_speed")) {
    return NULL;
  }
  // 1-inline void DriveInterface::set_forward_speed(PN_stdfloat speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_forward_speed((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_forward_speed(const DriveInterface self, float speed)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_forward_speed_68_comment =
  "C++ Interface:\n"
  "set_forward_speed(const DriveInterface self, float speed)\n"
  "\n"
  "/**\n"
  " * Sets the speed of full forward motion, when the mouse is at the very top of\n"
  " * the window.  This is in units (e.g.  feet) per second.\n"
  " */";
#else
static const char *Dtool_DriveInterface_set_forward_speed_68_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DriveInterface::get_forward_speed(void) const
 */
static PyObject *Dtool_DriveInterface_get_forward_speed_69(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DriveInterface::get_forward_speed(void) const
  PN_stdfloat return_value = (*(const DriveInterface*)local_this).get_forward_speed();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_forward_speed_69_comment =
  "C++ Interface:\n"
  "get_forward_speed(DriveInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the speed of full forward motion, when the mouse is at the very top\n"
  " * of the window.  This is in units (e.g.  feet) per second.\n"
  " */";
#else
static const char *Dtool_DriveInterface_get_forward_speed_69_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DriveInterface::set_reverse_speed(PN_stdfloat speed)
 */
static PyObject *Dtool_DriveInterface_set_reverse_speed_70(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_reverse_speed")) {
    return NULL;
  }
  // 1-inline void DriveInterface::set_reverse_speed(PN_stdfloat speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_reverse_speed((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_reverse_speed(const DriveInterface self, float speed)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_reverse_speed_70_comment =
  "C++ Interface:\n"
  "set_reverse_speed(const DriveInterface self, float speed)\n"
  "\n"
  "/**\n"
  " * Sets the speed of full reverse motion, when the mouse is at the very bottom\n"
  " * of the window.  This is in units (e.g.  feet) per second.\n"
  " */";
#else
static const char *Dtool_DriveInterface_set_reverse_speed_70_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DriveInterface::get_reverse_speed(void) const
 */
static PyObject *Dtool_DriveInterface_get_reverse_speed_71(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DriveInterface::get_reverse_speed(void) const
  PN_stdfloat return_value = (*(const DriveInterface*)local_this).get_reverse_speed();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_reverse_speed_71_comment =
  "C++ Interface:\n"
  "get_reverse_speed(DriveInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the speed of full reverse motion, when the mouse is at the very\n"
  " * bottom of the window.  This is in units (e.g.  feet) per second.\n"
  " */";
#else
static const char *Dtool_DriveInterface_get_reverse_speed_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DriveInterface::set_rotate_speed(PN_stdfloat speed)
 */
static PyObject *Dtool_DriveInterface_set_rotate_speed_72(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_rotate_speed")) {
    return NULL;
  }
  // 1-inline void DriveInterface::set_rotate_speed(PN_stdfloat speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_rotate_speed((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rotate_speed(const DriveInterface self, float speed)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_rotate_speed_72_comment =
  "C++ Interface:\n"
  "set_rotate_speed(const DriveInterface self, float speed)\n"
  "\n"
  "/**\n"
  " * Sets the maximum rate at which the user can rotate left or right, when the\n"
  " * mouse is at the very edge of the window.  This is in degrees per second.\n"
  " */";
#else
static const char *Dtool_DriveInterface_set_rotate_speed_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DriveInterface::get_rotate_speed(void) const
 */
static PyObject *Dtool_DriveInterface_get_rotate_speed_73(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DriveInterface::get_rotate_speed(void) const
  PN_stdfloat return_value = (*(const DriveInterface*)local_this).get_rotate_speed();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_rotate_speed_73_comment =
  "C++ Interface:\n"
  "get_rotate_speed(DriveInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum rate at which the user can rotate left or right, when\n"
  " * the mouse is at the very edge of the window.  This is in degrees per\n"
  " * second.\n"
  " */";
#else
static const char *Dtool_DriveInterface_get_rotate_speed_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DriveInterface::set_vertical_dead_zone(PN_stdfloat zone)
 */
static PyObject *Dtool_DriveInterface_set_vertical_dead_zone_74(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_vertical_dead_zone")) {
    return NULL;
  }
  // 1-inline void DriveInterface::set_vertical_dead_zone(PN_stdfloat zone)
  if (PyNumber_Check(arg)) {
    (*local_this).set_vertical_dead_zone((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertical_dead_zone(const DriveInterface self, float zone)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_vertical_dead_zone_74_comment =
  "C++ Interface:\n"
  "set_vertical_dead_zone(const DriveInterface self, float zone)\n"
  "\n"
  "/**\n"
  " * Sets the size of the horizontal bar in the center of the screen that\n"
  " * represents the \"dead zone\" of vertical motion: the region in which the\n"
  " * mouse does not report vertical motion.  This is in a fraction of the window\n"
  " * height, so 0.5 will set a dead zone as large as half the screen.\n"
  " */";
#else
static const char *Dtool_DriveInterface_set_vertical_dead_zone_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DriveInterface::get_vertical_dead_zone(void) const
 */
static PyObject *Dtool_DriveInterface_get_vertical_dead_zone_75(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DriveInterface::get_vertical_dead_zone(void) const
  PN_stdfloat return_value = (*(const DriveInterface*)local_this).get_vertical_dead_zone();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_vertical_dead_zone_75_comment =
  "C++ Interface:\n"
  "get_vertical_dead_zone(DriveInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the size of the horizontal bar in the center of the screen that\n"
  " * represents the \"dead zone\" of vertical motion: the region in which the\n"
  " * mouse does not report vertical motion.  This is in a fraction of the window\n"
  " * height, so 0.5 will set a dead zone as large as half the screen.\n"
  " */";
#else
static const char *Dtool_DriveInterface_get_vertical_dead_zone_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DriveInterface::set_horizontal_dead_zone(PN_stdfloat zone)
 */
static PyObject *Dtool_DriveInterface_set_horizontal_dead_zone_76(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_horizontal_dead_zone")) {
    return NULL;
  }
  // 1-inline void DriveInterface::set_horizontal_dead_zone(PN_stdfloat zone)
  if (PyNumber_Check(arg)) {
    (*local_this).set_horizontal_dead_zone((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_horizontal_dead_zone(const DriveInterface self, float zone)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_horizontal_dead_zone_76_comment =
  "C++ Interface:\n"
  "set_horizontal_dead_zone(const DriveInterface self, float zone)\n"
  "\n"
  "/**\n"
  " * Sets the size of the vertical bar in the center of the screen that\n"
  " * represents the \"dead zone\" of horizontal motion: the region in which the\n"
  " * mouse does not report horizontal motion.  This is in a fraction of the\n"
  " * window width, so 0.5 will set a dead zone as large as half the screen.\n"
  " */";
#else
static const char *Dtool_DriveInterface_set_horizontal_dead_zone_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DriveInterface::get_horizontal_dead_zone(void) const
 */
static PyObject *Dtool_DriveInterface_get_horizontal_dead_zone_77(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DriveInterface::get_horizontal_dead_zone(void) const
  PN_stdfloat return_value = (*(const DriveInterface*)local_this).get_horizontal_dead_zone();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_horizontal_dead_zone_77_comment =
  "C++ Interface:\n"
  "get_horizontal_dead_zone(DriveInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the size of the vertical bar in the center of the screen that\n"
  " * represents the \"dead zone\" of horizontal motion: the region in which the\n"
  " * mouse does not report horizontal motion.  This is in a fraction of the\n"
  " * window width, so 0.5 will set a dead zone as large as half the screen.\n"
  " */";
#else
static const char *Dtool_DriveInterface_get_horizontal_dead_zone_77_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DriveInterface::set_vertical_ramp_up_time(PN_stdfloat ramp_up_time)
 */
static PyObject *Dtool_DriveInterface_set_vertical_ramp_up_time_78(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_vertical_ramp_up_time")) {
    return NULL;
  }
  // 1-inline void DriveInterface::set_vertical_ramp_up_time(PN_stdfloat ramp_up_time)
  if (PyNumber_Check(arg)) {
    (*local_this).set_vertical_ramp_up_time((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertical_ramp_up_time(const DriveInterface self, float ramp_up_time)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_vertical_ramp_up_time_78_comment =
  "C++ Interface:\n"
  "set_vertical_ramp_up_time(const DriveInterface self, float ramp_up_time)\n"
  "\n"
  "/**\n"
  " * Sets the amount of time, in seconds, it takes between the time an up or\n"
  " * down arrow key is pressed and the time it registers full forward or\n"
  " * backward motion.\n"
  " */";
#else
static const char *Dtool_DriveInterface_set_vertical_ramp_up_time_78_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DriveInterface::get_vertical_ramp_up_time(void) const
 */
static PyObject *Dtool_DriveInterface_get_vertical_ramp_up_time_79(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DriveInterface::get_vertical_ramp_up_time(void) const
  PN_stdfloat return_value = (*(const DriveInterface*)local_this).get_vertical_ramp_up_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_vertical_ramp_up_time_79_comment =
  "C++ Interface:\n"
  "get_vertical_ramp_up_time(DriveInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the amount of time, in seconds, it takes between the time an up or\n"
  " * down arrow key is pressed and the time it registers full forward or\n"
  " * backward motion.\n"
  " */";
#else
static const char *Dtool_DriveInterface_get_vertical_ramp_up_time_79_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DriveInterface::set_vertical_ramp_down_time(PN_stdfloat ramp_down_time)
 */
static PyObject *Dtool_DriveInterface_set_vertical_ramp_down_time_80(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_vertical_ramp_down_time")) {
    return NULL;
  }
  // 1-inline void DriveInterface::set_vertical_ramp_down_time(PN_stdfloat ramp_down_time)
  if (PyNumber_Check(arg)) {
    (*local_this).set_vertical_ramp_down_time((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertical_ramp_down_time(const DriveInterface self, float ramp_down_time)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_vertical_ramp_down_time_80_comment =
  "C++ Interface:\n"
  "set_vertical_ramp_down_time(const DriveInterface self, float ramp_down_time)\n"
  "\n"
  "/**\n"
  " * Sets the amount of time, in seconds, it takes between the time an up or\n"
  " * down arrow key is released and the time it registers no motion.\n"
  " */";
#else
static const char *Dtool_DriveInterface_set_vertical_ramp_down_time_80_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DriveInterface::get_vertical_ramp_down_time(void) const
 */
static PyObject *Dtool_DriveInterface_get_vertical_ramp_down_time_81(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DriveInterface::get_vertical_ramp_down_time(void) const
  PN_stdfloat return_value = (*(const DriveInterface*)local_this).get_vertical_ramp_down_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_vertical_ramp_down_time_81_comment =
  "C++ Interface:\n"
  "get_vertical_ramp_down_time(DriveInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the amount of time, in seconds, it takes between the time an up or\n"
  " * down arrow key is released and the time it registers no motion.\n"
  " */";
#else
static const char *Dtool_DriveInterface_get_vertical_ramp_down_time_81_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DriveInterface::set_horizontal_ramp_up_time(PN_stdfloat ramp_up_time)
 */
static PyObject *Dtool_DriveInterface_set_horizontal_ramp_up_time_82(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_horizontal_ramp_up_time")) {
    return NULL;
  }
  // 1-inline void DriveInterface::set_horizontal_ramp_up_time(PN_stdfloat ramp_up_time)
  if (PyNumber_Check(arg)) {
    (*local_this).set_horizontal_ramp_up_time((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_horizontal_ramp_up_time(const DriveInterface self, float ramp_up_time)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_horizontal_ramp_up_time_82_comment =
  "C++ Interface:\n"
  "set_horizontal_ramp_up_time(const DriveInterface self, float ramp_up_time)\n"
  "\n"
  "/**\n"
  " * Sets the amount of time, in seconds, it takes between the time a left or\n"
  " * right arrow key is pressed and the time it registers full rotation.\n"
  " */";
#else
static const char *Dtool_DriveInterface_set_horizontal_ramp_up_time_82_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DriveInterface::get_horizontal_ramp_up_time(void) const
 */
static PyObject *Dtool_DriveInterface_get_horizontal_ramp_up_time_83(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DriveInterface::get_horizontal_ramp_up_time(void) const
  PN_stdfloat return_value = (*(const DriveInterface*)local_this).get_horizontal_ramp_up_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_horizontal_ramp_up_time_83_comment =
  "C++ Interface:\n"
  "get_horizontal_ramp_up_time(DriveInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the amount of time, in seconds, it takes between the time a left or\n"
  " * right arrow key is pressed and the time it registers full rotation.\n"
  " */";
#else
static const char *Dtool_DriveInterface_get_horizontal_ramp_up_time_83_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DriveInterface::set_horizontal_ramp_down_time(PN_stdfloat ramp_down_time)
 */
static PyObject *Dtool_DriveInterface_set_horizontal_ramp_down_time_84(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_horizontal_ramp_down_time")) {
    return NULL;
  }
  // 1-inline void DriveInterface::set_horizontal_ramp_down_time(PN_stdfloat ramp_down_time)
  if (PyNumber_Check(arg)) {
    (*local_this).set_horizontal_ramp_down_time((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_horizontal_ramp_down_time(const DriveInterface self, float ramp_down_time)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_horizontal_ramp_down_time_84_comment =
  "C++ Interface:\n"
  "set_horizontal_ramp_down_time(const DriveInterface self, float ramp_down_time)\n"
  "\n"
  "/**\n"
  " * Sets the amount of time, in seconds, it takes between the time a left or\n"
  " * right arrow key is released and the time it registers no motion.\n"
  " */";
#else
static const char *Dtool_DriveInterface_set_horizontal_ramp_down_time_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DriveInterface::get_horizontal_ramp_down_time(void) const
 */
static PyObject *Dtool_DriveInterface_get_horizontal_ramp_down_time_85(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DriveInterface::get_horizontal_ramp_down_time(void) const
  PN_stdfloat return_value = (*(const DriveInterface*)local_this).get_horizontal_ramp_down_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_horizontal_ramp_down_time_85_comment =
  "C++ Interface:\n"
  "get_horizontal_ramp_down_time(DriveInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the amount of time, in seconds, it takes between the time a left or\n"
  " * right arrow key is released and the time it registers no motion.\n"
  " */";
#else
static const char *Dtool_DriveInterface_get_horizontal_ramp_down_time_85_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DriveInterface::get_speed(void) const
 */
static PyObject *Dtool_DriveInterface_get_speed_86(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DriveInterface::get_speed(void) const
  PN_stdfloat return_value = (*(const DriveInterface*)local_this).get_speed();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_speed_86_comment =
  "C++ Interface:\n"
  "get_speed(DriveInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the speed of the previous update in units/sec\n"
  " */";
#else
static const char *Dtool_DriveInterface_get_speed_86_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DriveInterface::get_rot_speed(void) const
 */
static PyObject *Dtool_DriveInterface_get_rot_speed_87(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DriveInterface::get_rot_speed(void) const
  PN_stdfloat return_value = (*(const DriveInterface*)local_this).get_rot_speed();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_rot_speed_87_comment =
  "C++ Interface:\n"
  "get_rot_speed(DriveInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the rot_speed of the previous update in units/sec\n"
  " */";
#else
static const char *Dtool_DriveInterface_get_rot_speed_87_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DriveInterface::reset(void)
 */
static PyObject *Dtool_DriveInterface_reset_88(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.reset")) {
    return NULL;
  }
  // 1-void DriveInterface::reset(void)
  (*local_this).reset();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_reset_88_comment =
  "C++ Interface:\n"
  "reset(const DriveInterface self)\n"
  "\n"
  "/**\n"
  " * Reinitializes the driver to the origin and resets any knowledge about\n"
  " * buttons being held down.\n"
  " */";
#else
static const char *Dtool_DriveInterface_reset_88_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &DriveInterface::get_pos(void) const
 */
static PyObject *Dtool_DriveInterface_get_pos_89(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 const &DriveInterface::get_pos(void) const
  LPoint3 const *return_value = &((*(const DriveInterface*)local_this).get_pos());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_pos_89_comment =
  "C++ Interface:\n"
  "get_pos(DriveInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the driver's position.\n"
  " */";
#else
static const char *Dtool_DriveInterface_get_pos_89_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DriveInterface::get_x(void) const
 */
static PyObject *Dtool_DriveInterface_get_x_90(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DriveInterface::get_x(void) const
  PN_stdfloat return_value = (*(const DriveInterface*)local_this).get_x();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_x_90_comment =
  "C++ Interface:\n"
  "get_x(DriveInterface self)\n";
#else
static const char *Dtool_DriveInterface_get_x_90_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DriveInterface::get_y(void) const
 */
static PyObject *Dtool_DriveInterface_get_y_91(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DriveInterface::get_y(void) const
  PN_stdfloat return_value = (*(const DriveInterface*)local_this).get_y();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_y_91_comment =
  "C++ Interface:\n"
  "get_y(DriveInterface self)\n";
#else
static const char *Dtool_DriveInterface_get_y_91_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DriveInterface::get_z(void) const
 */
static PyObject *Dtool_DriveInterface_get_z_92(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DriveInterface::get_z(void) const
  PN_stdfloat return_value = (*(const DriveInterface*)local_this).get_z();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_z_92_comment =
  "C++ Interface:\n"
  "get_z(DriveInterface self)\n";
#else
static const char *Dtool_DriveInterface_get_z_92_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DriveInterface::set_pos(LVecBase3 const &vec)
 * inline void DriveInterface::set_pos(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_DriveInterface_set_pos_93(PyObject *self, PyObject *args, PyObject *kwds) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_pos")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "vec");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'vec' (pos 1) not found");
      }
      // 1-inline void DriveInterface::set_pos(LVecBase3 const &vec)
      LVecBase3f arg_local;
      LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "DriveInterface.set_pos", "LVecBase3f");
      }
      (*local_this).set_pos(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void DriveInterface::set_pos(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_pos", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_pos((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_pos() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos(const DriveInterface self, const LVecBase3f vec)\n"
      "set_pos(const DriveInterface self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_pos_93_comment =
  "C++ Interface:\n"
  "set_pos(const DriveInterface self, const LVecBase3f vec)\n"
  "set_pos(const DriveInterface self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Directly sets the driver's position.\n"
  " */";
#else
static const char *Dtool_DriveInterface_set_pos_93_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DriveInterface::set_x(PN_stdfloat x)
 */
static PyObject *Dtool_DriveInterface_set_x_94(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_x")) {
    return NULL;
  }
  // 1-inline void DriveInterface::set_x(PN_stdfloat x)
  if (PyNumber_Check(arg)) {
    (*local_this).set_x((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_x(const DriveInterface self, float x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_x_94_comment =
  "C++ Interface:\n"
  "set_x(const DriveInterface self, float x)\n";
#else
static const char *Dtool_DriveInterface_set_x_94_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DriveInterface::set_y(PN_stdfloat y)
 */
static PyObject *Dtool_DriveInterface_set_y_95(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_y")) {
    return NULL;
  }
  // 1-inline void DriveInterface::set_y(PN_stdfloat y)
  if (PyNumber_Check(arg)) {
    (*local_this).set_y((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_y(const DriveInterface self, float y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_y_95_comment =
  "C++ Interface:\n"
  "set_y(const DriveInterface self, float y)\n";
#else
static const char *Dtool_DriveInterface_set_y_95_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DriveInterface::set_z(PN_stdfloat z)
 */
static PyObject *Dtool_DriveInterface_set_z_96(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_z")) {
    return NULL;
  }
  // 1-inline void DriveInterface::set_z(PN_stdfloat z)
  if (PyNumber_Check(arg)) {
    (*local_this).set_z((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_z(const DriveInterface self, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_z_96_comment =
  "C++ Interface:\n"
  "set_z(const DriveInterface self, float z)\n";
#else
static const char *Dtool_DriveInterface_set_z_96_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3 const &DriveInterface::get_hpr(void) const
 */
static PyObject *Dtool_DriveInterface_get_hpr_97(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3 const &DriveInterface::get_hpr(void) const
  LVecBase3 const *return_value = &((*(const DriveInterface*)local_this).get_hpr());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_hpr_97_comment =
  "C++ Interface:\n"
  "get_hpr(DriveInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the driver's orientation.\n"
  " */";
#else
static const char *Dtool_DriveInterface_get_hpr_97_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DriveInterface::get_h(void) const
 */
static PyObject *Dtool_DriveInterface_get_h_98(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DriveInterface::get_h(void) const
  PN_stdfloat return_value = (*(const DriveInterface*)local_this).get_h();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_h_98_comment =
  "C++ Interface:\n"
  "get_h(DriveInterface self)\n";
#else
static const char *Dtool_DriveInterface_get_h_98_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DriveInterface::get_p(void) const
 */
static PyObject *Dtool_DriveInterface_get_p_99(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DriveInterface::get_p(void) const
  PN_stdfloat return_value = (*(const DriveInterface*)local_this).get_p();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_p_99_comment =
  "C++ Interface:\n"
  "get_p(DriveInterface self)\n";
#else
static const char *Dtool_DriveInterface_get_p_99_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DriveInterface::get_r(void) const
 */
static PyObject *Dtool_DriveInterface_get_r_100(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DriveInterface::get_r(void) const
  PN_stdfloat return_value = (*(const DriveInterface*)local_this).get_r();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_r_100_comment =
  "C++ Interface:\n"
  "get_r(DriveInterface self)\n";
#else
static const char *Dtool_DriveInterface_get_r_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DriveInterface::set_hpr(LVecBase3 const &hpr)
 * inline void DriveInterface::set_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
 */
static PyObject *Dtool_DriveInterface_set_hpr_101(PyObject *self, PyObject *args, PyObject *kwds) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_hpr")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "hpr");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'hpr' (pos 1) not found");
      }
      // 1-inline void DriveInterface::set_hpr(LVecBase3 const &hpr)
      LVecBase3f arg_local;
      LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "DriveInterface.set_hpr", "LVecBase3f");
      }
      (*local_this).set_hpr(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void DriveInterface::set_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"h", "p", "r", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_hpr", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_hpr((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_hpr() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_hpr(const DriveInterface self, const LVecBase3f hpr)\n"
      "set_hpr(const DriveInterface self, float h, float p, float r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_hpr_101_comment =
  "C++ Interface:\n"
  "set_hpr(const DriveInterface self, const LVecBase3f hpr)\n"
  "set_hpr(const DriveInterface self, float h, float p, float r)\n"
  "\n"
  "/**\n"
  " * Directly sets the driver's orientation.\n"
  " */";
#else
static const char *Dtool_DriveInterface_set_hpr_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DriveInterface::set_h(PN_stdfloat h)
 */
static PyObject *Dtool_DriveInterface_set_h_102(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_h")) {
    return NULL;
  }
  // 1-inline void DriveInterface::set_h(PN_stdfloat h)
  if (PyNumber_Check(arg)) {
    (*local_this).set_h((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_h(const DriveInterface self, float h)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_h_102_comment =
  "C++ Interface:\n"
  "set_h(const DriveInterface self, float h)\n";
#else
static const char *Dtool_DriveInterface_set_h_102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DriveInterface::set_p(PN_stdfloat p)
 */
static PyObject *Dtool_DriveInterface_set_p_103(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_p")) {
    return NULL;
  }
  // 1-inline void DriveInterface::set_p(PN_stdfloat p)
  if (PyNumber_Check(arg)) {
    (*local_this).set_p((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_p(const DriveInterface self, float p)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_p_103_comment =
  "C++ Interface:\n"
  "set_p(const DriveInterface self, float p)\n";
#else
static const char *Dtool_DriveInterface_set_p_103_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DriveInterface::set_r(PN_stdfloat r)
 */
static PyObject *Dtool_DriveInterface_set_r_104(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_r")) {
    return NULL;
  }
  // 1-inline void DriveInterface::set_r(PN_stdfloat r)
  if (PyNumber_Check(arg)) {
    (*local_this).set_r((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_r(const DriveInterface self, float r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_r_104_comment =
  "C++ Interface:\n"
  "set_r(const DriveInterface self, float r)\n";
#else
static const char *Dtool_DriveInterface_set_r_104_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DriveInterface::set_force_roll(PN_stdfloat force_roll)
 */
static PyObject *Dtool_DriveInterface_set_force_roll_105(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_force_roll")) {
    return NULL;
  }
  // 1-void DriveInterface::set_force_roll(PN_stdfloat force_roll)
  if (PyNumber_Check(arg)) {
    (*local_this).set_force_roll((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_force_roll(const DriveInterface self, float force_roll)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_force_roll_105_comment =
  "C++ Interface:\n"
  "set_force_roll(const DriveInterface self, float force_roll)\n"
  "\n"
  "/**\n"
  " * This function is no longer used and does nothing.  It will be removed soon.\n"
  " */";
#else
static const char *Dtool_DriveInterface_set_force_roll_105_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DriveInterface::set_ignore_mouse(bool ignore_mouse)
 */
static PyObject *Dtool_DriveInterface_set_ignore_mouse_106(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_ignore_mouse")) {
    return NULL;
  }
  // 1-inline void DriveInterface::set_ignore_mouse(bool ignore_mouse)
  (*local_this).set_ignore_mouse((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ignore_mouse(const DriveInterface self, bool ignore_mouse)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_ignore_mouse_106_comment =
  "C++ Interface:\n"
  "set_ignore_mouse(const DriveInterface self, bool ignore_mouse)\n"
  "\n"
  "/**\n"
  " * Changes the state of the ignore_mouse flag.  If this flag is true, the\n"
  " * DriveInterface will ignore mouse down button events (but still recognize\n"
  " * mouse up button events); the user will not be able to start the\n"
  " * DriveInterface going again if it is stopped, but if the user is currently\n"
  " * holding down a mouse button it will not stop immediately until the user\n"
  " * eventually releases the button.\n"
  " */";
#else
static const char *Dtool_DriveInterface_set_ignore_mouse_106_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DriveInterface::get_ignore_mouse(void) const
 */
static PyObject *Dtool_DriveInterface_get_ignore_mouse_107(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DriveInterface::get_ignore_mouse(void) const
  bool return_value = (*(const DriveInterface*)local_this).get_ignore_mouse();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_ignore_mouse_107_comment =
  "C++ Interface:\n"
  "get_ignore_mouse(DriveInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the ignore_mouse flag.  See\n"
  " * set_ignore_mouse().\n"
  " */";
#else
static const char *Dtool_DriveInterface_get_ignore_mouse_107_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DriveInterface::set_force_mouse(bool force_mouse)
 */
static PyObject *Dtool_DriveInterface_set_force_mouse_108(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_force_mouse")) {
    return NULL;
  }
  // 1-inline void DriveInterface::set_force_mouse(bool force_mouse)
  (*local_this).set_force_mouse((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_force_mouse(const DriveInterface self, bool force_mouse)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_force_mouse_108_comment =
  "C++ Interface:\n"
  "set_force_mouse(const DriveInterface self, bool force_mouse)\n"
  "\n"
  "/**\n"
  " * Changes the state of the force_mouse flag.  If this flag is true, the mouse\n"
  " * button need not be held down in order to drive the avatar around.\n"
  " */";
#else
static const char *Dtool_DriveInterface_set_force_mouse_108_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DriveInterface::get_force_mouse(void) const
 */
static PyObject *Dtool_DriveInterface_get_force_mouse_109(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DriveInterface::get_force_mouse(void) const
  bool return_value = (*(const DriveInterface*)local_this).get_force_mouse();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_force_mouse_109_comment =
  "C++ Interface:\n"
  "get_force_mouse(DriveInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the force_mouse flag.  See\n"
  " * set_force_mouse().\n"
  " */";
#else
static const char *Dtool_DriveInterface_get_force_mouse_109_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DriveInterface::set_stop_this_frame(bool stop_this_frame)
 */
static PyObject *Dtool_DriveInterface_set_stop_this_frame_110(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_stop_this_frame")) {
    return NULL;
  }
  // 1-inline void DriveInterface::set_stop_this_frame(bool stop_this_frame)
  (*local_this).set_stop_this_frame((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_stop_this_frame(const DriveInterface self, bool stop_this_frame)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_stop_this_frame_110_comment =
  "C++ Interface:\n"
  "set_stop_this_frame(const DriveInterface self, bool stop_this_frame)\n"
  "\n"
  "/**\n"
  " * If stop_this_frame is true, the next time the frame is computed no motion\n"
  " * will be allowed, and then the flag is reset to false.  This can be used to\n"
  " * prevent too much movement when we know a long time has artificially\n"
  " * elapsed, for instance when we take a screenshot, without munging the clock\n"
  " * for everything else.\n"
  " */";
#else
static const char *Dtool_DriveInterface_set_stop_this_frame_110_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DriveInterface::get_stop_this_frame(void) const
 */
static PyObject *Dtool_DriveInterface_get_stop_this_frame_111(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DriveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DriveInterface::get_stop_this_frame(void) const
  bool return_value = (*(const DriveInterface*)local_this).get_stop_this_frame();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_stop_this_frame_111_comment =
  "C++ Interface:\n"
  "get_stop_this_frame(DriveInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the stop_this_frame flag.  See\n"
  " * set_stop_this_frame().\n"
  " */";
#else
static const char *Dtool_DriveInterface_get_stop_this_frame_111_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DriveInterface::set_mat(LMatrix4 const &mat)
 */
static PyObject *Dtool_DriveInterface_set_mat_112(PyObject *self, PyObject *arg) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.set_mat")) {
    return NULL;
  }
  // 1-void DriveInterface::set_mat(LMatrix4 const &mat)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DriveInterface.set_mat", "LMatrix4f");
  }
  (*local_this).set_mat(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mat(const DriveInterface self, const LMatrix4f mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_set_mat_112_comment =
  "C++ Interface:\n"
  "set_mat(const DriveInterface self, const LMatrix4f mat)\n"
  "\n"
  "/**\n"
  " * Stores the indicated transform in the DriveInterface.\n"
  " */";
#else
static const char *Dtool_DriveInterface_set_mat_112_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LMatrix4 const &DriveInterface::get_mat(void)
 */
static PyObject *Dtool_DriveInterface_get_mat_113(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.get_mat")) {
    return NULL;
  }
  // 1-LMatrix4 const &DriveInterface::get_mat(void)
  LMatrix4 const *return_value = &((*local_this).get_mat());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_mat_113_comment =
  "C++ Interface:\n"
  "get_mat(const DriveInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the current transform.\n"
  " */";
#else
static const char *Dtool_DriveInterface_get_mat_113_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DriveInterface::force_dgraph(void)
 */
static PyObject *Dtool_DriveInterface_force_dgraph_114(PyObject *self, PyObject *) {
  DriveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DriveInterface, (void **)&local_this, "DriveInterface.force_dgraph")) {
    return NULL;
  }
  // 1-void DriveInterface::force_dgraph(void)
  (*local_this).force_dgraph();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_force_dgraph_114_comment =
  "C++ Interface:\n"
  "force_dgraph(const DriveInterface self)\n"
  "\n"
  "/**\n"
  " * This is a special kludge for DriveInterface to allow us to avoid the one-\n"
  " * frame latency after a collision.  It forces an immediate partial data flow\n"
  " * for all data graph nodes below this node, causing all data nodes that\n"
  " * depend on this matrix to be updated immediately.\n"
  " */";
#else
static const char *Dtool_DriveInterface_force_dgraph_114_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DriveInterface::get_class_type(void)
 */
static PyObject *Dtool_DriveInterface_get_class_type_115(PyObject *, PyObject *) {
  // 1-static TypeHandle DriveInterface::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(DriveInterface::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DriveInterface_get_class_type_115_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DriveInterface_get_class_type_115_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DriveInterface::DriveInterface(DriveInterface const &) = default
 * DriveInterface::DriveInterface(std::string const &name = "")
 */
static int Dtool_Init_DriveInterface(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-DriveInterface::DriveInterface(std::string const &name)
      DriveInterface *return_value = new DriveInterface();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DriveInterface, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline DriveInterface::DriveInterface(DriveInterface const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:DriveInterface", (char **)keyword_list, &param0)) {
          DriveInterface const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_DriveInterface, (void **)&param0_this);
          if (param0_this != NULL) {
            DriveInterface *return_value = new DriveInterface(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DriveInterface, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 DriveInterface::DriveInterface(std::string const &name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DriveInterface", (char **)keyword_list, &param0_str, &param0_len)) {
          DriveInterface *return_value = new DriveInterface(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DriveInterface, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline DriveInterface::DriveInterface(DriveInterface const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:DriveInterface", (char **)keyword_list, &param0)) {
          CPT(DriveInterface) param0_this;
          if (Dtool_ConstCoerce_DriveInterface(param0, param0_this)) {
            DriveInterface *return_value = new DriveInterface(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DriveInterface, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: DriveInterface::DriveInterface(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DriveInterface() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DriveInterface()\n"
      "DriveInterface(const DriveInterface param0)\n"
      "DriveInterface(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_DriveInterface(PyObject *args, CPT(DriveInterface) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_DriveInterface, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-DriveInterface::DriveInterface(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      DriveInterface *return_value = new DriveInterface(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_DriveInterface(PyObject *args, PT(DriveInterface) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_DriveInterface, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-DriveInterface::DriveInterface(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      DriveInterface *return_value = new DriveInterface(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_DriveInterface(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DriveInterface) {
    printf("DriveInterface ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DriveInterface *local_this = (DriveInterface *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DriveInterface) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *)(MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_MouseInterfaceNode) {
    return (MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *)(MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *)(MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *)(MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *)(MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *)(MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *)(MouseInterfaceNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DriveInterface(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DriveInterface) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (DriveInterface*)other_this;
  }
  if (from_type == Dtool_Ptr_MouseInterfaceNode) {
    MouseInterfaceNode* other_this = (MouseInterfaceNode*)from_this;
    return (DriveInterface*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (DriveInterface*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (DriveInterface*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (DriveInterface*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DriveInterface*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (DriveInterface*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (DriveInterface*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MouseSubregion
 */
/**
 * Python function wrapper for:
 * inline PN_stdfloat MouseSubregion::get_left(void) const
 */
static PyObject *Dtool_MouseSubregion_get_left_118(PyObject *self, PyObject *) {
  MouseSubregion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseSubregion, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat MouseSubregion::get_left(void) const
  PN_stdfloat return_value = (*(const MouseSubregion*)local_this).get_left();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseSubregion_get_left_118_comment =
  "C++ Interface:\n"
  "get_left(MouseSubregion self)\n"
  "\n"
  "/**\n"
  " * Retrieves the x coordinate of the left edge of the rectangle within the\n"
  " * window.  This number will be in the range [0..1].\n"
  " */";
#else
static const char *Dtool_MouseSubregion_get_left_118_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat MouseSubregion::get_right(void) const
 */
static PyObject *Dtool_MouseSubregion_get_right_119(PyObject *self, PyObject *) {
  MouseSubregion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseSubregion, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat MouseSubregion::get_right(void) const
  PN_stdfloat return_value = (*(const MouseSubregion*)local_this).get_right();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseSubregion_get_right_119_comment =
  "C++ Interface:\n"
  "get_right(MouseSubregion self)\n"
  "\n"
  "/**\n"
  " * Retrieves the x coordinate of the right edge of the rectangle within the\n"
  " * window.  This number will be in the range [0..1].\n"
  " */";
#else
static const char *Dtool_MouseSubregion_get_right_119_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat MouseSubregion::get_bottom(void) const
 */
static PyObject *Dtool_MouseSubregion_get_bottom_120(PyObject *self, PyObject *) {
  MouseSubregion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseSubregion, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat MouseSubregion::get_bottom(void) const
  PN_stdfloat return_value = (*(const MouseSubregion*)local_this).get_bottom();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseSubregion_get_bottom_120_comment =
  "C++ Interface:\n"
  "get_bottom(MouseSubregion self)\n"
  "\n"
  "/**\n"
  " * Retrieves the y coordinate of the bottom edge of the rectangle within the\n"
  " * window.  This number will be in the range [0..1].\n"
  " */";
#else
static const char *Dtool_MouseSubregion_get_bottom_120_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat MouseSubregion::get_top(void) const
 */
static PyObject *Dtool_MouseSubregion_get_top_121(PyObject *self, PyObject *) {
  MouseSubregion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseSubregion, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat MouseSubregion::get_top(void) const
  PN_stdfloat return_value = (*(const MouseSubregion*)local_this).get_top();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseSubregion_get_top_121_comment =
  "C++ Interface:\n"
  "get_top(MouseSubregion self)\n"
  "\n"
  "/**\n"
  " * Retrieves the y coordinate of the top edge of the rectangle within the\n"
  " * window.  This number will be in the range [0..1].\n"
  " */";
#else
static const char *Dtool_MouseSubregion_get_top_121_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseSubregion::set_dimensions(PN_stdfloat l, PN_stdfloat r, PN_stdfloat b, PN_stdfloat t)
 */
static PyObject *Dtool_MouseSubregion_set_dimensions_122(PyObject *self, PyObject *args, PyObject *kwds) {
  MouseSubregion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseSubregion, (void **)&local_this, "MouseSubregion.set_dimensions")) {
    return NULL;
  }
  // 1-inline void MouseSubregion::set_dimensions(PN_stdfloat l, PN_stdfloat r, PN_stdfloat b, PN_stdfloat t)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"l", "r", "b", "t", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_dimensions", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).set_dimensions((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_dimensions(const MouseSubregion self, float l, float r, float b, float t)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseSubregion_set_dimensions_122_comment =
  "C++ Interface:\n"
  "set_dimensions(const MouseSubregion self, float l, float r, float b, float t)\n"
  "\n"
  "/**\n"
  " * Changes the region of the window in which the mouse is considered to be\n"
  " * active.  The parameters are identical to those for a DisplayRegion: they\n"
  " * range from 0 to 1, where 0,0 is the lower left corner and 1,1 is the upper\n"
  " * right; (0, 1, 0, 1) represents the whole window.\n"
  " */";
#else
static const char *Dtool_MouseSubregion_set_dimensions_122_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MouseSubregion::get_class_type(void)
 */
static PyObject *Dtool_MouseSubregion_get_class_type_123(PyObject *, PyObject *) {
  // 1-static TypeHandle MouseSubregion::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(MouseSubregion::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseSubregion_get_class_type_123_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MouseSubregion_get_class_type_123_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline MouseSubregion::MouseSubregion(MouseSubregion const &) = default
 * MouseSubregion::MouseSubregion(std::string const &name)
 */
static int Dtool_Init_MouseSubregion(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "MouseSubregion() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline MouseSubregion::MouseSubregion(MouseSubregion const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:MouseSubregion", (char **)keyword_list, &param0)) {
      MouseSubregion const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_MouseSubregion, (void **)&param0_this);
      if (param0_this != NULL) {
        MouseSubregion *return_value = new MouseSubregion(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MouseSubregion, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 MouseSubregion::MouseSubregion(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:MouseSubregion", (char **)keyword_list, &param0_str, &param0_len)) {
      MouseSubregion *return_value = new MouseSubregion(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MouseSubregion, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline MouseSubregion::MouseSubregion(MouseSubregion const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:MouseSubregion", (char **)keyword_list, &param0)) {
      CPT(MouseSubregion) param0_this;
      if (Dtool_ConstCoerce_MouseSubregion(param0, param0_this)) {
        MouseSubregion *return_value = new MouseSubregion(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MouseSubregion, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: MouseSubregion::MouseSubregion(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MouseSubregion(const MouseSubregion param0)\n"
      "MouseSubregion(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_MouseSubregion(PyObject *args, CPT(MouseSubregion) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_MouseSubregion, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-MouseSubregion::MouseSubregion(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      MouseSubregion *return_value = new MouseSubregion(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_MouseSubregion(PyObject *args, PT(MouseSubregion) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_MouseSubregion, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-MouseSubregion::MouseSubregion(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      MouseSubregion *return_value = new MouseSubregion(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_MouseSubregion(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MouseSubregion) {
    printf("MouseSubregion ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MouseSubregion *local_this = (MouseSubregion *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MouseSubregion) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *)(MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_MouseInterfaceNode) {
    return (MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *)(MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *)(MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *)(MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *)(MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *)(MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *)(MouseInterfaceNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MouseSubregion(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MouseSubregion) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (MouseSubregion*)other_this;
  }
  if (from_type == Dtool_Ptr_MouseInterfaceNode) {
    MouseInterfaceNode* other_this = (MouseInterfaceNode*)from_this;
    return (MouseSubregion*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MouseSubregion*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (MouseSubregion*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MouseSubregion*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MouseSubregion*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MouseSubregion*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MouseSubregion*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MouseWatcherRegion
 */
/**
 * Python function wrapper for:
 * inline void MouseWatcherRegion::set_frame(LVecBase4 const &frame)
 * inline void MouseWatcherRegion::set_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 */
static PyObject *Dtool_MouseWatcherRegion_set_frame_132(PyObject *self, PyObject *args, PyObject *kwds) {
  MouseWatcherRegion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcherRegion, (void **)&local_this, "MouseWatcherRegion.set_frame")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "frame");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'frame' (pos 1) not found");
      }
      // 1-inline void MouseWatcherRegion::set_frame(LVecBase4 const &frame)
      LVecBase4f arg_local;
      LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "MouseWatcherRegion.set_frame", "LVecBase4f");
      }
      (*local_this).set_frame(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void MouseWatcherRegion::set_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"left", "right", "bottom", "top", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_frame", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_frame((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_frame() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame(const MouseWatcherRegion self, const LVecBase4f frame)\n"
      "set_frame(const MouseWatcherRegion self, float left, float right, float bottom, float top)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherRegion_set_frame_132_comment =
  "C++ Interface:\n"
  "set_frame(const MouseWatcherRegion self, const LVecBase4f frame)\n"
  "set_frame(const MouseWatcherRegion self, float left, float right, float bottom, float top)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_MouseWatcherRegion_set_frame_132_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 const &MouseWatcherRegion::get_frame(void) const
 */
static PyObject *Dtool_MouseWatcherRegion_get_frame_133(PyObject *self, PyObject *) {
  MouseWatcherRegion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherRegion, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4 const &MouseWatcherRegion::get_frame(void) const
  LVecBase4 const *return_value = &((*(const MouseWatcherRegion*)local_this).get_frame());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherRegion_get_frame_133_comment =
  "C++ Interface:\n"
  "get_frame(MouseWatcherRegion self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_MouseWatcherRegion_get_frame_133_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat MouseWatcherRegion::get_area(void) const
 */
static PyObject *Dtool_MouseWatcherRegion_get_area_134(PyObject *self, PyObject *) {
  MouseWatcherRegion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherRegion, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat MouseWatcherRegion::get_area(void) const
  PN_stdfloat return_value = (*(const MouseWatcherRegion*)local_this).get_area();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherRegion_get_area_134_comment =
  "C++ Interface:\n"
  "get_area(MouseWatcherRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the area of the rectangular region.\n"
  " */";
#else
static const char *Dtool_MouseWatcherRegion_get_area_134_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcherRegion::set_sort(int sort)
 */
static PyObject *Dtool_MouseWatcherRegion_set_sort_135(PyObject *self, PyObject *arg) {
  MouseWatcherRegion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcherRegion, (void **)&local_this, "MouseWatcherRegion.set_sort")) {
    return NULL;
  }
  // 1-inline void MouseWatcherRegion::set_sort(int sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_sort((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sort(const MouseWatcherRegion self, int sort)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherRegion_set_sort_135_comment =
  "C++ Interface:\n"
  "set_sort(const MouseWatcherRegion self, int sort)\n"
  "\n"
  "/**\n"
  " * Changes the sorting order of this particular region.  The sorting order is\n"
  " * used to resolve conflicts in the case of overlapping region; the region\n"
  " * with the highest sort value will be preferred, and between regions of the\n"
  " * same sort value, the smallest region will be preferred.  The default\n"
  " * sorting order, if none is explicitly specified, is 0.\n"
  " */";
#else
static const char *Dtool_MouseWatcherRegion_set_sort_135_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int MouseWatcherRegion::get_sort(void) const
 */
static PyObject *Dtool_MouseWatcherRegion_get_sort_136(PyObject *self, PyObject *) {
  MouseWatcherRegion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherRegion, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int MouseWatcherRegion::get_sort(void) const
  int return_value = (*(const MouseWatcherRegion*)local_this).get_sort();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherRegion_get_sort_136_comment =
  "C++ Interface:\n"
  "get_sort(MouseWatcherRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the current sorting order of this region.  See set_sort().\n"
  " */";
#else
static const char *Dtool_MouseWatcherRegion_get_sort_136_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcherRegion::set_active(bool active)
 */
static PyObject *Dtool_MouseWatcherRegion_set_active_137(PyObject *self, PyObject *arg) {
  MouseWatcherRegion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcherRegion, (void **)&local_this, "MouseWatcherRegion.set_active")) {
    return NULL;
  }
  // 1-inline void MouseWatcherRegion::set_active(bool active)
  (*local_this).set_active((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_active(const MouseWatcherRegion self, bool active)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherRegion_set_active_137_comment =
  "C++ Interface:\n"
  "set_active(const MouseWatcherRegion self, bool active)\n"
  "\n"
  "/**\n"
  " * Sets whether the region is active or not.  If it is not active, the\n"
  " * MouseWatcher will never consider the mouse to be over the region.  The\n"
  " * region might still receive keypress events if its set_keyboard() flag is\n"
  " * true.\n"
  " */";
#else
static const char *Dtool_MouseWatcherRegion_set_active_137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool MouseWatcherRegion::get_active(void) const
 */
static PyObject *Dtool_MouseWatcherRegion_get_active_138(PyObject *self, PyObject *) {
  MouseWatcherRegion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherRegion, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool MouseWatcherRegion::get_active(void) const
  bool return_value = (*(const MouseWatcherRegion*)local_this).get_active();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherRegion_get_active_138_comment =
  "C++ Interface:\n"
  "get_active(MouseWatcherRegion self)\n"
  "\n"
  "/**\n"
  " * Returns whether the region is active or not.  See set_active().\n"
  " */";
#else
static const char *Dtool_MouseWatcherRegion_get_active_138_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcherRegion::set_keyboard(bool keyboard)
 */
static PyObject *Dtool_MouseWatcherRegion_set_keyboard_139(PyObject *self, PyObject *arg) {
  MouseWatcherRegion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcherRegion, (void **)&local_this, "MouseWatcherRegion.set_keyboard")) {
    return NULL;
  }
  // 1-inline void MouseWatcherRegion::set_keyboard(bool keyboard)
  (*local_this).set_keyboard((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_keyboard(const MouseWatcherRegion self, bool keyboard)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherRegion_set_keyboard_139_comment =
  "C++ Interface:\n"
  "set_keyboard(const MouseWatcherRegion self, bool keyboard)\n"
  "\n"
  "/**\n"
  " * Sets whether the region is interested in global keyboard events.  If this\n"
  " * is true, then any keyboard button events will be passed to press() and\n"
  " * release() regardless of the position of the mouse onscreen; otherwise,\n"
  " * these events will only be passed if the mouse is over the region.\n"
  " */";
#else
static const char *Dtool_MouseWatcherRegion_set_keyboard_139_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool MouseWatcherRegion::get_keyboard(void) const
 */
static PyObject *Dtool_MouseWatcherRegion_get_keyboard_140(PyObject *self, PyObject *) {
  MouseWatcherRegion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherRegion, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool MouseWatcherRegion::get_keyboard(void) const
  bool return_value = (*(const MouseWatcherRegion*)local_this).get_keyboard();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherRegion_get_keyboard_140_comment =
  "C++ Interface:\n"
  "get_keyboard(MouseWatcherRegion self)\n"
  "\n"
  "/**\n"
  " * Returns whether the region is interested in global keyboard events; see\n"
  " * set_keyboard().\n"
  " */";
#else
static const char *Dtool_MouseWatcherRegion_get_keyboard_140_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcherRegion::set_suppress_flags(int suppress_flags)
 */
static PyObject *Dtool_MouseWatcherRegion_set_suppress_flags_142(PyObject *self, PyObject *arg) {
  MouseWatcherRegion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcherRegion, (void **)&local_this, "MouseWatcherRegion.set_suppress_flags")) {
    return NULL;
  }
  // 1-inline void MouseWatcherRegion::set_suppress_flags(int suppress_flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_suppress_flags((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_suppress_flags(const MouseWatcherRegion self, int suppress_flags)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherRegion_set_suppress_flags_142_comment =
  "C++ Interface:\n"
  "set_suppress_flags(const MouseWatcherRegion self, int suppress_flags)\n"
  "\n"
  "/**\n"
  " * Sets which events are suppressed when the mouse is over the region.  This\n"
  " * is the union of zero or more various SF_* values.  Normally, this is 0,\n"
  " * indicating that no events are suppressed.\n"
  " *\n"
  " * If you set this to a non-zero value, for instance SF_mouse_position, then\n"
  " * the mouse position will not be sent along the data graph when the mouse is\n"
  " * over this particular region.\n"
  " */";
#else
static const char *Dtool_MouseWatcherRegion_set_suppress_flags_142_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int MouseWatcherRegion::get_suppress_flags(void) const
 */
static PyObject *Dtool_MouseWatcherRegion_get_suppress_flags_143(PyObject *self, PyObject *) {
  MouseWatcherRegion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherRegion, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int MouseWatcherRegion::get_suppress_flags(void) const
  int return_value = (*(const MouseWatcherRegion*)local_this).get_suppress_flags();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherRegion_get_suppress_flags_143_comment =
  "C++ Interface:\n"
  "get_suppress_flags(MouseWatcherRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the current suppress_flags.  See set_suppress_flags().\n"
  " */";
#else
static const char *Dtool_MouseWatcherRegion_get_suppress_flags_143_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MouseWatcherRegion::output(ostream &out) const
 */
static PyObject *Dtool_MouseWatcherRegion_output_144(PyObject *self, PyObject *arg) {
  MouseWatcherRegion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherRegion, (void **)&local_this)) {
    return NULL;
  }
  // 1-void MouseWatcherRegion::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "MouseWatcherRegion.output", false, true);
  if (arg_this != NULL) {
    (*(const MouseWatcherRegion*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(MouseWatcherRegion self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherRegion_output_144_comment =
  "C++ Interface:\n"
  "output(MouseWatcherRegion self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_MouseWatcherRegion_output_144_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MouseWatcherRegion::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_MouseWatcherRegion_write_145(PyObject *self, PyObject *args, PyObject *kwds) {
  MouseWatcherRegion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherRegion, (void **)&local_this)) {
    return NULL;
  }
  // 1-void MouseWatcherRegion::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "MouseWatcherRegion.write", false, true);
    if (param1_this != NULL) {
      (*(const MouseWatcherRegion*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(MouseWatcherRegion self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherRegion_write_145_comment =
  "C++ Interface:\n"
  "write(MouseWatcherRegion self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_MouseWatcherRegion_write_145_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MouseWatcherRegion::get_class_type(void)
 */
static PyObject *Dtool_MouseWatcherRegion_get_class_type_146(PyObject *, PyObject *) {
  // 1-static TypeHandle MouseWatcherRegion::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(MouseWatcherRegion::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherRegion_get_class_type_146_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MouseWatcherRegion_get_class_type_146_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypedWritableReferenceCount *MouseWatcherRegion::upcast_to_TypedWritableReferenceCount(void)
 */
static PyObject *Dtool_MouseWatcherRegion_upcast_to_TypedWritableReferenceCount_126(PyObject *self, PyObject *) {
  MouseWatcherRegion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcherRegion, (void **)&local_this, "MouseWatcherRegion.upcast_to_TypedWritableReferenceCount")) {
    return NULL;
  }
  // 1-TypedWritableReferenceCount *MouseWatcherRegion::upcast_to_TypedWritableReferenceCount(void)
  TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherRegion_upcast_to_TypedWritableReferenceCount_126_comment =
  "C++ Interface:\n"
  "upcast_to_TypedWritableReferenceCount(const MouseWatcherRegion self)\n"
  "\n"
  "upcast from MouseWatcherRegion to TypedWritableReferenceCount";
#else
static const char *Dtool_MouseWatcherRegion_upcast_to_TypedWritableReferenceCount_126_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Namable *MouseWatcherRegion::upcast_to_Namable(void)
 */
static PyObject *Dtool_MouseWatcherRegion_upcast_to_Namable_129(PyObject *self, PyObject *) {
  MouseWatcherRegion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcherRegion, (void **)&local_this, "MouseWatcherRegion.upcast_to_Namable")) {
    return NULL;
  }
  // 1-Namable *MouseWatcherRegion::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherRegion_upcast_to_Namable_129_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const MouseWatcherRegion self)\n"
  "\n"
  "upcast from MouseWatcherRegion to Namable";
#else
static const char *Dtool_MouseWatcherRegion_upcast_to_Namable_129_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline MouseWatcherRegion::MouseWatcherRegion(MouseWatcherRegion const &) = default
 * inline MouseWatcherRegion::MouseWatcherRegion(std::string const &name, LVecBase4 const &frame)
 * inline MouseWatcherRegion::MouseWatcherRegion(std::string const &name, PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 */
static int Dtool_Init_MouseWatcherRegion(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline MouseWatcherRegion::MouseWatcherRegion(MouseWatcherRegion const &) = default
      CPT(MouseWatcherRegion) arg_this;
      if (!Dtool_ConstCoerce_MouseWatcherRegion(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "MouseWatcherRegion.MouseWatcherRegion", "MouseWatcherRegion");
        return -1;
      }
      MouseWatcherRegion *return_value = new MouseWatcherRegion(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MouseWatcherRegion, true, false);
    }
    break;
  case 2:
    {
      // 1-inline MouseWatcherRegion::MouseWatcherRegion(std::string const &name, LVecBase4 const &frame)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      static const char *keyword_list[] = {"name", "frame", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:MouseWatcherRegion", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
        LVecBase4f param1_local;
        LVecBase4 const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "MouseWatcherRegion.MouseWatcherRegion", "LVecBase4f");
          return -1;
        }
        MouseWatcherRegion *return_value = new MouseWatcherRegion(std::string(param0_str, param0_len), *param1_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MouseWatcherRegion, true, false);
      }
    }
    break;
  case 5:
    {
      // 1-inline MouseWatcherRegion::MouseWatcherRegion(std::string const &name, PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"name", "left", "right", "bottom", "top", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#ffff:MouseWatcherRegion", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
        MouseWatcherRegion *return_value = new MouseWatcherRegion(std::string(param0_str, param0_len), (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MouseWatcherRegion, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "MouseWatcherRegion() takes 1, 2 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MouseWatcherRegion(const MouseWatcherRegion param0)\n"
      "MouseWatcherRegion(str name, const LVecBase4f frame)\n"
      "MouseWatcherRegion(str name, float left, float right, float bottom, float top)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_MouseWatcherRegion(PyObject *args, CPT(MouseWatcherRegion) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_MouseWatcherRegion, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline MouseWatcherRegion::MouseWatcherRegion(std::string const &name, LVecBase4 const &frame)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        if (PyArg_ParseTuple(args, "s#O:MouseWatcherRegion", &param0_str, &param0_len, &param1)) {
          LVecBase4 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase4f, (void **)&param1_this);
          if (param1_this != NULL) {
            MouseWatcherRegion *return_value = new MouseWatcherRegion(std::string(param0_str, param0_len), *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 5: {
        // 1-inline MouseWatcherRegion::MouseWatcherRegion(std::string const &name, PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        float param1;
        float param2;
        float param3;
        float param4;
        if (PyArg_ParseTuple(args, "s#ffff:MouseWatcherRegion", &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
          MouseWatcherRegion *return_value = new MouseWatcherRegion(std::string(param0_str, param0_len), (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_MouseWatcherRegion(PyObject *args, PT(MouseWatcherRegion) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_MouseWatcherRegion, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline MouseWatcherRegion::MouseWatcherRegion(std::string const &name, LVecBase4 const &frame)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        if (PyArg_ParseTuple(args, "s#O:MouseWatcherRegion", &param0_str, &param0_len, &param1)) {
          LVecBase4 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase4f, (void **)&param1_this);
          if (param1_this != NULL) {
            MouseWatcherRegion *return_value = new MouseWatcherRegion(std::string(param0_str, param0_len), *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 5: {
        // 1-inline MouseWatcherRegion::MouseWatcherRegion(std::string const &name, PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        float param1;
        float param2;
        float param3;
        float param4;
        if (PyArg_ParseTuple(args, "s#ffff:MouseWatcherRegion", &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
          MouseWatcherRegion *return_value = new MouseWatcherRegion(std::string(param0_str, param0_len), (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_MouseWatcherRegion(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MouseWatcherRegion) {
    printf("MouseWatcherRegion ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MouseWatcherRegion *local_this = (MouseWatcherRegion *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MouseWatcherRegion) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MouseWatcherRegion(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MouseWatcherRegion) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MouseWatcherRegion*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MouseWatcherRegion*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MouseWatcherRegion*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MouseWatcherRegion*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MouseWatcherRegion*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MouseWatcherBase
 */
/**
 * Python function wrapper for:
 * void MouseWatcherBase::add_region(MouseWatcherRegion *region)
 */
static PyObject *Dtool_MouseWatcherBase_add_region_150(PyObject *self, PyObject *arg) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcherBase, (void **)&local_this, "MouseWatcherBase.add_region")) {
    return NULL;
  }
  // 1-void MouseWatcherBase::add_region(MouseWatcherRegion *region)
  PT(MouseWatcherRegion) arg_this;
  if (!Dtool_Coerce_MouseWatcherRegion(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "MouseWatcherBase.add_region", "MouseWatcherRegion");
  }
  (*local_this).add_region(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_region(const MouseWatcherBase self, MouseWatcherRegion region)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherBase_add_region_150_comment =
  "C++ Interface:\n"
  "add_region(const MouseWatcherBase self, MouseWatcherRegion region)\n"
  "\n"
  "/**\n"
  " * Adds the indicated region to the set of regions in the group.  It is an\n"
  " * error to add the same region to the set more than once.\n"
  " */";
#else
static const char *Dtool_MouseWatcherBase_add_region_150_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool MouseWatcherBase::has_region(MouseWatcherRegion *region) const
 */
static PyObject *Dtool_MouseWatcherBase_has_region_151(PyObject *self, PyObject *arg) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool MouseWatcherBase::has_region(MouseWatcherRegion *region) const
  PT(MouseWatcherRegion) arg_this;
  if (!Dtool_Coerce_MouseWatcherRegion(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "MouseWatcherBase.has_region", "MouseWatcherRegion");
  }
  bool return_value = (*(const MouseWatcherBase*)local_this).has_region(MOVE(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_region(MouseWatcherBase self, MouseWatcherRegion region)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherBase_has_region_151_comment =
  "C++ Interface:\n"
  "has_region(MouseWatcherBase self, MouseWatcherRegion region)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated region has already been added to the\n"
  " * MouseWatcherBase, false otherwise.\n"
  " */";
#else
static const char *Dtool_MouseWatcherBase_has_region_151_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool MouseWatcherBase::remove_region(MouseWatcherRegion *region)
 */
static PyObject *Dtool_MouseWatcherBase_remove_region_152(PyObject *self, PyObject *arg) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcherBase, (void **)&local_this, "MouseWatcherBase.remove_region")) {
    return NULL;
  }
  // 1-bool MouseWatcherBase::remove_region(MouseWatcherRegion *region)
  PT(MouseWatcherRegion) arg_this;
  if (!Dtool_Coerce_MouseWatcherRegion(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "MouseWatcherBase.remove_region", "MouseWatcherRegion");
  }
  bool return_value = (*local_this).remove_region(MOVE(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_region(const MouseWatcherBase self, MouseWatcherRegion region)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherBase_remove_region_152_comment =
  "C++ Interface:\n"
  "remove_region(const MouseWatcherBase self, MouseWatcherRegion region)\n"
  "\n"
  "/**\n"
  " * Removes the indicated region from the group.  Returns true if it was\n"
  " * successfully removed, or false if it wasn't there in the first place.\n"
  " */";
#else
static const char *Dtool_MouseWatcherBase_remove_region_152_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * MouseWatcherRegion *MouseWatcherBase::find_region(std::string const &name) const
 */
static PyObject *Dtool_MouseWatcherBase_find_region_153(PyObject *self, PyObject *arg) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-MouseWatcherRegion *MouseWatcherBase::find_region(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    MouseWatcherRegion *return_value = (*(const MouseWatcherBase*)local_this).find_region(std::string(param1_str, param1_len));
    if (return_value != (MouseWatcherRegion *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (MouseWatcherRegion *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_MouseWatcherRegion, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_region(MouseWatcherBase self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherBase_find_region_153_comment =
  "C++ Interface:\n"
  "find_region(MouseWatcherBase self, str name)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the first region found with the indicated name.  If\n"
  " * multiple regions share the same name, the one that is returned is\n"
  " * indeterminate.\n"
  " */";
#else
static const char *Dtool_MouseWatcherBase_find_region_153_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MouseWatcherBase::clear_regions(void)
 */
static PyObject *Dtool_MouseWatcherBase_clear_regions_154(PyObject *self, PyObject *) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcherBase, (void **)&local_this, "MouseWatcherBase.clear_regions")) {
    return NULL;
  }
  // 1-void MouseWatcherBase::clear_regions(void)
  (*local_this).clear_regions();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherBase_clear_regions_154_comment =
  "C++ Interface:\n"
  "clear_regions(const MouseWatcherBase self)\n"
  "\n"
  "/**\n"
  " * Removes all the regions from the group.\n"
  " */";
#else
static const char *Dtool_MouseWatcherBase_clear_regions_154_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MouseWatcherBase::sort_regions(void)
 */
static PyObject *Dtool_MouseWatcherBase_sort_regions_155(PyObject *self, PyObject *) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcherBase, (void **)&local_this, "MouseWatcherBase.sort_regions")) {
    return NULL;
  }
  // 1-void MouseWatcherBase::sort_regions(void)
  (*local_this).sort_regions();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherBase_sort_regions_155_comment =
  "C++ Interface:\n"
  "sort_regions(const MouseWatcherBase self)\n"
  "\n"
  "/**\n"
  " * Sorts all the regions in this group into pointer order.\n"
  " */";
#else
static const char *Dtool_MouseWatcherBase_sort_regions_155_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool MouseWatcherBase::is_sorted(void) const
 */
static PyObject *Dtool_MouseWatcherBase_is_sorted_156(PyObject *self, PyObject *) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool MouseWatcherBase::is_sorted(void) const
  bool return_value = (*(const MouseWatcherBase*)local_this).is_sorted();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherBase_is_sorted_156_comment =
  "C++ Interface:\n"
  "is_sorted(MouseWatcherBase self)\n"
  "\n"
  "/**\n"
  " * Returns true if the group has already been sorted, false otherwise.\n"
  " */";
#else
static const char *Dtool_MouseWatcherBase_is_sorted_156_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int MouseWatcherBase::get_num_regions(void) const
 */
static PyObject *Dtool_MouseWatcherBase_get_num_regions_158(PyObject *self, PyObject *) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-int MouseWatcherBase::get_num_regions(void) const
  int return_value = (*(const MouseWatcherBase*)local_this).get_num_regions();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherBase_get_num_regions_158_comment =
  "C++ Interface:\n"
  "get_num_regions(MouseWatcherBase self)\n"
  "\n"
  "/**\n"
  " * Returns the number of regions in the group.\n"
  " */";
#else
static const char *Dtool_MouseWatcherBase_get_num_regions_158_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * MouseWatcherRegion *MouseWatcherBase::get_region(int n) const
 */
static PyObject *Dtool_MouseWatcherBase_get_region_159(PyObject *self, PyObject *arg) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-MouseWatcherRegion *MouseWatcherBase::get_region(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    MouseWatcherRegion *return_value = (*(const MouseWatcherBase*)local_this).get_region((int)arg_val);
    if (return_value != (MouseWatcherRegion *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (MouseWatcherRegion *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_MouseWatcherRegion, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_region(MouseWatcherBase self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherBase_get_region_159_comment =
  "C++ Interface:\n"
  "get_region(MouseWatcherBase self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth region of the group; returns NULL if there is no nth\n"
  " * region.  Note that this is not thread-safe; another thread might have\n"
  " * removed the nth region before you called this method.\n"
  " */";
#else
static const char *Dtool_MouseWatcherBase_get_region_159_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MouseWatcherBase::output(ostream &out) const
 */
static PyObject *Dtool_MouseWatcherBase_output_163(PyObject *self, PyObject *arg) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-void MouseWatcherBase::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "MouseWatcherBase.output", false, true);
  if (arg_this != NULL) {
    (*(const MouseWatcherBase*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(MouseWatcherBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherBase_output_163_comment =
  "C++ Interface:\n"
  "output(MouseWatcherBase self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_MouseWatcherBase_output_163_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MouseWatcherBase::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_MouseWatcherBase_write_164(PyObject *self, PyObject *args, PyObject *kwds) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-void MouseWatcherBase::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "MouseWatcherBase.write", false, true);
    if (param1_this != NULL) {
      (*(const MouseWatcherBase*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(MouseWatcherBase self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherBase_write_164_comment =
  "C++ Interface:\n"
  "write(MouseWatcherBase self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_MouseWatcherBase_write_164_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MouseWatcherBase::show_regions(NodePath const &render2d, std::string const &bin_name, int draw_order)
 */
static PyObject *Dtool_MouseWatcherBase_show_regions_165(PyObject *self, PyObject *args, PyObject *kwds) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcherBase, (void **)&local_this, "MouseWatcherBase.show_regions")) {
    return NULL;
  }
  // 1-void MouseWatcherBase::show_regions(NodePath const &render2d, std::string const &bin_name, int draw_order)
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  int param3;
  static const char *keyword_list[] = {"render2d", "bin_name", "draw_order", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#i:show_regions", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "MouseWatcherBase.show_regions", true, true);
    if (param1_this != NULL) {
      (*local_this).show_regions(*param1_this, std::string(param2_str, param2_len), (int)param3);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "show_regions(const MouseWatcherBase self, const NodePath render2d, str bin_name, int draw_order)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherBase_show_regions_165_comment =
  "C++ Interface:\n"
  "show_regions(const MouseWatcherBase self, const NodePath render2d, str bin_name, int draw_order)\n"
  "\n"
  "/**\n"
  " * Enables the visualization of all of the regions handled by this\n"
  " * MouseWatcherBase.  The supplied NodePath should be the root of the 2-d\n"
  " * scene graph for the window.\n"
  " */";
#else
static const char *Dtool_MouseWatcherBase_show_regions_165_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MouseWatcherBase::set_color(LColor const &color)
 */
static PyObject *Dtool_MouseWatcherBase_set_color_166(PyObject *self, PyObject *arg) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcherBase, (void **)&local_this, "MouseWatcherBase.set_color")) {
    return NULL;
  }
  // 1-void MouseWatcherBase::set_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "MouseWatcherBase.set_color", "LVecBase4f");
  }
  (*local_this).set_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color(const MouseWatcherBase self, const LVecBase4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherBase_set_color_166_comment =
  "C++ Interface:\n"
  "set_color(const MouseWatcherBase self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Specifies the color used to draw the region rectangles for the regions\n"
  " * visualized by show_regions().\n"
  " */";
#else
static const char *Dtool_MouseWatcherBase_set_color_166_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MouseWatcherBase::hide_regions(void)
 */
static PyObject *Dtool_MouseWatcherBase_hide_regions_167(PyObject *self, PyObject *) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcherBase, (void **)&local_this, "MouseWatcherBase.hide_regions")) {
    return NULL;
  }
  // 1-void MouseWatcherBase::hide_regions(void)
  (*local_this).hide_regions();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherBase_hide_regions_167_comment =
  "C++ Interface:\n"
  "hide_regions(const MouseWatcherBase self)\n"
  "\n"
  "/**\n"
  " * Stops the visualization created by a previous call to show_regions().\n"
  " */";
#else
static const char *Dtool_MouseWatcherBase_hide_regions_167_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MouseWatcherBase::update_regions(void)
 */
static PyObject *Dtool_MouseWatcherBase_update_regions_168(PyObject *self, PyObject *) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcherBase, (void **)&local_this, "MouseWatcherBase.update_regions")) {
    return NULL;
  }
  // 1-void MouseWatcherBase::update_regions(void)
  (*local_this).update_regions();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherBase_update_regions_168_comment =
  "C++ Interface:\n"
  "update_regions(const MouseWatcherBase self)\n"
  "\n"
  "/**\n"
  " * Refreshes the visualization created by show_regions().\n"
  " */";
#else
static const char *Dtool_MouseWatcherBase_update_regions_168_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MouseWatcherBase::get_class_type(void)
 */
static PyObject *Dtool_MouseWatcherBase_get_class_type_169(PyObject *, PyObject *) {
  // 1-static TypeHandle MouseWatcherBase::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(MouseWatcherBase::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherBase_get_class_type_169_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MouseWatcherBase_get_class_type_169_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * MouseWatcherGroup *MouseWatcherBase::downcast_to_MouseWatcherGroup(void)
 */
static PyObject *Dtool_MouseWatcherBase_downcast_to_MouseWatcherGroup_172(PyObject *self, PyObject *) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcherBase, (void **)&local_this, "MouseWatcherBase.downcast_to_MouseWatcherGroup")) {
    return NULL;
  }
  // 1-MouseWatcherGroup *MouseWatcherBase::downcast_to_MouseWatcherGroup(void)
  MouseWatcherGroup *return_value = (MouseWatcherGroup *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_MouseWatcherGroup, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherBase_downcast_to_MouseWatcherGroup_172_comment =
  "C++ Interface:\n"
  "downcast_to_MouseWatcherGroup(const MouseWatcherBase self)\n"
  "\n"
  "downcast from MouseWatcherBase to MouseWatcherGroup";
#else
static const char *Dtool_MouseWatcherBase_downcast_to_MouseWatcherGroup_172_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * MouseWatcher *MouseWatcherBase::downcast_to_MouseWatcher(void)
 */
static PyObject *Dtool_MouseWatcherBase_downcast_to_MouseWatcher_182(PyObject *self, PyObject *) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcherBase, (void **)&local_this, "MouseWatcherBase.downcast_to_MouseWatcher")) {
    return NULL;
  }
  // 1-MouseWatcher *MouseWatcherBase::downcast_to_MouseWatcher(void)
  MouseWatcher *return_value = (MouseWatcher *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_MouseWatcher, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherBase_downcast_to_MouseWatcher_182_comment =
  "C++ Interface:\n"
  "downcast_to_MouseWatcher(const MouseWatcherBase self)\n"
  "\n"
  "downcast from MouseWatcherBase to MouseWatcher";
#else
static const char *Dtool_MouseWatcherBase_downcast_to_MouseWatcher_182_comment = NULL;
#endif

static PyObject *Dtool_MouseWatcherBase_sorted_Getter(PyObject *self, void *) {
  const MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherBase, (void **)&local_this)) {
    return NULL;
  }

  // 1-bool MouseWatcherBase::is_sorted(void) const
  bool return_value = (*(const MouseWatcherBase*)local_this).is_sorted();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * sequence length function for property MouseWatcherBase::regions
 */
static Py_ssize_t Dtool_MouseWatcherBase_regions_Len(PyObject *self) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherBase, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_regions();
}

/**
 * sequence getter for property MouseWatcherBase::regions
 */
static PyObject *Dtool_MouseWatcherBase_regions_Getitem(PyObject *self, Py_ssize_t index) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherBase, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_regions()) {
    PyErr_SetString(PyExc_IndexError, "MouseWatcherBase.regions[] index out of range");
    return NULL;
  }
  // 1-MouseWatcherRegion *MouseWatcherBase::get_region(int n) const
  MouseWatcherRegion *return_value = (*(const MouseWatcherBase*)local_this).get_region(index);
  if (return_value != (MouseWatcherRegion *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (MouseWatcherRegion *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_MouseWatcherRegion, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_region(MouseWatcherBase self, index)\n");
  }
}

static PyObject *Dtool_MouseWatcherBase_regions_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_MouseWatcherBase_regions_Len;
  wrap->_getitem_func = &Dtool_MouseWatcherBase_regions_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

static int Dtool_Init_MouseWatcherBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_MouseWatcherBase_get_regions(PyObject *self, PyObject *) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherBase, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_regions();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_MouseWatcherBase_get_region_159(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_MouseWatcherBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MouseWatcherBase) {
    printf("MouseWatcherBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MouseWatcherBase *local_this = (MouseWatcherBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MouseWatcherBase) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MouseWatcherBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MouseWatcherBase) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MouseWatcherGroup
 */
/**
 * Python function wrapper for:
 * static TypeHandle MouseWatcherGroup::get_class_type(void)
 */
static PyObject *Dtool_MouseWatcherGroup_get_class_type_176(PyObject *, PyObject *) {
  // 1-static TypeHandle MouseWatcherGroup::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(MouseWatcherGroup::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherGroup_get_class_type_176_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MouseWatcherGroup_get_class_type_176_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * MouseWatcherBase *MouseWatcherGroup::upcast_to_MouseWatcherBase(void)
 */
static PyObject *Dtool_MouseWatcherGroup_upcast_to_MouseWatcherBase_171(PyObject *self, PyObject *) {
  MouseWatcherGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcherGroup, (void **)&local_this, "MouseWatcherGroup.upcast_to_MouseWatcherBase")) {
    return NULL;
  }
  // 1-MouseWatcherBase *MouseWatcherGroup::upcast_to_MouseWatcherBase(void)
  MouseWatcherBase *return_value = (MouseWatcherBase *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_MouseWatcherBase, false, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherGroup_upcast_to_MouseWatcherBase_171_comment =
  "C++ Interface:\n"
  "upcast_to_MouseWatcherBase(const MouseWatcherGroup self)\n"
  "\n"
  "upcast from MouseWatcherGroup to MouseWatcherBase";
#else
static const char *Dtool_MouseWatcherGroup_upcast_to_MouseWatcherBase_171_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ReferenceCount *MouseWatcherGroup::upcast_to_ReferenceCount(void)
 */
static PyObject *Dtool_MouseWatcherGroup_upcast_to_ReferenceCount_174(PyObject *self, PyObject *) {
  MouseWatcherGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcherGroup, (void **)&local_this, "MouseWatcherGroup.upcast_to_ReferenceCount")) {
    return NULL;
  }
  // 1-ReferenceCount *MouseWatcherGroup::upcast_to_ReferenceCount(void)
  ReferenceCount *return_value = (ReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ReferenceCount, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherGroup_upcast_to_ReferenceCount_174_comment =
  "C++ Interface:\n"
  "upcast_to_ReferenceCount(const MouseWatcherGroup self)\n"
  "\n"
  "upcast from MouseWatcherGroup to ReferenceCount";
#else
static const char *Dtool_MouseWatcherGroup_upcast_to_ReferenceCount_174_comment = NULL;
#endif

static int Dtool_Init_MouseWatcherGroup(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_MouseWatcherGroup(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MouseWatcherGroup) {
    printf("MouseWatcherGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MouseWatcherGroup *local_this = (MouseWatcherGroup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MouseWatcherGroup) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MouseWatcherBase) {
    return (MouseWatcherBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MouseWatcherGroup(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MouseWatcherGroup) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MouseWatcherBase) {
    MouseWatcherBase* other_this = (MouseWatcherBase*)from_this;
    return (MouseWatcherGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MouseWatcherGroup*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MouseWatcher
 */
/**
 * Python function wrapper for:
 * bool MouseWatcher::remove_region(MouseWatcherRegion *region)
 */
static PyObject *Dtool_MouseWatcher_remove_region_185(PyObject *self, PyObject *arg) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.remove_region")) {
    return NULL;
  }
  // 1-bool MouseWatcher::remove_region(MouseWatcherRegion *region)
  PT(MouseWatcherRegion) arg_this;
  if (!Dtool_Coerce_MouseWatcherRegion(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "MouseWatcher.remove_region", "MouseWatcherRegion");
  }
  bool return_value = (*local_this).remove_region(MOVE(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_region(const MouseWatcher self, MouseWatcherRegion region)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_remove_region_185_comment =
  "C++ Interface:\n"
  "remove_region(const MouseWatcher self, MouseWatcherRegion region)\n"
  "\n"
  "/**\n"
  " * Removes the indicated region from the group.  Returns true if it was\n"
  " * successfully removed, or false if it wasn't there in the first place.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_remove_region_185_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool MouseWatcher::has_mouse(void) const
 */
static PyObject *Dtool_MouseWatcher_has_mouse_186(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool MouseWatcher::has_mouse(void) const
  bool return_value = (*(const MouseWatcher*)local_this).has_mouse();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_has_mouse_186_comment =
  "C++ Interface:\n"
  "has_mouse(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns true if the mouse is anywhere within the window, false otherwise.\n"
  " * Also see is_mouse_open().\n"
  " */";
#else
static const char *Dtool_MouseWatcher_has_mouse_186_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool MouseWatcher::is_mouse_open(void) const
 */
static PyObject *Dtool_MouseWatcher_is_mouse_open_187(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool MouseWatcher::is_mouse_open(void) const
  bool return_value = (*(const MouseWatcher*)local_this).is_mouse_open();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_is_mouse_open_187_comment =
  "C++ Interface:\n"
  "is_mouse_open(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns true if the mouse is within the window and not over some particular\n"
  " * MouseWatcherRegion that is marked to suppress mouse events; that is, that\n"
  " * the mouse is in open space within the window.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_is_mouse_open_187_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2 const &MouseWatcher::get_mouse(void) const
 */
static PyObject *Dtool_MouseWatcher_get_mouse_188(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2 const &MouseWatcher::get_mouse(void) const
  LPoint2 const *return_value = &((*(const MouseWatcher*)local_this).get_mouse());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_mouse_188_comment =
  "C++ Interface:\n"
  "get_mouse(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * It is only valid to call this if has_mouse() returns true.  If so, this\n"
  " * returns the current position of the mouse within the window.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_mouse_188_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat MouseWatcher::get_mouse_x(void) const
 */
static PyObject *Dtool_MouseWatcher_get_mouse_x_189(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat MouseWatcher::get_mouse_x(void) const
  PN_stdfloat return_value = (*(const MouseWatcher*)local_this).get_mouse_x();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_mouse_x_189_comment =
  "C++ Interface:\n"
  "get_mouse_x(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * It is only valid to call this if has_mouse() returns true.  If so, this\n"
  " * returns the current X position of the mouse within the window.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_mouse_x_189_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat MouseWatcher::get_mouse_y(void) const
 */
static PyObject *Dtool_MouseWatcher_get_mouse_y_190(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat MouseWatcher::get_mouse_y(void) const
  PN_stdfloat return_value = (*(const MouseWatcher*)local_this).get_mouse_y();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_mouse_y_190_comment =
  "C++ Interface:\n"
  "get_mouse_y(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * It is only valid to call this if has_mouse() returns true.  If so, this\n"
  " * returns the current Y position of the mouse within the window.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_mouse_y_190_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcher::set_frame(LVecBase4 const &frame)
 * inline void MouseWatcher::set_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 */
static PyObject *Dtool_MouseWatcher_set_frame_191(PyObject *self, PyObject *args, PyObject *kwds) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.set_frame")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "frame");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'frame' (pos 1) not found");
      }
      // 1-inline void MouseWatcher::set_frame(LVecBase4 const &frame)
      LVecBase4f arg_local;
      LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "MouseWatcher.set_frame", "LVecBase4f");
      }
      (*local_this).set_frame(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void MouseWatcher::set_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"left", "right", "bottom", "top", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_frame", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_frame((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_frame() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame(const MouseWatcher self, const LVecBase4f frame)\n"
      "set_frame(const MouseWatcher self, float left, float right, float bottom, float top)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_set_frame_191_comment =
  "C++ Interface:\n"
  "set_frame(const MouseWatcher self, const LVecBase4f frame)\n"
  "set_frame(const MouseWatcher self, float left, float right, float bottom, float top)\n"
  "\n"
  "/**\n"
  " * Sets the frame of the MouseWatcher.  See the next flavor of this method for\n"
  " * a more verbose explanation.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the frame of the MouseWatcher.  This determines the coordinate space\n"
  " * in which the MouseWatcherRegions should be expected to live.  Normally,\n"
  " * this is left at -1, 1, -1, 1, which is the default setting, and matches the\n"
  " * mouse coordinate range.\n"
  " *\n"
  " * Whatever values you specify here indicate the shape of the full screen, and\n"
  " * the MouseWatcherRegions will be given in coordinate space matching it.  For\n"
  " * instance, if you specify (0, 1, 0, 1), then a MouseWatcherRegion with the\n"
  " * frame (0, 1, 0, .5) will cover the lower half of the screen.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_set_frame_191_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 const &MouseWatcher::get_frame(void) const
 */
static PyObject *Dtool_MouseWatcher_get_frame_192(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4 const &MouseWatcher::get_frame(void) const
  LVecBase4 const *return_value = &((*(const MouseWatcher*)local_this).get_frame());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_frame_192_comment =
  "C++ Interface:\n"
  "get_frame(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns the frame of the MouseWatcher.  See set_frame().\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_frame_192_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool MouseWatcher::is_over_region(void) const
 * inline bool MouseWatcher::is_over_region(LPoint2 const &pos) const
 * inline bool MouseWatcher::is_over_region(PN_stdfloat x, PN_stdfloat y) const
 */
static PyObject *Dtool_MouseWatcher_is_over_region_193(PyObject *self, PyObject *args, PyObject *kwds) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool MouseWatcher::is_over_region(void) const
      bool return_value = (*(const MouseWatcher*)local_this).is_over_region();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pos");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'pos' (pos 1) not found");
      }
      // 1-inline bool MouseWatcher::is_over_region(LPoint2 const &pos) const
      LPoint2f arg_local;
      LPoint2 const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "MouseWatcher.is_over_region", "LPoint2f");
      }
      bool return_value = (*(const MouseWatcher*)local_this).is_over_region(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-inline bool MouseWatcher::is_over_region(PN_stdfloat x, PN_stdfloat y) const
      float param1;
      float param2;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:is_over_region", (char **)keyword_list, &param1, &param2)) {
        bool return_value = (*(const MouseWatcher*)local_this).is_over_region((PN_stdfloat)param1, (PN_stdfloat)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "is_over_region() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_over_region(MouseWatcher self)\n"
      "is_over_region(MouseWatcher self, const LPoint2f pos)\n"
      "is_over_region(MouseWatcher self, float x, float y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_is_over_region_193_comment =
  "C++ Interface:\n"
  "is_over_region(MouseWatcher self)\n"
  "is_over_region(MouseWatcher self, const LPoint2f pos)\n"
  "is_over_region(MouseWatcher self, float x, float y)\n"
  "\n"
  "/**\n"
  " * Returns true if the mouse is over any rectangular region, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the mouse is over any rectangular region, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the mouse is over any rectangular region, false otherwise.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_is_over_region_193_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline MouseWatcherRegion *MouseWatcher::get_over_region(void) const
 * MouseWatcherRegion *MouseWatcher::get_over_region(LPoint2 const &pos) const
 * inline MouseWatcherRegion *MouseWatcher::get_over_region(PN_stdfloat x, PN_stdfloat y) const
 */
static PyObject *Dtool_MouseWatcher_get_over_region_194(PyObject *self, PyObject *args, PyObject *kwds) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline MouseWatcherRegion *MouseWatcher::get_over_region(void) const
      MouseWatcherRegion *return_value = (*(const MouseWatcher*)local_this).get_over_region();
      if (return_value != (MouseWatcherRegion *)NULL) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != (MouseWatcherRegion *)NULL) {
          unref_delete(return_value);
        }
        return NULL;
      }
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_MouseWatcherRegion, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pos");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'pos' (pos 1) not found");
      }
      // 1-MouseWatcherRegion *MouseWatcher::get_over_region(LPoint2 const &pos) const
      LPoint2f arg_local;
      LPoint2 const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "MouseWatcher.get_over_region", "LPoint2f");
      }
      MouseWatcherRegion *return_value = (*(const MouseWatcher*)local_this).get_over_region(*arg_this);
      if (return_value != (MouseWatcherRegion *)NULL) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != (MouseWatcherRegion *)NULL) {
          unref_delete(return_value);
        }
        return NULL;
      }
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_MouseWatcherRegion, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
    break;
  case 2:
    {
      // 1-inline MouseWatcherRegion *MouseWatcher::get_over_region(PN_stdfloat x, PN_stdfloat y) const
      float param1;
      float param2;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:get_over_region", (char **)keyword_list, &param1, &param2)) {
        MouseWatcherRegion *return_value = (*(const MouseWatcher*)local_this).get_over_region((PN_stdfloat)param1, (PN_stdfloat)param2);
        if (return_value != (MouseWatcherRegion *)NULL) {
          return_value->ref();
        }
        if (Dtool_CheckErrorOccurred()) {
          if (return_value != (MouseWatcherRegion *)NULL) {
            unref_delete(return_value);
          }
          return NULL;
        }
        if (return_value == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_MouseWatcherRegion, true, false, return_value->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_over_region() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_over_region(MouseWatcher self)\n"
      "get_over_region(MouseWatcher self, const LPoint2f pos)\n"
      "get_over_region(MouseWatcher self, float x, float y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_over_region_194_comment =
  "C++ Interface:\n"
  "get_over_region(MouseWatcher self)\n"
  "get_over_region(MouseWatcher self, const LPoint2f pos)\n"
  "get_over_region(MouseWatcher self, float x, float y)\n"
  "\n"
  "/**\n"
  " * Returns the smallest region the mouse is currently over, or NULL if it is\n"
  " * over no region.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the smallest region the indicated point is over, or NULL if it is\n"
  " * over no region.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the preferred region the mouse is over.  In the case of overlapping\n"
  " * regions, the region with the largest sort order is preferred; if two\n"
  " * regions have the same sort order, then the smaller region is preferred.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_over_region_194_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool MouseWatcher::is_button_down(ButtonHandle button) const
 */
static PyObject *Dtool_MouseWatcher_is_button_down_195(PyObject *self, PyObject *arg) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool MouseWatcher::is_button_down(ButtonHandle button) const
  ButtonHandle arg_local;
  ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "MouseWatcher.is_button_down", "ButtonHandle");
  }
  bool return_value = (*(const MouseWatcher*)local_this).is_button_down(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_button_down(MouseWatcher self, ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_is_button_down_195_comment =
  "C++ Interface:\n"
  "is_button_down(MouseWatcher self, ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated button is currently being held down, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_is_button_down_195_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcher::set_button_down_pattern(std::string const &pattern)
 */
static PyObject *Dtool_MouseWatcher_set_button_down_pattern_196(PyObject *self, PyObject *arg) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.set_button_down_pattern")) {
    return NULL;
  }
  // 1-inline void MouseWatcher::set_button_down_pattern(std::string const &pattern)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_button_down_pattern(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_button_down_pattern(const MouseWatcher self, str pattern)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_set_button_down_pattern_196_comment =
  "C++ Interface:\n"
  "set_button_down_pattern(const MouseWatcher self, str pattern)\n"
  "\n"
  "/**\n"
  " * Sets the pattern string that indicates how the event names are generated\n"
  " * when a button is depressed.  This is a string that may contain any of the\n"
  " * following:\n"
  " *\n"
  " * %r  - the name of the region the mouse is over %b  - the name of the button\n"
  " * pressed.\n"
  " *\n"
  " * The event name will be based on the in_pattern string specified here, with\n"
  " * all occurrences of the above strings replaced with the corresponding\n"
  " * values.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_set_button_down_pattern_196_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &MouseWatcher::get_button_down_pattern(void) const
 */
static PyObject *Dtool_MouseWatcher_get_button_down_pattern_197(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &MouseWatcher::get_button_down_pattern(void) const
  std::string const &return_value = (*(const MouseWatcher*)local_this).get_button_down_pattern();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_button_down_pattern_197_comment =
  "C++ Interface:\n"
  "get_button_down_pattern(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns the string that indicates how event names are generated when a\n"
  " * button is depressed.  See set_button_down_pattern().\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_button_down_pattern_197_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcher::set_button_up_pattern(std::string const &pattern)
 */
static PyObject *Dtool_MouseWatcher_set_button_up_pattern_198(PyObject *self, PyObject *arg) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.set_button_up_pattern")) {
    return NULL;
  }
  // 1-inline void MouseWatcher::set_button_up_pattern(std::string const &pattern)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_button_up_pattern(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_button_up_pattern(const MouseWatcher self, str pattern)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_set_button_up_pattern_198_comment =
  "C++ Interface:\n"
  "set_button_up_pattern(const MouseWatcher self, str pattern)\n"
  "\n"
  "/**\n"
  " * Sets the pattern string that indicates how the event names are generated\n"
  " * when a button is released.  See set_button_down_pattern().\n"
  " */";
#else
static const char *Dtool_MouseWatcher_set_button_up_pattern_198_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &MouseWatcher::get_button_up_pattern(void) const
 */
static PyObject *Dtool_MouseWatcher_get_button_up_pattern_199(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &MouseWatcher::get_button_up_pattern(void) const
  std::string const &return_value = (*(const MouseWatcher*)local_this).get_button_up_pattern();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_button_up_pattern_199_comment =
  "C++ Interface:\n"
  "get_button_up_pattern(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns the string that indicates how event names are generated when a\n"
  " * button is released.  See set_button_down_pattern().\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_button_up_pattern_199_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcher::set_button_repeat_pattern(std::string const &pattern)
 */
static PyObject *Dtool_MouseWatcher_set_button_repeat_pattern_200(PyObject *self, PyObject *arg) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.set_button_repeat_pattern")) {
    return NULL;
  }
  // 1-inline void MouseWatcher::set_button_repeat_pattern(std::string const &pattern)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_button_repeat_pattern(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_button_repeat_pattern(const MouseWatcher self, str pattern)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_set_button_repeat_pattern_200_comment =
  "C++ Interface:\n"
  "set_button_repeat_pattern(const MouseWatcher self, str pattern)\n"
  "\n"
  "/**\n"
  " * Sets the pattern string that indicates how the event names are generated\n"
  " * when a button is continuously held and generates keyrepeat \"down\" events.\n"
  " * This is a string that may contain any of the following:\n"
  " *\n"
  " * %r  - the name of the region the mouse is over %b  - the name of the button\n"
  " * pressed.\n"
  " *\n"
  " * The event name will be based on the in_pattern string specified here, with\n"
  " * all occurrences of the above strings replaced with the corresponding\n"
  " * values.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_set_button_repeat_pattern_200_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &MouseWatcher::get_button_repeat_pattern(void) const
 */
static PyObject *Dtool_MouseWatcher_get_button_repeat_pattern_201(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &MouseWatcher::get_button_repeat_pattern(void) const
  std::string const &return_value = (*(const MouseWatcher*)local_this).get_button_repeat_pattern();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_button_repeat_pattern_201_comment =
  "C++ Interface:\n"
  "get_button_repeat_pattern(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns the string that indicates how event names are names are generated\n"
  " * when a button is continuously held and generates keyrepeat \"down\" events.\n"
  " * See set_button_repeat_pattern().\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_button_repeat_pattern_201_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcher::set_enter_pattern(std::string const &pattern)
 */
static PyObject *Dtool_MouseWatcher_set_enter_pattern_202(PyObject *self, PyObject *arg) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.set_enter_pattern")) {
    return NULL;
  }
  // 1-inline void MouseWatcher::set_enter_pattern(std::string const &pattern)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_enter_pattern(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_enter_pattern(const MouseWatcher self, str pattern)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_set_enter_pattern_202_comment =
  "C++ Interface:\n"
  "set_enter_pattern(const MouseWatcher self, str pattern)\n"
  "\n"
  "/**\n"
  " * Sets the pattern string that indicates how the event names are generated\n"
  " * when the mouse enters a region.  This is different from within_pattern, in\n"
  " * that a mouse is only \"entered\" in the topmost region at a given time, while\n"
  " * it might be \"within\" multiple nested regions.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_set_enter_pattern_202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &MouseWatcher::get_enter_pattern(void) const
 */
static PyObject *Dtool_MouseWatcher_get_enter_pattern_203(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &MouseWatcher::get_enter_pattern(void) const
  std::string const &return_value = (*(const MouseWatcher*)local_this).get_enter_pattern();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_enter_pattern_203_comment =
  "C++ Interface:\n"
  "get_enter_pattern(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns the string that indicates how event names are generated when the\n"
  " * mouse enters a region.  This is different from within_pattern, in that a\n"
  " * mouse is only \"entered\" in the topmost region at a given time, while it\n"
  " * might be \"within\" multiple nested regions.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_enter_pattern_203_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcher::set_leave_pattern(std::string const &pattern)
 */
static PyObject *Dtool_MouseWatcher_set_leave_pattern_204(PyObject *self, PyObject *arg) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.set_leave_pattern")) {
    return NULL;
  }
  // 1-inline void MouseWatcher::set_leave_pattern(std::string const &pattern)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_leave_pattern(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_leave_pattern(const MouseWatcher self, str pattern)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_set_leave_pattern_204_comment =
  "C++ Interface:\n"
  "set_leave_pattern(const MouseWatcher self, str pattern)\n"
  "\n"
  "/**\n"
  " * Sets the pattern string that indicates how the event names are generated\n"
  " * when the mouse leaves a region.  This is different from without_pattern, in\n"
  " * that a mouse is only \"entered\" in the topmost region at a given time, while\n"
  " * it might be \"within\" multiple nested regions.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_set_leave_pattern_204_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &MouseWatcher::get_leave_pattern(void) const
 */
static PyObject *Dtool_MouseWatcher_get_leave_pattern_205(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &MouseWatcher::get_leave_pattern(void) const
  std::string const &return_value = (*(const MouseWatcher*)local_this).get_leave_pattern();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_leave_pattern_205_comment =
  "C++ Interface:\n"
  "get_leave_pattern(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns the string that indicates how event names are generated when the\n"
  " * mouse leaves a region.  This is different from without_pattern, in that a\n"
  " * mouse is only \"entered\" in the topmost region at a given time, while it\n"
  " * might be \"within\" multiple nested regions.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_leave_pattern_205_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcher::set_within_pattern(std::string const &pattern)
 */
static PyObject *Dtool_MouseWatcher_set_within_pattern_206(PyObject *self, PyObject *arg) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.set_within_pattern")) {
    return NULL;
  }
  // 1-inline void MouseWatcher::set_within_pattern(std::string const &pattern)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_within_pattern(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_within_pattern(const MouseWatcher self, str pattern)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_set_within_pattern_206_comment =
  "C++ Interface:\n"
  "set_within_pattern(const MouseWatcher self, str pattern)\n"
  "\n"
  "/**\n"
  " * Sets the pattern string that indicates how the event names are generated\n"
  " * when the mouse wanders over a region.  This is different from\n"
  " * enter_pattern, in that a mouse is only \"entered\" in the topmost region at a\n"
  " * given time, while it might be \"within\" multiple nested regions.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_set_within_pattern_206_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &MouseWatcher::get_within_pattern(void) const
 */
static PyObject *Dtool_MouseWatcher_get_within_pattern_207(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &MouseWatcher::get_within_pattern(void) const
  std::string const &return_value = (*(const MouseWatcher*)local_this).get_within_pattern();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_within_pattern_207_comment =
  "C++ Interface:\n"
  "get_within_pattern(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns the string that indicates how event names are generated when the\n"
  " * mouse wanders over a region.  This is different from enter_pattern, in that\n"
  " * a mouse is only \"entered\" in the topmost region at a given time, while it\n"
  " * might be \"within\" multiple nested regions.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_within_pattern_207_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcher::set_without_pattern(std::string const &pattern)
 */
static PyObject *Dtool_MouseWatcher_set_without_pattern_208(PyObject *self, PyObject *arg) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.set_without_pattern")) {
    return NULL;
  }
  // 1-inline void MouseWatcher::set_without_pattern(std::string const &pattern)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_without_pattern(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_without_pattern(const MouseWatcher self, str pattern)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_set_without_pattern_208_comment =
  "C++ Interface:\n"
  "set_without_pattern(const MouseWatcher self, str pattern)\n"
  "\n"
  "/**\n"
  " * Sets the pattern string that indicates how the event names are generated\n"
  " * when the mouse wanders out of a region.  This is different from\n"
  " * leave_pattern, in that a mouse is only \"entered\" in the topmost region at a\n"
  " * given time, while it might be \"within\" multiple nested regions.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_set_without_pattern_208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &MouseWatcher::get_without_pattern(void) const
 */
static PyObject *Dtool_MouseWatcher_get_without_pattern_209(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &MouseWatcher::get_without_pattern(void) const
  std::string const &return_value = (*(const MouseWatcher*)local_this).get_without_pattern();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_without_pattern_209_comment =
  "C++ Interface:\n"
  "get_without_pattern(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns the string that indicates how event names are generated when the\n"
  " * mouse wanders out of a region.  This is different from leave_pattern, in\n"
  " * that a mouse is only \"entered\" in the topmost region at a given time, while\n"
  " * it might be \"within\" multiple nested regions.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_without_pattern_209_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcher::set_geometry(PandaNode *node)
 */
static PyObject *Dtool_MouseWatcher_set_geometry_210(PyObject *self, PyObject *arg) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.set_geometry")) {
    return NULL;
  }
  // 1-inline void MouseWatcher::set_geometry(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "MouseWatcher.set_geometry", false, true);
  if (arg_this != NULL) {
    (*local_this).set_geometry(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_geometry(const MouseWatcher self, PandaNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_set_geometry_210_comment =
  "C++ Interface:\n"
  "set_geometry(const MouseWatcher self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Sets the node that will be transformed each frame by the mouse's\n"
  " * coordinates.  It will also be hidden when the mouse goes outside the\n"
  " * window.  This can be used to implement a software mouse pointer for when a\n"
  " * hardware (or system) mouse pointer is unavailable.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_set_geometry_210_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool MouseWatcher::has_geometry(void) const
 */
static PyObject *Dtool_MouseWatcher_has_geometry_211(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool MouseWatcher::has_geometry(void) const
  bool return_value = (*(const MouseWatcher*)local_this).has_geometry();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_has_geometry_211_comment =
  "C++ Interface:\n"
  "has_geometry(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns true if a software mouse pointer has been setup via set_geometry(),\n"
  " * or false otherwise.  See set_geometry().\n"
  " */";
#else
static const char *Dtool_MouseWatcher_has_geometry_211_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode *MouseWatcher::get_geometry(void) const
 */
static PyObject *Dtool_MouseWatcher_get_geometry_212(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PandaNode *MouseWatcher::get_geometry(void) const
  PandaNode *return_value = (*(const MouseWatcher*)local_this).get_geometry();
  if (return_value != (PandaNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PandaNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_geometry_212_comment =
  "C++ Interface:\n"
  "get_geometry(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns the node that has been set as the software mouse pointer, or NULL\n"
  " * if no node has been set.  See has_geometry() and set_geometry().\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_geometry_212_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcher::clear_geometry(void)
 */
static PyObject *Dtool_MouseWatcher_clear_geometry_213(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.clear_geometry")) {
    return NULL;
  }
  // 1-inline void MouseWatcher::clear_geometry(void)
  (*local_this).clear_geometry();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_clear_geometry_213_comment =
  "C++ Interface:\n"
  "clear_geometry(const MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Stops the use of the software cursor set up via set_geometry().\n"
  " */";
#else
static const char *Dtool_MouseWatcher_clear_geometry_213_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcher::set_extra_handler(EventHandler *eh)
 */
static PyObject *Dtool_MouseWatcher_set_extra_handler_214(PyObject *self, PyObject *arg) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.set_extra_handler")) {
    return NULL;
  }
  // 1-inline void MouseWatcher::set_extra_handler(EventHandler *eh)
  EventHandler *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_EventHandler(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "MouseWatcher.set_extra_handler", "EventHandler");
  }
  (*local_this).set_extra_handler(arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_extra_handler(const MouseWatcher self, EventHandler eh)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_set_extra_handler_214_comment =
  "C++ Interface:\n"
  "set_extra_handler(const MouseWatcher self, EventHandler eh)\n"
  "\n"
  "/**\n"
  " * As an optimization for the C++ Gui, an extra handler can be registered with\n"
  " * a mouseWatcher so that events can be dealt with much sooner.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_set_extra_handler_214_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EventHandler *MouseWatcher::get_extra_handler(void) const
 */
static PyObject *Dtool_MouseWatcher_get_extra_handler_215(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EventHandler *MouseWatcher::get_extra_handler(void) const
  EventHandler *return_value = (*(const MouseWatcher*)local_this).get_extra_handler();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EventHandler, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_extra_handler_215_comment =
  "C++ Interface:\n"
  "get_extra_handler(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * As an optimization for the C++ Gui, an extra handler can be registered with\n"
  " * a mouseWatcher so that events can be dealt with much sooner.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_extra_handler_215_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcher::set_modifier_buttons(ModifierButtons const &mods)
 */
static PyObject *Dtool_MouseWatcher_set_modifier_buttons_216(PyObject *self, PyObject *arg) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.set_modifier_buttons")) {
    return NULL;
  }
  // 1-inline void MouseWatcher::set_modifier_buttons(ModifierButtons const &mods)
  ModifierButtons const *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 1, "MouseWatcher.set_modifier_buttons", true, true);
  if (arg_this != NULL) {
    (*local_this).set_modifier_buttons(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_modifier_buttons(const MouseWatcher self, const ModifierButtons mods)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_set_modifier_buttons_216_comment =
  "C++ Interface:\n"
  "set_modifier_buttons(const MouseWatcher self, const ModifierButtons mods)\n"
  "\n"
  "/**\n"
  " * Sets the buttons that should be monitored as modifier buttons for\n"
  " * generating events to the MouseWatcherRegions.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_set_modifier_buttons_216_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ModifierButtons MouseWatcher::get_modifier_buttons(void) const
 */
static PyObject *Dtool_MouseWatcher_get_modifier_buttons_217(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ModifierButtons MouseWatcher::get_modifier_buttons(void) const
  ModifierButtons *return_value = new ModifierButtons((*(const MouseWatcher*)local_this).get_modifier_buttons());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ModifierButtons, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_modifier_buttons_217_comment =
  "C++ Interface:\n"
  "get_modifier_buttons(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns the set of buttons that are being monitored as modifier buttons, as\n"
  " * well as their current state.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_modifier_buttons_217_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcher::set_display_region(DisplayRegion *dr)
 */
static PyObject *Dtool_MouseWatcher_set_display_region_218(PyObject *self, PyObject *arg) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.set_display_region")) {
    return NULL;
  }
  // 1-inline void MouseWatcher::set_display_region(DisplayRegion *dr)
  DisplayRegion *arg_this = (DisplayRegion *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DisplayRegion, 1, "MouseWatcher.set_display_region", false, true);
  if (arg_this != NULL) {
    (*local_this).set_display_region(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_display_region(const MouseWatcher self, DisplayRegion dr)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_set_display_region_218_comment =
  "C++ Interface:\n"
  "set_display_region(const MouseWatcher self, DisplayRegion dr)\n"
  "\n"
  "/**\n"
  " * Constrains the MouseWatcher to watching the mouse within a particular\n"
  " * indicated region of the screen.  DataNodes parented under the MouseWatcher\n"
  " * will observe the mouse and keyboard events only when the mouse is within\n"
  " * the indicated region, and the observed range will be from -1 .. 1 across\n"
  " * the region.\n"
  " *\n"
  " * Do not delete the DisplayRegion while it is owned by the MouseWatcher.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_set_display_region_218_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcher::clear_display_region(void)
 */
static PyObject *Dtool_MouseWatcher_clear_display_region_219(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.clear_display_region")) {
    return NULL;
  }
  // 1-inline void MouseWatcher::clear_display_region(void)
  (*local_this).clear_display_region();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_clear_display_region_219_comment =
  "C++ Interface:\n"
  "clear_display_region(const MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Removes the display region constraint from the MouseWatcher, and restores\n"
  " * it to the default behavior of watching the whole window.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_clear_display_region_219_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DisplayRegion *MouseWatcher::get_display_region(void) const
 */
static PyObject *Dtool_MouseWatcher_get_display_region_220(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline DisplayRegion *MouseWatcher::get_display_region(void) const
  DisplayRegion *return_value = (*(const MouseWatcher*)local_this).get_display_region();
  if (return_value != (DisplayRegion *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (DisplayRegion *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DisplayRegion, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_display_region_220_comment =
  "C++ Interface:\n"
  "get_display_region(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns the display region the MouseWatcher is constrained to by\n"
  " * set_display_region(), or NULL if it is not constrained.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_display_region_220_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool MouseWatcher::has_display_region(void) const
 */
static PyObject *Dtool_MouseWatcher_has_display_region_221(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool MouseWatcher::has_display_region(void) const
  bool return_value = (*(const MouseWatcher*)local_this).has_display_region();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_has_display_region_221_comment =
  "C++ Interface:\n"
  "has_display_region(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns true if the MouseWatcher has been constrained to a particular\n"
  " * region of the screen via set_display_region(), or false otherwise.  If this\n"
  " * returns true, get_display_region() may be used to return the particular\n"
  " * region.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_has_display_region_221_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool MouseWatcher::add_group(MouseWatcherGroup *group)
 */
static PyObject *Dtool_MouseWatcher_add_group_222(PyObject *self, PyObject *arg) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.add_group")) {
    return NULL;
  }
  // 1-bool MouseWatcher::add_group(MouseWatcherGroup *group)
  MouseWatcherGroup *arg_this = (MouseWatcherGroup *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MouseWatcherGroup, 1, "MouseWatcher.add_group", false, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).add_group(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_group(const MouseWatcher self, MouseWatcherGroup group)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_add_group_222_comment =
  "C++ Interface:\n"
  "add_group(const MouseWatcher self, MouseWatcherGroup group)\n"
  "\n"
  "/**\n"
  " * Adds the indicated group of regions to the set of regions the MouseWatcher\n"
  " * will monitor each frame.\n"
  " *\n"
  " * Since the MouseWatcher itself inherits from MouseWatcherBase, this\n"
  " * operation is normally not necessary--you can simply add the Regions you\n"
  " * care about one at a time.  Adding a complete group is useful when you may\n"
  " * want to explicitly remove the regions as a group later.\n"
  " *\n"
  " * Returns true if the group was successfully added, or false if it was\n"
  " * already on the list.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_add_group_222_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool MouseWatcher::remove_group(MouseWatcherGroup *group)
 */
static PyObject *Dtool_MouseWatcher_remove_group_223(PyObject *self, PyObject *arg) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.remove_group")) {
    return NULL;
  }
  // 1-bool MouseWatcher::remove_group(MouseWatcherGroup *group)
  MouseWatcherGroup *arg_this = (MouseWatcherGroup *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MouseWatcherGroup, 1, "MouseWatcher.remove_group", false, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).remove_group(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_group(const MouseWatcher self, MouseWatcherGroup group)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_remove_group_223_comment =
  "C++ Interface:\n"
  "remove_group(const MouseWatcher self, MouseWatcherGroup group)\n"
  "\n"
  "/**\n"
  " * Removes the indicated group from the set of extra groups associated with\n"
  " * the MouseWatcher.  Returns true if successful, or false if the group was\n"
  " * already removed or was never added via add_group().\n"
  " */";
#else
static const char *Dtool_MouseWatcher_remove_group_223_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool MouseWatcher::replace_group(MouseWatcherGroup *old_group, MouseWatcherGroup *new_group)
 */
static PyObject *Dtool_MouseWatcher_replace_group_224(PyObject *self, PyObject *args, PyObject *kwds) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.replace_group")) {
    return NULL;
  }
  // 1-bool MouseWatcher::replace_group(MouseWatcherGroup *old_group, MouseWatcherGroup *new_group)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"old_group", "new_group", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:replace_group", (char **)keyword_list, &param1, &param2)) {
    MouseWatcherGroup *param1_this = (MouseWatcherGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_MouseWatcherGroup, 1, "MouseWatcher.replace_group", false, true);
    MouseWatcherGroup *param2_this = (MouseWatcherGroup *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_MouseWatcherGroup, 2, "MouseWatcher.replace_group", false, true);
    if (param1_this != NULL && param2_this != NULL) {
      bool return_value = (*local_this).replace_group(param1_this, param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "replace_group(const MouseWatcher self, MouseWatcherGroup old_group, MouseWatcherGroup new_group)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_replace_group_224_comment =
  "C++ Interface:\n"
  "replace_group(const MouseWatcher self, MouseWatcherGroup old_group, MouseWatcherGroup new_group)\n"
  "\n"
  "/**\n"
  " * Atomically removes old_group from the MouseWatcher, and replaces it with\n"
  " * new_group.  Presumably old_group and new_group might have some regions in\n"
  " * common; these are handled properly.\n"
  " *\n"
  " * If old_group is not already present, simply adds new_group and returns\n"
  " * false.  Otherwise, removes old_group and adds new_group, and then returns\n"
  " * true.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_replace_group_224_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int MouseWatcher::get_num_groups(void) const
 */
static PyObject *Dtool_MouseWatcher_get_num_groups_225(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-int MouseWatcher::get_num_groups(void) const
  int return_value = (*(const MouseWatcher*)local_this).get_num_groups();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_num_groups_225_comment =
  "C++ Interface:\n"
  "get_num_groups(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns the number of separate groups added to the MouseWatcher via\n"
  " * add_group().\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_num_groups_225_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * MouseWatcherGroup *MouseWatcher::get_group(int n) const
 */
static PyObject *Dtool_MouseWatcher_get_group_226(PyObject *self, PyObject *arg) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-MouseWatcherGroup *MouseWatcher::get_group(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    MouseWatcherGroup *return_value = (*(const MouseWatcher*)local_this).get_group((int)arg_val);
    if (return_value != (MouseWatcherGroup *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (MouseWatcherGroup *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_MouseWatcherGroup, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_group(MouseWatcher self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_group_226_comment =
  "C++ Interface:\n"
  "get_group(MouseWatcher self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth group added to the MouseWatcher via add_group().\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_group_226_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcher::set_inactivity_timeout(double timeout)
 */
static PyObject *Dtool_MouseWatcher_set_inactivity_timeout_228(PyObject *self, PyObject *arg) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.set_inactivity_timeout")) {
    return NULL;
  }
  // 1-inline void MouseWatcher::set_inactivity_timeout(double timeout)
  if (PyNumber_Check(arg)) {
    (*local_this).set_inactivity_timeout(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_inactivity_timeout(const MouseWatcher self, double timeout)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_set_inactivity_timeout_228_comment =
  "C++ Interface:\n"
  "set_inactivity_timeout(const MouseWatcher self, double timeout)\n"
  "\n"
  "/**\n"
  " * Sets an inactivity timeout on the mouse activity.  When this timeout (in\n"
  " * seconds) is exceeded with no keyboard or mouse activity, all currently-held\n"
  " * buttons are automatically released.  This is intended to help protect\n"
  " * against people who inadvertently (or intentionally) leave a keyboard key\n"
  " * stuck down and then wander away from the keyboard.\n"
  " *\n"
  " * Also, when this timeout expires, the event specified by\n"
  " * set_inactivity_timeout_event() will be generated.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_set_inactivity_timeout_228_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool MouseWatcher::has_inactivity_timeout(void) const
 */
static PyObject *Dtool_MouseWatcher_has_inactivity_timeout_229(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool MouseWatcher::has_inactivity_timeout(void) const
  bool return_value = (*(const MouseWatcher*)local_this).has_inactivity_timeout();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_has_inactivity_timeout_229_comment =
  "C++ Interface:\n"
  "has_inactivity_timeout(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns true if an inactivity timeout has been set, false otherwise.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_has_inactivity_timeout_229_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double MouseWatcher::get_inactivity_timeout(void) const
 */
static PyObject *Dtool_MouseWatcher_get_inactivity_timeout_230(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double MouseWatcher::get_inactivity_timeout(void) const
  double return_value = (*(const MouseWatcher*)local_this).get_inactivity_timeout();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_inactivity_timeout_230_comment =
  "C++ Interface:\n"
  "get_inactivity_timeout(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns the inactivity timeout that has been set.  It is an error to call\n"
  " * this if has_inactivity_timeout() returns false.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_inactivity_timeout_230_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcher::clear_inactivity_timeout(void)
 */
static PyObject *Dtool_MouseWatcher_clear_inactivity_timeout_231(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.clear_inactivity_timeout")) {
    return NULL;
  }
  // 1-inline void MouseWatcher::clear_inactivity_timeout(void)
  (*local_this).clear_inactivity_timeout();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_clear_inactivity_timeout_231_comment =
  "C++ Interface:\n"
  "clear_inactivity_timeout(const MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Removes the inactivity timeout and restores the MouseWatcher to its default\n"
  " * behavior of allowing a key to be held indefinitely.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_clear_inactivity_timeout_231_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcher::set_inactivity_timeout_event(std::string const &event)
 */
static PyObject *Dtool_MouseWatcher_set_inactivity_timeout_event_232(PyObject *self, PyObject *arg) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.set_inactivity_timeout_event")) {
    return NULL;
  }
  // 1-inline void MouseWatcher::set_inactivity_timeout_event(std::string const &event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_inactivity_timeout_event(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_inactivity_timeout_event(const MouseWatcher self, str event)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_set_inactivity_timeout_event_232_comment =
  "C++ Interface:\n"
  "set_inactivity_timeout_event(const MouseWatcher self, str event)\n"
  "\n"
  "/**\n"
  " * Specifies the event string that will be generated when the inactivity\n"
  " * timeout counter expires.  See set_inactivity_timeout().\n"
  " */";
#else
static const char *Dtool_MouseWatcher_set_inactivity_timeout_event_232_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &MouseWatcher::get_inactivity_timeout_event(void) const
 */
static PyObject *Dtool_MouseWatcher_get_inactivity_timeout_event_233(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &MouseWatcher::get_inactivity_timeout_event(void) const
  std::string const &return_value = (*(const MouseWatcher*)local_this).get_inactivity_timeout_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_inactivity_timeout_event_233_comment =
  "C++ Interface:\n"
  "get_inactivity_timeout_event(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns the event string that will be generated when the inactivity timeout\n"
  " * counter expires.  See set_inactivity_timeout().\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_inactivity_timeout_event_233_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< PointerEventList > MouseWatcher::get_trail_log(void) const
 */
static PyObject *Dtool_MouseWatcher_get_trail_log_234(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ConstPointerTo< PointerEventList > MouseWatcher::get_trail_log(void) const
  ConstPointerTo< PointerEventList > return_value = (*(const MouseWatcher*)local_this).get_trail_log();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  PointerEventList const *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PointerEventList, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_trail_log_234_comment =
  "C++ Interface:\n"
  "get_trail_log(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Obtain the mouse trail log.  This is a PointerEventList.  Does not make a\n"
  " * copy, therefore, this PointerEventList will be updated each time\n"
  " * process_events gets called.\n"
  " *\n"
  " * To use trail logging, you need to enable the generation of pointer events\n"
  " * in the GraphicsWindowInputDevice and set the trail log duration in the\n"
  " * MouseWatcher.  Otherwise, the trail log will be empty.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_trail_log_234_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int MouseWatcher::num_trail_recent(void) const
 */
static PyObject *Dtool_MouseWatcher_num_trail_recent_235(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int MouseWatcher::num_trail_recent(void) const
  int return_value = (*(const MouseWatcher*)local_this).num_trail_recent();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_num_trail_recent_235_comment =
  "C++ Interface:\n"
  "num_trail_recent(MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * This counter indicates how many events were added to the trail log this\n"
  " * frame.  The trail log is updated once per frame, during the process_events\n"
  " * operation.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_num_trail_recent_235_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MouseWatcher::set_trail_log_duration(double duration)
 */
static PyObject *Dtool_MouseWatcher_set_trail_log_duration_236(PyObject *self, PyObject *arg) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.set_trail_log_duration")) {
    return NULL;
  }
  // 1-void MouseWatcher::set_trail_log_duration(double duration)
  if (PyNumber_Check(arg)) {
    (*local_this).set_trail_log_duration(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_trail_log_duration(const MouseWatcher self, double duration)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_set_trail_log_duration_236_comment =
  "C++ Interface:\n"
  "set_trail_log_duration(const MouseWatcher self, double duration)\n"
  "\n"
  "/**\n"
  " * If the duration is nonzero, causes the MouseWatcher to log the mouse's\n"
  " * trail.  Events older than the specified duration are discarded.  If the\n"
  " * duration is zero, logging is disabled.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_set_trail_log_duration_236_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< GeomNode > MouseWatcher::get_trail_node(void)
 */
static PyObject *Dtool_MouseWatcher_get_trail_node_237(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.get_trail_node")) {
    return NULL;
  }
  // 1-PointerTo< GeomNode > MouseWatcher::get_trail_node(void)
  PointerTo< GeomNode > return_value = (*local_this).get_trail_node();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  GeomNode *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomNode, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_trail_node_237_comment =
  "C++ Interface:\n"
  "get_trail_node(const MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Returns a GeomNode that represents the mouse trail.  The intent is that you\n"
  " * should reparent this GeomNode to Render2D, and then forget about it.  The\n"
  " * MouseWatcher will continually update the trail node.  There is only one\n"
  " * trail node, it does not create a new one each time you call get_trail_node.\n"
  " *\n"
  " * This is not a particularly beautiful way to render a mouse trail.  It is\n"
  " * intended more for debugging purposes than for finished applications.  Even\n"
  " * so, It is suggested that you might want to apply a line thickness and\n"
  " * antialias mode to the line --- doing so makes it look a lot better.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_get_trail_node_237_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MouseWatcher::clear_trail_node(void)
 */
static PyObject *Dtool_MouseWatcher_clear_trail_node_238(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.clear_trail_node")) {
    return NULL;
  }
  // 1-void MouseWatcher::clear_trail_node(void)
  (*local_this).clear_trail_node();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_clear_trail_node_238_comment =
  "C++ Interface:\n"
  "clear_trail_node(const MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * If you have previously fetched the trail node using get_trail_node, then\n"
  " * the MouseWatcher is continually updating the trail node every frame.  Using\n"
  " * clear_trail_node causes the MouseWatcher to forget the trail node and stop\n"
  " * updating it.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_clear_trail_node_238_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MouseWatcher::clear_trail_log(void)
 */
static PyObject *Dtool_MouseWatcher_clear_trail_log_239(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.clear_trail_log")) {
    return NULL;
  }
  // 1-inline void MouseWatcher::clear_trail_log(void)
  (*local_this).clear_trail_log();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_clear_trail_log_239_comment =
  "C++ Interface:\n"
  "clear_trail_log(const MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Clears the mouse trail log.  This does not prevent further accumulation of\n"
  " * the log given future events.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_clear_trail_log_239_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MouseWatcher::note_activity(void)
 */
static PyObject *Dtool_MouseWatcher_note_activity_240(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.note_activity")) {
    return NULL;
  }
  // 1-void MouseWatcher::note_activity(void)
  (*local_this).note_activity();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_note_activity_240_comment =
  "C++ Interface:\n"
  "note_activity(const MouseWatcher self)\n"
  "\n"
  "/**\n"
  " * Can be used in conjunction with the inactivity timeout to inform the\n"
  " * MouseWatcher that the user has just performed some action which proves\n"
  " * he/she is present.  It may be necessary to call this for external events,\n"
  " * such as joystick action, that the MouseWatcher might otherwise not know\n"
  " * about.  This will reset the current inactivity timer.  When the inactivity\n"
  " * timer reaches the length of time specified by set_inactivity_timeout(),\n"
  " * with no keyboard or mouse activity and no calls to note_activity(), then\n"
  " * any buttons held will be automatically released.\n"
  " */";
#else
static const char *Dtool_MouseWatcher_note_activity_240_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MouseWatcher::get_class_type(void)
 */
static PyObject *Dtool_MouseWatcher_get_class_type_241(PyObject *, PyObject *) {
  // 1-static TypeHandle MouseWatcher::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(MouseWatcher::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_get_class_type_241_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MouseWatcher_get_class_type_241_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DataNode *MouseWatcher::upcast_to_DataNode(void)
 */
static PyObject *Dtool_MouseWatcher_upcast_to_DataNode_179(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.upcast_to_DataNode")) {
    return NULL;
  }
  // 1-DataNode *MouseWatcher::upcast_to_DataNode(void)
  DataNode *return_value = (DataNode *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DataNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_upcast_to_DataNode_179_comment =
  "C++ Interface:\n"
  "upcast_to_DataNode(const MouseWatcher self)\n"
  "\n"
  "upcast from MouseWatcher to DataNode";
#else
static const char *Dtool_MouseWatcher_upcast_to_DataNode_179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * MouseWatcherBase *MouseWatcher::upcast_to_MouseWatcherBase(void)
 */
static PyObject *Dtool_MouseWatcher_upcast_to_MouseWatcherBase_181(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseWatcher, (void **)&local_this, "MouseWatcher.upcast_to_MouseWatcherBase")) {
    return NULL;
  }
  // 1-MouseWatcherBase *MouseWatcher::upcast_to_MouseWatcherBase(void)
  MouseWatcherBase *return_value = (MouseWatcherBase *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_MouseWatcherBase, false, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcher_upcast_to_MouseWatcherBase_181_comment =
  "C++ Interface:\n"
  "upcast_to_MouseWatcherBase(const MouseWatcher self)\n"
  "\n"
  "upcast from MouseWatcher to MouseWatcherBase";
#else
static const char *Dtool_MouseWatcher_upcast_to_MouseWatcherBase_181_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * MouseWatcher::MouseWatcher(std::string const &name = "")
 */
static int Dtool_Init_MouseWatcher(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-MouseWatcher::MouseWatcher(std::string const &name = "")
  const char *param0_str = "";
  Py_ssize_t param0_len = 0;
  static const char *keyword_list[] = {"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#:MouseWatcher", (char **)keyword_list, &param0_str, &param0_len)) {
    MouseWatcher *return_value = new MouseWatcher(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MouseWatcher, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MouseWatcher(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_MouseWatcher(PyObject *args, CPT(MouseWatcher) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_MouseWatcher, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-MouseWatcher::MouseWatcher(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      MouseWatcher *return_value = new MouseWatcher(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_MouseWatcher(PyObject *args, PT(MouseWatcher) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_MouseWatcher, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-MouseWatcher::MouseWatcher(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      MouseWatcher *return_value = new MouseWatcher(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_MouseWatcher_get_groups(PyObject *self, PyObject *) {
  MouseWatcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcher, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_groups();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_MouseWatcher_get_group_226(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_MouseWatcher(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MouseWatcher) {
    printf("MouseWatcher ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MouseWatcher *local_this = (MouseWatcher *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MouseWatcher) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_MouseWatcherBase) {
    return (MouseWatcherBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MouseWatcher(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MouseWatcher) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (MouseWatcher*)other_this;
  }
  if (from_type == Dtool_Ptr_MouseWatcherBase) {
    MouseWatcherBase* other_this = (MouseWatcherBase*)from_this;
    return (MouseWatcher*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MouseWatcher*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (MouseWatcher*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MouseWatcher*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MouseWatcher*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MouseWatcher*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MouseWatcher*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MouseWatcherParameter
 */
/**
 * Python function wrapper for:
 * inline bool MouseWatcherParameter::has_button(void) const
 */
static PyObject *Dtool_MouseWatcherParameter_has_button_244(PyObject *self, PyObject *) {
  MouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool MouseWatcherParameter::has_button(void) const
  bool return_value = (*(const MouseWatcherParameter*)local_this).has_button();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherParameter_has_button_244_comment =
  "C++ Interface:\n"
  "has_button(MouseWatcherParameter self)\n"
  "\n"
  "/**\n"
  " * Returns true if this parameter has an associated mouse or keyboard button,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_MouseWatcherParameter_has_button_244_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ButtonHandle MouseWatcherParameter::get_button(void) const
 */
static PyObject *Dtool_MouseWatcherParameter_get_button_245(PyObject *self, PyObject *) {
  MouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ButtonHandle MouseWatcherParameter::get_button(void) const
  ButtonHandle *return_value = new ButtonHandle((*(const MouseWatcherParameter*)local_this).get_button());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherParameter_get_button_245_comment =
  "C++ Interface:\n"
  "get_button(MouseWatcherParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the mouse or keyboard button associated with this event.  If\n"
  " * has_button(), above, returns false, this returns ButtonHandle::none().\n"
  " */";
#else
static const char *Dtool_MouseWatcherParameter_get_button_245_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool MouseWatcherParameter::is_keyrepeat(void) const
 */
static PyObject *Dtool_MouseWatcherParameter_is_keyrepeat_246(PyObject *self, PyObject *) {
  MouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool MouseWatcherParameter::is_keyrepeat(void) const
  bool return_value = (*(const MouseWatcherParameter*)local_this).is_keyrepeat();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherParameter_is_keyrepeat_246_comment =
  "C++ Interface:\n"
  "is_keyrepeat(MouseWatcherParameter self)\n"
  "\n"
  "/**\n"
  " * Returns true if the button-down even was generated due to keyrepeat, or\n"
  " * false if it was an original button down.\n"
  " */";
#else
static const char *Dtool_MouseWatcherParameter_is_keyrepeat_246_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool MouseWatcherParameter::has_keycode(void) const
 */
static PyObject *Dtool_MouseWatcherParameter_has_keycode_247(PyObject *self, PyObject *) {
  MouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool MouseWatcherParameter::has_keycode(void) const
  bool return_value = (*(const MouseWatcherParameter*)local_this).has_keycode();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherParameter_has_keycode_247_comment =
  "C++ Interface:\n"
  "has_keycode(MouseWatcherParameter self)\n"
  "\n"
  "/**\n"
  " * Returns true if this parameter has an associated keycode, false otherwise.\n"
  " */";
#else
static const char *Dtool_MouseWatcherParameter_has_keycode_247_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int MouseWatcherParameter::get_keycode(void) const
 */
static PyObject *Dtool_MouseWatcherParameter_get_keycode_248(PyObject *self, PyObject *) {
  MouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int MouseWatcherParameter::get_keycode(void) const
  int return_value = (*(const MouseWatcherParameter*)local_this).get_keycode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherParameter_get_keycode_248_comment =
  "C++ Interface:\n"
  "get_keycode(MouseWatcherParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the keycode associated with this event.  If has_keycode(), above,\n"
  " * returns false, this returns 0.\n"
  " */";
#else
static const char *Dtool_MouseWatcherParameter_get_keycode_248_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool MouseWatcherParameter::has_candidate(void) const
 */
static PyObject *Dtool_MouseWatcherParameter_has_candidate_249(PyObject *self, PyObject *) {
  MouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool MouseWatcherParameter::has_candidate(void) const
  bool return_value = (*(const MouseWatcherParameter*)local_this).has_candidate();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherParameter_has_candidate_249_comment =
  "C++ Interface:\n"
  "has_candidate(MouseWatcherParameter self)\n"
  "\n"
  "/**\n"
  " * Returns true if this parameter has an associated candidate string, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_MouseWatcherParameter_has_candidate_249_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string MouseWatcherParameter::get_candidate_string_encoded(void) const
 * inline std::string MouseWatcherParameter::get_candidate_string_encoded(TextEncoder::Encoding encoding) const
 */
static PyObject *Dtool_MouseWatcherParameter_get_candidate_string_encoded_250(PyObject *self, PyObject *args) {
  MouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherParameter, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline std::string MouseWatcherParameter::get_candidate_string_encoded(void) const
      std::string return_value = (*(const MouseWatcherParameter*)local_this).get_candidate_string_encoded();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline std::string MouseWatcherParameter::get_candidate_string_encoded(TextEncoder::Encoding encoding) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        std::string return_value = (*(const MouseWatcherParameter*)local_this).get_candidate_string_encoded((TextEncoder::Encoding)arg_val);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_candidate_string_encoded() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_candidate_string_encoded(MouseWatcherParameter self)\n"
      "get_candidate_string_encoded(MouseWatcherParameter self, int encoding)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherParameter_get_candidate_string_encoded_250_comment =
  "C++ Interface:\n"
  "get_candidate_string_encoded(MouseWatcherParameter self)\n"
  "get_candidate_string_encoded(MouseWatcherParameter self, int encoding)\n"
  "\n"
  "/**\n"
  " * Returns the candidate string associated with this event.  If\n"
  " * has_candidate(), above, returns false, this returns the empty string.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the candidate string associated with this event.  If\n"
  " * has_candidate(), above, returns false, this returns the empty string.\n"
  " */";
#else
static const char *Dtool_MouseWatcherParameter_get_candidate_string_encoded_250_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t MouseWatcherParameter::get_highlight_start(void) const
 */
static PyObject *Dtool_MouseWatcherParameter_get_highlight_start_251(PyObject *self, PyObject *) {
  MouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t MouseWatcherParameter::get_highlight_start(void) const
  std::size_t return_value = (*(const MouseWatcherParameter*)local_this).get_highlight_start();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherParameter_get_highlight_start_251_comment =
  "C++ Interface:\n"
  "get_highlight_start(MouseWatcherParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the first highlighted character in the candidate string.\n"
  " */";
#else
static const char *Dtool_MouseWatcherParameter_get_highlight_start_251_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t MouseWatcherParameter::get_highlight_end(void) const
 */
static PyObject *Dtool_MouseWatcherParameter_get_highlight_end_252(PyObject *self, PyObject *) {
  MouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t MouseWatcherParameter::get_highlight_end(void) const
  std::size_t return_value = (*(const MouseWatcherParameter*)local_this).get_highlight_end();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherParameter_get_highlight_end_252_comment =
  "C++ Interface:\n"
  "get_highlight_end(MouseWatcherParameter self)\n"
  "\n"
  "/**\n"
  " * Returns one more than the last highlighted character in the candidate\n"
  " * string.\n"
  " */";
#else
static const char *Dtool_MouseWatcherParameter_get_highlight_end_252_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t MouseWatcherParameter::get_cursor_pos(void) const
 */
static PyObject *Dtool_MouseWatcherParameter_get_cursor_pos_253(PyObject *self, PyObject *) {
  MouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t MouseWatcherParameter::get_cursor_pos(void) const
  std::size_t return_value = (*(const MouseWatcherParameter*)local_this).get_cursor_pos();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherParameter_get_cursor_pos_253_comment =
  "C++ Interface:\n"
  "get_cursor_pos(MouseWatcherParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the position of the user's edit cursor within the candidate string.\n"
  " */";
#else
static const char *Dtool_MouseWatcherParameter_get_cursor_pos_253_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ModifierButtons const &MouseWatcherParameter::get_modifier_buttons(void) const
 */
static PyObject *Dtool_MouseWatcherParameter_get_modifier_buttons_254(PyObject *self, PyObject *) {
  MouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ModifierButtons const &MouseWatcherParameter::get_modifier_buttons(void) const
  ModifierButtons const *return_value = &((*(const MouseWatcherParameter*)local_this).get_modifier_buttons());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ModifierButtons, false, true);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherParameter_get_modifier_buttons_254_comment =
  "C++ Interface:\n"
  "get_modifier_buttons(MouseWatcherParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the set of modifier buttons that were being held down while the\n"
  " * event was generated.\n"
  " */";
#else
static const char *Dtool_MouseWatcherParameter_get_modifier_buttons_254_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool MouseWatcherParameter::has_mouse(void) const
 */
static PyObject *Dtool_MouseWatcherParameter_has_mouse_255(PyObject *self, PyObject *) {
  MouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool MouseWatcherParameter::has_mouse(void) const
  bool return_value = (*(const MouseWatcherParameter*)local_this).has_mouse();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherParameter_has_mouse_255_comment =
  "C++ Interface:\n"
  "has_mouse(MouseWatcherParameter self)\n"
  "\n"
  "/**\n"
  " * Returns true if this parameter has an associated mouse position, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_MouseWatcherParameter_has_mouse_255_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2 const &MouseWatcherParameter::get_mouse(void) const
 */
static PyObject *Dtool_MouseWatcherParameter_get_mouse_256(PyObject *self, PyObject *) {
  MouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2 const &MouseWatcherParameter::get_mouse(void) const
  LPoint2 const *return_value = &((*(const MouseWatcherParameter*)local_this).get_mouse());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherParameter_get_mouse_256_comment =
  "C++ Interface:\n"
  "get_mouse(MouseWatcherParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the mouse position at the time the event was generated, in the\n"
  " * normalized range (-1 .. 1).  It is valid to call this only if has_mouse()\n"
  " * returned true.\n"
  " */";
#else
static const char *Dtool_MouseWatcherParameter_get_mouse_256_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool MouseWatcherParameter::is_outside(void) const
 */
static PyObject *Dtool_MouseWatcherParameter_is_outside_257(PyObject *self, PyObject *) {
  MouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool MouseWatcherParameter::is_outside(void) const
  bool return_value = (*(const MouseWatcherParameter*)local_this).is_outside();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherParameter_is_outside_257_comment =
  "C++ Interface:\n"
  "is_outside(MouseWatcherParameter self)\n"
  "\n"
  "/**\n"
  " * Returns true if the mouse was outside the region at the time the event was\n"
  " * generated, false otherwise.  This is only valid for \"release\" type events.\n"
  " */";
#else
static const char *Dtool_MouseWatcherParameter_is_outside_257_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MouseWatcherParameter::output(ostream &out) const
 */
static PyObject *Dtool_MouseWatcherParameter_output_258(PyObject *self, PyObject *arg) {
  MouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-void MouseWatcherParameter::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "MouseWatcherParameter.output", false, true);
  if (arg_this != NULL) {
    (*(const MouseWatcherParameter*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(MouseWatcherParameter self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MouseWatcherParameter_output_258_comment =
  "C++ Interface:\n"
  "output(MouseWatcherParameter self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_MouseWatcherParameter_output_258_comment = NULL;
#endif

static int Dtool_Init_MouseWatcherParameter(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_MouseWatcherParameter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MouseWatcherParameter) {
    printf("MouseWatcherParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MouseWatcherParameter *local_this = (MouseWatcherParameter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MouseWatcherParameter) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MouseWatcherParameter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MouseWatcherParameter) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Trackball
 */
/**
 * Python function wrapper for:
 * void Trackball::reset(void)
 */
static PyObject *Dtool_Trackball_reset_261(PyObject *self, PyObject *) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Trackball, (void **)&local_this, "Trackball.reset")) {
    return NULL;
  }
  // 1-void Trackball::reset(void)
  (*local_this).reset();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Trackball_reset_261_comment =
  "C++ Interface:\n"
  "reset(const Trackball self)\n"
  "\n"
  "/**\n"
  " * Reinitializes all transforms to identity.\n"
  " */";
#else
static const char *Dtool_Trackball_reset_261_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat Trackball::get_forward_scale(void) const
 */
static PyObject *Dtool_Trackball_get_forward_scale_262(PyObject *self, PyObject *) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Trackball, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat Trackball::get_forward_scale(void) const
  PN_stdfloat return_value = (*(const Trackball*)local_this).get_forward_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Trackball_get_forward_scale_262_comment =
  "C++ Interface:\n"
  "get_forward_scale(Trackball self)\n"
  "\n"
  "/**\n"
  " * Returns the scale factor applied to forward and backward motion.  See\n"
  " * set_forward_scale().\n"
  " */";
#else
static const char *Dtool_Trackball_get_forward_scale_262_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Trackball::set_forward_scale(PN_stdfloat fwdscale)
 */
static PyObject *Dtool_Trackball_set_forward_scale_263(PyObject *self, PyObject *arg) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Trackball, (void **)&local_this, "Trackball.set_forward_scale")) {
    return NULL;
  }
  // 1-void Trackball::set_forward_scale(PN_stdfloat fwdscale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_forward_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_forward_scale(const Trackball self, float fwdscale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Trackball_set_forward_scale_263_comment =
  "C++ Interface:\n"
  "set_forward_scale(const Trackball self, float fwdscale)\n"
  "\n"
  "/**\n"
  " * Changes the scale factor applied to forward and backward motion.  The\n"
  " * larger this number, the faster the model will move in response to dollying\n"
  " * in and out.\n"
  " */";
#else
static const char *Dtool_Trackball_set_forward_scale_263_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LPoint3 const &Trackball::get_pos(void) const
 */
static PyObject *Dtool_Trackball_get_pos_264(PyObject *self, PyObject *) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Trackball, (void **)&local_this)) {
    return NULL;
  }
  // 1-LPoint3 const &Trackball::get_pos(void) const
  LPoint3 const *return_value = &((*(const Trackball*)local_this).get_pos());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Trackball_get_pos_264_comment =
  "C++ Interface:\n"
  "get_pos(Trackball self)\n"
  "\n"
  "/**\n"
  " * Return the offset from the center of rotation.\n"
  " */";
#else
static const char *Dtool_Trackball_get_pos_264_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat Trackball::get_x(void) const
 */
static PyObject *Dtool_Trackball_get_x_265(PyObject *self, PyObject *) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Trackball, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat Trackball::get_x(void) const
  PN_stdfloat return_value = (*(const Trackball*)local_this).get_x();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Trackball_get_x_265_comment =
  "C++ Interface:\n"
  "get_x(Trackball self)\n";
#else
static const char *Dtool_Trackball_get_x_265_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat Trackball::get_y(void) const
 */
static PyObject *Dtool_Trackball_get_y_266(PyObject *self, PyObject *) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Trackball, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat Trackball::get_y(void) const
  PN_stdfloat return_value = (*(const Trackball*)local_this).get_y();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Trackball_get_y_266_comment =
  "C++ Interface:\n"
  "get_y(Trackball self)\n";
#else
static const char *Dtool_Trackball_get_y_266_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat Trackball::get_z(void) const
 */
static PyObject *Dtool_Trackball_get_z_267(PyObject *self, PyObject *) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Trackball, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat Trackball::get_z(void) const
  PN_stdfloat return_value = (*(const Trackball*)local_this).get_z();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Trackball_get_z_267_comment =
  "C++ Interface:\n"
  "get_z(Trackball self)\n";
#else
static const char *Dtool_Trackball_get_z_267_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Trackball::set_pos(LVecBase3 const &vec)
 * void Trackball::set_pos(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_Trackball_set_pos_268(PyObject *self, PyObject *args, PyObject *kwds) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Trackball, (void **)&local_this, "Trackball.set_pos")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "vec");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'vec' (pos 1) not found");
      }
      // 1-void Trackball::set_pos(LVecBase3 const &vec)
      LVecBase3f arg_local;
      LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "Trackball.set_pos", "LVecBase3f");
      }
      (*local_this).set_pos(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-void Trackball::set_pos(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_pos", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_pos((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_pos() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos(const Trackball self, const LVecBase3f vec)\n"
      "set_pos(const Trackball self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Trackball_set_pos_268_comment =
  "C++ Interface:\n"
  "set_pos(const Trackball self, const LVecBase3f vec)\n"
  "set_pos(const Trackball self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Directly set the offset from the rotational origin.\n"
  " */";
#else
static const char *Dtool_Trackball_set_pos_268_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Trackball::set_x(PN_stdfloat x)
 */
static PyObject *Dtool_Trackball_set_x_269(PyObject *self, PyObject *arg) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Trackball, (void **)&local_this, "Trackball.set_x")) {
    return NULL;
  }
  // 1-void Trackball::set_x(PN_stdfloat x)
  if (PyNumber_Check(arg)) {
    (*local_this).set_x((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_x(const Trackball self, float x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Trackball_set_x_269_comment =
  "C++ Interface:\n"
  "set_x(const Trackball self, float x)\n";
#else
static const char *Dtool_Trackball_set_x_269_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Trackball::set_y(PN_stdfloat y)
 */
static PyObject *Dtool_Trackball_set_y_270(PyObject *self, PyObject *arg) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Trackball, (void **)&local_this, "Trackball.set_y")) {
    return NULL;
  }
  // 1-void Trackball::set_y(PN_stdfloat y)
  if (PyNumber_Check(arg)) {
    (*local_this).set_y((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_y(const Trackball self, float y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Trackball_set_y_270_comment =
  "C++ Interface:\n"
  "set_y(const Trackball self, float y)\n";
#else
static const char *Dtool_Trackball_set_y_270_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Trackball::set_z(PN_stdfloat z)
 */
static PyObject *Dtool_Trackball_set_z_271(PyObject *self, PyObject *arg) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Trackball, (void **)&local_this, "Trackball.set_z")) {
    return NULL;
  }
  // 1-void Trackball::set_z(PN_stdfloat z)
  if (PyNumber_Check(arg)) {
    (*local_this).set_z((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_z(const Trackball self, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Trackball_set_z_271_comment =
  "C++ Interface:\n"
  "set_z(const Trackball self, float z)\n";
#else
static const char *Dtool_Trackball_set_z_271_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVecBase3 Trackball::get_hpr(void) const
 */
static PyObject *Dtool_Trackball_get_hpr_272(PyObject *self, PyObject *) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Trackball, (void **)&local_this)) {
    return NULL;
  }
  // 1-LVecBase3 Trackball::get_hpr(void) const
  LVecBase3 *return_value = new LVecBase3((*(const Trackball*)local_this).get_hpr());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Trackball_get_hpr_272_comment =
  "C++ Interface:\n"
  "get_hpr(Trackball self)\n"
  "\n"
  "/**\n"
  " * Return the trackball's orientation.\n"
  " */";
#else
static const char *Dtool_Trackball_get_hpr_272_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat Trackball::get_h(void) const
 */
static PyObject *Dtool_Trackball_get_h_273(PyObject *self, PyObject *) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Trackball, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat Trackball::get_h(void) const
  PN_stdfloat return_value = (*(const Trackball*)local_this).get_h();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Trackball_get_h_273_comment =
  "C++ Interface:\n"
  "get_h(Trackball self)\n";
#else
static const char *Dtool_Trackball_get_h_273_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat Trackball::get_p(void) const
 */
static PyObject *Dtool_Trackball_get_p_274(PyObject *self, PyObject *) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Trackball, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat Trackball::get_p(void) const
  PN_stdfloat return_value = (*(const Trackball*)local_this).get_p();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Trackball_get_p_274_comment =
  "C++ Interface:\n"
  "get_p(Trackball self)\n";
#else
static const char *Dtool_Trackball_get_p_274_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat Trackball::get_r(void) const
 */
static PyObject *Dtool_Trackball_get_r_275(PyObject *self, PyObject *) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Trackball, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat Trackball::get_r(void) const
  PN_stdfloat return_value = (*(const Trackball*)local_this).get_r();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Trackball_get_r_275_comment =
  "C++ Interface:\n"
  "get_r(Trackball self)\n";
#else
static const char *Dtool_Trackball_get_r_275_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Trackball::set_hpr(LVecBase3 const &hpr)
 * void Trackball::set_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
 */
static PyObject *Dtool_Trackball_set_hpr_276(PyObject *self, PyObject *args, PyObject *kwds) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Trackball, (void **)&local_this, "Trackball.set_hpr")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "hpr");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'hpr' (pos 1) not found");
      }
      // 1-void Trackball::set_hpr(LVecBase3 const &hpr)
      LVecBase3f arg_local;
      LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "Trackball.set_hpr", "LVecBase3f");
      }
      (*local_this).set_hpr(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-void Trackball::set_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"h", "p", "r", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_hpr", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_hpr((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_hpr() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_hpr(const Trackball self, const LVecBase3f hpr)\n"
      "set_hpr(const Trackball self, float h, float p, float r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Trackball_set_hpr_276_comment =
  "C++ Interface:\n"
  "set_hpr(const Trackball self, const LVecBase3f hpr)\n"
  "set_hpr(const Trackball self, float h, float p, float r)\n"
  "\n"
  "/**\n"
  " * Directly set the mover's orientation.\n"
  " */";
#else
static const char *Dtool_Trackball_set_hpr_276_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Trackball::set_h(PN_stdfloat h)
 */
static PyObject *Dtool_Trackball_set_h_277(PyObject *self, PyObject *arg) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Trackball, (void **)&local_this, "Trackball.set_h")) {
    return NULL;
  }
  // 1-void Trackball::set_h(PN_stdfloat h)
  if (PyNumber_Check(arg)) {
    (*local_this).set_h((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_h(const Trackball self, float h)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Trackball_set_h_277_comment =
  "C++ Interface:\n"
  "set_h(const Trackball self, float h)\n";
#else
static const char *Dtool_Trackball_set_h_277_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Trackball::set_p(PN_stdfloat p)
 */
static PyObject *Dtool_Trackball_set_p_278(PyObject *self, PyObject *arg) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Trackball, (void **)&local_this, "Trackball.set_p")) {
    return NULL;
  }
  // 1-void Trackball::set_p(PN_stdfloat p)
  if (PyNumber_Check(arg)) {
    (*local_this).set_p((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_p(const Trackball self, float p)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Trackball_set_p_278_comment =
  "C++ Interface:\n"
  "set_p(const Trackball self, float p)\n";
#else
static const char *Dtool_Trackball_set_p_278_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Trackball::set_r(PN_stdfloat r)
 */
static PyObject *Dtool_Trackball_set_r_279(PyObject *self, PyObject *arg) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Trackball, (void **)&local_this, "Trackball.set_r")) {
    return NULL;
  }
  // 1-void Trackball::set_r(PN_stdfloat r)
  if (PyNumber_Check(arg)) {
    (*local_this).set_r((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_r(const Trackball self, float r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Trackball_set_r_279_comment =
  "C++ Interface:\n"
  "set_r(const Trackball self, float r)\n";
#else
static const char *Dtool_Trackball_set_r_279_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Trackball::reset_origin_here(void)
 */
static PyObject *Dtool_Trackball_reset_origin_here_280(PyObject *self, PyObject *) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Trackball, (void **)&local_this, "Trackball.reset_origin_here")) {
    return NULL;
  }
  // 1-void Trackball::reset_origin_here(void)
  (*local_this).reset_origin_here();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Trackball_reset_origin_here_280_comment =
  "C++ Interface:\n"
  "reset_origin_here(const Trackball self)\n"
  "\n"
  "/**\n"
  " * Reposition the center of rotation to coincide with the current translation\n"
  " * offset.  Future rotations will be about the current origin.\n"
  " */";
#else
static const char *Dtool_Trackball_reset_origin_here_280_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Trackball::move_origin(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_Trackball_move_origin_281(PyObject *self, PyObject *args, PyObject *kwds) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Trackball, (void **)&local_this, "Trackball.move_origin")) {
    return NULL;
  }
  // 1-void Trackball::move_origin(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
  float param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"x", "y", "z", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:move_origin", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).move_origin((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "move_origin(const Trackball self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Trackball_move_origin_281_comment =
  "C++ Interface:\n"
  "move_origin(const Trackball self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Moves the center of rotation by the given amount.\n"
  " */";
#else
static const char *Dtool_Trackball_move_origin_281_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LPoint3 Trackball::get_origin(void) const
 */
static PyObject *Dtool_Trackball_get_origin_282(PyObject *self, PyObject *) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Trackball, (void **)&local_this)) {
    return NULL;
  }
  // 1-LPoint3 Trackball::get_origin(void) const
  LPoint3 *return_value = new LPoint3((*(const Trackball*)local_this).get_origin());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Trackball_get_origin_282_comment =
  "C++ Interface:\n"
  "get_origin(Trackball self)\n"
  "\n"
  "/**\n"
  " * Returns the current center of rotation.\n"
  " */";
#else
static const char *Dtool_Trackball_get_origin_282_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Trackball::set_origin(LVecBase3 const &origin)
 */
static PyObject *Dtool_Trackball_set_origin_283(PyObject *self, PyObject *arg) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Trackball, (void **)&local_this, "Trackball.set_origin")) {
    return NULL;
  }
  // 1-void Trackball::set_origin(LVecBase3 const &origin)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Trackball.set_origin", "LVecBase3f");
  }
  (*local_this).set_origin(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_origin(const Trackball self, const LVecBase3f origin)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Trackball_set_origin_283_comment =
  "C++ Interface:\n"
  "set_origin(const Trackball self, const LVecBase3f origin)\n"
  "\n"
  "/**\n"
  " * Directly sets the center of rotation.\n"
  " */";
#else
static const char *Dtool_Trackball_set_origin_283_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Trackball::set_control_mode(Trackball::ControlMode control_mode)
 */
static PyObject *Dtool_Trackball_set_control_mode_285(PyObject *self, PyObject *arg) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Trackball, (void **)&local_this, "Trackball.set_control_mode")) {
    return NULL;
  }
  // 1-void Trackball::set_control_mode(Trackball::ControlMode control_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_control_mode((Trackball::ControlMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_control_mode(const Trackball self, int control_mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Trackball_set_control_mode_285_comment =
  "C++ Interface:\n"
  "set_control_mode(const Trackball self, int control_mode)\n"
  "\n"
  "/**\n"
  " * Sets the control mode.  Normally this is CM_default, which means each mouse\n"
  " * button serves its normal function.  When it is CM_truck, CM_pan, CM_dolly,\n"
  " * or CM_roll, all of the mouse buttons serve the indicated function instead\n"
  " * of their normal function.  This can be used in conjunction with some\n"
  " * external way of changing modes.\n"
  " */";
#else
static const char *Dtool_Trackball_set_control_mode_285_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Trackball::ControlMode Trackball::get_control_mode(void) const
 */
static PyObject *Dtool_Trackball_get_control_mode_286(PyObject *self, PyObject *) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Trackball, (void **)&local_this)) {
    return NULL;
  }
  // 1-Trackball::ControlMode Trackball::get_control_mode(void) const
  Trackball::ControlMode return_value = (*(const Trackball*)local_this).get_control_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Trackball_get_control_mode_286_comment =
  "C++ Interface:\n"
  "get_control_mode(Trackball self)\n"
  "\n"
  "/**\n"
  " * Returns the control mode.  See set_control_mode().\n"
  " */";
#else
static const char *Dtool_Trackball_get_control_mode_286_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Trackball::set_invert(bool flag)
 */
static PyObject *Dtool_Trackball_set_invert_287(PyObject *self, PyObject *arg) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Trackball, (void **)&local_this, "Trackball.set_invert")) {
    return NULL;
  }
  // 1-void Trackball::set_invert(bool flag)
  (*local_this).set_invert((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_invert(const Trackball self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Trackball_set_invert_287_comment =
  "C++ Interface:\n"
  "set_invert(const Trackball self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the invert flag.  When this is set, the inverse matrix is generated,\n"
  " * suitable for joining to a camera, instead of parenting the scene under it.\n"
  " */";
#else
static const char *Dtool_Trackball_set_invert_287_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Trackball::get_invert(void) const
 */
static PyObject *Dtool_Trackball_get_invert_288(PyObject *self, PyObject *) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Trackball, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Trackball::get_invert(void) const
  bool return_value = (*(const Trackball*)local_this).get_invert();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Trackball_get_invert_288_comment =
  "C++ Interface:\n"
  "get_invert(Trackball self)\n"
  "\n"
  "/**\n"
  " * Returns the invert flag.  When this is set, the inverse matrix is\n"
  " * generated, suitable for joining to a camera, instead of parenting the scene\n"
  " * under it.\n"
  " */";
#else
static const char *Dtool_Trackball_get_invert_288_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Trackball::set_rel_to(NodePath const &rel_to)
 */
static PyObject *Dtool_Trackball_set_rel_to_289(PyObject *self, PyObject *arg) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Trackball, (void **)&local_this, "Trackball.set_rel_to")) {
    return NULL;
  }
  // 1-void Trackball::set_rel_to(NodePath const &rel_to)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "Trackball.set_rel_to", true, true);
  if (arg_this != NULL) {
    (*local_this).set_rel_to(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rel_to(const Trackball self, const NodePath rel_to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Trackball_set_rel_to_289_comment =
  "C++ Interface:\n"
  "set_rel_to(const Trackball self, const NodePath rel_to)\n"
  "\n"
  "/**\n"
  " * Sets the NodePath that all trackball manipulations are to be assumed to be\n"
  " * relative to.  For instance, set your camera node here to make the trackball\n"
  " * motion camera relative.  The default is the empty path, which means\n"
  " * trackball motion is in global space.\n"
  " */";
#else
static const char *Dtool_Trackball_set_rel_to_289_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePath const &Trackball::get_rel_to(void) const
 */
static PyObject *Dtool_Trackball_get_rel_to_290(PyObject *self, PyObject *) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Trackball, (void **)&local_this)) {
    return NULL;
  }
  // 1-NodePath const &Trackball::get_rel_to(void) const
  NodePath const *return_value = &((*(const Trackball*)local_this).get_rel_to());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Trackball_get_rel_to_290_comment =
  "C++ Interface:\n"
  "get_rel_to(Trackball self)\n"
  "\n"
  "/**\n"
  " * Returns the NodePath that all trackball manipulations are relative to, or\n"
  " * the empty path.\n"
  " */";
#else
static const char *Dtool_Trackball_get_rel_to_290_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Trackball::set_coordinate_system(CoordinateSystem cs)
 */
static PyObject *Dtool_Trackball_set_coordinate_system_291(PyObject *self, PyObject *arg) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Trackball, (void **)&local_this, "Trackball.set_coordinate_system")) {
    return NULL;
  }
  // 1-void Trackball::set_coordinate_system(CoordinateSystem cs)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_coordinate_system((CoordinateSystem)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_coordinate_system(const Trackball self, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Trackball_set_coordinate_system_291_comment =
  "C++ Interface:\n"
  "set_coordinate_system(const Trackball self, int cs)\n"
  "\n"
  "/**\n"
  " * Sets the coordinate system of the Trackball.  Normally, this is the default\n"
  " * coordinate system.  This changes the axes the Trackball manipulates so that\n"
  " * the user interface remains consistent across different coordinate systems.\n"
  " */";
#else
static const char *Dtool_Trackball_set_coordinate_system_291_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CoordinateSystem Trackball::get_coordinate_system(void) const
 */
static PyObject *Dtool_Trackball_get_coordinate_system_292(PyObject *self, PyObject *) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Trackball, (void **)&local_this)) {
    return NULL;
  }
  // 1-CoordinateSystem Trackball::get_coordinate_system(void) const
  CoordinateSystem return_value = (*(const Trackball*)local_this).get_coordinate_system();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Trackball_get_coordinate_system_292_comment =
  "C++ Interface:\n"
  "get_coordinate_system(Trackball self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate system of the Trackball.  See\n"
  " * set_coordinate_system().\n"
  " */";
#else
static const char *Dtool_Trackball_get_coordinate_system_292_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Trackball::set_mat(LMatrix4 const &mat)
 */
static PyObject *Dtool_Trackball_set_mat_293(PyObject *self, PyObject *arg) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Trackball, (void **)&local_this, "Trackball.set_mat")) {
    return NULL;
  }
  // 1-void Trackball::set_mat(LMatrix4 const &mat)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Trackball.set_mat", "LMatrix4f");
  }
  (*local_this).set_mat(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mat(const Trackball self, const LMatrix4f mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Trackball_set_mat_293_comment =
  "C++ Interface:\n"
  "set_mat(const Trackball self, const LMatrix4f mat)\n"
  "\n"
  "/**\n"
  " * Stores the indicated transform in the trackball.  This is a transform in\n"
  " * global space, regardless of the rel_to node.\n"
  " */";
#else
static const char *Dtool_Trackball_set_mat_293_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LMatrix4 const &Trackball::get_mat(void) const
 */
static PyObject *Dtool_Trackball_get_mat_294(PyObject *self, PyObject *) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Trackball, (void **)&local_this)) {
    return NULL;
  }
  // 1-LMatrix4 const &Trackball::get_mat(void) const
  LMatrix4 const *return_value = &((*(const Trackball*)local_this).get_mat());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Trackball_get_mat_294_comment =
  "C++ Interface:\n"
  "get_mat(Trackball self)\n"
  "\n"
  "/**\n"
  " * Returns the matrix represented by the trackball rotation.\n"
  " */";
#else
static const char *Dtool_Trackball_get_mat_294_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LMatrix4 const &Trackball::get_trans_mat(void) const
 */
static PyObject *Dtool_Trackball_get_trans_mat_295(PyObject *self, PyObject *) {
  Trackball *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Trackball, (void **)&local_this)) {
    return NULL;
  }
  // 1-LMatrix4 const &Trackball::get_trans_mat(void) const
  LMatrix4 const *return_value = &((*(const Trackball*)local_this).get_trans_mat());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Trackball_get_trans_mat_295_comment =
  "C++ Interface:\n"
  "get_trans_mat(Trackball self)\n"
  "\n"
  "/**\n"
  " * Returns the actual transform that will be applied to the scene graph.  This\n"
  " * is the same as get_mat(), unless invert is in effect.\n"
  " */";
#else
static const char *Dtool_Trackball_get_trans_mat_295_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Trackball::get_class_type(void)
 */
static PyObject *Dtool_Trackball_get_class_type_296(PyObject *, PyObject *) {
  // 1-static TypeHandle Trackball::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(Trackball::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Trackball_get_class_type_296_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Trackball_get_class_type_296_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Trackball::Trackball(Trackball const &) = default
 * Trackball::Trackball(std::string const &name)
 */
static int Dtool_Init_Trackball(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Trackball() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline Trackball::Trackball(Trackball const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Trackball", (char **)keyword_list, &param0)) {
      Trackball const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Trackball, (void **)&param0_this);
      if (param0_this != NULL) {
        Trackball *return_value = new Trackball(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Trackball, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 Trackball::Trackball(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:Trackball", (char **)keyword_list, &param0_str, &param0_len)) {
      Trackball *return_value = new Trackball(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Trackball, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline Trackball::Trackball(Trackball const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Trackball", (char **)keyword_list, &param0)) {
      CPT(Trackball) param0_this;
      if (Dtool_ConstCoerce_Trackball(param0, param0_this)) {
        Trackball *return_value = new Trackball(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Trackball, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: Trackball::Trackball(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Trackball(const Trackball param0)\n"
      "Trackball(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Trackball(PyObject *args, CPT(Trackball) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Trackball, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Trackball::Trackball(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      Trackball *return_value = new Trackball(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_Trackball(PyObject *args, PT(Trackball) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Trackball, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Trackball::Trackball(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      Trackball *return_value = new Trackball(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_Trackball(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Trackball) {
    printf("Trackball ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Trackball *local_this = (Trackball *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Trackball) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *)(MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_MouseInterfaceNode) {
    return (MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *)(MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *)(MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *)(MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *)(MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *)(MouseInterfaceNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *)(MouseInterfaceNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Trackball(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Trackball) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (Trackball*)other_this;
  }
  if (from_type == Dtool_Ptr_MouseInterfaceNode) {
    MouseInterfaceNode* other_this = (MouseInterfaceNode*)from_this;
    return (Trackball*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (Trackball*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (Trackball*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Trackball*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Trackball*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (Trackball*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (Trackball*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Transform2SG
 */
/**
 * Python function wrapper for:
 * void Transform2SG::set_node(PandaNode *node)
 */
static PyObject *Dtool_Transform2SG_set_node_299(PyObject *self, PyObject *arg) {
  Transform2SG *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Transform2SG, (void **)&local_this, "Transform2SG.set_node")) {
    return NULL;
  }
  // 1-void Transform2SG::set_node(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "Transform2SG.set_node", false, true);
  if (arg_this != NULL) {
    (*local_this).set_node(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_node(const Transform2SG self, PandaNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Transform2SG_set_node_299_comment =
  "C++ Interface:\n"
  "set_node(const Transform2SG self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Sets the node that this object will adjust.\n"
  " */";
#else
static const char *Dtool_Transform2SG_set_node_299_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PandaNode *Transform2SG::get_node(void) const
 */
static PyObject *Dtool_Transform2SG_get_node_300(PyObject *self, PyObject *) {
  Transform2SG *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Transform2SG, (void **)&local_this)) {
    return NULL;
  }
  // 1-PandaNode *Transform2SG::get_node(void) const
  PandaNode *return_value = (*(const Transform2SG*)local_this).get_node();
  if (return_value != (PandaNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PandaNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Transform2SG_get_node_300_comment =
  "C++ Interface:\n"
  "get_node(Transform2SG self)\n"
  "\n"
  "/**\n"
  " * Returns the node that this object will adjust, or NULL if the node has not\n"
  " * yet been set.\n"
  " */";
#else
static const char *Dtool_Transform2SG_get_node_300_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Transform2SG::get_class_type(void)
 */
static PyObject *Dtool_Transform2SG_get_class_type_301(PyObject *, PyObject *) {
  // 1-static TypeHandle Transform2SG::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(Transform2SG::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Transform2SG_get_class_type_301_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Transform2SG_get_class_type_301_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Transform2SG::Transform2SG(Transform2SG const &) = default
 * Transform2SG::Transform2SG(std::string const &name)
 */
static int Dtool_Init_Transform2SG(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Transform2SG() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline Transform2SG::Transform2SG(Transform2SG const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Transform2SG", (char **)keyword_list, &param0)) {
      Transform2SG const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Transform2SG, (void **)&param0_this);
      if (param0_this != NULL) {
        Transform2SG *return_value = new Transform2SG(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Transform2SG, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 Transform2SG::Transform2SG(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:Transform2SG", (char **)keyword_list, &param0_str, &param0_len)) {
      Transform2SG *return_value = new Transform2SG(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Transform2SG, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline Transform2SG::Transform2SG(Transform2SG const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Transform2SG", (char **)keyword_list, &param0)) {
      CPT(Transform2SG) param0_this;
      if (Dtool_ConstCoerce_Transform2SG(param0, param0_this)) {
        Transform2SG *return_value = new Transform2SG(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Transform2SG, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: Transform2SG::Transform2SG(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Transform2SG(const Transform2SG param0)\n"
      "Transform2SG(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Transform2SG(PyObject *args, CPT(Transform2SG) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Transform2SG, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Transform2SG::Transform2SG(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      Transform2SG *return_value = new Transform2SG(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_Transform2SG(PyObject *args, PT(Transform2SG) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Transform2SG, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Transform2SG::Transform2SG(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      Transform2SG *return_value = new Transform2SG(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_Transform2SG(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Transform2SG) {
    printf("Transform2SG ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Transform2SG *local_this = (Transform2SG *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Transform2SG) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Transform2SG(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Transform2SG) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (Transform2SG*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (Transform2SG*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (Transform2SG*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Transform2SG*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Transform2SG*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (Transform2SG*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (Transform2SG*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for ButtonThrower (ButtonThrower)
 */
static PyMethodDef Dtool_Methods_ButtonThrower[] = {
  {"set_button_down_event", &Dtool_ButtonThrower_set_button_down_event_4, METH_O, (const char *)Dtool_ButtonThrower_set_button_down_event_4_comment},
  {"setButtonDownEvent", &Dtool_ButtonThrower_set_button_down_event_4, METH_O, (const char *)Dtool_ButtonThrower_set_button_down_event_4_comment},
  {"get_button_down_event", &Dtool_ButtonThrower_get_button_down_event_5, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_button_down_event_5_comment},
  {"getButtonDownEvent", &Dtool_ButtonThrower_get_button_down_event_5, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_button_down_event_5_comment},
  {"set_button_up_event", &Dtool_ButtonThrower_set_button_up_event_6, METH_O, (const char *)Dtool_ButtonThrower_set_button_up_event_6_comment},
  {"setButtonUpEvent", &Dtool_ButtonThrower_set_button_up_event_6, METH_O, (const char *)Dtool_ButtonThrower_set_button_up_event_6_comment},
  {"get_button_up_event", &Dtool_ButtonThrower_get_button_up_event_7, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_button_up_event_7_comment},
  {"getButtonUpEvent", &Dtool_ButtonThrower_get_button_up_event_7, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_button_up_event_7_comment},
  {"set_button_repeat_event", &Dtool_ButtonThrower_set_button_repeat_event_8, METH_O, (const char *)Dtool_ButtonThrower_set_button_repeat_event_8_comment},
  {"setButtonRepeatEvent", &Dtool_ButtonThrower_set_button_repeat_event_8, METH_O, (const char *)Dtool_ButtonThrower_set_button_repeat_event_8_comment},
  {"get_button_repeat_event", &Dtool_ButtonThrower_get_button_repeat_event_9, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_button_repeat_event_9_comment},
  {"getButtonRepeatEvent", &Dtool_ButtonThrower_get_button_repeat_event_9, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_button_repeat_event_9_comment},
  {"set_keystroke_event", &Dtool_ButtonThrower_set_keystroke_event_10, METH_O, (const char *)Dtool_ButtonThrower_set_keystroke_event_10_comment},
  {"setKeystrokeEvent", &Dtool_ButtonThrower_set_keystroke_event_10, METH_O, (const char *)Dtool_ButtonThrower_set_keystroke_event_10_comment},
  {"get_keystroke_event", &Dtool_ButtonThrower_get_keystroke_event_11, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_keystroke_event_11_comment},
  {"getKeystrokeEvent", &Dtool_ButtonThrower_get_keystroke_event_11, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_keystroke_event_11_comment},
  {"set_candidate_event", &Dtool_ButtonThrower_set_candidate_event_12, METH_O, (const char *)Dtool_ButtonThrower_set_candidate_event_12_comment},
  {"setCandidateEvent", &Dtool_ButtonThrower_set_candidate_event_12, METH_O, (const char *)Dtool_ButtonThrower_set_candidate_event_12_comment},
  {"get_candidate_event", &Dtool_ButtonThrower_get_candidate_event_13, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_candidate_event_13_comment},
  {"getCandidateEvent", &Dtool_ButtonThrower_get_candidate_event_13, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_candidate_event_13_comment},
  {"set_move_event", &Dtool_ButtonThrower_set_move_event_14, METH_O, (const char *)Dtool_ButtonThrower_set_move_event_14_comment},
  {"setMoveEvent", &Dtool_ButtonThrower_set_move_event_14, METH_O, (const char *)Dtool_ButtonThrower_set_move_event_14_comment},
  {"get_move_event", &Dtool_ButtonThrower_get_move_event_15, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_move_event_15_comment},
  {"getMoveEvent", &Dtool_ButtonThrower_get_move_event_15, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_move_event_15_comment},
  {"set_raw_button_down_event", &Dtool_ButtonThrower_set_raw_button_down_event_16, METH_O, (const char *)Dtool_ButtonThrower_set_raw_button_down_event_16_comment},
  {"setRawButtonDownEvent", &Dtool_ButtonThrower_set_raw_button_down_event_16, METH_O, (const char *)Dtool_ButtonThrower_set_raw_button_down_event_16_comment},
  {"get_raw_button_down_event", &Dtool_ButtonThrower_get_raw_button_down_event_17, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_raw_button_down_event_17_comment},
  {"getRawButtonDownEvent", &Dtool_ButtonThrower_get_raw_button_down_event_17, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_raw_button_down_event_17_comment},
  {"set_raw_button_up_event", &Dtool_ButtonThrower_set_raw_button_up_event_18, METH_O, (const char *)Dtool_ButtonThrower_set_raw_button_up_event_18_comment},
  {"setRawButtonUpEvent", &Dtool_ButtonThrower_set_raw_button_up_event_18, METH_O, (const char *)Dtool_ButtonThrower_set_raw_button_up_event_18_comment},
  {"get_raw_button_up_event", &Dtool_ButtonThrower_get_raw_button_up_event_19, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_raw_button_up_event_19_comment},
  {"getRawButtonUpEvent", &Dtool_ButtonThrower_get_raw_button_up_event_19, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_raw_button_up_event_19_comment},
  {"set_prefix", &Dtool_ButtonThrower_set_prefix_31, METH_O, (const char *)Dtool_ButtonThrower_set_prefix_31_comment},
  {"setPrefix", &Dtool_ButtonThrower_set_prefix_31, METH_O, (const char *)Dtool_ButtonThrower_set_prefix_31_comment},
  {"get_prefix", &Dtool_ButtonThrower_get_prefix_32, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_prefix_32_comment},
  {"getPrefix", &Dtool_ButtonThrower_get_prefix_32, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_prefix_32_comment},
  {"set_specific_flag", &Dtool_ButtonThrower_set_specific_flag_33, METH_O, (const char *)Dtool_ButtonThrower_set_specific_flag_33_comment},
  {"setSpecificFlag", &Dtool_ButtonThrower_set_specific_flag_33, METH_O, (const char *)Dtool_ButtonThrower_set_specific_flag_33_comment},
  {"get_specific_flag", &Dtool_ButtonThrower_get_specific_flag_34, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_specific_flag_34_comment},
  {"getSpecificFlag", &Dtool_ButtonThrower_get_specific_flag_34, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_specific_flag_34_comment},
  {"set_time_flag", &Dtool_ButtonThrower_set_time_flag_38, METH_O, (const char *)Dtool_ButtonThrower_set_time_flag_38_comment},
  {"setTimeFlag", &Dtool_ButtonThrower_set_time_flag_38, METH_O, (const char *)Dtool_ButtonThrower_set_time_flag_38_comment},
  {"get_time_flag", &Dtool_ButtonThrower_get_time_flag_39, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_time_flag_39_comment},
  {"getTimeFlag", &Dtool_ButtonThrower_get_time_flag_39, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_time_flag_39_comment},
  {"add_parameter", &Dtool_ButtonThrower_add_parameter_41, METH_O, (const char *)Dtool_ButtonThrower_add_parameter_41_comment},
  {"addParameter", &Dtool_ButtonThrower_add_parameter_41, METH_O, (const char *)Dtool_ButtonThrower_add_parameter_41_comment},
  {"get_num_parameters", &Dtool_ButtonThrower_get_num_parameters_42, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_num_parameters_42_comment},
  {"getNumParameters", &Dtool_ButtonThrower_get_num_parameters_42, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_num_parameters_42_comment},
  {"get_parameter", &Dtool_ButtonThrower_get_parameter_43, METH_O, (const char *)Dtool_ButtonThrower_get_parameter_43_comment},
  {"getParameter", &Dtool_ButtonThrower_get_parameter_43, METH_O, (const char *)Dtool_ButtonThrower_get_parameter_43_comment},
  {"get_modifier_buttons", &Dtool_ButtonThrower_get_modifier_buttons_47, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_modifier_buttons_47_comment},
  {"getModifierButtons", &Dtool_ButtonThrower_get_modifier_buttons_47, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_modifier_buttons_47_comment},
  {"set_modifier_buttons", &Dtool_ButtonThrower_set_modifier_buttons_48, METH_O, (const char *)Dtool_ButtonThrower_set_modifier_buttons_48_comment},
  {"setModifierButtons", &Dtool_ButtonThrower_set_modifier_buttons_48, METH_O, (const char *)Dtool_ButtonThrower_set_modifier_buttons_48_comment},
  {"set_throw_buttons_active", &Dtool_ButtonThrower_set_throw_buttons_active_52, METH_O, (const char *)Dtool_ButtonThrower_set_throw_buttons_active_52_comment},
  {"setThrowButtonsActive", &Dtool_ButtonThrower_set_throw_buttons_active_52, METH_O, (const char *)Dtool_ButtonThrower_set_throw_buttons_active_52_comment},
  {"get_throw_buttons_active", &Dtool_ButtonThrower_get_throw_buttons_active_53, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_throw_buttons_active_53_comment},
  {"getThrowButtonsActive", &Dtool_ButtonThrower_get_throw_buttons_active_53, METH_NOARGS, (const char *)Dtool_ButtonThrower_get_throw_buttons_active_53_comment},
  {"add_throw_button", (PyCFunction) &Dtool_ButtonThrower_add_throw_button_55, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ButtonThrower_add_throw_button_55_comment},
  {"addThrowButton", (PyCFunction) &Dtool_ButtonThrower_add_throw_button_55, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ButtonThrower_add_throw_button_55_comment},
  {"remove_throw_button", (PyCFunction) &Dtool_ButtonThrower_remove_throw_button_56, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ButtonThrower_remove_throw_button_56_comment},
  {"removeThrowButton", (PyCFunction) &Dtool_ButtonThrower_remove_throw_button_56, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ButtonThrower_remove_throw_button_56_comment},
  {"has_throw_button", (PyCFunction) &Dtool_ButtonThrower_has_throw_button_57, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ButtonThrower_has_throw_button_57_comment},
  {"hasThrowButton", (PyCFunction) &Dtool_ButtonThrower_has_throw_button_57, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ButtonThrower_has_throw_button_57_comment},
  {"clear_throw_buttons", &Dtool_ButtonThrower_clear_throw_buttons_58, METH_NOARGS, (const char *)Dtool_ButtonThrower_clear_throw_buttons_58_comment},
  {"clearThrowButtons", &Dtool_ButtonThrower_clear_throw_buttons_58, METH_NOARGS, (const char *)Dtool_ButtonThrower_clear_throw_buttons_58_comment},
  {"get_class_type", &Dtool_ButtonThrower_get_class_type_59, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonThrower_get_class_type_59_comment},
  {"getClassType", &Dtool_ButtonThrower_get_class_type_59, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonThrower_get_class_type_59_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_parameters", (PyCFunction) &MakeSeq_ButtonThrower_get_parameters, METH_NOARGS, NULL},
  { "getParameters", (PyCFunction) &MakeSeq_ButtonThrower_get_parameters, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ButtonThrower[] = {
  {(char *)"button_down_event", &Dtool_ButtonThrower_button_down_event_Getter, &Dtool_ButtonThrower_button_down_event_Setter, NULL, NULL},
  {(char *)"button_up_event", &Dtool_ButtonThrower_button_up_event_Getter, &Dtool_ButtonThrower_button_up_event_Setter, NULL, NULL},
  {(char *)"button_repeat_event", &Dtool_ButtonThrower_button_repeat_event_Getter, &Dtool_ButtonThrower_button_repeat_event_Setter, NULL, NULL},
  {(char *)"keystroke_event", &Dtool_ButtonThrower_keystroke_event_Getter, &Dtool_ButtonThrower_keystroke_event_Setter, NULL, NULL},
  {(char *)"candidate_event", &Dtool_ButtonThrower_candidate_event_Getter, &Dtool_ButtonThrower_candidate_event_Setter, NULL, NULL},
  {(char *)"move_event", &Dtool_ButtonThrower_move_event_Getter, &Dtool_ButtonThrower_move_event_Setter, NULL, NULL},
  {(char *)"raw_button_down_event", &Dtool_ButtonThrower_raw_button_down_event_Getter, &Dtool_ButtonThrower_raw_button_down_event_Setter, NULL, NULL},
  {(char *)"raw_button_up_event", &Dtool_ButtonThrower_raw_button_up_event_Getter, &Dtool_ButtonThrower_raw_button_up_event_Setter, NULL, NULL},
  {(char *)"prefix", &Dtool_ButtonThrower_prefix_Getter, &Dtool_ButtonThrower_prefix_Setter, NULL, NULL},
  {(char *)"specific_flag", &Dtool_ButtonThrower_specific_flag_Getter, &Dtool_ButtonThrower_specific_flag_Setter, NULL, NULL},
  {(char *)"time_flag", &Dtool_ButtonThrower_time_flag_Getter, &Dtool_ButtonThrower_time_flag_Setter, NULL, NULL},
  {(char *)"parameters", &Dtool_ButtonThrower_parameters_Getter, NULL, NULL, NULL},
  {(char *)"modifier_buttons", &Dtool_ButtonThrower_modifier_buttons_Getter, &Dtool_ButtonThrower_modifier_buttons_Setter, NULL, NULL},
  {(char *)"throw_buttons_active", &Dtool_ButtonThrower_throw_buttons_active_Getter, &Dtool_ButtonThrower_throw_buttons_active_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ButtonThrower = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ButtonThrower = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ButtonThrower = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ButtonThrower = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ButtonThrower = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ButtonThrower",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ButtonThrower,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ButtonThrower,
    &Dtool_SequenceMethods_ButtonThrower,
    &Dtool_MappingMethods_ButtonThrower,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ButtonThrower,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Throws Panda Events for button down/up events generated within the data\n"
    " * graph.\n"
    " *\n"
    " * This is a DataNode which is intended to be parented to the data graph below\n"
    " * a device which is generating a sequence of button events, like a\n"
    " * MouseAndKeyboard device.  It simply takes each button it finds and throws a\n"
    " * corresponding event based on the button name via the throw_event() call.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ButtonThrower,
    0, // tp_members
    Dtool_Properties_ButtonThrower,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ButtonThrower,
    PyType_GenericAlloc,
    Dtool_new_ButtonThrower,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ButtonThrower,
  Dtool_UpcastInterface_ButtonThrower,
  Dtool_DowncastInterface_ButtonThrower,
  (CoerceFunction)Dtool_ConstCoerce_ButtonThrower,
  (CoerceFunction)Dtool_Coerce_ButtonThrower,
};

static void Dtool_PyModuleClassInit_ButtonThrower(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != NULL);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(NULL);
    Dtool_ButtonThrower._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DataNode);
    PyObject *dict = PyDict_New();
    Dtool_ButtonThrower._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ButtonThrower) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ButtonThrower)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ButtonThrower);
  }
}

/**
 * Python method tables for MouseInterfaceNode (MouseInterfaceNode)
 */
static PyMethodDef Dtool_Methods_MouseInterfaceNode[] = {
  {"require_button", (PyCFunction) &Dtool_MouseInterfaceNode_require_button_61, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseInterfaceNode_require_button_61_comment},
  {"requireButton", (PyCFunction) &Dtool_MouseInterfaceNode_require_button_61, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseInterfaceNode_require_button_61_comment},
  {"clear_button", &Dtool_MouseInterfaceNode_clear_button_62, METH_O, (const char *)Dtool_MouseInterfaceNode_clear_button_62_comment},
  {"clearButton", &Dtool_MouseInterfaceNode_clear_button_62, METH_O, (const char *)Dtool_MouseInterfaceNode_clear_button_62_comment},
  {"clear_all_buttons", &Dtool_MouseInterfaceNode_clear_all_buttons_63, METH_NOARGS, (const char *)Dtool_MouseInterfaceNode_clear_all_buttons_63_comment},
  {"clearAllButtons", &Dtool_MouseInterfaceNode_clear_all_buttons_63, METH_NOARGS, (const char *)Dtool_MouseInterfaceNode_clear_all_buttons_63_comment},
  {"get_class_type", &Dtool_MouseInterfaceNode_get_class_type_64, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseInterfaceNode_get_class_type_64_comment},
  {"getClassType", &Dtool_MouseInterfaceNode_get_class_type_64, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseInterfaceNode_get_class_type_64_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MouseInterfaceNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MouseInterfaceNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_MouseInterfaceNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_MouseInterfaceNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_MouseInterfaceNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MouseInterfaceNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MouseInterfaceNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MouseInterfaceNode,
    &Dtool_SequenceMethods_MouseInterfaceNode,
    &Dtool_MappingMethods_MouseInterfaceNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_MouseInterfaceNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for some classes that monitor the mouse and keyboard\n"
    " * input and perform some action due to their state.\n"
    " *\n"
    " * It collects together some common interface; in particular, the\n"
    " * require_button() and related methods.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MouseInterfaceNode,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MouseInterfaceNode,
    PyType_GenericAlloc,
    Dtool_new_MouseInterfaceNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MouseInterfaceNode,
  Dtool_UpcastInterface_MouseInterfaceNode,
  Dtool_DowncastInterface_MouseInterfaceNode,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MouseInterfaceNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != NULL);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(NULL);
    Dtool_MouseInterfaceNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DataNode);
    PyObject *dict = PyDict_New();
    Dtool_MouseInterfaceNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MouseInterfaceNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MouseInterfaceNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MouseInterfaceNode);
  }
}

/**
 * Python method tables for DriveInterface (DriveInterface)
 */
static PyMethodDef Dtool_Methods_DriveInterface[] = {
  {"set_forward_speed", &Dtool_DriveInterface_set_forward_speed_68, METH_O, (const char *)Dtool_DriveInterface_set_forward_speed_68_comment},
  {"setForwardSpeed", &Dtool_DriveInterface_set_forward_speed_68, METH_O, (const char *)Dtool_DriveInterface_set_forward_speed_68_comment},
  {"get_forward_speed", &Dtool_DriveInterface_get_forward_speed_69, METH_NOARGS, (const char *)Dtool_DriveInterface_get_forward_speed_69_comment},
  {"getForwardSpeed", &Dtool_DriveInterface_get_forward_speed_69, METH_NOARGS, (const char *)Dtool_DriveInterface_get_forward_speed_69_comment},
  {"set_reverse_speed", &Dtool_DriveInterface_set_reverse_speed_70, METH_O, (const char *)Dtool_DriveInterface_set_reverse_speed_70_comment},
  {"setReverseSpeed", &Dtool_DriveInterface_set_reverse_speed_70, METH_O, (const char *)Dtool_DriveInterface_set_reverse_speed_70_comment},
  {"get_reverse_speed", &Dtool_DriveInterface_get_reverse_speed_71, METH_NOARGS, (const char *)Dtool_DriveInterface_get_reverse_speed_71_comment},
  {"getReverseSpeed", &Dtool_DriveInterface_get_reverse_speed_71, METH_NOARGS, (const char *)Dtool_DriveInterface_get_reverse_speed_71_comment},
  {"set_rotate_speed", &Dtool_DriveInterface_set_rotate_speed_72, METH_O, (const char *)Dtool_DriveInterface_set_rotate_speed_72_comment},
  {"setRotateSpeed", &Dtool_DriveInterface_set_rotate_speed_72, METH_O, (const char *)Dtool_DriveInterface_set_rotate_speed_72_comment},
  {"get_rotate_speed", &Dtool_DriveInterface_get_rotate_speed_73, METH_NOARGS, (const char *)Dtool_DriveInterface_get_rotate_speed_73_comment},
  {"getRotateSpeed", &Dtool_DriveInterface_get_rotate_speed_73, METH_NOARGS, (const char *)Dtool_DriveInterface_get_rotate_speed_73_comment},
  {"set_vertical_dead_zone", &Dtool_DriveInterface_set_vertical_dead_zone_74, METH_O, (const char *)Dtool_DriveInterface_set_vertical_dead_zone_74_comment},
  {"setVerticalDeadZone", &Dtool_DriveInterface_set_vertical_dead_zone_74, METH_O, (const char *)Dtool_DriveInterface_set_vertical_dead_zone_74_comment},
  {"get_vertical_dead_zone", &Dtool_DriveInterface_get_vertical_dead_zone_75, METH_NOARGS, (const char *)Dtool_DriveInterface_get_vertical_dead_zone_75_comment},
  {"getVerticalDeadZone", &Dtool_DriveInterface_get_vertical_dead_zone_75, METH_NOARGS, (const char *)Dtool_DriveInterface_get_vertical_dead_zone_75_comment},
  {"set_horizontal_dead_zone", &Dtool_DriveInterface_set_horizontal_dead_zone_76, METH_O, (const char *)Dtool_DriveInterface_set_horizontal_dead_zone_76_comment},
  {"setHorizontalDeadZone", &Dtool_DriveInterface_set_horizontal_dead_zone_76, METH_O, (const char *)Dtool_DriveInterface_set_horizontal_dead_zone_76_comment},
  {"get_horizontal_dead_zone", &Dtool_DriveInterface_get_horizontal_dead_zone_77, METH_NOARGS, (const char *)Dtool_DriveInterface_get_horizontal_dead_zone_77_comment},
  {"getHorizontalDeadZone", &Dtool_DriveInterface_get_horizontal_dead_zone_77, METH_NOARGS, (const char *)Dtool_DriveInterface_get_horizontal_dead_zone_77_comment},
  {"set_vertical_ramp_up_time", &Dtool_DriveInterface_set_vertical_ramp_up_time_78, METH_O, (const char *)Dtool_DriveInterface_set_vertical_ramp_up_time_78_comment},
  {"setVerticalRampUpTime", &Dtool_DriveInterface_set_vertical_ramp_up_time_78, METH_O, (const char *)Dtool_DriveInterface_set_vertical_ramp_up_time_78_comment},
  {"get_vertical_ramp_up_time", &Dtool_DriveInterface_get_vertical_ramp_up_time_79, METH_NOARGS, (const char *)Dtool_DriveInterface_get_vertical_ramp_up_time_79_comment},
  {"getVerticalRampUpTime", &Dtool_DriveInterface_get_vertical_ramp_up_time_79, METH_NOARGS, (const char *)Dtool_DriveInterface_get_vertical_ramp_up_time_79_comment},
  {"set_vertical_ramp_down_time", &Dtool_DriveInterface_set_vertical_ramp_down_time_80, METH_O, (const char *)Dtool_DriveInterface_set_vertical_ramp_down_time_80_comment},
  {"setVerticalRampDownTime", &Dtool_DriveInterface_set_vertical_ramp_down_time_80, METH_O, (const char *)Dtool_DriveInterface_set_vertical_ramp_down_time_80_comment},
  {"get_vertical_ramp_down_time", &Dtool_DriveInterface_get_vertical_ramp_down_time_81, METH_NOARGS, (const char *)Dtool_DriveInterface_get_vertical_ramp_down_time_81_comment},
  {"getVerticalRampDownTime", &Dtool_DriveInterface_get_vertical_ramp_down_time_81, METH_NOARGS, (const char *)Dtool_DriveInterface_get_vertical_ramp_down_time_81_comment},
  {"set_horizontal_ramp_up_time", &Dtool_DriveInterface_set_horizontal_ramp_up_time_82, METH_O, (const char *)Dtool_DriveInterface_set_horizontal_ramp_up_time_82_comment},
  {"setHorizontalRampUpTime", &Dtool_DriveInterface_set_horizontal_ramp_up_time_82, METH_O, (const char *)Dtool_DriveInterface_set_horizontal_ramp_up_time_82_comment},
  {"get_horizontal_ramp_up_time", &Dtool_DriveInterface_get_horizontal_ramp_up_time_83, METH_NOARGS, (const char *)Dtool_DriveInterface_get_horizontal_ramp_up_time_83_comment},
  {"getHorizontalRampUpTime", &Dtool_DriveInterface_get_horizontal_ramp_up_time_83, METH_NOARGS, (const char *)Dtool_DriveInterface_get_horizontal_ramp_up_time_83_comment},
  {"set_horizontal_ramp_down_time", &Dtool_DriveInterface_set_horizontal_ramp_down_time_84, METH_O, (const char *)Dtool_DriveInterface_set_horizontal_ramp_down_time_84_comment},
  {"setHorizontalRampDownTime", &Dtool_DriveInterface_set_horizontal_ramp_down_time_84, METH_O, (const char *)Dtool_DriveInterface_set_horizontal_ramp_down_time_84_comment},
  {"get_horizontal_ramp_down_time", &Dtool_DriveInterface_get_horizontal_ramp_down_time_85, METH_NOARGS, (const char *)Dtool_DriveInterface_get_horizontal_ramp_down_time_85_comment},
  {"getHorizontalRampDownTime", &Dtool_DriveInterface_get_horizontal_ramp_down_time_85, METH_NOARGS, (const char *)Dtool_DriveInterface_get_horizontal_ramp_down_time_85_comment},
  {"get_speed", &Dtool_DriveInterface_get_speed_86, METH_NOARGS, (const char *)Dtool_DriveInterface_get_speed_86_comment},
  {"getSpeed", &Dtool_DriveInterface_get_speed_86, METH_NOARGS, (const char *)Dtool_DriveInterface_get_speed_86_comment},
  {"get_rot_speed", &Dtool_DriveInterface_get_rot_speed_87, METH_NOARGS, (const char *)Dtool_DriveInterface_get_rot_speed_87_comment},
  {"getRotSpeed", &Dtool_DriveInterface_get_rot_speed_87, METH_NOARGS, (const char *)Dtool_DriveInterface_get_rot_speed_87_comment},
  {"reset", &Dtool_DriveInterface_reset_88, METH_NOARGS, (const char *)Dtool_DriveInterface_reset_88_comment},
  {"get_pos", &Dtool_DriveInterface_get_pos_89, METH_NOARGS, (const char *)Dtool_DriveInterface_get_pos_89_comment},
  {"getPos", &Dtool_DriveInterface_get_pos_89, METH_NOARGS, (const char *)Dtool_DriveInterface_get_pos_89_comment},
  {"get_x", &Dtool_DriveInterface_get_x_90, METH_NOARGS, (const char *)Dtool_DriveInterface_get_x_90_comment},
  {"getX", &Dtool_DriveInterface_get_x_90, METH_NOARGS, (const char *)Dtool_DriveInterface_get_x_90_comment},
  {"get_y", &Dtool_DriveInterface_get_y_91, METH_NOARGS, (const char *)Dtool_DriveInterface_get_y_91_comment},
  {"getY", &Dtool_DriveInterface_get_y_91, METH_NOARGS, (const char *)Dtool_DriveInterface_get_y_91_comment},
  {"get_z", &Dtool_DriveInterface_get_z_92, METH_NOARGS, (const char *)Dtool_DriveInterface_get_z_92_comment},
  {"getZ", &Dtool_DriveInterface_get_z_92, METH_NOARGS, (const char *)Dtool_DriveInterface_get_z_92_comment},
  {"set_pos", (PyCFunction) &Dtool_DriveInterface_set_pos_93, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DriveInterface_set_pos_93_comment},
  {"setPos", (PyCFunction) &Dtool_DriveInterface_set_pos_93, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DriveInterface_set_pos_93_comment},
  {"set_x", &Dtool_DriveInterface_set_x_94, METH_O, (const char *)Dtool_DriveInterface_set_x_94_comment},
  {"setX", &Dtool_DriveInterface_set_x_94, METH_O, (const char *)Dtool_DriveInterface_set_x_94_comment},
  {"set_y", &Dtool_DriveInterface_set_y_95, METH_O, (const char *)Dtool_DriveInterface_set_y_95_comment},
  {"setY", &Dtool_DriveInterface_set_y_95, METH_O, (const char *)Dtool_DriveInterface_set_y_95_comment},
  {"set_z", &Dtool_DriveInterface_set_z_96, METH_O, (const char *)Dtool_DriveInterface_set_z_96_comment},
  {"setZ", &Dtool_DriveInterface_set_z_96, METH_O, (const char *)Dtool_DriveInterface_set_z_96_comment},
  {"get_hpr", &Dtool_DriveInterface_get_hpr_97, METH_NOARGS, (const char *)Dtool_DriveInterface_get_hpr_97_comment},
  {"getHpr", &Dtool_DriveInterface_get_hpr_97, METH_NOARGS, (const char *)Dtool_DriveInterface_get_hpr_97_comment},
  {"get_h", &Dtool_DriveInterface_get_h_98, METH_NOARGS, (const char *)Dtool_DriveInterface_get_h_98_comment},
  {"getH", &Dtool_DriveInterface_get_h_98, METH_NOARGS, (const char *)Dtool_DriveInterface_get_h_98_comment},
  {"get_p", &Dtool_DriveInterface_get_p_99, METH_NOARGS, (const char *)Dtool_DriveInterface_get_p_99_comment},
  {"getP", &Dtool_DriveInterface_get_p_99, METH_NOARGS, (const char *)Dtool_DriveInterface_get_p_99_comment},
  {"get_r", &Dtool_DriveInterface_get_r_100, METH_NOARGS, (const char *)Dtool_DriveInterface_get_r_100_comment},
  {"getR", &Dtool_DriveInterface_get_r_100, METH_NOARGS, (const char *)Dtool_DriveInterface_get_r_100_comment},
  {"set_hpr", (PyCFunction) &Dtool_DriveInterface_set_hpr_101, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DriveInterface_set_hpr_101_comment},
  {"setHpr", (PyCFunction) &Dtool_DriveInterface_set_hpr_101, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DriveInterface_set_hpr_101_comment},
  {"set_h", &Dtool_DriveInterface_set_h_102, METH_O, (const char *)Dtool_DriveInterface_set_h_102_comment},
  {"setH", &Dtool_DriveInterface_set_h_102, METH_O, (const char *)Dtool_DriveInterface_set_h_102_comment},
  {"set_p", &Dtool_DriveInterface_set_p_103, METH_O, (const char *)Dtool_DriveInterface_set_p_103_comment},
  {"setP", &Dtool_DriveInterface_set_p_103, METH_O, (const char *)Dtool_DriveInterface_set_p_103_comment},
  {"set_r", &Dtool_DriveInterface_set_r_104, METH_O, (const char *)Dtool_DriveInterface_set_r_104_comment},
  {"setR", &Dtool_DriveInterface_set_r_104, METH_O, (const char *)Dtool_DriveInterface_set_r_104_comment},
  {"set_force_roll", &Dtool_DriveInterface_set_force_roll_105, METH_O, (const char *)Dtool_DriveInterface_set_force_roll_105_comment},
  {"setForceRoll", &Dtool_DriveInterface_set_force_roll_105, METH_O, (const char *)Dtool_DriveInterface_set_force_roll_105_comment},
  {"set_ignore_mouse", &Dtool_DriveInterface_set_ignore_mouse_106, METH_O, (const char *)Dtool_DriveInterface_set_ignore_mouse_106_comment},
  {"setIgnoreMouse", &Dtool_DriveInterface_set_ignore_mouse_106, METH_O, (const char *)Dtool_DriveInterface_set_ignore_mouse_106_comment},
  {"get_ignore_mouse", &Dtool_DriveInterface_get_ignore_mouse_107, METH_NOARGS, (const char *)Dtool_DriveInterface_get_ignore_mouse_107_comment},
  {"getIgnoreMouse", &Dtool_DriveInterface_get_ignore_mouse_107, METH_NOARGS, (const char *)Dtool_DriveInterface_get_ignore_mouse_107_comment},
  {"set_force_mouse", &Dtool_DriveInterface_set_force_mouse_108, METH_O, (const char *)Dtool_DriveInterface_set_force_mouse_108_comment},
  {"setForceMouse", &Dtool_DriveInterface_set_force_mouse_108, METH_O, (const char *)Dtool_DriveInterface_set_force_mouse_108_comment},
  {"get_force_mouse", &Dtool_DriveInterface_get_force_mouse_109, METH_NOARGS, (const char *)Dtool_DriveInterface_get_force_mouse_109_comment},
  {"getForceMouse", &Dtool_DriveInterface_get_force_mouse_109, METH_NOARGS, (const char *)Dtool_DriveInterface_get_force_mouse_109_comment},
  {"set_stop_this_frame", &Dtool_DriveInterface_set_stop_this_frame_110, METH_O, (const char *)Dtool_DriveInterface_set_stop_this_frame_110_comment},
  {"setStopThisFrame", &Dtool_DriveInterface_set_stop_this_frame_110, METH_O, (const char *)Dtool_DriveInterface_set_stop_this_frame_110_comment},
  {"get_stop_this_frame", &Dtool_DriveInterface_get_stop_this_frame_111, METH_NOARGS, (const char *)Dtool_DriveInterface_get_stop_this_frame_111_comment},
  {"getStopThisFrame", &Dtool_DriveInterface_get_stop_this_frame_111, METH_NOARGS, (const char *)Dtool_DriveInterface_get_stop_this_frame_111_comment},
  {"set_mat", &Dtool_DriveInterface_set_mat_112, METH_O, (const char *)Dtool_DriveInterface_set_mat_112_comment},
  {"setMat", &Dtool_DriveInterface_set_mat_112, METH_O, (const char *)Dtool_DriveInterface_set_mat_112_comment},
  {"get_mat", &Dtool_DriveInterface_get_mat_113, METH_NOARGS, (const char *)Dtool_DriveInterface_get_mat_113_comment},
  {"getMat", &Dtool_DriveInterface_get_mat_113, METH_NOARGS, (const char *)Dtool_DriveInterface_get_mat_113_comment},
  {"force_dgraph", &Dtool_DriveInterface_force_dgraph_114, METH_NOARGS, (const char *)Dtool_DriveInterface_force_dgraph_114_comment},
  {"forceDgraph", &Dtool_DriveInterface_force_dgraph_114, METH_NOARGS, (const char *)Dtool_DriveInterface_force_dgraph_114_comment},
  {"get_class_type", &Dtool_DriveInterface_get_class_type_115, METH_NOARGS | METH_STATIC, (const char *)Dtool_DriveInterface_get_class_type_115_comment},
  {"getClassType", &Dtool_DriveInterface_get_class_type_115, METH_NOARGS | METH_STATIC, (const char *)Dtool_DriveInterface_get_class_type_115_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DriveInterface = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DriveInterface = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DriveInterface = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DriveInterface = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DriveInterface = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.DriveInterface",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DriveInterface,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DriveInterface,
    &Dtool_SequenceMethods_DriveInterface,
    &Dtool_MappingMethods_DriveInterface,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DriveInterface,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a TFormer, similar to Trackball, that moves around a transform\n"
    " * matrix in response to mouse input.  The basic motion is on a horizontal\n"
    " * plane, as if driving a vehicle.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DriveInterface,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DriveInterface,
    PyType_GenericAlloc,
    Dtool_new_DriveInterface,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DriveInterface,
  Dtool_UpcastInterface_DriveInterface,
  Dtool_DowncastInterface_DriveInterface,
  (CoerceFunction)Dtool_ConstCoerce_DriveInterface,
  (CoerceFunction)Dtool_Coerce_DriveInterface,
};

static void Dtool_PyModuleClassInit_DriveInterface(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MouseInterfaceNode(NULL);
    Dtool_DriveInterface._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MouseInterfaceNode);
    PyObject *dict = PyDict_New();
    Dtool_DriveInterface._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DriveInterface) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DriveInterface)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DriveInterface);
  }
}

/**
 * Python method tables for MouseSubregion (MouseSubregion)
 */
static PyMethodDef Dtool_Methods_MouseSubregion[] = {
  {"get_left", &Dtool_MouseSubregion_get_left_118, METH_NOARGS, (const char *)Dtool_MouseSubregion_get_left_118_comment},
  {"getLeft", &Dtool_MouseSubregion_get_left_118, METH_NOARGS, (const char *)Dtool_MouseSubregion_get_left_118_comment},
  {"get_right", &Dtool_MouseSubregion_get_right_119, METH_NOARGS, (const char *)Dtool_MouseSubregion_get_right_119_comment},
  {"getRight", &Dtool_MouseSubregion_get_right_119, METH_NOARGS, (const char *)Dtool_MouseSubregion_get_right_119_comment},
  {"get_bottom", &Dtool_MouseSubregion_get_bottom_120, METH_NOARGS, (const char *)Dtool_MouseSubregion_get_bottom_120_comment},
  {"getBottom", &Dtool_MouseSubregion_get_bottom_120, METH_NOARGS, (const char *)Dtool_MouseSubregion_get_bottom_120_comment},
  {"get_top", &Dtool_MouseSubregion_get_top_121, METH_NOARGS, (const char *)Dtool_MouseSubregion_get_top_121_comment},
  {"getTop", &Dtool_MouseSubregion_get_top_121, METH_NOARGS, (const char *)Dtool_MouseSubregion_get_top_121_comment},
  {"set_dimensions", (PyCFunction) &Dtool_MouseSubregion_set_dimensions_122, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseSubregion_set_dimensions_122_comment},
  {"setDimensions", (PyCFunction) &Dtool_MouseSubregion_set_dimensions_122, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseSubregion_set_dimensions_122_comment},
  {"get_class_type", &Dtool_MouseSubregion_get_class_type_123, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseSubregion_get_class_type_123_comment},
  {"getClassType", &Dtool_MouseSubregion_get_class_type_123, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseSubregion_get_class_type_123_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MouseSubregion = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MouseSubregion = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_MouseSubregion = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_MouseSubregion = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_MouseSubregion = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MouseSubregion",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MouseSubregion,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MouseSubregion,
    &Dtool_SequenceMethods_MouseSubregion,
    &Dtool_MappingMethods_MouseSubregion,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_MouseSubregion,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The MouseSubregion object scales the mouse inputs from within a rectangular\n"
    " * region of the screen, as if they were the full-screen inputs.\n"
    " *\n"
    " * If you choose your MouseSubregion coordinates to exactly match a\n"
    " * DisplayRegion within your window, you end up with a virtual mouse within\n"
    " * your DisplayRegion.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MouseSubregion,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MouseSubregion,
    PyType_GenericAlloc,
    Dtool_new_MouseSubregion,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MouseSubregion,
  Dtool_UpcastInterface_MouseSubregion,
  Dtool_DowncastInterface_MouseSubregion,
  (CoerceFunction)Dtool_ConstCoerce_MouseSubregion,
  (CoerceFunction)Dtool_Coerce_MouseSubregion,
};

static void Dtool_PyModuleClassInit_MouseSubregion(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MouseInterfaceNode(NULL);
    Dtool_MouseSubregion._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MouseInterfaceNode);
    PyObject *dict = PyDict_New();
    Dtool_MouseSubregion._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MouseSubregion) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MouseSubregion)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MouseSubregion);
  }
}

/**
 * Python method tables for MouseWatcherRegion (MouseWatcherRegion)
 */
static PyMethodDef Dtool_Methods_MouseWatcherRegion[] = {
  {"set_frame", (PyCFunction) &Dtool_MouseWatcherRegion_set_frame_132, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseWatcherRegion_set_frame_132_comment},
  {"setFrame", (PyCFunction) &Dtool_MouseWatcherRegion_set_frame_132, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseWatcherRegion_set_frame_132_comment},
  {"get_frame", &Dtool_MouseWatcherRegion_get_frame_133, METH_NOARGS, (const char *)Dtool_MouseWatcherRegion_get_frame_133_comment},
  {"getFrame", &Dtool_MouseWatcherRegion_get_frame_133, METH_NOARGS, (const char *)Dtool_MouseWatcherRegion_get_frame_133_comment},
  {"get_area", &Dtool_MouseWatcherRegion_get_area_134, METH_NOARGS, (const char *)Dtool_MouseWatcherRegion_get_area_134_comment},
  {"getArea", &Dtool_MouseWatcherRegion_get_area_134, METH_NOARGS, (const char *)Dtool_MouseWatcherRegion_get_area_134_comment},
  {"set_sort", &Dtool_MouseWatcherRegion_set_sort_135, METH_O, (const char *)Dtool_MouseWatcherRegion_set_sort_135_comment},
  {"setSort", &Dtool_MouseWatcherRegion_set_sort_135, METH_O, (const char *)Dtool_MouseWatcherRegion_set_sort_135_comment},
  {"get_sort", &Dtool_MouseWatcherRegion_get_sort_136, METH_NOARGS, (const char *)Dtool_MouseWatcherRegion_get_sort_136_comment},
  {"getSort", &Dtool_MouseWatcherRegion_get_sort_136, METH_NOARGS, (const char *)Dtool_MouseWatcherRegion_get_sort_136_comment},
  {"set_active", &Dtool_MouseWatcherRegion_set_active_137, METH_O, (const char *)Dtool_MouseWatcherRegion_set_active_137_comment},
  {"setActive", &Dtool_MouseWatcherRegion_set_active_137, METH_O, (const char *)Dtool_MouseWatcherRegion_set_active_137_comment},
  {"get_active", &Dtool_MouseWatcherRegion_get_active_138, METH_NOARGS, (const char *)Dtool_MouseWatcherRegion_get_active_138_comment},
  {"getActive", &Dtool_MouseWatcherRegion_get_active_138, METH_NOARGS, (const char *)Dtool_MouseWatcherRegion_get_active_138_comment},
  {"set_keyboard", &Dtool_MouseWatcherRegion_set_keyboard_139, METH_O, (const char *)Dtool_MouseWatcherRegion_set_keyboard_139_comment},
  {"setKeyboard", &Dtool_MouseWatcherRegion_set_keyboard_139, METH_O, (const char *)Dtool_MouseWatcherRegion_set_keyboard_139_comment},
  {"get_keyboard", &Dtool_MouseWatcherRegion_get_keyboard_140, METH_NOARGS, (const char *)Dtool_MouseWatcherRegion_get_keyboard_140_comment},
  {"getKeyboard", &Dtool_MouseWatcherRegion_get_keyboard_140, METH_NOARGS, (const char *)Dtool_MouseWatcherRegion_get_keyboard_140_comment},
  {"set_suppress_flags", &Dtool_MouseWatcherRegion_set_suppress_flags_142, METH_O, (const char *)Dtool_MouseWatcherRegion_set_suppress_flags_142_comment},
  {"setSuppressFlags", &Dtool_MouseWatcherRegion_set_suppress_flags_142, METH_O, (const char *)Dtool_MouseWatcherRegion_set_suppress_flags_142_comment},
  {"get_suppress_flags", &Dtool_MouseWatcherRegion_get_suppress_flags_143, METH_NOARGS, (const char *)Dtool_MouseWatcherRegion_get_suppress_flags_143_comment},
  {"getSuppressFlags", &Dtool_MouseWatcherRegion_get_suppress_flags_143, METH_NOARGS, (const char *)Dtool_MouseWatcherRegion_get_suppress_flags_143_comment},
  {"output", &Dtool_MouseWatcherRegion_output_144, METH_O, (const char *)Dtool_MouseWatcherRegion_output_144_comment},
  {"write", (PyCFunction) &Dtool_MouseWatcherRegion_write_145, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseWatcherRegion_write_145_comment},
  {"get_class_type", &Dtool_MouseWatcherRegion_get_class_type_146, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseWatcherRegion_get_class_type_146_comment},
  {"getClassType", &Dtool_MouseWatcherRegion_get_class_type_146, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseWatcherRegion_get_class_type_146_comment},
  {"upcast_to_TypedWritableReferenceCount", &Dtool_MouseWatcherRegion_upcast_to_TypedWritableReferenceCount_126, METH_NOARGS, (const char *)Dtool_MouseWatcherRegion_upcast_to_TypedWritableReferenceCount_126_comment},
  {"upcastToTypedWritableReferenceCount", &Dtool_MouseWatcherRegion_upcast_to_TypedWritableReferenceCount_126, METH_NOARGS, (const char *)Dtool_MouseWatcherRegion_upcast_to_TypedWritableReferenceCount_126_comment},
  {"upcast_to_Namable", &Dtool_MouseWatcherRegion_upcast_to_Namable_129, METH_NOARGS, (const char *)Dtool_MouseWatcherRegion_upcast_to_Namable_129_comment},
  {"upcastToNamable", &Dtool_MouseWatcherRegion_upcast_to_Namable_129, METH_NOARGS, (const char *)Dtool_MouseWatcherRegion_upcast_to_Namable_129_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     MouseWatcherRegion
//////////////////
static PyObject *Dtool_Repr_MouseWatcherRegion(PyObject *self) {
  MouseWatcherRegion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherRegion, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     MouseWatcherRegion
//////////////////
static PyObject *Dtool_Str_MouseWatcherRegion(PyObject *self) {
  MouseWatcherRegion *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherRegion, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_MouseWatcherRegion = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MouseWatcherRegion = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_MouseWatcherRegion = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_MouseWatcherRegion = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_MouseWatcherRegion = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MouseWatcherRegion",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MouseWatcherRegion,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_MouseWatcherRegion,
    &Dtool_NumberMethods_MouseWatcherRegion,
    &Dtool_SequenceMethods_MouseWatcherRegion,
    &Dtool_MappingMethods_MouseWatcherRegion,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_MouseWatcherRegion,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_MouseWatcherRegion,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the class that defines a rectangular region on the screen for the\n"
    " * MouseWatcher.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MouseWatcherRegion,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MouseWatcherRegion,
    PyType_GenericAlloc,
    Dtool_new_MouseWatcherRegion,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MouseWatcherRegion,
  Dtool_UpcastInterface_MouseWatcherRegion,
  Dtool_DowncastInterface_MouseWatcherRegion,
  (CoerceFunction)Dtool_ConstCoerce_MouseWatcherRegion,
  (CoerceFunction)Dtool_Coerce_MouseWatcherRegion,
};

static void Dtool_PyModuleClassInit_MouseWatcherRegion(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != NULL);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(NULL);
    assert(Dtool_Ptr_Namable != NULL);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(NULL);
    Dtool_MouseWatcherRegion._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_MouseWatcherRegion._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum MouseWatcherRegion::SuppressFlags;
    PyDict_SetItemString(dict, "SF_mouse_button", Dtool_WrapValue(MouseWatcherRegion::SF_mouse_button));
    PyDict_SetItemString(dict, "SFMouseButton", Dtool_WrapValue(MouseWatcherRegion::SF_mouse_button));
    PyDict_SetItemString(dict, "SF_other_button", Dtool_WrapValue(MouseWatcherRegion::SF_other_button));
    PyDict_SetItemString(dict, "SFOtherButton", Dtool_WrapValue(MouseWatcherRegion::SF_other_button));
    PyDict_SetItemString(dict, "SF_any_button", Dtool_WrapValue(MouseWatcherRegion::SF_any_button));
    PyDict_SetItemString(dict, "SFAnyButton", Dtool_WrapValue(MouseWatcherRegion::SF_any_button));
    PyDict_SetItemString(dict, "SF_mouse_position", Dtool_WrapValue(MouseWatcherRegion::SF_mouse_position));
    PyDict_SetItemString(dict, "SFMousePosition", Dtool_WrapValue(MouseWatcherRegion::SF_mouse_position));
    if (PyType_Ready((PyTypeObject *)&Dtool_MouseWatcherRegion) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MouseWatcherRegion)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MouseWatcherRegion);
  }
}

/**
 * Python method tables for MouseWatcherBase (MouseWatcherBase)
 */
static PyMethodDef Dtool_Methods_MouseWatcherBase[] = {
  {"add_region", &Dtool_MouseWatcherBase_add_region_150, METH_O, (const char *)Dtool_MouseWatcherBase_add_region_150_comment},
  {"addRegion", &Dtool_MouseWatcherBase_add_region_150, METH_O, (const char *)Dtool_MouseWatcherBase_add_region_150_comment},
  {"has_region", &Dtool_MouseWatcherBase_has_region_151, METH_O, (const char *)Dtool_MouseWatcherBase_has_region_151_comment},
  {"hasRegion", &Dtool_MouseWatcherBase_has_region_151, METH_O, (const char *)Dtool_MouseWatcherBase_has_region_151_comment},
  {"remove_region", &Dtool_MouseWatcherBase_remove_region_152, METH_O, (const char *)Dtool_MouseWatcherBase_remove_region_152_comment},
  {"removeRegion", &Dtool_MouseWatcherBase_remove_region_152, METH_O, (const char *)Dtool_MouseWatcherBase_remove_region_152_comment},
  {"find_region", &Dtool_MouseWatcherBase_find_region_153, METH_O, (const char *)Dtool_MouseWatcherBase_find_region_153_comment},
  {"findRegion", &Dtool_MouseWatcherBase_find_region_153, METH_O, (const char *)Dtool_MouseWatcherBase_find_region_153_comment},
  {"clear_regions", &Dtool_MouseWatcherBase_clear_regions_154, METH_NOARGS, (const char *)Dtool_MouseWatcherBase_clear_regions_154_comment},
  {"clearRegions", &Dtool_MouseWatcherBase_clear_regions_154, METH_NOARGS, (const char *)Dtool_MouseWatcherBase_clear_regions_154_comment},
  {"sort_regions", &Dtool_MouseWatcherBase_sort_regions_155, METH_NOARGS, (const char *)Dtool_MouseWatcherBase_sort_regions_155_comment},
  {"sortRegions", &Dtool_MouseWatcherBase_sort_regions_155, METH_NOARGS, (const char *)Dtool_MouseWatcherBase_sort_regions_155_comment},
  {"is_sorted", &Dtool_MouseWatcherBase_is_sorted_156, METH_NOARGS, (const char *)Dtool_MouseWatcherBase_is_sorted_156_comment},
  {"isSorted", &Dtool_MouseWatcherBase_is_sorted_156, METH_NOARGS, (const char *)Dtool_MouseWatcherBase_is_sorted_156_comment},
  {"get_num_regions", &Dtool_MouseWatcherBase_get_num_regions_158, METH_NOARGS, (const char *)Dtool_MouseWatcherBase_get_num_regions_158_comment},
  {"getNumRegions", &Dtool_MouseWatcherBase_get_num_regions_158, METH_NOARGS, (const char *)Dtool_MouseWatcherBase_get_num_regions_158_comment},
  {"get_region", &Dtool_MouseWatcherBase_get_region_159, METH_O, (const char *)Dtool_MouseWatcherBase_get_region_159_comment},
  {"getRegion", &Dtool_MouseWatcherBase_get_region_159, METH_O, (const char *)Dtool_MouseWatcherBase_get_region_159_comment},
  {"output", &Dtool_MouseWatcherBase_output_163, METH_O, (const char *)Dtool_MouseWatcherBase_output_163_comment},
  {"write", (PyCFunction) &Dtool_MouseWatcherBase_write_164, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseWatcherBase_write_164_comment},
  {"show_regions", (PyCFunction) &Dtool_MouseWatcherBase_show_regions_165, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseWatcherBase_show_regions_165_comment},
  {"showRegions", (PyCFunction) &Dtool_MouseWatcherBase_show_regions_165, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseWatcherBase_show_regions_165_comment},
  {"set_color", &Dtool_MouseWatcherBase_set_color_166, METH_O, (const char *)Dtool_MouseWatcherBase_set_color_166_comment},
  {"setColor", &Dtool_MouseWatcherBase_set_color_166, METH_O, (const char *)Dtool_MouseWatcherBase_set_color_166_comment},
  {"hide_regions", &Dtool_MouseWatcherBase_hide_regions_167, METH_NOARGS, (const char *)Dtool_MouseWatcherBase_hide_regions_167_comment},
  {"hideRegions", &Dtool_MouseWatcherBase_hide_regions_167, METH_NOARGS, (const char *)Dtool_MouseWatcherBase_hide_regions_167_comment},
  {"update_regions", &Dtool_MouseWatcherBase_update_regions_168, METH_NOARGS, (const char *)Dtool_MouseWatcherBase_update_regions_168_comment},
  {"updateRegions", &Dtool_MouseWatcherBase_update_regions_168, METH_NOARGS, (const char *)Dtool_MouseWatcherBase_update_regions_168_comment},
  {"get_class_type", &Dtool_MouseWatcherBase_get_class_type_169, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseWatcherBase_get_class_type_169_comment},
  {"getClassType", &Dtool_MouseWatcherBase_get_class_type_169, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseWatcherBase_get_class_type_169_comment},
  {"downcast_to_MouseWatcherGroup", &Dtool_MouseWatcherBase_downcast_to_MouseWatcherGroup_172, METH_NOARGS, (const char *)Dtool_MouseWatcherBase_downcast_to_MouseWatcherGroup_172_comment},
  {"downcastToMouseWatcherGroup", &Dtool_MouseWatcherBase_downcast_to_MouseWatcherGroup_172, METH_NOARGS, (const char *)Dtool_MouseWatcherBase_downcast_to_MouseWatcherGroup_172_comment},
  {"downcast_to_MouseWatcher", &Dtool_MouseWatcherBase_downcast_to_MouseWatcher_182, METH_NOARGS, (const char *)Dtool_MouseWatcherBase_downcast_to_MouseWatcher_182_comment},
  {"downcastToMouseWatcher", &Dtool_MouseWatcherBase_downcast_to_MouseWatcher_182, METH_NOARGS, (const char *)Dtool_MouseWatcherBase_downcast_to_MouseWatcher_182_comment},
  {"get_regions", (PyCFunction) &MakeSeq_MouseWatcherBase_get_regions, METH_NOARGS, NULL},
  { "getRegions", (PyCFunction) &MakeSeq_MouseWatcherBase_get_regions, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     MouseWatcherBase
//////////////////
static PyObject *Dtool_Repr_MouseWatcherBase(PyObject *self) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherBase, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     MouseWatcherBase
//////////////////
static PyObject *Dtool_Str_MouseWatcherBase(PyObject *self) {
  MouseWatcherBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherBase, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_MouseWatcherBase[] = {
  {(char *)"sorted", &Dtool_MouseWatcherBase_sorted_Getter, NULL, NULL, NULL},
  {(char *)"regions", &Dtool_MouseWatcherBase_regions_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_MouseWatcherBase = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_MouseWatcherBase = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MouseWatcherBase",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MouseWatcherBase,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_MouseWatcherBase,
    &Dtool_NumberMethods_MouseWatcherBase,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_MouseWatcherBase,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents a collection of MouseWatcherRegions that may be managed as\n"
    " * a group.  This is the base class for both MouseWatcherGroup and\n"
    " * MouseWatcher, and exists so that we don't have to make MouseWatcher inherit\n"
    " * from ReferenceCount more than once.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MouseWatcherBase,
    0, // tp_members
    Dtool_Properties_MouseWatcherBase,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MouseWatcherBase,
    PyType_GenericAlloc,
    Dtool_new_MouseWatcherBase,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MouseWatcherBase,
  Dtool_UpcastInterface_MouseWatcherBase,
  Dtool_DowncastInterface_MouseWatcherBase,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MouseWatcherBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_MouseWatcherBase._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_MouseWatcherBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MouseWatcherBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MouseWatcherBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MouseWatcherBase);
  }
}

/**
 * Python method tables for MouseWatcherGroup (MouseWatcherGroup)
 */
static PyMethodDef Dtool_Methods_MouseWatcherGroup[] = {
  {"get_class_type", &Dtool_MouseWatcherGroup_get_class_type_176, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseWatcherGroup_get_class_type_176_comment},
  {"getClassType", &Dtool_MouseWatcherGroup_get_class_type_176, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseWatcherGroup_get_class_type_176_comment},
  {"upcast_to_MouseWatcherBase", &Dtool_MouseWatcherGroup_upcast_to_MouseWatcherBase_171, METH_NOARGS, (const char *)Dtool_MouseWatcherGroup_upcast_to_MouseWatcherBase_171_comment},
  {"upcastToMouseWatcherBase", &Dtool_MouseWatcherGroup_upcast_to_MouseWatcherBase_171, METH_NOARGS, (const char *)Dtool_MouseWatcherGroup_upcast_to_MouseWatcherBase_171_comment},
  {"upcast_to_ReferenceCount", &Dtool_MouseWatcherGroup_upcast_to_ReferenceCount_174, METH_NOARGS, (const char *)Dtool_MouseWatcherGroup_upcast_to_ReferenceCount_174_comment},
  {"upcastToReferenceCount", &Dtool_MouseWatcherGroup_upcast_to_ReferenceCount_174, METH_NOARGS, (const char *)Dtool_MouseWatcherGroup_upcast_to_ReferenceCount_174_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MouseWatcherGroup = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MouseWatcherGroup = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_MouseWatcherGroup = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_MouseWatcherGroup = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_MouseWatcherGroup = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MouseWatcherGroup",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MouseWatcherGroup,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MouseWatcherGroup,
    &Dtool_SequenceMethods_MouseWatcherGroup,
    &Dtool_MappingMethods_MouseWatcherGroup,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_MouseWatcherGroup,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents a collection of MouseWatcherRegions that may be managed as\n"
    " * a group.  The implementation for this is in MouseWatcherBase; this class\n"
    " * exists so that we can inherit from ReferenceCount.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MouseWatcherGroup,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MouseWatcherGroup,
    PyType_GenericAlloc,
    Dtool_new_MouseWatcherGroup,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MouseWatcherGroup,
  Dtool_UpcastInterface_MouseWatcherGroup,
  Dtool_DowncastInterface_MouseWatcherGroup,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MouseWatcherGroup(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MouseWatcherBase(NULL);
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_MouseWatcherGroup._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_MouseWatcherBase, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_MouseWatcherGroup._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MouseWatcherGroup) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MouseWatcherGroup)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MouseWatcherGroup);
  }
}

/**
 * Python method tables for MouseWatcher (MouseWatcher)
 */
static PyMethodDef Dtool_Methods_MouseWatcher[] = {
  {"remove_region", &Dtool_MouseWatcher_remove_region_185, METH_O, (const char *)Dtool_MouseWatcher_remove_region_185_comment},
  {"removeRegion", &Dtool_MouseWatcher_remove_region_185, METH_O, (const char *)Dtool_MouseWatcher_remove_region_185_comment},
  {"has_mouse", &Dtool_MouseWatcher_has_mouse_186, METH_NOARGS, (const char *)Dtool_MouseWatcher_has_mouse_186_comment},
  {"hasMouse", &Dtool_MouseWatcher_has_mouse_186, METH_NOARGS, (const char *)Dtool_MouseWatcher_has_mouse_186_comment},
  {"is_mouse_open", &Dtool_MouseWatcher_is_mouse_open_187, METH_NOARGS, (const char *)Dtool_MouseWatcher_is_mouse_open_187_comment},
  {"isMouseOpen", &Dtool_MouseWatcher_is_mouse_open_187, METH_NOARGS, (const char *)Dtool_MouseWatcher_is_mouse_open_187_comment},
  {"get_mouse", &Dtool_MouseWatcher_get_mouse_188, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_mouse_188_comment},
  {"getMouse", &Dtool_MouseWatcher_get_mouse_188, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_mouse_188_comment},
  {"get_mouse_x", &Dtool_MouseWatcher_get_mouse_x_189, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_mouse_x_189_comment},
  {"getMouseX", &Dtool_MouseWatcher_get_mouse_x_189, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_mouse_x_189_comment},
  {"get_mouse_y", &Dtool_MouseWatcher_get_mouse_y_190, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_mouse_y_190_comment},
  {"getMouseY", &Dtool_MouseWatcher_get_mouse_y_190, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_mouse_y_190_comment},
  {"set_frame", (PyCFunction) &Dtool_MouseWatcher_set_frame_191, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseWatcher_set_frame_191_comment},
  {"setFrame", (PyCFunction) &Dtool_MouseWatcher_set_frame_191, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseWatcher_set_frame_191_comment},
  {"get_frame", &Dtool_MouseWatcher_get_frame_192, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_frame_192_comment},
  {"getFrame", &Dtool_MouseWatcher_get_frame_192, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_frame_192_comment},
  {"is_over_region", (PyCFunction) &Dtool_MouseWatcher_is_over_region_193, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseWatcher_is_over_region_193_comment},
  {"isOverRegion", (PyCFunction) &Dtool_MouseWatcher_is_over_region_193, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseWatcher_is_over_region_193_comment},
  {"get_over_region", (PyCFunction) &Dtool_MouseWatcher_get_over_region_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseWatcher_get_over_region_194_comment},
  {"getOverRegion", (PyCFunction) &Dtool_MouseWatcher_get_over_region_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseWatcher_get_over_region_194_comment},
  {"is_button_down", &Dtool_MouseWatcher_is_button_down_195, METH_O, (const char *)Dtool_MouseWatcher_is_button_down_195_comment},
  {"isButtonDown", &Dtool_MouseWatcher_is_button_down_195, METH_O, (const char *)Dtool_MouseWatcher_is_button_down_195_comment},
  {"set_button_down_pattern", &Dtool_MouseWatcher_set_button_down_pattern_196, METH_O, (const char *)Dtool_MouseWatcher_set_button_down_pattern_196_comment},
  {"setButtonDownPattern", &Dtool_MouseWatcher_set_button_down_pattern_196, METH_O, (const char *)Dtool_MouseWatcher_set_button_down_pattern_196_comment},
  {"get_button_down_pattern", &Dtool_MouseWatcher_get_button_down_pattern_197, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_button_down_pattern_197_comment},
  {"getButtonDownPattern", &Dtool_MouseWatcher_get_button_down_pattern_197, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_button_down_pattern_197_comment},
  {"set_button_up_pattern", &Dtool_MouseWatcher_set_button_up_pattern_198, METH_O, (const char *)Dtool_MouseWatcher_set_button_up_pattern_198_comment},
  {"setButtonUpPattern", &Dtool_MouseWatcher_set_button_up_pattern_198, METH_O, (const char *)Dtool_MouseWatcher_set_button_up_pattern_198_comment},
  {"get_button_up_pattern", &Dtool_MouseWatcher_get_button_up_pattern_199, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_button_up_pattern_199_comment},
  {"getButtonUpPattern", &Dtool_MouseWatcher_get_button_up_pattern_199, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_button_up_pattern_199_comment},
  {"set_button_repeat_pattern", &Dtool_MouseWatcher_set_button_repeat_pattern_200, METH_O, (const char *)Dtool_MouseWatcher_set_button_repeat_pattern_200_comment},
  {"setButtonRepeatPattern", &Dtool_MouseWatcher_set_button_repeat_pattern_200, METH_O, (const char *)Dtool_MouseWatcher_set_button_repeat_pattern_200_comment},
  {"get_button_repeat_pattern", &Dtool_MouseWatcher_get_button_repeat_pattern_201, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_button_repeat_pattern_201_comment},
  {"getButtonRepeatPattern", &Dtool_MouseWatcher_get_button_repeat_pattern_201, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_button_repeat_pattern_201_comment},
  {"set_enter_pattern", &Dtool_MouseWatcher_set_enter_pattern_202, METH_O, (const char *)Dtool_MouseWatcher_set_enter_pattern_202_comment},
  {"setEnterPattern", &Dtool_MouseWatcher_set_enter_pattern_202, METH_O, (const char *)Dtool_MouseWatcher_set_enter_pattern_202_comment},
  {"get_enter_pattern", &Dtool_MouseWatcher_get_enter_pattern_203, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_enter_pattern_203_comment},
  {"getEnterPattern", &Dtool_MouseWatcher_get_enter_pattern_203, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_enter_pattern_203_comment},
  {"set_leave_pattern", &Dtool_MouseWatcher_set_leave_pattern_204, METH_O, (const char *)Dtool_MouseWatcher_set_leave_pattern_204_comment},
  {"setLeavePattern", &Dtool_MouseWatcher_set_leave_pattern_204, METH_O, (const char *)Dtool_MouseWatcher_set_leave_pattern_204_comment},
  {"get_leave_pattern", &Dtool_MouseWatcher_get_leave_pattern_205, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_leave_pattern_205_comment},
  {"getLeavePattern", &Dtool_MouseWatcher_get_leave_pattern_205, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_leave_pattern_205_comment},
  {"set_within_pattern", &Dtool_MouseWatcher_set_within_pattern_206, METH_O, (const char *)Dtool_MouseWatcher_set_within_pattern_206_comment},
  {"setWithinPattern", &Dtool_MouseWatcher_set_within_pattern_206, METH_O, (const char *)Dtool_MouseWatcher_set_within_pattern_206_comment},
  {"get_within_pattern", &Dtool_MouseWatcher_get_within_pattern_207, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_within_pattern_207_comment},
  {"getWithinPattern", &Dtool_MouseWatcher_get_within_pattern_207, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_within_pattern_207_comment},
  {"set_without_pattern", &Dtool_MouseWatcher_set_without_pattern_208, METH_O, (const char *)Dtool_MouseWatcher_set_without_pattern_208_comment},
  {"setWithoutPattern", &Dtool_MouseWatcher_set_without_pattern_208, METH_O, (const char *)Dtool_MouseWatcher_set_without_pattern_208_comment},
  {"get_without_pattern", &Dtool_MouseWatcher_get_without_pattern_209, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_without_pattern_209_comment},
  {"getWithoutPattern", &Dtool_MouseWatcher_get_without_pattern_209, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_without_pattern_209_comment},
  {"set_geometry", &Dtool_MouseWatcher_set_geometry_210, METH_O, (const char *)Dtool_MouseWatcher_set_geometry_210_comment},
  {"setGeometry", &Dtool_MouseWatcher_set_geometry_210, METH_O, (const char *)Dtool_MouseWatcher_set_geometry_210_comment},
  {"has_geometry", &Dtool_MouseWatcher_has_geometry_211, METH_NOARGS, (const char *)Dtool_MouseWatcher_has_geometry_211_comment},
  {"hasGeometry", &Dtool_MouseWatcher_has_geometry_211, METH_NOARGS, (const char *)Dtool_MouseWatcher_has_geometry_211_comment},
  {"get_geometry", &Dtool_MouseWatcher_get_geometry_212, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_geometry_212_comment},
  {"getGeometry", &Dtool_MouseWatcher_get_geometry_212, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_geometry_212_comment},
  {"clear_geometry", &Dtool_MouseWatcher_clear_geometry_213, METH_NOARGS, (const char *)Dtool_MouseWatcher_clear_geometry_213_comment},
  {"clearGeometry", &Dtool_MouseWatcher_clear_geometry_213, METH_NOARGS, (const char *)Dtool_MouseWatcher_clear_geometry_213_comment},
  {"set_extra_handler", &Dtool_MouseWatcher_set_extra_handler_214, METH_O, (const char *)Dtool_MouseWatcher_set_extra_handler_214_comment},
  {"setExtraHandler", &Dtool_MouseWatcher_set_extra_handler_214, METH_O, (const char *)Dtool_MouseWatcher_set_extra_handler_214_comment},
  {"get_extra_handler", &Dtool_MouseWatcher_get_extra_handler_215, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_extra_handler_215_comment},
  {"getExtraHandler", &Dtool_MouseWatcher_get_extra_handler_215, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_extra_handler_215_comment},
  {"set_modifier_buttons", &Dtool_MouseWatcher_set_modifier_buttons_216, METH_O, (const char *)Dtool_MouseWatcher_set_modifier_buttons_216_comment},
  {"setModifierButtons", &Dtool_MouseWatcher_set_modifier_buttons_216, METH_O, (const char *)Dtool_MouseWatcher_set_modifier_buttons_216_comment},
  {"get_modifier_buttons", &Dtool_MouseWatcher_get_modifier_buttons_217, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_modifier_buttons_217_comment},
  {"getModifierButtons", &Dtool_MouseWatcher_get_modifier_buttons_217, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_modifier_buttons_217_comment},
  {"set_display_region", &Dtool_MouseWatcher_set_display_region_218, METH_O, (const char *)Dtool_MouseWatcher_set_display_region_218_comment},
  {"setDisplayRegion", &Dtool_MouseWatcher_set_display_region_218, METH_O, (const char *)Dtool_MouseWatcher_set_display_region_218_comment},
  {"clear_display_region", &Dtool_MouseWatcher_clear_display_region_219, METH_NOARGS, (const char *)Dtool_MouseWatcher_clear_display_region_219_comment},
  {"clearDisplayRegion", &Dtool_MouseWatcher_clear_display_region_219, METH_NOARGS, (const char *)Dtool_MouseWatcher_clear_display_region_219_comment},
  {"get_display_region", &Dtool_MouseWatcher_get_display_region_220, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_display_region_220_comment},
  {"getDisplayRegion", &Dtool_MouseWatcher_get_display_region_220, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_display_region_220_comment},
  {"has_display_region", &Dtool_MouseWatcher_has_display_region_221, METH_NOARGS, (const char *)Dtool_MouseWatcher_has_display_region_221_comment},
  {"hasDisplayRegion", &Dtool_MouseWatcher_has_display_region_221, METH_NOARGS, (const char *)Dtool_MouseWatcher_has_display_region_221_comment},
  {"add_group", &Dtool_MouseWatcher_add_group_222, METH_O, (const char *)Dtool_MouseWatcher_add_group_222_comment},
  {"addGroup", &Dtool_MouseWatcher_add_group_222, METH_O, (const char *)Dtool_MouseWatcher_add_group_222_comment},
  {"remove_group", &Dtool_MouseWatcher_remove_group_223, METH_O, (const char *)Dtool_MouseWatcher_remove_group_223_comment},
  {"removeGroup", &Dtool_MouseWatcher_remove_group_223, METH_O, (const char *)Dtool_MouseWatcher_remove_group_223_comment},
  {"replace_group", (PyCFunction) &Dtool_MouseWatcher_replace_group_224, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseWatcher_replace_group_224_comment},
  {"replaceGroup", (PyCFunction) &Dtool_MouseWatcher_replace_group_224, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseWatcher_replace_group_224_comment},
  {"get_num_groups", &Dtool_MouseWatcher_get_num_groups_225, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_num_groups_225_comment},
  {"getNumGroups", &Dtool_MouseWatcher_get_num_groups_225, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_num_groups_225_comment},
  {"get_group", &Dtool_MouseWatcher_get_group_226, METH_O, (const char *)Dtool_MouseWatcher_get_group_226_comment},
  {"getGroup", &Dtool_MouseWatcher_get_group_226, METH_O, (const char *)Dtool_MouseWatcher_get_group_226_comment},
  {"set_inactivity_timeout", &Dtool_MouseWatcher_set_inactivity_timeout_228, METH_O, (const char *)Dtool_MouseWatcher_set_inactivity_timeout_228_comment},
  {"setInactivityTimeout", &Dtool_MouseWatcher_set_inactivity_timeout_228, METH_O, (const char *)Dtool_MouseWatcher_set_inactivity_timeout_228_comment},
  {"has_inactivity_timeout", &Dtool_MouseWatcher_has_inactivity_timeout_229, METH_NOARGS, (const char *)Dtool_MouseWatcher_has_inactivity_timeout_229_comment},
  {"hasInactivityTimeout", &Dtool_MouseWatcher_has_inactivity_timeout_229, METH_NOARGS, (const char *)Dtool_MouseWatcher_has_inactivity_timeout_229_comment},
  {"get_inactivity_timeout", &Dtool_MouseWatcher_get_inactivity_timeout_230, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_inactivity_timeout_230_comment},
  {"getInactivityTimeout", &Dtool_MouseWatcher_get_inactivity_timeout_230, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_inactivity_timeout_230_comment},
  {"clear_inactivity_timeout", &Dtool_MouseWatcher_clear_inactivity_timeout_231, METH_NOARGS, (const char *)Dtool_MouseWatcher_clear_inactivity_timeout_231_comment},
  {"clearInactivityTimeout", &Dtool_MouseWatcher_clear_inactivity_timeout_231, METH_NOARGS, (const char *)Dtool_MouseWatcher_clear_inactivity_timeout_231_comment},
  {"set_inactivity_timeout_event", &Dtool_MouseWatcher_set_inactivity_timeout_event_232, METH_O, (const char *)Dtool_MouseWatcher_set_inactivity_timeout_event_232_comment},
  {"setInactivityTimeoutEvent", &Dtool_MouseWatcher_set_inactivity_timeout_event_232, METH_O, (const char *)Dtool_MouseWatcher_set_inactivity_timeout_event_232_comment},
  {"get_inactivity_timeout_event", &Dtool_MouseWatcher_get_inactivity_timeout_event_233, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_inactivity_timeout_event_233_comment},
  {"getInactivityTimeoutEvent", &Dtool_MouseWatcher_get_inactivity_timeout_event_233, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_inactivity_timeout_event_233_comment},
  {"get_trail_log", &Dtool_MouseWatcher_get_trail_log_234, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_trail_log_234_comment},
  {"getTrailLog", &Dtool_MouseWatcher_get_trail_log_234, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_trail_log_234_comment},
  {"num_trail_recent", &Dtool_MouseWatcher_num_trail_recent_235, METH_NOARGS, (const char *)Dtool_MouseWatcher_num_trail_recent_235_comment},
  {"numTrailRecent", &Dtool_MouseWatcher_num_trail_recent_235, METH_NOARGS, (const char *)Dtool_MouseWatcher_num_trail_recent_235_comment},
  {"set_trail_log_duration", &Dtool_MouseWatcher_set_trail_log_duration_236, METH_O, (const char *)Dtool_MouseWatcher_set_trail_log_duration_236_comment},
  {"setTrailLogDuration", &Dtool_MouseWatcher_set_trail_log_duration_236, METH_O, (const char *)Dtool_MouseWatcher_set_trail_log_duration_236_comment},
  {"get_trail_node", &Dtool_MouseWatcher_get_trail_node_237, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_trail_node_237_comment},
  {"getTrailNode", &Dtool_MouseWatcher_get_trail_node_237, METH_NOARGS, (const char *)Dtool_MouseWatcher_get_trail_node_237_comment},
  {"clear_trail_node", &Dtool_MouseWatcher_clear_trail_node_238, METH_NOARGS, (const char *)Dtool_MouseWatcher_clear_trail_node_238_comment},
  {"clearTrailNode", &Dtool_MouseWatcher_clear_trail_node_238, METH_NOARGS, (const char *)Dtool_MouseWatcher_clear_trail_node_238_comment},
  {"clear_trail_log", &Dtool_MouseWatcher_clear_trail_log_239, METH_NOARGS, (const char *)Dtool_MouseWatcher_clear_trail_log_239_comment},
  {"clearTrailLog", &Dtool_MouseWatcher_clear_trail_log_239, METH_NOARGS, (const char *)Dtool_MouseWatcher_clear_trail_log_239_comment},
  {"note_activity", &Dtool_MouseWatcher_note_activity_240, METH_NOARGS, (const char *)Dtool_MouseWatcher_note_activity_240_comment},
  {"noteActivity", &Dtool_MouseWatcher_note_activity_240, METH_NOARGS, (const char *)Dtool_MouseWatcher_note_activity_240_comment},
  {"get_class_type", &Dtool_MouseWatcher_get_class_type_241, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseWatcher_get_class_type_241_comment},
  {"getClassType", &Dtool_MouseWatcher_get_class_type_241, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseWatcher_get_class_type_241_comment},
  {"upcast_to_DataNode", &Dtool_MouseWatcher_upcast_to_DataNode_179, METH_NOARGS, (const char *)Dtool_MouseWatcher_upcast_to_DataNode_179_comment},
  {"upcastToDataNode", &Dtool_MouseWatcher_upcast_to_DataNode_179, METH_NOARGS, (const char *)Dtool_MouseWatcher_upcast_to_DataNode_179_comment},
  {"upcast_to_MouseWatcherBase", &Dtool_MouseWatcher_upcast_to_MouseWatcherBase_181, METH_NOARGS, (const char *)Dtool_MouseWatcher_upcast_to_MouseWatcherBase_181_comment},
  {"upcastToMouseWatcherBase", &Dtool_MouseWatcher_upcast_to_MouseWatcherBase_181, METH_NOARGS, (const char *)Dtool_MouseWatcher_upcast_to_MouseWatcherBase_181_comment},
  {"get_groups", (PyCFunction) &MakeSeq_MouseWatcher_get_groups, METH_NOARGS, NULL},
  { "getGroups", (PyCFunction) &MakeSeq_MouseWatcher_get_groups, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MouseWatcher = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MouseWatcher = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_MouseWatcher = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_MouseWatcher = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_MouseWatcher = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MouseWatcher",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MouseWatcher,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MouseWatcher,
    &Dtool_SequenceMethods_MouseWatcher,
    &Dtool_MappingMethods_MouseWatcher,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_MouseWatcher,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This TFormer maintains a list of rectangular regions on the screen that are\n"
    " * considered special mouse regions; typically these will be click buttons.\n"
    " * When the mouse passes in or out of one of these regions, or when a button\n"
    " * is clicked while the mouse is in one of these regions, an event is thrown.\n"
    " *\n"
    " * Mouse events may also be suppressed from the rest of the datagraph in these\n"
    " * special regions.\n"
    " *\n"
    " * This class can also implement a software mouse pointer by automatically\n"
    " * generating a transform to apply to a piece of geometry placed under the 2-d\n"
    " * scene graph.  It will move the geometry around according to the mouse's\n"
    " * known position.\n"
    " *\n"
    " * Finally, this class can keep a record of the mouse trail.  This is useful\n"
    " * if you want to know, not just where the mouse is, but the exact sequence of\n"
    " * movements it took to get there.  This information is mainly useful for\n"
    " * gesture-recognition code.  To use trail logging, you need to enable the\n"
    " * generation of pointer events in the GraphicsWindowInputDevice and set the\n"
    " * trail log duration in the MouseWatcher.  Otherwise, the trail log will be\n"
    " * empty.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MouseWatcher,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MouseWatcher,
    PyType_GenericAlloc,
    Dtool_new_MouseWatcher,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MouseWatcher,
  Dtool_UpcastInterface_MouseWatcher,
  Dtool_DowncastInterface_MouseWatcher,
  (CoerceFunction)Dtool_ConstCoerce_MouseWatcher,
  (CoerceFunction)Dtool_Coerce_MouseWatcher,
};

static void Dtool_PyModuleClassInit_MouseWatcher(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != NULL);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(NULL);
    Dtool_PyModuleClassInit_MouseWatcherBase(NULL);
    Dtool_MouseWatcher._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_DataNode, (PyTypeObject *)&Dtool_MouseWatcherBase);
    PyObject *dict = PyDict_New();
    Dtool_MouseWatcher._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MouseWatcher) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MouseWatcher)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MouseWatcher);
  }
}

/**
 * Python method tables for MouseWatcherParameter (MouseWatcherParameter)
 */
static PyMethodDef Dtool_Methods_MouseWatcherParameter[] = {
  {"has_button", &Dtool_MouseWatcherParameter_has_button_244, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_has_button_244_comment},
  {"hasButton", &Dtool_MouseWatcherParameter_has_button_244, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_has_button_244_comment},
  {"get_button", &Dtool_MouseWatcherParameter_get_button_245, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_get_button_245_comment},
  {"getButton", &Dtool_MouseWatcherParameter_get_button_245, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_get_button_245_comment},
  {"is_keyrepeat", &Dtool_MouseWatcherParameter_is_keyrepeat_246, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_is_keyrepeat_246_comment},
  {"isKeyrepeat", &Dtool_MouseWatcherParameter_is_keyrepeat_246, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_is_keyrepeat_246_comment},
  {"has_keycode", &Dtool_MouseWatcherParameter_has_keycode_247, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_has_keycode_247_comment},
  {"hasKeycode", &Dtool_MouseWatcherParameter_has_keycode_247, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_has_keycode_247_comment},
  {"get_keycode", &Dtool_MouseWatcherParameter_get_keycode_248, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_get_keycode_248_comment},
  {"getKeycode", &Dtool_MouseWatcherParameter_get_keycode_248, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_get_keycode_248_comment},
  {"has_candidate", &Dtool_MouseWatcherParameter_has_candidate_249, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_has_candidate_249_comment},
  {"hasCandidate", &Dtool_MouseWatcherParameter_has_candidate_249, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_has_candidate_249_comment},
  {"get_candidate_string_encoded", &Dtool_MouseWatcherParameter_get_candidate_string_encoded_250, METH_VARARGS, (const char *)Dtool_MouseWatcherParameter_get_candidate_string_encoded_250_comment},
  {"getCandidateStringEncoded", &Dtool_MouseWatcherParameter_get_candidate_string_encoded_250, METH_VARARGS, (const char *)Dtool_MouseWatcherParameter_get_candidate_string_encoded_250_comment},
  {"get_highlight_start", &Dtool_MouseWatcherParameter_get_highlight_start_251, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_get_highlight_start_251_comment},
  {"getHighlightStart", &Dtool_MouseWatcherParameter_get_highlight_start_251, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_get_highlight_start_251_comment},
  {"get_highlight_end", &Dtool_MouseWatcherParameter_get_highlight_end_252, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_get_highlight_end_252_comment},
  {"getHighlightEnd", &Dtool_MouseWatcherParameter_get_highlight_end_252, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_get_highlight_end_252_comment},
  {"get_cursor_pos", &Dtool_MouseWatcherParameter_get_cursor_pos_253, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_get_cursor_pos_253_comment},
  {"getCursorPos", &Dtool_MouseWatcherParameter_get_cursor_pos_253, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_get_cursor_pos_253_comment},
  {"get_modifier_buttons", &Dtool_MouseWatcherParameter_get_modifier_buttons_254, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_get_modifier_buttons_254_comment},
  {"getModifierButtons", &Dtool_MouseWatcherParameter_get_modifier_buttons_254, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_get_modifier_buttons_254_comment},
  {"has_mouse", &Dtool_MouseWatcherParameter_has_mouse_255, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_has_mouse_255_comment},
  {"hasMouse", &Dtool_MouseWatcherParameter_has_mouse_255, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_has_mouse_255_comment},
  {"get_mouse", &Dtool_MouseWatcherParameter_get_mouse_256, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_get_mouse_256_comment},
  {"getMouse", &Dtool_MouseWatcherParameter_get_mouse_256, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_get_mouse_256_comment},
  {"is_outside", &Dtool_MouseWatcherParameter_is_outside_257, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_is_outside_257_comment},
  {"isOutside", &Dtool_MouseWatcherParameter_is_outside_257, METH_NOARGS, (const char *)Dtool_MouseWatcherParameter_is_outside_257_comment},
  {"output", &Dtool_MouseWatcherParameter_output_258, METH_O, (const char *)Dtool_MouseWatcherParameter_output_258_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     MouseWatcherParameter
//////////////////
static PyObject *Dtool_Repr_MouseWatcherParameter(PyObject *self) {
  MouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MouseWatcherParameter, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_MouseWatcherParameter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_MouseWatcherParameter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MouseWatcherParameter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MouseWatcherParameter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_MouseWatcherParameter,
    &Dtool_NumberMethods_MouseWatcherParameter,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_MouseWatcherParameter,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is sent along as a parameter to most events generated for a region to\n"
    " * indicate the mouse and button state for the event.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MouseWatcherParameter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MouseWatcherParameter,
    PyType_GenericAlloc,
    Dtool_new_MouseWatcherParameter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MouseWatcherParameter,
  Dtool_UpcastInterface_MouseWatcherParameter,
  Dtool_DowncastInterface_MouseWatcherParameter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MouseWatcherParameter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_MouseWatcherParameter._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_MouseWatcherParameter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MouseWatcherParameter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MouseWatcherParameter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MouseWatcherParameter);
  }
}

/**
 * Python method tables for Trackball (Trackball)
 */
static PyMethodDef Dtool_Methods_Trackball[] = {
  {"reset", &Dtool_Trackball_reset_261, METH_NOARGS, (const char *)Dtool_Trackball_reset_261_comment},
  {"get_forward_scale", &Dtool_Trackball_get_forward_scale_262, METH_NOARGS, (const char *)Dtool_Trackball_get_forward_scale_262_comment},
  {"getForwardScale", &Dtool_Trackball_get_forward_scale_262, METH_NOARGS, (const char *)Dtool_Trackball_get_forward_scale_262_comment},
  {"set_forward_scale", &Dtool_Trackball_set_forward_scale_263, METH_O, (const char *)Dtool_Trackball_set_forward_scale_263_comment},
  {"setForwardScale", &Dtool_Trackball_set_forward_scale_263, METH_O, (const char *)Dtool_Trackball_set_forward_scale_263_comment},
  {"get_pos", &Dtool_Trackball_get_pos_264, METH_NOARGS, (const char *)Dtool_Trackball_get_pos_264_comment},
  {"getPos", &Dtool_Trackball_get_pos_264, METH_NOARGS, (const char *)Dtool_Trackball_get_pos_264_comment},
  {"get_x", &Dtool_Trackball_get_x_265, METH_NOARGS, (const char *)Dtool_Trackball_get_x_265_comment},
  {"getX", &Dtool_Trackball_get_x_265, METH_NOARGS, (const char *)Dtool_Trackball_get_x_265_comment},
  {"get_y", &Dtool_Trackball_get_y_266, METH_NOARGS, (const char *)Dtool_Trackball_get_y_266_comment},
  {"getY", &Dtool_Trackball_get_y_266, METH_NOARGS, (const char *)Dtool_Trackball_get_y_266_comment},
  {"get_z", &Dtool_Trackball_get_z_267, METH_NOARGS, (const char *)Dtool_Trackball_get_z_267_comment},
  {"getZ", &Dtool_Trackball_get_z_267, METH_NOARGS, (const char *)Dtool_Trackball_get_z_267_comment},
  {"set_pos", (PyCFunction) &Dtool_Trackball_set_pos_268, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Trackball_set_pos_268_comment},
  {"setPos", (PyCFunction) &Dtool_Trackball_set_pos_268, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Trackball_set_pos_268_comment},
  {"set_x", &Dtool_Trackball_set_x_269, METH_O, (const char *)Dtool_Trackball_set_x_269_comment},
  {"setX", &Dtool_Trackball_set_x_269, METH_O, (const char *)Dtool_Trackball_set_x_269_comment},
  {"set_y", &Dtool_Trackball_set_y_270, METH_O, (const char *)Dtool_Trackball_set_y_270_comment},
  {"setY", &Dtool_Trackball_set_y_270, METH_O, (const char *)Dtool_Trackball_set_y_270_comment},
  {"set_z", &Dtool_Trackball_set_z_271, METH_O, (const char *)Dtool_Trackball_set_z_271_comment},
  {"setZ", &Dtool_Trackball_set_z_271, METH_O, (const char *)Dtool_Trackball_set_z_271_comment},
  {"get_hpr", &Dtool_Trackball_get_hpr_272, METH_NOARGS, (const char *)Dtool_Trackball_get_hpr_272_comment},
  {"getHpr", &Dtool_Trackball_get_hpr_272, METH_NOARGS, (const char *)Dtool_Trackball_get_hpr_272_comment},
  {"get_h", &Dtool_Trackball_get_h_273, METH_NOARGS, (const char *)Dtool_Trackball_get_h_273_comment},
  {"getH", &Dtool_Trackball_get_h_273, METH_NOARGS, (const char *)Dtool_Trackball_get_h_273_comment},
  {"get_p", &Dtool_Trackball_get_p_274, METH_NOARGS, (const char *)Dtool_Trackball_get_p_274_comment},
  {"getP", &Dtool_Trackball_get_p_274, METH_NOARGS, (const char *)Dtool_Trackball_get_p_274_comment},
  {"get_r", &Dtool_Trackball_get_r_275, METH_NOARGS, (const char *)Dtool_Trackball_get_r_275_comment},
  {"getR", &Dtool_Trackball_get_r_275, METH_NOARGS, (const char *)Dtool_Trackball_get_r_275_comment},
  {"set_hpr", (PyCFunction) &Dtool_Trackball_set_hpr_276, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Trackball_set_hpr_276_comment},
  {"setHpr", (PyCFunction) &Dtool_Trackball_set_hpr_276, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Trackball_set_hpr_276_comment},
  {"set_h", &Dtool_Trackball_set_h_277, METH_O, (const char *)Dtool_Trackball_set_h_277_comment},
  {"setH", &Dtool_Trackball_set_h_277, METH_O, (const char *)Dtool_Trackball_set_h_277_comment},
  {"set_p", &Dtool_Trackball_set_p_278, METH_O, (const char *)Dtool_Trackball_set_p_278_comment},
  {"setP", &Dtool_Trackball_set_p_278, METH_O, (const char *)Dtool_Trackball_set_p_278_comment},
  {"set_r", &Dtool_Trackball_set_r_279, METH_O, (const char *)Dtool_Trackball_set_r_279_comment},
  {"setR", &Dtool_Trackball_set_r_279, METH_O, (const char *)Dtool_Trackball_set_r_279_comment},
  {"reset_origin_here", &Dtool_Trackball_reset_origin_here_280, METH_NOARGS, (const char *)Dtool_Trackball_reset_origin_here_280_comment},
  {"resetOriginHere", &Dtool_Trackball_reset_origin_here_280, METH_NOARGS, (const char *)Dtool_Trackball_reset_origin_here_280_comment},
  {"move_origin", (PyCFunction) &Dtool_Trackball_move_origin_281, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Trackball_move_origin_281_comment},
  {"moveOrigin", (PyCFunction) &Dtool_Trackball_move_origin_281, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Trackball_move_origin_281_comment},
  {"get_origin", &Dtool_Trackball_get_origin_282, METH_NOARGS, (const char *)Dtool_Trackball_get_origin_282_comment},
  {"getOrigin", &Dtool_Trackball_get_origin_282, METH_NOARGS, (const char *)Dtool_Trackball_get_origin_282_comment},
  {"set_origin", &Dtool_Trackball_set_origin_283, METH_O, (const char *)Dtool_Trackball_set_origin_283_comment},
  {"setOrigin", &Dtool_Trackball_set_origin_283, METH_O, (const char *)Dtool_Trackball_set_origin_283_comment},
  {"set_control_mode", &Dtool_Trackball_set_control_mode_285, METH_O, (const char *)Dtool_Trackball_set_control_mode_285_comment},
  {"setControlMode", &Dtool_Trackball_set_control_mode_285, METH_O, (const char *)Dtool_Trackball_set_control_mode_285_comment},
  {"get_control_mode", &Dtool_Trackball_get_control_mode_286, METH_NOARGS, (const char *)Dtool_Trackball_get_control_mode_286_comment},
  {"getControlMode", &Dtool_Trackball_get_control_mode_286, METH_NOARGS, (const char *)Dtool_Trackball_get_control_mode_286_comment},
  {"set_invert", &Dtool_Trackball_set_invert_287, METH_O, (const char *)Dtool_Trackball_set_invert_287_comment},
  {"setInvert", &Dtool_Trackball_set_invert_287, METH_O, (const char *)Dtool_Trackball_set_invert_287_comment},
  {"get_invert", &Dtool_Trackball_get_invert_288, METH_NOARGS, (const char *)Dtool_Trackball_get_invert_288_comment},
  {"getInvert", &Dtool_Trackball_get_invert_288, METH_NOARGS, (const char *)Dtool_Trackball_get_invert_288_comment},
  {"set_rel_to", &Dtool_Trackball_set_rel_to_289, METH_O, (const char *)Dtool_Trackball_set_rel_to_289_comment},
  {"setRelTo", &Dtool_Trackball_set_rel_to_289, METH_O, (const char *)Dtool_Trackball_set_rel_to_289_comment},
  {"get_rel_to", &Dtool_Trackball_get_rel_to_290, METH_NOARGS, (const char *)Dtool_Trackball_get_rel_to_290_comment},
  {"getRelTo", &Dtool_Trackball_get_rel_to_290, METH_NOARGS, (const char *)Dtool_Trackball_get_rel_to_290_comment},
  {"set_coordinate_system", &Dtool_Trackball_set_coordinate_system_291, METH_O, (const char *)Dtool_Trackball_set_coordinate_system_291_comment},
  {"setCoordinateSystem", &Dtool_Trackball_set_coordinate_system_291, METH_O, (const char *)Dtool_Trackball_set_coordinate_system_291_comment},
  {"get_coordinate_system", &Dtool_Trackball_get_coordinate_system_292, METH_NOARGS, (const char *)Dtool_Trackball_get_coordinate_system_292_comment},
  {"getCoordinateSystem", &Dtool_Trackball_get_coordinate_system_292, METH_NOARGS, (const char *)Dtool_Trackball_get_coordinate_system_292_comment},
  {"set_mat", &Dtool_Trackball_set_mat_293, METH_O, (const char *)Dtool_Trackball_set_mat_293_comment},
  {"setMat", &Dtool_Trackball_set_mat_293, METH_O, (const char *)Dtool_Trackball_set_mat_293_comment},
  {"get_mat", &Dtool_Trackball_get_mat_294, METH_NOARGS, (const char *)Dtool_Trackball_get_mat_294_comment},
  {"getMat", &Dtool_Trackball_get_mat_294, METH_NOARGS, (const char *)Dtool_Trackball_get_mat_294_comment},
  {"get_trans_mat", &Dtool_Trackball_get_trans_mat_295, METH_NOARGS, (const char *)Dtool_Trackball_get_trans_mat_295_comment},
  {"getTransMat", &Dtool_Trackball_get_trans_mat_295, METH_NOARGS, (const char *)Dtool_Trackball_get_trans_mat_295_comment},
  {"get_class_type", &Dtool_Trackball_get_class_type_296, METH_NOARGS | METH_STATIC, (const char *)Dtool_Trackball_get_class_type_296_comment},
  {"getClassType", &Dtool_Trackball_get_class_type_296, METH_NOARGS | METH_STATIC, (const char *)Dtool_Trackball_get_class_type_296_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Trackball = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Trackball = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Trackball = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Trackball = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Trackball = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Trackball",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Trackball,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Trackball,
    &Dtool_SequenceMethods_Trackball,
    &Dtool_MappingMethods_Trackball,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Trackball,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Trackball acts like Performer in trackball mode.  It can either spin around\n"
    " * a piece of geometry directly, or it can spin around a camera with the\n"
    " * inverse transform to make it appear that the whole world is spinning.\n"
    " *\n"
    " * The Trackball object actually just places a transform in the data graph;\n"
    " * parent a Transform2SG node under it to actually transform objects (or\n"
    " * cameras) in the world.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Trackball,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Trackball,
    PyType_GenericAlloc,
    Dtool_new_Trackball,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Trackball,
  Dtool_UpcastInterface_Trackball,
  Dtool_DowncastInterface_Trackball,
  (CoerceFunction)Dtool_ConstCoerce_Trackball,
  (CoerceFunction)Dtool_Coerce_Trackball,
};

static void Dtool_PyModuleClassInit_Trackball(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MouseInterfaceNode(NULL);
    Dtool_Trackball._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MouseInterfaceNode);
    PyObject *dict = _PyDict_NewPresized(11);
    Dtool_Trackball._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum Trackball::ControlMode;
    PyDict_SetItemString(dict, "CM_default", Dtool_WrapValue(Trackball::CM_default));
    PyDict_SetItemString(dict, "CMDefault", Dtool_WrapValue(Trackball::CM_default));
    PyDict_SetItemString(dict, "CM_truck", Dtool_WrapValue(Trackball::CM_truck));
    PyDict_SetItemString(dict, "CMTruck", Dtool_WrapValue(Trackball::CM_truck));
    PyDict_SetItemString(dict, "CM_pan", Dtool_WrapValue(Trackball::CM_pan));
    PyDict_SetItemString(dict, "CMPan", Dtool_WrapValue(Trackball::CM_pan));
    PyDict_SetItemString(dict, "CM_dolly", Dtool_WrapValue(Trackball::CM_dolly));
    PyDict_SetItemString(dict, "CMDolly", Dtool_WrapValue(Trackball::CM_dolly));
    PyDict_SetItemString(dict, "CM_roll", Dtool_WrapValue(Trackball::CM_roll));
    PyDict_SetItemString(dict, "CMRoll", Dtool_WrapValue(Trackball::CM_roll));
    if (PyType_Ready((PyTypeObject *)&Dtool_Trackball) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Trackball)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Trackball);
  }
}

/**
 * Python method tables for Transform2SG (Transform2SG)
 */
static PyMethodDef Dtool_Methods_Transform2SG[] = {
  {"set_node", &Dtool_Transform2SG_set_node_299, METH_O, (const char *)Dtool_Transform2SG_set_node_299_comment},
  {"setNode", &Dtool_Transform2SG_set_node_299, METH_O, (const char *)Dtool_Transform2SG_set_node_299_comment},
  {"get_node", &Dtool_Transform2SG_get_node_300, METH_NOARGS, (const char *)Dtool_Transform2SG_get_node_300_comment},
  {"getNode", &Dtool_Transform2SG_get_node_300, METH_NOARGS, (const char *)Dtool_Transform2SG_get_node_300_comment},
  {"get_class_type", &Dtool_Transform2SG_get_class_type_301, METH_NOARGS | METH_STATIC, (const char *)Dtool_Transform2SG_get_class_type_301_comment},
  {"getClassType", &Dtool_Transform2SG_get_class_type_301, METH_NOARGS | METH_STATIC, (const char *)Dtool_Transform2SG_get_class_type_301_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Transform2SG = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Transform2SG = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Transform2SG = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Transform2SG = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Transform2SG = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Transform2SG",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Transform2SG,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Transform2SG,
    &Dtool_SequenceMethods_Transform2SG,
    &Dtool_MappingMethods_Transform2SG,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Transform2SG,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * input: Transform (matrix)\n"
    " *\n"
    " * output: none, but applies the matrix as the transform transition for a\n"
    " * given arc of the scene graph.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Transform2SG,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Transform2SG,
    PyType_GenericAlloc,
    Dtool_new_Transform2SG,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Transform2SG,
  Dtool_UpcastInterface_Transform2SG,
  Dtool_DowncastInterface_Transform2SG,
  (CoerceFunction)Dtool_ConstCoerce_Transform2SG,
  (CoerceFunction)Dtool_Coerce_Transform2SG,
};

static void Dtool_PyModuleClassInit_Transform2SG(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != NULL);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(NULL);
    Dtool_Transform2SG._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DataNode);
    PyObject *dict = PyDict_New();
    Dtool_Transform2SG._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Transform2SG) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Transform2SG)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Transform2SG);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3tform_RegisterTypes() {
  Dtool_ButtonThrower._type = ButtonThrower::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ButtonThrower);
  Dtool_MouseInterfaceNode._type = MouseInterfaceNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_MouseInterfaceNode);
  Dtool_DriveInterface._type = DriveInterface::get_class_type();
  RegisterRuntimeTypedClass(Dtool_DriveInterface);
  Dtool_MouseSubregion._type = MouseSubregion::get_class_type();
  RegisterRuntimeTypedClass(Dtool_MouseSubregion);
  Dtool_MouseWatcherRegion._type = MouseWatcherRegion::get_class_type();
  RegisterRuntimeTypedClass(Dtool_MouseWatcherRegion);
  Dtool_MouseWatcherBase._type = MouseWatcherBase::get_class_type();
  RegisterRuntimeTypedClass(Dtool_MouseWatcherBase);
  Dtool_MouseWatcherGroup._type = MouseWatcherGroup::get_class_type();
  RegisterRuntimeTypedClass(Dtool_MouseWatcherGroup);
  Dtool_MouseWatcher._type = MouseWatcher::get_class_type();
  RegisterRuntimeTypedClass(Dtool_MouseWatcher);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("MouseWatcherParameter", Dtool_MouseWatcherParameter);
#endif
  Dtool_Trackball._type = Trackball::get_class_type();
  RegisterRuntimeTypedClass(Dtool_Trackball);
  Dtool_Transform2SG._type = Transform2SG::get_class_type();
  RegisterRuntimeTypedClass(Dtool_Transform2SG);
}

void Dtool_libp3tform_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_TypedWritableReferenceCount = LookupRuntimeTypedClass(TypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_TypedWritable = LookupRuntimeTypedClass(TypedWritable::get_class_type());
  Dtool_Ptr_LVecBase4f = LookupRuntimeTypedClass(LVecBase4f::get_class_type());
  Dtool_Ptr_LPoint2f = LookupRuntimeTypedClass(LPoint2f::get_class_type());
  Dtool_Ptr_LPoint3f = LookupRuntimeTypedClass(LPoint3f::get_class_type());
  Dtool_Ptr_LVecBase3f = LookupRuntimeTypedClass(LVecBase3f::get_class_type());
  Dtool_Ptr_LMatrix4f = LookupRuntimeTypedClass(LMatrix4f::get_class_type());
  Dtool_Ptr_EventParameter = LookupNamedClass("EventParameter");
  Dtool_Ptr_PandaNode = LookupRuntimeTypedClass(PandaNode::get_class_type());
  Dtool_Ptr_DataNode = LookupRuntimeTypedClass(DataNode::get_class_type());
  Dtool_Ptr_ModifierButtons = LookupNamedClass("ModifierButtons");
  Dtool_Ptr_ButtonHandle = LookupRuntimeTypedClass(ButtonHandle::get_class_type());
  Dtool_Ptr_NodePath = LookupRuntimeTypedClass(NodePath::get_class_type());
  Dtool_Ptr_EventHandler = LookupRuntimeTypedClass(EventHandler::get_class_type());
  Dtool_Ptr_PointerEventList = LookupRuntimeTypedClass(PointerEventList::get_class_type());
  Dtool_Ptr_GeomNode = LookupRuntimeTypedClass(GeomNode::get_class_type());
  Dtool_Ptr_DisplayRegion = LookupRuntimeTypedClass(DisplayRegion::get_class_type());
#endif
}

void Dtool_libp3tform_BuildInstants(PyObject *module) {
  (void) module;
  // ButtonThrower
  Dtool_PyModuleClassInit_ButtonThrower(module);
  PyModule_AddObject(module, "ButtonThrower", (PyObject *)&Dtool_ButtonThrower);
  // MouseInterfaceNode
  Dtool_PyModuleClassInit_MouseInterfaceNode(module);
  PyModule_AddObject(module, "MouseInterfaceNode", (PyObject *)&Dtool_MouseInterfaceNode);
  // DriveInterface
  Dtool_PyModuleClassInit_DriveInterface(module);
  PyModule_AddObject(module, "DriveInterface", (PyObject *)&Dtool_DriveInterface);
  // MouseSubregion
  Dtool_PyModuleClassInit_MouseSubregion(module);
  PyModule_AddObject(module, "MouseSubregion", (PyObject *)&Dtool_MouseSubregion);
  // MouseWatcherRegion
  Dtool_PyModuleClassInit_MouseWatcherRegion(module);
  PyModule_AddObject(module, "MouseWatcherRegion", (PyObject *)&Dtool_MouseWatcherRegion);
  // MouseWatcherBase
  Dtool_PyModuleClassInit_MouseWatcherBase(module);
  PyModule_AddObject(module, "MouseWatcherBase", (PyObject *)&Dtool_MouseWatcherBase);
  // MouseWatcherGroup
  Dtool_PyModuleClassInit_MouseWatcherGroup(module);
  PyModule_AddObject(module, "MouseWatcherGroup", (PyObject *)&Dtool_MouseWatcherGroup);
  // MouseWatcher
  Dtool_PyModuleClassInit_MouseWatcher(module);
  PyModule_AddObject(module, "MouseWatcher", (PyObject *)&Dtool_MouseWatcher);
  // MouseWatcherParameter
  Dtool_PyModuleClassInit_MouseWatcherParameter(module);
  PyModule_AddObject(module, "MouseWatcherParameter", (PyObject *)&Dtool_MouseWatcherParameter);
  // Trackball
  Dtool_PyModuleClassInit_Trackball(module);
  PyModule_AddObject(module, "Trackball", (PyObject *)&Dtool_Trackball);
  // Transform2SG
  Dtool_PyModuleClassInit_Transform2SG(module);
  PyModule_AddObject(module, "Transform2SG", (PyObject *)&Dtool_Transform2SG);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3tform_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478213322,  /* file_identifier */
  "libp3tform",  /* library_name */
  "v_mB",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3tform.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  671  /* next_index */
};

Configure(_in_configure_libp3tform);
ConfigureFn(_in_configure_libp3tform) {
  interrogate_request_module(&_in_module_def);
}

