/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/parametrics -Ipanda/src/parametrics -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3parametrics_igate.cxx -od built/pandac/input/libp3parametrics.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/parametrics -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3parametrics config_parametrics.h cubicCurveseg.h curveFitter.h hermiteCurve.h nurbsBasisVector.h nurbsCurve.h nurbsCurveEvaluator.h nurbsCurveInterface.h nurbsCurveResult.h nurbsSurfaceEvaluator.h nurbsSurfaceResult.h nurbsVertex.h p3parametrics_composite1.cxx p3parametrics_composite2.cxx parametricCurve.h parametricCurveCollection.h piecewiseCurve.h ropeNode.h sheetNode.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3parametrics
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "config_parametrics.h"
#include "cubicCurveseg.h"
#include "curveFitter.h"
#include "epvector.h"
#include "hermiteCurve.h"
#include "luse.h"
#include "nodePath.h"
#include "notifyCategoryProxy.h"
#include "nurbsBasisVector.h"
#include "nurbsCurve.h"
#include "nurbsCurveEvaluator.h"
#include "nurbsCurveInterface.h"
#include "nurbsCurveResult.h"
#include "nurbsSurfaceEvaluator.h"
#include "nurbsSurfaceResult.h"
#include "nurbsVertex.h"
#include "pandabase.h"
#include "parametricCurve.h"
#include "parametricCurveCollection.h"
#include "piecewiseCurve.h"
#include "pmap.h"
#include "pointerTo.h"
#include "pvector.h"
#include "referenceCount.h"
#include "ropeNode.h"
#include "sheetNode.h"
#include "typedef.h"
#include "vector_stdfloat.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class ParametricCurve
 */
typedef ParametricCurve ParametricCurve_localtype;
Define_Module_ClassRef(panda3d.core, ParametricCurve, ParametricCurve_localtype, ParametricCurve);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParametricCurve = &Dtool_ParametricCurve;
static void Dtool_PyModuleClassInit_ParametricCurve(PyObject *module);

/**
 * Forward declarations for top-level class CubicCurveseg
 */
typedef CubicCurveseg CubicCurveseg_localtype;
Define_Module_ClassRef(panda3d.core, CubicCurveseg, CubicCurveseg_localtype, CubicCurveseg);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CubicCurveseg = &Dtool_CubicCurveseg;
static void Dtool_PyModuleClassInit_CubicCurveseg(PyObject *module);

/**
 * Forward declarations for top-level class ParametricCurveCollection
 */
typedef ParametricCurveCollection ParametricCurveCollection_localtype;
Define_Module_ClassRef(panda3d.core, ParametricCurveCollection, ParametricCurveCollection_localtype, ParametricCurveCollection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParametricCurveCollection = &Dtool_ParametricCurveCollection;
static void Dtool_PyModuleClassInit_ParametricCurveCollection(PyObject *module);

/**
 * Forward declarations for top-level class CurveFitter
 */
typedef CurveFitter CurveFitter_localtype;
Define_Module_Class(panda3d.core, CurveFitter, CurveFitter_localtype, CurveFitter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CurveFitter = &Dtool_CurveFitter;
static void Dtool_PyModuleClassInit_CurveFitter(PyObject *module);

/**
 * Forward declarations for top-level class PiecewiseCurve
 */
typedef PiecewiseCurve PiecewiseCurve_localtype;
Define_Module_ClassRef(panda3d.core, PiecewiseCurve, PiecewiseCurve_localtype, PiecewiseCurve);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PiecewiseCurve = &Dtool_PiecewiseCurve;
static void Dtool_PyModuleClassInit_PiecewiseCurve(PyObject *module);

/**
 * Forward declarations for top-level class HermiteCurve
 */
typedef HermiteCurve HermiteCurve_localtype;
Define_Module_ClassRef(panda3d.core, HermiteCurve, HermiteCurve_localtype, HermiteCurve);
static struct Dtool_PyTypedObject *const Dtool_Ptr_HermiteCurve = &Dtool_HermiteCurve;
static void Dtool_PyModuleClassInit_HermiteCurve(PyObject *module);
bool Dtool_ConstCoerce_HermiteCurve(PyObject *args, CPT(HermiteCurve) &coerced);
bool Dtool_Coerce_HermiteCurve(PyObject *args, PT(HermiteCurve) &coerced);

/**
 * Forward declarations for top-level class NurbsCurveInterface
 */
typedef NurbsCurveInterface NurbsCurveInterface_localtype;
Define_Module_Class(panda3d.core, NurbsCurveInterface, NurbsCurveInterface_localtype, NurbsCurveInterface);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NurbsCurveInterface = &Dtool_NurbsCurveInterface;
static void Dtool_PyModuleClassInit_NurbsCurveInterface(PyObject *module);

/**
 * Forward declarations for top-level class NurbsCurve
 */
typedef NurbsCurve NurbsCurve_localtype;
Define_Module_ClassRef(panda3d.core, NurbsCurve, NurbsCurve_localtype, NurbsCurve);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NurbsCurve = &Dtool_NurbsCurve;
static void Dtool_PyModuleClassInit_NurbsCurve(PyObject *module);
bool Dtool_ConstCoerce_NurbsCurve(PyObject *args, CPT(NurbsCurve) &coerced);
bool Dtool_Coerce_NurbsCurve(PyObject *args, PT(NurbsCurve) &coerced);

/**
 * Forward declarations for top-level class NurbsCurveResult
 */
typedef NurbsCurveResult NurbsCurveResult_localtype;
Define_Module_ClassRef(panda3d.core, NurbsCurveResult, NurbsCurveResult_localtype, NurbsCurveResult);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NurbsCurveResult = &Dtool_NurbsCurveResult;
static void Dtool_PyModuleClassInit_NurbsCurveResult(PyObject *module);

/**
 * Forward declarations for top-level class NurbsCurveEvaluator
 */
typedef NurbsCurveEvaluator NurbsCurveEvaluator_localtype;
Define_Module_ClassRef(panda3d.core, NurbsCurveEvaluator, NurbsCurveEvaluator_localtype, NurbsCurveEvaluator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NurbsCurveEvaluator = &Dtool_NurbsCurveEvaluator;
static void Dtool_PyModuleClassInit_NurbsCurveEvaluator(PyObject *module);

/**
 * Forward declarations for top-level class NurbsSurfaceResult
 */
typedef NurbsSurfaceResult NurbsSurfaceResult_localtype;
Define_Module_ClassRef(panda3d.core, NurbsSurfaceResult, NurbsSurfaceResult_localtype, NurbsSurfaceResult);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NurbsSurfaceResult = &Dtool_NurbsSurfaceResult;
static void Dtool_PyModuleClassInit_NurbsSurfaceResult(PyObject *module);

/**
 * Forward declarations for top-level class NurbsSurfaceEvaluator
 */
typedef NurbsSurfaceEvaluator NurbsSurfaceEvaluator_localtype;
Define_Module_ClassRef(panda3d.core, NurbsSurfaceEvaluator, NurbsSurfaceEvaluator_localtype, NurbsSurfaceEvaluator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NurbsSurfaceEvaluator = &Dtool_NurbsSurfaceEvaluator;
static void Dtool_PyModuleClassInit_NurbsSurfaceEvaluator(PyObject *module);

/**
 * Forward declarations for top-level class RopeNode
 */
typedef RopeNode RopeNode_localtype;
Define_Module_ClassRef(panda3d.core, RopeNode, RopeNode_localtype, RopeNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RopeNode = &Dtool_RopeNode;
static void Dtool_PyModuleClassInit_RopeNode(PyObject *module);
bool Dtool_ConstCoerce_RopeNode(PyObject *args, CPT(RopeNode) &coerced);
bool Dtool_Coerce_RopeNode(PyObject *args, PT(RopeNode) &coerced);

/**
 * Forward declarations for top-level class SheetNode
 */
typedef SheetNode SheetNode_localtype;
Define_Module_ClassRef(panda3d.core, SheetNode, SheetNode_localtype, SheetNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SheetNode = &Dtool_SheetNode;
static void Dtool_PyModuleClassInit_SheetNode(PyObject *module);
bool Dtool_ConstCoerce_SheetNode(PyObject *args, CPT(SheetNode) &coerced);
bool Dtool_Coerce_SheetNode(PyObject *args, PT(SheetNode) &coerced);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// Filename
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Filename;
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != NULL, NULL);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != NULL, NULL);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritable;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3f;
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVector3f;
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != NULL, NULL);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint3f;
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != NULL, NULL);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4f;
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix4f;
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PandaNode;
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// NodePath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePath;
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class ParametricCurve
 */
/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::is_valid(void) const
 */
static PyObject *Dtool_ParametricCurve_is_valid_3(PyObject *self, PyObject *) {
  ParametricCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool ParametricCurve::is_valid(void) const
  bool return_value = (*(const ParametricCurve*)local_this).is_valid();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_is_valid_3_comment =
  "C++ Interface:\n"
  "is_valid(ParametricCurve self)\n"
  "\n"
  "/**\n"
  " * Returns true if the curve is defined.  This base class function always\n"
  " * returns true; derived classes might override this to sometimes return\n"
  " * false.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_is_valid_3_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat ParametricCurve::get_max_t(void) const
 */
static PyObject *Dtool_ParametricCurve_get_max_t_4(PyObject *self, PyObject *) {
  ParametricCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual PN_stdfloat ParametricCurve::get_max_t(void) const
  PN_stdfloat return_value = (*(const ParametricCurve*)local_this).get_max_t();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_get_max_t_4_comment =
  "C++ Interface:\n"
  "get_max_t(ParametricCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the upper bound of t for the entire curve.  The curve is defined in\n"
  " * the range 0.0f <= t <= get_max_t().  This base class function always\n"
  " * returns 1.0f; derived classes might override this to return something else.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_get_max_t_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurve::set_curve_type(int type)
 */
static PyObject *Dtool_ParametricCurve_set_curve_type_5(PyObject *self, PyObject *arg) {
  ParametricCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurve, (void **)&local_this, "ParametricCurve.set_curve_type")) {
    return NULL;
  }
  // 1-void ParametricCurve::set_curve_type(int type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_curve_type((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_curve_type(const ParametricCurve self, int type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_set_curve_type_5_comment =
  "C++ Interface:\n"
  "set_curve_type(const ParametricCurve self, int type)\n"
  "\n"
  "/**\n"
  " * Sets the flag indicating the use to which the curve is intended to be put.\n"
  " * This flag is optional and only serves to provide a hint to the egg reader\n"
  " * and writer code; it has no effect on the curve's behavior.\n"
  " *\n"
  " * Setting the curve type also sets the num_dimensions to 3 or 1 according to\n"
  " * the type.\n"
  " *\n"
  " * THis flag may have one of the values PCT_XYZ, PCT_HPR, or PCT_T.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_set_curve_type_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int ParametricCurve::get_curve_type(void) const
 */
static PyObject *Dtool_ParametricCurve_get_curve_type_6(PyObject *self, PyObject *) {
  ParametricCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-int ParametricCurve::get_curve_type(void) const
  int return_value = (*(const ParametricCurve*)local_this).get_curve_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_get_curve_type_6_comment =
  "C++ Interface:\n"
  "get_curve_type(ParametricCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the flag indicating the use to which the curve is intended to be\n"
  " * put.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_get_curve_type_6_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurve::set_num_dimensions(int num)
 */
static PyObject *Dtool_ParametricCurve_set_num_dimensions_7(PyObject *self, PyObject *arg) {
  ParametricCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurve, (void **)&local_this, "ParametricCurve.set_num_dimensions")) {
    return NULL;
  }
  // 1-void ParametricCurve::set_num_dimensions(int num)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_num_dimensions((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_dimensions(const ParametricCurve self, int num)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_set_num_dimensions_7_comment =
  "C++ Interface:\n"
  "set_num_dimensions(const ParametricCurve self, int num)\n"
  "\n"
  "/**\n"
  " * Specifies the number of significant dimensions in the curve's vertices.\n"
  " * This should be one of 1, 2, or 3. Normally, XYZ and HPR curves have three\n"
  " * dimensions; time curves should always have one dimension.  This only serves\n"
  " * as a hint to the mopath editor, and also controls how the curve is written\n"
  " * out.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_set_num_dimensions_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int ParametricCurve::get_num_dimensions(void) const
 */
static PyObject *Dtool_ParametricCurve_get_num_dimensions_8(PyObject *self, PyObject *) {
  ParametricCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-int ParametricCurve::get_num_dimensions(void) const
  int return_value = (*(const ParametricCurve*)local_this).get_num_dimensions();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_get_num_dimensions_8_comment =
  "C++ Interface:\n"
  "get_num_dimensions(ParametricCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the number of significant dimensions in the curve's vertices, as\n"
  " * set by a previous call to set_num_dimensions().  This is only a hint as to\n"
  " * how the curve is intended to be used; the actual number of dimensions of\n"
  " * any curve is always three.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_get_num_dimensions_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat ParametricCurve::calc_length(void) const
 * PN_stdfloat ParametricCurve::calc_length(PN_stdfloat from, PN_stdfloat to) const
 */
static PyObject *Dtool_ParametricCurve_calc_length_9(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurve, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PN_stdfloat ParametricCurve::calc_length(void) const
      PN_stdfloat return_value = (*(const ParametricCurve*)local_this).calc_length();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 2:
    {
      // 1-PN_stdfloat ParametricCurve::calc_length(PN_stdfloat from, PN_stdfloat to) const
      float param1;
      float param2;
      static const char *keyword_list[] = {"from", "to", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:calc_length", (char **)keyword_list, &param1, &param2)) {
        PN_stdfloat return_value = (*(const ParametricCurve*)local_this).calc_length((PN_stdfloat)param1, (PN_stdfloat)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "calc_length() takes 1 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_length(ParametricCurve self)\n"
      "calc_length(ParametricCurve self, float from, float to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_calc_length_9_comment =
  "C++ Interface:\n"
  "calc_length(ParametricCurve self)\n"
  "calc_length(ParametricCurve self, float from, float to)\n"
  "\n"
  "/**\n"
  " * Approximates the length of the entire curve to within a few decimal places.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Approximates the length of the curve segment from parametric time 'from' to\n"
  " * time 'to'.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_calc_length_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat ParametricCurve::find_length(PN_stdfloat start_t, PN_stdfloat length_offset) const
 */
static PyObject *Dtool_ParametricCurve_find_length_10(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat ParametricCurve::find_length(PN_stdfloat start_t, PN_stdfloat length_offset) const
  float param1;
  float param2;
  static const char *keyword_list[] = {"start_t", "length_offset", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:find_length", (char **)keyword_list, &param1, &param2)) {
    PN_stdfloat return_value = (*(const ParametricCurve*)local_this).find_length((PN_stdfloat)param1, (PN_stdfloat)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_length(ParametricCurve self, float start_t, float length_offset)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_find_length_10_comment =
  "C++ Interface:\n"
  "find_length(ParametricCurve self, float start_t, float length_offset)\n"
  "\n"
  "/**\n"
  " * Returns the parametric value corresponding to the indicated distance along\n"
  " * the curve from the starting parametric value.\n"
  " *\n"
  " * This is the inverse of calc_length(): rather than determining the length\n"
  " * along the curve between two parametric points, it determines the position\n"
  " * in parametric time of a point n units along the curve.\n"
  " *\n"
  " * The search distance must not be negative.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_find_length_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::get_point(PN_stdfloat t, LVecBase3 &point) const = 0
 */
static PyObject *Dtool_ParametricCurve_get_point_11(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool ParametricCurve::get_point(PN_stdfloat t, LVecBase3 &point) const = 0
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"t", "point", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:get_point", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurve.get_point", "LVecBase3f");
    }
    bool return_value = (*(const ParametricCurve*)local_this).get_point((PN_stdfloat)param1, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(ParametricCurve self, float t, LVecBase3f point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_get_point_11_comment =
  "C++ Interface:\n"
  "get_point(ParametricCurve self, float t, LVecBase3f point)\n";
#else
static const char *Dtool_ParametricCurve_get_point_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::get_tangent(PN_stdfloat t, LVecBase3 &tangent) const = 0
 */
static PyObject *Dtool_ParametricCurve_get_tangent_12(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool ParametricCurve::get_tangent(PN_stdfloat t, LVecBase3 &tangent) const = 0
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"t", "tangent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:get_tangent", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurve.get_tangent", "LVecBase3f");
    }
    bool return_value = (*(const ParametricCurve*)local_this).get_tangent((PN_stdfloat)param1, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tangent(ParametricCurve self, float t, LVecBase3f tangent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_get_tangent_12_comment =
  "C++ Interface:\n"
  "get_tangent(ParametricCurve self, float t, LVecBase3f tangent)\n";
#else
static const char *Dtool_ParametricCurve_get_tangent_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::get_pt(PN_stdfloat t, LVecBase3 &point, LVecBase3 &tangent) const = 0
 */
static PyObject *Dtool_ParametricCurve_get_pt_13(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool ParametricCurve::get_pt(PN_stdfloat t, LVecBase3 &point, LVecBase3 &tangent) const = 0
  float param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"t", "point", "tangent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fOO:get_pt", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurve.get_pt", "LVecBase3f");
    }
    LVecBase3f param3_local;
    LVecBase3 *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "ParametricCurve.get_pt", "LVecBase3f");
    }
    bool return_value = (*(const ParametricCurve*)local_this).get_pt((PN_stdfloat)param1, *param2_this, *param3_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pt(ParametricCurve self, float t, LVecBase3f point, LVecBase3f tangent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_get_pt_13_comment =
  "C++ Interface:\n"
  "get_pt(ParametricCurve self, float t, LVecBase3f point, LVecBase3f tangent)\n";
#else
static const char *Dtool_ParametricCurve_get_pt_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::get_2ndtangent(PN_stdfloat t, LVecBase3 &tangent2) const = 0
 */
static PyObject *Dtool_ParametricCurve_get_2ndtangent_14(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool ParametricCurve::get_2ndtangent(PN_stdfloat t, LVecBase3 &tangent2) const = 0
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"t", "tangent2", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:get_2ndtangent", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurve.get_2ndtangent", "LVecBase3f");
    }
    bool return_value = (*(const ParametricCurve*)local_this).get_2ndtangent((PN_stdfloat)param1, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_2ndtangent(ParametricCurve self, float t, LVecBase3f tangent2)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_get_2ndtangent_14_comment =
  "C++ Interface:\n"
  "get_2ndtangent(ParametricCurve self, float t, LVecBase3f tangent2)\n";
#else
static const char *Dtool_ParametricCurve_get_2ndtangent_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::adjust_point(PN_stdfloat t, PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz)
 */
static PyObject *Dtool_ParametricCurve_adjust_point_15(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurve, (void **)&local_this, "ParametricCurve.adjust_point")) {
    return NULL;
  }
  // 1-virtual bool ParametricCurve::adjust_point(PN_stdfloat t, PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"t", "px", "py", "pz", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:adjust_point", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    bool return_value = (*local_this).adjust_point((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "adjust_point(const ParametricCurve self, float t, float px, float py, float pz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_adjust_point_15_comment =
  "C++ Interface:\n"
  "adjust_point(const ParametricCurve self, float t, float px, float py, float pz)\n"
  "\n"
  "/**\n"
  " * Recomputes the curve such that it passes through the point (px, py, pz) at\n"
  " * time t, but keeps the same tangent value at that point.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_adjust_point_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::adjust_tangent(PN_stdfloat t, PN_stdfloat tx, PN_stdfloat ty, PN_stdfloat tz)
 */
static PyObject *Dtool_ParametricCurve_adjust_tangent_16(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurve, (void **)&local_this, "ParametricCurve.adjust_tangent")) {
    return NULL;
  }
  // 1-virtual bool ParametricCurve::adjust_tangent(PN_stdfloat t, PN_stdfloat tx, PN_stdfloat ty, PN_stdfloat tz)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"t", "tx", "ty", "tz", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:adjust_tangent", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    bool return_value = (*local_this).adjust_tangent((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "adjust_tangent(const ParametricCurve self, float t, float tx, float ty, float tz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_adjust_tangent_16_comment =
  "C++ Interface:\n"
  "adjust_tangent(const ParametricCurve self, float t, float tx, float ty, float tz)\n"
  "\n"
  "/**\n"
  " * Recomputes the curve such that it has the tangent (tx, ty, tz) at time t,\n"
  " * but keeps the same position at the point.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_adjust_tangent_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::adjust_pt(PN_stdfloat t, PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz, PN_stdfloat tx, PN_stdfloat ty, PN_stdfloat tz)
 */
static PyObject *Dtool_ParametricCurve_adjust_pt_17(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurve, (void **)&local_this, "ParametricCurve.adjust_pt")) {
    return NULL;
  }
  // 1-virtual bool ParametricCurve::adjust_pt(PN_stdfloat t, PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz, PN_stdfloat tx, PN_stdfloat ty, PN_stdfloat tz)
  float param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  float param7;
  static const char *keyword_list[] = {"t", "px", "py", "pz", "tx", "ty", "tz", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fffffff:adjust_pt", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
    bool return_value = (*local_this).adjust_pt((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "adjust_pt(const ParametricCurve self, float t, float px, float py, float pz, float tx, float ty, float tz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_adjust_pt_17_comment =
  "C++ Interface:\n"
  "adjust_pt(const ParametricCurve self, float t, float px, float py, float pz, float tx, float ty, float tz)\n"
  "\n"
  "/**\n"
  " * Recomputes the curve such that it passes through the point (px, py, pz)\n"
  " * with the tangent (tx, ty, tz).\n"
  " */";
#else
static const char *Dtool_ParametricCurve_adjust_pt_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::recompute(void)
 */
static PyObject *Dtool_ParametricCurve_recompute_18(PyObject *self, PyObject *) {
  ParametricCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurve, (void **)&local_this, "ParametricCurve.recompute")) {
    return NULL;
  }
  // 1-virtual bool ParametricCurve::recompute(void)
  bool return_value = (*local_this).recompute();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_recompute_18_comment =
  "C++ Interface:\n"
  "recompute(const ParametricCurve self)\n"
  "\n"
  "/**\n"
  " * Recalculates the curve, if necessary.  Returns true if the resulting curve\n"
  " * is valid, false otherwise.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_recompute_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::stitch(ParametricCurve const *a, ParametricCurve const *b)
 */
static PyObject *Dtool_ParametricCurve_stitch_19(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurve, (void **)&local_this, "ParametricCurve.stitch")) {
    return NULL;
  }
  // 1-virtual bool ParametricCurve::stitch(ParametricCurve const *a, ParametricCurve const *b)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"a", "b", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:stitch", (char **)keyword_list, &param1, &param2)) {
    ParametricCurve const *param1_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ParametricCurve, 1, "ParametricCurve.stitch", true, true);
    ParametricCurve const *param2_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_ParametricCurve, 2, "ParametricCurve.stitch", true, true);
    if (param1_this != NULL && param2_this != NULL) {
      bool return_value = (*local_this).stitch(param1_this, param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "stitch(const ParametricCurve self, const ParametricCurve a, const ParametricCurve b)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_stitch_19_comment =
  "C++ Interface:\n"
  "stitch(const ParametricCurve self, const ParametricCurve a, const ParametricCurve b)\n"
  "\n"
  "/**\n"
  " * Regenerates this curve as one long curve: the first curve connected end-to-\n"
  " * end with the second one.  Either a or b may be the same as 'this'.\n"
  " *\n"
  " * Returns true if successful, false on failure or if the curve type does not\n"
  " * support stitching.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_stitch_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ParametricCurve::write_egg(Filename filename, CoordinateSystem cs = ::CS_default)
 * bool ParametricCurve::write_egg(ostream &out, Filename const &filename, CoordinateSystem cs)
 */
static PyObject *Dtool_ParametricCurve_write_egg_20(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurve, (void **)&local_this, "ParametricCurve.write_egg")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "filename");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'filename' (pos 1) not found");
      }
      // 1-bool ParametricCurve::write_egg(Filename filename, CoordinateSystem cs)
      Filename arg_local;
      Filename *arg_this = Dtool_Coerce_Filename(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "ParametricCurve.write_egg", "Filename");
      }
      bool return_value = (*local_this).write_egg(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-bool ParametricCurve::write_egg(Filename filename, CoordinateSystem cs)
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"filename", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_egg", (char **)keyword_list, &param1, &param2)) {
        Filename param1_local;
        Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "ParametricCurve.write_egg", "Filename");
        }
        bool return_value = (*local_this).write_egg(*param1_this, (CoordinateSystem)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-bool ParametricCurve::write_egg(ostream &out, Filename const &filename, CoordinateSystem cs)
      PyObject *param1;
      PyObject *param2;
      int param3;
      static const char *keyword_list[] = {"out", "filename", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:write_egg", (char **)keyword_list, &param1, &param2, &param3)) {
        ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "ParametricCurve.write_egg", false, true);
        Filename param2_local;
        Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurve.write_egg", "Filename");
        }
        if (param1_this != NULL) {
          bool return_value = (*local_this).write_egg(*param1_this, *param2_this, (CoordinateSystem)param3);
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "write_egg() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_egg(const ParametricCurve self, Filename filename)\n"
      "write_egg(const ParametricCurve self, Filename filename, int cs)\n"
      "write_egg(const ParametricCurve self, ostream out, const Filename filename, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_write_egg_20_comment =
  "C++ Interface:\n"
  "write_egg(const ParametricCurve self, Filename filename)\n"
  "write_egg(const ParametricCurve self, Filename filename, int cs)\n"
  "write_egg(const ParametricCurve self, ostream out, const Filename filename, int cs)\n"
  "\n"
  "/**\n"
  " * Writes an egg description of the nurbs curve to the specified output file.\n"
  " * Returns true if the file is successfully written.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Writes an egg description of the nurbs curve to the specified output\n"
  " * stream.  Returns true if the file is successfully written.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_write_egg_20_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParametricCurve::get_class_type(void)
 */
static PyObject *Dtool_ParametricCurve_get_class_type_21(PyObject *, PyObject *) {
  // 1-static TypeHandle ParametricCurve::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ParametricCurve::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_get_class_type_21_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParametricCurve_get_class_type_21_comment = NULL;
#endif

static int Dtool_Init_ParametricCurve(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ParametricCurve(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParametricCurve) {
    printf("ParametricCurve ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParametricCurve *local_this = (ParametricCurve *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParametricCurve) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParametricCurve(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParametricCurve) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ParametricCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (ParametricCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParametricCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParametricCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParametricCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParametricCurve*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CubicCurveseg
 */
/**
 * Python function wrapper for:
 * static TypeHandle CubicCurveseg::get_class_type(void)
 */
static PyObject *Dtool_CubicCurveseg_get_class_type_23(PyObject *, PyObject *) {
  // 1-static TypeHandle CubicCurveseg::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CubicCurveseg::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CubicCurveseg_get_class_type_23_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CubicCurveseg_get_class_type_23_comment = NULL;
#endif

static int Dtool_Init_CubicCurveseg(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_CubicCurveseg(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CubicCurveseg) {
    printf("CubicCurveseg ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CubicCurveseg *local_this = (CubicCurveseg *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CubicCurveseg) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_ParametricCurve) {
    return (ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CubicCurveseg(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CubicCurveseg) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (CubicCurveseg*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (CubicCurveseg*)other_this;
  }
  if (from_type == Dtool_Ptr_ParametricCurve) {
    ParametricCurve* other_this = (ParametricCurve*)from_this;
    return (CubicCurveseg*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CubicCurveseg*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CubicCurveseg*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CubicCurveseg*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CubicCurveseg*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParametricCurveCollection
 */
/**
 * Python function wrapper for:
 * void ParametricCurveCollection::add_curve(ParametricCurve *curve)
 * void ParametricCurveCollection::add_curve(ParametricCurve *curve, int index)
 */
static PyObject *Dtool_ParametricCurveCollection_add_curve_27(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.add_curve")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "curve");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'curve' (pos 1) not found");
      }
      // 1-void ParametricCurveCollection::add_curve(ParametricCurve *curve)
      ParametricCurve *arg_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ParametricCurve, 1, "ParametricCurveCollection.add_curve", false, true);
      if (arg_this != NULL) {
        (*local_this).add_curve(arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void ParametricCurveCollection::add_curve(ParametricCurve *curve, int index)
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"curve", "index", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:add_curve", (char **)keyword_list, &param1, &param2)) {
        ParametricCurve *param1_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ParametricCurve, 1, "ParametricCurveCollection.add_curve", false, true);
        if (param1_this != NULL) {
          (*local_this).add_curve(param1_this, (int)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_curve() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_curve(const ParametricCurveCollection self, ParametricCurve curve)\n"
      "add_curve(const ParametricCurveCollection self, ParametricCurve curve, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_add_curve_27_comment =
  "C++ Interface:\n"
  "add_curve(const ParametricCurveCollection self, ParametricCurve curve)\n"
  "add_curve(const ParametricCurveCollection self, ParametricCurve curve, int index)\n"
  "\n"
  "/**\n"
  " * Adds a new ParametricCurve to the collection.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a new ParametricCurve to the collection at the indicated index.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_add_curve_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int ParametricCurveCollection::add_curves(PandaNode *node)
 */
static PyObject *Dtool_ParametricCurveCollection_add_curves_28(PyObject *self, PyObject *arg) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.add_curves")) {
    return NULL;
  }
  // 1-int ParametricCurveCollection::add_curves(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "ParametricCurveCollection.add_curves", false, true);
  if (arg_this != NULL) {
    int return_value = (*local_this).add_curves(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_curves(const ParametricCurveCollection self, PandaNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_add_curves_28_comment =
  "C++ Interface:\n"
  "add_curves(const ParametricCurveCollection self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Adds all the curves found in the scene graph rooted at the given node.\n"
  " * Returns the number of curves found.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_add_curves_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ParametricCurveCollection::remove_curve(ParametricCurve *curve)
 * void ParametricCurveCollection::remove_curve(int index)
 */
static PyObject *Dtool_ParametricCurveCollection_remove_curve_29(PyObject *self, PyObject *arg) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.remove_curve")) {
    return NULL;
  }
  {
    // -2 bool ParametricCurveCollection::remove_curve(ParametricCurve *curve)
    ParametricCurve *arg_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ParametricCurve, 1, "ParametricCurveCollection.remove_curve", false, false);
    if (arg_this != NULL) {
      bool return_value = (*local_this).remove_curve(arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 void ParametricCurveCollection::remove_curve(int index)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      (*local_this).remove_curve((int)arg_val);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: bool ParametricCurveCollection::remove_curve(ParametricCurve *curve)
  // No coercion possible: void ParametricCurveCollection::remove_curve(int index)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_curve(const ParametricCurveCollection self, ParametricCurve curve)\n"
      "remove_curve(const ParametricCurveCollection self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_remove_curve_29_comment =
  "C++ Interface:\n"
  "remove_curve(const ParametricCurveCollection self, ParametricCurve curve)\n"
  "remove_curve(const ParametricCurveCollection self, int index)\n"
  "\n"
  "/**\n"
  " * Removes the indicated ParametricCurve from the collection.  Returns true if\n"
  " * the curve was removed, false if it was not a member of the collection.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the indicated ParametricCurve from the collection, by its index\n"
  " * number.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_remove_curve_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurveCollection::set_curve(int index, ParametricCurve *curve)
 */
static PyObject *Dtool_ParametricCurveCollection_set_curve_30(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.set_curve")) {
    return NULL;
  }
  // 1-void ParametricCurveCollection::set_curve(int index, ParametricCurve *curve)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "curve", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_curve", (char **)keyword_list, &param1, &param2)) {
    ParametricCurve *param2_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_ParametricCurve, 2, "ParametricCurveCollection.set_curve", false, true);
    if (param2_this != NULL) {
      (*local_this).set_curve((int)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_curve(const ParametricCurveCollection self, int index, ParametricCurve curve)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_set_curve_30_comment =
  "C++ Interface:\n"
  "set_curve(const ParametricCurveCollection self, int index, ParametricCurve curve)\n"
  "\n"
  "/**\n"
  " * Replaces the indicated ParametricCurve from the collection, by its index\n"
  " * number.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_set_curve_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ParametricCurveCollection::has_curve(ParametricCurve *curve) const
 */
static PyObject *Dtool_ParametricCurveCollection_has_curve_31(PyObject *self, PyObject *arg) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool ParametricCurveCollection::has_curve(ParametricCurve *curve) const
  ParametricCurve *arg_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ParametricCurve, 1, "ParametricCurveCollection.has_curve", false, true);
  if (arg_this != NULL) {
    bool return_value = (*(const ParametricCurveCollection*)local_this).has_curve(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_curve(ParametricCurveCollection self, ParametricCurve curve)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_has_curve_31_comment =
  "C++ Interface:\n"
  "has_curve(ParametricCurveCollection self, ParametricCurve curve)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated ParametricCurve appears in this collection,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_has_curve_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurveCollection::clear(void)
 */
static PyObject *Dtool_ParametricCurveCollection_clear_32(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.clear")) {
    return NULL;
  }
  // 1-void ParametricCurveCollection::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_clear_32_comment =
  "C++ Interface:\n"
  "clear(const ParametricCurveCollection self)\n"
  "\n"
  "/**\n"
  " * Removes all ParametricCurves from the collection.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_clear_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurveCollection::clear_timewarps(void)
 */
static PyObject *Dtool_ParametricCurveCollection_clear_timewarps_33(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.clear_timewarps")) {
    return NULL;
  }
  // 1-void ParametricCurveCollection::clear_timewarps(void)
  (*local_this).clear_timewarps();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_clear_timewarps_33_comment =
  "C++ Interface:\n"
  "clear_timewarps(const ParametricCurveCollection self)\n"
  "\n"
  "/**\n"
  " * Removes all the timewarp curves from the collection.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_clear_timewarps_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ParametricCurveCollection::get_num_curves(void) const
 */
static PyObject *Dtool_ParametricCurveCollection_get_num_curves_34(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ParametricCurveCollection::get_num_curves(void) const
  int return_value = (*(const ParametricCurveCollection*)local_this).get_num_curves();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_get_num_curves_34_comment =
  "C++ Interface:\n"
  "get_num_curves(ParametricCurveCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the number of ParametricCurves in the collection.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_get_num_curves_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ParametricCurve *ParametricCurveCollection::get_curve(int index) const
 */
static PyObject *Dtool_ParametricCurveCollection_get_curve_35(PyObject *self, PyObject *arg) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ParametricCurve *ParametricCurveCollection::get_curve(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ParametricCurve *return_value = (*(const ParametricCurveCollection*)local_this).get_curve((int)arg_val);
    if (return_value != (ParametricCurve *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (ParametricCurve *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_curve(ParametricCurveCollection self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_get_curve_35_comment =
  "C++ Interface:\n"
  "get_curve(ParametricCurveCollection self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth ParametricCurve in the collection.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_get_curve_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ParametricCurve *ParametricCurveCollection::get_xyz_curve(void) const
 */
static PyObject *Dtool_ParametricCurveCollection_get_xyz_curve_37(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-ParametricCurve *ParametricCurveCollection::get_xyz_curve(void) const
  ParametricCurve *return_value = (*(const ParametricCurveCollection*)local_this).get_xyz_curve();
  if (return_value != (ParametricCurve *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (ParametricCurve *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_get_xyz_curve_37_comment =
  "C++ Interface:\n"
  "get_xyz_curve(ParametricCurveCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the first XYZ curve in the collection, if any, or NULL if there are\n"
  " * none.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_get_xyz_curve_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ParametricCurve *ParametricCurveCollection::get_hpr_curve(void) const
 */
static PyObject *Dtool_ParametricCurveCollection_get_hpr_curve_38(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-ParametricCurve *ParametricCurveCollection::get_hpr_curve(void) const
  ParametricCurve *return_value = (*(const ParametricCurveCollection*)local_this).get_hpr_curve();
  if (return_value != (ParametricCurve *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (ParametricCurve *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_get_hpr_curve_38_comment =
  "C++ Interface:\n"
  "get_hpr_curve(ParametricCurveCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the first HPR curve in the collection, if any, or NULL if there are\n"
  " * none.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_get_hpr_curve_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ParametricCurve *ParametricCurveCollection::get_default_curve(void) const
 */
static PyObject *Dtool_ParametricCurveCollection_get_default_curve_39(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-ParametricCurve *ParametricCurveCollection::get_default_curve(void) const
  ParametricCurve *return_value = (*(const ParametricCurveCollection*)local_this).get_default_curve();
  if (return_value != (ParametricCurve *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (ParametricCurve *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_get_default_curve_39_comment =
  "C++ Interface:\n"
  "get_default_curve(ParametricCurveCollection self)\n"
  "\n"
  "/**\n"
  " * If there is an XYZ curve in the collection, returns it; otherwise, returns\n"
  " * the first curve whose type is unspecified.  Returns NULL if no curve meets\n"
  " * the criteria.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_get_default_curve_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int ParametricCurveCollection::get_num_timewarps(void) const
 */
static PyObject *Dtool_ParametricCurveCollection_get_num_timewarps_40(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-int ParametricCurveCollection::get_num_timewarps(void) const
  int return_value = (*(const ParametricCurveCollection*)local_this).get_num_timewarps();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_get_num_timewarps_40_comment =
  "C++ Interface:\n"
  "get_num_timewarps(ParametricCurveCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the number of timewarp curves in the collection.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_get_num_timewarps_40_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ParametricCurve *ParametricCurveCollection::get_timewarp_curve(int n) const
 */
static PyObject *Dtool_ParametricCurveCollection_get_timewarp_curve_41(PyObject *self, PyObject *arg) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-ParametricCurve *ParametricCurveCollection::get_timewarp_curve(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ParametricCurve *return_value = (*(const ParametricCurveCollection*)local_this).get_timewarp_curve((int)arg_val);
    if (return_value != (ParametricCurve *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (ParametricCurve *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_timewarp_curve(ParametricCurveCollection self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_get_timewarp_curve_41_comment =
  "C++ Interface:\n"
  "get_timewarp_curve(ParametricCurveCollection self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth timewarp curve in the collection.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_get_timewarp_curve_41_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat ParametricCurveCollection::get_max_t(void) const
 */
static PyObject *Dtool_ParametricCurveCollection_get_max_t_43(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat ParametricCurveCollection::get_max_t(void) const
  PN_stdfloat return_value = (*(const ParametricCurveCollection*)local_this).get_max_t();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_get_max_t_43_comment =
  "C++ Interface:\n"
  "get_max_t(ParametricCurveCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum T value associated with the *last* curve in the\n"
  " * collection.  Normally, this will be either the XYZ or HPR curve, or a\n"
  " * timewarp curve.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_get_max_t_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurveCollection::make_even(PN_stdfloat max_t, PN_stdfloat segments_per_unit)
 */
static PyObject *Dtool_ParametricCurveCollection_make_even_53(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.make_even")) {
    return NULL;
  }
  // 1-void ParametricCurveCollection::make_even(PN_stdfloat max_t, PN_stdfloat segments_per_unit)
  float param1;
  float param2;
  static const char *keyword_list[] = {"max_t", "segments_per_unit", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:make_even", (char **)keyword_list, &param1, &param2)) {
    (*local_this).make_even((PN_stdfloat)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_even(const ParametricCurveCollection self, float max_t, float segments_per_unit)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_make_even_53_comment =
  "C++ Interface:\n"
  "make_even(const ParametricCurveCollection self, float max_t, float segments_per_unit)\n"
  "\n"
  "/**\n"
  " * Discards all existing timewarp curves and recomputes a new timewarp curve\n"
  " * that maps distance along the curve to parametric time, so that the distance\n"
  " * between any two points in parametric time is proportional to the\n"
  " * approximate distance of those same two points along the XYZ curve.\n"
  " *\n"
  " * segments_per_unit represents the number of segments to take per each unit\n"
  " * of parametric time of the original XYZ curve.\n"
  " *\n"
  " * The new timewarp curve (and thus, the apparent range of the collection)\n"
  " * will range from 0 to max_t.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_make_even_53_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurveCollection::face_forward(PN_stdfloat segments_per_unit)
 */
static PyObject *Dtool_ParametricCurveCollection_face_forward_54(PyObject *self, PyObject *arg) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.face_forward")) {
    return NULL;
  }
  // 1-void ParametricCurveCollection::face_forward(PN_stdfloat segments_per_unit)
  if (PyNumber_Check(arg)) {
    (*local_this).face_forward((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "face_forward(const ParametricCurveCollection self, float segments_per_unit)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_face_forward_54_comment =
  "C++ Interface:\n"
  "face_forward(const ParametricCurveCollection self, float segments_per_unit)\n"
  "\n"
  "/**\n"
  " * Discards the existing HPR curve and generates a new one that looks in the\n"
  " * direction of travel along the XYZ curve, based on the XYZ curve's tangent\n"
  " * at each point.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_face_forward_54_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurveCollection::reset_max_t(PN_stdfloat max_t)
 */
static PyObject *Dtool_ParametricCurveCollection_reset_max_t_55(PyObject *self, PyObject *arg) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.reset_max_t")) {
    return NULL;
  }
  // 1-void ParametricCurveCollection::reset_max_t(PN_stdfloat max_t)
  if (PyNumber_Check(arg)) {
    (*local_this).reset_max_t((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reset_max_t(const ParametricCurveCollection self, float max_t)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_reset_max_t_55_comment =
  "C++ Interface:\n"
  "reset_max_t(const ParametricCurveCollection self, float max_t)\n"
  "\n"
  "/**\n"
  " * Adjusts the apparent length of the curve by applying a new timewarp that\n"
  " * maps the range [0..max_t] to the range [0..get_max_t()].  After this call,\n"
  " * the curve collection will contain one more timewarp curve, and get_max_t()\n"
  " * will return the given max_t value.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_reset_max_t_55_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ParametricCurveCollection::evaluate(PN_stdfloat t, LMatrix4 &result, CoordinateSystem cs = ::CS_default) const
 * bool ParametricCurveCollection::evaluate(PN_stdfloat t, LVecBase3 &xyz, LVecBase3 &hpr) const
 */
static PyObject *Dtool_ParametricCurveCollection_evaluate_56(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-bool ParametricCurveCollection::evaluate(PN_stdfloat t, LMatrix4 &result, CoordinateSystem cs) const
      float param1;
      PyObject *param2;
      static const char *keyword_list[] = {"t", "result", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:evaluate", (char **)keyword_list, &param1, &param2)) {
        LMatrix4f param2_local;
        LMatrix4 *param2_this = Dtool_Coerce_LMatrix4f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurveCollection.evaluate", "LMatrix4f");
        }
        bool return_value = (*(const ParametricCurveCollection*)local_this).evaluate((PN_stdfloat)param1, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
    {
      {
        // -2 bool ParametricCurveCollection::evaluate(PN_stdfloat t, LVecBase3 &xyz, LVecBase3 &hpr) const
        float param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"t", "xyz", "hpr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "fOO:evaluate", (char **)keyword_list, &param1, &param2, &param3)) {
          LVecBase3 *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVecBase3f, 2, "ParametricCurveCollection.evaluate", false, false);
          LVecBase3 *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_LVecBase3f, 3, "ParametricCurveCollection.evaluate", false, false);
          if (param2_this != NULL && param3_this != NULL) {
            bool return_value = (*(const ParametricCurveCollection*)local_this).evaluate((PN_stdfloat)param1, *param2_this, *param3_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool ParametricCurveCollection::evaluate(PN_stdfloat t, LMatrix4 &result, CoordinateSystem cs) const
        float param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"t", "result", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "fOi:evaluate", (char **)keyword_list, &param1, &param2, &param3)) {
          LMatrix4 *param2_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LMatrix4f, 2, "ParametricCurveCollection.evaluate", false, false);
          if (param2_this != NULL) {
            bool return_value = (*(const ParametricCurveCollection*)local_this).evaluate((PN_stdfloat)param1, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool ParametricCurveCollection::evaluate(PN_stdfloat t, LVecBase3 &xyz, LVecBase3 &hpr) const
        float param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"t", "xyz", "hpr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "fOO:evaluate", (char **)keyword_list, &param1, &param2, &param3)) {
          LVecBase3f param2_local;
          LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
          LVecBase3f param3_local;
          LVecBase3 *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
          if ((param2_this != NULL) && (param3_this != NULL)) {
            bool return_value = (*(const ParametricCurveCollection*)local_this).evaluate((PN_stdfloat)param1, *param2_this, *param3_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool ParametricCurveCollection::evaluate(PN_stdfloat t, LMatrix4 &result, CoordinateSystem cs) const
        float param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"t", "result", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "fOi:evaluate", (char **)keyword_list, &param1, &param2, &param3)) {
          LMatrix4f param2_local;
          LMatrix4 *param2_this = Dtool_Coerce_LMatrix4f(param2, param2_local);
          if ((param2_this != NULL)) {
            bool return_value = (*(const ParametricCurveCollection*)local_this).evaluate((PN_stdfloat)param1, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "evaluate() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "evaluate(ParametricCurveCollection self, float t, LMatrix4f result)\n"
      "evaluate(ParametricCurveCollection self, float t, LVecBase3f xyz, LVecBase3f hpr)\n"
      "evaluate(ParametricCurveCollection self, float t, LMatrix4f result, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_evaluate_56_comment =
  "C++ Interface:\n"
  "evaluate(ParametricCurveCollection self, float t, LMatrix4f result)\n"
  "evaluate(ParametricCurveCollection self, float t, LVecBase3f xyz, LVecBase3f hpr)\n"
  "evaluate(ParametricCurveCollection self, float t, LMatrix4f result, int cs)\n"
  "\n"
  "/**\n"
  " * Computes the position and rotation represented by the first XYZ and HPR\n"
  " * curves in the collection at the given point t, after t has been modified by\n"
  " * all the timewarp curves in the collection applied in sequence, from back to\n"
  " * front.\n"
  " *\n"
  " * Returns true if the point is valid (i.e.  t is within the bounds indicated\n"
  " * by all the timewarp curves and within the bounds of the curves themselves),\n"
  " * or false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Computes the transform matrix representing translation to the position\n"
  " * indicated by the first XYZ curve in the collection and the rotation\n"
  " * indicated by the first HPR curve in the collection, after t has been\n"
  " * modified by all the timewarp curves in the collection applied in sequence,\n"
  " * from back to front.\n"
  " *\n"
  " * Returns true if the point is valid (i.e.  t is within the bounds indicated\n"
  " * by all the timewarp curves and within the bounds of the curves themselves),\n"
  " * or false otherwise.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_evaluate_56_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat ParametricCurveCollection::evaluate_t(PN_stdfloat t) const
 */
static PyObject *Dtool_ParametricCurveCollection_evaluate_t_57(PyObject *self, PyObject *arg) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat ParametricCurveCollection::evaluate_t(PN_stdfloat t) const
  if (PyNumber_Check(arg)) {
    PN_stdfloat return_value = (*(const ParametricCurveCollection*)local_this).evaluate_t((PN_stdfloat)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "evaluate_t(ParametricCurveCollection self, float t)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_evaluate_t_57_comment =
  "C++ Interface:\n"
  "evaluate_t(ParametricCurveCollection self, float t)\n"
  "\n"
  "/**\n"
  " * Determines the value of t that should be passed to the XYZ and HPR curves,\n"
  " * after applying the given value of t to all the timewarps.  Return -1.0f if\n"
  " * the value of t exceeds one of the timewarps' ranges.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_evaluate_t_57_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ParametricCurveCollection::evaluate_xyz(PN_stdfloat t, LVecBase3 &xyz) const
 */
static PyObject *Dtool_ParametricCurveCollection_evaluate_xyz_58(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ParametricCurveCollection::evaluate_xyz(PN_stdfloat t, LVecBase3 &xyz) const
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"t", "xyz", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:evaluate_xyz", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurveCollection.evaluate_xyz", "LVecBase3f");
    }
    bool return_value = (*(const ParametricCurveCollection*)local_this).evaluate_xyz((PN_stdfloat)param1, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "evaluate_xyz(ParametricCurveCollection self, float t, LVecBase3f xyz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_evaluate_xyz_58_comment =
  "C++ Interface:\n"
  "evaluate_xyz(ParametricCurveCollection self, float t, LVecBase3f xyz)\n"
  "\n"
  "/**\n"
  " * Computes only the XYZ part of the curves.  See evaluate().\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_evaluate_xyz_58_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ParametricCurveCollection::evaluate_hpr(PN_stdfloat t, LVecBase3 &hpr) const
 */
static PyObject *Dtool_ParametricCurveCollection_evaluate_hpr_59(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ParametricCurveCollection::evaluate_hpr(PN_stdfloat t, LVecBase3 &hpr) const
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"t", "hpr", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:evaluate_hpr", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurveCollection.evaluate_hpr", "LVecBase3f");
    }
    bool return_value = (*(const ParametricCurveCollection*)local_this).evaluate_hpr((PN_stdfloat)param1, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "evaluate_hpr(ParametricCurveCollection self, float t, LVecBase3f hpr)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_evaluate_hpr_59_comment =
  "C++ Interface:\n"
  "evaluate_hpr(ParametricCurveCollection self, float t, LVecBase3f hpr)\n"
  "\n"
  "/**\n"
  " * Computes only the HPR part of the curves.  See evaluate().\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_evaluate_hpr_59_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ParametricCurveCollection::adjust_xyz(PN_stdfloat t, LVecBase3 const &xyz)
 * inline bool ParametricCurveCollection::adjust_xyz(PN_stdfloat t, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_ParametricCurveCollection_adjust_xyz_60(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.adjust_xyz")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-bool ParametricCurveCollection::adjust_xyz(PN_stdfloat t, LVecBase3 const &xyz)
      float param1;
      PyObject *param2;
      static const char *keyword_list[] = {"t", "xyz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:adjust_xyz", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurveCollection.adjust_xyz", "LVecBase3f");
        }
        bool return_value = (*local_this).adjust_xyz((PN_stdfloat)param1, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 4:
    {
      // 1-inline bool ParametricCurveCollection::adjust_xyz(PN_stdfloat t, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"t", "x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:adjust_xyz", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        bool return_value = (*local_this).adjust_xyz((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "adjust_xyz() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "adjust_xyz(const ParametricCurveCollection self, float t, const LVecBase3f xyz)\n"
      "adjust_xyz(const ParametricCurveCollection self, float t, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_adjust_xyz_60_comment =
  "C++ Interface:\n"
  "adjust_xyz(const ParametricCurveCollection self, float t, const LVecBase3f xyz)\n"
  "adjust_xyz(const ParametricCurveCollection self, float t, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Adjust the XYZ curve at the indicated time to the new value.  The curve\n"
  " * shape will change correspondingly.  Returns true if successful, false if\n"
  " * unable to make the adjustment for some reason.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adjust the XYZ curve at the indicated time to the new value.  The curve\n"
  " * shape will change correspondingly.  Returns true if successful, false if\n"
  " * unable to make the adjustment for some reason.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_adjust_xyz_60_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ParametricCurveCollection::adjust_hpr(PN_stdfloat t, LVecBase3 const &xyz)
 * inline bool ParametricCurveCollection::adjust_hpr(PN_stdfloat t, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
 */
static PyObject *Dtool_ParametricCurveCollection_adjust_hpr_61(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.adjust_hpr")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-bool ParametricCurveCollection::adjust_hpr(PN_stdfloat t, LVecBase3 const &xyz)
      float param1;
      PyObject *param2;
      static const char *keyword_list[] = {"t", "xyz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:adjust_hpr", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurveCollection.adjust_hpr", "LVecBase3f");
        }
        bool return_value = (*local_this).adjust_hpr((PN_stdfloat)param1, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 4:
    {
      // 1-inline bool ParametricCurveCollection::adjust_hpr(PN_stdfloat t, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"t", "h", "p", "r", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:adjust_hpr", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        bool return_value = (*local_this).adjust_hpr((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "adjust_hpr() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "adjust_hpr(const ParametricCurveCollection self, float t, const LVecBase3f xyz)\n"
      "adjust_hpr(const ParametricCurveCollection self, float t, float h, float p, float r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_adjust_hpr_61_comment =
  "C++ Interface:\n"
  "adjust_hpr(const ParametricCurveCollection self, float t, const LVecBase3f xyz)\n"
  "adjust_hpr(const ParametricCurveCollection self, float t, float h, float p, float r)\n"
  "\n"
  "/**\n"
  " * Adjust the HPR curve at the indicated time to the new value.  The curve\n"
  " * shape will change correspondingly.  Returns true if successful, false if\n"
  " * unable to make the adjustment for some reason.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adjust the HPR curve at the indicated time to the new value.  The curve\n"
  " * shape will change correspondingly.  Returns true if successful, false if\n"
  " * unable to make the adjustment for some reason.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_adjust_hpr_61_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ParametricCurveCollection::recompute(void)
 */
static PyObject *Dtool_ParametricCurveCollection_recompute_62(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.recompute")) {
    return NULL;
  }
  // 1-bool ParametricCurveCollection::recompute(void)
  bool return_value = (*local_this).recompute();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_recompute_62_comment =
  "C++ Interface:\n"
  "recompute(const ParametricCurveCollection self)\n"
  "\n"
  "/**\n"
  " * Ensures all the curves are freshly computed and up-to-date.  Returns true\n"
  " * if everything is valid, false if at least one curve is incorrect.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_recompute_62_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ParametricCurveCollection::stitch(ParametricCurveCollection const *a, ParametricCurveCollection const *b)
 */
static PyObject *Dtool_ParametricCurveCollection_stitch_63(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.stitch")) {
    return NULL;
  }
  // 1-bool ParametricCurveCollection::stitch(ParametricCurveCollection const *a, ParametricCurveCollection const *b)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"a", "b", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:stitch", (char **)keyword_list, &param1, &param2)) {
    ParametricCurveCollection const *param1_this = (ParametricCurveCollection *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ParametricCurveCollection, 1, "ParametricCurveCollection.stitch", true, true);
    ParametricCurveCollection const *param2_this = (ParametricCurveCollection *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_ParametricCurveCollection, 2, "ParametricCurveCollection.stitch", true, true);
    if (param1_this != NULL && param2_this != NULL) {
      bool return_value = (*local_this).stitch(param1_this, param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "stitch(const ParametricCurveCollection self, const ParametricCurveCollection a, const ParametricCurveCollection b)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_stitch_63_comment =
  "C++ Interface:\n"
  "stitch(const ParametricCurveCollection self, const ParametricCurveCollection a, const ParametricCurveCollection b)\n"
  "\n"
  "/**\n"
  " * Regenerates this curve as one long curve: the first curve connected end-to-\n"
  " * end with the second one.  Either a or b may be the same as 'this'.  This\n"
  " * will lose any timewarps on the input curves.\n"
  " *\n"
  " * Returns true if successful, false on failure.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_stitch_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurveCollection::output(ostream &out) const
 */
static PyObject *Dtool_ParametricCurveCollection_output_64(PyObject *self, PyObject *arg) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ParametricCurveCollection::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ParametricCurveCollection.output", false, true);
  if (arg_this != NULL) {
    (*(const ParametricCurveCollection*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ParametricCurveCollection self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_output_64_comment =
  "C++ Interface:\n"
  "output(ParametricCurveCollection self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a brief one-line description of the ParametricCurveCollection to the\n"
  " * indicated output stream.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_output_64_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurveCollection::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_ParametricCurveCollection_write_65(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ParametricCurveCollection::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "ParametricCurveCollection.write", false, true);
    if (param1_this != NULL) {
      (*(const ParametricCurveCollection*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ParametricCurveCollection self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_write_65_comment =
  "C++ Interface:\n"
  "write(ParametricCurveCollection self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a complete multi-line description of the ParametricCurveCollection\n"
  " * to the indicated output stream.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_write_65_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ParametricCurveCollection::write_egg(Filename filename, CoordinateSystem cs = ::CS_default)
 * bool ParametricCurveCollection::write_egg(ostream &out, Filename const &filename, CoordinateSystem cs)
 */
static PyObject *Dtool_ParametricCurveCollection_write_egg_66(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.write_egg")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "filename");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'filename' (pos 1) not found");
      }
      // 1-bool ParametricCurveCollection::write_egg(Filename filename, CoordinateSystem cs)
      Filename arg_local;
      Filename *arg_this = Dtool_Coerce_Filename(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "ParametricCurveCollection.write_egg", "Filename");
      }
      bool return_value = (*local_this).write_egg(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-bool ParametricCurveCollection::write_egg(Filename filename, CoordinateSystem cs)
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"filename", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_egg", (char **)keyword_list, &param1, &param2)) {
        Filename param1_local;
        Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "ParametricCurveCollection.write_egg", "Filename");
        }
        bool return_value = (*local_this).write_egg(*param1_this, (CoordinateSystem)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-bool ParametricCurveCollection::write_egg(ostream &out, Filename const &filename, CoordinateSystem cs)
      PyObject *param1;
      PyObject *param2;
      int param3;
      static const char *keyword_list[] = {"out", "filename", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:write_egg", (char **)keyword_list, &param1, &param2, &param3)) {
        ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "ParametricCurveCollection.write_egg", false, true);
        Filename param2_local;
        Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurveCollection.write_egg", "Filename");
        }
        if (param1_this != NULL) {
          bool return_value = (*local_this).write_egg(*param1_this, *param2_this, (CoordinateSystem)param3);
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "write_egg() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_egg(const ParametricCurveCollection self, Filename filename)\n"
      "write_egg(const ParametricCurveCollection self, Filename filename, int cs)\n"
      "write_egg(const ParametricCurveCollection self, ostream out, const Filename filename, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_write_egg_66_comment =
  "C++ Interface:\n"
  "write_egg(const ParametricCurveCollection self, Filename filename)\n"
  "write_egg(const ParametricCurveCollection self, Filename filename, int cs)\n"
  "write_egg(const ParametricCurveCollection self, ostream out, const Filename filename, int cs)\n"
  "\n"
  "/**\n"
  " * Writes an egg description of all the nurbs curves in the collection to the\n"
  " * specified output file.  Returns true if the file is successfully written.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Writes an egg description of all the nurbs curves in the collection to the\n"
  " * specified output stream.  Returns true if the file is successfully written.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_write_egg_66_comment = NULL;
#endif

/**
 * sequence length function for property ParametricCurveCollection::curves
 */
static Py_ssize_t Dtool_ParametricCurveCollection_curves_Len(PyObject *self) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_curves();
}

/**
 * sequence getter for property ParametricCurveCollection::curves
 */
static PyObject *Dtool_ParametricCurveCollection_curves_Getitem(PyObject *self, Py_ssize_t index) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_curves()) {
    PyErr_SetString(PyExc_IndexError, "ParametricCurveCollection.curves[] index out of range");
    return NULL;
  }
  // 1-inline ParametricCurve *ParametricCurveCollection::get_curve(int index) const
  ParametricCurve *return_value = (*(const ParametricCurveCollection*)local_this).get_curve(index);
  if (return_value != (ParametricCurve *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (ParametricCurve *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_curve(ParametricCurveCollection self, index)\n");
  }
}

static int Dtool_ParametricCurveCollection_curves_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.curves")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    local_this->remove_curve(index);
    return 0;
  }
  // 1-void ParametricCurveCollection::set_curve(int index, ParametricCurve *curve)
  ParametricCurve *arg_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ParametricCurve, 2, "ParametricCurveCollection.set_curve", false, true);
  if (arg_this != NULL) {
    (*local_this).set_curve(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_curve(const ParametricCurveCollection self, index, ParametricCurve curve)\n");
  }
  return -1;
}

static PyObject *Dtool_ParametricCurveCollection_curves_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_ParametricCurveCollection_curves_Len;
  wrap->_getitem_func = &Dtool_ParametricCurveCollection_curves_Getitem;
  wrap->_setitem_func = &Dtool_ParametricCurveCollection_curves_Setitem;
  return (PyObject *)wrap;
}

static PyObject *Dtool_ParametricCurveCollection_xyz_curve_Getter(PyObject *self, void *) {
  const ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }

  // 1-ParametricCurve *ParametricCurveCollection::get_xyz_curve(void) const
  ParametricCurve *return_value = (*(const ParametricCurveCollection*)local_this).get_xyz_curve();
  if (return_value != (ParametricCurve *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (ParametricCurve *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_ParametricCurveCollection_hpr_curve_Getter(PyObject *self, void *) {
  const ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }

  // 1-ParametricCurve *ParametricCurveCollection::get_hpr_curve(void) const
  ParametricCurve *return_value = (*(const ParametricCurveCollection*)local_this).get_hpr_curve();
  if (return_value != (ParametricCurve *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (ParametricCurve *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_ParametricCurveCollection_default_curve_Getter(PyObject *self, void *) {
  const ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }

  // 1-ParametricCurve *ParametricCurveCollection::get_default_curve(void) const
  ParametricCurve *return_value = (*(const ParametricCurveCollection*)local_this).get_default_curve();
  if (return_value != (ParametricCurve *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (ParametricCurve *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
}

/**
 * sequence length function for property ParametricCurveCollection::timewarp_curves
 */
static Py_ssize_t Dtool_ParametricCurveCollection_timewarp_curves_Len(PyObject *self) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_timewarps();
}

/**
 * sequence getter for property ParametricCurveCollection::timewarp_curves
 */
static PyObject *Dtool_ParametricCurveCollection_timewarp_curves_Getitem(PyObject *self, Py_ssize_t index) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_timewarps()) {
    PyErr_SetString(PyExc_IndexError, "ParametricCurveCollection.timewarp_curves[] index out of range");
    return NULL;
  }
  // 1-ParametricCurve *ParametricCurveCollection::get_timewarp_curve(int n) const
  ParametricCurve *return_value = (*(const ParametricCurveCollection*)local_this).get_timewarp_curve(index);
  if (return_value != (ParametricCurve *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (ParametricCurve *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_timewarp_curve(ParametricCurveCollection self, index)\n");
  }
}

static PyObject *Dtool_ParametricCurveCollection_timewarp_curves_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_ParametricCurveCollection_timewarp_curves_Len;
  wrap->_getitem_func = &Dtool_ParametricCurveCollection_timewarp_curves_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

static PyObject *Dtool_ParametricCurveCollection_max_t_Getter(PyObject *self, void *) {
  const ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat ParametricCurveCollection::get_max_t(void) const
  PN_stdfloat return_value = (*(const ParametricCurveCollection*)local_this).get_max_t();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * ParametricCurveCollection::ParametricCurveCollection(void)
 * inline ParametricCurveCollection::ParametricCurveCollection(ParametricCurveCollection const &) = default
 */
static int Dtool_Init_ParametricCurveCollection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-ParametricCurveCollection::ParametricCurveCollection(void)
      ParametricCurveCollection *return_value = new ParametricCurveCollection();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParametricCurveCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline ParametricCurveCollection::ParametricCurveCollection(ParametricCurveCollection const &) = default
      ParametricCurveCollection const *arg_this = (ParametricCurveCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ParametricCurveCollection, 0, "ParametricCurveCollection.ParametricCurveCollection", true, true);
      if (arg_this != NULL) {
        ParametricCurveCollection *return_value = new ParametricCurveCollection(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParametricCurveCollection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ParametricCurveCollection() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParametricCurveCollection()\n"
      "ParametricCurveCollection(const ParametricCurveCollection param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ParametricCurveCollection_get_curves(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_curves();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ParametricCurveCollection_get_curve_35(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ParametricCurveCollection_get_timewarp_curves(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_timewarps();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ParametricCurveCollection_get_timewarp_curve_41(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_ParametricCurveCollection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParametricCurveCollection) {
    printf("ParametricCurveCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParametricCurveCollection *local_this = (ParametricCurveCollection *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParametricCurveCollection) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParametricCurveCollection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParametricCurveCollection) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParametricCurveCollection*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CurveFitter
 */
/**
 * Python function wrapper for:
 * void CurveFitter::reset(void)
 */
static PyObject *Dtool_CurveFitter_reset_70(PyObject *self, PyObject *) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.reset")) {
    return NULL;
  }
  // 1-void CurveFitter::reset(void)
  (*local_this).reset();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_reset_70_comment =
  "C++ Interface:\n"
  "reset(const CurveFitter self)\n"
  "\n"
  "/**\n"
  " * Removes all the data points previously added to the CurveFitter, and\n"
  " * initializes it for a new curve.\n"
  " */";
#else
static const char *Dtool_CurveFitter_reset_70_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::add_xyz(PN_stdfloat t, LVecBase3 const &xyz)
 */
static PyObject *Dtool_CurveFitter_add_xyz_71(PyObject *self, PyObject *args, PyObject *kwds) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.add_xyz")) {
    return NULL;
  }
  // 1-void CurveFitter::add_xyz(PN_stdfloat t, LVecBase3 const &xyz)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"t", "xyz", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:add_xyz", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CurveFitter.add_xyz", "LVecBase3f");
    }
    (*local_this).add_xyz((PN_stdfloat)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_xyz(const CurveFitter self, float t, const LVecBase3f xyz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_add_xyz_71_comment =
  "C++ Interface:\n"
  "add_xyz(const CurveFitter self, float t, const LVecBase3f xyz)\n"
  "\n"
  "/**\n"
  " * Adds a single sample xyz.\n"
  " */";
#else
static const char *Dtool_CurveFitter_add_xyz_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::add_hpr(PN_stdfloat t, LVecBase3 const &hpr)
 */
static PyObject *Dtool_CurveFitter_add_hpr_72(PyObject *self, PyObject *args, PyObject *kwds) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.add_hpr")) {
    return NULL;
  }
  // 1-void CurveFitter::add_hpr(PN_stdfloat t, LVecBase3 const &hpr)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"t", "hpr", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:add_hpr", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CurveFitter.add_hpr", "LVecBase3f");
    }
    (*local_this).add_hpr((PN_stdfloat)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_hpr(const CurveFitter self, float t, const LVecBase3f hpr)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_add_hpr_72_comment =
  "C++ Interface:\n"
  "add_hpr(const CurveFitter self, float t, const LVecBase3f hpr)\n"
  "\n"
  "/**\n"
  " * Adds a single sample hpr.\n"
  " */";
#else
static const char *Dtool_CurveFitter_add_hpr_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::add_xyz_hpr(PN_stdfloat t, LVecBase3 const &xyz, LVecBase3 const &hpr)
 */
static PyObject *Dtool_CurveFitter_add_xyz_hpr_73(PyObject *self, PyObject *args, PyObject *kwds) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.add_xyz_hpr")) {
    return NULL;
  }
  // 1-void CurveFitter::add_xyz_hpr(PN_stdfloat t, LVecBase3 const &xyz, LVecBase3 const &hpr)
  float param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"t", "xyz", "hpr", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fOO:add_xyz_hpr", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3f param2_local;
    LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CurveFitter.add_xyz_hpr", "LVecBase3f");
    }
    LVecBase3f param3_local;
    LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "CurveFitter.add_xyz_hpr", "LVecBase3f");
    }
    (*local_this).add_xyz_hpr((PN_stdfloat)param1, *param2_this, *param3_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_xyz_hpr(const CurveFitter self, float t, const LVecBase3f xyz, const LVecBase3f hpr)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_add_xyz_hpr_73_comment =
  "C++ Interface:\n"
  "add_xyz_hpr(const CurveFitter self, float t, const LVecBase3f xyz, const LVecBase3f hpr)\n"
  "\n"
  "/**\n"
  " * Adds a single sample xyz & hpr simultaneously.\n"
  " */";
#else
static const char *Dtool_CurveFitter_add_xyz_hpr_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int CurveFitter::get_num_samples(void) const
 */
static PyObject *Dtool_CurveFitter_get_num_samples_74(PyObject *self, PyObject *) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CurveFitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-int CurveFitter::get_num_samples(void) const
  int return_value = (*(const CurveFitter*)local_this).get_num_samples();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_get_num_samples_74_comment =
  "C++ Interface:\n"
  "get_num_samples(CurveFitter self)\n"
  "\n"
  "/**\n"
  " * Returns the number of sample points that have been added.\n"
  " */";
#else
static const char *Dtool_CurveFitter_get_num_samples_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat CurveFitter::get_sample_t(int n) const
 */
static PyObject *Dtool_CurveFitter_get_sample_t_75(PyObject *self, PyObject *arg) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CurveFitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat CurveFitter::get_sample_t(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = (*(const CurveFitter*)local_this).get_sample_t((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sample_t(CurveFitter self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_get_sample_t_75_comment =
  "C++ Interface:\n"
  "get_sample_t(CurveFitter self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the parametric value of the nth sample added.\n"
  " */";
#else
static const char *Dtool_CurveFitter_get_sample_t_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVecBase3 CurveFitter::get_sample_xyz(int n) const
 */
static PyObject *Dtool_CurveFitter_get_sample_xyz_76(PyObject *self, PyObject *arg) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CurveFitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-LVecBase3 CurveFitter::get_sample_xyz(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3 *return_value = new LVecBase3((*(const CurveFitter*)local_this).get_sample_xyz((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sample_xyz(CurveFitter self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_get_sample_xyz_76_comment =
  "C++ Interface:\n"
  "get_sample_xyz(CurveFitter self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the point in space of the nth sample added.\n"
  " */";
#else
static const char *Dtool_CurveFitter_get_sample_xyz_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVecBase3 CurveFitter::get_sample_hpr(int n) const
 */
static PyObject *Dtool_CurveFitter_get_sample_hpr_77(PyObject *self, PyObject *arg) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CurveFitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-LVecBase3 CurveFitter::get_sample_hpr(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3 *return_value = new LVecBase3((*(const CurveFitter*)local_this).get_sample_hpr((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sample_hpr(CurveFitter self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_get_sample_hpr_77_comment =
  "C++ Interface:\n"
  "get_sample_hpr(CurveFitter self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the orientation of the nth sample added.\n"
  " */";
#else
static const char *Dtool_CurveFitter_get_sample_hpr_77_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVecBase3 CurveFitter::get_sample_tangent(int n) const
 */
static PyObject *Dtool_CurveFitter_get_sample_tangent_78(PyObject *self, PyObject *arg) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CurveFitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-LVecBase3 CurveFitter::get_sample_tangent(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3 *return_value = new LVecBase3((*(const CurveFitter*)local_this).get_sample_tangent((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sample_tangent(CurveFitter self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_get_sample_tangent_78_comment =
  "C++ Interface:\n"
  "get_sample_tangent(CurveFitter self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the tangent associated with the nth sample added.  This is only\n"
  " * meaningful if compute_tangents() has already been called.\n"
  " */";
#else
static const char *Dtool_CurveFitter_get_sample_tangent_78_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::remove_samples(int begin, int end)
 */
static PyObject *Dtool_CurveFitter_remove_samples_79(PyObject *self, PyObject *args, PyObject *kwds) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.remove_samples")) {
    return NULL;
  }
  // 1-void CurveFitter::remove_samples(int begin, int end)
  int param1;
  int param2;
  static const char *keyword_list[] = {"begin", "end", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:remove_samples", (char **)keyword_list, &param1, &param2)) {
    (*local_this).remove_samples((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_samples(const CurveFitter self, int begin, int end)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_remove_samples_79_comment =
  "C++ Interface:\n"
  "remove_samples(const CurveFitter self, int begin, int end)\n"
  "\n"
  "/**\n"
  " * Eliminates all samples from index begin, up to but not including index end,\n"
  " * from the database.\n"
  " */";
#else
static const char *Dtool_CurveFitter_remove_samples_79_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::sample(ParametricCurveCollection *curves, int count)
 */
static PyObject *Dtool_CurveFitter_sample_80(PyObject *self, PyObject *args, PyObject *kwds) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.sample")) {
    return NULL;
  }
  // 1-void CurveFitter::sample(ParametricCurveCollection *curves, int count)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"curves", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:sample", (char **)keyword_list, &param1, &param2)) {
    ParametricCurveCollection *param1_this = (ParametricCurveCollection *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ParametricCurveCollection, 1, "CurveFitter.sample", false, true);
    if (param1_this != NULL) {
      (*local_this).sample(param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "sample(const CurveFitter self, ParametricCurveCollection curves, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_sample_80_comment =
  "C++ Interface:\n"
  "sample(const CurveFitter self, ParametricCurveCollection curves, int count)\n"
  "\n"
  "/**\n"
  " * Generates a series of data points by sampling the given curve (or xyz/hpr\n"
  " * curves) the indicated number of times.  The sampling is made evenly in\n"
  " * parametric time, and then the timewarps, if any, are applied.\n"
  " */";
#else
static const char *Dtool_CurveFitter_sample_80_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::wrap_hpr(void)
 */
static PyObject *Dtool_CurveFitter_wrap_hpr_81(PyObject *self, PyObject *) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.wrap_hpr")) {
    return NULL;
  }
  // 1-void CurveFitter::wrap_hpr(void)
  (*local_this).wrap_hpr();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_wrap_hpr_81_comment =
  "C++ Interface:\n"
  "wrap_hpr(const CurveFitter self)\n"
  "\n"
  "/**\n"
  " * Resets each HPR data point so that the maximum delta between any two\n"
  " * consecutive points is 180 degrees, which should prevent incorrect HPR\n"
  " * wrapping.\n"
  " */";
#else
static const char *Dtool_CurveFitter_wrap_hpr_81_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::sort_points(void)
 */
static PyObject *Dtool_CurveFitter_sort_points_82(PyObject *self, PyObject *) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.sort_points")) {
    return NULL;
  }
  // 1-void CurveFitter::sort_points(void)
  (*local_this).sort_points();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_sort_points_82_comment =
  "C++ Interface:\n"
  "sort_points(const CurveFitter self)\n"
  "\n"
  "/**\n"
  " * Sorts all the data points in order by parametric time, in case they were\n"
  " * added in an incorrect order.\n"
  " */";
#else
static const char *Dtool_CurveFitter_sort_points_82_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::desample(PN_stdfloat factor)
 */
static PyObject *Dtool_CurveFitter_desample_83(PyObject *self, PyObject *arg) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.desample")) {
    return NULL;
  }
  // 1-void CurveFitter::desample(PN_stdfloat factor)
  if (PyNumber_Check(arg)) {
    (*local_this).desample((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "desample(const CurveFitter self, float factor)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_desample_83_comment =
  "C++ Interface:\n"
  "desample(const CurveFitter self, float factor)\n"
  "\n"
  "/**\n"
  " * Removes sample points in order to reduce the complexity of a sampled curve.\n"
  " * Keeps one out of every factor samples.  Also keeps the first and the last\n"
  " * samples.\n"
  " */";
#else
static const char *Dtool_CurveFitter_desample_83_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::compute_tangents(PN_stdfloat scale)
 */
static PyObject *Dtool_CurveFitter_compute_tangents_84(PyObject *self, PyObject *arg) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.compute_tangents")) {
    return NULL;
  }
  // 1-void CurveFitter::compute_tangents(PN_stdfloat scale)
  if (PyNumber_Check(arg)) {
    (*local_this).compute_tangents((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compute_tangents(const CurveFitter self, float scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_compute_tangents_84_comment =
  "C++ Interface:\n"
  "compute_tangents(const CurveFitter self, float scale)\n"
  "\n"
  "/**\n"
  " * Once a set of points has been built, and prior to calling MakeHermite() or\n"
  " * MakeNurbs(), ComputeTangents() must be called to set up the tangents\n"
  " * correctly (unless the tangents were defined as the points were added).\n"
  " */";
#else
static const char *Dtool_CurveFitter_compute_tangents_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< ParametricCurveCollection > CurveFitter::make_hermite(void) const
 */
static PyObject *Dtool_CurveFitter_make_hermite_85(PyObject *self, PyObject *) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CurveFitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-PointerTo< ParametricCurveCollection > CurveFitter::make_hermite(void) const
  PointerTo< ParametricCurveCollection > return_value = (*(const CurveFitter*)local_this).make_hermite();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  ParametricCurveCollection *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_ParametricCurveCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_make_hermite_85_comment =
  "C++ Interface:\n"
  "make_hermite(CurveFitter self)\n"
  "\n"
  "/**\n"
  " * Converts the current set of data points into a Hermite curve.\n"
  " */";
#else
static const char *Dtool_CurveFitter_make_hermite_85_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< ParametricCurveCollection > CurveFitter::make_nurbs(void) const
 */
static PyObject *Dtool_CurveFitter_make_nurbs_86(PyObject *self, PyObject *) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CurveFitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-PointerTo< ParametricCurveCollection > CurveFitter::make_nurbs(void) const
  PointerTo< ParametricCurveCollection > return_value = (*(const CurveFitter*)local_this).make_nurbs();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  ParametricCurveCollection *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_ParametricCurveCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_make_nurbs_86_comment =
  "C++ Interface:\n"
  "make_nurbs(CurveFitter self)\n"
  "\n"
  "/**\n"
  " * Converts the current set of data points into a NURBS curve.  This gives a\n"
  " * smoother curve than produced by MakeHermite().\n"
  " */";
#else
static const char *Dtool_CurveFitter_make_nurbs_86_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::output(ostream &out) const
 */
static PyObject *Dtool_CurveFitter_output_87(PyObject *self, PyObject *arg) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CurveFitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-void CurveFitter::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "CurveFitter.output", false, true);
  if (arg_this != NULL) {
    (*(const CurveFitter*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CurveFitter self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_output_87_comment =
  "C++ Interface:\n"
  "output(CurveFitter self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CurveFitter_output_87_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::write(ostream &out) const
 */
static PyObject *Dtool_CurveFitter_write_88(PyObject *self, PyObject *arg) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CurveFitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-void CurveFitter::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "CurveFitter.write", false, true);
  if (arg_this != NULL) {
    (*(const CurveFitter*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(CurveFitter self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_write_88_comment =
  "C++ Interface:\n"
  "write(CurveFitter self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CurveFitter_write_88_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CurveFitter::get_class_type(void)
 */
static PyObject *Dtool_CurveFitter_get_class_type_89(PyObject *, PyObject *) {
  // 1-static TypeHandle CurveFitter::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CurveFitter::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_get_class_type_89_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CurveFitter_get_class_type_89_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CurveFitter::CurveFitter(void)
 * inline CurveFitter::CurveFitter(CurveFitter const &) = default
 */
static int Dtool_Init_CurveFitter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-CurveFitter::CurveFitter(void)
      CurveFitter *return_value = new CurveFitter();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CurveFitter, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline CurveFitter::CurveFitter(CurveFitter const &) = default
      CurveFitter const *arg_this = (CurveFitter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CurveFitter, 0, "CurveFitter.CurveFitter", true, true);
      if (arg_this != NULL) {
        CurveFitter *return_value = new CurveFitter(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CurveFitter, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CurveFitter() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CurveFitter()\n"
      "CurveFitter(const CurveFitter param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CurveFitter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CurveFitter) {
    printf("CurveFitter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CurveFitter *local_this = (CurveFitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CurveFitter) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CurveFitter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CurveFitter) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PiecewiseCurve
 */
/**
 * Python function wrapper for:
 * static TypeHandle PiecewiseCurve::get_class_type(void)
 */
static PyObject *Dtool_PiecewiseCurve_get_class_type_92(PyObject *, PyObject *) {
  // 1-static TypeHandle PiecewiseCurve::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PiecewiseCurve::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PiecewiseCurve_get_class_type_92_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PiecewiseCurve_get_class_type_92_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NurbsCurve *PiecewiseCurve::downcast_to_NurbsCurve(void)
 */
static PyObject *Dtool_PiecewiseCurve_downcast_to_NurbsCurve_138(PyObject *self, PyObject *) {
  PiecewiseCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PiecewiseCurve, (void **)&local_this, "PiecewiseCurve.downcast_to_NurbsCurve")) {
    return NULL;
  }
  // 1-NurbsCurve *PiecewiseCurve::downcast_to_NurbsCurve(void)
  NurbsCurve *return_value = (NurbsCurve *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_NurbsCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PiecewiseCurve_downcast_to_NurbsCurve_138_comment =
  "C++ Interface:\n"
  "downcast_to_NurbsCurve(const PiecewiseCurve self)\n"
  "\n"
  "downcast from PiecewiseCurve to NurbsCurve";
#else
static const char *Dtool_PiecewiseCurve_downcast_to_NurbsCurve_138_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PiecewiseCurve::PiecewiseCurve(void)
 */
static int Dtool_Init_PiecewiseCurve(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PiecewiseCurve() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-PiecewiseCurve::PiecewiseCurve(void)
  PiecewiseCurve *return_value = new PiecewiseCurve();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PiecewiseCurve, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PiecewiseCurve()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PiecewiseCurve(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PiecewiseCurve) {
    printf("PiecewiseCurve ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PiecewiseCurve *local_this = (PiecewiseCurve *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PiecewiseCurve) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_ParametricCurve) {
    return (ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PiecewiseCurve(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PiecewiseCurve) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PiecewiseCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (PiecewiseCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_ParametricCurve) {
    ParametricCurve* other_this = (ParametricCurve*)from_this;
    return (PiecewiseCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PiecewiseCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PiecewiseCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PiecewiseCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PiecewiseCurve*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class HermiteCurve
 */
/**
 * Python function wrapper for:
 * int HermiteCurve::get_num_cvs(void) const
 */
static PyObject *Dtool_HermiteCurve_get_num_cvs_95(PyObject *self, PyObject *) {
  HermiteCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HermiteCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-int HermiteCurve::get_num_cvs(void) const
  int return_value = (*(const HermiteCurve*)local_this).get_num_cvs();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_get_num_cvs_95_comment =
  "C++ Interface:\n"
  "get_num_cvs(HermiteCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the number of CV's in the curve.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_get_num_cvs_95_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int HermiteCurve::insert_cv(PN_stdfloat t)
 */
static PyObject *Dtool_HermiteCurve_insert_cv_96(PyObject *self, PyObject *arg) {
  HermiteCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.insert_cv")) {
    return NULL;
  }
  // 1-int HermiteCurve::insert_cv(PN_stdfloat t)
  if (PyNumber_Check(arg)) {
    int return_value = (*local_this).insert_cv((PN_stdfloat)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "insert_cv(const HermiteCurve self, float t)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_insert_cv_96_comment =
  "C++ Interface:\n"
  "insert_cv(const HermiteCurve self, float t)\n"
  "\n"
  "/**\n"
  " * Inserts a new CV at the given parametric point along the curve.  If this\n"
  " * parametric point is already on the curve, the CV is assigned an index\n"
  " * between its two neighbors and the indices of all following CV's are\n"
  " * incremented by 1; its in and out tangents are chosen to keep the curve\n"
  " * consistent.  If the new parametric point is beyond the end of the existing\n"
  " * curve, the curve is extended to meet it and the new CV's position, in\n"
  " * tangent, and out tangent are set to zero.\n"
  " *\n"
  " * The index number of the new CV is returned.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_insert_cv_96_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int HermiteCurve::append_cv(int type, LVecBase3 const &v)
 * int HermiteCurve::append_cv(int type, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_HermiteCurve_append_cv_97(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.append_cv")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline int HermiteCurve::append_cv(int type, LVecBase3 const &v)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"type", "v", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:append_cv", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "HermiteCurve.append_cv", "LVecBase3f");
        }
        int return_value = (*local_this).append_cv((int)param1, *param2_this);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 4:
    {
      // 1-int HermiteCurve::append_cv(int type, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      int param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"type", "x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ifff:append_cv", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        int return_value = (*local_this).append_cv((int)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "append_cv() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_cv(const HermiteCurve self, int type, const LVecBase3f v)\n"
      "append_cv(const HermiteCurve self, int type, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_append_cv_97_comment =
  "C++ Interface:\n"
  "append_cv(const HermiteCurve self, int type, const LVecBase3f v)\n"
  "append_cv(const HermiteCurve self, int type, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Adds a new CV to the end of the curve.  The new CV is given initial in/out\n"
  " * tangents of 0.  The return value is the index of the new CV.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_append_cv_97_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HermiteCurve::remove_cv(int n)
 */
static PyObject *Dtool_HermiteCurve_remove_cv_98(PyObject *self, PyObject *arg) {
  HermiteCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.remove_cv")) {
    return NULL;
  }
  // 1-bool HermiteCurve::remove_cv(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*local_this).remove_cv((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_cv(const HermiteCurve self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_remove_cv_98_comment =
  "C++ Interface:\n"
  "remove_cv(const HermiteCurve self, int n)\n"
  "\n"
  "/**\n"
  " * Removes the given CV from the curve.  Returns true if the CV existed, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_remove_cv_98_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HermiteCurve::remove_all_cvs(void)
 */
static PyObject *Dtool_HermiteCurve_remove_all_cvs_99(PyObject *self, PyObject *) {
  HermiteCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.remove_all_cvs")) {
    return NULL;
  }
  // 1-void HermiteCurve::remove_all_cvs(void)
  (*local_this).remove_all_cvs();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_remove_all_cvs_99_comment =
  "C++ Interface:\n"
  "remove_all_cvs(const HermiteCurve self)\n"
  "\n"
  "/**\n"
  " * Removes all CV's from the curve.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_remove_all_cvs_99_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HermiteCurve::set_cv_type(int n, int type)
 */
static PyObject *Dtool_HermiteCurve_set_cv_type_100(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.set_cv_type")) {
    return NULL;
  }
  // 1-bool HermiteCurve::set_cv_type(int n, int type)
  int param1;
  int param2;
  static const char *keyword_list[] = {"n", "type", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_cv_type", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*local_this).set_cv_type((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv_type(const HermiteCurve self, int n, int type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_set_cv_type_100_comment =
  "C++ Interface:\n"
  "set_cv_type(const HermiteCurve self, int n, int type)\n"
  "\n"
  "/**\n"
  " * Changes the given CV's continuity type.  Legal values are HC_CUT, HC_FREE,\n"
  " * HC_G1, or HC_SMOOTH.\n"
  " *\n"
  " * Other than HC_CUT, these have no effect on the actual curve; it remains up\n"
  " * to user software to impose the constraints these imply.\n"
  " *\n"
  " * HC_CUT implies a disconnection of the curve; HC_FREE imposes no constraints\n"
  " * on the tangents; HC_G1 forces the tangents to be collinear, and HC_SMOOTH\n"
  " * forces the tangents to be identical.  Setting type type to HC_G1 or\n"
  " * HC_SMOOTH may adjust the out tangent to match the in tangent.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_set_cv_type_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HermiteCurve::set_cv_point(int n, LVecBase3 const &v)
 * bool HermiteCurve::set_cv_point(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_HermiteCurve_set_cv_point_101(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.set_cv_point")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline bool HermiteCurve::set_cv_point(int n, LVecBase3 const &v)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"n", "v", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_cv_point", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "HermiteCurve.set_cv_point", "LVecBase3f");
        }
        bool return_value = (*local_this).set_cv_point((int)param1, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 4:
    {
      // 1-bool HermiteCurve::set_cv_point(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      int param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"n", "x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ifff:set_cv_point", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        bool return_value = (*local_this).set_cv_point((int)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_cv_point() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv_point(const HermiteCurve self, int n, const LVecBase3f v)\n"
      "set_cv_point(const HermiteCurve self, int n, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_set_cv_point_101_comment =
  "C++ Interface:\n"
  "set_cv_point(const HermiteCurve self, int n, const LVecBase3f v)\n"
  "set_cv_point(const HermiteCurve self, int n, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Changes the given CV's position.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_set_cv_point_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HermiteCurve::set_cv_in(int n, LVecBase3 const &v)
 * bool HermiteCurve::set_cv_in(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_HermiteCurve_set_cv_in_102(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.set_cv_in")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline bool HermiteCurve::set_cv_in(int n, LVecBase3 const &v)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"n", "v", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_cv_in", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "HermiteCurve.set_cv_in", "LVecBase3f");
        }
        bool return_value = (*local_this).set_cv_in((int)param1, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 4:
    {
      // 1-bool HermiteCurve::set_cv_in(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      int param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"n", "x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ifff:set_cv_in", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        bool return_value = (*local_this).set_cv_in((int)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_cv_in() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv_in(const HermiteCurve self, int n, const LVecBase3f v)\n"
      "set_cv_in(const HermiteCurve self, int n, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_set_cv_in_102_comment =
  "C++ Interface:\n"
  "set_cv_in(const HermiteCurve self, int n, const LVecBase3f v)\n"
  "set_cv_in(const HermiteCurve self, int n, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Changes the given CV's in tangent.  Depending on the continuity type, this\n"
  " * may also adjust the out tangent.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_set_cv_in_102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HermiteCurve::set_cv_out(int n, LVecBase3 const &v)
 * bool HermiteCurve::set_cv_out(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_HermiteCurve_set_cv_out_103(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.set_cv_out")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline bool HermiteCurve::set_cv_out(int n, LVecBase3 const &v)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"n", "v", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_cv_out", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "HermiteCurve.set_cv_out", "LVecBase3f");
        }
        bool return_value = (*local_this).set_cv_out((int)param1, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 4:
    {
      // 1-bool HermiteCurve::set_cv_out(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      int param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"n", "x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ifff:set_cv_out", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        bool return_value = (*local_this).set_cv_out((int)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_cv_out() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv_out(const HermiteCurve self, int n, const LVecBase3f v)\n"
      "set_cv_out(const HermiteCurve self, int n, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_set_cv_out_103_comment =
  "C++ Interface:\n"
  "set_cv_out(const HermiteCurve self, int n, const LVecBase3f v)\n"
  "set_cv_out(const HermiteCurve self, int n, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Changes the given CV's out tangent.  Depending on the continuity type, this\n"
  " * may also adjust the in tangent.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_set_cv_out_103_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HermiteCurve::set_cv_tstart(int n, PN_stdfloat tstart)
 */
static PyObject *Dtool_HermiteCurve_set_cv_tstart_104(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.set_cv_tstart")) {
    return NULL;
  }
  // 1-bool HermiteCurve::set_cv_tstart(int n, PN_stdfloat tstart)
  int param1;
  float param2;
  static const char *keyword_list[] = {"n", "tstart", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_cv_tstart", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*local_this).set_cv_tstart((int)param1, (PN_stdfloat)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv_tstart(const HermiteCurve self, int n, float tstart)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_set_cv_tstart_104_comment =
  "C++ Interface:\n"
  "set_cv_tstart(const HermiteCurve self, int n, float tstart)\n"
  "\n"
  "/**\n"
  " * Changes the given CV's parametric starting time.  This may affect the shape\n"
  " * of the curve.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_set_cv_tstart_104_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HermiteCurve::set_cv_name(int n, char const *name)
 */
static PyObject *Dtool_HermiteCurve_set_cv_name_105(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.set_cv_name")) {
    return NULL;
  }
  // 1-bool HermiteCurve::set_cv_name(int n, char const *name)
  int param1;
  char const *param2;
  static const char *keyword_list[] = {"n", "name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iz:set_cv_name", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*local_this).set_cv_name((int)param1, (char const *)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv_name(const HermiteCurve self, int n, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_set_cv_name_105_comment =
  "C++ Interface:\n"
  "set_cv_name(const HermiteCurve self, int n, str name)\n"
  "\n"
  "/**\n"
  " * Changes the name associated with a particular CV.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_set_cv_name_105_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int HermiteCurve::get_cv_type(int n) const
 */
static PyObject *Dtool_HermiteCurve_get_cv_type_106(PyObject *self, PyObject *arg) {
  HermiteCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HermiteCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-int HermiteCurve::get_cv_type(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const HermiteCurve*)local_this).get_cv_type((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv_type(HermiteCurve self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_get_cv_type_106_comment =
  "C++ Interface:\n"
  "get_cv_type(HermiteCurve self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the given CV's continuity type, HC_CUT, HC_FREE, HC_G1, or\n"
  " * HC_SMOOTH, or 0 if there is no such CV.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_get_cv_type_106_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVecBase3 const &HermiteCurve::get_cv_point(int n) const
 * void HermiteCurve::get_cv_point(int n, LVecBase3 &v) const
 */
static PyObject *Dtool_HermiteCurve_get_cv_point_107(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HermiteCurve, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-LVecBase3 const &HermiteCurve::get_cv_point(int n) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        LVecBase3 const *return_value = &((*(const HermiteCurve*)local_this).get_cv_point((int)arg_val));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
      }
    }
    break;
  case 2:
    {
      // 1-void HermiteCurve::get_cv_point(int n, LVecBase3 &v) const
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"n", "v", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_cv_point", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "HermiteCurve.get_cv_point", "LVecBase3f");
        }
        (*(const HermiteCurve*)local_this).get_cv_point((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_cv_point() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv_point(HermiteCurve self, int n)\n"
      "get_cv_point(HermiteCurve self, int n, LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_get_cv_point_107_comment =
  "C++ Interface:\n"
  "get_cv_point(HermiteCurve self, int n)\n"
  "get_cv_point(HermiteCurve self, int n, LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * Returns the position of the given CV.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_get_cv_point_107_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVecBase3 const &HermiteCurve::get_cv_in(int n) const
 * void HermiteCurve::get_cv_in(int n, LVecBase3 &v) const
 */
static PyObject *Dtool_HermiteCurve_get_cv_in_108(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HermiteCurve, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-LVecBase3 const &HermiteCurve::get_cv_in(int n) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        LVecBase3 const *return_value = &((*(const HermiteCurve*)local_this).get_cv_in((int)arg_val));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
      }
    }
    break;
  case 2:
    {
      // 1-void HermiteCurve::get_cv_in(int n, LVecBase3 &v) const
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"n", "v", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_cv_in", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "HermiteCurve.get_cv_in", "LVecBase3f");
        }
        (*(const HermiteCurve*)local_this).get_cv_in((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_cv_in() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv_in(HermiteCurve self, int n)\n"
      "get_cv_in(HermiteCurve self, int n, LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_get_cv_in_108_comment =
  "C++ Interface:\n"
  "get_cv_in(HermiteCurve self, int n)\n"
  "get_cv_in(HermiteCurve self, int n, LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * Returns the in tangent of the given CV.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_get_cv_in_108_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVecBase3 const &HermiteCurve::get_cv_out(int n) const
 * void HermiteCurve::get_cv_out(int n, LVecBase3 &v) const
 */
static PyObject *Dtool_HermiteCurve_get_cv_out_109(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HermiteCurve, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-LVecBase3 const &HermiteCurve::get_cv_out(int n) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        LVecBase3 const *return_value = &((*(const HermiteCurve*)local_this).get_cv_out((int)arg_val));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
      }
    }
    break;
  case 2:
    {
      // 1-void HermiteCurve::get_cv_out(int n, LVecBase3 &v) const
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"n", "v", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_cv_out", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "HermiteCurve.get_cv_out", "LVecBase3f");
        }
        (*(const HermiteCurve*)local_this).get_cv_out((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_cv_out() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv_out(HermiteCurve self, int n)\n"
      "get_cv_out(HermiteCurve self, int n, LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_get_cv_out_109_comment =
  "C++ Interface:\n"
  "get_cv_out(HermiteCurve self, int n)\n"
  "get_cv_out(HermiteCurve self, int n, LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * Returns the out tangent of the given CV.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_get_cv_out_109_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat HermiteCurve::get_cv_tstart(int n) const
 */
static PyObject *Dtool_HermiteCurve_get_cv_tstart_110(PyObject *self, PyObject *arg) {
  HermiteCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HermiteCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat HermiteCurve::get_cv_tstart(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = (*(const HermiteCurve*)local_this).get_cv_tstart((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv_tstart(HermiteCurve self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_get_cv_tstart_110_comment =
  "C++ Interface:\n"
  "get_cv_tstart(HermiteCurve self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the starting point in parametric space of the given CV.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_get_cv_tstart_110_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string HermiteCurve::get_cv_name(int n) const
 */
static PyObject *Dtool_HermiteCurve_get_cv_name_111(PyObject *self, PyObject *arg) {
  HermiteCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HermiteCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string HermiteCurve::get_cv_name(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (*(const HermiteCurve*)local_this).get_cv_name((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv_name(HermiteCurve self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_get_cv_name_111_comment =
  "C++ Interface:\n"
  "get_cv_name(HermiteCurve self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the name of the given CV, or NULL.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_get_cv_name_111_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HermiteCurve::write_cv(ostream &out, int n) const
 */
static PyObject *Dtool_HermiteCurve_write_cv_112(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HermiteCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-void HermiteCurve::write_cv(ostream &out, int n) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "n", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_cv", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "HermiteCurve.write_cv", false, true);
    if (param1_this != NULL) {
      (*(const HermiteCurve*)local_this).write_cv(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_cv(HermiteCurve self, ostream out, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_write_cv_112_comment =
  "C++ Interface:\n"
  "write_cv(HermiteCurve self, ostream out, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HermiteCurve_write_cv_112_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle HermiteCurve::get_class_type(void)
 */
static PyObject *Dtool_HermiteCurve_get_class_type_113(PyObject *, PyObject *) {
  // 1-static TypeHandle HermiteCurve::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(HermiteCurve::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_get_class_type_113_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_HermiteCurve_get_class_type_113_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * HermiteCurve::HermiteCurve(void)
 * HermiteCurve::HermiteCurve(ParametricCurve const &pc)
 */
static int Dtool_Init_HermiteCurve(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-HermiteCurve::HermiteCurve(void)
      HermiteCurve *return_value = new HermiteCurve();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HermiteCurve, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pc");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'pc' (pos 1) not found");
        return -1;
      }
      // 1-HermiteCurve::HermiteCurve(ParametricCurve const &pc)
      ParametricCurve const *arg_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ParametricCurve, 0, "HermiteCurve.HermiteCurve", true, true);
      if (arg_this != NULL) {
        HermiteCurve *return_value = new HermiteCurve(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HermiteCurve, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "HermiteCurve() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "HermiteCurve()\n"
      "HermiteCurve(const ParametricCurve pc)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_HermiteCurve(PyObject *args, CPT(HermiteCurve) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_HermiteCurve, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-HermiteCurve::HermiteCurve(ParametricCurve const &pc)
    ParametricCurve const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_ParametricCurve, (void **)&arg_this);
    if (arg_this != NULL) {
      HermiteCurve *return_value = new HermiteCurve(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_HermiteCurve(PyObject *args, PT(HermiteCurve) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_HermiteCurve, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-HermiteCurve::HermiteCurve(ParametricCurve const &pc)
    ParametricCurve const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_ParametricCurve, (void **)&arg_this);
    if (arg_this != NULL) {
      HermiteCurve *return_value = new HermiteCurve(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_HermiteCurve(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_HermiteCurve) {
    printf("HermiteCurve ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  HermiteCurve *local_this = (HermiteCurve *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_HermiteCurve) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_ParametricCurve) {
    return (ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_PiecewiseCurve) {
    return (PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_HermiteCurve(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_HermiteCurve) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (HermiteCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (HermiteCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_ParametricCurve) {
    ParametricCurve* other_this = (ParametricCurve*)from_this;
    return (HermiteCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_PiecewiseCurve) {
    PiecewiseCurve* other_this = (PiecewiseCurve*)from_this;
    return (HermiteCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (HermiteCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (HermiteCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (HermiteCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (HermiteCurve*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class NurbsCurveInterface
 */
/**
 * Python function wrapper for:
 * virtual void NurbsCurveInterface::set_order(int order) = 0
 */
static PyObject *Dtool_NurbsCurveInterface_set_order_116(PyObject *self, PyObject *arg) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveInterface, (void **)&local_this, "NurbsCurveInterface.set_order")) {
    return NULL;
  }
  // 1-virtual void NurbsCurveInterface::set_order(int order) = 0
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_order((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_order(const NurbsCurveInterface self, int order)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_set_order_116_comment =
  "C++ Interface:\n"
  "set_order(const NurbsCurveInterface self, int order)\n";
#else
static const char *Dtool_NurbsCurveInterface_set_order_116_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual int NurbsCurveInterface::get_order(void) const = 0
 */
static PyObject *Dtool_NurbsCurveInterface_get_order_117(PyObject *self, PyObject *) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual int NurbsCurveInterface::get_order(void) const = 0
  int return_value = (*(const NurbsCurveInterface*)local_this).get_order();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_get_order_117_comment =
  "C++ Interface:\n"
  "get_order(NurbsCurveInterface self)\n";
#else
static const char *Dtool_NurbsCurveInterface_get_order_117_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual int NurbsCurveInterface::get_num_cvs(void) const = 0
 */
static PyObject *Dtool_NurbsCurveInterface_get_num_cvs_118(PyObject *self, PyObject *) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual int NurbsCurveInterface::get_num_cvs(void) const = 0
  int return_value = (*(const NurbsCurveInterface*)local_this).get_num_cvs();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_get_num_cvs_118_comment =
  "C++ Interface:\n"
  "get_num_cvs(NurbsCurveInterface self)\n";
#else
static const char *Dtool_NurbsCurveInterface_get_num_cvs_118_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual int NurbsCurveInterface::get_num_knots(void) const = 0
 */
static PyObject *Dtool_NurbsCurveInterface_get_num_knots_119(PyObject *self, PyObject *) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual int NurbsCurveInterface::get_num_knots(void) const = 0
  int return_value = (*(const NurbsCurveInterface*)local_this).get_num_knots();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_get_num_knots_119_comment =
  "C++ Interface:\n"
  "get_num_knots(NurbsCurveInterface self)\n";
#else
static const char *Dtool_NurbsCurveInterface_get_num_knots_119_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool NurbsCurveInterface::insert_cv(PN_stdfloat t) = 0
 */
static PyObject *Dtool_NurbsCurveInterface_insert_cv_120(PyObject *self, PyObject *arg) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveInterface, (void **)&local_this, "NurbsCurveInterface.insert_cv")) {
    return NULL;
  }
  // 1-virtual bool NurbsCurveInterface::insert_cv(PN_stdfloat t) = 0
  if (PyNumber_Check(arg)) {
    bool return_value = (*local_this).insert_cv((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "insert_cv(const NurbsCurveInterface self, float t)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_insert_cv_120_comment =
  "C++ Interface:\n"
  "insert_cv(const NurbsCurveInterface self, float t)\n";
#else
static const char *Dtool_NurbsCurveInterface_insert_cv_120_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsCurveInterface::append_cv(LVecBase3 const &v)
 * inline int NurbsCurveInterface::append_cv(LVecBase4 const &v)
 * inline int NurbsCurveInterface::append_cv(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_NurbsCurveInterface_append_cv_121(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveInterface, (void **)&local_this, "NurbsCurveInterface.append_cv")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "v");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'v' (pos 1) not found");
      }
      {
        // -2 inline int NurbsCurveInterface::append_cv(LVecBase3 const &v)
        LVecBase3 const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
        if (arg_this != NULL) {
          int return_value = (*local_this).append_cv(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline int NurbsCurveInterface::append_cv(LVecBase4 const &v)
        LVecBase4 const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
        if (arg_this != NULL) {
          int return_value = (*local_this).append_cv(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline int NurbsCurveInterface::append_cv(LVecBase3 const &v)
        LVecBase3f arg_local;
        LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if ((arg_this != NULL)) {
          int return_value = (*local_this).append_cv(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline int NurbsCurveInterface::append_cv(LVecBase4 const &v)
        LVecBase4f arg_local;
        LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if ((arg_this != NULL)) {
          int return_value = (*local_this).append_cv(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

    }
    break;
  case 3:
    {
      // 1-inline int NurbsCurveInterface::append_cv(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:append_cv", (char **)keyword_list, &param1, &param2, &param3)) {
        int return_value = (*local_this).append_cv((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "append_cv() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_cv(const NurbsCurveInterface self, const LVecBase3f v)\n"
      "append_cv(const NurbsCurveInterface self, const LVecBase4f v)\n"
      "append_cv(const NurbsCurveInterface self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_append_cv_121_comment =
  "C++ Interface:\n"
  "append_cv(const NurbsCurveInterface self, const LVecBase3f v)\n"
  "append_cv(const NurbsCurveInterface self, const LVecBase4f v)\n"
  "append_cv(const NurbsCurveInterface self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NurbsCurveInterface_append_cv_121_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool NurbsCurveInterface::remove_cv(int n) = 0
 */
static PyObject *Dtool_NurbsCurveInterface_remove_cv_122(PyObject *self, PyObject *arg) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveInterface, (void **)&local_this, "NurbsCurveInterface.remove_cv")) {
    return NULL;
  }
  // 1-virtual bool NurbsCurveInterface::remove_cv(int n) = 0
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*local_this).remove_cv((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_cv(const NurbsCurveInterface self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_remove_cv_122_comment =
  "C++ Interface:\n"
  "remove_cv(const NurbsCurveInterface self, int n)\n";
#else
static const char *Dtool_NurbsCurveInterface_remove_cv_122_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void NurbsCurveInterface::remove_all_cvs(void) = 0
 */
static PyObject *Dtool_NurbsCurveInterface_remove_all_cvs_123(PyObject *self, PyObject *) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveInterface, (void **)&local_this, "NurbsCurveInterface.remove_all_cvs")) {
    return NULL;
  }
  // 1-virtual void NurbsCurveInterface::remove_all_cvs(void) = 0
  (*local_this).remove_all_cvs();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_remove_all_cvs_123_comment =
  "C++ Interface:\n"
  "remove_all_cvs(const NurbsCurveInterface self)\n";
#else
static const char *Dtool_NurbsCurveInterface_remove_all_cvs_123_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool NurbsCurveInterface::set_cv_point(int n, LVecBase3 const &v)
 * inline bool NurbsCurveInterface::set_cv_point(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_NurbsCurveInterface_set_cv_point_124(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveInterface, (void **)&local_this, "NurbsCurveInterface.set_cv_point")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline bool NurbsCurveInterface::set_cv_point(int n, LVecBase3 const &v)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"n", "v", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_cv_point", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NurbsCurveInterface.set_cv_point", "LVecBase3f");
        }
        bool return_value = (*local_this).set_cv_point((int)param1, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 4:
    {
      // 1-inline bool NurbsCurveInterface::set_cv_point(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      int param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"n", "x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ifff:set_cv_point", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        bool return_value = (*local_this).set_cv_point((int)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_cv_point() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv_point(const NurbsCurveInterface self, int n, const LVecBase3f v)\n"
      "set_cv_point(const NurbsCurveInterface self, int n, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_set_cv_point_124_comment =
  "C++ Interface:\n"
  "set_cv_point(const NurbsCurveInterface self, int n, const LVecBase3f v)\n"
  "set_cv_point(const NurbsCurveInterface self, int n, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Repositions the indicated CV.  Returns true if successful, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Repositions the indicated CV.  Returns true if successful, false otherwise.\n"
  " */";
#else
static const char *Dtool_NurbsCurveInterface_set_cv_point_124_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3 NurbsCurveInterface::get_cv_point(int n) const
 */
static PyObject *Dtool_NurbsCurveInterface_get_cv_point_125(PyObject *self, PyObject *arg) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3 NurbsCurveInterface::get_cv_point(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3 *return_value = new LVecBase3((*(const NurbsCurveInterface*)local_this).get_cv_point((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv_point(NurbsCurveInterface self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_get_cv_point_125_comment =
  "C++ Interface:\n"
  "get_cv_point(NurbsCurveInterface self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the position of the indicated CV.\n"
  " */";
#else
static const char *Dtool_NurbsCurveInterface_get_cv_point_125_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool NurbsCurveInterface::set_cv_weight(int n, PN_stdfloat w)
 */
static PyObject *Dtool_NurbsCurveInterface_set_cv_weight_126(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveInterface, (void **)&local_this, "NurbsCurveInterface.set_cv_weight")) {
    return NULL;
  }
  // 1-bool NurbsCurveInterface::set_cv_weight(int n, PN_stdfloat w)
  int param1;
  float param2;
  static const char *keyword_list[] = {"n", "w", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_cv_weight", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*local_this).set_cv_weight((int)param1, (PN_stdfloat)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv_weight(const NurbsCurveInterface self, int n, float w)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_set_cv_weight_126_comment =
  "C++ Interface:\n"
  "set_cv_weight(const NurbsCurveInterface self, int n, float w)\n"
  "\n"
  "/**\n"
  " * Sets the weight of the indicated CV without affecting its position in 3-d\n"
  " * space.\n"
  " */";
#else
static const char *Dtool_NurbsCurveInterface_set_cv_weight_126_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsCurveInterface::get_cv_weight(int n) const
 */
static PyObject *Dtool_NurbsCurveInterface_get_cv_weight_127(PyObject *self, PyObject *arg) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat NurbsCurveInterface::get_cv_weight(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = (*(const NurbsCurveInterface*)local_this).get_cv_weight((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv_weight(NurbsCurveInterface self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_get_cv_weight_127_comment =
  "C++ Interface:\n"
  "get_cv_weight(NurbsCurveInterface self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the weight of the indicated CV.\n"
  " */";
#else
static const char *Dtool_NurbsCurveInterface_get_cv_weight_127_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool NurbsCurveInterface::set_cv(int n, LVecBase4 const &v) = 0
 */
static PyObject *Dtool_NurbsCurveInterface_set_cv_128(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveInterface, (void **)&local_this, "NurbsCurveInterface.set_cv")) {
    return NULL;
  }
  // 1-virtual bool NurbsCurveInterface::set_cv(int n, LVecBase4 const &v) = 0
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "v", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_cv", (char **)keyword_list, &param1, &param2)) {
    LVecBase4f param2_local;
    LVecBase4 const *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "NurbsCurveInterface.set_cv", "LVecBase4f");
    }
    bool return_value = (*local_this).set_cv((int)param1, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv(const NurbsCurveInterface self, int n, const LVecBase4f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_set_cv_128_comment =
  "C++ Interface:\n"
  "set_cv(const NurbsCurveInterface self, int n, const LVecBase4f v)\n";
#else
static const char *Dtool_NurbsCurveInterface_set_cv_128_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual LVecBase4 NurbsCurveInterface::get_cv(int n) const = 0
 */
static PyObject *Dtool_NurbsCurveInterface_get_cv_129(PyObject *self, PyObject *arg) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual LVecBase4 NurbsCurveInterface::get_cv(int n) const = 0
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase4 *return_value = new LVecBase4((*(const NurbsCurveInterface*)local_this).get_cv((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv(NurbsCurveInterface self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_get_cv_129_comment =
  "C++ Interface:\n"
  "get_cv(NurbsCurveInterface self, int n)\n";
#else
static const char *Dtool_NurbsCurveInterface_get_cv_129_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool NurbsCurveInterface::set_knot(int n, PN_stdfloat t) = 0
 */
static PyObject *Dtool_NurbsCurveInterface_set_knot_130(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveInterface, (void **)&local_this, "NurbsCurveInterface.set_knot")) {
    return NULL;
  }
  // 1-virtual bool NurbsCurveInterface::set_knot(int n, PN_stdfloat t) = 0
  int param1;
  float param2;
  static const char *keyword_list[] = {"n", "t", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_knot", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*local_this).set_knot((int)param1, (PN_stdfloat)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_knot(const NurbsCurveInterface self, int n, float t)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_set_knot_130_comment =
  "C++ Interface:\n"
  "set_knot(const NurbsCurveInterface self, int n, float t)\n";
#else
static const char *Dtool_NurbsCurveInterface_set_knot_130_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat NurbsCurveInterface::get_knot(int n) const = 0
 */
static PyObject *Dtool_NurbsCurveInterface_get_knot_131(PyObject *self, PyObject *arg) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual PN_stdfloat NurbsCurveInterface::get_knot(int n) const = 0
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = (*(const NurbsCurveInterface*)local_this).get_knot((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_knot(NurbsCurveInterface self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_get_knot_131_comment =
  "C++ Interface:\n"
  "get_knot(NurbsCurveInterface self, int n)\n";
#else
static const char *Dtool_NurbsCurveInterface_get_knot_131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveInterface::write_cv(ostream &out, int n) const
 */
static PyObject *Dtool_NurbsCurveInterface_write_cv_134(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-void NurbsCurveInterface::write_cv(ostream &out, int n) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "n", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_cv", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "NurbsCurveInterface.write_cv", false, true);
    if (param1_this != NULL) {
      (*(const NurbsCurveInterface*)local_this).write_cv(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_cv(NurbsCurveInterface self, ostream out, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_write_cv_134_comment =
  "C++ Interface:\n"
  "write_cv(NurbsCurveInterface self, ostream out, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NurbsCurveInterface_write_cv_134_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle NurbsCurveInterface::get_class_type(void)
 */
static PyObject *Dtool_NurbsCurveInterface_get_class_type_135(PyObject *, PyObject *) {
  // 1-static TypeHandle NurbsCurveInterface::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(NurbsCurveInterface::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_get_class_type_135_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_NurbsCurveInterface_get_class_type_135_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NurbsCurve *NurbsCurveInterface::downcast_to_NurbsCurve(void)
 */
static PyObject *Dtool_NurbsCurveInterface_downcast_to_NurbsCurve_140(PyObject *self, PyObject *) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveInterface, (void **)&local_this, "NurbsCurveInterface.downcast_to_NurbsCurve")) {
    return NULL;
  }
  // 1-NurbsCurve *NurbsCurveInterface::downcast_to_NurbsCurve(void)
  NurbsCurve *return_value = (NurbsCurve *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_NurbsCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_downcast_to_NurbsCurve_140_comment =
  "C++ Interface:\n"
  "downcast_to_NurbsCurve(const NurbsCurveInterface self)\n"
  "\n"
  "downcast from NurbsCurveInterface to NurbsCurve";
#else
static const char *Dtool_NurbsCurveInterface_downcast_to_NurbsCurve_140_comment = NULL;
#endif

static int Dtool_Init_NurbsCurveInterface(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NurbsCurveInterface_get_cvs(PyObject *self, PyObject *) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveInterface, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_cvs();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NurbsCurveInterface_get_cv_129(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NurbsCurveInterface_get_knots(PyObject *self, PyObject *) {
  NurbsCurveInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveInterface, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_knots();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NurbsCurveInterface_get_knot_131(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_NurbsCurveInterface(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_NurbsCurveInterface) {
    printf("NurbsCurveInterface ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  NurbsCurveInterface *local_this = (NurbsCurveInterface *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_NurbsCurveInterface) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_NurbsCurveInterface(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_NurbsCurveInterface) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class NurbsCurve
 */
/**
 * Python function wrapper for:
 * static TypeHandle NurbsCurve::get_class_type(void)
 */
static PyObject *Dtool_NurbsCurve_get_class_type_143(PyObject *, PyObject *) {
  // 1-static TypeHandle NurbsCurve::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(NurbsCurve::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurve_get_class_type_143_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_NurbsCurve_get_class_type_143_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PiecewiseCurve *NurbsCurve::upcast_to_PiecewiseCurve(void)
 */
static PyObject *Dtool_NurbsCurve_upcast_to_PiecewiseCurve_137(PyObject *self, PyObject *) {
  NurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurve, (void **)&local_this, "NurbsCurve.upcast_to_PiecewiseCurve")) {
    return NULL;
  }
  // 1-PiecewiseCurve *NurbsCurve::upcast_to_PiecewiseCurve(void)
  PiecewiseCurve *return_value = (PiecewiseCurve *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PiecewiseCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurve_upcast_to_PiecewiseCurve_137_comment =
  "C++ Interface:\n"
  "upcast_to_PiecewiseCurve(const NurbsCurve self)\n"
  "\n"
  "upcast from NurbsCurve to PiecewiseCurve";
#else
static const char *Dtool_NurbsCurve_upcast_to_PiecewiseCurve_137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NurbsCurveInterface *NurbsCurve::upcast_to_NurbsCurveInterface(void)
 */
static PyObject *Dtool_NurbsCurve_upcast_to_NurbsCurveInterface_139(PyObject *self, PyObject *) {
  NurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurve, (void **)&local_this, "NurbsCurve.upcast_to_NurbsCurveInterface")) {
    return NULL;
  }
  // 1-NurbsCurveInterface *NurbsCurve::upcast_to_NurbsCurveInterface(void)
  NurbsCurveInterface *return_value = (NurbsCurveInterface *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NurbsCurveInterface, false, false);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurve_upcast_to_NurbsCurveInterface_139_comment =
  "C++ Interface:\n"
  "upcast_to_NurbsCurveInterface(const NurbsCurve self)\n"
  "\n"
  "upcast from NurbsCurve to NurbsCurveInterface";
#else
static const char *Dtool_NurbsCurve_upcast_to_NurbsCurveInterface_139_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NurbsCurve::NurbsCurve(void)
 * NurbsCurve::NurbsCurve(ParametricCurve const &pc)
 */
static int Dtool_Init_NurbsCurve(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-NurbsCurve::NurbsCurve(void)
      NurbsCurve *return_value = new NurbsCurve();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NurbsCurve, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pc");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'pc' (pos 1) not found");
        return -1;
      }
      // 1-NurbsCurve::NurbsCurve(ParametricCurve const &pc)
      ParametricCurve const *arg_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ParametricCurve, 0, "NurbsCurve.NurbsCurve", true, true);
      if (arg_this != NULL) {
        NurbsCurve *return_value = new NurbsCurve(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NurbsCurve, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "NurbsCurve() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NurbsCurve()\n"
      "NurbsCurve(const ParametricCurve pc)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_NurbsCurve(PyObject *args, CPT(NurbsCurve) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_NurbsCurve, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-NurbsCurve::NurbsCurve(ParametricCurve const &pc)
    ParametricCurve const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_ParametricCurve, (void **)&arg_this);
    if (arg_this != NULL) {
      NurbsCurve *return_value = new NurbsCurve(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_NurbsCurve(PyObject *args, PT(NurbsCurve) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_NurbsCurve, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-NurbsCurve::NurbsCurve(ParametricCurve const &pc)
    ParametricCurve const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_ParametricCurve, (void **)&arg_this);
    if (arg_this != NULL) {
      NurbsCurve *return_value = new NurbsCurve(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_NurbsCurve(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_NurbsCurve) {
    printf("NurbsCurve ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  NurbsCurve *local_this = (NurbsCurve *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_NurbsCurve) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_NurbsCurveInterface) {
    return (NurbsCurveInterface *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_ParametricCurve) {
    return (ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_PiecewiseCurve) {
    return (PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_NurbsCurve(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_NurbsCurve) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (NurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_NurbsCurveInterface) {
    NurbsCurveInterface* other_this = (NurbsCurveInterface*)from_this;
    return (NurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (NurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_ParametricCurve) {
    ParametricCurve* other_this = (ParametricCurve*)from_this;
    return (NurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_PiecewiseCurve) {
    PiecewiseCurve* other_this = (PiecewiseCurve*)from_this;
    return (NurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (NurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (NurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (NurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (NurbsCurve*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class NurbsCurveResult
 */
/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsCurveResult::get_start_t(void) const
 */
static PyObject *Dtool_NurbsCurveResult_get_start_t_145(PyObject *self, PyObject *) {
  NurbsCurveResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat NurbsCurveResult::get_start_t(void) const
  PN_stdfloat return_value = (*(const NurbsCurveResult*)local_this).get_start_t();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_get_start_t_145_comment =
  "C++ Interface:\n"
  "get_start_t(NurbsCurveResult self)\n"
  "\n"
  "/**\n"
  " * Returns the first legal value of t on the curve.  Usually this is 0.0.\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_get_start_t_145_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsCurveResult::get_end_t(void) const
 */
static PyObject *Dtool_NurbsCurveResult_get_end_t_146(PyObject *self, PyObject *) {
  NurbsCurveResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat NurbsCurveResult::get_end_t(void) const
  PN_stdfloat return_value = (*(const NurbsCurveResult*)local_this).get_end_t();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_get_end_t_146_comment =
  "C++ Interface:\n"
  "get_end_t(NurbsCurveResult self)\n"
  "\n"
  "/**\n"
  " * Returns the last legal value of t on the curve.\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_get_end_t_146_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool NurbsCurveResult::eval_point(PN_stdfloat t, LVecBase3 &point)
 */
static PyObject *Dtool_NurbsCurveResult_eval_point_147(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveResult, (void **)&local_this, "NurbsCurveResult.eval_point")) {
    return NULL;
  }
  // 1-inline bool NurbsCurveResult::eval_point(PN_stdfloat t, LVecBase3 &point)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"t", "point", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:eval_point", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "NurbsCurveResult.eval_point", "LVecBase3f");
    }
    bool return_value = (*local_this).eval_point((PN_stdfloat)param1, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_point(const NurbsCurveResult self, float t, LVecBase3f point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_eval_point_147_comment =
  "C++ Interface:\n"
  "eval_point(const NurbsCurveResult self, float t, LVecBase3f point)\n"
  "\n"
  "/**\n"
  " * Computes the point on the curve corresponding to the indicated value in\n"
  " * parametric time.  Returns true if the t value is valid, false otherwise.\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_eval_point_147_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool NurbsCurveResult::eval_tangent(PN_stdfloat t, LVecBase3 &tangent)
 */
static PyObject *Dtool_NurbsCurveResult_eval_tangent_148(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveResult, (void **)&local_this, "NurbsCurveResult.eval_tangent")) {
    return NULL;
  }
  // 1-inline bool NurbsCurveResult::eval_tangent(PN_stdfloat t, LVecBase3 &tangent)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"t", "tangent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:eval_tangent", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "NurbsCurveResult.eval_tangent", "LVecBase3f");
    }
    bool return_value = (*local_this).eval_tangent((PN_stdfloat)param1, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_tangent(const NurbsCurveResult self, float t, LVecBase3f tangent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_eval_tangent_148_comment =
  "C++ Interface:\n"
  "eval_tangent(const NurbsCurveResult self, float t, LVecBase3f tangent)\n"
  "\n"
  "/**\n"
  " * Computes the tangent to the curve at the indicated point in parametric\n"
  " * time.  This tangent vector will not necessarily be normalized, and could be\n"
  " * zero.  See also eval_point().\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_eval_tangent_148_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsCurveResult::eval_extended_point(PN_stdfloat t, int d)
 */
static PyObject *Dtool_NurbsCurveResult_eval_extended_point_149(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveResult, (void **)&local_this, "NurbsCurveResult.eval_extended_point")) {
    return NULL;
  }
  // 1-inline PN_stdfloat NurbsCurveResult::eval_extended_point(PN_stdfloat t, int d)
  float param1;
  int param2;
  static const char *keyword_list[] = {"t", "d", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fi:eval_extended_point", (char **)keyword_list, &param1, &param2)) {
    PN_stdfloat return_value = (*local_this).eval_extended_point((PN_stdfloat)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_extended_point(const NurbsCurveResult self, float t, int d)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_eval_extended_point_149_comment =
  "C++ Interface:\n"
  "eval_extended_point(const NurbsCurveResult self, float t, int d)\n"
  "\n"
  "/**\n"
  " * Evaluates the curve in n-dimensional space according to the extended\n"
  " * vertices associated with the curve in the indicated dimension.\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_eval_extended_point_149_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool NurbsCurveResult::eval_extended_points(PN_stdfloat t, int d, PN_stdfloat result[], int num_values)
 */
static PyObject *Dtool_NurbsCurveResult_eval_extended_points_150(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveResult, (void **)&local_this, "NurbsCurveResult.eval_extended_points")) {
    return NULL;
  }
  // 1-inline bool NurbsCurveResult::eval_extended_points(PN_stdfloat t, int d, PN_stdfloat result[], int num_values)
  float param1;
  int param2;
  PyObject *param3;
  Py_buffer param3_view;
  int param4;
  static const char *keyword_list[] = {"t", "d", "result", "num_values", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fiOi:eval_extended_points", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    if (PyObject_GetBuffer(param3, &param3_view, PyBUF_FORMAT | PyBUF_WRITABLE) == 0 && param3_view.format[0] == 'f' && param3_view.format[1] == 0) {
      bool return_value = (*local_this).eval_extended_points((PN_stdfloat)param1, (int)param2, (float *)param3_view.buf, (int)param4);
      PyBuffer_Release(&param3_view);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_extended_points(const NurbsCurveResult self, float t, int d, buffer result, int num_values)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_eval_extended_points_150_comment =
  "C++ Interface:\n"
  "eval_extended_points(const NurbsCurveResult self, float t, int d, buffer result, int num_values)\n"
  "\n"
  "/**\n"
  " * Simultaneously performs eval_extended_point on a contiguous sequence of\n"
  " * dimensions.  The dimensions evaluated are d through (d + num_values - 1);\n"
  " * the results are filled into the num_values elements in the indicated result\n"
  " * array.\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_eval_extended_points_150_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsCurveResult::get_num_segments(void) const
 */
static PyObject *Dtool_NurbsCurveResult_get_num_segments_151(PyObject *self, PyObject *) {
  NurbsCurveResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int NurbsCurveResult::get_num_segments(void) const
  int return_value = (*(const NurbsCurveResult*)local_this).get_num_segments();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_get_num_segments_151_comment =
  "C++ Interface:\n"
  "get_num_segments(NurbsCurveResult self)\n"
  "\n"
  "/**\n"
  " * Returns the number of piecewise continuous segments within the curve.  This\n"
  " * number is usually not important unless you plan to call\n"
  " * eval_segment_point().\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_get_num_segments_151_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveResult::eval_segment_point(int segment, PN_stdfloat t, LVecBase3 &point) const
 */
static PyObject *Dtool_NurbsCurveResult_eval_segment_point_152(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-void NurbsCurveResult::eval_segment_point(int segment, PN_stdfloat t, LVecBase3 &point) const
  int param1;
  float param2;
  PyObject *param3;
  static const char *keyword_list[] = {"segment", "t", "point", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ifO:eval_segment_point", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3f param3_local;
    LVecBase3 *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "NurbsCurveResult.eval_segment_point", "LVecBase3f");
    }
    (*(const NurbsCurveResult*)local_this).eval_segment_point((int)param1, (PN_stdfloat)param2, *param3_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_segment_point(NurbsCurveResult self, int segment, float t, LVecBase3f point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_eval_segment_point_152_comment =
  "C++ Interface:\n"
  "eval_segment_point(NurbsCurveResult self, int segment, float t, LVecBase3f point)\n"
  "\n"
  "/**\n"
  " * Evaluates the point on the curve corresponding to the indicated value in\n"
  " * parametric time within the indicated curve segment.  t should be in the\n"
  " * range [0, 1].\n"
  " *\n"
  " * The curve is internally represented as a number of connected (or possibly\n"
  " * unconnected) piecewise continuous segments.  The exact number of segments\n"
  " * for a particular curve depends on the knot vector, and is returned by\n"
  " * get_num_segments().  Normally, eval_point() is used to evaluate a point\n"
  " * along the continuous curve, but when you care more about local continuity,\n"
  " * you can use eval_segment_point() to evaluate the points along each segment.\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_eval_segment_point_152_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveResult::eval_segment_tangent(int segment, PN_stdfloat t, LVecBase3 &tangent) const
 */
static PyObject *Dtool_NurbsCurveResult_eval_segment_tangent_153(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-void NurbsCurveResult::eval_segment_tangent(int segment, PN_stdfloat t, LVecBase3 &tangent) const
  int param1;
  float param2;
  PyObject *param3;
  static const char *keyword_list[] = {"segment", "t", "tangent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ifO:eval_segment_tangent", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3f param3_local;
    LVecBase3 *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "NurbsCurveResult.eval_segment_tangent", "LVecBase3f");
    }
    (*(const NurbsCurveResult*)local_this).eval_segment_tangent((int)param1, (PN_stdfloat)param2, *param3_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_segment_tangent(NurbsCurveResult self, int segment, float t, LVecBase3f tangent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_eval_segment_tangent_153_comment =
  "C++ Interface:\n"
  "eval_segment_tangent(NurbsCurveResult self, int segment, float t, LVecBase3f tangent)\n"
  "\n"
  "/**\n"
  " * As eval_segment_point, but computes the tangent to the curve at the\n"
  " * indicated point.  The tangent vector will not necessarily be normalized,\n"
  " * and could be zero, particularly at the endpoints.\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_eval_segment_tangent_153_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat NurbsCurveResult::eval_segment_extended_point(int segment, PN_stdfloat t, int d) const
 */
static PyObject *Dtool_NurbsCurveResult_eval_segment_extended_point_154(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat NurbsCurveResult::eval_segment_extended_point(int segment, PN_stdfloat t, int d) const
  int param1;
  float param2;
  int param3;
  static const char *keyword_list[] = {"segment", "t", "d", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ifi:eval_segment_extended_point", (char **)keyword_list, &param1, &param2, &param3)) {
    PN_stdfloat return_value = (*(const NurbsCurveResult*)local_this).eval_segment_extended_point((int)param1, (PN_stdfloat)param2, (int)param3);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_segment_extended_point(NurbsCurveResult self, int segment, float t, int d)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_eval_segment_extended_point_154_comment =
  "C++ Interface:\n"
  "eval_segment_extended_point(NurbsCurveResult self, int segment, float t, int d)\n"
  "\n"
  "/**\n"
  " * Evaluates the curve in n-dimensional space according to the extended\n"
  " * vertices associated with the curve in the indicated dimension.\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_eval_segment_extended_point_154_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveResult::eval_segment_extended_points(int segment, PN_stdfloat t, int d, PN_stdfloat result[], int num_values) const
 */
static PyObject *Dtool_NurbsCurveResult_eval_segment_extended_points_155(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-void NurbsCurveResult::eval_segment_extended_points(int segment, PN_stdfloat t, int d, PN_stdfloat result[], int num_values) const
  int param1;
  float param2;
  int param3;
  PyObject *param4;
  Py_buffer param4_view;
  int param5;
  static const char *keyword_list[] = {"segment", "t", "d", "result", "num_values", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ifiOi:eval_segment_extended_points", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    if (PyObject_GetBuffer(param4, &param4_view, PyBUF_FORMAT | PyBUF_WRITABLE) == 0 && param4_view.format[0] == 'f' && param4_view.format[1] == 0) {
      (*(const NurbsCurveResult*)local_this).eval_segment_extended_points((int)param1, (PN_stdfloat)param2, (int)param3, (float *)param4_view.buf, (int)param5);
      PyBuffer_Release(&param4_view);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_segment_extended_points(NurbsCurveResult self, int segment, float t, int d, buffer result, int num_values)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_eval_segment_extended_points_155_comment =
  "C++ Interface:\n"
  "eval_segment_extended_points(NurbsCurveResult self, int segment, float t, int d, buffer result, int num_values)\n"
  "\n"
  "/**\n"
  " * Simultaneously performs eval_extended_point on a contiguous sequence of\n"
  " * dimensions.  The dimensions evaluated are d through (d + num_values - 1);\n"
  " * the results are filled into the num_values elements in the indicated result\n"
  " * array.\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_eval_segment_extended_points_155_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsCurveResult::get_segment_t(int segment, PN_stdfloat t) const
 */
static PyObject *Dtool_NurbsCurveResult_get_segment_t_156(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat NurbsCurveResult::get_segment_t(int segment, PN_stdfloat t) const
  int param1;
  float param2;
  static const char *keyword_list[] = {"segment", "t", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:get_segment_t", (char **)keyword_list, &param1, &param2)) {
    PN_stdfloat return_value = (*(const NurbsCurveResult*)local_this).get_segment_t((int)param1, (PN_stdfloat)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_segment_t(NurbsCurveResult self, int segment, float t)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_get_segment_t_156_comment =
  "C++ Interface:\n"
  "get_segment_t(NurbsCurveResult self, int segment, float t)\n"
  "\n"
  "/**\n"
  " * Accepts a t value in the range [0, 1], and assumed to be relative to the\n"
  " * indicated segment (as in eval_segment_point()), and returns the\n"
  " * corresponding t value in the entire curve (as in eval_point()).\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_get_segment_t_156_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveResult::adaptive_sample(PN_stdfloat tolerance)
 */
static PyObject *Dtool_NurbsCurveResult_adaptive_sample_157(PyObject *self, PyObject *arg) {
  NurbsCurveResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveResult, (void **)&local_this, "NurbsCurveResult.adaptive_sample")) {
    return NULL;
  }
  // 1-void NurbsCurveResult::adaptive_sample(PN_stdfloat tolerance)
  if (PyNumber_Check(arg)) {
    (*local_this).adaptive_sample((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "adaptive_sample(const NurbsCurveResult self, float tolerance)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_adaptive_sample_157_comment =
  "C++ Interface:\n"
  "adaptive_sample(const NurbsCurveResult self, float tolerance)\n"
  "\n"
  "/**\n"
  " * Determines the set of subdivisions necessary to approximate the curve with\n"
  " * a set of linear segments, no point of which is farther than tolerance units\n"
  " * from the actual curve.\n"
  " *\n"
  " * After this call, you may walk through the resulting set of samples with\n"
  " * get_num_samples(), get_sample_t(), and get_sample_point().\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_adaptive_sample_157_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsCurveResult::get_num_samples(void) const
 */
static PyObject *Dtool_NurbsCurveResult_get_num_samples_158(PyObject *self, PyObject *) {
  NurbsCurveResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int NurbsCurveResult::get_num_samples(void) const
  int return_value = (*(const NurbsCurveResult*)local_this).get_num_samples();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_get_num_samples_158_comment =
  "C++ Interface:\n"
  "get_num_samples(NurbsCurveResult self)\n"
  "\n"
  "/**\n"
  " * Returns the number of sample points generated by the previous call to\n"
  " * adaptive_sample().\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_get_num_samples_158_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsCurveResult::get_sample_t(int n) const
 */
static PyObject *Dtool_NurbsCurveResult_get_sample_t_159(PyObject *self, PyObject *arg) {
  NurbsCurveResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat NurbsCurveResult::get_sample_t(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = (*(const NurbsCurveResult*)local_this).get_sample_t((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sample_t(NurbsCurveResult self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_get_sample_t_159_comment =
  "C++ Interface:\n"
  "get_sample_t(NurbsCurveResult self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the t value of the nth sample point generated by the previous call\n"
  " * to adaptive_sample().\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_get_sample_t_159_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &NurbsCurveResult::get_sample_point(int n) const
 */
static PyObject *Dtool_NurbsCurveResult_get_sample_point_160(PyObject *self, PyObject *arg) {
  NurbsCurveResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 const &NurbsCurveResult::get_sample_point(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3 const *return_value = &((*(const NurbsCurveResult*)local_this).get_sample_point((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sample_point(NurbsCurveResult self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_get_sample_point_160_comment =
  "C++ Interface:\n"
  "get_sample_point(NurbsCurveResult self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the point on the curve of the nth sample point generated by the\n"
  " * previous call to adaptive_sample().\n"
  " *\n"
  " * For tangents, or extended points, you should use get_sample_t() and pass it\n"
  " * into eval_tangent() or eval_extended_point().\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_get_sample_point_160_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NurbsCurveResult::NurbsCurveResult(NurbsCurveResult const &) = default
 */
static int Dtool_Init_NurbsCurveResult(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "NurbsCurveResult() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline NurbsCurveResult::NurbsCurveResult(NurbsCurveResult const &) = default
  NurbsCurveResult const *arg_this = (NurbsCurveResult *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NurbsCurveResult, 0, "NurbsCurveResult.NurbsCurveResult", true, true);
  if (arg_this != NULL) {
    NurbsCurveResult *return_value = new NurbsCurveResult(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NurbsCurveResult, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NurbsCurveResult(const NurbsCurveResult param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NurbsCurveResult_get_sample_ts(PyObject *self, PyObject *) {
  NurbsCurveResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveResult, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_samples();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NurbsCurveResult_get_sample_t_159(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NurbsCurveResult_get_sample_points(PyObject *self, PyObject *) {
  NurbsCurveResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveResult, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_samples();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NurbsCurveResult_get_sample_point_160(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_NurbsCurveResult(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_NurbsCurveResult) {
    printf("NurbsCurveResult ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  NurbsCurveResult *local_this = (NurbsCurveResult *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_NurbsCurveResult) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_NurbsCurveResult(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_NurbsCurveResult) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (NurbsCurveResult*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class NurbsCurveEvaluator
 */
/**
 * Python function wrapper for:
 * inline void NurbsCurveEvaluator::set_order(int order)
 */
static PyObject *Dtool_NurbsCurveEvaluator_set_order_166(PyObject *self, PyObject *arg) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveEvaluator, (void **)&local_this, "NurbsCurveEvaluator.set_order")) {
    return NULL;
  }
  // 1-inline void NurbsCurveEvaluator::set_order(int order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_order((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_order(const NurbsCurveEvaluator self, int order)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_set_order_166_comment =
  "C++ Interface:\n"
  "set_order(const NurbsCurveEvaluator self, int order)\n"
  "\n"
  "/**\n"
  " * Sets the order of the curve.  This resets the knot vector to the default\n"
  " * knot vector for the number of vertices.\n"
  " *\n"
  " * The order must be 1, 2, 3, or 4, and the value is one more than the degree\n"
  " * of the curve.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_set_order_166_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsCurveEvaluator::get_order(void) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_get_order_167(PyObject *self, PyObject *) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int NurbsCurveEvaluator::get_order(void) const
  int return_value = (*(const NurbsCurveEvaluator*)local_this).get_order();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_get_order_167_comment =
  "C++ Interface:\n"
  "get_order(NurbsCurveEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the order of the curve as set by a previous call to set_order().\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_get_order_167_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveEvaluator::reset(int num_vertices)
 */
static PyObject *Dtool_NurbsCurveEvaluator_reset_168(PyObject *self, PyObject *arg) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveEvaluator, (void **)&local_this, "NurbsCurveEvaluator.reset")) {
    return NULL;
  }
  // 1-void NurbsCurveEvaluator::reset(int num_vertices)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).reset((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reset(const NurbsCurveEvaluator self, int num_vertices)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_reset_168_comment =
  "C++ Interface:\n"
  "reset(const NurbsCurveEvaluator self, int num_vertices)\n"
  "\n"
  "/**\n"
  " * Resets all the vertices and knots to their default values, and sets the\n"
  " * curve up with the indicated number of vertices.  You must then call\n"
  " * set_vertex() repeatedly to fill in all of the vertex values appropriately.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_reset_168_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsCurveEvaluator::get_num_vertices(void) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_get_num_vertices_169(PyObject *self, PyObject *) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int NurbsCurveEvaluator::get_num_vertices(void) const
  int return_value = (*(const NurbsCurveEvaluator*)local_this).get_num_vertices();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_get_num_vertices_169_comment =
  "C++ Interface:\n"
  "get_num_vertices(NurbsCurveEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of control vertices in the curve.  This is the number\n"
  " * passed to the last call to reset().\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_get_num_vertices_169_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase3 const &vertex, PN_stdfloat weight = 1.0)
 * inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase4 const &vertex)
 */
static PyObject *Dtool_NurbsCurveEvaluator_set_vertex_170(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveEvaluator, (void **)&local_this, "NurbsCurveEvaluator.set_vertex")) {
    return NULL;
  }
  {
    // -2 inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase3 const &vertex, PN_stdfloat weight = 1.0)
    int param1;
    PyObject *param2;
    float param3 = 1.0;
    static const char *keyword_list[] = {"i", "vertex", "weight", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO|f:set_vertex", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3 const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_vertex((int)param1, *param2_this, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase4 const &vertex)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"i", "vertex", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_vertex", (char **)keyword_list, &param1, &param2)) {
      LVecBase4 const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase4f, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_vertex((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase3 const &vertex, PN_stdfloat weight = 1.0)
    int param1;
    PyObject *param2;
    float param3 = 1.0;
    static const char *keyword_list[] = {"i", "vertex", "weight", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO|f:set_vertex", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3f param2_local;
      LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
      if ((param2_this != NULL)) {
        (*local_this).set_vertex((int)param1, *param2_this, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase4 const &vertex)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"i", "vertex", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_vertex", (char **)keyword_list, &param1, &param2)) {
      LVecBase4f param2_local;
      LVecBase4 const *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
      if ((param2_this != NULL)) {
        (*local_this).set_vertex((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertex(const NurbsCurveEvaluator self, int i, const LVecBase3f vertex, float weight)\n"
      "set_vertex(const NurbsCurveEvaluator self, int i, const LVecBase4f vertex)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_set_vertex_170_comment =
  "C++ Interface:\n"
  "set_vertex(const NurbsCurveEvaluator self, int i, const LVecBase3f vertex, float weight)\n"
  "set_vertex(const NurbsCurveEvaluator self, int i, const LVecBase4f vertex)\n"
  "\n"
  "/**\n"
  " * Sets the nth control vertex of the curve, as a vertex in 4-d homogeneous\n"
  " * space.  In this form, the first three components of the vertex should\n"
  " * already have been scaled by the fourth component, which is the homogeneous\n"
  " * weight.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the nth control vertex of the curve.  This flavor sets the vertex as a\n"
  " * 3-d coordinate and a weight; the 3-d coordinate values are implicitly\n"
  " * scaled up by the weight factor.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_set_vertex_170_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 const &NurbsCurveEvaluator::get_vertex(int i) const
 * inline LVecBase4 NurbsCurveEvaluator::get_vertex(int i, NodePath const &rel_to) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_get_vertex_171(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveEvaluator, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "i");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'i' (pos 1) not found");
      }
      // 1-inline LVecBase4 const &NurbsCurveEvaluator::get_vertex(int i) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        LVecBase4 const *return_value = &((*(const NurbsCurveEvaluator*)local_this).get_vertex((int)arg_val));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
      }
    }
    break;
  case 2:
    {
      // 1-inline LVecBase4 NurbsCurveEvaluator::get_vertex(int i, NodePath const &rel_to) const
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"i", "rel_to", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_vertex", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "NurbsCurveEvaluator.get_vertex", true, true);
        if (param2_this != NULL) {
          LVecBase4 *return_value = new LVecBase4((*(const NurbsCurveEvaluator*)local_this).get_vertex((int)param1, *param2_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_vertex() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(NurbsCurveEvaluator self, int i)\n"
      "get_vertex(NurbsCurveEvaluator self, int i, const NodePath rel_to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_get_vertex_171_comment =
  "C++ Interface:\n"
  "get_vertex(NurbsCurveEvaluator self, int i)\n"
  "get_vertex(NurbsCurveEvaluator self, int i, const NodePath rel_to)\n"
  "\n"
  "/**\n"
  " * Returns the nth control vertex of the curve, relative to its indicated\n"
  " * coordinate space.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the nth control vertex of the curve, relative to the given\n"
  " * coordinate space.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_get_vertex_171_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void NurbsCurveEvaluator::set_vertex_space(int i, NodePath const &space)
 * inline void NurbsCurveEvaluator::set_vertex_space(int i, std::string const &space)
 */
static PyObject *Dtool_NurbsCurveEvaluator_set_vertex_space_173(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveEvaluator, (void **)&local_this, "NurbsCurveEvaluator.set_vertex_space")) {
    return NULL;
  }
  {
    // -2 inline void NurbsCurveEvaluator::set_vertex_space(int i, NodePath const &space)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"i", "space", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_vertex_space", (char **)keyword_list, &param1, &param2)) {
      NodePath const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_NodePath, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_vertex_space((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void NurbsCurveEvaluator::set_vertex_space(int i, std::string const &space)
    int param1;
    char *param2_str = NULL;
    Py_ssize_t param2_len;
    static const char *keyword_list[] = {"i", "space", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "is#:set_vertex_space", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
      (*local_this).set_vertex_space((int)param1, std::string(param2_str, param2_len));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: inline void NurbsCurveEvaluator::set_vertex_space(int i, NodePath const &space)
  // No coercion possible: inline void NurbsCurveEvaluator::set_vertex_space(int i, std::string const &space)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertex_space(const NurbsCurveEvaluator self, int i, const NodePath space)\n"
      "set_vertex_space(const NurbsCurveEvaluator self, int i, str space)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_set_vertex_space_173_comment =
  "C++ Interface:\n"
  "set_vertex_space(const NurbsCurveEvaluator self, int i, const NodePath space)\n"
  "set_vertex_space(const NurbsCurveEvaluator self, int i, str space)\n"
  "\n"
  "/**\n"
  " * Sets the coordinate space of the nth control vertex.  If this is not\n"
  " * specified, or is set to an empty NodePath, the nth control vertex is deemed\n"
  " * to be in the coordinate space passed to evaluate().\n"
  " *\n"
  " * This specifies the space as a fixed NodePath, which is always the same\n"
  " * NodePath.  Also see setting the space as a path string, which can specify a\n"
  " * different NodePath for different instances of the curve.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the coordinate space of the nth control vertex.  If this is not\n"
  " * specified, or is set to an empty string, the nth control vertex is deemed\n"
  " * to be in the coordinate space passed to evaluate().\n"
  " *\n"
  " * This specifies the space as a string, which describes the path to find the\n"
  " * node relative to the rel_to NodePath when the curve is evaluated.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_set_vertex_space_173_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePath NurbsCurveEvaluator::get_vertex_space(int i, NodePath const &rel_to) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_get_vertex_space_174(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-NodePath NurbsCurveEvaluator::get_vertex_space(int i, NodePath const &rel_to) const
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"i", "rel_to", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_vertex_space", (char **)keyword_list, &param1, &param2)) {
    NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "NurbsCurveEvaluator.get_vertex_space", true, true);
    if (param2_this != NULL) {
      NodePath *return_value = new NodePath((*(const NurbsCurveEvaluator*)local_this).get_vertex_space((int)param1, *param2_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex_space(NurbsCurveEvaluator self, int i, const NodePath rel_to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_get_vertex_space_174_comment =
  "C++ Interface:\n"
  "get_vertex_space(NurbsCurveEvaluator self, int i, const NodePath rel_to)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate space of the nth control vertex of the curve,\n"
  " * expressed as a NodePath.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_get_vertex_space_174_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void NurbsCurveEvaluator::set_extended_vertex(int i, int d, PN_stdfloat value)
 */
static PyObject *Dtool_NurbsCurveEvaluator_set_extended_vertex_175(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveEvaluator, (void **)&local_this, "NurbsCurveEvaluator.set_extended_vertex")) {
    return NULL;
  }
  // 1-inline void NurbsCurveEvaluator::set_extended_vertex(int i, int d, PN_stdfloat value)
  int param1;
  int param2;
  float param3;
  static const char *keyword_list[] = {"i", "d", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iif:set_extended_vertex", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_extended_vertex((int)param1, (int)param2, (PN_stdfloat)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_extended_vertex(const NurbsCurveEvaluator self, int i, int d, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_set_extended_vertex_175_comment =
  "C++ Interface:\n"
  "set_extended_vertex(const NurbsCurveEvaluator self, int i, int d, float value)\n"
  "\n"
  "/**\n"
  " * Sets an n-dimensional vertex value.  This allows definition of a NURBS\n"
  " * surface or curve in a sparse n-dimensional space, typically used for\n"
  " * associating additional properties (like color or joint membership) with\n"
  " * each vertex of a surface.\n"
  " *\n"
  " * The value d is an arbitrary integer value and specifies the dimension of\n"
  " * question for this particular vertex.  Any number of dimensions may be\n"
  " * specified, and they need not be consecutive.  If a value for a given\n"
  " * dimension is not specified, is it implicitly 0.0.\n"
  " *\n"
  " * The value is implicitly scaled by the homogenous weight value--that is, the\n"
  " * fourth component of the value passed to set_vertex().  This means the\n"
  " * ordinary vertex must be set first, before the extended vertices can be set.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_set_extended_vertex_175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsCurveEvaluator::get_extended_vertex(int i, int d) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_get_extended_vertex_176(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat NurbsCurveEvaluator::get_extended_vertex(int i, int d) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"i", "d", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_extended_vertex", (char **)keyword_list, &param1, &param2)) {
    PN_stdfloat return_value = (*(const NurbsCurveEvaluator*)local_this).get_extended_vertex((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_extended_vertex(NurbsCurveEvaluator self, int i, int d)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_get_extended_vertex_176_comment =
  "C++ Interface:\n"
  "get_extended_vertex(NurbsCurveEvaluator self, int i, int d)\n"
  "\n"
  "/**\n"
  " * Returns an n-dimensional vertex value.  See set_extended_vertex().  This\n"
  " * returns the value set for the indicated dimension, or 0.0 if nothing has\n"
  " * been set.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_get_extended_vertex_176_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveEvaluator::set_extended_vertices(int i, int d, PN_stdfloat const values[], int num_values)
 */
static PyObject *Dtool_NurbsCurveEvaluator_set_extended_vertices_177(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveEvaluator, (void **)&local_this, "NurbsCurveEvaluator.set_extended_vertices")) {
    return NULL;
  }
  // 1-void NurbsCurveEvaluator::set_extended_vertices(int i, int d, PN_stdfloat const values[], int num_values)
  int param1;
  int param2;
  PyObject *param3;
  Py_buffer param3_view;
  int param4;
  static const char *keyword_list[] = {"i", "d", "values", "num_values", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiOi:set_extended_vertices", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    if (PyObject_GetBuffer(param3, &param3_view, PyBUF_FORMAT) == 0 && param3_view.format[0] == 'f' && param3_view.format[1] == 0) {
      (*local_this).set_extended_vertices((int)param1, (int)param2, (float *)param3_view.buf, (int)param4);
      PyBuffer_Release(&param3_view);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_extended_vertices(const NurbsCurveEvaluator self, int i, int d, buffer values, int num_values)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_set_extended_vertices_177_comment =
  "C++ Interface:\n"
  "set_extended_vertices(const NurbsCurveEvaluator self, int i, int d, buffer values, int num_values)\n"
  "\n"
  "/**\n"
  " * Simultaneously sets several extended values in the slots d through (d +\n"
  " * num_values - 1) from the num_values elements of the indicated array.  This\n"
  " * is equivalent to calling set_extended_vertex() num_values times.  See\n"
  " * set_extended_vertex().\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_set_extended_vertices_177_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsCurveEvaluator::get_num_knots(void) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_get_num_knots_178(PyObject *self, PyObject *) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int NurbsCurveEvaluator::get_num_knots(void) const
  int return_value = (*(const NurbsCurveEvaluator*)local_this).get_num_knots();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_get_num_knots_178_comment =
  "C++ Interface:\n"
  "get_num_knots(NurbsCurveEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of knot values in the curve.  This is based on the\n"
  " * number of vertices and the order.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_get_num_knots_178_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveEvaluator::set_knot(int i, PN_stdfloat knot)
 */
static PyObject *Dtool_NurbsCurveEvaluator_set_knot_179(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveEvaluator, (void **)&local_this, "NurbsCurveEvaluator.set_knot")) {
    return NULL;
  }
  // 1-void NurbsCurveEvaluator::set_knot(int i, PN_stdfloat knot)
  int param1;
  float param2;
  static const char *keyword_list[] = {"i", "knot", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_knot", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_knot((int)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_knot(const NurbsCurveEvaluator self, int i, float knot)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_set_knot_179_comment =
  "C++ Interface:\n"
  "set_knot(const NurbsCurveEvaluator self, int i, float knot)\n"
  "\n"
  "/**\n"
  " * Sets the value of the nth knot.  Each knot value should be greater than or\n"
  " * equal to the preceding value.  If no knot values are set, a default knot\n"
  " * vector is supplied.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_set_knot_179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat NurbsCurveEvaluator::get_knot(int i) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_get_knot_180(PyObject *self, PyObject *arg) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat NurbsCurveEvaluator::get_knot(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = (*(const NurbsCurveEvaluator*)local_this).get_knot((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_knot(NurbsCurveEvaluator self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_get_knot_180_comment =
  "C++ Interface:\n"
  "get_knot(NurbsCurveEvaluator self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the value of the nth knot.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_get_knot_180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveEvaluator::normalize_knots(void)
 */
static PyObject *Dtool_NurbsCurveEvaluator_normalize_knots_182(PyObject *self, PyObject *) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveEvaluator, (void **)&local_this, "NurbsCurveEvaluator.normalize_knots")) {
    return NULL;
  }
  // 1-void NurbsCurveEvaluator::normalize_knots(void)
  (*local_this).normalize_knots();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_normalize_knots_182_comment =
  "C++ Interface:\n"
  "normalize_knots(const NurbsCurveEvaluator self)\n"
  "\n"
  "/**\n"
  " * Normalizes the knot sequence so that the parametric range of the curve is 0\n"
  " * .. 1.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_normalize_knots_182_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsCurveEvaluator::get_num_segments(void) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_get_num_segments_183(PyObject *self, PyObject *) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int NurbsCurveEvaluator::get_num_segments(void) const
  int return_value = (*(const NurbsCurveEvaluator*)local_this).get_num_segments();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_get_num_segments_183_comment =
  "C++ Interface:\n"
  "get_num_segments(NurbsCurveEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of piecewise continuous segments in the curve.  This is\n"
  " * based on the knot vector.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_get_num_segments_183_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< NurbsCurveResult > NurbsCurveEvaluator::evaluate(NodePath const &rel_to = NodePath()) const
 * PointerTo< NurbsCurveResult > NurbsCurveEvaluator::evaluate(NodePath const &rel_to, LMatrix4 const &mat) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_evaluate_184(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveEvaluator, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PointerTo< NurbsCurveResult > NurbsCurveEvaluator::evaluate(NodePath const &rel_to) const
      PointerTo< NurbsCurveResult > return_value = (*(const NurbsCurveEvaluator*)local_this).evaluate();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      // Transfer ownership of return_value.
      NurbsCurveResult *return_ptr = return_value.p();
      return_value.cheat() = NULL;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_NurbsCurveResult, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "rel_to");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'rel_to' (pos 1) not found");
      }
      // 1-PointerTo< NurbsCurveResult > NurbsCurveEvaluator::evaluate(NodePath const &rel_to) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NurbsCurveEvaluator.evaluate", true, true);
      if (arg_this != NULL) {
        PointerTo< NurbsCurveResult > return_value = (*(const NurbsCurveEvaluator*)local_this).evaluate(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        // Transfer ownership of return_value.
        NurbsCurveResult *return_ptr = return_value.p();
        return_value.cheat() = NULL;
        return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_NurbsCurveResult, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-PointerTo< NurbsCurveResult > NurbsCurveEvaluator::evaluate(NodePath const &rel_to, LMatrix4 const &mat) const
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"rel_to", "mat", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:evaluate", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NurbsCurveEvaluator.evaluate", true, true);
        LMatrix4f param2_local;
        LMatrix4 const *param2_this = Dtool_Coerce_LMatrix4f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NurbsCurveEvaluator.evaluate", "LMatrix4f");
        }
        if (param1_this != NULL) {
          PointerTo< NurbsCurveResult > return_value = (*(const NurbsCurveEvaluator*)local_this).evaluate(*param1_this, *param2_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          // Transfer ownership of return_value.
          NurbsCurveResult *return_ptr = return_value.p();
          return_value.cheat() = NULL;
          return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_NurbsCurveResult, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "evaluate() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "evaluate(NurbsCurveEvaluator self)\n"
      "evaluate(NurbsCurveEvaluator self, const NodePath rel_to)\n"
      "evaluate(NurbsCurveEvaluator self, const NodePath rel_to, const LMatrix4f mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_evaluate_184_comment =
  "C++ Interface:\n"
  "evaluate(NurbsCurveEvaluator self)\n"
  "evaluate(NurbsCurveEvaluator self, const NodePath rel_to)\n"
  "evaluate(NurbsCurveEvaluator self, const NodePath rel_to, const LMatrix4f mat)\n"
  "\n"
  "/**\n"
  " * Returns a NurbsCurveResult object that represents the result of applying\n"
  " * the knots to all of the current values of the vertices, transformed into\n"
  " * the indicated coordinate space.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a NurbsCurveResult object that represents the result of applying\n"
  " * the knots to all of the current values of the vertices, transformed into\n"
  " * the indicated coordinate space, and then further transformed by the\n"
  " * indicated matrix.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_evaluate_184_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveEvaluator::output(ostream &out) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_output_185(PyObject *self, PyObject *arg) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-void NurbsCurveEvaluator::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "NurbsCurveEvaluator.output", false, true);
  if (arg_this != NULL) {
    (*(const NurbsCurveEvaluator*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(NurbsCurveEvaluator self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_output_185_comment =
  "C++ Interface:\n"
  "output(NurbsCurveEvaluator self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_output_185_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NurbsCurveEvaluator::NurbsCurveEvaluator(void)
 * inline NurbsCurveEvaluator::NurbsCurveEvaluator(NurbsCurveEvaluator const &) = default
 */
static int Dtool_Init_NurbsCurveEvaluator(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-NurbsCurveEvaluator::NurbsCurveEvaluator(void)
      NurbsCurveEvaluator *return_value = new NurbsCurveEvaluator();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NurbsCurveEvaluator, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline NurbsCurveEvaluator::NurbsCurveEvaluator(NurbsCurveEvaluator const &) = default
      NurbsCurveEvaluator const *arg_this = (NurbsCurveEvaluator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NurbsCurveEvaluator, 0, "NurbsCurveEvaluator.NurbsCurveEvaluator", true, true);
      if (arg_this != NULL) {
        NurbsCurveEvaluator *return_value = new NurbsCurveEvaluator(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NurbsCurveEvaluator, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "NurbsCurveEvaluator() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NurbsCurveEvaluator()\n"
      "NurbsCurveEvaluator(const NurbsCurveEvaluator param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NurbsCurveEvaluator_get_vertices(PyObject *self, PyObject *) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveEvaluator, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_vertices();
  PyTupleObject args;
  PyObject_INIT_VAR(&args, &PyTuple_Type, 1);
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyTuple_SET_ITEM(&args, 0, index);
    PyObject *value = Dtool_NurbsCurveEvaluator_get_vertex_171(self, (PyObject *)&args, NULL);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  _Py_ForgetReference((PyObject *)&args);
  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NurbsCurveEvaluator_get_knots(PyObject *self, PyObject *) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveEvaluator, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_knots();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NurbsCurveEvaluator_get_knot_180(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_NurbsCurveEvaluator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_NurbsCurveEvaluator) {
    printf("NurbsCurveEvaluator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  NurbsCurveEvaluator *local_this = (NurbsCurveEvaluator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_NurbsCurveEvaluator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_NurbsCurveEvaluator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_NurbsCurveEvaluator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (NurbsCurveEvaluator*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class NurbsSurfaceResult
 */
/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsSurfaceResult::get_start_u(void) const
 */
static PyObject *Dtool_NurbsSurfaceResult_get_start_u_187(PyObject *self, PyObject *) {
  NurbsSurfaceResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat NurbsSurfaceResult::get_start_u(void) const
  PN_stdfloat return_value = (*(const NurbsSurfaceResult*)local_this).get_start_u();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_get_start_u_187_comment =
  "C++ Interface:\n"
  "get_start_u(NurbsSurfaceResult self)\n"
  "\n"
  "/**\n"
  " * Returns the first legal value of u on the surface.  Usually this is 0.0.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_get_start_u_187_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsSurfaceResult::get_end_u(void) const
 */
static PyObject *Dtool_NurbsSurfaceResult_get_end_u_188(PyObject *self, PyObject *) {
  NurbsSurfaceResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat NurbsSurfaceResult::get_end_u(void) const
  PN_stdfloat return_value = (*(const NurbsSurfaceResult*)local_this).get_end_u();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_get_end_u_188_comment =
  "C++ Interface:\n"
  "get_end_u(NurbsSurfaceResult self)\n"
  "\n"
  "/**\n"
  " * Returns the last legal value of u on the surface.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_get_end_u_188_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsSurfaceResult::get_start_v(void) const
 */
static PyObject *Dtool_NurbsSurfaceResult_get_start_v_189(PyObject *self, PyObject *) {
  NurbsSurfaceResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat NurbsSurfaceResult::get_start_v(void) const
  PN_stdfloat return_value = (*(const NurbsSurfaceResult*)local_this).get_start_v();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_get_start_v_189_comment =
  "C++ Interface:\n"
  "get_start_v(NurbsSurfaceResult self)\n"
  "\n"
  "/**\n"
  " * Returns the first legal value of v on the surface.  Usually this is 0.0.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_get_start_v_189_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsSurfaceResult::get_end_v(void) const
 */
static PyObject *Dtool_NurbsSurfaceResult_get_end_v_190(PyObject *self, PyObject *) {
  NurbsSurfaceResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat NurbsSurfaceResult::get_end_v(void) const
  PN_stdfloat return_value = (*(const NurbsSurfaceResult*)local_this).get_end_v();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_get_end_v_190_comment =
  "C++ Interface:\n"
  "get_end_v(NurbsSurfaceResult self)\n"
  "\n"
  "/**\n"
  " * Returns the last legal value of v on the surface.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_get_end_v_190_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool NurbsSurfaceResult::eval_point(PN_stdfloat u, PN_stdfloat v, LVecBase3 &point)
 */
static PyObject *Dtool_NurbsSurfaceResult_eval_point_191(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceResult, (void **)&local_this, "NurbsSurfaceResult.eval_point")) {
    return NULL;
  }
  // 1-inline bool NurbsSurfaceResult::eval_point(PN_stdfloat u, PN_stdfloat v, LVecBase3 &point)
  float param1;
  float param2;
  PyObject *param3;
  static const char *keyword_list[] = {"u", "v", "point", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffO:eval_point", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3f param3_local;
    LVecBase3 *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "NurbsSurfaceResult.eval_point", "LVecBase3f");
    }
    bool return_value = (*local_this).eval_point((PN_stdfloat)param1, (PN_stdfloat)param2, *param3_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_point(const NurbsSurfaceResult self, float u, float v, LVecBase3f point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_eval_point_191_comment =
  "C++ Interface:\n"
  "eval_point(const NurbsSurfaceResult self, float u, float v, LVecBase3f point)\n"
  "\n"
  "/**\n"
  " * Computes the point on the surface corresponding to the indicated value in\n"
  " * parametric time.  Returns true if the u, v values are valid, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_eval_point_191_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool NurbsSurfaceResult::eval_normal(PN_stdfloat u, PN_stdfloat v, LVecBase3 &normal)
 */
static PyObject *Dtool_NurbsSurfaceResult_eval_normal_192(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceResult, (void **)&local_this, "NurbsSurfaceResult.eval_normal")) {
    return NULL;
  }
  // 1-inline bool NurbsSurfaceResult::eval_normal(PN_stdfloat u, PN_stdfloat v, LVecBase3 &normal)
  float param1;
  float param2;
  PyObject *param3;
  static const char *keyword_list[] = {"u", "v", "normal", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffO:eval_normal", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3f param3_local;
    LVecBase3 *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "NurbsSurfaceResult.eval_normal", "LVecBase3f");
    }
    bool return_value = (*local_this).eval_normal((PN_stdfloat)param1, (PN_stdfloat)param2, *param3_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_normal(const NurbsSurfaceResult self, float u, float v, LVecBase3f normal)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_eval_normal_192_comment =
  "C++ Interface:\n"
  "eval_normal(const NurbsSurfaceResult self, float u, float v, LVecBase3f normal)\n"
  "\n"
  "/**\n"
  " * Computes the normal to the surface at the indicated point in parametric\n"
  " * time.  This normal vector will not necessarily be normalized, and could be\n"
  " * zero.  See also eval_point().\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_eval_normal_192_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsSurfaceResult::eval_extended_point(PN_stdfloat u, PN_stdfloat v, int d)
 */
static PyObject *Dtool_NurbsSurfaceResult_eval_extended_point_193(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceResult, (void **)&local_this, "NurbsSurfaceResult.eval_extended_point")) {
    return NULL;
  }
  // 1-inline PN_stdfloat NurbsSurfaceResult::eval_extended_point(PN_stdfloat u, PN_stdfloat v, int d)
  float param1;
  float param2;
  int param3;
  static const char *keyword_list[] = {"u", "v", "d", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffi:eval_extended_point", (char **)keyword_list, &param1, &param2, &param3)) {
    PN_stdfloat return_value = (*local_this).eval_extended_point((PN_stdfloat)param1, (PN_stdfloat)param2, (int)param3);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_extended_point(const NurbsSurfaceResult self, float u, float v, int d)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_eval_extended_point_193_comment =
  "C++ Interface:\n"
  "eval_extended_point(const NurbsSurfaceResult self, float u, float v, int d)\n"
  "\n"
  "/**\n"
  " * Evaluates the surface in n-dimensional space according to the extended\n"
  " * vertices associated with the surface in the indicated dimension.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_eval_extended_point_193_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool NurbsSurfaceResult::eval_extended_points(PN_stdfloat u, PN_stdfloat v, int d, PN_stdfloat result[], int num_values)
 */
static PyObject *Dtool_NurbsSurfaceResult_eval_extended_points_194(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceResult, (void **)&local_this, "NurbsSurfaceResult.eval_extended_points")) {
    return NULL;
  }
  // 1-inline bool NurbsSurfaceResult::eval_extended_points(PN_stdfloat u, PN_stdfloat v, int d, PN_stdfloat result[], int num_values)
  float param1;
  float param2;
  int param3;
  PyObject *param4;
  Py_buffer param4_view;
  int param5;
  static const char *keyword_list[] = {"u", "v", "d", "result", "num_values", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffiOi:eval_extended_points", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    if (PyObject_GetBuffer(param4, &param4_view, PyBUF_FORMAT | PyBUF_WRITABLE) == 0 && param4_view.format[0] == 'f' && param4_view.format[1] == 0) {
      bool return_value = (*local_this).eval_extended_points((PN_stdfloat)param1, (PN_stdfloat)param2, (int)param3, (float *)param4_view.buf, (int)param5);
      PyBuffer_Release(&param4_view);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_extended_points(const NurbsSurfaceResult self, float u, float v, int d, buffer result, int num_values)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_eval_extended_points_194_comment =
  "C++ Interface:\n"
  "eval_extended_points(const NurbsSurfaceResult self, float u, float v, int d, buffer result, int num_values)\n"
  "\n"
  "/**\n"
  " * Simultaneously performs eval_extended_point on a contiguous sequence of\n"
  " * dimensions.  The dimensions evaluated are d through (d + num_values - 1);\n"
  " * the results are filled into the num_values elements in the indicated result\n"
  " * array.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_eval_extended_points_194_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceResult::get_num_u_segments(void) const
 */
static PyObject *Dtool_NurbsSurfaceResult_get_num_u_segments_195(PyObject *self, PyObject *) {
  NurbsSurfaceResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int NurbsSurfaceResult::get_num_u_segments(void) const
  int return_value = (*(const NurbsSurfaceResult*)local_this).get_num_u_segments();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_get_num_u_segments_195_comment =
  "C++ Interface:\n"
  "get_num_u_segments(NurbsSurfaceResult self)\n"
  "\n"
  "/**\n"
  " * Returns the number of piecewise continuous segments within the surface in\n"
  " * the U direction.  This number is usually not important unless you plan to\n"
  " * call eval_segment_point().\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_get_num_u_segments_195_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceResult::get_num_v_segments(void) const
 */
static PyObject *Dtool_NurbsSurfaceResult_get_num_v_segments_196(PyObject *self, PyObject *) {
  NurbsSurfaceResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int NurbsSurfaceResult::get_num_v_segments(void) const
  int return_value = (*(const NurbsSurfaceResult*)local_this).get_num_v_segments();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_get_num_v_segments_196_comment =
  "C++ Interface:\n"
  "get_num_v_segments(NurbsSurfaceResult self)\n"
  "\n"
  "/**\n"
  " * Returns the number of piecewise continuous segments within the surface in\n"
  " * the V direction.  This number is usually not important unless you plan to\n"
  " * call eval_segment_point().\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_get_num_v_segments_196_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceResult::eval_segment_point(int ui, int vi, PN_stdfloat u, PN_stdfloat v, LVecBase3 &point) const
 */
static PyObject *Dtool_NurbsSurfaceResult_eval_segment_point_197(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-void NurbsSurfaceResult::eval_segment_point(int ui, int vi, PN_stdfloat u, PN_stdfloat v, LVecBase3 &point) const
  int param1;
  int param2;
  float param3;
  float param4;
  PyObject *param5;
  static const char *keyword_list[] = {"ui", "vi", "u", "v", "point", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiffO:eval_segment_point", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    LVecBase3f param5_local;
    LVecBase3 *param5_this = Dtool_Coerce_LVecBase3f(param5, param5_local);
    if (!(param5_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param5, 5, "NurbsSurfaceResult.eval_segment_point", "LVecBase3f");
    }
    (*(const NurbsSurfaceResult*)local_this).eval_segment_point((int)param1, (int)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, *param5_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_segment_point(NurbsSurfaceResult self, int ui, int vi, float u, float v, LVecBase3f point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_eval_segment_point_197_comment =
  "C++ Interface:\n"
  "eval_segment_point(NurbsSurfaceResult self, int ui, int vi, float u, float v, LVecBase3f point)\n"
  "\n"
  "/**\n"
  " * Evaluates the point on the surface corresponding to the indicated value in\n"
  " * parametric time within the indicated surface segment.  u and v should be in\n"
  " * the range [0, 1].\n"
  " *\n"
  " * The surface is internally represented as a number of connected (or possibly\n"
  " * unconnected) piecewise continuous segments.  The exact number of segments\n"
  " * for a particular surface depends on the knot vector, and is returned by\n"
  " * get_num_segments().  Normally, eval_point() is used to evaluate a point\n"
  " * along the continuous surface, but when you care more about local\n"
  " * continuity, you can use eval_segment_point() to evaluate the points along\n"
  " * each segment.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_eval_segment_point_197_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceResult::eval_segment_normal(int ui, int vi, PN_stdfloat u, PN_stdfloat v, LVecBase3 &normal) const
 */
static PyObject *Dtool_NurbsSurfaceResult_eval_segment_normal_198(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-void NurbsSurfaceResult::eval_segment_normal(int ui, int vi, PN_stdfloat u, PN_stdfloat v, LVecBase3 &normal) const
  int param1;
  int param2;
  float param3;
  float param4;
  PyObject *param5;
  static const char *keyword_list[] = {"ui", "vi", "u", "v", "normal", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiffO:eval_segment_normal", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    LVecBase3f param5_local;
    LVecBase3 *param5_this = Dtool_Coerce_LVecBase3f(param5, param5_local);
    if (!(param5_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param5, 5, "NurbsSurfaceResult.eval_segment_normal", "LVecBase3f");
    }
    (*(const NurbsSurfaceResult*)local_this).eval_segment_normal((int)param1, (int)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, *param5_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_segment_normal(NurbsSurfaceResult self, int ui, int vi, float u, float v, LVecBase3f normal)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_eval_segment_normal_198_comment =
  "C++ Interface:\n"
  "eval_segment_normal(NurbsSurfaceResult self, int ui, int vi, float u, float v, LVecBase3f normal)\n"
  "\n"
  "/**\n"
  " * As eval_segment_point, but computes the normal to the surface at the\n"
  " * indicated point.  The normal vector will not necessarily be normalized, and\n"
  " * could be zero.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_eval_segment_normal_198_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat NurbsSurfaceResult::eval_segment_extended_point(int ui, int vi, PN_stdfloat u, PN_stdfloat v, int d) const
 */
static PyObject *Dtool_NurbsSurfaceResult_eval_segment_extended_point_199(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat NurbsSurfaceResult::eval_segment_extended_point(int ui, int vi, PN_stdfloat u, PN_stdfloat v, int d) const
  int param1;
  int param2;
  float param3;
  float param4;
  int param5;
  static const char *keyword_list[] = {"ui", "vi", "u", "v", "d", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiffi:eval_segment_extended_point", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    PN_stdfloat return_value = (*(const NurbsSurfaceResult*)local_this).eval_segment_extended_point((int)param1, (int)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (int)param5);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_segment_extended_point(NurbsSurfaceResult self, int ui, int vi, float u, float v, int d)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_eval_segment_extended_point_199_comment =
  "C++ Interface:\n"
  "eval_segment_extended_point(NurbsSurfaceResult self, int ui, int vi, float u, float v, int d)\n"
  "\n"
  "/**\n"
  " * Evaluates the surface in n-dimensional space according to the extended\n"
  " * vertices associated with the surface in the indicated dimension.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_eval_segment_extended_point_199_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceResult::eval_segment_extended_points(int ui, int vi, PN_stdfloat u, PN_stdfloat v, int d, PN_stdfloat result[], int num_values) const
 */
static PyObject *Dtool_NurbsSurfaceResult_eval_segment_extended_points_200(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-void NurbsSurfaceResult::eval_segment_extended_points(int ui, int vi, PN_stdfloat u, PN_stdfloat v, int d, PN_stdfloat result[], int num_values) const
  int param1;
  int param2;
  float param3;
  float param4;
  int param5;
  PyObject *param6;
  Py_buffer param6_view;
  int param7;
  static const char *keyword_list[] = {"ui", "vi", "u", "v", "d", "result", "num_values", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiffiOi:eval_segment_extended_points", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
    if (PyObject_GetBuffer(param6, &param6_view, PyBUF_FORMAT | PyBUF_WRITABLE) == 0 && param6_view.format[0] == 'f' && param6_view.format[1] == 0) {
      (*(const NurbsSurfaceResult*)local_this).eval_segment_extended_points((int)param1, (int)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (int)param5, (float *)param6_view.buf, (int)param7);
      PyBuffer_Release(&param6_view);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_segment_extended_points(NurbsSurfaceResult self, int ui, int vi, float u, float v, int d, buffer result, int num_values)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_eval_segment_extended_points_200_comment =
  "C++ Interface:\n"
  "eval_segment_extended_points(NurbsSurfaceResult self, int ui, int vi, float u, float v, int d, buffer result, int num_values)\n"
  "\n"
  "/**\n"
  " * Simultaneously performs eval_extended_point on a contiguous sequence of\n"
  " * dimensions.  The dimensions evaluated are d through (d + num_values - 1);\n"
  " * the results are filled into the num_values elements in the indicated result\n"
  " * array.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_eval_segment_extended_points_200_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsSurfaceResult::get_segment_u(int ui, PN_stdfloat u) const
 */
static PyObject *Dtool_NurbsSurfaceResult_get_segment_u_201(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat NurbsSurfaceResult::get_segment_u(int ui, PN_stdfloat u) const
  int param1;
  float param2;
  static const char *keyword_list[] = {"ui", "u", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:get_segment_u", (char **)keyword_list, &param1, &param2)) {
    PN_stdfloat return_value = (*(const NurbsSurfaceResult*)local_this).get_segment_u((int)param1, (PN_stdfloat)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_segment_u(NurbsSurfaceResult self, int ui, float u)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_get_segment_u_201_comment =
  "C++ Interface:\n"
  "get_segment_u(NurbsSurfaceResult self, int ui, float u)\n"
  "\n"
  "/**\n"
  " * Accepts a u value in the range [0, 1], and assumed to be relative to the\n"
  " * indicated segment (as in eval_segment_point()), and returns the\n"
  " * corresponding u value in the entire surface (as in eval_point()).\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_get_segment_u_201_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsSurfaceResult::get_segment_v(int vi, PN_stdfloat v) const
 */
static PyObject *Dtool_NurbsSurfaceResult_get_segment_v_202(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceResult, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat NurbsSurfaceResult::get_segment_v(int vi, PN_stdfloat v) const
  int param1;
  float param2;
  static const char *keyword_list[] = {"vi", "v", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:get_segment_v", (char **)keyword_list, &param1, &param2)) {
    PN_stdfloat return_value = (*(const NurbsSurfaceResult*)local_this).get_segment_v((int)param1, (PN_stdfloat)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_segment_v(NurbsSurfaceResult self, int vi, float v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_get_segment_v_202_comment =
  "C++ Interface:\n"
  "get_segment_v(NurbsSurfaceResult self, int vi, float v)\n"
  "\n"
  "/**\n"
  " * Accepts a v value in the range [0, 1], and assumed to be relative to the\n"
  " * indicated segment (as in eval_segment_point()), and returns the\n"
  " * corresponding v value in the entire surface (as in eval_point()).\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_get_segment_v_202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NurbsSurfaceResult::NurbsSurfaceResult(NurbsSurfaceResult const &) = default
 */
static int Dtool_Init_NurbsSurfaceResult(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "NurbsSurfaceResult() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline NurbsSurfaceResult::NurbsSurfaceResult(NurbsSurfaceResult const &) = default
  NurbsSurfaceResult const *arg_this = (NurbsSurfaceResult *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NurbsSurfaceResult, 0, "NurbsSurfaceResult.NurbsSurfaceResult", true, true);
  if (arg_this != NULL) {
    NurbsSurfaceResult *return_value = new NurbsSurfaceResult(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NurbsSurfaceResult, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NurbsSurfaceResult(const NurbsSurfaceResult param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_NurbsSurfaceResult(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_NurbsSurfaceResult) {
    printf("NurbsSurfaceResult ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  NurbsSurfaceResult *local_this = (NurbsSurfaceResult *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_NurbsSurfaceResult) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_NurbsSurfaceResult(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_NurbsSurfaceResult) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (NurbsSurfaceResult*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class NurbsSurfaceEvaluator
 */
/**
 * Python function wrapper for:
 * inline void NurbsSurfaceEvaluator::set_u_order(int u_order)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_set_u_order_206(PyObject *self, PyObject *arg) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.set_u_order")) {
    return NULL;
  }
  // 1-inline void NurbsSurfaceEvaluator::set_u_order(int u_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_u_order((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_u_order(const NurbsSurfaceEvaluator self, int u_order)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_set_u_order_206_comment =
  "C++ Interface:\n"
  "set_u_order(const NurbsSurfaceEvaluator self, int u_order)\n"
  "\n"
  "/**\n"
  " * Sets the order of the surface in the U direction.  This resets the knot\n"
  " * vector to the default knot vector for the number of vertices.\n"
  " *\n"
  " * The order must be 1, 2, 3, or 4, and the value is one more than the degree\n"
  " * of the surface.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_set_u_order_206_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceEvaluator::get_u_order(void) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_u_order_207(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int NurbsSurfaceEvaluator::get_u_order(void) const
  int return_value = (*(const NurbsSurfaceEvaluator*)local_this).get_u_order();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_u_order_207_comment =
  "C++ Interface:\n"
  "get_u_order(NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the order of the surface in the U direction as set by a previous\n"
  " * call to set_u_order().\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_u_order_207_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void NurbsSurfaceEvaluator::set_v_order(int v_order)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_set_v_order_208(PyObject *self, PyObject *arg) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.set_v_order")) {
    return NULL;
  }
  // 1-inline void NurbsSurfaceEvaluator::set_v_order(int v_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_v_order((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_v_order(const NurbsSurfaceEvaluator self, int v_order)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_set_v_order_208_comment =
  "C++ Interface:\n"
  "set_v_order(const NurbsSurfaceEvaluator self, int v_order)\n"
  "\n"
  "/**\n"
  " * Sets the order of the surface in the V direction.  This resets the knot\n"
  " * vector to the default knot vector for the number of vertices.\n"
  " *\n"
  " * The order must be 1, 2, 3, or 4, and the value is one more than the degree\n"
  " * of the surface.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_set_v_order_208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceEvaluator::get_v_order(void) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_v_order_209(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int NurbsSurfaceEvaluator::get_v_order(void) const
  int return_value = (*(const NurbsSurfaceEvaluator*)local_this).get_v_order();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_v_order_209_comment =
  "C++ Interface:\n"
  "get_v_order(NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the order of the surface in the V direction as set by a previous\n"
  " * call to set_v_order().\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_v_order_209_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceEvaluator::reset(int num_u_vertices, int num_v_vertices)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_reset_210(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.reset")) {
    return NULL;
  }
  // 1-void NurbsSurfaceEvaluator::reset(int num_u_vertices, int num_v_vertices)
  int param1;
  int param2;
  static const char *keyword_list[] = {"num_u_vertices", "num_v_vertices", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:reset", (char **)keyword_list, &param1, &param2)) {
    (*local_this).reset((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reset(const NurbsSurfaceEvaluator self, int num_u_vertices, int num_v_vertices)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_reset_210_comment =
  "C++ Interface:\n"
  "reset(const NurbsSurfaceEvaluator self, int num_u_vertices, int num_v_vertices)\n"
  "\n"
  "/**\n"
  " * Resets all the vertices and knots to their default values, and sets the\n"
  " * surface up with the indicated number of vertices.  You must then call\n"
  " * set_vertex() repeatedly to fill in all of the vertex values appropriately.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_reset_210_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceEvaluator::get_num_u_vertices(void) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_num_u_vertices_211(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int NurbsSurfaceEvaluator::get_num_u_vertices(void) const
  int return_value = (*(const NurbsSurfaceEvaluator*)local_this).get_num_u_vertices();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_num_u_vertices_211_comment =
  "C++ Interface:\n"
  "get_num_u_vertices(NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of control vertices in the U direction on the surface.\n"
  " * This is the number passed to the last call to reset().\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_num_u_vertices_211_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceEvaluator::get_num_v_vertices(void) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_num_v_vertices_212(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int NurbsSurfaceEvaluator::get_num_v_vertices(void) const
  int return_value = (*(const NurbsSurfaceEvaluator*)local_this).get_num_v_vertices();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_num_v_vertices_212_comment =
  "C++ Interface:\n"
  "get_num_v_vertices(NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of control vertices in the V direction on the surface.\n"
  " * This is the number passed to the last call to reset().\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_num_v_vertices_212_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase3 const &vertex, PN_stdfloat weight = 1.0)
 * inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase4 const &vertex)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_set_vertex_213(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.set_vertex")) {
    return NULL;
  }
  {
    // -2 inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase3 const &vertex, PN_stdfloat weight = 1.0)
    int param1;
    int param2;
    PyObject *param3;
    float param4 = 1.0;
    static const char *keyword_list[] = {"ui", "vi", "vertex", "weight", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO|f:set_vertex", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      LVecBase3 const *param3_this;
      DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase3f, (void **)&param3_this);
      if (param3_this != NULL) {
        (*local_this).set_vertex((int)param1, (int)param2, *param3_this, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase4 const &vertex)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"ui", "vi", "vertex", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_vertex", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase4 const *param3_this;
      DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase4f, (void **)&param3_this);
      if (param3_this != NULL) {
        (*local_this).set_vertex((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase3 const &vertex, PN_stdfloat weight = 1.0)
    int param1;
    int param2;
    PyObject *param3;
    float param4 = 1.0;
    static const char *keyword_list[] = {"ui", "vi", "vertex", "weight", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO|f:set_vertex", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      LVecBase3f param3_local;
      LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
      if ((param3_this != NULL)) {
        (*local_this).set_vertex((int)param1, (int)param2, *param3_this, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase4 const &vertex)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"ui", "vi", "vertex", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_vertex", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase4f param3_local;
      LVecBase4 const *param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
      if ((param3_this != NULL)) {
        (*local_this).set_vertex((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertex(const NurbsSurfaceEvaluator self, int ui, int vi, const LVecBase3f vertex, float weight)\n"
      "set_vertex(const NurbsSurfaceEvaluator self, int ui, int vi, const LVecBase4f vertex)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_set_vertex_213_comment =
  "C++ Interface:\n"
  "set_vertex(const NurbsSurfaceEvaluator self, int ui, int vi, const LVecBase3f vertex, float weight)\n"
  "set_vertex(const NurbsSurfaceEvaluator self, int ui, int vi, const LVecBase4f vertex)\n"
  "\n"
  "/**\n"
  " * Sets the nth control vertex of the surface, as a vertex in 4-d homogeneous\n"
  " * space.  In this form, the first three components of the vertex should\n"
  " * already have been scaled by the fourth component, which is the homogeneous\n"
  " * weight.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the nth control vertex of the surface.  This flavor sets the vertex as\n"
  " * a 3-d coordinate and a weight; the 3-d coordinate values are implicitly\n"
  " * scaled up by the weight factor.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_set_vertex_213_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 const &NurbsSurfaceEvaluator::get_vertex(int ui, int vi) const
 * inline LVecBase4 NurbsSurfaceEvaluator::get_vertex(int ui, int vi, NodePath const &rel_to) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_vertex_214(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline LVecBase4 const &NurbsSurfaceEvaluator::get_vertex(int ui, int vi) const
      int param1;
      int param2;
      static const char *keyword_list[] = {"ui", "vi", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_vertex", (char **)keyword_list, &param1, &param2)) {
        LVecBase4 const *return_value = &((*(const NurbsSurfaceEvaluator*)local_this).get_vertex((int)param1, (int)param2));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
      }
    }
    break;
  case 3:
    {
      // 1-inline LVecBase4 NurbsSurfaceEvaluator::get_vertex(int ui, int vi, NodePath const &rel_to) const
      int param1;
      int param2;
      PyObject *param3;
      static const char *keyword_list[] = {"ui", "vi", "rel_to", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:get_vertex", (char **)keyword_list, &param1, &param2, &param3)) {
        NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "NurbsSurfaceEvaluator.get_vertex", true, true);
        if (param3_this != NULL) {
          LVecBase4 *return_value = new LVecBase4((*(const NurbsSurfaceEvaluator*)local_this).get_vertex((int)param1, (int)param2, *param3_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_vertex() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(NurbsSurfaceEvaluator self, int ui, int vi)\n"
      "get_vertex(NurbsSurfaceEvaluator self, int ui, int vi, const NodePath rel_to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_vertex_214_comment =
  "C++ Interface:\n"
  "get_vertex(NurbsSurfaceEvaluator self, int ui, int vi)\n"
  "get_vertex(NurbsSurfaceEvaluator self, int ui, int vi, const NodePath rel_to)\n"
  "\n"
  "/**\n"
  " * Returns the nth control vertex of the surface, relative to its indicated\n"
  " * coordinate space.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the nth control vertex of the surface, relative to the given\n"
  " * coordinate space.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_vertex_214_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, NodePath const &space)
 * inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, std::string const &space)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_set_vertex_space_215(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.set_vertex_space")) {
    return NULL;
  }
  {
    // -2 inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, NodePath const &space)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"ui", "vi", "space", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_vertex_space", (char **)keyword_list, &param1, &param2, &param3)) {
      NodePath const *param3_this;
      DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_NodePath, (void **)&param3_this);
      if (param3_this != NULL) {
        (*local_this).set_vertex_space((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, std::string const &space)
    int param1;
    int param2;
    char *param3_str = NULL;
    Py_ssize_t param3_len;
    static const char *keyword_list[] = {"ui", "vi", "space", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iis#:set_vertex_space", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
      (*local_this).set_vertex_space((int)param1, (int)param2, std::string(param3_str, param3_len));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, NodePath const &space)
  // No coercion possible: inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, std::string const &space)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertex_space(const NurbsSurfaceEvaluator self, int ui, int vi, const NodePath space)\n"
      "set_vertex_space(const NurbsSurfaceEvaluator self, int ui, int vi, str space)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_set_vertex_space_215_comment =
  "C++ Interface:\n"
  "set_vertex_space(const NurbsSurfaceEvaluator self, int ui, int vi, const NodePath space)\n"
  "set_vertex_space(const NurbsSurfaceEvaluator self, int ui, int vi, str space)\n"
  "\n"
  "/**\n"
  " * Sets the coordinate space of the nth control vertex.  If this is not\n"
  " * specified, or is set to an empty NodePath, the nth control vertex is deemed\n"
  " * to be in the coordinate space passed to evaluate().\n"
  " *\n"
  " * This specifies the space as a fixed NodePath, which is always the same\n"
  " * NodePath.  Also see setting the space as a path string, which can specify a\n"
  " * different NodePath for different instances of the surface.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the coordinate space of the nth control vertex.  If this is not\n"
  " * specified, or is set to an empty string, the nth control vertex is deemed\n"
  " * to be in the coordinate space passed to evaluate().\n"
  " *\n"
  " * This specifies the space as a string, which describes the path to find the\n"
  " * node relative to the rel_to NodePath when the surface is evaluated.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_set_vertex_space_215_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePath NurbsSurfaceEvaluator::get_vertex_space(int ui, int vi, NodePath const &rel_to) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_vertex_space_216(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-NodePath NurbsSurfaceEvaluator::get_vertex_space(int ui, int vi, NodePath const &rel_to) const
  int param1;
  int param2;
  PyObject *param3;
  static const char *keyword_list[] = {"ui", "vi", "rel_to", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:get_vertex_space", (char **)keyword_list, &param1, &param2, &param3)) {
    NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "NurbsSurfaceEvaluator.get_vertex_space", true, true);
    if (param3_this != NULL) {
      NodePath *return_value = new NodePath((*(const NurbsSurfaceEvaluator*)local_this).get_vertex_space((int)param1, (int)param2, *param3_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex_space(NurbsSurfaceEvaluator self, int ui, int vi, const NodePath rel_to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_vertex_space_216_comment =
  "C++ Interface:\n"
  "get_vertex_space(NurbsSurfaceEvaluator self, int ui, int vi, const NodePath rel_to)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate space of the nth control vertex of the surface,\n"
  " * expressed as a NodePath.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_vertex_space_216_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void NurbsSurfaceEvaluator::set_extended_vertex(int ui, int vi, int d, PN_stdfloat value)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_set_extended_vertex_217(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.set_extended_vertex")) {
    return NULL;
  }
  // 1-inline void NurbsSurfaceEvaluator::set_extended_vertex(int ui, int vi, int d, PN_stdfloat value)
  int param1;
  int param2;
  int param3;
  float param4;
  static const char *keyword_list[] = {"ui", "vi", "d", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiif:set_extended_vertex", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).set_extended_vertex((int)param1, (int)param2, (int)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_extended_vertex(const NurbsSurfaceEvaluator self, int ui, int vi, int d, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_set_extended_vertex_217_comment =
  "C++ Interface:\n"
  "set_extended_vertex(const NurbsSurfaceEvaluator self, int ui, int vi, int d, float value)\n"
  "\n"
  "/**\n"
  " * Sets an n-dimensional vertex value.  This allows definition of a NURBS\n"
  " * surface or surface in a sparse n-dimensional space, typically used for\n"
  " * associating additional properties (like color or joint membership) with\n"
  " * each vertex of a surface.\n"
  " *\n"
  " * The value d is an arbitrary integer value and specifies the dimension of\n"
  " * question for this particular vertex.  Any number of dimensions may be\n"
  " * specified, and they need not be consecutive.  If a value for a given\n"
  " * dimension is not specified, is it implicitly 0.0.\n"
  " *\n"
  " * The value is implicitly scaled by the homogenous weight value--that is, the\n"
  " * fourth component of the value passed to set_vertex().  This means the\n"
  " * ordinary vertex must be set first, before the extended vertices can be set.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_set_extended_vertex_217_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsSurfaceEvaluator::get_extended_vertex(int ui, int vi, int d) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_extended_vertex_218(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat NurbsSurfaceEvaluator::get_extended_vertex(int ui, int vi, int d) const
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"ui", "vi", "d", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:get_extended_vertex", (char **)keyword_list, &param1, &param2, &param3)) {
    PN_stdfloat return_value = (*(const NurbsSurfaceEvaluator*)local_this).get_extended_vertex((int)param1, (int)param2, (int)param3);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_extended_vertex(NurbsSurfaceEvaluator self, int ui, int vi, int d)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_extended_vertex_218_comment =
  "C++ Interface:\n"
  "get_extended_vertex(NurbsSurfaceEvaluator self, int ui, int vi, int d)\n"
  "\n"
  "/**\n"
  " * Returns an n-dimensional vertex value.  See set_extended_vertex().  This\n"
  " * returns the value set for the indicated dimension, or 0.0 if nothing has\n"
  " * been set.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_extended_vertex_218_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceEvaluator::set_extended_vertices(int ui, int vi, int d, PN_stdfloat const values[], int num_values)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_set_extended_vertices_219(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.set_extended_vertices")) {
    return NULL;
  }
  // 1-void NurbsSurfaceEvaluator::set_extended_vertices(int ui, int vi, int d, PN_stdfloat const values[], int num_values)
  int param1;
  int param2;
  int param3;
  PyObject *param4;
  Py_buffer param4_view;
  int param5;
  static const char *keyword_list[] = {"ui", "vi", "d", "values", "num_values", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiiOi:set_extended_vertices", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    if (PyObject_GetBuffer(param4, &param4_view, PyBUF_FORMAT) == 0 && param4_view.format[0] == 'f' && param4_view.format[1] == 0) {
      (*local_this).set_extended_vertices((int)param1, (int)param2, (int)param3, (float *)param4_view.buf, (int)param5);
      PyBuffer_Release(&param4_view);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_extended_vertices(const NurbsSurfaceEvaluator self, int ui, int vi, int d, buffer values, int num_values)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_set_extended_vertices_219_comment =
  "C++ Interface:\n"
  "set_extended_vertices(const NurbsSurfaceEvaluator self, int ui, int vi, int d, buffer values, int num_values)\n"
  "\n"
  "/**\n"
  " * Simultaneously sets several extended values in the slots d through (d +\n"
  " * num_values - 1) from the num_values elements of the indicated array.  This\n"
  " * is equivalent to calling set_extended_vertex() num_values times.  See\n"
  " * set_extended_vertex().\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_set_extended_vertices_219_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceEvaluator::get_num_u_knots(void) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_num_u_knots_220(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int NurbsSurfaceEvaluator::get_num_u_knots(void) const
  int return_value = (*(const NurbsSurfaceEvaluator*)local_this).get_num_u_knots();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_num_u_knots_220_comment =
  "C++ Interface:\n"
  "get_num_u_knots(NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of knot values in the surface in the U direction.  This\n"
  " * is based on the number of vertices and the order.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_num_u_knots_220_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceEvaluator::set_u_knot(int i, PN_stdfloat knot)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_set_u_knot_221(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.set_u_knot")) {
    return NULL;
  }
  // 1-void NurbsSurfaceEvaluator::set_u_knot(int i, PN_stdfloat knot)
  int param1;
  float param2;
  static const char *keyword_list[] = {"i", "knot", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_u_knot", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_u_knot((int)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_u_knot(const NurbsSurfaceEvaluator self, int i, float knot)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_set_u_knot_221_comment =
  "C++ Interface:\n"
  "set_u_knot(const NurbsSurfaceEvaluator self, int i, float knot)\n"
  "\n"
  "/**\n"
  " * Sets the value of the nth knot.  Each knot value should be greater than or\n"
  " * equal to the preceding value.  If no knot values are set, a default knot\n"
  " * vector is supplied.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_set_u_knot_221_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat NurbsSurfaceEvaluator::get_u_knot(int i) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_u_knot_222(PyObject *self, PyObject *arg) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat NurbsSurfaceEvaluator::get_u_knot(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = (*(const NurbsSurfaceEvaluator*)local_this).get_u_knot((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_u_knot(NurbsSurfaceEvaluator self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_u_knot_222_comment =
  "C++ Interface:\n"
  "get_u_knot(NurbsSurfaceEvaluator self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the value of the nth knot.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_u_knot_222_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceEvaluator::normalize_u_knots(void)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_normalize_u_knots_224(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.normalize_u_knots")) {
    return NULL;
  }
  // 1-void NurbsSurfaceEvaluator::normalize_u_knots(void)
  (*local_this).normalize_u_knots();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_normalize_u_knots_224_comment =
  "C++ Interface:\n"
  "normalize_u_knots(const NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Normalizes the knot sequence so that the parametric range of the surface in\n"
  " * the U direction is 0 .. 1.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_normalize_u_knots_224_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceEvaluator::get_num_v_knots(void) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_num_v_knots_225(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int NurbsSurfaceEvaluator::get_num_v_knots(void) const
  int return_value = (*(const NurbsSurfaceEvaluator*)local_this).get_num_v_knots();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_num_v_knots_225_comment =
  "C++ Interface:\n"
  "get_num_v_knots(NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of knot values in the surface in the V direction.  This\n"
  " * is based on the number of vertices and the order.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_num_v_knots_225_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceEvaluator::set_v_knot(int i, PN_stdfloat knot)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_set_v_knot_226(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.set_v_knot")) {
    return NULL;
  }
  // 1-void NurbsSurfaceEvaluator::set_v_knot(int i, PN_stdfloat knot)
  int param1;
  float param2;
  static const char *keyword_list[] = {"i", "knot", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_v_knot", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_v_knot((int)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_v_knot(const NurbsSurfaceEvaluator self, int i, float knot)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_set_v_knot_226_comment =
  "C++ Interface:\n"
  "set_v_knot(const NurbsSurfaceEvaluator self, int i, float knot)\n"
  "\n"
  "/**\n"
  " * Sets the value of the nth knot.  Each knot value should be greater than or\n"
  " * equal to the preceding value.  If no knot values are set, a default knot\n"
  " * vector is supplied.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_set_v_knot_226_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat NurbsSurfaceEvaluator::get_v_knot(int i) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_v_knot_227(PyObject *self, PyObject *arg) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat NurbsSurfaceEvaluator::get_v_knot(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = (*(const NurbsSurfaceEvaluator*)local_this).get_v_knot((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_v_knot(NurbsSurfaceEvaluator self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_v_knot_227_comment =
  "C++ Interface:\n"
  "get_v_knot(NurbsSurfaceEvaluator self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the value of the nth knot.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_v_knot_227_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceEvaluator::normalize_v_knots(void)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_normalize_v_knots_229(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.normalize_v_knots")) {
    return NULL;
  }
  // 1-void NurbsSurfaceEvaluator::normalize_v_knots(void)
  (*local_this).normalize_v_knots();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_normalize_v_knots_229_comment =
  "C++ Interface:\n"
  "normalize_v_knots(const NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Normalizes the knot sequence so that the parametric range of the surface in\n"
  " * the U direction is 0 .. 1.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_normalize_v_knots_229_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceEvaluator::get_num_u_segments(void) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_num_u_segments_230(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int NurbsSurfaceEvaluator::get_num_u_segments(void) const
  int return_value = (*(const NurbsSurfaceEvaluator*)local_this).get_num_u_segments();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_num_u_segments_230_comment =
  "C++ Interface:\n"
  "get_num_u_segments(NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of piecewise continuous segments in the surface in the U\n"
  " * direction.  This is based on the knot vector.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_num_u_segments_230_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceEvaluator::get_num_v_segments(void) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_num_v_segments_231(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int NurbsSurfaceEvaluator::get_num_v_segments(void) const
  int return_value = (*(const NurbsSurfaceEvaluator*)local_this).get_num_v_segments();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_num_v_segments_231_comment =
  "C++ Interface:\n"
  "get_num_v_segments(NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of piecewise continuous segments in the surface in the V\n"
  " * direction.  This is based on the knot vector.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_num_v_segments_231_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< NurbsSurfaceResult > NurbsSurfaceEvaluator::evaluate(NodePath const &rel_to = NodePath()) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_evaluate_232(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PointerTo< NurbsSurfaceResult > NurbsSurfaceEvaluator::evaluate(NodePath const &rel_to) const
      PointerTo< NurbsSurfaceResult > return_value = (*(const NurbsSurfaceEvaluator*)local_this).evaluate();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      // Transfer ownership of return_value.
      NurbsSurfaceResult *return_ptr = return_value.p();
      return_value.cheat() = NULL;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_NurbsSurfaceResult, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "rel_to");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'rel_to' (pos 1) not found");
      }
      // 1-PointerTo< NurbsSurfaceResult > NurbsSurfaceEvaluator::evaluate(NodePath const &rel_to) const
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NurbsSurfaceEvaluator.evaluate", true, true);
      if (arg_this != NULL) {
        PointerTo< NurbsSurfaceResult > return_value = (*(const NurbsSurfaceEvaluator*)local_this).evaluate(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        // Transfer ownership of return_value.
        NurbsSurfaceResult *return_ptr = return_value.p();
        return_value.cheat() = NULL;
        return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_NurbsSurfaceResult, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "evaluate() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "evaluate(NurbsSurfaceEvaluator self)\n"
      "evaluate(NurbsSurfaceEvaluator self, const NodePath rel_to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_evaluate_232_comment =
  "C++ Interface:\n"
  "evaluate(NurbsSurfaceEvaluator self)\n"
  "evaluate(NurbsSurfaceEvaluator self, const NodePath rel_to)\n"
  "\n"
  "/**\n"
  " * Returns a NurbsSurfaceResult object that represents the result of applying\n"
  " * the knots to all of the current values of the vertices, transformed into\n"
  " * the indicated coordinate space.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_evaluate_232_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceEvaluator::output(ostream &out) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_output_233(PyObject *self, PyObject *arg) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }
  // 1-void NurbsSurfaceEvaluator::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "NurbsSurfaceEvaluator.output", false, true);
  if (arg_this != NULL) {
    (*(const NurbsSurfaceEvaluator*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(NurbsSurfaceEvaluator self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_output_233_comment =
  "C++ Interface:\n"
  "output(NurbsSurfaceEvaluator self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_output_233_comment = NULL;
#endif

static PyObject *Dtool_NurbsSurfaceEvaluator_u_order_Getter(PyObject *self, void *) {
  const NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int NurbsSurfaceEvaluator::get_u_order(void) const
  int return_value = (*(const NurbsSurfaceEvaluator*)local_this).get_u_order();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_NurbsSurfaceEvaluator_u_order_Setter(PyObject *self, PyObject *arg, void *) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.u_order")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete u_order attribute");
    return -1;
  }
  // 1-inline void NurbsSurfaceEvaluator::set_u_order(int u_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_u_order((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_u_order(const NurbsSurfaceEvaluator self, int u_order)\n");
  }
  return -1;
}

static PyObject *Dtool_NurbsSurfaceEvaluator_v_order_Getter(PyObject *self, void *) {
  const NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int NurbsSurfaceEvaluator::get_v_order(void) const
  int return_value = (*(const NurbsSurfaceEvaluator*)local_this).get_v_order();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_NurbsSurfaceEvaluator_v_order_Setter(PyObject *self, PyObject *arg, void *) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.v_order")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete v_order attribute");
    return -1;
  }
  // 1-inline void NurbsSurfaceEvaluator::set_v_order(int v_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_v_order((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_v_order(const NurbsSurfaceEvaluator self, int v_order)\n");
  }
  return -1;
}

/**
 * sequence length function for property NurbsSurfaceEvaluator::u_knots
 */
static Py_ssize_t Dtool_NurbsSurfaceEvaluator_u_knots_Len(PyObject *self) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_u_knots();
}

/**
 * sequence getter for property NurbsSurfaceEvaluator::u_knots
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_u_knots_Getitem(PyObject *self, Py_ssize_t index) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_u_knots()) {
    PyErr_SetString(PyExc_IndexError, "NurbsSurfaceEvaluator.u_knots[] index out of range");
    return NULL;
  }
  // 1-PN_stdfloat NurbsSurfaceEvaluator::get_u_knot(int i) const
  PN_stdfloat return_value = (*(const NurbsSurfaceEvaluator*)local_this).get_u_knot(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_u_knot(NurbsSurfaceEvaluator self, index)\n");
  }
}

static int Dtool_NurbsSurfaceEvaluator_u_knots_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.u_knots")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete u_knots[] attribute");
    return -1;
  }
  // 1-void NurbsSurfaceEvaluator::set_u_knot(int i, PN_stdfloat knot)
  if (PyNumber_Check(arg)) {
    (*local_this).set_u_knot(index, (PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_u_knot(const NurbsSurfaceEvaluator self, index, float knot)\n");
  }
  return -1;
}

static PyObject *Dtool_NurbsSurfaceEvaluator_u_knots_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_NurbsSurfaceEvaluator_u_knots_Len;
  wrap->_getitem_func = &Dtool_NurbsSurfaceEvaluator_u_knots_Getitem;
  wrap->_setitem_func = &Dtool_NurbsSurfaceEvaluator_u_knots_Setitem;
  return (PyObject *)wrap;
}

/**
 * sequence length function for property NurbsSurfaceEvaluator::v_knots
 */
static Py_ssize_t Dtool_NurbsSurfaceEvaluator_v_knots_Len(PyObject *self) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_v_knots();
}

/**
 * sequence getter for property NurbsSurfaceEvaluator::v_knots
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_v_knots_Getitem(PyObject *self, Py_ssize_t index) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_v_knots()) {
    PyErr_SetString(PyExc_IndexError, "NurbsSurfaceEvaluator.v_knots[] index out of range");
    return NULL;
  }
  // 1-PN_stdfloat NurbsSurfaceEvaluator::get_v_knot(int i) const
  PN_stdfloat return_value = (*(const NurbsSurfaceEvaluator*)local_this).get_v_knot(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_v_knot(NurbsSurfaceEvaluator self, index)\n");
  }
}

static int Dtool_NurbsSurfaceEvaluator_v_knots_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.v_knots")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete v_knots[] attribute");
    return -1;
  }
  // 1-void NurbsSurfaceEvaluator::set_v_knot(int i, PN_stdfloat knot)
  if (PyNumber_Check(arg)) {
    (*local_this).set_v_knot(index, (PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_v_knot(const NurbsSurfaceEvaluator self, index, float knot)\n");
  }
  return -1;
}

static PyObject *Dtool_NurbsSurfaceEvaluator_v_knots_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_NurbsSurfaceEvaluator_v_knots_Len;
  wrap->_getitem_func = &Dtool_NurbsSurfaceEvaluator_v_knots_Getitem;
  wrap->_setitem_func = &Dtool_NurbsSurfaceEvaluator_v_knots_Setitem;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * NurbsSurfaceEvaluator::NurbsSurfaceEvaluator(void)
 * inline NurbsSurfaceEvaluator::NurbsSurfaceEvaluator(NurbsSurfaceEvaluator const &) = default
 */
static int Dtool_Init_NurbsSurfaceEvaluator(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-NurbsSurfaceEvaluator::NurbsSurfaceEvaluator(void)
      NurbsSurfaceEvaluator *return_value = new NurbsSurfaceEvaluator();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NurbsSurfaceEvaluator, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline NurbsSurfaceEvaluator::NurbsSurfaceEvaluator(NurbsSurfaceEvaluator const &) = default
      NurbsSurfaceEvaluator const *arg_this = (NurbsSurfaceEvaluator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NurbsSurfaceEvaluator, 0, "NurbsSurfaceEvaluator.NurbsSurfaceEvaluator", true, true);
      if (arg_this != NULL) {
        NurbsSurfaceEvaluator *return_value = new NurbsSurfaceEvaluator(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NurbsSurfaceEvaluator, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "NurbsSurfaceEvaluator() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NurbsSurfaceEvaluator()\n"
      "NurbsSurfaceEvaluator(const NurbsSurfaceEvaluator param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NurbsSurfaceEvaluator_get_u_knots(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_u_knots();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NurbsSurfaceEvaluator_get_u_knot_222(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NurbsSurfaceEvaluator_get_v_knots(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_v_knots();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NurbsSurfaceEvaluator_get_v_knot_227(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_NurbsSurfaceEvaluator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_NurbsSurfaceEvaluator) {
    printf("NurbsSurfaceEvaluator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  NurbsSurfaceEvaluator *local_this = (NurbsSurfaceEvaluator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_NurbsSurfaceEvaluator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_NurbsSurfaceEvaluator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_NurbsSurfaceEvaluator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (NurbsSurfaceEvaluator*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class RopeNode
 */
/**
 * Python function wrapper for:
 * inline void RopeNode::set_curve(NurbsCurveEvaluator *curve)
 */
static PyObject *Dtool_RopeNode_set_curve_244(PyObject *self, PyObject *arg) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_curve")) {
    return NULL;
  }
  // 1-inline void RopeNode::set_curve(NurbsCurveEvaluator *curve)
  NurbsCurveEvaluator *arg_this = (NurbsCurveEvaluator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NurbsCurveEvaluator, 1, "RopeNode.set_curve", false, true);
  if (arg_this != NULL) {
    (*local_this).set_curve(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_curve(const RopeNode self, NurbsCurveEvaluator curve)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_curve_244_comment =
  "C++ Interface:\n"
  "set_curve(const RopeNode self, NurbsCurveEvaluator curve)\n"
  "\n"
  "/**\n"
  " * Sets the particular curve represented by the RopeNode.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_curve_244_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NurbsCurveEvaluator *RopeNode::get_curve(void) const
 */
static PyObject *Dtool_RopeNode_get_curve_245(PyObject *self, PyObject *) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NurbsCurveEvaluator *RopeNode::get_curve(void) const
  NurbsCurveEvaluator *return_value = (*(const RopeNode*)local_this).get_curve();
  if (return_value != (NurbsCurveEvaluator *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (NurbsCurveEvaluator *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NurbsCurveEvaluator, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_curve_245_comment =
  "C++ Interface:\n"
  "get_curve(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the curve represented by the RopeNode.\n"
  " */";
#else
static const char *Dtool_RopeNode_get_curve_245_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_render_mode(RopeNode::RenderMode render_mode)
 */
static PyObject *Dtool_RopeNode_set_render_mode_246(PyObject *self, PyObject *arg) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_render_mode")) {
    return NULL;
  }
  // 1-inline void RopeNode::set_render_mode(RopeNode::RenderMode render_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_render_mode((RopeNode::RenderMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_render_mode(const RopeNode self, int render_mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_render_mode_246_comment =
  "C++ Interface:\n"
  "set_render_mode(const RopeNode self, int render_mode)\n"
  "\n"
  "/**\n"
  " * Specifies the method used to render the rope.  The simplest is RM_thread,\n"
  " * which just draws a one-pixel line segment.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_render_mode_246_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline RopeNode::RenderMode RopeNode::get_render_mode(void) const
 */
static PyObject *Dtool_RopeNode_get_render_mode_247(PyObject *self, PyObject *) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline RopeNode::RenderMode RopeNode::get_render_mode(void) const
  RopeNode::RenderMode return_value = (*(const RopeNode*)local_this).get_render_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_render_mode_247_comment =
  "C++ Interface:\n"
  "get_render_mode(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the method used to render the rope.  See set_render_mode().\n"
  " */";
#else
static const char *Dtool_RopeNode_get_render_mode_247_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_uv_mode(RopeNode::UVMode uv_mode)
 */
static PyObject *Dtool_RopeNode_set_uv_mode_248(PyObject *self, PyObject *arg) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_uv_mode")) {
    return NULL;
  }
  // 1-inline void RopeNode::set_uv_mode(RopeNode::UVMode uv_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_uv_mode((RopeNode::UVMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uv_mode(const RopeNode self, int uv_mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_uv_mode_248_comment =
  "C++ Interface:\n"
  "set_uv_mode(const RopeNode self, int uv_mode)\n"
  "\n"
  "/**\n"
  " * Specifies the algorithm to use to generate UV's for the rope.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_uv_mode_248_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline RopeNode::UVMode RopeNode::get_uv_mode(void) const
 */
static PyObject *Dtool_RopeNode_get_uv_mode_249(PyObject *self, PyObject *) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline RopeNode::UVMode RopeNode::get_uv_mode(void) const
  RopeNode::UVMode return_value = (*(const RopeNode*)local_this).get_uv_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_uv_mode_249_comment =
  "C++ Interface:\n"
  "get_uv_mode(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the algorithm to use to generate UV's for the rope.\n"
  " */";
#else
static const char *Dtool_RopeNode_get_uv_mode_249_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_uv_direction(bool u_dominant)
 */
static PyObject *Dtool_RopeNode_set_uv_direction_250(PyObject *self, PyObject *arg) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_uv_direction")) {
    return NULL;
  }
  // 1-inline void RopeNode::set_uv_direction(bool u_dominant)
  (*local_this).set_uv_direction((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uv_direction(const RopeNode self, bool u_dominant)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_uv_direction_250_comment =
  "C++ Interface:\n"
  "set_uv_direction(const RopeNode self, bool u_dominant)\n"
  "\n"
  "/**\n"
  " * Specify true to vary the U coordinate down the length of the rope, or false\n"
  " * to vary the V coordinate.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_uv_direction_250_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool RopeNode::get_uv_direction(void) const
 */
static PyObject *Dtool_RopeNode_get_uv_direction_251(PyObject *self, PyObject *) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool RopeNode::get_uv_direction(void) const
  bool return_value = (*(const RopeNode*)local_this).get_uv_direction();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_uv_direction_251_comment =
  "C++ Interface:\n"
  "get_uv_direction(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the rope runs down the U coordinate of the texture, or\n"
  " * false if it runs down the V coordinate.\n"
  " */";
#else
static const char *Dtool_RopeNode_get_uv_direction_251_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_uv_scale(PN_stdfloat scale)
 */
static PyObject *Dtool_RopeNode_set_uv_scale_252(PyObject *self, PyObject *arg) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_uv_scale")) {
    return NULL;
  }
  // 1-inline void RopeNode::set_uv_scale(PN_stdfloat scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_uv_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uv_scale(const RopeNode self, float scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_uv_scale_252_comment =
  "C++ Interface:\n"
  "set_uv_scale(const RopeNode self, float scale)\n"
  "\n"
  "/**\n"
  " * Specifies an additional scaling factor to apply to generated UV's along the\n"
  " * rope.  This scale factor is applied in whichever direction is along the\n"
  " * rope, as specified by set_uv_direction().\n"
  " */";
#else
static const char *Dtool_RopeNode_set_uv_scale_252_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat RopeNode::get_uv_scale(void) const
 */
static PyObject *Dtool_RopeNode_get_uv_scale_253(PyObject *self, PyObject *) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat RopeNode::get_uv_scale(void) const
  PN_stdfloat return_value = (*(const RopeNode*)local_this).get_uv_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_uv_scale_253_comment =
  "C++ Interface:\n"
  "get_uv_scale(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the scaling factor to apply to generated UV's for the rope.\n"
  " */";
#else
static const char *Dtool_RopeNode_get_uv_scale_253_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_normal_mode(RopeNode::NormalMode normal_mode)
 */
static PyObject *Dtool_RopeNode_set_normal_mode_254(PyObject *self, PyObject *arg) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_normal_mode")) {
    return NULL;
  }
  // 1-inline void RopeNode::set_normal_mode(RopeNode::NormalMode normal_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_normal_mode((RopeNode::NormalMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_normal_mode(const RopeNode self, int normal_mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_normal_mode_254_comment =
  "C++ Interface:\n"
  "set_normal_mode(const RopeNode self, int normal_mode)\n"
  "\n"
  "/**\n"
  " * Specifies the kind of normals to generate for the rope.  This is only\n"
  " * applicable when the RenderMode is set to RM_tube; in the other render\n"
  " * modes, normals are never generated.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_normal_mode_254_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline RopeNode::NormalMode RopeNode::get_normal_mode(void) const
 */
static PyObject *Dtool_RopeNode_get_normal_mode_255(PyObject *self, PyObject *) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline RopeNode::NormalMode RopeNode::get_normal_mode(void) const
  RopeNode::NormalMode return_value = (*(const RopeNode*)local_this).get_normal_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_normal_mode_255_comment =
  "C++ Interface:\n"
  "get_normal_mode(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the kind of normals to generate for the rope.  This is only\n"
  " * applicable when the RenderMode is set to RM_tube.\n"
  " */";
#else
static const char *Dtool_RopeNode_get_normal_mode_255_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_tube_up(LVector3 const &tube_up)
 */
static PyObject *Dtool_RopeNode_set_tube_up_256(PyObject *self, PyObject *arg) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_tube_up")) {
    return NULL;
  }
  // 1-inline void RopeNode::set_tube_up(LVector3 const &tube_up)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "RopeNode.set_tube_up", "LVector3f");
  }
  (*local_this).set_tube_up(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tube_up(const RopeNode self, const LVector3f tube_up)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_tube_up_256_comment =
  "C++ Interface:\n"
  "set_tube_up(const RopeNode self, const LVector3f tube_up)\n"
  "\n"
  "/**\n"
  " * Specifies a normal vector, generally perpendicular to the main axis of the\n"
  " * starting point of the curve, that controls the \"top\" of the curve, when\n"
  " * RenderMode is RM_tube.  This is used to orient the vertices that make up\n"
  " * the tube.  If this vector is too nearly parallel with the starting\n"
  " * direction of the curve, there may be a tendency for the whole tube to\n"
  " * gimble-lock around its primary axis.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_tube_up_256_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 const &RopeNode::get_tube_up(void) const
 */
static PyObject *Dtool_RopeNode_get_tube_up_257(PyObject *self, PyObject *) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3 const &RopeNode::get_tube_up(void) const
  LVector3 const *return_value = &((*(const RopeNode*)local_this).get_tube_up());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_tube_up_257_comment =
  "C++ Interface:\n"
  "get_tube_up(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the normal vector used to control the \"top\" of the curve, when\n"
  " * RenderMode is RM_tube.  See set_tube_up().\n"
  " */";
#else
static const char *Dtool_RopeNode_get_tube_up_257_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_use_vertex_color(bool flag)
 */
static PyObject *Dtool_RopeNode_set_use_vertex_color_258(PyObject *self, PyObject *arg) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_use_vertex_color")) {
    return NULL;
  }
  // 1-inline void RopeNode::set_use_vertex_color(bool flag)
  (*local_this).set_use_vertex_color((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_use_vertex_color(const RopeNode self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_use_vertex_color_258_comment =
  "C++ Interface:\n"
  "set_use_vertex_color(const RopeNode self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the \"use vertex color\" flag.  When this is true, the R, G, B, A vertex\n"
  " * color is assumed to be stored as the dimensions n + 0, n + 1, n + 2, n + 3,\n"
  " * respectively, of the extended vertex values, where n is the value returned\n"
  " * by get_vertex_color_dimension().  Use\n"
  " * NurbsCurveEvaluator::set_extended_vertex() to set these values.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_use_vertex_color_258_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool RopeNode::get_use_vertex_color(void) const
 */
static PyObject *Dtool_RopeNode_get_use_vertex_color_259(PyObject *self, PyObject *) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool RopeNode::get_use_vertex_color(void) const
  bool return_value = (*(const RopeNode*)local_this).get_use_vertex_color();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_use_vertex_color_259_comment =
  "C++ Interface:\n"
  "get_use_vertex_color(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the \"use vertex color\" flag.  See set_use_vertex_color().\n"
  " */";
#else
static const char *Dtool_RopeNode_get_use_vertex_color_259_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline int RopeNode::get_vertex_color_dimension(void)
 */
static PyObject *Dtool_RopeNode_get_vertex_color_dimension_260(PyObject *, PyObject *) {
  // 1-static inline int RopeNode::get_vertex_color_dimension(void)
  int return_value = RopeNode::get_vertex_color_dimension();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_vertex_color_dimension_260_comment =
  "C++ Interface:\n"
  "get_vertex_color_dimension()\n"
  "\n"
  "/**\n"
  " * Returns the numeric extended dimension in which the color components should\n"
  " * be found.  See NurbsCurveEvaluator::set_extended_vertex().\n"
  " *\n"
  " * The color components will be expected at (n, n + 1, n + 2, n + 3).\n"
  " */";
#else
static const char *Dtool_RopeNode_get_vertex_color_dimension_260_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_num_subdiv(int num_subdiv)
 */
static PyObject *Dtool_RopeNode_set_num_subdiv_261(PyObject *self, PyObject *arg) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_num_subdiv")) {
    return NULL;
  }
  // 1-inline void RopeNode::set_num_subdiv(int num_subdiv)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_num_subdiv((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_subdiv(const RopeNode self, int num_subdiv)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_num_subdiv_261_comment =
  "C++ Interface:\n"
  "set_num_subdiv(const RopeNode self, int num_subdiv)\n"
  "\n"
  "/**\n"
  " * Specifies the number of subdivisions per cubic segment (that is, per unique\n"
  " * knot value) to draw in a fixed uniform tesselation of the curve.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_num_subdiv_261_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int RopeNode::get_num_subdiv(void) const
 */
static PyObject *Dtool_RopeNode_get_num_subdiv_262(PyObject *self, PyObject *) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int RopeNode::get_num_subdiv(void) const
  int return_value = (*(const RopeNode*)local_this).get_num_subdiv();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_num_subdiv_262_comment =
  "C++ Interface:\n"
  "get_num_subdiv(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of subdivisions per cubic segment to draw.  See\n"
  " * set_num_subdiv().\n"
  " */";
#else
static const char *Dtool_RopeNode_get_num_subdiv_262_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_num_slices(int num_slices)
 */
static PyObject *Dtool_RopeNode_set_num_slices_263(PyObject *self, PyObject *arg) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_num_slices")) {
    return NULL;
  }
  // 1-inline void RopeNode::set_num_slices(int num_slices)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_num_slices((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_slices(const RopeNode self, int num_slices)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_num_slices_263_comment =
  "C++ Interface:\n"
  "set_num_slices(const RopeNode self, int num_slices)\n"
  "\n"
  "/**\n"
  " * Specifies the number of radial subdivisions to make if RenderMode is\n"
  " * RM_tube.  It is ignored in the other render modes.\n"
  " *\n"
  " * Increasing this number increases the roundness of a cross-section of the\n"
  " * tube.  The minimum value for a dimensional tube is 3; setting it to 2 will\n"
  " * get you a thin piece of tape (which is similar to RM_billboard, except it\n"
  " * won't rotate to face the camera).\n"
  " */";
#else
static const char *Dtool_RopeNode_set_num_slices_263_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int RopeNode::get_num_slices(void) const
 */
static PyObject *Dtool_RopeNode_get_num_slices_264(PyObject *self, PyObject *) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int RopeNode::get_num_slices(void) const
  int return_value = (*(const RopeNode*)local_this).get_num_slices();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_num_slices_264_comment =
  "C++ Interface:\n"
  "get_num_slices(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of radial subdivisions to make if RenderMode is RM_tube.\n"
  " * It is ignored in the other render modes.  See set_num_slices().\n"
  " */";
#else
static const char *Dtool_RopeNode_get_num_slices_264_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_use_vertex_thickness(bool flag)
 */
static PyObject *Dtool_RopeNode_set_use_vertex_thickness_265(PyObject *self, PyObject *arg) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_use_vertex_thickness")) {
    return NULL;
  }
  // 1-inline void RopeNode::set_use_vertex_thickness(bool flag)
  (*local_this).set_use_vertex_thickness((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_use_vertex_thickness(const RopeNode self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_use_vertex_thickness_265_comment =
  "C++ Interface:\n"
  "set_use_vertex_thickness(const RopeNode self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the \"use vertex thickness\" flag.  When this is true, the vertex\n"
  " * thickness is assumed to be stored as the dimension\n"
  " * get_vertex_thickness_dimension(), of the extended vertex values.  Use\n"
  " * NurbsCurveEvaluator::set_extended_vertex() to set these values.\n"
  " *\n"
  " * In this mode, the overall thickness is also applied as a scale to the\n"
  " * vertex thickness.  Not all render modes support vertex thickness.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_use_vertex_thickness_265_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool RopeNode::get_use_vertex_thickness(void) const
 */
static PyObject *Dtool_RopeNode_get_use_vertex_thickness_266(PyObject *self, PyObject *) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool RopeNode::get_use_vertex_thickness(void) const
  bool return_value = (*(const RopeNode*)local_this).get_use_vertex_thickness();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_use_vertex_thickness_266_comment =
  "C++ Interface:\n"
  "get_use_vertex_thickness(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the \"use vertex thickness\" flag.  See set_use_vertex_thickness().\n"
  " */";
#else
static const char *Dtool_RopeNode_get_use_vertex_thickness_266_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline int RopeNode::get_vertex_thickness_dimension(void)
 */
static PyObject *Dtool_RopeNode_get_vertex_thickness_dimension_267(PyObject *, PyObject *) {
  // 1-static inline int RopeNode::get_vertex_thickness_dimension(void)
  int return_value = RopeNode::get_vertex_thickness_dimension();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_vertex_thickness_dimension_267_comment =
  "C++ Interface:\n"
  "get_vertex_thickness_dimension()\n"
  "\n"
  "/**\n"
  " * Returns the numeric extended dimension in which the thickness component\n"
  " * should be found.  See NurbsCurveEvaluator::set_extended_vertex().\n"
  " */";
#else
static const char *Dtool_RopeNode_get_vertex_thickness_dimension_267_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_thickness(PN_stdfloat thickness)
 */
static PyObject *Dtool_RopeNode_set_thickness_268(PyObject *self, PyObject *arg) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_thickness")) {
    return NULL;
  }
  // 1-inline void RopeNode::set_thickness(PN_stdfloat thickness)
  if (PyNumber_Check(arg)) {
    (*local_this).set_thickness((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_thickness(const RopeNode self, float thickness)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_thickness_268_comment =
  "C++ Interface:\n"
  "set_thickness(const RopeNode self, float thickness)\n"
  "\n"
  "/**\n"
  " * Specifies the thickness of the rope, in pixels or in spatial units,\n"
  " * depending on the render mode.  See set_render_mode().\n"
  " *\n"
  " * The thickness may also be specified on a per-vertex basis.  See\n"
  " * set_use_vertex_thickness().\n"
  " */";
#else
static const char *Dtool_RopeNode_set_thickness_268_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat RopeNode::get_thickness(void) const
 */
static PyObject *Dtool_RopeNode_get_thickness_269(PyObject *self, PyObject *) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat RopeNode::get_thickness(void) const
  PN_stdfloat return_value = (*(const RopeNode*)local_this).get_thickness();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_thickness_269_comment =
  "C++ Interface:\n"
  "get_thickness(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the thickness of the rope.  See set_thickness().\n"
  " */";
#else
static const char *Dtool_RopeNode_get_thickness_269_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_matrix(LMatrix4 const &matrix)
 */
static PyObject *Dtool_RopeNode_set_matrix_270(PyObject *self, PyObject *arg) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_matrix")) {
    return NULL;
  }
  // 1-inline void RopeNode::set_matrix(LMatrix4 const &matrix)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "RopeNode.set_matrix", "LMatrix4f");
  }
  (*local_this).set_matrix(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_matrix(const RopeNode self, const LMatrix4f matrix)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_matrix_270_comment =
  "C++ Interface:\n"
  "set_matrix(const RopeNode self, const LMatrix4f matrix)\n"
  "\n"
  "/**\n"
  " * Specifies an optional matrix which is used to transform each control vertex\n"
  " * after it has been transformed into the RopeNode's coordinate space, but\n"
  " * before the polygon vertices are generated.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_matrix_270_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::clear_matrix(void)
 */
static PyObject *Dtool_RopeNode_clear_matrix_271(PyObject *self, PyObject *) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.clear_matrix")) {
    return NULL;
  }
  // 1-inline void RopeNode::clear_matrix(void)
  (*local_this).clear_matrix();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_clear_matrix_271_comment =
  "C++ Interface:\n"
  "clear_matrix(const RopeNode self)\n"
  "\n"
  "/**\n"
  " * Resets the node's matrix to identity.  See set_matrix().\n"
  " */";
#else
static const char *Dtool_RopeNode_clear_matrix_271_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool RopeNode::has_matrix(void) const
 */
static PyObject *Dtool_RopeNode_has_matrix_272(PyObject *self, PyObject *) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool RopeNode::has_matrix(void) const
  bool return_value = (*(const RopeNode*)local_this).has_matrix();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_has_matrix_272_comment =
  "C++ Interface:\n"
  "has_matrix(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the node has a matrix set, false otherwise.  See\n"
  " * set_matrix().\n"
  " */";
#else
static const char *Dtool_RopeNode_has_matrix_272_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &RopeNode::get_matrix(void) const
 */
static PyObject *Dtool_RopeNode_get_matrix_273(PyObject *self, PyObject *) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4 const &RopeNode::get_matrix(void) const
  LMatrix4 const *return_value = &((*(const RopeNode*)local_this).get_matrix());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_matrix_273_comment =
  "C++ Interface:\n"
  "get_matrix(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the optional matrix which is used to transform each control vertex\n"
  " * after it has been transformed into the RopeNode's coordinate space, but\n"
  " * before the polygon vertices are generated.\n"
  " */";
#else
static const char *Dtool_RopeNode_get_matrix_273_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void RopeNode::reset_bound(NodePath const &rel_to)
 */
static PyObject *Dtool_RopeNode_reset_bound_274(PyObject *self, PyObject *arg) {
  RopeNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.reset_bound")) {
    return NULL;
  }
  // 1-void RopeNode::reset_bound(NodePath const &rel_to)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "RopeNode.reset_bound", true, true);
  if (arg_this != NULL) {
    (*local_this).reset_bound(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reset_bound(const RopeNode self, const NodePath rel_to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_reset_bound_274_comment =
  "C++ Interface:\n"
  "reset_bound(const RopeNode self, const NodePath rel_to)\n"
  "\n"
  "/**\n"
  " * Recomputes the bounding volume.  This is normally called automatically, but\n"
  " * it must occasionally be called explicitly when the curve has changed\n"
  " * properties outside of this node's knowledge.\n"
  " */";
#else
static const char *Dtool_RopeNode_reset_bound_274_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle RopeNode::get_class_type(void)
 */
static PyObject *Dtool_RopeNode_get_class_type_275(PyObject *, PyObject *) {
  // 1-static TypeHandle RopeNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(RopeNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_class_type_275_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_RopeNode_get_class_type_275_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * RopeNode::RopeNode(std::string const &name)
 */
static int Dtool_Init_RopeNode(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "RopeNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-RopeNode::RopeNode(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    RopeNode *return_value = new RopeNode(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RopeNode, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "RopeNode(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_RopeNode(PyObject *args, CPT(RopeNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_RopeNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-RopeNode::RopeNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      RopeNode *return_value = new RopeNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_RopeNode(PyObject *args, PT(RopeNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_RopeNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-RopeNode::RopeNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      RopeNode *return_value = new RopeNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_RopeNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_RopeNode) {
    printf("RopeNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  RopeNode *local_this = (RopeNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_RopeNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_RopeNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_RopeNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (RopeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (RopeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RopeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (RopeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (RopeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (RopeNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class SheetNode
 */
/**
 * Python function wrapper for:
 * inline void SheetNode::set_surface(NurbsSurfaceEvaluator *surface)
 */
static PyObject *Dtool_SheetNode_set_surface_279(PyObject *self, PyObject *arg) {
  SheetNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SheetNode, (void **)&local_this, "SheetNode.set_surface")) {
    return NULL;
  }
  // 1-inline void SheetNode::set_surface(NurbsSurfaceEvaluator *surface)
  NurbsSurfaceEvaluator *arg_this = (NurbsSurfaceEvaluator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NurbsSurfaceEvaluator, 1, "SheetNode.set_surface", false, true);
  if (arg_this != NULL) {
    (*local_this).set_surface(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_surface(const SheetNode self, NurbsSurfaceEvaluator surface)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_set_surface_279_comment =
  "C++ Interface:\n"
  "set_surface(const SheetNode self, NurbsSurfaceEvaluator surface)\n"
  "\n"
  "/**\n"
  " * Sets the particular surface represented by the SheetNode.\n"
  " */";
#else
static const char *Dtool_SheetNode_set_surface_279_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NurbsSurfaceEvaluator *SheetNode::get_surface(void) const
 */
static PyObject *Dtool_SheetNode_get_surface_280(PyObject *self, PyObject *) {
  SheetNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SheetNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NurbsSurfaceEvaluator *SheetNode::get_surface(void) const
  NurbsSurfaceEvaluator *return_value = (*(const SheetNode*)local_this).get_surface();
  if (return_value != (NurbsSurfaceEvaluator *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (NurbsSurfaceEvaluator *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NurbsSurfaceEvaluator, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_get_surface_280_comment =
  "C++ Interface:\n"
  "get_surface(SheetNode self)\n"
  "\n"
  "/**\n"
  " * Returns the surface represented by the SheetNode.\n"
  " */";
#else
static const char *Dtool_SheetNode_get_surface_280_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SheetNode::set_use_vertex_color(bool flag)
 */
static PyObject *Dtool_SheetNode_set_use_vertex_color_281(PyObject *self, PyObject *arg) {
  SheetNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SheetNode, (void **)&local_this, "SheetNode.set_use_vertex_color")) {
    return NULL;
  }
  // 1-inline void SheetNode::set_use_vertex_color(bool flag)
  (*local_this).set_use_vertex_color((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_use_vertex_color(const SheetNode self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_set_use_vertex_color_281_comment =
  "C++ Interface:\n"
  "set_use_vertex_color(const SheetNode self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the \"use vertex color\" flag.  When this is true, the R, G, B, A vertex\n"
  " * color is assumed to be stored as the dimensions 0, 1, 2, 3, respectively,\n"
  " * of the extended vertex values.  Use\n"
  " * NurbsCurveEvaluator::set_extended_vertex() to set these values.\n"
  " */";
#else
static const char *Dtool_SheetNode_set_use_vertex_color_281_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SheetNode::get_use_vertex_color(void) const
 */
static PyObject *Dtool_SheetNode_get_use_vertex_color_282(PyObject *self, PyObject *) {
  SheetNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SheetNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool SheetNode::get_use_vertex_color(void) const
  bool return_value = (*(const SheetNode*)local_this).get_use_vertex_color();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_get_use_vertex_color_282_comment =
  "C++ Interface:\n"
  "get_use_vertex_color(SheetNode self)\n"
  "\n"
  "/**\n"
  " * Returns the \"use vertex color\" flag.  See set_use_vertex_color().\n"
  " */";
#else
static const char *Dtool_SheetNode_get_use_vertex_color_282_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SheetNode::set_num_u_subdiv(int num_u_subdiv)
 */
static PyObject *Dtool_SheetNode_set_num_u_subdiv_283(PyObject *self, PyObject *arg) {
  SheetNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SheetNode, (void **)&local_this, "SheetNode.set_num_u_subdiv")) {
    return NULL;
  }
  // 1-inline void SheetNode::set_num_u_subdiv(int num_u_subdiv)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_num_u_subdiv((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_u_subdiv(const SheetNode self, int num_u_subdiv)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_set_num_u_subdiv_283_comment =
  "C++ Interface:\n"
  "set_num_u_subdiv(const SheetNode self, int num_u_subdiv)\n"
  "\n"
  "/**\n"
  " * Specifies the number of subdivisions per cubic segment (that is, per unique\n"
  " * knot value) to draw in a fixed uniform tesselation of the surface in the U\n"
  " * direction.\n"
  " */";
#else
static const char *Dtool_SheetNode_set_num_u_subdiv_283_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SheetNode::get_num_u_subdiv(void) const
 */
static PyObject *Dtool_SheetNode_get_num_u_subdiv_284(PyObject *self, PyObject *) {
  SheetNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SheetNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SheetNode::get_num_u_subdiv(void) const
  int return_value = (*(const SheetNode*)local_this).get_num_u_subdiv();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_get_num_u_subdiv_284_comment =
  "C++ Interface:\n"
  "get_num_u_subdiv(SheetNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of subdivisions per cubic segment to draw in the U\n"
  " * direction.  See set_num_u_subdiv().\n"
  " */";
#else
static const char *Dtool_SheetNode_get_num_u_subdiv_284_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SheetNode::set_num_v_subdiv(int num_v_subdiv)
 */
static PyObject *Dtool_SheetNode_set_num_v_subdiv_285(PyObject *self, PyObject *arg) {
  SheetNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SheetNode, (void **)&local_this, "SheetNode.set_num_v_subdiv")) {
    return NULL;
  }
  // 1-inline void SheetNode::set_num_v_subdiv(int num_v_subdiv)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_num_v_subdiv((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_v_subdiv(const SheetNode self, int num_v_subdiv)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_set_num_v_subdiv_285_comment =
  "C++ Interface:\n"
  "set_num_v_subdiv(const SheetNode self, int num_v_subdiv)\n"
  "\n"
  "/**\n"
  " * Specifies the number of subdivisions per cubic segment (that is, per unique\n"
  " * knot value) to draw in a fixed uniform tesselation of the surface in the V\n"
  " * direction.\n"
  " */";
#else
static const char *Dtool_SheetNode_set_num_v_subdiv_285_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SheetNode::get_num_v_subdiv(void) const
 */
static PyObject *Dtool_SheetNode_get_num_v_subdiv_286(PyObject *self, PyObject *) {
  SheetNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SheetNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SheetNode::get_num_v_subdiv(void) const
  int return_value = (*(const SheetNode*)local_this).get_num_v_subdiv();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_get_num_v_subdiv_286_comment =
  "C++ Interface:\n"
  "get_num_v_subdiv(SheetNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of subdivisions per cubic segment to draw in the V\n"
  " * direction.  See set_num_v_subdiv().\n"
  " */";
#else
static const char *Dtool_SheetNode_get_num_v_subdiv_286_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void SheetNode::reset_bound(NodePath const &rel_to)
 */
static PyObject *Dtool_SheetNode_reset_bound_287(PyObject *self, PyObject *arg) {
  SheetNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SheetNode, (void **)&local_this, "SheetNode.reset_bound")) {
    return NULL;
  }
  // 1-void SheetNode::reset_bound(NodePath const &rel_to)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "SheetNode.reset_bound", true, true);
  if (arg_this != NULL) {
    (*local_this).reset_bound(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reset_bound(const SheetNode self, const NodePath rel_to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_reset_bound_287_comment =
  "C++ Interface:\n"
  "reset_bound(const SheetNode self, const NodePath rel_to)\n"
  "\n"
  "/**\n"
  " * Recomputes the bounding volume.  This is normally called automatically, but\n"
  " * it must occasionally be called explicitly when the surface has changed\n"
  " * properties outside of this node's knowledge.\n"
  " */";
#else
static const char *Dtool_SheetNode_reset_bound_287_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle SheetNode::get_class_type(void)
 */
static PyObject *Dtool_SheetNode_get_class_type_288(PyObject *, PyObject *) {
  // 1-static TypeHandle SheetNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(SheetNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_get_class_type_288_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SheetNode_get_class_type_288_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * SheetNode::SheetNode(std::string const &name)
 */
static int Dtool_Init_SheetNode(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "SheetNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-SheetNode::SheetNode(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    SheetNode *return_value = new SheetNode(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SheetNode, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SheetNode(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_SheetNode(PyObject *args, CPT(SheetNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SheetNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-SheetNode::SheetNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      SheetNode *return_value = new SheetNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_SheetNode(PyObject *args, PT(SheetNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SheetNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-SheetNode::SheetNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      SheetNode *return_value = new SheetNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_SheetNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SheetNode) {
    printf("SheetNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SheetNode *local_this = (SheetNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SheetNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SheetNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SheetNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (SheetNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (SheetNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SheetNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (SheetNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (SheetNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (SheetNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for ParametricCurve (ParametricCurve)
 */
static PyMethodDef Dtool_Methods_ParametricCurve[] = {
  {"is_valid", &Dtool_ParametricCurve_is_valid_3, METH_NOARGS, (const char *)Dtool_ParametricCurve_is_valid_3_comment},
  {"isValid", &Dtool_ParametricCurve_is_valid_3, METH_NOARGS, (const char *)Dtool_ParametricCurve_is_valid_3_comment},
  {"get_max_t", &Dtool_ParametricCurve_get_max_t_4, METH_NOARGS, (const char *)Dtool_ParametricCurve_get_max_t_4_comment},
  {"getMaxT", &Dtool_ParametricCurve_get_max_t_4, METH_NOARGS, (const char *)Dtool_ParametricCurve_get_max_t_4_comment},
  {"set_curve_type", &Dtool_ParametricCurve_set_curve_type_5, METH_O, (const char *)Dtool_ParametricCurve_set_curve_type_5_comment},
  {"setCurveType", &Dtool_ParametricCurve_set_curve_type_5, METH_O, (const char *)Dtool_ParametricCurve_set_curve_type_5_comment},
  {"get_curve_type", &Dtool_ParametricCurve_get_curve_type_6, METH_NOARGS, (const char *)Dtool_ParametricCurve_get_curve_type_6_comment},
  {"getCurveType", &Dtool_ParametricCurve_get_curve_type_6, METH_NOARGS, (const char *)Dtool_ParametricCurve_get_curve_type_6_comment},
  {"set_num_dimensions", &Dtool_ParametricCurve_set_num_dimensions_7, METH_O, (const char *)Dtool_ParametricCurve_set_num_dimensions_7_comment},
  {"setNumDimensions", &Dtool_ParametricCurve_set_num_dimensions_7, METH_O, (const char *)Dtool_ParametricCurve_set_num_dimensions_7_comment},
  {"get_num_dimensions", &Dtool_ParametricCurve_get_num_dimensions_8, METH_NOARGS, (const char *)Dtool_ParametricCurve_get_num_dimensions_8_comment},
  {"getNumDimensions", &Dtool_ParametricCurve_get_num_dimensions_8, METH_NOARGS, (const char *)Dtool_ParametricCurve_get_num_dimensions_8_comment},
  {"calc_length", (PyCFunction) &Dtool_ParametricCurve_calc_length_9, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_calc_length_9_comment},
  {"calcLength", (PyCFunction) &Dtool_ParametricCurve_calc_length_9, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_calc_length_9_comment},
  {"find_length", (PyCFunction) &Dtool_ParametricCurve_find_length_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_find_length_10_comment},
  {"findLength", (PyCFunction) &Dtool_ParametricCurve_find_length_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_find_length_10_comment},
  {"get_point", (PyCFunction) &Dtool_ParametricCurve_get_point_11, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_get_point_11_comment},
  {"getPoint", (PyCFunction) &Dtool_ParametricCurve_get_point_11, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_get_point_11_comment},
  {"get_tangent", (PyCFunction) &Dtool_ParametricCurve_get_tangent_12, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_get_tangent_12_comment},
  {"getTangent", (PyCFunction) &Dtool_ParametricCurve_get_tangent_12, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_get_tangent_12_comment},
  {"get_pt", (PyCFunction) &Dtool_ParametricCurve_get_pt_13, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_get_pt_13_comment},
  {"getPt", (PyCFunction) &Dtool_ParametricCurve_get_pt_13, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_get_pt_13_comment},
  {"get_2ndtangent", (PyCFunction) &Dtool_ParametricCurve_get_2ndtangent_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_get_2ndtangent_14_comment},
  {"get2ndtangent", (PyCFunction) &Dtool_ParametricCurve_get_2ndtangent_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_get_2ndtangent_14_comment},
  {"adjust_point", (PyCFunction) &Dtool_ParametricCurve_adjust_point_15, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_adjust_point_15_comment},
  {"adjustPoint", (PyCFunction) &Dtool_ParametricCurve_adjust_point_15, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_adjust_point_15_comment},
  {"adjust_tangent", (PyCFunction) &Dtool_ParametricCurve_adjust_tangent_16, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_adjust_tangent_16_comment},
  {"adjustTangent", (PyCFunction) &Dtool_ParametricCurve_adjust_tangent_16, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_adjust_tangent_16_comment},
  {"adjust_pt", (PyCFunction) &Dtool_ParametricCurve_adjust_pt_17, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_adjust_pt_17_comment},
  {"adjustPt", (PyCFunction) &Dtool_ParametricCurve_adjust_pt_17, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_adjust_pt_17_comment},
  {"recompute", &Dtool_ParametricCurve_recompute_18, METH_NOARGS, (const char *)Dtool_ParametricCurve_recompute_18_comment},
  {"stitch", (PyCFunction) &Dtool_ParametricCurve_stitch_19, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_stitch_19_comment},
  {"write_egg", (PyCFunction) &Dtool_ParametricCurve_write_egg_20, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_write_egg_20_comment},
  {"writeEgg", (PyCFunction) &Dtool_ParametricCurve_write_egg_20, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_write_egg_20_comment},
  {"get_class_type", &Dtool_ParametricCurve_get_class_type_21, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParametricCurve_get_class_type_21_comment},
  {"getClassType", &Dtool_ParametricCurve_get_class_type_21, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParametricCurve_get_class_type_21_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ParametricCurve = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParametricCurve = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParametricCurve = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParametricCurve = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParametricCurve = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ParametricCurve",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParametricCurve,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ParametricCurve,
    &Dtool_SequenceMethods_ParametricCurve,
    &Dtool_MappingMethods_ParametricCurve,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParametricCurve,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A virtual base class for parametric curves.  This encapsulates all curves\n"
    " * in 3-d space defined for a single parameter t in the range [0,get_max_t()].\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParametricCurve,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParametricCurve,
    PyType_GenericAlloc,
    Dtool_new_ParametricCurve,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParametricCurve,
  Dtool_UpcastInterface_ParametricCurve,
  Dtool_DowncastInterface_ParametricCurve,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ParametricCurve(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_ParametricCurve._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_ParametricCurve._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParametricCurve) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParametricCurve)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParametricCurve);
  }
}

/**
 * Python method tables for CubicCurveseg (CubicCurveseg)
 */
static PyMethodDef Dtool_Methods_CubicCurveseg[] = {
  {"get_class_type", &Dtool_CubicCurveseg_get_class_type_23, METH_NOARGS | METH_STATIC, (const char *)Dtool_CubicCurveseg_get_class_type_23_comment},
  {"getClassType", &Dtool_CubicCurveseg_get_class_type_23, METH_NOARGS | METH_STATIC, (const char *)Dtool_CubicCurveseg_get_class_type_23_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CubicCurveseg = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CubicCurveseg = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CubicCurveseg = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CubicCurveseg = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CubicCurveseg = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CubicCurveseg",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CubicCurveseg,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CubicCurveseg,
    &Dtool_SequenceMethods_CubicCurveseg,
    &Dtool_MappingMethods_CubicCurveseg,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CubicCurveseg,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A CubicCurveseg is any curve that can be completely described by four\n"
    " * 4-valued basis vectors, one for each dimension in three-space, and one for\n"
    " * the homogeneous coordinate.  This includes Beziers, Hermites, and NURBS.\n"
    " *\n"
    " * This class encapsulates a single curve segment of the cubic curve.\n"
    " * Normally, when we think of Bezier and Hermite curves, we think of a\n"
    " * piecewise collection of such segments.\n"
    " *\n"
    " * Although this class includes methods such as hermite_basis() and\n"
    " * nurbs_basis(), to generate a Hermite and NURBS curve segment, respectively,\n"
    " * only the final basis vectors are stored: the product of the basis matrix of\n"
    " * the corresponding curve type, and its geometry vectors.  This is the\n"
    " * minimum information needed to evaluate the curve.  However, the individual\n"
    " * CV's that were used to compute these basis vectors are not retained; this\n"
    " * might be handled in a subclass (for instance, HermiteCurve).\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CubicCurveseg,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CubicCurveseg,
    PyType_GenericAlloc,
    Dtool_new_CubicCurveseg,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CubicCurveseg,
  Dtool_UpcastInterface_CubicCurveseg,
  Dtool_DowncastInterface_CubicCurveseg,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CubicCurveseg(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParametricCurve(NULL);
    Dtool_CubicCurveseg._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParametricCurve);
    PyObject *dict = PyDict_New();
    Dtool_CubicCurveseg._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CubicCurveseg) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CubicCurveseg)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CubicCurveseg);
  }
}

/**
 * Python method tables for ParametricCurveCollection (ParametricCurveCollection)
 */
static PyMethodDef Dtool_Methods_ParametricCurveCollection[] = {
  {"add_curve", (PyCFunction) &Dtool_ParametricCurveCollection_add_curve_27, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_add_curve_27_comment},
  {"addCurve", (PyCFunction) &Dtool_ParametricCurveCollection_add_curve_27, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_add_curve_27_comment},
  {"add_curves", &Dtool_ParametricCurveCollection_add_curves_28, METH_O, (const char *)Dtool_ParametricCurveCollection_add_curves_28_comment},
  {"addCurves", &Dtool_ParametricCurveCollection_add_curves_28, METH_O, (const char *)Dtool_ParametricCurveCollection_add_curves_28_comment},
  {"remove_curve", &Dtool_ParametricCurveCollection_remove_curve_29, METH_O, (const char *)Dtool_ParametricCurveCollection_remove_curve_29_comment},
  {"removeCurve", &Dtool_ParametricCurveCollection_remove_curve_29, METH_O, (const char *)Dtool_ParametricCurveCollection_remove_curve_29_comment},
  {"set_curve", (PyCFunction) &Dtool_ParametricCurveCollection_set_curve_30, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_set_curve_30_comment},
  {"setCurve", (PyCFunction) &Dtool_ParametricCurveCollection_set_curve_30, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_set_curve_30_comment},
  {"has_curve", &Dtool_ParametricCurveCollection_has_curve_31, METH_O, (const char *)Dtool_ParametricCurveCollection_has_curve_31_comment},
  {"hasCurve", &Dtool_ParametricCurveCollection_has_curve_31, METH_O, (const char *)Dtool_ParametricCurveCollection_has_curve_31_comment},
  {"clear", &Dtool_ParametricCurveCollection_clear_32, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_clear_32_comment},
  {"clear_timewarps", &Dtool_ParametricCurveCollection_clear_timewarps_33, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_clear_timewarps_33_comment},
  {"clearTimewarps", &Dtool_ParametricCurveCollection_clear_timewarps_33, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_clear_timewarps_33_comment},
  {"get_num_curves", &Dtool_ParametricCurveCollection_get_num_curves_34, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_num_curves_34_comment},
  {"getNumCurves", &Dtool_ParametricCurveCollection_get_num_curves_34, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_num_curves_34_comment},
  {"get_curve", &Dtool_ParametricCurveCollection_get_curve_35, METH_O, (const char *)Dtool_ParametricCurveCollection_get_curve_35_comment},
  {"getCurve", &Dtool_ParametricCurveCollection_get_curve_35, METH_O, (const char *)Dtool_ParametricCurveCollection_get_curve_35_comment},
  {"get_xyz_curve", &Dtool_ParametricCurveCollection_get_xyz_curve_37, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_xyz_curve_37_comment},
  {"getXyzCurve", &Dtool_ParametricCurveCollection_get_xyz_curve_37, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_xyz_curve_37_comment},
  {"get_hpr_curve", &Dtool_ParametricCurveCollection_get_hpr_curve_38, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_hpr_curve_38_comment},
  {"getHprCurve", &Dtool_ParametricCurveCollection_get_hpr_curve_38, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_hpr_curve_38_comment},
  {"get_default_curve", &Dtool_ParametricCurveCollection_get_default_curve_39, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_default_curve_39_comment},
  {"getDefaultCurve", &Dtool_ParametricCurveCollection_get_default_curve_39, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_default_curve_39_comment},
  {"get_num_timewarps", &Dtool_ParametricCurveCollection_get_num_timewarps_40, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_num_timewarps_40_comment},
  {"getNumTimewarps", &Dtool_ParametricCurveCollection_get_num_timewarps_40, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_num_timewarps_40_comment},
  {"get_timewarp_curve", &Dtool_ParametricCurveCollection_get_timewarp_curve_41, METH_O, (const char *)Dtool_ParametricCurveCollection_get_timewarp_curve_41_comment},
  {"getTimewarpCurve", &Dtool_ParametricCurveCollection_get_timewarp_curve_41, METH_O, (const char *)Dtool_ParametricCurveCollection_get_timewarp_curve_41_comment},
  {"get_max_t", &Dtool_ParametricCurveCollection_get_max_t_43, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_max_t_43_comment},
  {"getMaxT", &Dtool_ParametricCurveCollection_get_max_t_43, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_max_t_43_comment},
  {"make_even", (PyCFunction) &Dtool_ParametricCurveCollection_make_even_53, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_make_even_53_comment},
  {"makeEven", (PyCFunction) &Dtool_ParametricCurveCollection_make_even_53, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_make_even_53_comment},
  {"face_forward", &Dtool_ParametricCurveCollection_face_forward_54, METH_O, (const char *)Dtool_ParametricCurveCollection_face_forward_54_comment},
  {"faceForward", &Dtool_ParametricCurveCollection_face_forward_54, METH_O, (const char *)Dtool_ParametricCurveCollection_face_forward_54_comment},
  {"reset_max_t", &Dtool_ParametricCurveCollection_reset_max_t_55, METH_O, (const char *)Dtool_ParametricCurveCollection_reset_max_t_55_comment},
  {"resetMaxT", &Dtool_ParametricCurveCollection_reset_max_t_55, METH_O, (const char *)Dtool_ParametricCurveCollection_reset_max_t_55_comment},
  {"evaluate", (PyCFunction) &Dtool_ParametricCurveCollection_evaluate_56, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_evaluate_56_comment},
  {"evaluate_t", &Dtool_ParametricCurveCollection_evaluate_t_57, METH_O, (const char *)Dtool_ParametricCurveCollection_evaluate_t_57_comment},
  {"evaluateT", &Dtool_ParametricCurveCollection_evaluate_t_57, METH_O, (const char *)Dtool_ParametricCurveCollection_evaluate_t_57_comment},
  {"evaluate_xyz", (PyCFunction) &Dtool_ParametricCurveCollection_evaluate_xyz_58, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_evaluate_xyz_58_comment},
  {"evaluateXyz", (PyCFunction) &Dtool_ParametricCurveCollection_evaluate_xyz_58, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_evaluate_xyz_58_comment},
  {"evaluate_hpr", (PyCFunction) &Dtool_ParametricCurveCollection_evaluate_hpr_59, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_evaluate_hpr_59_comment},
  {"evaluateHpr", (PyCFunction) &Dtool_ParametricCurveCollection_evaluate_hpr_59, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_evaluate_hpr_59_comment},
  {"adjust_xyz", (PyCFunction) &Dtool_ParametricCurveCollection_adjust_xyz_60, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_adjust_xyz_60_comment},
  {"adjustXyz", (PyCFunction) &Dtool_ParametricCurveCollection_adjust_xyz_60, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_adjust_xyz_60_comment},
  {"adjust_hpr", (PyCFunction) &Dtool_ParametricCurveCollection_adjust_hpr_61, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_adjust_hpr_61_comment},
  {"adjustHpr", (PyCFunction) &Dtool_ParametricCurveCollection_adjust_hpr_61, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_adjust_hpr_61_comment},
  {"recompute", &Dtool_ParametricCurveCollection_recompute_62, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_recompute_62_comment},
  {"stitch", (PyCFunction) &Dtool_ParametricCurveCollection_stitch_63, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_stitch_63_comment},
  {"output", &Dtool_ParametricCurveCollection_output_64, METH_O, (const char *)Dtool_ParametricCurveCollection_output_64_comment},
  {"write", (PyCFunction) &Dtool_ParametricCurveCollection_write_65, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_write_65_comment},
  {"write_egg", (PyCFunction) &Dtool_ParametricCurveCollection_write_egg_66, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_write_egg_66_comment},
  {"writeEgg", (PyCFunction) &Dtool_ParametricCurveCollection_write_egg_66, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_write_egg_66_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_curves", (PyCFunction) &MakeSeq_ParametricCurveCollection_get_curves, METH_NOARGS, NULL},
  { "getCurves", (PyCFunction) &MakeSeq_ParametricCurveCollection_get_curves, METH_NOARGS, NULL},
  {"get_timewarp_curves", (PyCFunction) &MakeSeq_ParametricCurveCollection_get_timewarp_curves, METH_NOARGS, NULL},
  { "getTimewarpCurves", (PyCFunction) &MakeSeq_ParametricCurveCollection_get_timewarp_curves, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     ParametricCurveCollection
//////////////////
static PyObject *Dtool_Repr_ParametricCurveCollection(PyObject *self) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ParametricCurveCollection
//////////////////
static PyObject *Dtool_Str_ParametricCurveCollection(PyObject *self) {
  ParametricCurveCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_ParametricCurveCollection[] = {
  {(char *)"curves", &Dtool_ParametricCurveCollection_curves_Getter, NULL, NULL, NULL},
  {(char *)"xyz_curve", &Dtool_ParametricCurveCollection_xyz_curve_Getter, NULL, NULL, NULL},
  {(char *)"hpr_curve", &Dtool_ParametricCurveCollection_hpr_curve_Getter, NULL, NULL, NULL},
  {(char *)"default_curve", &Dtool_ParametricCurveCollection_default_curve_Getter, NULL, NULL, NULL},
  {(char *)"timewarp_curves", &Dtool_ParametricCurveCollection_timewarp_curves_Getter, NULL, NULL, NULL},
  {(char *)"max_t", &Dtool_ParametricCurveCollection_max_t_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ParametricCurveCollection = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParametricCurveCollection = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParametricCurveCollection = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParametricCurveCollection = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParametricCurveCollection = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ParametricCurveCollection",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParametricCurveCollection,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_ParametricCurveCollection,
    &Dtool_NumberMethods_ParametricCurveCollection,
    &Dtool_SequenceMethods_ParametricCurveCollection,
    &Dtool_MappingMethods_ParametricCurveCollection,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_ParametricCurveCollection,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParametricCurveCollection,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a set of zero or more ParametricCurves, which may or may not be\n"
    " * related.  If they are related, the set should contain no more than one XYZ\n"
    " * curve, no more than one HPR curve, and zero or more Timewarp curves, which\n"
    " * can then be evaluated as a unit to return a single transformation matrix\n"
    " * for a given unit of time.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParametricCurveCollection,
    0, // tp_members
    Dtool_Properties_ParametricCurveCollection,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParametricCurveCollection,
    PyType_GenericAlloc,
    Dtool_new_ParametricCurveCollection,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParametricCurveCollection,
  Dtool_UpcastInterface_ParametricCurveCollection,
  Dtool_DowncastInterface_ParametricCurveCollection,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ParametricCurveCollection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_ParametricCurveCollection._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_ParametricCurveCollection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParametricCurveCollection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParametricCurveCollection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParametricCurveCollection);
  }
}

/**
 * Python method tables for CurveFitter (CurveFitter)
 */
static PyMethodDef Dtool_Methods_CurveFitter[] = {
  {"reset", &Dtool_CurveFitter_reset_70, METH_NOARGS, (const char *)Dtool_CurveFitter_reset_70_comment},
  {"add_xyz", (PyCFunction) &Dtool_CurveFitter_add_xyz_71, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CurveFitter_add_xyz_71_comment},
  {"addXyz", (PyCFunction) &Dtool_CurveFitter_add_xyz_71, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CurveFitter_add_xyz_71_comment},
  {"add_hpr", (PyCFunction) &Dtool_CurveFitter_add_hpr_72, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CurveFitter_add_hpr_72_comment},
  {"addHpr", (PyCFunction) &Dtool_CurveFitter_add_hpr_72, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CurveFitter_add_hpr_72_comment},
  {"add_xyz_hpr", (PyCFunction) &Dtool_CurveFitter_add_xyz_hpr_73, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CurveFitter_add_xyz_hpr_73_comment},
  {"addXyzHpr", (PyCFunction) &Dtool_CurveFitter_add_xyz_hpr_73, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CurveFitter_add_xyz_hpr_73_comment},
  {"get_num_samples", &Dtool_CurveFitter_get_num_samples_74, METH_NOARGS, (const char *)Dtool_CurveFitter_get_num_samples_74_comment},
  {"getNumSamples", &Dtool_CurveFitter_get_num_samples_74, METH_NOARGS, (const char *)Dtool_CurveFitter_get_num_samples_74_comment},
  {"get_sample_t", &Dtool_CurveFitter_get_sample_t_75, METH_O, (const char *)Dtool_CurveFitter_get_sample_t_75_comment},
  {"getSampleT", &Dtool_CurveFitter_get_sample_t_75, METH_O, (const char *)Dtool_CurveFitter_get_sample_t_75_comment},
  {"get_sample_xyz", &Dtool_CurveFitter_get_sample_xyz_76, METH_O, (const char *)Dtool_CurveFitter_get_sample_xyz_76_comment},
  {"getSampleXyz", &Dtool_CurveFitter_get_sample_xyz_76, METH_O, (const char *)Dtool_CurveFitter_get_sample_xyz_76_comment},
  {"get_sample_hpr", &Dtool_CurveFitter_get_sample_hpr_77, METH_O, (const char *)Dtool_CurveFitter_get_sample_hpr_77_comment},
  {"getSampleHpr", &Dtool_CurveFitter_get_sample_hpr_77, METH_O, (const char *)Dtool_CurveFitter_get_sample_hpr_77_comment},
  {"get_sample_tangent", &Dtool_CurveFitter_get_sample_tangent_78, METH_O, (const char *)Dtool_CurveFitter_get_sample_tangent_78_comment},
  {"getSampleTangent", &Dtool_CurveFitter_get_sample_tangent_78, METH_O, (const char *)Dtool_CurveFitter_get_sample_tangent_78_comment},
  {"remove_samples", (PyCFunction) &Dtool_CurveFitter_remove_samples_79, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CurveFitter_remove_samples_79_comment},
  {"removeSamples", (PyCFunction) &Dtool_CurveFitter_remove_samples_79, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CurveFitter_remove_samples_79_comment},
  {"sample", (PyCFunction) &Dtool_CurveFitter_sample_80, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CurveFitter_sample_80_comment},
  {"wrap_hpr", &Dtool_CurveFitter_wrap_hpr_81, METH_NOARGS, (const char *)Dtool_CurveFitter_wrap_hpr_81_comment},
  {"wrapHpr", &Dtool_CurveFitter_wrap_hpr_81, METH_NOARGS, (const char *)Dtool_CurveFitter_wrap_hpr_81_comment},
  {"sort_points", &Dtool_CurveFitter_sort_points_82, METH_NOARGS, (const char *)Dtool_CurveFitter_sort_points_82_comment},
  {"sortPoints", &Dtool_CurveFitter_sort_points_82, METH_NOARGS, (const char *)Dtool_CurveFitter_sort_points_82_comment},
  {"desample", &Dtool_CurveFitter_desample_83, METH_O, (const char *)Dtool_CurveFitter_desample_83_comment},
  {"compute_tangents", &Dtool_CurveFitter_compute_tangents_84, METH_O, (const char *)Dtool_CurveFitter_compute_tangents_84_comment},
  {"computeTangents", &Dtool_CurveFitter_compute_tangents_84, METH_O, (const char *)Dtool_CurveFitter_compute_tangents_84_comment},
  {"make_hermite", &Dtool_CurveFitter_make_hermite_85, METH_NOARGS, (const char *)Dtool_CurveFitter_make_hermite_85_comment},
  {"makeHermite", &Dtool_CurveFitter_make_hermite_85, METH_NOARGS, (const char *)Dtool_CurveFitter_make_hermite_85_comment},
  {"make_nurbs", &Dtool_CurveFitter_make_nurbs_86, METH_NOARGS, (const char *)Dtool_CurveFitter_make_nurbs_86_comment},
  {"makeNurbs", &Dtool_CurveFitter_make_nurbs_86, METH_NOARGS, (const char *)Dtool_CurveFitter_make_nurbs_86_comment},
  {"output", &Dtool_CurveFitter_output_87, METH_O, (const char *)Dtool_CurveFitter_output_87_comment},
  {"write", &Dtool_CurveFitter_write_88, METH_O, (const char *)Dtool_CurveFitter_write_88_comment},
  {"get_class_type", &Dtool_CurveFitter_get_class_type_89, METH_NOARGS | METH_STATIC, (const char *)Dtool_CurveFitter_get_class_type_89_comment},
  {"getClassType", &Dtool_CurveFitter_get_class_type_89, METH_NOARGS | METH_STATIC, (const char *)Dtool_CurveFitter_get_class_type_89_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     CurveFitter
//////////////////
static PyObject *Dtool_Repr_CurveFitter(PyObject *self) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CurveFitter, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     CurveFitter
//////////////////
static PyObject *Dtool_Str_CurveFitter(PyObject *self) {
  CurveFitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CurveFitter, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_CurveFitter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_CurveFitter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CurveFitter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CurveFitter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_CurveFitter,
    &Dtool_NumberMethods_CurveFitter,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_CurveFitter,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CurveFitter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CurveFitter,
    PyType_GenericAlloc,
    Dtool_new_CurveFitter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CurveFitter,
  Dtool_UpcastInterface_CurveFitter,
  Dtool_DowncastInterface_CurveFitter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CurveFitter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_CurveFitter._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_CurveFitter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CurveFitter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CurveFitter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CurveFitter);
  }
}

/**
 * Python method tables for PiecewiseCurve (PiecewiseCurve)
 */
static PyMethodDef Dtool_Methods_PiecewiseCurve[] = {
  {"get_class_type", &Dtool_PiecewiseCurve_get_class_type_92, METH_NOARGS | METH_STATIC, (const char *)Dtool_PiecewiseCurve_get_class_type_92_comment},
  {"getClassType", &Dtool_PiecewiseCurve_get_class_type_92, METH_NOARGS | METH_STATIC, (const char *)Dtool_PiecewiseCurve_get_class_type_92_comment},
  {"downcast_to_NurbsCurve", &Dtool_PiecewiseCurve_downcast_to_NurbsCurve_138, METH_NOARGS, (const char *)Dtool_PiecewiseCurve_downcast_to_NurbsCurve_138_comment},
  {"downcastToNurbsCurve", &Dtool_PiecewiseCurve_downcast_to_NurbsCurve_138, METH_NOARGS, (const char *)Dtool_PiecewiseCurve_downcast_to_NurbsCurve_138_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PiecewiseCurve = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PiecewiseCurve = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PiecewiseCurve = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PiecewiseCurve = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PiecewiseCurve = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PiecewiseCurve",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PiecewiseCurve,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PiecewiseCurve,
    &Dtool_SequenceMethods_PiecewiseCurve,
    &Dtool_MappingMethods_PiecewiseCurve,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PiecewiseCurve,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A PiecewiseCurve is a curve made up of several curve segments, connected in\n"
    " * a head-to-tail fashion.  The length of each curve segment in parametric\n"
    " * space is definable.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PiecewiseCurve,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PiecewiseCurve,
    PyType_GenericAlloc,
    Dtool_new_PiecewiseCurve,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PiecewiseCurve,
  Dtool_UpcastInterface_PiecewiseCurve,
  Dtool_DowncastInterface_PiecewiseCurve,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PiecewiseCurve(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParametricCurve(NULL);
    Dtool_PiecewiseCurve._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParametricCurve);
    PyObject *dict = PyDict_New();
    Dtool_PiecewiseCurve._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PiecewiseCurve) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PiecewiseCurve)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PiecewiseCurve);
  }
}

/**
 * Python method tables for HermiteCurve (HermiteCurve)
 */
static PyMethodDef Dtool_Methods_HermiteCurve[] = {
  {"get_num_cvs", &Dtool_HermiteCurve_get_num_cvs_95, METH_NOARGS, (const char *)Dtool_HermiteCurve_get_num_cvs_95_comment},
  {"getNumCvs", &Dtool_HermiteCurve_get_num_cvs_95, METH_NOARGS, (const char *)Dtool_HermiteCurve_get_num_cvs_95_comment},
  {"insert_cv", &Dtool_HermiteCurve_insert_cv_96, METH_O, (const char *)Dtool_HermiteCurve_insert_cv_96_comment},
  {"insertCv", &Dtool_HermiteCurve_insert_cv_96, METH_O, (const char *)Dtool_HermiteCurve_insert_cv_96_comment},
  {"append_cv", (PyCFunction) &Dtool_HermiteCurve_append_cv_97, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_append_cv_97_comment},
  {"appendCv", (PyCFunction) &Dtool_HermiteCurve_append_cv_97, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_append_cv_97_comment},
  {"remove_cv", &Dtool_HermiteCurve_remove_cv_98, METH_O, (const char *)Dtool_HermiteCurve_remove_cv_98_comment},
  {"removeCv", &Dtool_HermiteCurve_remove_cv_98, METH_O, (const char *)Dtool_HermiteCurve_remove_cv_98_comment},
  {"remove_all_cvs", &Dtool_HermiteCurve_remove_all_cvs_99, METH_NOARGS, (const char *)Dtool_HermiteCurve_remove_all_cvs_99_comment},
  {"removeAllCvs", &Dtool_HermiteCurve_remove_all_cvs_99, METH_NOARGS, (const char *)Dtool_HermiteCurve_remove_all_cvs_99_comment},
  {"set_cv_type", (PyCFunction) &Dtool_HermiteCurve_set_cv_type_100, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_type_100_comment},
  {"setCvType", (PyCFunction) &Dtool_HermiteCurve_set_cv_type_100, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_type_100_comment},
  {"set_cv_point", (PyCFunction) &Dtool_HermiteCurve_set_cv_point_101, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_point_101_comment},
  {"setCvPoint", (PyCFunction) &Dtool_HermiteCurve_set_cv_point_101, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_point_101_comment},
  {"set_cv_in", (PyCFunction) &Dtool_HermiteCurve_set_cv_in_102, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_in_102_comment},
  {"setCvIn", (PyCFunction) &Dtool_HermiteCurve_set_cv_in_102, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_in_102_comment},
  {"set_cv_out", (PyCFunction) &Dtool_HermiteCurve_set_cv_out_103, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_out_103_comment},
  {"setCvOut", (PyCFunction) &Dtool_HermiteCurve_set_cv_out_103, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_out_103_comment},
  {"set_cv_tstart", (PyCFunction) &Dtool_HermiteCurve_set_cv_tstart_104, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_tstart_104_comment},
  {"setCvTstart", (PyCFunction) &Dtool_HermiteCurve_set_cv_tstart_104, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_tstart_104_comment},
  {"set_cv_name", (PyCFunction) &Dtool_HermiteCurve_set_cv_name_105, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_name_105_comment},
  {"setCvName", (PyCFunction) &Dtool_HermiteCurve_set_cv_name_105, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_name_105_comment},
  {"get_cv_type", &Dtool_HermiteCurve_get_cv_type_106, METH_O, (const char *)Dtool_HermiteCurve_get_cv_type_106_comment},
  {"getCvType", &Dtool_HermiteCurve_get_cv_type_106, METH_O, (const char *)Dtool_HermiteCurve_get_cv_type_106_comment},
  {"get_cv_point", (PyCFunction) &Dtool_HermiteCurve_get_cv_point_107, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_get_cv_point_107_comment},
  {"getCvPoint", (PyCFunction) &Dtool_HermiteCurve_get_cv_point_107, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_get_cv_point_107_comment},
  {"get_cv_in", (PyCFunction) &Dtool_HermiteCurve_get_cv_in_108, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_get_cv_in_108_comment},
  {"getCvIn", (PyCFunction) &Dtool_HermiteCurve_get_cv_in_108, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_get_cv_in_108_comment},
  {"get_cv_out", (PyCFunction) &Dtool_HermiteCurve_get_cv_out_109, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_get_cv_out_109_comment},
  {"getCvOut", (PyCFunction) &Dtool_HermiteCurve_get_cv_out_109, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_get_cv_out_109_comment},
  {"get_cv_tstart", &Dtool_HermiteCurve_get_cv_tstart_110, METH_O, (const char *)Dtool_HermiteCurve_get_cv_tstart_110_comment},
  {"getCvTstart", &Dtool_HermiteCurve_get_cv_tstart_110, METH_O, (const char *)Dtool_HermiteCurve_get_cv_tstart_110_comment},
  {"get_cv_name", &Dtool_HermiteCurve_get_cv_name_111, METH_O, (const char *)Dtool_HermiteCurve_get_cv_name_111_comment},
  {"getCvName", &Dtool_HermiteCurve_get_cv_name_111, METH_O, (const char *)Dtool_HermiteCurve_get_cv_name_111_comment},
  {"write_cv", (PyCFunction) &Dtool_HermiteCurve_write_cv_112, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_write_cv_112_comment},
  {"writeCv", (PyCFunction) &Dtool_HermiteCurve_write_cv_112, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_write_cv_112_comment},
  {"get_class_type", &Dtool_HermiteCurve_get_class_type_113, METH_NOARGS | METH_STATIC, (const char *)Dtool_HermiteCurve_get_class_type_113_comment},
  {"getClassType", &Dtool_HermiteCurve_get_class_type_113, METH_NOARGS | METH_STATIC, (const char *)Dtool_HermiteCurve_get_class_type_113_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_HermiteCurve = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_HermiteCurve = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_HermiteCurve = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_HermiteCurve = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_HermiteCurve = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.HermiteCurve",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_HermiteCurve,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_HermiteCurve,
    &Dtool_SequenceMethods_HermiteCurve,
    &Dtool_MappingMethods_HermiteCurve,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_HermiteCurve,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A parametric curve defined by a sequence of control vertices, each with an\n"
    " * in and out tangent.\n"
    " *\n"
    " * This class is actually implemented as a PiecewiseCurve made up of several\n"
    " * CubicCurvesegs, each of which is created using the hermite_basis() method.\n"
    " * The HermiteCurve class itself keeps its own list of the CV's that are used\n"
    " * to define the curve (since the CubicCurveseg class doesn't retain these).\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_HermiteCurve,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_HermiteCurve,
    PyType_GenericAlloc,
    Dtool_new_HermiteCurve,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_HermiteCurve,
  Dtool_UpcastInterface_HermiteCurve,
  Dtool_DowncastInterface_HermiteCurve,
  (CoerceFunction)Dtool_ConstCoerce_HermiteCurve,
  (CoerceFunction)Dtool_Coerce_HermiteCurve,
};

static void Dtool_PyModuleClassInit_HermiteCurve(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PiecewiseCurve(NULL);
    Dtool_HermiteCurve._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PiecewiseCurve);
    PyObject *dict = PyDict_New();
    Dtool_HermiteCurve._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_HermiteCurve) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(HermiteCurve)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_HermiteCurve);
  }
}

/**
 * Python method tables for NurbsCurveInterface (NurbsCurveInterface)
 */
static PyMethodDef Dtool_Methods_NurbsCurveInterface[] = {
  {"set_order", &Dtool_NurbsCurveInterface_set_order_116, METH_O, (const char *)Dtool_NurbsCurveInterface_set_order_116_comment},
  {"setOrder", &Dtool_NurbsCurveInterface_set_order_116, METH_O, (const char *)Dtool_NurbsCurveInterface_set_order_116_comment},
  {"get_order", &Dtool_NurbsCurveInterface_get_order_117, METH_NOARGS, (const char *)Dtool_NurbsCurveInterface_get_order_117_comment},
  {"getOrder", &Dtool_NurbsCurveInterface_get_order_117, METH_NOARGS, (const char *)Dtool_NurbsCurveInterface_get_order_117_comment},
  {"get_num_cvs", &Dtool_NurbsCurveInterface_get_num_cvs_118, METH_NOARGS, (const char *)Dtool_NurbsCurveInterface_get_num_cvs_118_comment},
  {"getNumCvs", &Dtool_NurbsCurveInterface_get_num_cvs_118, METH_NOARGS, (const char *)Dtool_NurbsCurveInterface_get_num_cvs_118_comment},
  {"get_num_knots", &Dtool_NurbsCurveInterface_get_num_knots_119, METH_NOARGS, (const char *)Dtool_NurbsCurveInterface_get_num_knots_119_comment},
  {"getNumKnots", &Dtool_NurbsCurveInterface_get_num_knots_119, METH_NOARGS, (const char *)Dtool_NurbsCurveInterface_get_num_knots_119_comment},
  {"insert_cv", &Dtool_NurbsCurveInterface_insert_cv_120, METH_O, (const char *)Dtool_NurbsCurveInterface_insert_cv_120_comment},
  {"insertCv", &Dtool_NurbsCurveInterface_insert_cv_120, METH_O, (const char *)Dtool_NurbsCurveInterface_insert_cv_120_comment},
  {"append_cv", (PyCFunction) &Dtool_NurbsCurveInterface_append_cv_121, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_append_cv_121_comment},
  {"appendCv", (PyCFunction) &Dtool_NurbsCurveInterface_append_cv_121, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_append_cv_121_comment},
  {"remove_cv", &Dtool_NurbsCurveInterface_remove_cv_122, METH_O, (const char *)Dtool_NurbsCurveInterface_remove_cv_122_comment},
  {"removeCv", &Dtool_NurbsCurveInterface_remove_cv_122, METH_O, (const char *)Dtool_NurbsCurveInterface_remove_cv_122_comment},
  {"remove_all_cvs", &Dtool_NurbsCurveInterface_remove_all_cvs_123, METH_NOARGS, (const char *)Dtool_NurbsCurveInterface_remove_all_cvs_123_comment},
  {"removeAllCvs", &Dtool_NurbsCurveInterface_remove_all_cvs_123, METH_NOARGS, (const char *)Dtool_NurbsCurveInterface_remove_all_cvs_123_comment},
  {"set_cv_point", (PyCFunction) &Dtool_NurbsCurveInterface_set_cv_point_124, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_set_cv_point_124_comment},
  {"setCvPoint", (PyCFunction) &Dtool_NurbsCurveInterface_set_cv_point_124, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_set_cv_point_124_comment},
  {"get_cv_point", &Dtool_NurbsCurveInterface_get_cv_point_125, METH_O, (const char *)Dtool_NurbsCurveInterface_get_cv_point_125_comment},
  {"getCvPoint", &Dtool_NurbsCurveInterface_get_cv_point_125, METH_O, (const char *)Dtool_NurbsCurveInterface_get_cv_point_125_comment},
  {"set_cv_weight", (PyCFunction) &Dtool_NurbsCurveInterface_set_cv_weight_126, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_set_cv_weight_126_comment},
  {"setCvWeight", (PyCFunction) &Dtool_NurbsCurveInterface_set_cv_weight_126, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_set_cv_weight_126_comment},
  {"get_cv_weight", &Dtool_NurbsCurveInterface_get_cv_weight_127, METH_O, (const char *)Dtool_NurbsCurveInterface_get_cv_weight_127_comment},
  {"getCvWeight", &Dtool_NurbsCurveInterface_get_cv_weight_127, METH_O, (const char *)Dtool_NurbsCurveInterface_get_cv_weight_127_comment},
  {"set_cv", (PyCFunction) &Dtool_NurbsCurveInterface_set_cv_128, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_set_cv_128_comment},
  {"setCv", (PyCFunction) &Dtool_NurbsCurveInterface_set_cv_128, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_set_cv_128_comment},
  {"get_cv", &Dtool_NurbsCurveInterface_get_cv_129, METH_O, (const char *)Dtool_NurbsCurveInterface_get_cv_129_comment},
  {"getCv", &Dtool_NurbsCurveInterface_get_cv_129, METH_O, (const char *)Dtool_NurbsCurveInterface_get_cv_129_comment},
  {"set_knot", (PyCFunction) &Dtool_NurbsCurveInterface_set_knot_130, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_set_knot_130_comment},
  {"setKnot", (PyCFunction) &Dtool_NurbsCurveInterface_set_knot_130, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_set_knot_130_comment},
  {"get_knot", &Dtool_NurbsCurveInterface_get_knot_131, METH_O, (const char *)Dtool_NurbsCurveInterface_get_knot_131_comment},
  {"getKnot", &Dtool_NurbsCurveInterface_get_knot_131, METH_O, (const char *)Dtool_NurbsCurveInterface_get_knot_131_comment},
  {"write_cv", (PyCFunction) &Dtool_NurbsCurveInterface_write_cv_134, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_write_cv_134_comment},
  {"writeCv", (PyCFunction) &Dtool_NurbsCurveInterface_write_cv_134, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_write_cv_134_comment},
  {"get_class_type", &Dtool_NurbsCurveInterface_get_class_type_135, METH_NOARGS | METH_STATIC, (const char *)Dtool_NurbsCurveInterface_get_class_type_135_comment},
  {"getClassType", &Dtool_NurbsCurveInterface_get_class_type_135, METH_NOARGS | METH_STATIC, (const char *)Dtool_NurbsCurveInterface_get_class_type_135_comment},
  {"downcast_to_NurbsCurve", &Dtool_NurbsCurveInterface_downcast_to_NurbsCurve_140, METH_NOARGS, (const char *)Dtool_NurbsCurveInterface_downcast_to_NurbsCurve_140_comment},
  {"downcastToNurbsCurve", &Dtool_NurbsCurveInterface_downcast_to_NurbsCurve_140, METH_NOARGS, (const char *)Dtool_NurbsCurveInterface_downcast_to_NurbsCurve_140_comment},
  {"get_cvs", (PyCFunction) &MakeSeq_NurbsCurveInterface_get_cvs, METH_NOARGS, NULL},
  { "getCvs", (PyCFunction) &MakeSeq_NurbsCurveInterface_get_cvs, METH_NOARGS, NULL},
  {"get_knots", (PyCFunction) &MakeSeq_NurbsCurveInterface_get_knots, METH_NOARGS, NULL},
  { "getKnots", (PyCFunction) &MakeSeq_NurbsCurveInterface_get_knots, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_NurbsCurveInterface = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_NurbsCurveInterface = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.NurbsCurveInterface",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_NurbsCurveInterface,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_NurbsCurveInterface,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This abstract class defines the interface only for a Nurbs-style curve,\n"
    " * with knots and coordinates in homogeneous space.\n"
    " *\n"
    " * The NurbsCurve class inherits both from this and from ParametricCurve.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_NurbsCurveInterface,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_NurbsCurveInterface,
    PyType_GenericAlloc,
    Dtool_new_NurbsCurveInterface,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NurbsCurveInterface,
  Dtool_UpcastInterface_NurbsCurveInterface,
  Dtool_DowncastInterface_NurbsCurveInterface,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_NurbsCurveInterface(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_NurbsCurveInterface._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_NurbsCurveInterface._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NurbsCurveInterface) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NurbsCurveInterface)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NurbsCurveInterface);
  }
}

/**
 * Python method tables for NurbsCurve (NurbsCurve)
 */
static PyMethodDef Dtool_Methods_NurbsCurve[] = {
  {"get_class_type", &Dtool_NurbsCurve_get_class_type_143, METH_NOARGS | METH_STATIC, (const char *)Dtool_NurbsCurve_get_class_type_143_comment},
  {"getClassType", &Dtool_NurbsCurve_get_class_type_143, METH_NOARGS | METH_STATIC, (const char *)Dtool_NurbsCurve_get_class_type_143_comment},
  {"upcast_to_PiecewiseCurve", &Dtool_NurbsCurve_upcast_to_PiecewiseCurve_137, METH_NOARGS, (const char *)Dtool_NurbsCurve_upcast_to_PiecewiseCurve_137_comment},
  {"upcastToPiecewiseCurve", &Dtool_NurbsCurve_upcast_to_PiecewiseCurve_137, METH_NOARGS, (const char *)Dtool_NurbsCurve_upcast_to_PiecewiseCurve_137_comment},
  {"upcast_to_NurbsCurveInterface", &Dtool_NurbsCurve_upcast_to_NurbsCurveInterface_139, METH_NOARGS, (const char *)Dtool_NurbsCurve_upcast_to_NurbsCurveInterface_139_comment},
  {"upcastToNurbsCurveInterface", &Dtool_NurbsCurve_upcast_to_NurbsCurveInterface_139, METH_NOARGS, (const char *)Dtool_NurbsCurve_upcast_to_NurbsCurveInterface_139_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_NurbsCurve = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NurbsCurve = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_NurbsCurve = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_NurbsCurve = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_NurbsCurve = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.NurbsCurve",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_NurbsCurve,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_NurbsCurve,
    &Dtool_SequenceMethods_NurbsCurve,
    &Dtool_MappingMethods_NurbsCurve,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_NurbsCurve,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A Nonuniform Rational B-Spline.\n"
    " *\n"
    " * This class is actually implemented as a PiecewiseCurve made up of several\n"
    " * CubicCurvesegs, each of which is created using the nurbs_basis() method.\n"
    " * The list of CV's and knots is kept here, within the NurbsCurve class.\n"
    " *\n"
    " * This class is the original Panda-native implementation of a NURBS curve.\n"
    " * It is typedeffed as \"NurbsCurve\" and performs all NURBS curve functions if\n"
    " * we do not have the NURBS++ library available.\n"
    " *\n"
    " * However, if we *do* have the NURBS++ library, another class exists, the\n"
    " * NurbsPPCurve, which is a wrapper around that library and provides some\n"
    " * additional functionality.  In that case, the other class is typedeffed to\n"
    " * \"NurbsCurve\" instead of this one, and performs most of the NURBS curve\n"
    " * functions.  This class then becomes vestigial.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_NurbsCurve,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_NurbsCurve,
    PyType_GenericAlloc,
    Dtool_new_NurbsCurve,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NurbsCurve,
  Dtool_UpcastInterface_NurbsCurve,
  Dtool_DowncastInterface_NurbsCurve,
  (CoerceFunction)Dtool_ConstCoerce_NurbsCurve,
  (CoerceFunction)Dtool_Coerce_NurbsCurve,
};

static void Dtool_PyModuleClassInit_NurbsCurve(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PiecewiseCurve(NULL);
    Dtool_PyModuleClassInit_NurbsCurveInterface(NULL);
    Dtool_NurbsCurve._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_PiecewiseCurve, (PyTypeObject *)&Dtool_NurbsCurveInterface);
    PyObject *dict = PyDict_New();
    Dtool_NurbsCurve._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NurbsCurve) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NurbsCurve)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NurbsCurve);
  }
}

/**
 * Python method tables for NurbsCurveResult (NurbsCurveResult)
 */
static PyMethodDef Dtool_Methods_NurbsCurveResult[] = {
  {"get_start_t", &Dtool_NurbsCurveResult_get_start_t_145, METH_NOARGS, (const char *)Dtool_NurbsCurveResult_get_start_t_145_comment},
  {"getStartT", &Dtool_NurbsCurveResult_get_start_t_145, METH_NOARGS, (const char *)Dtool_NurbsCurveResult_get_start_t_145_comment},
  {"get_end_t", &Dtool_NurbsCurveResult_get_end_t_146, METH_NOARGS, (const char *)Dtool_NurbsCurveResult_get_end_t_146_comment},
  {"getEndT", &Dtool_NurbsCurveResult_get_end_t_146, METH_NOARGS, (const char *)Dtool_NurbsCurveResult_get_end_t_146_comment},
  {"eval_point", (PyCFunction) &Dtool_NurbsCurveResult_eval_point_147, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_point_147_comment},
  {"evalPoint", (PyCFunction) &Dtool_NurbsCurveResult_eval_point_147, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_point_147_comment},
  {"eval_tangent", (PyCFunction) &Dtool_NurbsCurveResult_eval_tangent_148, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_tangent_148_comment},
  {"evalTangent", (PyCFunction) &Dtool_NurbsCurveResult_eval_tangent_148, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_tangent_148_comment},
  {"eval_extended_point", (PyCFunction) &Dtool_NurbsCurveResult_eval_extended_point_149, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_extended_point_149_comment},
  {"evalExtendedPoint", (PyCFunction) &Dtool_NurbsCurveResult_eval_extended_point_149, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_extended_point_149_comment},
  {"eval_extended_points", (PyCFunction) &Dtool_NurbsCurveResult_eval_extended_points_150, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_extended_points_150_comment},
  {"evalExtendedPoints", (PyCFunction) &Dtool_NurbsCurveResult_eval_extended_points_150, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_extended_points_150_comment},
  {"get_num_segments", &Dtool_NurbsCurveResult_get_num_segments_151, METH_NOARGS, (const char *)Dtool_NurbsCurveResult_get_num_segments_151_comment},
  {"getNumSegments", &Dtool_NurbsCurveResult_get_num_segments_151, METH_NOARGS, (const char *)Dtool_NurbsCurveResult_get_num_segments_151_comment},
  {"eval_segment_point", (PyCFunction) &Dtool_NurbsCurveResult_eval_segment_point_152, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_segment_point_152_comment},
  {"evalSegmentPoint", (PyCFunction) &Dtool_NurbsCurveResult_eval_segment_point_152, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_segment_point_152_comment},
  {"eval_segment_tangent", (PyCFunction) &Dtool_NurbsCurveResult_eval_segment_tangent_153, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_segment_tangent_153_comment},
  {"evalSegmentTangent", (PyCFunction) &Dtool_NurbsCurveResult_eval_segment_tangent_153, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_segment_tangent_153_comment},
  {"eval_segment_extended_point", (PyCFunction) &Dtool_NurbsCurveResult_eval_segment_extended_point_154, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_segment_extended_point_154_comment},
  {"evalSegmentExtendedPoint", (PyCFunction) &Dtool_NurbsCurveResult_eval_segment_extended_point_154, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_segment_extended_point_154_comment},
  {"eval_segment_extended_points", (PyCFunction) &Dtool_NurbsCurveResult_eval_segment_extended_points_155, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_segment_extended_points_155_comment},
  {"evalSegmentExtendedPoints", (PyCFunction) &Dtool_NurbsCurveResult_eval_segment_extended_points_155, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_segment_extended_points_155_comment},
  {"get_segment_t", (PyCFunction) &Dtool_NurbsCurveResult_get_segment_t_156, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_get_segment_t_156_comment},
  {"getSegmentT", (PyCFunction) &Dtool_NurbsCurveResult_get_segment_t_156, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_get_segment_t_156_comment},
  {"adaptive_sample", &Dtool_NurbsCurveResult_adaptive_sample_157, METH_O, (const char *)Dtool_NurbsCurveResult_adaptive_sample_157_comment},
  {"adaptiveSample", &Dtool_NurbsCurveResult_adaptive_sample_157, METH_O, (const char *)Dtool_NurbsCurveResult_adaptive_sample_157_comment},
  {"get_num_samples", &Dtool_NurbsCurveResult_get_num_samples_158, METH_NOARGS, (const char *)Dtool_NurbsCurveResult_get_num_samples_158_comment},
  {"getNumSamples", &Dtool_NurbsCurveResult_get_num_samples_158, METH_NOARGS, (const char *)Dtool_NurbsCurveResult_get_num_samples_158_comment},
  {"get_sample_t", &Dtool_NurbsCurveResult_get_sample_t_159, METH_O, (const char *)Dtool_NurbsCurveResult_get_sample_t_159_comment},
  {"getSampleT", &Dtool_NurbsCurveResult_get_sample_t_159, METH_O, (const char *)Dtool_NurbsCurveResult_get_sample_t_159_comment},
  {"get_sample_point", &Dtool_NurbsCurveResult_get_sample_point_160, METH_O, (const char *)Dtool_NurbsCurveResult_get_sample_point_160_comment},
  {"getSamplePoint", &Dtool_NurbsCurveResult_get_sample_point_160, METH_O, (const char *)Dtool_NurbsCurveResult_get_sample_point_160_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_sample_ts", (PyCFunction) &MakeSeq_NurbsCurveResult_get_sample_ts, METH_NOARGS, NULL},
  { "getSampleTs", (PyCFunction) &MakeSeq_NurbsCurveResult_get_sample_ts, METH_NOARGS, NULL},
  {"get_sample_points", (PyCFunction) &MakeSeq_NurbsCurveResult_get_sample_points, METH_NOARGS, NULL},
  { "getSamplePoints", (PyCFunction) &MakeSeq_NurbsCurveResult_get_sample_points, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_NurbsCurveResult = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NurbsCurveResult = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_NurbsCurveResult = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_NurbsCurveResult = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_NurbsCurveResult = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.NurbsCurveResult",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_NurbsCurveResult,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_NurbsCurveResult,
    &Dtool_SequenceMethods_NurbsCurveResult,
    &Dtool_MappingMethods_NurbsCurveResult,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_NurbsCurveResult,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The result of a NurbsCurveEvaluator.  This object represents a curve in a\n"
    " * particular coordinate space.  It can return the point and/or tangent to the\n"
    " * curve at any point.\n"
    " *\n"
    " * This is not related to NurbsCurve, CubicCurveseg or any of the\n"
    " * ParametricCurve-derived objects in this module.  It is a completely\n"
    " * parallel implementation of NURBS curves, and will probably eventually\n"
    " * replace the whole ParametricCurve class hierarchy.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_NurbsCurveResult,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_NurbsCurveResult,
    PyType_GenericAlloc,
    Dtool_new_NurbsCurveResult,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NurbsCurveResult,
  Dtool_UpcastInterface_NurbsCurveResult,
  Dtool_DowncastInterface_NurbsCurveResult,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_NurbsCurveResult(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_NurbsCurveResult._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_NurbsCurveResult._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NurbsCurveResult) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NurbsCurveResult)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NurbsCurveResult);
  }
}

/**
 * Python method tables for NurbsCurveEvaluator (NurbsCurveEvaluator)
 */
static PyMethodDef Dtool_Methods_NurbsCurveEvaluator[] = {
  {"set_order", &Dtool_NurbsCurveEvaluator_set_order_166, METH_O, (const char *)Dtool_NurbsCurveEvaluator_set_order_166_comment},
  {"setOrder", &Dtool_NurbsCurveEvaluator_set_order_166, METH_O, (const char *)Dtool_NurbsCurveEvaluator_set_order_166_comment},
  {"get_order", &Dtool_NurbsCurveEvaluator_get_order_167, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_get_order_167_comment},
  {"getOrder", &Dtool_NurbsCurveEvaluator_get_order_167, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_get_order_167_comment},
  {"reset", &Dtool_NurbsCurveEvaluator_reset_168, METH_O, (const char *)Dtool_NurbsCurveEvaluator_reset_168_comment},
  {"get_num_vertices", &Dtool_NurbsCurveEvaluator_get_num_vertices_169, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_get_num_vertices_169_comment},
  {"getNumVertices", &Dtool_NurbsCurveEvaluator_get_num_vertices_169, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_get_num_vertices_169_comment},
  {"set_vertex", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_vertex_170, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_vertex_170_comment},
  {"setVertex", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_vertex_170, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_vertex_170_comment},
  {"get_vertex", (PyCFunction) &Dtool_NurbsCurveEvaluator_get_vertex_171, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_get_vertex_171_comment},
  {"getVertex", (PyCFunction) &Dtool_NurbsCurveEvaluator_get_vertex_171, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_get_vertex_171_comment},
  {"set_vertex_space", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_vertex_space_173, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_vertex_space_173_comment},
  {"setVertexSpace", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_vertex_space_173, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_vertex_space_173_comment},
  {"get_vertex_space", (PyCFunction) &Dtool_NurbsCurveEvaluator_get_vertex_space_174, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_get_vertex_space_174_comment},
  {"getVertexSpace", (PyCFunction) &Dtool_NurbsCurveEvaluator_get_vertex_space_174, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_get_vertex_space_174_comment},
  {"set_extended_vertex", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_extended_vertex_175, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_extended_vertex_175_comment},
  {"setExtendedVertex", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_extended_vertex_175, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_extended_vertex_175_comment},
  {"get_extended_vertex", (PyCFunction) &Dtool_NurbsCurveEvaluator_get_extended_vertex_176, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_get_extended_vertex_176_comment},
  {"getExtendedVertex", (PyCFunction) &Dtool_NurbsCurveEvaluator_get_extended_vertex_176, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_get_extended_vertex_176_comment},
  {"set_extended_vertices", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_extended_vertices_177, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_extended_vertices_177_comment},
  {"setExtendedVertices", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_extended_vertices_177, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_extended_vertices_177_comment},
  {"get_num_knots", &Dtool_NurbsCurveEvaluator_get_num_knots_178, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_get_num_knots_178_comment},
  {"getNumKnots", &Dtool_NurbsCurveEvaluator_get_num_knots_178, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_get_num_knots_178_comment},
  {"set_knot", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_knot_179, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_knot_179_comment},
  {"setKnot", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_knot_179, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_knot_179_comment},
  {"get_knot", &Dtool_NurbsCurveEvaluator_get_knot_180, METH_O, (const char *)Dtool_NurbsCurveEvaluator_get_knot_180_comment},
  {"getKnot", &Dtool_NurbsCurveEvaluator_get_knot_180, METH_O, (const char *)Dtool_NurbsCurveEvaluator_get_knot_180_comment},
  {"normalize_knots", &Dtool_NurbsCurveEvaluator_normalize_knots_182, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_normalize_knots_182_comment},
  {"normalizeKnots", &Dtool_NurbsCurveEvaluator_normalize_knots_182, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_normalize_knots_182_comment},
  {"get_num_segments", &Dtool_NurbsCurveEvaluator_get_num_segments_183, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_get_num_segments_183_comment},
  {"getNumSegments", &Dtool_NurbsCurveEvaluator_get_num_segments_183, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_get_num_segments_183_comment},
  {"evaluate", (PyCFunction) &Dtool_NurbsCurveEvaluator_evaluate_184, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_evaluate_184_comment},
  {"output", &Dtool_NurbsCurveEvaluator_output_185, METH_O, (const char *)Dtool_NurbsCurveEvaluator_output_185_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_vertices", (PyCFunction) &MakeSeq_NurbsCurveEvaluator_get_vertices, METH_NOARGS, NULL},
  { "getVertices", (PyCFunction) &MakeSeq_NurbsCurveEvaluator_get_vertices, METH_NOARGS, NULL},
  {"get_knots", (PyCFunction) &MakeSeq_NurbsCurveEvaluator_get_knots, METH_NOARGS, NULL},
  { "getKnots", (PyCFunction) &MakeSeq_NurbsCurveEvaluator_get_knots, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     NurbsCurveEvaluator
//////////////////
static PyObject *Dtool_Repr_NurbsCurveEvaluator(PyObject *self) {
  NurbsCurveEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveEvaluator, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_NurbsCurveEvaluator = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NurbsCurveEvaluator = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_NurbsCurveEvaluator = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_NurbsCurveEvaluator = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_NurbsCurveEvaluator = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.NurbsCurveEvaluator",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_NurbsCurveEvaluator,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_NurbsCurveEvaluator,
    &Dtool_NumberMethods_NurbsCurveEvaluator,
    &Dtool_SequenceMethods_NurbsCurveEvaluator,
    &Dtool_MappingMethods_NurbsCurveEvaluator,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_NurbsCurveEvaluator,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_NurbsCurveEvaluator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is an abstraction for evaluating NURBS curves.  It accepts an\n"
    " * array of vertices, each of which may be in a different coordinate space (as\n"
    " * defined by a NodePath), as well as an optional knot vector.\n"
    " *\n"
    " * This is not related to NurbsCurve, CubicCurveseg or any of the\n"
    " * ParametricCurve-derived objects in this module.  It is a completely\n"
    " * parallel implementation of NURBS curves, and will probably eventually\n"
    " * replace the whole ParametricCurve class hierarchy.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_NurbsCurveEvaluator,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_NurbsCurveEvaluator,
    PyType_GenericAlloc,
    Dtool_new_NurbsCurveEvaluator,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NurbsCurveEvaluator,
  Dtool_UpcastInterface_NurbsCurveEvaluator,
  Dtool_DowncastInterface_NurbsCurveEvaluator,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_NurbsCurveEvaluator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_NurbsCurveEvaluator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_NurbsCurveEvaluator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NurbsCurveEvaluator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NurbsCurveEvaluator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NurbsCurveEvaluator);
  }
}

/**
 * Python method tables for NurbsSurfaceResult (NurbsSurfaceResult)
 */
static PyMethodDef Dtool_Methods_NurbsSurfaceResult[] = {
  {"get_start_u", &Dtool_NurbsSurfaceResult_get_start_u_187, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_start_u_187_comment},
  {"getStartU", &Dtool_NurbsSurfaceResult_get_start_u_187, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_start_u_187_comment},
  {"get_end_u", &Dtool_NurbsSurfaceResult_get_end_u_188, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_end_u_188_comment},
  {"getEndU", &Dtool_NurbsSurfaceResult_get_end_u_188, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_end_u_188_comment},
  {"get_start_v", &Dtool_NurbsSurfaceResult_get_start_v_189, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_start_v_189_comment},
  {"getStartV", &Dtool_NurbsSurfaceResult_get_start_v_189, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_start_v_189_comment},
  {"get_end_v", &Dtool_NurbsSurfaceResult_get_end_v_190, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_end_v_190_comment},
  {"getEndV", &Dtool_NurbsSurfaceResult_get_end_v_190, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_end_v_190_comment},
  {"eval_point", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_point_191, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_point_191_comment},
  {"evalPoint", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_point_191, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_point_191_comment},
  {"eval_normal", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_normal_192, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_normal_192_comment},
  {"evalNormal", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_normal_192, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_normal_192_comment},
  {"eval_extended_point", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_extended_point_193, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_extended_point_193_comment},
  {"evalExtendedPoint", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_extended_point_193, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_extended_point_193_comment},
  {"eval_extended_points", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_extended_points_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_extended_points_194_comment},
  {"evalExtendedPoints", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_extended_points_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_extended_points_194_comment},
  {"get_num_u_segments", &Dtool_NurbsSurfaceResult_get_num_u_segments_195, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_num_u_segments_195_comment},
  {"getNumUSegments", &Dtool_NurbsSurfaceResult_get_num_u_segments_195, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_num_u_segments_195_comment},
  {"get_num_v_segments", &Dtool_NurbsSurfaceResult_get_num_v_segments_196, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_num_v_segments_196_comment},
  {"getNumVSegments", &Dtool_NurbsSurfaceResult_get_num_v_segments_196, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_num_v_segments_196_comment},
  {"eval_segment_point", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_segment_point_197, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_segment_point_197_comment},
  {"evalSegmentPoint", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_segment_point_197, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_segment_point_197_comment},
  {"eval_segment_normal", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_segment_normal_198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_segment_normal_198_comment},
  {"evalSegmentNormal", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_segment_normal_198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_segment_normal_198_comment},
  {"eval_segment_extended_point", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_segment_extended_point_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_segment_extended_point_199_comment},
  {"evalSegmentExtendedPoint", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_segment_extended_point_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_segment_extended_point_199_comment},
  {"eval_segment_extended_points", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_segment_extended_points_200, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_segment_extended_points_200_comment},
  {"evalSegmentExtendedPoints", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_segment_extended_points_200, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_segment_extended_points_200_comment},
  {"get_segment_u", (PyCFunction) &Dtool_NurbsSurfaceResult_get_segment_u_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_get_segment_u_201_comment},
  {"getSegmentU", (PyCFunction) &Dtool_NurbsSurfaceResult_get_segment_u_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_get_segment_u_201_comment},
  {"get_segment_v", (PyCFunction) &Dtool_NurbsSurfaceResult_get_segment_v_202, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_get_segment_v_202_comment},
  {"getSegmentV", (PyCFunction) &Dtool_NurbsSurfaceResult_get_segment_v_202, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_get_segment_v_202_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_NurbsSurfaceResult = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NurbsSurfaceResult = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_NurbsSurfaceResult = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_NurbsSurfaceResult = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_NurbsSurfaceResult = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.NurbsSurfaceResult",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_NurbsSurfaceResult,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_NurbsSurfaceResult,
    &Dtool_SequenceMethods_NurbsSurfaceResult,
    &Dtool_MappingMethods_NurbsSurfaceResult,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_NurbsSurfaceResult,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The result of a NurbsSurfaceEvaluator.  This object represents a surface in\n"
    " * a particular coordinate space.  It can return the point and/or normal to\n"
    " * the surface at any point.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_NurbsSurfaceResult,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_NurbsSurfaceResult,
    PyType_GenericAlloc,
    Dtool_new_NurbsSurfaceResult,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NurbsSurfaceResult,
  Dtool_UpcastInterface_NurbsSurfaceResult,
  Dtool_DowncastInterface_NurbsSurfaceResult,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_NurbsSurfaceResult(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_NurbsSurfaceResult._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_NurbsSurfaceResult._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NurbsSurfaceResult) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NurbsSurfaceResult)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NurbsSurfaceResult);
  }
}

/**
 * Python method tables for NurbsSurfaceEvaluator (NurbsSurfaceEvaluator)
 */
static PyMethodDef Dtool_Methods_NurbsSurfaceEvaluator[] = {
  {"set_u_order", &Dtool_NurbsSurfaceEvaluator_set_u_order_206, METH_O, (const char *)Dtool_NurbsSurfaceEvaluator_set_u_order_206_comment},
  {"setUOrder", &Dtool_NurbsSurfaceEvaluator_set_u_order_206, METH_O, (const char *)Dtool_NurbsSurfaceEvaluator_set_u_order_206_comment},
  {"get_u_order", &Dtool_NurbsSurfaceEvaluator_get_u_order_207, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_u_order_207_comment},
  {"getUOrder", &Dtool_NurbsSurfaceEvaluator_get_u_order_207, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_u_order_207_comment},
  {"set_v_order", &Dtool_NurbsSurfaceEvaluator_set_v_order_208, METH_O, (const char *)Dtool_NurbsSurfaceEvaluator_set_v_order_208_comment},
  {"setVOrder", &Dtool_NurbsSurfaceEvaluator_set_v_order_208, METH_O, (const char *)Dtool_NurbsSurfaceEvaluator_set_v_order_208_comment},
  {"get_v_order", &Dtool_NurbsSurfaceEvaluator_get_v_order_209, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_v_order_209_comment},
  {"getVOrder", &Dtool_NurbsSurfaceEvaluator_get_v_order_209, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_v_order_209_comment},
  {"reset", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_reset_210, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_reset_210_comment},
  {"get_num_u_vertices", &Dtool_NurbsSurfaceEvaluator_get_num_u_vertices_211, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_u_vertices_211_comment},
  {"getNumUVertices", &Dtool_NurbsSurfaceEvaluator_get_num_u_vertices_211, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_u_vertices_211_comment},
  {"get_num_v_vertices", &Dtool_NurbsSurfaceEvaluator_get_num_v_vertices_212, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_v_vertices_212_comment},
  {"getNumVVertices", &Dtool_NurbsSurfaceEvaluator_get_num_v_vertices_212, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_v_vertices_212_comment},
  {"set_vertex", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_vertex_213, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_vertex_213_comment},
  {"setVertex", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_vertex_213, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_vertex_213_comment},
  {"get_vertex", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_get_vertex_214, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_get_vertex_214_comment},
  {"getVertex", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_get_vertex_214, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_get_vertex_214_comment},
  {"set_vertex_space", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_vertex_space_215, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_vertex_space_215_comment},
  {"setVertexSpace", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_vertex_space_215, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_vertex_space_215_comment},
  {"get_vertex_space", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_get_vertex_space_216, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_get_vertex_space_216_comment},
  {"getVertexSpace", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_get_vertex_space_216, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_get_vertex_space_216_comment},
  {"set_extended_vertex", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_extended_vertex_217, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_extended_vertex_217_comment},
  {"setExtendedVertex", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_extended_vertex_217, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_extended_vertex_217_comment},
  {"get_extended_vertex", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_get_extended_vertex_218, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_get_extended_vertex_218_comment},
  {"getExtendedVertex", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_get_extended_vertex_218, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_get_extended_vertex_218_comment},
  {"set_extended_vertices", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_extended_vertices_219, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_extended_vertices_219_comment},
  {"setExtendedVertices", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_extended_vertices_219, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_extended_vertices_219_comment},
  {"get_num_u_knots", &Dtool_NurbsSurfaceEvaluator_get_num_u_knots_220, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_u_knots_220_comment},
  {"getNumUKnots", &Dtool_NurbsSurfaceEvaluator_get_num_u_knots_220, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_u_knots_220_comment},
  {"set_u_knot", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_u_knot_221, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_u_knot_221_comment},
  {"setUKnot", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_u_knot_221, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_u_knot_221_comment},
  {"get_u_knot", &Dtool_NurbsSurfaceEvaluator_get_u_knot_222, METH_O, (const char *)Dtool_NurbsSurfaceEvaluator_get_u_knot_222_comment},
  {"getUKnot", &Dtool_NurbsSurfaceEvaluator_get_u_knot_222, METH_O, (const char *)Dtool_NurbsSurfaceEvaluator_get_u_knot_222_comment},
  {"normalize_u_knots", &Dtool_NurbsSurfaceEvaluator_normalize_u_knots_224, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_normalize_u_knots_224_comment},
  {"normalizeUKnots", &Dtool_NurbsSurfaceEvaluator_normalize_u_knots_224, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_normalize_u_knots_224_comment},
  {"get_num_v_knots", &Dtool_NurbsSurfaceEvaluator_get_num_v_knots_225, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_v_knots_225_comment},
  {"getNumVKnots", &Dtool_NurbsSurfaceEvaluator_get_num_v_knots_225, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_v_knots_225_comment},
  {"set_v_knot", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_v_knot_226, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_v_knot_226_comment},
  {"setVKnot", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_v_knot_226, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_v_knot_226_comment},
  {"get_v_knot", &Dtool_NurbsSurfaceEvaluator_get_v_knot_227, METH_O, (const char *)Dtool_NurbsSurfaceEvaluator_get_v_knot_227_comment},
  {"getVKnot", &Dtool_NurbsSurfaceEvaluator_get_v_knot_227, METH_O, (const char *)Dtool_NurbsSurfaceEvaluator_get_v_knot_227_comment},
  {"normalize_v_knots", &Dtool_NurbsSurfaceEvaluator_normalize_v_knots_229, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_normalize_v_knots_229_comment},
  {"normalizeVKnots", &Dtool_NurbsSurfaceEvaluator_normalize_v_knots_229, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_normalize_v_knots_229_comment},
  {"get_num_u_segments", &Dtool_NurbsSurfaceEvaluator_get_num_u_segments_230, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_u_segments_230_comment},
  {"getNumUSegments", &Dtool_NurbsSurfaceEvaluator_get_num_u_segments_230, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_u_segments_230_comment},
  {"get_num_v_segments", &Dtool_NurbsSurfaceEvaluator_get_num_v_segments_231, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_v_segments_231_comment},
  {"getNumVSegments", &Dtool_NurbsSurfaceEvaluator_get_num_v_segments_231, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_v_segments_231_comment},
  {"evaluate", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_evaluate_232, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_evaluate_232_comment},
  {"output", &Dtool_NurbsSurfaceEvaluator_output_233, METH_O, (const char *)Dtool_NurbsSurfaceEvaluator_output_233_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_u_knots", (PyCFunction) &MakeSeq_NurbsSurfaceEvaluator_get_u_knots, METH_NOARGS, NULL},
  { "getUKnots", (PyCFunction) &MakeSeq_NurbsSurfaceEvaluator_get_u_knots, METH_NOARGS, NULL},
  {"get_v_knots", (PyCFunction) &MakeSeq_NurbsSurfaceEvaluator_get_v_knots, METH_NOARGS, NULL},
  { "getVKnots", (PyCFunction) &MakeSeq_NurbsSurfaceEvaluator_get_v_knots, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     NurbsSurfaceEvaluator
//////////////////
static PyObject *Dtool_Repr_NurbsSurfaceEvaluator(PyObject *self) {
  NurbsSurfaceEvaluator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_NurbsSurfaceEvaluator[] = {
  {(char *)"u_order", &Dtool_NurbsSurfaceEvaluator_u_order_Getter, &Dtool_NurbsSurfaceEvaluator_u_order_Setter, NULL, NULL},
  {(char *)"v_order", &Dtool_NurbsSurfaceEvaluator_v_order_Getter, &Dtool_NurbsSurfaceEvaluator_v_order_Setter, NULL, NULL},
  {(char *)"u_knots", &Dtool_NurbsSurfaceEvaluator_u_knots_Getter, NULL, NULL, NULL},
  {(char *)"v_knots", &Dtool_NurbsSurfaceEvaluator_v_knots_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_NurbsSurfaceEvaluator = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NurbsSurfaceEvaluator = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_NurbsSurfaceEvaluator = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_NurbsSurfaceEvaluator = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_NurbsSurfaceEvaluator = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.NurbsSurfaceEvaluator",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_NurbsSurfaceEvaluator,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_NurbsSurfaceEvaluator,
    &Dtool_NumberMethods_NurbsSurfaceEvaluator,
    &Dtool_SequenceMethods_NurbsSurfaceEvaluator,
    &Dtool_MappingMethods_NurbsSurfaceEvaluator,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_NurbsSurfaceEvaluator,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_NurbsSurfaceEvaluator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is an abstraction for evaluating NURBS surfaces.  It accepts an\n"
    " * array of vertices, each of which may be in a different coordinate space (as\n"
    " * defined by a NodePath), as well as an optional knot vector.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_NurbsSurfaceEvaluator,
    0, // tp_members
    Dtool_Properties_NurbsSurfaceEvaluator,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_NurbsSurfaceEvaluator,
    PyType_GenericAlloc,
    Dtool_new_NurbsSurfaceEvaluator,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NurbsSurfaceEvaluator,
  Dtool_UpcastInterface_NurbsSurfaceEvaluator,
  Dtool_DowncastInterface_NurbsSurfaceEvaluator,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_NurbsSurfaceEvaluator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_NurbsSurfaceEvaluator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_NurbsSurfaceEvaluator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NurbsSurfaceEvaluator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NurbsSurfaceEvaluator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NurbsSurfaceEvaluator);
  }
}

/**
 * Python method tables for RopeNode (RopeNode)
 */
static PyMethodDef Dtool_Methods_RopeNode[] = {
  {"set_curve", &Dtool_RopeNode_set_curve_244, METH_O, (const char *)Dtool_RopeNode_set_curve_244_comment},
  {"setCurve", &Dtool_RopeNode_set_curve_244, METH_O, (const char *)Dtool_RopeNode_set_curve_244_comment},
  {"get_curve", &Dtool_RopeNode_get_curve_245, METH_NOARGS, (const char *)Dtool_RopeNode_get_curve_245_comment},
  {"getCurve", &Dtool_RopeNode_get_curve_245, METH_NOARGS, (const char *)Dtool_RopeNode_get_curve_245_comment},
  {"set_render_mode", &Dtool_RopeNode_set_render_mode_246, METH_O, (const char *)Dtool_RopeNode_set_render_mode_246_comment},
  {"setRenderMode", &Dtool_RopeNode_set_render_mode_246, METH_O, (const char *)Dtool_RopeNode_set_render_mode_246_comment},
  {"get_render_mode", &Dtool_RopeNode_get_render_mode_247, METH_NOARGS, (const char *)Dtool_RopeNode_get_render_mode_247_comment},
  {"getRenderMode", &Dtool_RopeNode_get_render_mode_247, METH_NOARGS, (const char *)Dtool_RopeNode_get_render_mode_247_comment},
  {"set_uv_mode", &Dtool_RopeNode_set_uv_mode_248, METH_O, (const char *)Dtool_RopeNode_set_uv_mode_248_comment},
  {"setUvMode", &Dtool_RopeNode_set_uv_mode_248, METH_O, (const char *)Dtool_RopeNode_set_uv_mode_248_comment},
  {"get_uv_mode", &Dtool_RopeNode_get_uv_mode_249, METH_NOARGS, (const char *)Dtool_RopeNode_get_uv_mode_249_comment},
  {"getUvMode", &Dtool_RopeNode_get_uv_mode_249, METH_NOARGS, (const char *)Dtool_RopeNode_get_uv_mode_249_comment},
  {"set_uv_direction", &Dtool_RopeNode_set_uv_direction_250, METH_O, (const char *)Dtool_RopeNode_set_uv_direction_250_comment},
  {"setUvDirection", &Dtool_RopeNode_set_uv_direction_250, METH_O, (const char *)Dtool_RopeNode_set_uv_direction_250_comment},
  {"get_uv_direction", &Dtool_RopeNode_get_uv_direction_251, METH_NOARGS, (const char *)Dtool_RopeNode_get_uv_direction_251_comment},
  {"getUvDirection", &Dtool_RopeNode_get_uv_direction_251, METH_NOARGS, (const char *)Dtool_RopeNode_get_uv_direction_251_comment},
  {"set_uv_scale", &Dtool_RopeNode_set_uv_scale_252, METH_O, (const char *)Dtool_RopeNode_set_uv_scale_252_comment},
  {"setUvScale", &Dtool_RopeNode_set_uv_scale_252, METH_O, (const char *)Dtool_RopeNode_set_uv_scale_252_comment},
  {"get_uv_scale", &Dtool_RopeNode_get_uv_scale_253, METH_NOARGS, (const char *)Dtool_RopeNode_get_uv_scale_253_comment},
  {"getUvScale", &Dtool_RopeNode_get_uv_scale_253, METH_NOARGS, (const char *)Dtool_RopeNode_get_uv_scale_253_comment},
  {"set_normal_mode", &Dtool_RopeNode_set_normal_mode_254, METH_O, (const char *)Dtool_RopeNode_set_normal_mode_254_comment},
  {"setNormalMode", &Dtool_RopeNode_set_normal_mode_254, METH_O, (const char *)Dtool_RopeNode_set_normal_mode_254_comment},
  {"get_normal_mode", &Dtool_RopeNode_get_normal_mode_255, METH_NOARGS, (const char *)Dtool_RopeNode_get_normal_mode_255_comment},
  {"getNormalMode", &Dtool_RopeNode_get_normal_mode_255, METH_NOARGS, (const char *)Dtool_RopeNode_get_normal_mode_255_comment},
  {"set_tube_up", &Dtool_RopeNode_set_tube_up_256, METH_O, (const char *)Dtool_RopeNode_set_tube_up_256_comment},
  {"setTubeUp", &Dtool_RopeNode_set_tube_up_256, METH_O, (const char *)Dtool_RopeNode_set_tube_up_256_comment},
  {"get_tube_up", &Dtool_RopeNode_get_tube_up_257, METH_NOARGS, (const char *)Dtool_RopeNode_get_tube_up_257_comment},
  {"getTubeUp", &Dtool_RopeNode_get_tube_up_257, METH_NOARGS, (const char *)Dtool_RopeNode_get_tube_up_257_comment},
  {"set_use_vertex_color", &Dtool_RopeNode_set_use_vertex_color_258, METH_O, (const char *)Dtool_RopeNode_set_use_vertex_color_258_comment},
  {"setUseVertexColor", &Dtool_RopeNode_set_use_vertex_color_258, METH_O, (const char *)Dtool_RopeNode_set_use_vertex_color_258_comment},
  {"get_use_vertex_color", &Dtool_RopeNode_get_use_vertex_color_259, METH_NOARGS, (const char *)Dtool_RopeNode_get_use_vertex_color_259_comment},
  {"getUseVertexColor", &Dtool_RopeNode_get_use_vertex_color_259, METH_NOARGS, (const char *)Dtool_RopeNode_get_use_vertex_color_259_comment},
  {"get_vertex_color_dimension", &Dtool_RopeNode_get_vertex_color_dimension_260, METH_NOARGS | METH_STATIC, (const char *)Dtool_RopeNode_get_vertex_color_dimension_260_comment},
  {"getVertexColorDimension", &Dtool_RopeNode_get_vertex_color_dimension_260, METH_NOARGS | METH_STATIC, (const char *)Dtool_RopeNode_get_vertex_color_dimension_260_comment},
  {"set_num_subdiv", &Dtool_RopeNode_set_num_subdiv_261, METH_O, (const char *)Dtool_RopeNode_set_num_subdiv_261_comment},
  {"setNumSubdiv", &Dtool_RopeNode_set_num_subdiv_261, METH_O, (const char *)Dtool_RopeNode_set_num_subdiv_261_comment},
  {"get_num_subdiv", &Dtool_RopeNode_get_num_subdiv_262, METH_NOARGS, (const char *)Dtool_RopeNode_get_num_subdiv_262_comment},
  {"getNumSubdiv", &Dtool_RopeNode_get_num_subdiv_262, METH_NOARGS, (const char *)Dtool_RopeNode_get_num_subdiv_262_comment},
  {"set_num_slices", &Dtool_RopeNode_set_num_slices_263, METH_O, (const char *)Dtool_RopeNode_set_num_slices_263_comment},
  {"setNumSlices", &Dtool_RopeNode_set_num_slices_263, METH_O, (const char *)Dtool_RopeNode_set_num_slices_263_comment},
  {"get_num_slices", &Dtool_RopeNode_get_num_slices_264, METH_NOARGS, (const char *)Dtool_RopeNode_get_num_slices_264_comment},
  {"getNumSlices", &Dtool_RopeNode_get_num_slices_264, METH_NOARGS, (const char *)Dtool_RopeNode_get_num_slices_264_comment},
  {"set_use_vertex_thickness", &Dtool_RopeNode_set_use_vertex_thickness_265, METH_O, (const char *)Dtool_RopeNode_set_use_vertex_thickness_265_comment},
  {"setUseVertexThickness", &Dtool_RopeNode_set_use_vertex_thickness_265, METH_O, (const char *)Dtool_RopeNode_set_use_vertex_thickness_265_comment},
  {"get_use_vertex_thickness", &Dtool_RopeNode_get_use_vertex_thickness_266, METH_NOARGS, (const char *)Dtool_RopeNode_get_use_vertex_thickness_266_comment},
  {"getUseVertexThickness", &Dtool_RopeNode_get_use_vertex_thickness_266, METH_NOARGS, (const char *)Dtool_RopeNode_get_use_vertex_thickness_266_comment},
  {"get_vertex_thickness_dimension", &Dtool_RopeNode_get_vertex_thickness_dimension_267, METH_NOARGS | METH_STATIC, (const char *)Dtool_RopeNode_get_vertex_thickness_dimension_267_comment},
  {"getVertexThicknessDimension", &Dtool_RopeNode_get_vertex_thickness_dimension_267, METH_NOARGS | METH_STATIC, (const char *)Dtool_RopeNode_get_vertex_thickness_dimension_267_comment},
  {"set_thickness", &Dtool_RopeNode_set_thickness_268, METH_O, (const char *)Dtool_RopeNode_set_thickness_268_comment},
  {"setThickness", &Dtool_RopeNode_set_thickness_268, METH_O, (const char *)Dtool_RopeNode_set_thickness_268_comment},
  {"get_thickness", &Dtool_RopeNode_get_thickness_269, METH_NOARGS, (const char *)Dtool_RopeNode_get_thickness_269_comment},
  {"getThickness", &Dtool_RopeNode_get_thickness_269, METH_NOARGS, (const char *)Dtool_RopeNode_get_thickness_269_comment},
  {"set_matrix", &Dtool_RopeNode_set_matrix_270, METH_O, (const char *)Dtool_RopeNode_set_matrix_270_comment},
  {"setMatrix", &Dtool_RopeNode_set_matrix_270, METH_O, (const char *)Dtool_RopeNode_set_matrix_270_comment},
  {"clear_matrix", &Dtool_RopeNode_clear_matrix_271, METH_NOARGS, (const char *)Dtool_RopeNode_clear_matrix_271_comment},
  {"clearMatrix", &Dtool_RopeNode_clear_matrix_271, METH_NOARGS, (const char *)Dtool_RopeNode_clear_matrix_271_comment},
  {"has_matrix", &Dtool_RopeNode_has_matrix_272, METH_NOARGS, (const char *)Dtool_RopeNode_has_matrix_272_comment},
  {"hasMatrix", &Dtool_RopeNode_has_matrix_272, METH_NOARGS, (const char *)Dtool_RopeNode_has_matrix_272_comment},
  {"get_matrix", &Dtool_RopeNode_get_matrix_273, METH_NOARGS, (const char *)Dtool_RopeNode_get_matrix_273_comment},
  {"getMatrix", &Dtool_RopeNode_get_matrix_273, METH_NOARGS, (const char *)Dtool_RopeNode_get_matrix_273_comment},
  {"reset_bound", &Dtool_RopeNode_reset_bound_274, METH_O, (const char *)Dtool_RopeNode_reset_bound_274_comment},
  {"resetBound", &Dtool_RopeNode_reset_bound_274, METH_O, (const char *)Dtool_RopeNode_reset_bound_274_comment},
  {"get_class_type", &Dtool_RopeNode_get_class_type_275, METH_NOARGS | METH_STATIC, (const char *)Dtool_RopeNode_get_class_type_275_comment},
  {"getClassType", &Dtool_RopeNode_get_class_type_275, METH_NOARGS | METH_STATIC, (const char *)Dtool_RopeNode_get_class_type_275_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_RopeNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RopeNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_RopeNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_RopeNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_RopeNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.RopeNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_RopeNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_RopeNode,
    &Dtool_SequenceMethods_RopeNode,
    &Dtool_MappingMethods_RopeNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_RopeNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class draws a visible representation of the NURBS curve stored in its\n"
    " * NurbsCurveEvaluator.  It automatically recomputes the curve every frame.\n"
    " *\n"
    " * This is not related to NurbsCurve, CubicCurveseg or any of the\n"
    " * ParametricCurve-derived objects in this module.  It is a completely\n"
    " * parallel implementation of NURBS curves, and will probably eventually\n"
    " * replace the whole ParametricCurve class hierarchy.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_RopeNode,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_RopeNode,
    PyType_GenericAlloc,
    Dtool_new_RopeNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RopeNode,
  Dtool_UpcastInterface_RopeNode,
  Dtool_DowncastInterface_RopeNode,
  (CoerceFunction)Dtool_ConstCoerce_RopeNode,
  (CoerceFunction)Dtool_Coerce_RopeNode,
};

static void Dtool_PyModuleClassInit_RopeNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_RopeNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = _PyDict_NewPresized(21);
    Dtool_RopeNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum RopeNode::RenderMode;
    PyDict_SetItemString(dict, "RM_thread", Dtool_WrapValue(RopeNode::RM_thread));
    PyDict_SetItemString(dict, "RMThread", Dtool_WrapValue(RopeNode::RM_thread));
    PyDict_SetItemString(dict, "RM_tape", Dtool_WrapValue(RopeNode::RM_tape));
    PyDict_SetItemString(dict, "RMTape", Dtool_WrapValue(RopeNode::RM_tape));
    PyDict_SetItemString(dict, "RM_billboard", Dtool_WrapValue(RopeNode::RM_billboard));
    PyDict_SetItemString(dict, "RMBillboard", Dtool_WrapValue(RopeNode::RM_billboard));
    PyDict_SetItemString(dict, "RM_tube", Dtool_WrapValue(RopeNode::RM_tube));
    PyDict_SetItemString(dict, "RMTube", Dtool_WrapValue(RopeNode::RM_tube));
    // enum RopeNode::UVMode;
    PyDict_SetItemString(dict, "UV_none", Dtool_WrapValue(RopeNode::UV_none));
    PyDict_SetItemString(dict, "UVNone", Dtool_WrapValue(RopeNode::UV_none));
    PyDict_SetItemString(dict, "UV_parametric", Dtool_WrapValue(RopeNode::UV_parametric));
    PyDict_SetItemString(dict, "UVParametric", Dtool_WrapValue(RopeNode::UV_parametric));
    PyDict_SetItemString(dict, "UV_distance", Dtool_WrapValue(RopeNode::UV_distance));
    PyDict_SetItemString(dict, "UVDistance", Dtool_WrapValue(RopeNode::UV_distance));
    PyDict_SetItemString(dict, "UV_distance2", Dtool_WrapValue(RopeNode::UV_distance2));
    PyDict_SetItemString(dict, "UVDistance2", Dtool_WrapValue(RopeNode::UV_distance2));
    // enum RopeNode::NormalMode;
    PyDict_SetItemString(dict, "NM_none", Dtool_WrapValue(RopeNode::NM_none));
    PyDict_SetItemString(dict, "NMNone", Dtool_WrapValue(RopeNode::NM_none));
    PyDict_SetItemString(dict, "NM_vertex", Dtool_WrapValue(RopeNode::NM_vertex));
    PyDict_SetItemString(dict, "NMVertex", Dtool_WrapValue(RopeNode::NM_vertex));
    if (PyType_Ready((PyTypeObject *)&Dtool_RopeNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RopeNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RopeNode);
  }
}

/**
 * Python method tables for SheetNode (SheetNode)
 */
static PyMethodDef Dtool_Methods_SheetNode[] = {
  {"set_surface", &Dtool_SheetNode_set_surface_279, METH_O, (const char *)Dtool_SheetNode_set_surface_279_comment},
  {"setSurface", &Dtool_SheetNode_set_surface_279, METH_O, (const char *)Dtool_SheetNode_set_surface_279_comment},
  {"get_surface", &Dtool_SheetNode_get_surface_280, METH_NOARGS, (const char *)Dtool_SheetNode_get_surface_280_comment},
  {"getSurface", &Dtool_SheetNode_get_surface_280, METH_NOARGS, (const char *)Dtool_SheetNode_get_surface_280_comment},
  {"set_use_vertex_color", &Dtool_SheetNode_set_use_vertex_color_281, METH_O, (const char *)Dtool_SheetNode_set_use_vertex_color_281_comment},
  {"setUseVertexColor", &Dtool_SheetNode_set_use_vertex_color_281, METH_O, (const char *)Dtool_SheetNode_set_use_vertex_color_281_comment},
  {"get_use_vertex_color", &Dtool_SheetNode_get_use_vertex_color_282, METH_NOARGS, (const char *)Dtool_SheetNode_get_use_vertex_color_282_comment},
  {"getUseVertexColor", &Dtool_SheetNode_get_use_vertex_color_282, METH_NOARGS, (const char *)Dtool_SheetNode_get_use_vertex_color_282_comment},
  {"set_num_u_subdiv", &Dtool_SheetNode_set_num_u_subdiv_283, METH_O, (const char *)Dtool_SheetNode_set_num_u_subdiv_283_comment},
  {"setNumUSubdiv", &Dtool_SheetNode_set_num_u_subdiv_283, METH_O, (const char *)Dtool_SheetNode_set_num_u_subdiv_283_comment},
  {"get_num_u_subdiv", &Dtool_SheetNode_get_num_u_subdiv_284, METH_NOARGS, (const char *)Dtool_SheetNode_get_num_u_subdiv_284_comment},
  {"getNumUSubdiv", &Dtool_SheetNode_get_num_u_subdiv_284, METH_NOARGS, (const char *)Dtool_SheetNode_get_num_u_subdiv_284_comment},
  {"set_num_v_subdiv", &Dtool_SheetNode_set_num_v_subdiv_285, METH_O, (const char *)Dtool_SheetNode_set_num_v_subdiv_285_comment},
  {"setNumVSubdiv", &Dtool_SheetNode_set_num_v_subdiv_285, METH_O, (const char *)Dtool_SheetNode_set_num_v_subdiv_285_comment},
  {"get_num_v_subdiv", &Dtool_SheetNode_get_num_v_subdiv_286, METH_NOARGS, (const char *)Dtool_SheetNode_get_num_v_subdiv_286_comment},
  {"getNumVSubdiv", &Dtool_SheetNode_get_num_v_subdiv_286, METH_NOARGS, (const char *)Dtool_SheetNode_get_num_v_subdiv_286_comment},
  {"reset_bound", &Dtool_SheetNode_reset_bound_287, METH_O, (const char *)Dtool_SheetNode_reset_bound_287_comment},
  {"resetBound", &Dtool_SheetNode_reset_bound_287, METH_O, (const char *)Dtool_SheetNode_reset_bound_287_comment},
  {"get_class_type", &Dtool_SheetNode_get_class_type_288, METH_NOARGS | METH_STATIC, (const char *)Dtool_SheetNode_get_class_type_288_comment},
  {"getClassType", &Dtool_SheetNode_get_class_type_288, METH_NOARGS | METH_STATIC, (const char *)Dtool_SheetNode_get_class_type_288_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_SheetNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SheetNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_SheetNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_SheetNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_SheetNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.SheetNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SheetNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_SheetNode,
    &Dtool_SequenceMethods_SheetNode,
    &Dtool_MappingMethods_SheetNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_SheetNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class draws a visible representation of the NURBS surface stored in\n"
    " * its NurbsSurfaceEvaluator.  It automatically recomputes the surface every\n"
    " * frame.\n"
    " *\n"
    " * This is not related to NurbsSurface, CubicSurfaceseg or any of the\n"
    " * ParametricSurface-derived objects in this module.  It is a completely\n"
    " * parallel implementation of NURBS surfaces, and will probably eventually\n"
    " * replace the whole ParametricSurface class hierarchy.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SheetNode,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SheetNode,
    PyType_GenericAlloc,
    Dtool_new_SheetNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SheetNode,
  Dtool_UpcastInterface_SheetNode,
  Dtool_DowncastInterface_SheetNode,
  (CoerceFunction)Dtool_ConstCoerce_SheetNode,
  (CoerceFunction)Dtool_Coerce_SheetNode,
};

static void Dtool_PyModuleClassInit_SheetNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_SheetNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_SheetNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SheetNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SheetNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SheetNode);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3parametrics_RegisterTypes() {
  Dtool_ParametricCurve._type = ParametricCurve::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ParametricCurve);
  Dtool_CubicCurveseg._type = CubicCurveseg::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CubicCurveseg);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ParametricCurveCollection", Dtool_ParametricCurveCollection);
#endif
  Dtool_CurveFitter._type = CurveFitter::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CurveFitter);
  Dtool_PiecewiseCurve._type = PiecewiseCurve::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PiecewiseCurve);
  Dtool_HermiteCurve._type = HermiteCurve::get_class_type();
  RegisterRuntimeTypedClass(Dtool_HermiteCurve);
  Dtool_NurbsCurveInterface._type = NurbsCurveInterface::get_class_type();
  RegisterRuntimeTypedClass(Dtool_NurbsCurveInterface);
  Dtool_NurbsCurve._type = NurbsCurve::get_class_type();
  RegisterRuntimeTypedClass(Dtool_NurbsCurve);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("NurbsCurveResult", Dtool_NurbsCurveResult);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("NurbsCurveEvaluator", Dtool_NurbsCurveEvaluator);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("NurbsSurfaceResult", Dtool_NurbsSurfaceResult);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("NurbsSurfaceEvaluator", Dtool_NurbsSurfaceEvaluator);
#endif
  Dtool_RopeNode._type = RopeNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_RopeNode);
  Dtool_SheetNode._type = SheetNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_SheetNode);
}

void Dtool_libp3parametrics_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_Filename = LookupRuntimeTypedClass(Filename::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_TypedWritable = LookupRuntimeTypedClass(TypedWritable::get_class_type());
  Dtool_Ptr_TypedWritableReferenceCount = LookupRuntimeTypedClass(TypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_LVecBase3f = LookupRuntimeTypedClass(LVecBase3f::get_class_type());
  Dtool_Ptr_LVector3f = LookupRuntimeTypedClass(LVector3f::get_class_type());
  Dtool_Ptr_LPoint3f = LookupRuntimeTypedClass(LPoint3f::get_class_type());
  Dtool_Ptr_LVecBase4f = LookupRuntimeTypedClass(LVecBase4f::get_class_type());
  Dtool_Ptr_LMatrix4f = LookupRuntimeTypedClass(LMatrix4f::get_class_type());
  Dtool_Ptr_PandaNode = LookupRuntimeTypedClass(PandaNode::get_class_type());
  Dtool_Ptr_NodePath = LookupRuntimeTypedClass(NodePath::get_class_type());
#endif
}

void Dtool_libp3parametrics_BuildInstants(PyObject *module) {
  (void) module;
  PyModule_AddIntConstant(module, "HC_CUT", 1);
  PyModule_AddIntConstant(module, "HCCUT", 1);
  PyModule_AddIntConstant(module, "HC_FREE", 2);
  PyModule_AddIntConstant(module, "HCFREE", 2);
  PyModule_AddIntConstant(module, "HC_G1", 3);
  PyModule_AddIntConstant(module, "HCG1", 3);
  PyModule_AddIntConstant(module, "HC_SMOOTH", 4);
  PyModule_AddIntConstant(module, "HCSMOOTH", 4);
  PyModule_AddIntConstant(module, "PCT_HPR", 2);
  PyModule_AddIntConstant(module, "PCTHPR", 2);
  PyModule_AddIntConstant(module, "PCT_NONE", 0);
  PyModule_AddIntConstant(module, "PCTNONE", 0);
  PyModule_AddIntConstant(module, "PCT_T", 3);
  PyModule_AddIntConstant(module, "PCTT", 3);
  PyModule_AddIntConstant(module, "PCT_XYZ", 1);
  PyModule_AddIntConstant(module, "PCTXYZ", 1);
  // ParametricCurve
  Dtool_PyModuleClassInit_ParametricCurve(module);
  PyModule_AddObject(module, "ParametricCurve", (PyObject *)&Dtool_ParametricCurve);
  // CubicCurveseg
  Dtool_PyModuleClassInit_CubicCurveseg(module);
  PyModule_AddObject(module, "CubicCurveseg", (PyObject *)&Dtool_CubicCurveseg);
  // ParametricCurveCollection
  Dtool_PyModuleClassInit_ParametricCurveCollection(module);
  PyModule_AddObject(module, "ParametricCurveCollection", (PyObject *)&Dtool_ParametricCurveCollection);
  // CurveFitter
  Dtool_PyModuleClassInit_CurveFitter(module);
  PyModule_AddObject(module, "CurveFitter", (PyObject *)&Dtool_CurveFitter);
  // PiecewiseCurve
  Dtool_PyModuleClassInit_PiecewiseCurve(module);
  PyModule_AddObject(module, "PiecewiseCurve", (PyObject *)&Dtool_PiecewiseCurve);
  // HermiteCurve
  Dtool_PyModuleClassInit_HermiteCurve(module);
  PyModule_AddObject(module, "HermiteCurve", (PyObject *)&Dtool_HermiteCurve);
  // NurbsCurveInterface
  Dtool_PyModuleClassInit_NurbsCurveInterface(module);
  PyModule_AddObject(module, "NurbsCurveInterface", (PyObject *)&Dtool_NurbsCurveInterface);
  // NurbsCurve
  Dtool_PyModuleClassInit_NurbsCurve(module);
  PyModule_AddObject(module, "NurbsCurve", (PyObject *)&Dtool_NurbsCurve);
  // NurbsCurveResult
  Dtool_PyModuleClassInit_NurbsCurveResult(module);
  PyModule_AddObject(module, "NurbsCurveResult", (PyObject *)&Dtool_NurbsCurveResult);
  // NurbsCurveEvaluator
  Dtool_PyModuleClassInit_NurbsCurveEvaluator(module);
  PyModule_AddObject(module, "NurbsCurveEvaluator", (PyObject *)&Dtool_NurbsCurveEvaluator);
  // NurbsSurfaceResult
  Dtool_PyModuleClassInit_NurbsSurfaceResult(module);
  PyModule_AddObject(module, "NurbsSurfaceResult", (PyObject *)&Dtool_NurbsSurfaceResult);
  // NurbsSurfaceEvaluator
  Dtool_PyModuleClassInit_NurbsSurfaceEvaluator(module);
  PyModule_AddObject(module, "NurbsSurfaceEvaluator", (PyObject *)&Dtool_NurbsSurfaceEvaluator);
  // RopeNode
  Dtool_PyModuleClassInit_RopeNode(module);
  PyModule_AddObject(module, "RopeNode", (PyObject *)&Dtool_RopeNode);
  // SheetNode
  Dtool_PyModuleClassInit_SheetNode(module);
  PyModule_AddObject(module, "SheetNode", (PyObject *)&Dtool_SheetNode);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3parametrics_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478213494,  /* file_identifier */
  "libp3parametrics",  /* library_name */
  "UKlv",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3parametrics.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  647  /* next_index */
};

Configure(_in_configure_libp3parametrics);
ConfigureFn(_in_configure_libp3parametrics) {
  interrogate_request_module(&_in_module_def);
}

