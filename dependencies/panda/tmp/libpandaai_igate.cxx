/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir contrib/src/ai -Icontrib/src/ai -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libpandaai_igate.cxx -od built/pandac/input/libpandaai.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Icontrib/src/ai -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.ai -library libpandaai aiBehaviors.h aiCharacter.h aiGlobals.h aiNode.h aiPathFinder.h aiWorld.h arrival.h config_ai.h evade.h flee.h flock.h meshNode.h obstacleAvoidance.h p3ai_composite1.cxx pathFind.h pathFollow.h pursue.h seek.h wander.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libpandaai
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "aiBehaviors.h"
#include "aiCharacter.h"
#include "aiGlobals.h"
#include "aiNode.h"
#include "aiPathFinder.h"
#include "aiWorld.h"
#include "arrival.h"
#include "boundingSphere.h"
#include "cmath.h"
#include "config_ai.h"
#include "evade.h"
#include "flee.h"
#include "flock.h"
#include "lineSegs.h"
#include "meshNode.h"
#include "obstacleAvoidance.h"
#include "pathFind.h"
#include "pathFollow.h"
#include "pursue.h"
#include "seek.h"
#include "wander.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class AIBehaviors
 */
typedef AIBehaviors AIBehaviors_localtype;
Define_Module_Class(panda3d.ai, AIBehaviors, AIBehaviors_localtype, AIBehaviors);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AIBehaviors = &Dtool_AIBehaviors;
static void Dtool_PyModuleClassInit_AIBehaviors(PyObject *module);

/**
 * Forward declarations for top-level class AICharacter
 */
typedef AICharacter AICharacter_localtype;
Define_Module_Class(panda3d.ai, AICharacter, AICharacter_localtype, AICharacter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AICharacter = &Dtool_AICharacter;
static void Dtool_PyModuleClassInit_AICharacter(PyObject *module);
bool Dtool_ConstCoerce_AICharacter(PyObject *args, AICharacter const *&coerced, bool &manage);
bool Dtool_Coerce_AICharacter(PyObject *args, AICharacter *&coerced, bool &manage);

/**
 * Forward declarations for top-level class AINode
 */
typedef AINode AINode_localtype;
Define_Module_Class(panda3d.ai, AINode, AINode_localtype, AINode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AINode = &Dtool_AINode;
static void Dtool_PyModuleClassInit_AINode(PyObject *module);
bool Dtool_ConstCoerce_AINode(PyObject *args, AINode const *&coerced, bool &manage);
bool Dtool_Coerce_AINode(PyObject *args, AINode *&coerced, bool &manage);

/**
 * Forward declarations for top-level class Flock
 */
typedef Flock Flock_localtype;
Define_Module_Class(panda3d.ai, Flock, Flock_localtype, Flock);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Flock = &Dtool_Flock;
static void Dtool_PyModuleClassInit_Flock(PyObject *module);
bool Dtool_ConstCoerce_Flock(PyObject *args, Flock const *&coerced, bool &manage);
bool Dtool_Coerce_Flock(PyObject *args, Flock *&coerced, bool &manage);

/**
 * Forward declarations for top-level class AIWorld
 */
typedef AIWorld AIWorld_localtype;
Define_Module_Class(panda3d.ai, AIWorld, AIWorld_localtype, AIWorld);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AIWorld = &Dtool_AIWorld;
static void Dtool_PyModuleClassInit_AIWorld(PyObject *module);
bool Dtool_ConstCoerce_AIWorld(PyObject *args, AIWorld const *&coerced, bool &manage);
bool Dtool_Coerce_AIWorld(PyObject *args, AIWorld *&coerced, bool &manage);

/**
 * Extern declarations for imported classes
 */
// LVecBase3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3f;
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// NodePath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePath;
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class AIBehaviors
 */
/**
 * Python function wrapper for:
 * void AIBehaviors::seek(LVecBase3 pos, float seek_wt = 1.0)
 * void AIBehaviors::seek(NodePath target_object, float seek_wt = 1.0)
 */
static PyObject *Dtool_AIBehaviors_seek_3(PyObject *self, PyObject *args, PyObject *kwds) {
  AIBehaviors *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.seek")) {
    return NULL;
  }
  {
    // -2 void AIBehaviors::seek(LVecBase3 pos, float seek_wt = 1.0)
    PyObject *param1;
    float param2 = 1.0;
    static const char *keyword_list[] = {"pos", "seek_wt", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|f:seek", (char **)keyword_list, &param1, &param2)) {
      LVecBase3 *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
      if (param1_this != NULL) {
        (*local_this).seek(*param1_this, (float)param2);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void AIBehaviors::seek(NodePath target_object, float seek_wt = 1.0)
    PyObject *param1;
    float param2 = 1.0;
    static const char *keyword_list[] = {"target_object", "seek_wt", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|f:seek", (char **)keyword_list, &param1, &param2)) {
      NodePath *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_NodePath, (void **)&param1_this);
      if (param1_this != NULL) {
        (*local_this).seek(*param1_this, (float)param2);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void AIBehaviors::seek(LVecBase3 pos, float seek_wt = 1.0)
    PyObject *param1;
    float param2 = 1.0;
    static const char *keyword_list[] = {"pos", "seek_wt", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|f:seek", (char **)keyword_list, &param1, &param2)) {
      LVecBase3f param1_local;
      LVecBase3 *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
      if ((param1_this != NULL)) {
        (*local_this).seek(*param1_this, (float)param2);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: void AIBehaviors::seek(NodePath target_object, float seek_wt = 1.0)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "seek(const AIBehaviors self, LVecBase3f pos, float seek_wt)\n"
      "seek(const AIBehaviors self, NodePath target_object, float seek_wt)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_seek_3_comment =
  "C++ Interface:\n"
  "seek(const AIBehaviors self, LVecBase3f pos, float seek_wt)\n"
  "seek(const AIBehaviors self, NodePath target_object, float seek_wt)\n"
  "\n"
  "/**\n"
  " * This function activates seek and makes an object of the Seek class.  This\n"
  " * is the function we want the user to call for seek to be done.  This\n"
  " * function is overloaded to accept a NodePath or an LVecBase3.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_seek_3_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::flee(LVecBase3 pos, double panic_distance = 10.0, double relax_distance = 10.0, float flee_wt = 1.0)
 * void AIBehaviors::flee(NodePath target_object, double panic_distance = 10.0, double relax_distance = 10.0, float flee_wt = 1.0)
 */
static PyObject *Dtool_AIBehaviors_flee_4(PyObject *self, PyObject *args, PyObject *kwds) {
  AIBehaviors *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.flee")) {
    return NULL;
  }
  {
    // -2 void AIBehaviors::flee(LVecBase3 pos, double panic_distance = 10.0, double relax_distance = 10.0, float flee_wt = 1.0)
    PyObject *param1;
    double param2 = 10.0;
    double param3 = 10.0;
    float param4 = 1.0;
    static const char *keyword_list[] = {"pos", "panic_distance", "relax_distance", "flee_wt", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|ddf:flee", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      LVecBase3 *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
      if (param1_this != NULL) {
        (*local_this).flee(*param1_this, (double)param2, (double)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void AIBehaviors::flee(NodePath target_object, double panic_distance = 10.0, double relax_distance = 10.0, float flee_wt = 1.0)
    PyObject *param1;
    double param2 = 10.0;
    double param3 = 10.0;
    float param4 = 1.0;
    static const char *keyword_list[] = {"target_object", "panic_distance", "relax_distance", "flee_wt", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|ddf:flee", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      NodePath *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_NodePath, (void **)&param1_this);
      if (param1_this != NULL) {
        (*local_this).flee(*param1_this, (double)param2, (double)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void AIBehaviors::flee(LVecBase3 pos, double panic_distance = 10.0, double relax_distance = 10.0, float flee_wt = 1.0)
    PyObject *param1;
    double param2 = 10.0;
    double param3 = 10.0;
    float param4 = 1.0;
    static const char *keyword_list[] = {"pos", "panic_distance", "relax_distance", "flee_wt", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|ddf:flee", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      LVecBase3f param1_local;
      LVecBase3 *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
      if ((param1_this != NULL)) {
        (*local_this).flee(*param1_this, (double)param2, (double)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: void AIBehaviors::flee(NodePath target_object, double panic_distance = 10.0, double relax_distance = 10.0, float flee_wt = 1.0)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "flee(const AIBehaviors self, LVecBase3f pos, double panic_distance, double relax_distance, float flee_wt)\n"
      "flee(const AIBehaviors self, NodePath target_object, double panic_distance, double relax_distance, float flee_wt)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_flee_4_comment =
  "C++ Interface:\n"
  "flee(const AIBehaviors self, LVecBase3f pos, double panic_distance, double relax_distance, float flee_wt)\n"
  "flee(const AIBehaviors self, NodePath target_object, double panic_distance, double relax_distance, float flee_wt)\n"
  "\n"
  "/**\n"
  " * This function activates flee_activate and creates an object of the Flee\n"
  " * class.  This function is overloaded to accept a NodePath or an LVecBase3.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_flee_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::pursue(NodePath target_object, float pursue_wt = 1.0)
 */
static PyObject *Dtool_AIBehaviors_pursue_5(PyObject *self, PyObject *args, PyObject *kwds) {
  AIBehaviors *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.pursue")) {
    return NULL;
  }
  // 1-void AIBehaviors::pursue(NodePath target_object, float pursue_wt = 1.0)
  PyObject *param1;
  float param2 = 1.0;
  static const char *keyword_list[] = {"target_object", "pursue_wt", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|f:pursue", (char **)keyword_list, &param1, &param2)) {
    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "AIBehaviors.pursue", true, true);
    if (param1_this != NULL) {
      (*local_this).pursue(*param1_this, (float)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pursue(const AIBehaviors self, NodePath target_object, float pursue_wt)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_pursue_5_comment =
  "C++ Interface:\n"
  "pursue(const AIBehaviors self, NodePath target_object, float pursue_wt)\n"
  "\n"
  "/**\n"
  " * This function activates pursue.  This is the function we want the user to\n"
  " * call for pursue to be done.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_pursue_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::evade(NodePath target_object, double panic_distance = 10.0, double relax_distance = 10.0, float evade_wt = 1.0)
 */
static PyObject *Dtool_AIBehaviors_evade_6(PyObject *self, PyObject *args, PyObject *kwds) {
  AIBehaviors *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.evade")) {
    return NULL;
  }
  // 1-void AIBehaviors::evade(NodePath target_object, double panic_distance = 10.0, double relax_distance = 10.0, float evade_wt = 1.0)
  PyObject *param1;
  double param2 = 10.0;
  double param3 = 10.0;
  float param4 = 1.0;
  static const char *keyword_list[] = {"target_object", "panic_distance", "relax_distance", "evade_wt", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|ddf:evade", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "AIBehaviors.evade", true, true);
    if (param1_this != NULL) {
      (*local_this).evade(*param1_this, (double)param2, (double)param3, (float)param4);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "evade(const AIBehaviors self, NodePath target_object, double panic_distance, double relax_distance, float evade_wt)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_evade_6_comment =
  "C++ Interface:\n"
  "evade(const AIBehaviors self, NodePath target_object, double panic_distance, double relax_distance, float evade_wt)\n"
  "\n"
  "/**\n"
  " * This function activates evade_activate.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_evade_6_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::arrival(double distance = 10.0)
 */
static PyObject *Dtool_AIBehaviors_arrival_7(PyObject *self, PyObject *args, PyObject *kwds) {
  AIBehaviors *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.arrival")) {
    return NULL;
  }
  // 1-void AIBehaviors::arrival(double distance = 10.0)
  double param1 = 10.0;
  static const char *keyword_list[] = {"distance", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|d:arrival", (char **)keyword_list, &param1)) {
    (*local_this).arrival((double)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "arrival(const AIBehaviors self, double distance)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_arrival_7_comment =
  "C++ Interface:\n"
  "arrival(const AIBehaviors self, double distance)\n"
  "\n"
  "/**\n"
  " * This function activates arrival.  This is the function we want the user to\n"
  " * call for arrival to be done.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_arrival_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::flock(float flock_wt)
 */
static PyObject *Dtool_AIBehaviors_flock_8(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.flock")) {
    return NULL;
  }
  // 1-void AIBehaviors::flock(float flock_wt)
  if (PyNumber_Check(arg)) {
    (*local_this).flock((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "flock(const AIBehaviors self, float flock_wt)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_flock_8_comment =
  "C++ Interface:\n"
  "flock(const AIBehaviors self, float flock_wt)\n"
  "\n"
  "/**\n"
  " * This function activates flock.  This is the function we want the user to\n"
  " * call for flock to be done.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_flock_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::wander(double wander_radius = 5.0, int flag = 0, double aoe = 0.0, float wander_weight = 1.0)
 */
static PyObject *Dtool_AIBehaviors_wander_9(PyObject *self, PyObject *args, PyObject *kwds) {
  AIBehaviors *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.wander")) {
    return NULL;
  }
  // 1-void AIBehaviors::wander(double wander_radius = 5.0, int flag = 0, double aoe = 0.0, float wander_weight = 1.0)
  double param1 = 5.0;
  int param2 = 0;
  double param3 = 0.0;
  float param4 = 1.0;
  static const char *keyword_list[] = {"wander_radius", "flag", "aoe", "wander_weight", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|didf:wander", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).wander((double)param1, (int)param2, (double)param3, (float)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "wander(const AIBehaviors self, double wander_radius, int flag, double aoe, float wander_weight)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_wander_9_comment =
  "C++ Interface:\n"
  "wander(const AIBehaviors self, double wander_radius, int flag, double aoe, float wander_weight)\n"
  "\n"
  "/**\n"
  " * This function activates wander.  This is the function we want the user to\n"
  " * call for flock to be done.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_wander_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::obstacle_avoidance(float feeler_length = 1.0)
 */
static PyObject *Dtool_AIBehaviors_obstacle_avoidance_10(PyObject *self, PyObject *args, PyObject *kwds) {
  AIBehaviors *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.obstacle_avoidance")) {
    return NULL;
  }
  // 1-void AIBehaviors::obstacle_avoidance(float feeler_length = 1.0)
  float param1 = 1.0;
  static const char *keyword_list[] = {"feeler_length", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|f:obstacle_avoidance", (char **)keyword_list, &param1)) {
    (*local_this).obstacle_avoidance((float)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "obstacle_avoidance(const AIBehaviors self, float feeler_length)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_obstacle_avoidance_10_comment =
  "C++ Interface:\n"
  "obstacle_avoidance(const AIBehaviors self, float feeler_length)\n"
  "\n"
  "/**\n"
  " * This function activates obstacle avoidance for a given character.  This is\n"
  " * the function we want the user to call for obstacle avoidance to be\n"
  " * performed.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_obstacle_avoidance_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::path_follow(float follow_wt)
 */
static PyObject *Dtool_AIBehaviors_path_follow_11(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.path_follow")) {
    return NULL;
  }
  // 1-void AIBehaviors::path_follow(float follow_wt)
  if (PyNumber_Check(arg)) {
    (*local_this).path_follow((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "path_follow(const AIBehaviors self, float follow_wt)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_path_follow_11_comment =
  "C++ Interface:\n"
  "path_follow(const AIBehaviors self, float follow_wt)\n"
  "\n"
  "/**\n"
  " * This function activates path following.  This is the function we want the\n"
  " * user to call for path following.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_path_follow_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::add_to_path(LVecBase3 pos)
 */
static PyObject *Dtool_AIBehaviors_add_to_path_12(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.add_to_path")) {
    return NULL;
  }
  // 1-void AIBehaviors::add_to_path(LVecBase3 pos)
  LVecBase3f arg_local;
  LVecBase3 *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "AIBehaviors.add_to_path", "LVecBase3f");
  }
  (*local_this).add_to_path(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_to_path(const AIBehaviors self, LVecBase3f pos)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_add_to_path_12_comment =
  "C++ Interface:\n"
  "add_to_path(const AIBehaviors self, LVecBase3f pos)\n"
  "\n"
  "/**\n"
  " * This function adds positions to the path to follow.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_add_to_path_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::start_follow(std::string type = "normal")
 */
static PyObject *Dtool_AIBehaviors_start_follow_13(PyObject *self, PyObject *args, PyObject *kwds) {
  AIBehaviors *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.start_follow")) {
    return NULL;
  }
  // 1-void AIBehaviors::start_follow(std::string type = "normal")
  const char *param1_str = "normal";
  Py_ssize_t param1_len = 6;
  static const char *keyword_list[] = {"type", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#:start_follow", (char **)keyword_list, &param1_str, &param1_len)) {
    (*local_this).start_follow(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "start_follow(const AIBehaviors self, str type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_start_follow_13_comment =
  "C++ Interface:\n"
  "start_follow(const AIBehaviors self, str type)\n";
#else
static const char *Dtool_AIBehaviors_start_follow_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::init_path_find(char const *navmesh_filename)
 */
static PyObject *Dtool_AIBehaviors_init_path_find_14(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.init_path_find")) {
    return NULL;
  }
  // 1-void AIBehaviors::init_path_find(char const *navmesh_filename)
  char const *param1;
  if (PyArg_Parse(arg, "z:init_path_find", &param1)) {
    (*local_this).init_path_find((char const *)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "init_path_find(const AIBehaviors self, str navmesh_filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_init_path_find_14_comment =
  "C++ Interface:\n"
  "init_path_find(const AIBehaviors self, str navmesh_filename)\n"
  "\n"
  "// should have different function names.\n"
  "\n"
  "/**\n"
  " * This function activates path finding in the character.  This function\n"
  " * accepts the meshdata in .csv format.\n"
  " *\n"
  " */";
#else
static const char *Dtool_AIBehaviors_init_path_find_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::path_find_to(LVecBase3 pos, std::string type = "normal")
 * void AIBehaviors::path_find_to(NodePath target, std::string type = "normal")
 */
static PyObject *Dtool_AIBehaviors_path_find_to_15(PyObject *self, PyObject *args, PyObject *kwds) {
  AIBehaviors *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.path_find_to")) {
    return NULL;
  }
  {
    // -2 void AIBehaviors::path_find_to(NodePath target, std::string type = "normal")
    PyObject *param1;
    const char *param2_str = "normal";
    Py_ssize_t param2_len = 6;
    static const char *keyword_list[] = {"target", "type", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:path_find_to", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
      NodePath *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_NodePath, (void **)&param1_this);
      if (param1_this != NULL) {
        (*local_this).path_find_to(*param1_this, std::string(param2_str, param2_len));
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: void AIBehaviors::path_find_to(NodePath target, std::string type = "normal")
  {
    // -2 void AIBehaviors::path_find_to(LVecBase3 pos, std::string type = "normal")
    PyObject *param1;
    const char *param2_str = "normal";
    Py_ssize_t param2_len = 6;
    static const char *keyword_list[] = {"pos", "type", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:path_find_to", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
      LVecBase3f param1_local;
      LVecBase3 *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
      if ((param1_this != NULL)) {
        (*local_this).path_find_to(*param1_this, std::string(param2_str, param2_len));
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "path_find_to(const AIBehaviors self, NodePath target, str type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_path_find_to_15_comment =
  "C++ Interface:\n"
  "path_find_to(const AIBehaviors self, NodePath target, str type)\n"
  "\n"
  "/**\n"
  " * This function checks for the source and target in the navigation mesh for\n"
  " * its availability and then finds the best path via the A* algorithm Then it\n"
  " * calls the path follower to make the object follow the path.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This function checks for the source and target in the navigation mesh for\n"
  " * its availability and then finds the best path via the A* algorithm Then it\n"
  " * calls the path follower to make the object follow the path.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_path_find_to_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::add_static_obstacle(NodePath obstacle)
 */
static PyObject *Dtool_AIBehaviors_add_static_obstacle_16(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.add_static_obstacle")) {
    return NULL;
  }
  // 1-void AIBehaviors::add_static_obstacle(NodePath obstacle)
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "AIBehaviors.add_static_obstacle", true, true);
  if (arg_this != NULL) {
    (*local_this).add_static_obstacle(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_static_obstacle(const AIBehaviors self, NodePath obstacle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_add_static_obstacle_16_comment =
  "C++ Interface:\n"
  "add_static_obstacle(const AIBehaviors self, NodePath obstacle)\n"
  "\n"
  "/**\n"
  " * This function allows the user to dynamically add obstacles to the game\n"
  " * environment.  The function will update the nodes within the bounding volume\n"
  " * of the obstacle as non-traversable.  Hence will not be considered by the\n"
  " * pathfinding algorithm.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_add_static_obstacle_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::add_dynamic_obstacle(NodePath obstacle)
 */
static PyObject *Dtool_AIBehaviors_add_dynamic_obstacle_17(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.add_dynamic_obstacle")) {
    return NULL;
  }
  // 1-void AIBehaviors::add_dynamic_obstacle(NodePath obstacle)
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "AIBehaviors.add_dynamic_obstacle", true, true);
  if (arg_this != NULL) {
    (*local_this).add_dynamic_obstacle(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_dynamic_obstacle(const AIBehaviors self, NodePath obstacle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_add_dynamic_obstacle_17_comment =
  "C++ Interface:\n"
  "add_dynamic_obstacle(const AIBehaviors self, NodePath obstacle)\n"
  "\n"
  "/**\n"
  " * This function starts the pathfinding obstacle navigation for the passed in\n"
  " * obstacle.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_add_dynamic_obstacle_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::remove_ai(std::string ai_type)
 */
static PyObject *Dtool_AIBehaviors_remove_ai_18(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.remove_ai")) {
    return NULL;
  }
  // 1-void AIBehaviors::remove_ai(std::string ai_type)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).remove_ai(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_ai(const AIBehaviors self, str ai_type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_remove_ai_18_comment =
  "C++ Interface:\n"
  "remove_ai(const AIBehaviors self, str ai_type)\n"
  "\n"
  "/**\n"
  " * This function removes individual or all the AIs.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_remove_ai_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::pause_ai(std::string ai_type)
 */
static PyObject *Dtool_AIBehaviors_pause_ai_19(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.pause_ai")) {
    return NULL;
  }
  // 1-void AIBehaviors::pause_ai(std::string ai_type)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).pause_ai(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pause_ai(const AIBehaviors self, str ai_type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_pause_ai_19_comment =
  "C++ Interface:\n"
  "pause_ai(const AIBehaviors self, str ai_type)\n"
  "\n"
  "/**\n"
  " * This function pauses individual or all the AIs.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_pause_ai_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::resume_ai(std::string ai_type)
 */
static PyObject *Dtool_AIBehaviors_resume_ai_20(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.resume_ai")) {
    return NULL;
  }
  // 1-void AIBehaviors::resume_ai(std::string ai_type)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).resume_ai(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "resume_ai(const AIBehaviors self, str ai_type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_resume_ai_20_comment =
  "C++ Interface:\n"
  "resume_ai(const AIBehaviors self, str ai_type)\n"
  "\n"
  "/**\n"
  " * This function resumes individual or all the AIs\n"
  " */";
#else
static const char *Dtool_AIBehaviors_resume_ai_20_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string AIBehaviors::behavior_status(std::string ai_type)
 */
static PyObject *Dtool_AIBehaviors_behavior_status_21(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.behavior_status")) {
    return NULL;
  }
  // 1-std::string AIBehaviors::behavior_status(std::string ai_type)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    std::string return_value = (*local_this).behavior_status(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "behavior_status(const AIBehaviors self, str ai_type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_behavior_status_21_comment =
  "C++ Interface:\n"
  "behavior_status(const AIBehaviors self, str ai_type)\n"
  "\n"
  "/**\n"
  " * This function returns the status of an AI Type whether it is active, paused\n"
  " * or disabled.  It returns -1 if an invalid string is passed.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_behavior_status_21_comment = NULL;
#endif

static int Dtool_Init_AIBehaviors(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AIBehaviors(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AIBehaviors) {
    printf("AIBehaviors ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AIBehaviors *local_this = (AIBehaviors *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AIBehaviors) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AIBehaviors(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AIBehaviors) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AICharacter
 */
/**
 * Python function wrapper for:
 * double AICharacter::get_mass(void)
 */
static PyObject *Dtool_AICharacter_get_mass_23(PyObject *self, PyObject *) {
  AICharacter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AICharacter, (void **)&local_this, "AICharacter.get_mass")) {
    return NULL;
  }
  // 1-double AICharacter::get_mass(void)
  double return_value = (*local_this).get_mass();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AICharacter_get_mass_23_comment =
  "C++ Interface:\n"
  "get_mass(const AICharacter self)\n";
#else
static const char *Dtool_AICharacter_get_mass_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AICharacter::set_mass(double m)
 */
static PyObject *Dtool_AICharacter_set_mass_24(PyObject *self, PyObject *arg) {
  AICharacter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AICharacter, (void **)&local_this, "AICharacter.set_mass")) {
    return NULL;
  }
  // 1-void AICharacter::set_mass(double m)
  if (PyNumber_Check(arg)) {
    (*local_this).set_mass(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mass(const AICharacter self, double m)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AICharacter_set_mass_24_comment =
  "C++ Interface:\n"
  "set_mass(const AICharacter self, double m)\n";
#else
static const char *Dtool_AICharacter_set_mass_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVecBase3 AICharacter::get_velocity(void)
 */
static PyObject *Dtool_AICharacter_get_velocity_25(PyObject *self, PyObject *) {
  AICharacter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AICharacter, (void **)&local_this, "AICharacter.get_velocity")) {
    return NULL;
  }
  // 1-LVecBase3 AICharacter::get_velocity(void)
  LVecBase3 *return_value = new LVecBase3((*local_this).get_velocity());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AICharacter_get_velocity_25_comment =
  "C++ Interface:\n"
  "get_velocity(const AICharacter self)\n";
#else
static const char *Dtool_AICharacter_get_velocity_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double AICharacter::get_max_force(void)
 */
static PyObject *Dtool_AICharacter_get_max_force_26(PyObject *self, PyObject *) {
  AICharacter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AICharacter, (void **)&local_this, "AICharacter.get_max_force")) {
    return NULL;
  }
  // 1-double AICharacter::get_max_force(void)
  double return_value = (*local_this).get_max_force();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AICharacter_get_max_force_26_comment =
  "C++ Interface:\n"
  "get_max_force(const AICharacter self)\n";
#else
static const char *Dtool_AICharacter_get_max_force_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AICharacter::set_max_force(double max_force)
 */
static PyObject *Dtool_AICharacter_set_max_force_27(PyObject *self, PyObject *arg) {
  AICharacter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AICharacter, (void **)&local_this, "AICharacter.set_max_force")) {
    return NULL;
  }
  // 1-void AICharacter::set_max_force(double max_force)
  if (PyNumber_Check(arg)) {
    (*local_this).set_max_force(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_force(const AICharacter self, double max_force)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AICharacter_set_max_force_27_comment =
  "C++ Interface:\n"
  "set_max_force(const AICharacter self, double max_force)\n";
#else
static const char *Dtool_AICharacter_set_max_force_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePath AICharacter::get_node_path(void)
 */
static PyObject *Dtool_AICharacter_get_node_path_28(PyObject *self, PyObject *) {
  AICharacter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AICharacter, (void **)&local_this, "AICharacter.get_node_path")) {
    return NULL;
  }
  // 1-NodePath AICharacter::get_node_path(void)
  NodePath *return_value = new NodePath((*local_this).get_node_path());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AICharacter_get_node_path_28_comment =
  "C++ Interface:\n"
  "get_node_path(const AICharacter self)\n";
#else
static const char *Dtool_AICharacter_get_node_path_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AICharacter::set_node_path(NodePath np)
 */
static PyObject *Dtool_AICharacter_set_node_path_29(PyObject *self, PyObject *arg) {
  AICharacter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AICharacter, (void **)&local_this, "AICharacter.set_node_path")) {
    return NULL;
  }
  // 1-void AICharacter::set_node_path(NodePath np)
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "AICharacter.set_node_path", true, true);
  if (arg_this != NULL) {
    (*local_this).set_node_path(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_node_path(const AICharacter self, NodePath np)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AICharacter_set_node_path_29_comment =
  "C++ Interface:\n"
  "set_node_path(const AICharacter self, NodePath np)\n";
#else
static const char *Dtool_AICharacter_set_node_path_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AIBehaviors *AICharacter::get_ai_behaviors(void)
 */
static PyObject *Dtool_AICharacter_get_ai_behaviors_30(PyObject *self, PyObject *) {
  AICharacter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AICharacter, (void **)&local_this, "AICharacter.get_ai_behaviors")) {
    return NULL;
  }
  // 1-AIBehaviors *AICharacter::get_ai_behaviors(void)
  AIBehaviors *return_value = (*local_this).get_ai_behaviors();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AIBehaviors, false, false);
}

#ifndef NDEBUG
static const char *Dtool_AICharacter_get_ai_behaviors_30_comment =
  "C++ Interface:\n"
  "get_ai_behaviors(const AICharacter self)\n";
#else
static const char *Dtool_AICharacter_get_ai_behaviors_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AICharacter::set_pf_guide(bool pf_guide)
 */
static PyObject *Dtool_AICharacter_set_pf_guide_31(PyObject *self, PyObject *arg) {
  AICharacter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AICharacter, (void **)&local_this, "AICharacter.set_pf_guide")) {
    return NULL;
  }
  // 1-void AICharacter::set_pf_guide(bool pf_guide)
  (*local_this).set_pf_guide((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pf_guide(const AICharacter self, bool pf_guide)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AICharacter_set_pf_guide_31_comment =
  "C++ Interface:\n"
  "set_pf_guide(const AICharacter self, bool pf_guide)\n"
  "\n"
  "// This function is used to enable or disable the guides for path finding.";
#else
static const char *Dtool_AICharacter_set_pf_guide_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline AICharacter::AICharacter(AICharacter const &) = default
 * AICharacter::AICharacter(std::string model_name, NodePath model_np, double mass, double movt_force, double max_force)
 */
static int Dtool_Init_AICharacter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline AICharacter::AICharacter(AICharacter const &) = default
      AICharacter const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_AICharacter(arg, arg_this, arg_manage)) {
        Dtool_Raise_ArgTypeError(arg, 0, "AICharacter.AICharacter", "AICharacter");
        return -1;
      }
      AICharacter *return_value = new AICharacter(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AICharacter, true, false);
    }
    break;
  case 5:
    {
      // 1-AICharacter::AICharacter(std::string model_name, NodePath model_np, double mass, double movt_force, double max_force)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      double param2;
      double param3;
      double param4;
      static const char *keyword_list[] = {"model_name", "model_np", "mass", "movt_force", "max_force", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#Oddd:AICharacter", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
        NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "AICharacter.AICharacter", true, true);
        if (param1_this != NULL) {
          AICharacter *return_value = new AICharacter(std::string(param0_str, param0_len), *param1_this, (double)param2, (double)param3, (double)param4);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AICharacter, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "AICharacter() takes 1 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AICharacter(const AICharacter param0)\n"
      "AICharacter(str model_name, NodePath model_np, double mass, double movt_force, double max_force)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_AICharacter(PyObject *args, AICharacter const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AICharacter, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 5) {
      // 1-AICharacter::AICharacter(std::string model_name, NodePath model_np, double mass, double movt_force, double max_force)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      double param2;
      double param3;
      double param4;
      if (PyArg_ParseTuple(args, "s#Oddd:AICharacter", &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
        NodePath *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_NodePath, (void **)&param1_this);
        if (param1_this != NULL) {
          AICharacter *return_value = new AICharacter(std::string(param0_str, param0_len), *param1_this, (double)param2, (double)param3, (double)param4);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_AICharacter(PyObject *args, AICharacter *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AICharacter, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 5) {
      // 1-AICharacter::AICharacter(std::string model_name, NodePath model_np, double mass, double movt_force, double max_force)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      double param2;
      double param3;
      double param4;
      if (PyArg_ParseTuple(args, "s#Oddd:AICharacter", &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
        NodePath *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_NodePath, (void **)&param1_this);
        if (param1_this != NULL) {
          AICharacter *return_value = new AICharacter(std::string(param0_str, param0_len), *param1_this, (double)param2, (double)param3, (double)param4);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_AICharacter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AICharacter) {
    printf("AICharacter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AICharacter *local_this = (AICharacter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AICharacter) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AICharacter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AICharacter) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AINode
 */
/**
 * Python function wrapper for:
 * bool AINode::contains(float x, float y)
 */
static PyObject *Dtool_AINode_contains_37(PyObject *self, PyObject *args, PyObject *kwds) {
  AINode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AINode, (void **)&local_this, "AINode.contains")) {
    return NULL;
  }
  // 1-bool AINode::contains(float x, float y)
  float param1;
  float param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:contains", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*local_this).contains((float)param1, (float)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "contains(const AINode self, float x, float y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AINode_contains_37_comment =
  "C++ Interface:\n"
  "contains(const AINode self, float x, float y)\n"
  "\n"
  "/**\n"
  " * This is a handy function which returns true if the passed position is\n"
  " * within the node's dimensions.\n"
  " */";
#else
static const char *Dtool_AINode_contains_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AINode::AINode(int grid_x, int grid_y, LVecBase3 pos, float w, float l, float h)
 */
static int Dtool_Init_AINode(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-AINode::AINode(int grid_x, int grid_y, LVecBase3 pos, float w, float l, float h)
  int param0;
  int param1;
  PyObject *param2;
  float param3;
  float param4;
  float param5;
  static const char *keyword_list[] = {"grid_x", "grid_y", "pos", "w", "l", "h", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiOfff:AINode", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      Dtool_Raise_ArgTypeError(param2, 2, "AINode.AINode", "LVecBase3f");
      return -1;
    }
    AINode *return_value = new AINode((int)param0, (int)param1, *param2_this, (float)param3, (float)param4, (float)param5);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AINode, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AINode(int grid_x, int grid_y, LVecBase3f pos, float w, float l, float h)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_AINode(PyObject *args, AINode const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AINode, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 6) {
      // 1-AINode::AINode(int grid_x, int grid_y, LVecBase3 pos, float w, float l, float h)
      int param0;
      int param1;
      PyObject *param2;
      float param3;
      float param4;
      float param5;
      if (PyArg_ParseTuple(args, "iiOfff:AINode", &param0, &param1, &param2, &param3, &param4, &param5)) {
        LVecBase3 *param2_this;
        DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
        if (param2_this != NULL) {
          AINode *return_value = new AINode((int)param0, (int)param1, *param2_this, (float)param3, (float)param4, (float)param5);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_AINode(PyObject *args, AINode *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AINode, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 6) {
      // 1-AINode::AINode(int grid_x, int grid_y, LVecBase3 pos, float w, float l, float h)
      int param0;
      int param1;
      PyObject *param2;
      float param3;
      float param4;
      float param5;
      if (PyArg_ParseTuple(args, "iiOfff:AINode", &param0, &param1, &param2, &param3, &param4, &param5)) {
        LVecBase3 *param2_this;
        DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
        if (param2_this != NULL) {
          AINode *return_value = new AINode((int)param0, (int)param1, *param2_this, (float)param3, (float)param4, (float)param5);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_AINode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AINode) {
    printf("AINode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AINode *local_this = (AINode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AINode) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AINode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AINode) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Flock
 */
/**
 * Python function wrapper for:
 * void Flock::add_ai_char(AICharacter *ai_char)
 */
static PyObject *Dtool_Flock_add_ai_char_41(PyObject *self, PyObject *arg) {
  Flock *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Flock, (void **)&local_this, "Flock.add_ai_char")) {
    return NULL;
  }
  // 1-void Flock::add_ai_char(AICharacter *ai_char)
  AICharacter *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_AICharacter(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Flock.add_ai_char", "AICharacter");
  }
  (*local_this).add_ai_char(arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_ai_char(const Flock self, AICharacter ai_char)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Flock_add_ai_char_41_comment =
  "C++ Interface:\n"
  "add_ai_char(const Flock self, AICharacter ai_char)\n"
  "\n"
  "// Function to add the ai characters to _ai_char_list.\n"
  "\n"
  "/**\n"
  " * This function adds AI characters to the flock.\n"
  " */";
#else
static const char *Dtool_Flock_add_ai_char_41_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * unsigned int Flock::get_id(void)
 */
static PyObject *Dtool_Flock_get_id_42(PyObject *self, PyObject *) {
  Flock *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Flock, (void **)&local_this, "Flock.get_id")) {
    return NULL;
  }
  // 1-unsigned int Flock::get_id(void)
  unsigned int return_value = (*local_this).get_id();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Flock_get_id_42_comment =
  "C++ Interface:\n"
  "get_id(const Flock self)\n"
  "\n"
  "// Function to access the private member flock_id.";
#else
static const char *Dtool_Flock_get_id_42_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Flock::Flock(Flock const &) = default
 * Flock::Flock(unsigned int flock_id, double vcone_angle, double vcone_radius, unsigned int separation_wt = 2, unsigned int cohesion_wt = 4, unsigned int alignment_wt = 1)
 */
static int Dtool_Init_Flock(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline Flock::Flock(Flock const &) = default
      Flock const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_Flock(arg, arg_this, arg_manage)) {
        Dtool_Raise_ArgTypeError(arg, 0, "Flock.Flock", "Flock");
        return -1;
      }
      Flock *return_value = new Flock(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Flock, true, false);
    }
    break;
  case 3:
  case 4:
  case 5:
  case 6:
    {
      // 1-Flock::Flock(unsigned int flock_id, double vcone_angle, double vcone_radius, unsigned int separation_wt = 2, unsigned int cohesion_wt = 4, unsigned int alignment_wt = 1)
      unsigned long param0;
      double param1;
      double param2;
      unsigned long param3 = 2;
      unsigned long param4 = 4;
      unsigned long param5 = 1;
      static const char *keyword_list[] = {"flock_id", "vcone_angle", "vcone_radius", "separation_wt", "cohesion_wt", "alignment_wt", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kdd|kkk:Flock", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param0 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param0);
          return -1;
        }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param3 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param3);
          return -1;
        }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param4 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param4);
          return -1;
        }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param5 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param5);
          return -1;
        }
#endif
        Flock *return_value = new Flock((unsigned int)param0, (double)param1, (double)param2, (unsigned int)param3, (unsigned int)param4, (unsigned int)param5);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Flock, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Flock() takes 1, 3, 4, 5 or 6 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Flock(const Flock param0)\n"
      "Flock(int flock_id, double vcone_angle, double vcone_radius, int separation_wt, int cohesion_wt, int alignment_wt)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Flock(PyObject *args, Flock const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Flock, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 3 && size <= 6) {
      // 1-Flock::Flock(unsigned int flock_id, double vcone_angle, double vcone_radius, unsigned int separation_wt = 2, unsigned int cohesion_wt = 4, unsigned int alignment_wt = 1)
      unsigned long param0;
      double param1;
      double param2;
      unsigned long param3 = 2;
      unsigned long param4 = 4;
      unsigned long param5 = 1;
      if (PyArg_ParseTuple(args, "kdd|kkk:Flock", &param0, &param1, &param2, &param3, &param4, &param5)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param0 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param0);
          return false;
        }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param3 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param3);
          return false;
        }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param4 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param4);
          return false;
        }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param5 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param5);
          return false;
        }
#endif
        Flock *return_value = new Flock((unsigned int)param0, (double)param1, (double)param2, (unsigned int)param3, (unsigned int)param4, (unsigned int)param5);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_Flock(PyObject *args, Flock *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Flock, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 3 && size <= 6) {
      // 1-Flock::Flock(unsigned int flock_id, double vcone_angle, double vcone_radius, unsigned int separation_wt = 2, unsigned int cohesion_wt = 4, unsigned int alignment_wt = 1)
      unsigned long param0;
      double param1;
      double param2;
      unsigned long param3 = 2;
      unsigned long param4 = 4;
      unsigned long param5 = 1;
      if (PyArg_ParseTuple(args, "kdd|kkk:Flock", &param0, &param1, &param2, &param3, &param4, &param5)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param0 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param0);
          return false;
        }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param3 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param3);
          return false;
        }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param4 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param4);
          return false;
        }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param5 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param5);
          return false;
        }
#endif
        Flock *return_value = new Flock((unsigned int)param0, (double)param1, (double)param2, (unsigned int)param3, (unsigned int)param4, (unsigned int)param5);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_Flock(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Flock) {
    printf("Flock ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Flock *local_this = (Flock *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Flock) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Flock(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Flock) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AIWorld
 */
/**
 * Python function wrapper for:
 * void AIWorld::add_ai_char(AICharacter *ai_ch)
 */
static PyObject *Dtool_AIWorld_add_ai_char_46(PyObject *self, PyObject *arg) {
  AIWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.add_ai_char")) {
    return NULL;
  }
  // 1-void AIWorld::add_ai_char(AICharacter *ai_ch)
  AICharacter *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_AICharacter(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "AIWorld.add_ai_char", "AICharacter");
  }
  (*local_this).add_ai_char(arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_ai_char(const AIWorld self, AICharacter ai_ch)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_add_ai_char_46_comment =
  "C++ Interface:\n"
  "add_ai_char(const AIWorld self, AICharacter ai_ch)\n";
#else
static const char *Dtool_AIWorld_add_ai_char_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIWorld::remove_ai_char(std::string name)
 */
static PyObject *Dtool_AIWorld_remove_ai_char_47(PyObject *self, PyObject *arg) {
  AIWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.remove_ai_char")) {
    return NULL;
  }
  // 1-void AIWorld::remove_ai_char(std::string name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).remove_ai_char(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_ai_char(const AIWorld self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_remove_ai_char_47_comment =
  "C++ Interface:\n"
  "remove_ai_char(const AIWorld self, str name)\n";
#else
static const char *Dtool_AIWorld_remove_ai_char_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIWorld::add_flock(Flock *flock)
 */
static PyObject *Dtool_AIWorld_add_flock_48(PyObject *self, PyObject *arg) {
  AIWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.add_flock")) {
    return NULL;
  }
  // 1-void AIWorld::add_flock(Flock *flock)
  Flock *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Flock(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "AIWorld.add_flock", "Flock");
  }
  (*local_this).add_flock(arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_flock(const AIWorld self, Flock flock)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_add_flock_48_comment =
  "C++ Interface:\n"
  "add_flock(const AIWorld self, Flock flock)\n"
  "\n"
  "/**\n"
  " * This function adds all the AI characters in the Flock object to the\n"
  " * AICharPool.  This function allows adding the AI characetrs as part of a\n"
  " * flock.\n"
  " */";
#else
static const char *Dtool_AIWorld_add_flock_48_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIWorld::flock_off(unsigned int flock_id)
 */
static PyObject *Dtool_AIWorld_flock_off_49(PyObject *self, PyObject *arg) {
  AIWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.flock_off")) {
    return NULL;
  }
  // 1-void AIWorld::flock_off(unsigned int flock_id)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    (*local_this).flock_off((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "flock_off(const AIWorld self, int flock_id)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_flock_off_49_comment =
  "C++ Interface:\n"
  "flock_off(const AIWorld self, int flock_id)\n"
  "\n"
  "/**\n"
  " * This function turns off the flock behavior temporarily.  Similar to pausing\n"
  " * the behavior.\n"
  " */";
#else
static const char *Dtool_AIWorld_flock_off_49_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIWorld::flock_on(unsigned int flock_id)
 */
static PyObject *Dtool_AIWorld_flock_on_50(PyObject *self, PyObject *arg) {
  AIWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.flock_on")) {
    return NULL;
  }
  // 1-void AIWorld::flock_on(unsigned int flock_id)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    (*local_this).flock_on((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "flock_on(const AIWorld self, int flock_id)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_flock_on_50_comment =
  "C++ Interface:\n"
  "flock_on(const AIWorld self, int flock_id)\n"
  "\n"
  "/**\n"
  " * This function turns on the flock behavior.\n"
  " */";
#else
static const char *Dtool_AIWorld_flock_on_50_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIWorld::remove_flock(unsigned int flock_id)
 */
static PyObject *Dtool_AIWorld_remove_flock_51(PyObject *self, PyObject *arg) {
  AIWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.remove_flock")) {
    return NULL;
  }
  // 1-void AIWorld::remove_flock(unsigned int flock_id)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    (*local_this).remove_flock((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_flock(const AIWorld self, int flock_id)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_remove_flock_51_comment =
  "C++ Interface:\n"
  "remove_flock(const AIWorld self, int flock_id)\n"
  "\n"
  "/**\n"
  " * This function removes the flock behavior completely.\n"
  " */";
#else
static const char *Dtool_AIWorld_remove_flock_51_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Flock AIWorld::get_flock(unsigned int flock_id)
 */
static PyObject *Dtool_AIWorld_get_flock_52(PyObject *self, PyObject *arg) {
  AIWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.get_flock")) {
    return NULL;
  }
  // 1-Flock AIWorld::get_flock(unsigned int flock_id)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    Flock *return_value = new Flock((*local_this).get_flock((unsigned int)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Flock, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_flock(const AIWorld self, int flock_id)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_get_flock_52_comment =
  "C++ Interface:\n"
  "get_flock(const AIWorld self, int flock_id)\n"
  "\n"
  "/**\n"
  " * This function returns a handle to the Flock whose id is passed.\n"
  " */";
#else
static const char *Dtool_AIWorld_get_flock_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIWorld::add_obstacle(NodePath obstacle)
 */
static PyObject *Dtool_AIWorld_add_obstacle_53(PyObject *self, PyObject *arg) {
  AIWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.add_obstacle")) {
    return NULL;
  }
  // 1-void AIWorld::add_obstacle(NodePath obstacle)
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "AIWorld.add_obstacle", true, true);
  if (arg_this != NULL) {
    (*local_this).add_obstacle(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_obstacle(const AIWorld self, NodePath obstacle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_add_obstacle_53_comment =
  "C++ Interface:\n"
  "add_obstacle(const AIWorld self, NodePath obstacle)\n"
  "\n"
  "/**\n"
  " * This function adds the nodepath as an obstacle that is needed by the\n"
  " * obstacle avoidance behavior.\n"
  " */";
#else
static const char *Dtool_AIWorld_add_obstacle_53_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIWorld::remove_obstacle(NodePath obstacle)
 */
static PyObject *Dtool_AIWorld_remove_obstacle_54(PyObject *self, PyObject *arg) {
  AIWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.remove_obstacle")) {
    return NULL;
  }
  // 1-void AIWorld::remove_obstacle(NodePath obstacle)
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "AIWorld.remove_obstacle", true, true);
  if (arg_this != NULL) {
    (*local_this).remove_obstacle(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_obstacle(const AIWorld self, NodePath obstacle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_remove_obstacle_54_comment =
  "C++ Interface:\n"
  "remove_obstacle(const AIWorld self, NodePath obstacle)\n"
  "\n"
  "/**\n"
  " * This function removes the nodepath from the obstacles list that is needed\n"
  " * by the obstacle avoidance behavior.\n"
  " */";
#else
static const char *Dtool_AIWorld_remove_obstacle_54_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIWorld::print_list(void)
 */
static PyObject *Dtool_AIWorld_print_list_55(PyObject *self, PyObject *) {
  AIWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.print_list")) {
    return NULL;
  }
  // 1-void AIWorld::print_list(void)
  (*local_this).print_list();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_print_list_55_comment =
  "C++ Interface:\n"
  "print_list(const AIWorld self)\n";
#else
static const char *Dtool_AIWorld_print_list_55_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AIWorld::update(void)
 */
static PyObject *Dtool_AIWorld_update_56(PyObject *self, PyObject *) {
  AIWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.update")) {
    return NULL;
  }
  // 1-void AIWorld::update(void)
  (*local_this).update();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_update_56_comment =
  "C++ Interface:\n"
  "update(const AIWorld self)\n"
  "\n"
  "/**\n"
  " * The AIWorld update function calls the update function of all the AI\n"
  " * characters which have been added to the AIWorld.\n"
  " */";
#else
static const char *Dtool_AIWorld_update_56_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline AIWorld::AIWorld(AIWorld const &) = default
 * AIWorld::AIWorld(NodePath render)
 */
static int Dtool_Init_AIWorld(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "AIWorld() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline AIWorld::AIWorld(AIWorld const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:AIWorld", (char **)keyword_list, &param0)) {
      AIWorld const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_AIWorld, (void **)&param0_this);
      if (param0_this != NULL) {
        AIWorld *return_value = new AIWorld(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AIWorld, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 AIWorld::AIWorld(NodePath render)
    PyObject *param0;
    static const char *keyword_list[] = {"render", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:AIWorld", (char **)keyword_list, &param0)) {
      NodePath *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_NodePath, (void **)&param0_this);
      if (param0_this != NULL) {
        AIWorld *return_value = new AIWorld(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AIWorld, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline AIWorld::AIWorld(AIWorld const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:AIWorld", (char **)keyword_list, &param0)) {
      AIWorld const *param0_this;
      bool param0_manage = false;
      if (Dtool_ConstCoerce_AIWorld(param0, param0_this, param0_manage)) {
        AIWorld *return_value = new AIWorld(*param0_this);
        if (param0_manage) {
          delete param0_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AIWorld, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: AIWorld::AIWorld(NodePath render)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AIWorld(const AIWorld param0)\n"
      "AIWorld(NodePath render)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_AIWorld(PyObject *args, AIWorld const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AIWorld, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-AIWorld::AIWorld(NodePath render)
    NodePath *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_NodePath, (void **)&arg_this);
    if (arg_this != NULL) {
      AIWorld *return_value = new AIWorld(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_AIWorld(PyObject *args, AIWorld *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AIWorld, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-AIWorld::AIWorld(NodePath render)
    NodePath *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_NodePath, (void **)&arg_this);
    if (arg_this != NULL) {
      AIWorld *return_value = new AIWorld(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_AIWorld(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AIWorld) {
    printf("AIWorld ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AIWorld *local_this = (AIWorld *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AIWorld) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AIWorld(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AIWorld) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for AIBehaviors (AIBehaviors)
 */
static PyMethodDef Dtool_Methods_AIBehaviors[] = {
  {"seek", (PyCFunction) &Dtool_AIBehaviors_seek_3, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_seek_3_comment},
  {"flee", (PyCFunction) &Dtool_AIBehaviors_flee_4, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_flee_4_comment},
  {"pursue", (PyCFunction) &Dtool_AIBehaviors_pursue_5, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_pursue_5_comment},
  {"evade", (PyCFunction) &Dtool_AIBehaviors_evade_6, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_evade_6_comment},
  {"arrival", (PyCFunction) &Dtool_AIBehaviors_arrival_7, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_arrival_7_comment},
  {"flock", &Dtool_AIBehaviors_flock_8, METH_O, (const char *)Dtool_AIBehaviors_flock_8_comment},
  {"wander", (PyCFunction) &Dtool_AIBehaviors_wander_9, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_wander_9_comment},
  {"obstacle_avoidance", (PyCFunction) &Dtool_AIBehaviors_obstacle_avoidance_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_obstacle_avoidance_10_comment},
  {"obstacleAvoidance", (PyCFunction) &Dtool_AIBehaviors_obstacle_avoidance_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_obstacle_avoidance_10_comment},
  {"path_follow", &Dtool_AIBehaviors_path_follow_11, METH_O, (const char *)Dtool_AIBehaviors_path_follow_11_comment},
  {"pathFollow", &Dtool_AIBehaviors_path_follow_11, METH_O, (const char *)Dtool_AIBehaviors_path_follow_11_comment},
  {"add_to_path", &Dtool_AIBehaviors_add_to_path_12, METH_O, (const char *)Dtool_AIBehaviors_add_to_path_12_comment},
  {"addToPath", &Dtool_AIBehaviors_add_to_path_12, METH_O, (const char *)Dtool_AIBehaviors_add_to_path_12_comment},
  {"start_follow", (PyCFunction) &Dtool_AIBehaviors_start_follow_13, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_start_follow_13_comment},
  {"startFollow", (PyCFunction) &Dtool_AIBehaviors_start_follow_13, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_start_follow_13_comment},
  {"init_path_find", &Dtool_AIBehaviors_init_path_find_14, METH_O, (const char *)Dtool_AIBehaviors_init_path_find_14_comment},
  {"initPathFind", &Dtool_AIBehaviors_init_path_find_14, METH_O, (const char *)Dtool_AIBehaviors_init_path_find_14_comment},
  {"path_find_to", (PyCFunction) &Dtool_AIBehaviors_path_find_to_15, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_path_find_to_15_comment},
  {"pathFindTo", (PyCFunction) &Dtool_AIBehaviors_path_find_to_15, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_path_find_to_15_comment},
  {"add_static_obstacle", &Dtool_AIBehaviors_add_static_obstacle_16, METH_O, (const char *)Dtool_AIBehaviors_add_static_obstacle_16_comment},
  {"addStaticObstacle", &Dtool_AIBehaviors_add_static_obstacle_16, METH_O, (const char *)Dtool_AIBehaviors_add_static_obstacle_16_comment},
  {"add_dynamic_obstacle", &Dtool_AIBehaviors_add_dynamic_obstacle_17, METH_O, (const char *)Dtool_AIBehaviors_add_dynamic_obstacle_17_comment},
  {"addDynamicObstacle", &Dtool_AIBehaviors_add_dynamic_obstacle_17, METH_O, (const char *)Dtool_AIBehaviors_add_dynamic_obstacle_17_comment},
  {"remove_ai", &Dtool_AIBehaviors_remove_ai_18, METH_O, (const char *)Dtool_AIBehaviors_remove_ai_18_comment},
  {"removeAi", &Dtool_AIBehaviors_remove_ai_18, METH_O, (const char *)Dtool_AIBehaviors_remove_ai_18_comment},
  {"pause_ai", &Dtool_AIBehaviors_pause_ai_19, METH_O, (const char *)Dtool_AIBehaviors_pause_ai_19_comment},
  {"pauseAi", &Dtool_AIBehaviors_pause_ai_19, METH_O, (const char *)Dtool_AIBehaviors_pause_ai_19_comment},
  {"resume_ai", &Dtool_AIBehaviors_resume_ai_20, METH_O, (const char *)Dtool_AIBehaviors_resume_ai_20_comment},
  {"resumeAi", &Dtool_AIBehaviors_resume_ai_20, METH_O, (const char *)Dtool_AIBehaviors_resume_ai_20_comment},
  {"behavior_status", &Dtool_AIBehaviors_behavior_status_21, METH_O, (const char *)Dtool_AIBehaviors_behavior_status_21_comment},
  {"behaviorStatus", &Dtool_AIBehaviors_behavior_status_21, METH_O, (const char *)Dtool_AIBehaviors_behavior_status_21_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AIBehaviors = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_AIBehaviors = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ai.AIBehaviors",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AIBehaviors,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AIBehaviors,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class implements all the steering behaviors of the AI framework, such\n"
    " * as seek, flee, pursue, evade, wander and flock.  Each steering behavior has\n"
    " * a weight which is used when more than one type of steering behavior is\n"
    " * acting on the same ai character.  The weight decides the contribution of\n"
    " * each type of steering behavior.  The AICharacter class has a handle to an\n"
    " * object of this class and this allows to invoke the steering behaviors via\n"
    " * the AICharacter.  This class also provides functionality such as pausing,\n"
    " * resuming and removing the AI behaviors of an AI character at anytime.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AIBehaviors,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AIBehaviors,
    PyType_GenericAlloc,
    Dtool_new_AIBehaviors,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AIBehaviors,
  Dtool_UpcastInterface_AIBehaviors,
  Dtool_DowncastInterface_AIBehaviors,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AIBehaviors(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_AIBehaviors._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_AIBehaviors._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AIBehaviors) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AIBehaviors)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AIBehaviors);
  }
}

/**
 * Python method tables for AICharacter (AICharacter)
 */
static PyMethodDef Dtool_Methods_AICharacter[] = {
  {"get_mass", &Dtool_AICharacter_get_mass_23, METH_NOARGS, (const char *)Dtool_AICharacter_get_mass_23_comment},
  {"getMass", &Dtool_AICharacter_get_mass_23, METH_NOARGS, (const char *)Dtool_AICharacter_get_mass_23_comment},
  {"set_mass", &Dtool_AICharacter_set_mass_24, METH_O, (const char *)Dtool_AICharacter_set_mass_24_comment},
  {"setMass", &Dtool_AICharacter_set_mass_24, METH_O, (const char *)Dtool_AICharacter_set_mass_24_comment},
  {"get_velocity", &Dtool_AICharacter_get_velocity_25, METH_NOARGS, (const char *)Dtool_AICharacter_get_velocity_25_comment},
  {"getVelocity", &Dtool_AICharacter_get_velocity_25, METH_NOARGS, (const char *)Dtool_AICharacter_get_velocity_25_comment},
  {"get_max_force", &Dtool_AICharacter_get_max_force_26, METH_NOARGS, (const char *)Dtool_AICharacter_get_max_force_26_comment},
  {"getMaxForce", &Dtool_AICharacter_get_max_force_26, METH_NOARGS, (const char *)Dtool_AICharacter_get_max_force_26_comment},
  {"set_max_force", &Dtool_AICharacter_set_max_force_27, METH_O, (const char *)Dtool_AICharacter_set_max_force_27_comment},
  {"setMaxForce", &Dtool_AICharacter_set_max_force_27, METH_O, (const char *)Dtool_AICharacter_set_max_force_27_comment},
  {"get_node_path", &Dtool_AICharacter_get_node_path_28, METH_NOARGS, (const char *)Dtool_AICharacter_get_node_path_28_comment},
  {"getNodePath", &Dtool_AICharacter_get_node_path_28, METH_NOARGS, (const char *)Dtool_AICharacter_get_node_path_28_comment},
  {"set_node_path", &Dtool_AICharacter_set_node_path_29, METH_O, (const char *)Dtool_AICharacter_set_node_path_29_comment},
  {"setNodePath", &Dtool_AICharacter_set_node_path_29, METH_O, (const char *)Dtool_AICharacter_set_node_path_29_comment},
  {"get_ai_behaviors", &Dtool_AICharacter_get_ai_behaviors_30, METH_NOARGS, (const char *)Dtool_AICharacter_get_ai_behaviors_30_comment},
  {"getAiBehaviors", &Dtool_AICharacter_get_ai_behaviors_30, METH_NOARGS, (const char *)Dtool_AICharacter_get_ai_behaviors_30_comment},
  {"set_pf_guide", &Dtool_AICharacter_set_pf_guide_31, METH_O, (const char *)Dtool_AICharacter_set_pf_guide_31_comment},
  {"setPfGuide", &Dtool_AICharacter_set_pf_guide_31, METH_O, (const char *)Dtool_AICharacter_set_pf_guide_31_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AICharacter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_AICharacter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ai.AICharacter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AICharacter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AICharacter,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AICharacter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AICharacter,
    PyType_GenericAlloc,
    Dtool_new_AICharacter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AICharacter,
  Dtool_UpcastInterface_AICharacter,
  Dtool_DowncastInterface_AICharacter,
  (CoerceFunction)Dtool_ConstCoerce_AICharacter,
  (CoerceFunction)Dtool_Coerce_AICharacter,
};

static void Dtool_PyModuleClassInit_AICharacter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_AICharacter._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_AICharacter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AICharacter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AICharacter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AICharacter);
  }
}

/**
 * Python method tables for AINode (AINode)
 */
static PyMethodDef Dtool_Methods_AINode[] = {
  {"contains", (PyCFunction) &Dtool_AINode_contains_37, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AINode_contains_37_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AINode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_AINode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ai.AINode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AINode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AINode,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is used to assign the nodes on the mesh.  It holds all the data\n"
    " * necessary to compute A* algorithm.  It also maintains a lot of vital\n"
    " * information such as the neighbor nodes of each node and also its position\n"
    " * on the mesh.  Note: The Mesh Generator which is a standalone tool makes use\n"
    " * of this class to generate the nodes on the mesh.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AINode,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AINode,
    PyType_GenericAlloc,
    Dtool_new_AINode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AINode,
  Dtool_UpcastInterface_AINode,
  Dtool_DowncastInterface_AINode,
  (CoerceFunction)Dtool_ConstCoerce_AINode,
  (CoerceFunction)Dtool_Coerce_AINode,
};

static void Dtool_PyModuleClassInit_AINode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_AINode._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_AINode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AINode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AINode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AINode);
  }
}

/**
 * Python method tables for Flock (Flock)
 */
static PyMethodDef Dtool_Methods_Flock[] = {
  {"add_ai_char", &Dtool_Flock_add_ai_char_41, METH_O, (const char *)Dtool_Flock_add_ai_char_41_comment},
  {"addAiChar", &Dtool_Flock_add_ai_char_41, METH_O, (const char *)Dtool_Flock_add_ai_char_41_comment},
  {"get_id", &Dtool_Flock_get_id_42, METH_NOARGS, (const char *)Dtool_Flock_get_id_42_comment},
  {"getId", &Dtool_Flock_get_id_42, METH_NOARGS, (const char *)Dtool_Flock_get_id_42_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Flock = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_Flock = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ai.Flock",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Flock,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Flock,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is used to define the flock attributes and the AI characters\n"
    " * which are part of the flock.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Flock,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Flock,
    PyType_GenericAlloc,
    Dtool_new_Flock,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Flock,
  Dtool_UpcastInterface_Flock,
  Dtool_DowncastInterface_Flock,
  (CoerceFunction)Dtool_ConstCoerce_Flock,
  (CoerceFunction)Dtool_Coerce_Flock,
};

static void Dtool_PyModuleClassInit_Flock(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Flock._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_Flock._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Flock) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Flock)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Flock);
  }
}

/**
 * Python method tables for AIWorld (AIWorld)
 */
static PyMethodDef Dtool_Methods_AIWorld[] = {
  {"add_ai_char", &Dtool_AIWorld_add_ai_char_46, METH_O, (const char *)Dtool_AIWorld_add_ai_char_46_comment},
  {"addAiChar", &Dtool_AIWorld_add_ai_char_46, METH_O, (const char *)Dtool_AIWorld_add_ai_char_46_comment},
  {"remove_ai_char", &Dtool_AIWorld_remove_ai_char_47, METH_O, (const char *)Dtool_AIWorld_remove_ai_char_47_comment},
  {"removeAiChar", &Dtool_AIWorld_remove_ai_char_47, METH_O, (const char *)Dtool_AIWorld_remove_ai_char_47_comment},
  {"add_flock", &Dtool_AIWorld_add_flock_48, METH_O, (const char *)Dtool_AIWorld_add_flock_48_comment},
  {"addFlock", &Dtool_AIWorld_add_flock_48, METH_O, (const char *)Dtool_AIWorld_add_flock_48_comment},
  {"flock_off", &Dtool_AIWorld_flock_off_49, METH_O, (const char *)Dtool_AIWorld_flock_off_49_comment},
  {"flockOff", &Dtool_AIWorld_flock_off_49, METH_O, (const char *)Dtool_AIWorld_flock_off_49_comment},
  {"flock_on", &Dtool_AIWorld_flock_on_50, METH_O, (const char *)Dtool_AIWorld_flock_on_50_comment},
  {"flockOn", &Dtool_AIWorld_flock_on_50, METH_O, (const char *)Dtool_AIWorld_flock_on_50_comment},
  {"remove_flock", &Dtool_AIWorld_remove_flock_51, METH_O, (const char *)Dtool_AIWorld_remove_flock_51_comment},
  {"removeFlock", &Dtool_AIWorld_remove_flock_51, METH_O, (const char *)Dtool_AIWorld_remove_flock_51_comment},
  {"get_flock", &Dtool_AIWorld_get_flock_52, METH_O, (const char *)Dtool_AIWorld_get_flock_52_comment},
  {"getFlock", &Dtool_AIWorld_get_flock_52, METH_O, (const char *)Dtool_AIWorld_get_flock_52_comment},
  {"add_obstacle", &Dtool_AIWorld_add_obstacle_53, METH_O, (const char *)Dtool_AIWorld_add_obstacle_53_comment},
  {"addObstacle", &Dtool_AIWorld_add_obstacle_53, METH_O, (const char *)Dtool_AIWorld_add_obstacle_53_comment},
  {"remove_obstacle", &Dtool_AIWorld_remove_obstacle_54, METH_O, (const char *)Dtool_AIWorld_remove_obstacle_54_comment},
  {"removeObstacle", &Dtool_AIWorld_remove_obstacle_54, METH_O, (const char *)Dtool_AIWorld_remove_obstacle_54_comment},
  {"print_list", &Dtool_AIWorld_print_list_55, METH_NOARGS, (const char *)Dtool_AIWorld_print_list_55_comment},
  {"printList", &Dtool_AIWorld_print_list_55, METH_NOARGS, (const char *)Dtool_AIWorld_print_list_55_comment},
  {"update", &Dtool_AIWorld_update_56, METH_NOARGS, (const char *)Dtool_AIWorld_update_56_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AIWorld = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_AIWorld = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ai.AIWorld",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AIWorld,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AIWorld,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class that implements the virtual AI world which keeps track of the AI\n"
    " * characters active at any given time.  It contains a linked list of AI\n"
    " * characters, obstactle data and unique name for each character.  It also\n"
    " * updates each characters state.  The AI characters can also be added to the\n"
    " * world as flocks.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AIWorld,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AIWorld,
    PyType_GenericAlloc,
    Dtool_new_AIWorld,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AIWorld,
  Dtool_UpcastInterface_AIWorld,
  Dtool_DowncastInterface_AIWorld,
  (CoerceFunction)Dtool_ConstCoerce_AIWorld,
  (CoerceFunction)Dtool_Coerce_AIWorld,
};

static void Dtool_PyModuleClassInit_AIWorld(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_AIWorld._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_AIWorld._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AIWorld) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AIWorld)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AIWorld);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libpandaai_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("AIBehaviors", Dtool_AIBehaviors);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("AICharacter", Dtool_AICharacter);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("AINode", Dtool_AINode);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("Flock", Dtool_Flock);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("AIWorld", Dtool_AIWorld);
#endif
}

void Dtool_libpandaai_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_LVecBase3f = LookupRuntimeTypedClass(LVecBase3f::get_class_type());
  Dtool_Ptr_NodePath = LookupRuntimeTypedClass(NodePath::get_class_type());
#endif
}

void Dtool_libpandaai_BuildInstants(PyObject *module) {
  (void) module;
  // AIBehaviors
  Dtool_PyModuleClassInit_AIBehaviors(module);
  PyModule_AddObject(module, "AIBehaviors", (PyObject *)&Dtool_AIBehaviors);
  // AICharacter
  Dtool_PyModuleClassInit_AICharacter(module);
  PyModule_AddObject(module, "AICharacter", (PyObject *)&Dtool_AICharacter);
  // AINode
  Dtool_PyModuleClassInit_AINode(module);
  PyModule_AddObject(module, "AINode", (PyObject *)&Dtool_AINode);
  // Flock
  Dtool_PyModuleClassInit_Flock(module);
  PyModule_AddObject(module, "Flock", (PyObject *)&Dtool_Flock);
  // AIWorld
  Dtool_PyModuleClassInit_AIWorld(module);
  PyModule_AddObject(module, "AIWorld", (PyObject *)&Dtool_AIWorld);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libpandaai_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478215200,  /* file_identifier */
  "libpandaai",  /* library_name */
  "s1eG",  /* library_hash_name */
  "panda3d.ai",  /* module_name */
  "libpandaai.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  132  /* next_index */
};

Configure(_in_configure_libpandaai);
ConfigureFn(_in_configure_libpandaai) {
  interrogate_request_module(&_in_module_def);
}

