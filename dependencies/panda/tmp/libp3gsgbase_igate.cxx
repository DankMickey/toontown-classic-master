/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/gsgbase -Ipanda/src/gsgbase -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3gsgbase_igate.cxx -od built/pandac/input/libp3gsgbase.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/gsgbase -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3gsgbase config_gsgbase.h displayRegionBase.h graphicsOutputBase.h graphicsStateGuardianBase.h p3gsgbase_composite1.cxx 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3gsgbase
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "config_gsgbase.h"
#include "displayRegionBase.h"
#include "graphicsOutputBase.h"
#include "graphicsStateGuardianBase.h"
#include "lightMutex.h"
#include "luse.h"
#include "nodeCachedReferenceCount.h"
#include "pandabase.h"
#include "typedReferenceCount.h"
#include "typedWritableReferenceCount.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class DisplayRegionBase
 */
typedef DisplayRegionBase DisplayRegionBase_localtype;
Define_Module_ClassRef(panda3d.core, DisplayRegionBase, DisplayRegionBase_localtype, DisplayRegionBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DisplayRegionBase = &Dtool_DisplayRegionBase;
static void Dtool_PyModuleClassInit_DisplayRegionBase(PyObject *module);

/**
 * Forward declarations for top-level class GraphicsOutputBase
 */
typedef GraphicsOutputBase GraphicsOutputBase_localtype;
Define_Module_ClassRef(panda3d.core, GraphicsOutputBase, GraphicsOutputBase_localtype, GraphicsOutputBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsOutputBase = &Dtool_GraphicsOutputBase;
static void Dtool_PyModuleClassInit_GraphicsOutputBase(PyObject *module);

/**
 * Forward declarations for top-level class GraphicsStateGuardianBase
 */
typedef GraphicsStateGuardianBase GraphicsStateGuardianBase_localtype;
Define_Module_ClassRef(panda3d.core, GraphicsStateGuardianBase, GraphicsStateGuardianBase_localtype, GraphicsStateGuardianBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsStateGuardianBase = &Dtool_GraphicsStateGuardianBase;
static void Dtool_PyModuleClassInit_GraphicsStateGuardianBase(PyObject *module);

/**
 * Extern declarations for imported classes
 */
// TypedWritable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritable;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class DisplayRegionBase
 */
/**
 * Python function wrapper for:
 * virtual void DisplayRegionBase::output(ostream &out) const = 0
 */
static PyObject *Dtool_DisplayRegionBase_output_3(PyObject *self, PyObject *arg) {
  DisplayRegionBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegionBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void DisplayRegionBase::output(ostream &out) const = 0
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "DisplayRegionBase.output", false, true);
  if (arg_this != NULL) {
    (*(const DisplayRegionBase*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(DisplayRegionBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegionBase_output_3_comment =
  "C++ Interface:\n"
  "output(DisplayRegionBase self, ostream out)\n";
#else
static const char *Dtool_DisplayRegionBase_output_3_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DisplayRegionBase::get_class_type(void)
 */
static PyObject *Dtool_DisplayRegionBase_get_class_type_4(PyObject *, PyObject *) {
  // 1-static TypeHandle DisplayRegionBase::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(DisplayRegionBase::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegionBase_get_class_type_4_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DisplayRegionBase_get_class_type_4_comment = NULL;
#endif

static int Dtool_Init_DisplayRegionBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DisplayRegionBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DisplayRegionBase) {
    printf("DisplayRegionBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DisplayRegionBase *local_this = (DisplayRegionBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DisplayRegionBase) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DisplayRegionBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DisplayRegionBase) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (DisplayRegionBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DisplayRegionBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (DisplayRegionBase*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class GraphicsOutputBase
 */
/**
 * Python function wrapper for:
 * virtual void GraphicsOutputBase::set_sort(int sort) = 0
 */
static PyObject *Dtool_GraphicsOutputBase_set_sort_7(PyObject *self, PyObject *arg) {
  GraphicsOutputBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutputBase, (void **)&local_this, "GraphicsOutputBase.set_sort")) {
    return NULL;
  }
  // 1-virtual void GraphicsOutputBase::set_sort(int sort) = 0
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_sort((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sort(const GraphicsOutputBase self, int sort)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutputBase_set_sort_7_comment =
  "C++ Interface:\n"
  "set_sort(const GraphicsOutputBase self, int sort)\n";
#else
static const char *Dtool_GraphicsOutputBase_set_sort_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GraphicsOutputBase::get_class_type(void)
 */
static PyObject *Dtool_GraphicsOutputBase_get_class_type_9(PyObject *, PyObject *) {
  // 1-static TypeHandle GraphicsOutputBase::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(GraphicsOutputBase::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutputBase_get_class_type_9_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GraphicsOutputBase_get_class_type_9_comment = NULL;
#endif

static int Dtool_Init_GraphicsOutputBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_GraphicsOutputBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_GraphicsOutputBase) {
    printf("GraphicsOutputBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  GraphicsOutputBase *local_this = (GraphicsOutputBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_GraphicsOutputBase) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_GraphicsOutputBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_GraphicsOutputBase) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GraphicsOutputBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GraphicsOutputBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GraphicsOutputBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GraphicsOutputBase*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class GraphicsStateGuardianBase
 */
/**
 * Python function wrapper for:
 * virtual bool GraphicsStateGuardianBase::get_incomplete_render(void) const = 0
 */
static PyObject *Dtool_GraphicsStateGuardianBase_get_incomplete_render_12(PyObject *self, PyObject *) {
  GraphicsStateGuardianBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardianBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool GraphicsStateGuardianBase::get_incomplete_render(void) const = 0
  bool return_value = (*(const GraphicsStateGuardianBase*)local_this).get_incomplete_render();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardianBase_get_incomplete_render_12_comment =
  "C++ Interface:\n"
  "get_incomplete_render(GraphicsStateGuardianBase self)\n";
#else
static const char *Dtool_GraphicsStateGuardianBase_get_incomplete_render_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool GraphicsStateGuardianBase::get_effective_incomplete_render(void) const = 0
 */
static PyObject *Dtool_GraphicsStateGuardianBase_get_effective_incomplete_render_13(PyObject *self, PyObject *) {
  GraphicsStateGuardianBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardianBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool GraphicsStateGuardianBase::get_effective_incomplete_render(void) const = 0
  bool return_value = (*(const GraphicsStateGuardianBase*)local_this).get_effective_incomplete_render();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardianBase_get_effective_incomplete_render_13_comment =
  "C++ Interface:\n"
  "get_effective_incomplete_render(GraphicsStateGuardianBase self)\n";
#else
static const char *Dtool_GraphicsStateGuardianBase_get_effective_incomplete_render_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool GraphicsStateGuardianBase::prefers_triangle_strips(void) const = 0
 */
static PyObject *Dtool_GraphicsStateGuardianBase_prefers_triangle_strips_14(PyObject *self, PyObject *) {
  GraphicsStateGuardianBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardianBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool GraphicsStateGuardianBase::prefers_triangle_strips(void) const = 0
  bool return_value = (*(const GraphicsStateGuardianBase*)local_this).prefers_triangle_strips();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardianBase_prefers_triangle_strips_14_comment =
  "C++ Interface:\n"
  "prefers_triangle_strips(GraphicsStateGuardianBase self)\n";
#else
static const char *Dtool_GraphicsStateGuardianBase_prefers_triangle_strips_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual int GraphicsStateGuardianBase::get_max_vertices_per_array(void) const = 0
 */
static PyObject *Dtool_GraphicsStateGuardianBase_get_max_vertices_per_array_15(PyObject *self, PyObject *) {
  GraphicsStateGuardianBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardianBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual int GraphicsStateGuardianBase::get_max_vertices_per_array(void) const = 0
  int return_value = (*(const GraphicsStateGuardianBase*)local_this).get_max_vertices_per_array();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardianBase_get_max_vertices_per_array_15_comment =
  "C++ Interface:\n"
  "get_max_vertices_per_array(GraphicsStateGuardianBase self)\n";
#else
static const char *Dtool_GraphicsStateGuardianBase_get_max_vertices_per_array_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual int GraphicsStateGuardianBase::get_max_vertices_per_primitive(void) const = 0
 */
static PyObject *Dtool_GraphicsStateGuardianBase_get_max_vertices_per_primitive_16(PyObject *self, PyObject *) {
  GraphicsStateGuardianBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardianBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual int GraphicsStateGuardianBase::get_max_vertices_per_primitive(void) const = 0
  int return_value = (*(const GraphicsStateGuardianBase*)local_this).get_max_vertices_per_primitive();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardianBase_get_max_vertices_per_primitive_16_comment =
  "C++ Interface:\n"
  "get_max_vertices_per_primitive(GraphicsStateGuardianBase self)\n";
#else
static const char *Dtool_GraphicsStateGuardianBase_get_max_vertices_per_primitive_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual int GraphicsStateGuardianBase::get_max_texture_dimension(void) const = 0
 */
static PyObject *Dtool_GraphicsStateGuardianBase_get_max_texture_dimension_17(PyObject *self, PyObject *) {
  GraphicsStateGuardianBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardianBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual int GraphicsStateGuardianBase::get_max_texture_dimension(void) const = 0
  int return_value = (*(const GraphicsStateGuardianBase*)local_this).get_max_texture_dimension();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardianBase_get_max_texture_dimension_17_comment =
  "C++ Interface:\n"
  "get_max_texture_dimension(GraphicsStateGuardianBase self)\n";
#else
static const char *Dtool_GraphicsStateGuardianBase_get_max_texture_dimension_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool GraphicsStateGuardianBase::get_supports_compressed_texture_format(int compression_mode) const = 0
 */
static PyObject *Dtool_GraphicsStateGuardianBase_get_supports_compressed_texture_format_18(PyObject *self, PyObject *arg) {
  GraphicsStateGuardianBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardianBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool GraphicsStateGuardianBase::get_supports_compressed_texture_format(int compression_mode) const = 0
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const GraphicsStateGuardianBase*)local_this).get_supports_compressed_texture_format((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_supports_compressed_texture_format(GraphicsStateGuardianBase self, int compression_mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardianBase_get_supports_compressed_texture_format_18_comment =
  "C++ Interface:\n"
  "get_supports_compressed_texture_format(GraphicsStateGuardianBase self, int compression_mode)\n";
#else
static const char *Dtool_GraphicsStateGuardianBase_get_supports_compressed_texture_format_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool GraphicsStateGuardianBase::get_supports_multisample(void) const = 0
 */
static PyObject *Dtool_GraphicsStateGuardianBase_get_supports_multisample_19(PyObject *self, PyObject *) {
  GraphicsStateGuardianBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardianBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool GraphicsStateGuardianBase::get_supports_multisample(void) const = 0
  bool return_value = (*(const GraphicsStateGuardianBase*)local_this).get_supports_multisample();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardianBase_get_supports_multisample_19_comment =
  "C++ Interface:\n"
  "get_supports_multisample(GraphicsStateGuardianBase self)\n";
#else
static const char *Dtool_GraphicsStateGuardianBase_get_supports_multisample_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual int GraphicsStateGuardianBase::get_supported_geom_rendering(void) const = 0
 */
static PyObject *Dtool_GraphicsStateGuardianBase_get_supported_geom_rendering_20(PyObject *self, PyObject *) {
  GraphicsStateGuardianBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardianBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual int GraphicsStateGuardianBase::get_supported_geom_rendering(void) const = 0
  int return_value = (*(const GraphicsStateGuardianBase*)local_this).get_supported_geom_rendering();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardianBase_get_supported_geom_rendering_20_comment =
  "C++ Interface:\n"
  "get_supported_geom_rendering(GraphicsStateGuardianBase self)\n";
#else
static const char *Dtool_GraphicsStateGuardianBase_get_supported_geom_rendering_20_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool GraphicsStateGuardianBase::get_supports_shadow_filter(void) const = 0
 */
static PyObject *Dtool_GraphicsStateGuardianBase_get_supports_shadow_filter_21(PyObject *self, PyObject *) {
  GraphicsStateGuardianBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardianBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool GraphicsStateGuardianBase::get_supports_shadow_filter(void) const = 0
  bool return_value = (*(const GraphicsStateGuardianBase*)local_this).get_supports_shadow_filter();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardianBase_get_supports_shadow_filter_21_comment =
  "C++ Interface:\n"
  "get_supports_shadow_filter(GraphicsStateGuardianBase self)\n";
#else
static const char *Dtool_GraphicsStateGuardianBase_get_supports_shadow_filter_21_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool GraphicsStateGuardianBase::get_supports_texture_srgb(void) const = 0
 */
static PyObject *Dtool_GraphicsStateGuardianBase_get_supports_texture_srgb_22(PyObject *self, PyObject *) {
  GraphicsStateGuardianBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardianBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool GraphicsStateGuardianBase::get_supports_texture_srgb(void) const = 0
  bool return_value = (*(const GraphicsStateGuardianBase*)local_this).get_supports_texture_srgb();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardianBase_get_supports_texture_srgb_22_comment =
  "C++ Interface:\n"
  "get_supports_texture_srgb(GraphicsStateGuardianBase self)\n";
#else
static const char *Dtool_GraphicsStateGuardianBase_get_supports_texture_srgb_22_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool GraphicsStateGuardianBase::get_supports_hlsl(void) const = 0
 */
static PyObject *Dtool_GraphicsStateGuardianBase_get_supports_hlsl_23(PyObject *self, PyObject *) {
  GraphicsStateGuardianBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardianBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool GraphicsStateGuardianBase::get_supports_hlsl(void) const = 0
  bool return_value = (*(const GraphicsStateGuardianBase*)local_this).get_supports_hlsl();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardianBase_get_supports_hlsl_23_comment =
  "C++ Interface:\n"
  "get_supports_hlsl(GraphicsStateGuardianBase self)\n";
#else
static const char *Dtool_GraphicsStateGuardianBase_get_supports_hlsl_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static GraphicsStateGuardianBase *GraphicsStateGuardianBase::get_default_gsg(void)
 */
static PyObject *Dtool_GraphicsStateGuardianBase_get_default_gsg_24(PyObject *, PyObject *) {
  // 1-static GraphicsStateGuardianBase *GraphicsStateGuardianBase::get_default_gsg(void)
  GraphicsStateGuardianBase *return_value = GraphicsStateGuardianBase::get_default_gsg();
  if (return_value != (GraphicsStateGuardianBase *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (GraphicsStateGuardianBase *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsStateGuardianBase, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardianBase_get_default_gsg_24_comment =
  "C++ Interface:\n"
  "get_default_gsg()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the \"default\" GSG.  This is typically the first GSG\n"
  " * created in an application; in a single-window application, it will be the\n"
  " * only GSG. This GSG is used to determine default optimization choices for\n"
  " * loaded geometry.\n"
  " *\n"
  " * The return value may be NULL if a GSG has not been created.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardianBase_get_default_gsg_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static void GraphicsStateGuardianBase::set_default_gsg(GraphicsStateGuardianBase *default_gsg)
 */
static PyObject *Dtool_GraphicsStateGuardianBase_set_default_gsg_25(PyObject *, PyObject *arg) {
  // 1-static void GraphicsStateGuardianBase::set_default_gsg(GraphicsStateGuardianBase *default_gsg)
  GraphicsStateGuardianBase *arg_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsStateGuardianBase, 0, "GraphicsStateGuardianBase.set_default_gsg", false, true);
  if (arg_this != NULL) {
    GraphicsStateGuardianBase::set_default_gsg(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_default_gsg(GraphicsStateGuardianBase default_gsg)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardianBase_set_default_gsg_25_comment =
  "C++ Interface:\n"
  "set_default_gsg(GraphicsStateGuardianBase default_gsg)\n"
  "\n"
  "/**\n"
  " * Specifies a particular GSG to use as the \"default\" GSG.  See\n"
  " * get_default_gsg().\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardianBase_set_default_gsg_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static std::size_t GraphicsStateGuardianBase::get_num_gsgs(void)
 */
static PyObject *Dtool_GraphicsStateGuardianBase_get_num_gsgs_26(PyObject *, PyObject *) {
  // 1-static std::size_t GraphicsStateGuardianBase::get_num_gsgs(void)
  std::size_t return_value = GraphicsStateGuardianBase::get_num_gsgs();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardianBase_get_num_gsgs_26_comment =
  "C++ Interface:\n"
  "get_num_gsgs()\n"
  "\n"
  "/**\n"
  " * Returns the total number of GSG's in the universe.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardianBase_get_num_gsgs_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static GraphicsStateGuardianBase *GraphicsStateGuardianBase::get_gsg(std::size_t n)
 */
static PyObject *Dtool_GraphicsStateGuardianBase_get_gsg_27(PyObject *, PyObject *arg) {
  // 1-static GraphicsStateGuardianBase *GraphicsStateGuardianBase::get_gsg(std::size_t n)
  Py_ssize_t param0;
  if (PyArg_Parse(arg, "n:get_gsg", &param0)) {
#ifndef NDEBUG
    if (param0 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param0);
    }
#endif
    GraphicsStateGuardianBase *return_value = GraphicsStateGuardianBase::get_gsg((std::size_t)param0);
    if (return_value != (GraphicsStateGuardianBase *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (GraphicsStateGuardianBase *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsStateGuardianBase, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_gsg(int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardianBase_get_gsg_27_comment =
  "C++ Interface:\n"
  "get_gsg(int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth GSG in the universe.  GSG's automatically add themselves\n"
  " * and remove themselves from this list as they are created and destroyed.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardianBase_get_gsg_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GraphicsStateGuardianBase::get_class_type(void)
 */
static PyObject *Dtool_GraphicsStateGuardianBase_get_class_type_29(PyObject *, PyObject *) {
  // 1-static TypeHandle GraphicsStateGuardianBase::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(GraphicsStateGuardianBase::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardianBase_get_class_type_29_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GraphicsStateGuardianBase_get_class_type_29_comment = NULL;
#endif

static int Dtool_Init_GraphicsStateGuardianBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GraphicsStateGuardianBase_get_gsgs(PyObject *self, PyObject *) {
  Py_ssize_t count = (Py_ssize_t)GraphicsStateGuardianBase::get_num_gsgs();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GraphicsStateGuardianBase_get_gsg_27(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_GraphicsStateGuardianBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_GraphicsStateGuardianBase) {
    printf("GraphicsStateGuardianBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  GraphicsStateGuardianBase *local_this = (GraphicsStateGuardianBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_GraphicsStateGuardianBase) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_GraphicsStateGuardianBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_GraphicsStateGuardianBase) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GraphicsStateGuardianBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GraphicsStateGuardianBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GraphicsStateGuardianBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GraphicsStateGuardianBase*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for DisplayRegionBase (DisplayRegionBase)
 */
static PyMethodDef Dtool_Methods_DisplayRegionBase[] = {
  {"output", &Dtool_DisplayRegionBase_output_3, METH_O, (const char *)Dtool_DisplayRegionBase_output_3_comment},
  {"get_class_type", &Dtool_DisplayRegionBase_get_class_type_4, METH_NOARGS | METH_STATIC, (const char *)Dtool_DisplayRegionBase_get_class_type_4_comment},
  {"getClassType", &Dtool_DisplayRegionBase_get_class_type_4, METH_NOARGS | METH_STATIC, (const char *)Dtool_DisplayRegionBase_get_class_type_4_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     DisplayRegionBase
//////////////////
static PyObject *Dtool_Repr_DisplayRegionBase(PyObject *self) {
  DisplayRegionBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegionBase, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_DisplayRegionBase = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DisplayRegionBase = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DisplayRegionBase = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DisplayRegionBase = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DisplayRegionBase = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.DisplayRegionBase",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DisplayRegionBase,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_DisplayRegionBase,
    &Dtool_NumberMethods_DisplayRegionBase,
    &Dtool_SequenceMethods_DisplayRegionBase,
    &Dtool_MappingMethods_DisplayRegionBase,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_DisplayRegionBase,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DisplayRegionBase,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An abstract base class for DisplayRegion, mainly so we can store\n"
    " * DisplayRegion pointers in a Camera.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DisplayRegionBase,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DisplayRegionBase,
    PyType_GenericAlloc,
    Dtool_new_DisplayRegionBase,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DisplayRegionBase,
  Dtool_UpcastInterface_DisplayRegionBase,
  Dtool_DowncastInterface_DisplayRegionBase,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DisplayRegionBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_DisplayRegionBase._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_DisplayRegionBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DisplayRegionBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DisplayRegionBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DisplayRegionBase);
  }
}

/**
 * Python method tables for GraphicsOutputBase (GraphicsOutputBase)
 */
static PyMethodDef Dtool_Methods_GraphicsOutputBase[] = {
  {"set_sort", &Dtool_GraphicsOutputBase_set_sort_7, METH_O, (const char *)Dtool_GraphicsOutputBase_set_sort_7_comment},
  {"setSort", &Dtool_GraphicsOutputBase_set_sort_7, METH_O, (const char *)Dtool_GraphicsOutputBase_set_sort_7_comment},
  {"get_class_type", &Dtool_GraphicsOutputBase_get_class_type_9, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsOutputBase_get_class_type_9_comment},
  {"getClassType", &Dtool_GraphicsOutputBase_get_class_type_9, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsOutputBase_get_class_type_9_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_GraphicsOutputBase = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GraphicsOutputBase = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_GraphicsOutputBase = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_GraphicsOutputBase = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_GraphicsOutputBase = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.GraphicsOutputBase",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_GraphicsOutputBase,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_GraphicsOutputBase,
    &Dtool_SequenceMethods_GraphicsOutputBase,
    &Dtool_MappingMethods_GraphicsOutputBase,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_GraphicsOutputBase,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An abstract base class for GraphicsOutput, for all the usual reasons.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_GraphicsOutputBase,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_GraphicsOutputBase,
    PyType_GenericAlloc,
    Dtool_new_GraphicsOutputBase,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GraphicsOutputBase,
  Dtool_UpcastInterface_GraphicsOutputBase,
  Dtool_DowncastInterface_GraphicsOutputBase,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_GraphicsOutputBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != NULL);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_GraphicsOutputBase._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_GraphicsOutputBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GraphicsOutputBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GraphicsOutputBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GraphicsOutputBase);
  }
}

/**
 * Python method tables for GraphicsStateGuardianBase (GraphicsStateGuardianBase)
 */
static PyMethodDef Dtool_Methods_GraphicsStateGuardianBase[] = {
  {"get_incomplete_render", &Dtool_GraphicsStateGuardianBase_get_incomplete_render_12, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_incomplete_render_12_comment},
  {"getIncompleteRender", &Dtool_GraphicsStateGuardianBase_get_incomplete_render_12, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_incomplete_render_12_comment},
  {"get_effective_incomplete_render", &Dtool_GraphicsStateGuardianBase_get_effective_incomplete_render_13, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_effective_incomplete_render_13_comment},
  {"getEffectiveIncompleteRender", &Dtool_GraphicsStateGuardianBase_get_effective_incomplete_render_13, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_effective_incomplete_render_13_comment},
  {"prefers_triangle_strips", &Dtool_GraphicsStateGuardianBase_prefers_triangle_strips_14, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_prefers_triangle_strips_14_comment},
  {"prefersTriangleStrips", &Dtool_GraphicsStateGuardianBase_prefers_triangle_strips_14, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_prefers_triangle_strips_14_comment},
  {"get_max_vertices_per_array", &Dtool_GraphicsStateGuardianBase_get_max_vertices_per_array_15, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_max_vertices_per_array_15_comment},
  {"getMaxVerticesPerArray", &Dtool_GraphicsStateGuardianBase_get_max_vertices_per_array_15, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_max_vertices_per_array_15_comment},
  {"get_max_vertices_per_primitive", &Dtool_GraphicsStateGuardianBase_get_max_vertices_per_primitive_16, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_max_vertices_per_primitive_16_comment},
  {"getMaxVerticesPerPrimitive", &Dtool_GraphicsStateGuardianBase_get_max_vertices_per_primitive_16, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_max_vertices_per_primitive_16_comment},
  {"get_max_texture_dimension", &Dtool_GraphicsStateGuardianBase_get_max_texture_dimension_17, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_max_texture_dimension_17_comment},
  {"getMaxTextureDimension", &Dtool_GraphicsStateGuardianBase_get_max_texture_dimension_17, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_max_texture_dimension_17_comment},
  {"get_supports_compressed_texture_format", &Dtool_GraphicsStateGuardianBase_get_supports_compressed_texture_format_18, METH_O, (const char *)Dtool_GraphicsStateGuardianBase_get_supports_compressed_texture_format_18_comment},
  {"getSupportsCompressedTextureFormat", &Dtool_GraphicsStateGuardianBase_get_supports_compressed_texture_format_18, METH_O, (const char *)Dtool_GraphicsStateGuardianBase_get_supports_compressed_texture_format_18_comment},
  {"get_supports_multisample", &Dtool_GraphicsStateGuardianBase_get_supports_multisample_19, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_supports_multisample_19_comment},
  {"getSupportsMultisample", &Dtool_GraphicsStateGuardianBase_get_supports_multisample_19, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_supports_multisample_19_comment},
  {"get_supported_geom_rendering", &Dtool_GraphicsStateGuardianBase_get_supported_geom_rendering_20, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_supported_geom_rendering_20_comment},
  {"getSupportedGeomRendering", &Dtool_GraphicsStateGuardianBase_get_supported_geom_rendering_20, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_supported_geom_rendering_20_comment},
  {"get_supports_shadow_filter", &Dtool_GraphicsStateGuardianBase_get_supports_shadow_filter_21, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_supports_shadow_filter_21_comment},
  {"getSupportsShadowFilter", &Dtool_GraphicsStateGuardianBase_get_supports_shadow_filter_21, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_supports_shadow_filter_21_comment},
  {"get_supports_texture_srgb", &Dtool_GraphicsStateGuardianBase_get_supports_texture_srgb_22, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_supports_texture_srgb_22_comment},
  {"getSupportsTextureSrgb", &Dtool_GraphicsStateGuardianBase_get_supports_texture_srgb_22, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_supports_texture_srgb_22_comment},
  {"get_supports_hlsl", &Dtool_GraphicsStateGuardianBase_get_supports_hlsl_23, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_supports_hlsl_23_comment},
  {"getSupportsHlsl", &Dtool_GraphicsStateGuardianBase_get_supports_hlsl_23, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardianBase_get_supports_hlsl_23_comment},
  {"get_default_gsg", &Dtool_GraphicsStateGuardianBase_get_default_gsg_24, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsStateGuardianBase_get_default_gsg_24_comment},
  {"getDefaultGsg", &Dtool_GraphicsStateGuardianBase_get_default_gsg_24, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsStateGuardianBase_get_default_gsg_24_comment},
  {"set_default_gsg", &Dtool_GraphicsStateGuardianBase_set_default_gsg_25, METH_O | METH_STATIC, (const char *)Dtool_GraphicsStateGuardianBase_set_default_gsg_25_comment},
  {"setDefaultGsg", &Dtool_GraphicsStateGuardianBase_set_default_gsg_25, METH_O | METH_STATIC, (const char *)Dtool_GraphicsStateGuardianBase_set_default_gsg_25_comment},
  {"get_num_gsgs", &Dtool_GraphicsStateGuardianBase_get_num_gsgs_26, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsStateGuardianBase_get_num_gsgs_26_comment},
  {"getNumGsgs", &Dtool_GraphicsStateGuardianBase_get_num_gsgs_26, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsStateGuardianBase_get_num_gsgs_26_comment},
  {"get_gsg", &Dtool_GraphicsStateGuardianBase_get_gsg_27, METH_O | METH_STATIC, (const char *)Dtool_GraphicsStateGuardianBase_get_gsg_27_comment},
  {"getGsg", &Dtool_GraphicsStateGuardianBase_get_gsg_27, METH_O | METH_STATIC, (const char *)Dtool_GraphicsStateGuardianBase_get_gsg_27_comment},
  {"get_class_type", &Dtool_GraphicsStateGuardianBase_get_class_type_29, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsStateGuardianBase_get_class_type_29_comment},
  {"getClassType", &Dtool_GraphicsStateGuardianBase_get_class_type_29, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsStateGuardianBase_get_class_type_29_comment},
  {"get_gsgs", (PyCFunction) &MakeSeq_GraphicsStateGuardianBase_get_gsgs, METH_NOARGS | METH_STATIC, NULL},
  { "getGsgs", (PyCFunction) &MakeSeq_GraphicsStateGuardianBase_get_gsgs, METH_NOARGS | METH_STATIC, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_GraphicsStateGuardianBase = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GraphicsStateGuardianBase = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_GraphicsStateGuardianBase = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_GraphicsStateGuardianBase = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_GraphicsStateGuardianBase = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.GraphicsStateGuardianBase",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_GraphicsStateGuardianBase,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_GraphicsStateGuardianBase,
    &Dtool_SequenceMethods_GraphicsStateGuardianBase,
    &Dtool_MappingMethods_GraphicsStateGuardianBase,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_GraphicsStateGuardianBase,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a base class for the GraphicsStateGuardian class, which is itself a\n"
    " * base class for the various GSG's for different platforms.  This class\n"
    " * contains all the function prototypes to support the double-dispatch of GSG\n"
    " * to geoms, transitions, etc.  It lives in a separate class in its own\n"
    " * package so we can avoid circular build dependency problems.\n"
    " *\n"
    " * GraphicsStateGuardians are not actually writable to bam files, of course,\n"
    " * but they may be passed as event parameters, so they inherit from\n"
    " * TypedWritableReferenceCount instead of TypedReferenceCount for that\n"
    " * convenience.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_GraphicsStateGuardianBase,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_GraphicsStateGuardianBase,
    PyType_GenericAlloc,
    Dtool_new_GraphicsStateGuardianBase,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GraphicsStateGuardianBase,
  Dtool_UpcastInterface_GraphicsStateGuardianBase,
  Dtool_DowncastInterface_GraphicsStateGuardianBase,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_GraphicsStateGuardianBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != NULL);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_GraphicsStateGuardianBase._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_GraphicsStateGuardianBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GraphicsStateGuardianBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GraphicsStateGuardianBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GraphicsStateGuardianBase);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3gsgbase_RegisterTypes() {
  Dtool_DisplayRegionBase._type = DisplayRegionBase::get_class_type();
  RegisterRuntimeTypedClass(Dtool_DisplayRegionBase);
  Dtool_GraphicsOutputBase._type = GraphicsOutputBase::get_class_type();
  RegisterRuntimeTypedClass(Dtool_GraphicsOutputBase);
  Dtool_GraphicsStateGuardianBase._type = GraphicsStateGuardianBase::get_class_type();
  RegisterRuntimeTypedClass(Dtool_GraphicsStateGuardianBase);
}

void Dtool_libp3gsgbase_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_TypedWritable = LookupRuntimeTypedClass(TypedWritable::get_class_type());
  Dtool_Ptr_TypedWritableReferenceCount = LookupRuntimeTypedClass(TypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
#endif
}

void Dtool_libp3gsgbase_BuildInstants(PyObject *module) {
  (void) module;
  // DisplayRegionBase
  Dtool_PyModuleClassInit_DisplayRegionBase(module);
  PyModule_AddObject(module, "DisplayRegionBase", (PyObject *)&Dtool_DisplayRegionBase);
  // GraphicsOutputBase
  Dtool_PyModuleClassInit_GraphicsOutputBase(module);
  PyModule_AddObject(module, "GraphicsOutputBase", (PyObject *)&Dtool_GraphicsOutputBase);
  // GraphicsStateGuardianBase
  Dtool_PyModuleClassInit_GraphicsStateGuardianBase(module);
  PyModule_AddObject(module, "GraphicsStateGuardianBase", (PyObject *)&Dtool_GraphicsStateGuardianBase);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3gsgbase_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478210338,  /* file_identifier */
  "libp3gsgbase",  /* library_name */
  "Oe1b",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3gsgbase.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  72  /* next_index */
};

Configure(_in_configure_libp3gsgbase);
ConfigureFn(_in_configure_libp3gsgbase) {
  interrogate_request_module(&_in_module_def);
}

