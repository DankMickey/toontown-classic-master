/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/particlesystem -Ipanda/src/particlesystem -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3particlesystem_igate.cxx -od built/pandac/input/libp3particlesystem.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/particlesystem -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.physics -library libp3particlesystem arcEmitter.h baseParticle.h baseParticleEmitter.h baseParticleFactory.h baseParticleRenderer.h boxEmitter.h colorInterpolationManager.h config_particlesystem.h discEmitter.h geomParticleRenderer.h lineEmitter.h lineParticleRenderer.h p3particlesystem_composite1.cxx p3particlesystem_composite2.cxx particleCommonFuncs.h particleSystem.h particleSystemManager.h pointEmitter.h pointParticle.h pointParticleFactory.h pointParticleRenderer.h rectangleEmitter.h ringEmitter.h sparkleParticleRenderer.h sphereSurfaceEmitter.h sphereVolumeEmitter.h spriteParticleRenderer.h tangentRingEmitter.h zSpinParticle.h zSpinParticleFactory.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3particlesystem
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "arcEmitter.h"
#include "baseParticle.h"
#include "baseParticleEmitter.h"
#include "baseParticleFactory.h"
#include "baseParticleRenderer.h"
#include "boxEmitter.h"
#include "colorBlendAttrib.h"
#include "colorInterpolationManager.h"
#include "config_particlesystem.h"
#include "dconfig.h"
#include "discEmitter.h"
#include "geom.h"
#include "geomLines.h"
#include "geomNode.h"
#include "geomParticleRenderer.h"
#include "geomVertexData.h"
#include "lineEmitter.h"
#include "lineParticleRenderer.h"
#include "luse.h"
#include "nodePath.h"
#include "notifyCategoryProxy.h"
#include "pStatCollector.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "particleCommonFuncs.h"
#include "particleSystem.h"
#include "particleSystemManager.h"
#include "physicsObject.h"
#include "pointEmitter.h"
#include "pointParticle.h"
#include "pointParticleFactory.h"
#include "pointParticleRenderer.h"
#include "pointerTo.h"
#include "pointerToArray.h"
#include "pvector.h"
#include "rectangleEmitter.h"
#include "referenceCount.h"
#include "renderState.h"
#include "ringEmitter.h"
#include "sparkleParticleRenderer.h"
#include "sphereSurfaceEmitter.h"
#include "sphereVolumeEmitter.h"
#include "spriteParticleRenderer.h"
#include <stdlib.h>
#include "tangentRingEmitter.h"
#include "typedObject.h"
#include "typedReferenceCount.h"
#include "zSpinParticle.h"
#include "zSpinParticleFactory.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class BaseParticleEmitter
 */
typedef BaseParticleEmitter BaseParticleEmitter_localtype;
Define_Module_ClassRef(panda3d.physics, BaseParticleEmitter, BaseParticleEmitter_localtype, BaseParticleEmitter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BaseParticleEmitter = &Dtool_BaseParticleEmitter;
static void Dtool_PyModuleClassInit_BaseParticleEmitter(PyObject *module);

/**
 * Forward declarations for top-level class RingEmitter
 */
typedef RingEmitter RingEmitter_localtype;
Define_Module_ClassRef(panda3d.physics, RingEmitter, RingEmitter_localtype, RingEmitter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RingEmitter = &Dtool_RingEmitter;
static void Dtool_PyModuleClassInit_RingEmitter(PyObject *module);

/**
 * Forward declarations for top-level class ArcEmitter
 */
typedef ArcEmitter ArcEmitter_localtype;
Define_Module_ClassRef(panda3d.physics, ArcEmitter, ArcEmitter_localtype, ArcEmitter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ArcEmitter = &Dtool_ArcEmitter;
static void Dtool_PyModuleClassInit_ArcEmitter(PyObject *module);

/**
 * Forward declarations for top-level class BaseParticleFactory
 */
typedef BaseParticleFactory BaseParticleFactory_localtype;
Define_Module_ClassRef(panda3d.physics, BaseParticleFactory, BaseParticleFactory_localtype, BaseParticleFactory);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BaseParticleFactory = &Dtool_BaseParticleFactory;
static void Dtool_PyModuleClassInit_BaseParticleFactory(PyObject *module);

/**
 * Forward declarations for top-level class BaseParticleRenderer
 */
typedef BaseParticleRenderer BaseParticleRenderer_localtype;
Define_Module_ClassRef(panda3d.physics, BaseParticleRenderer, BaseParticleRenderer_localtype, BaseParticleRenderer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BaseParticleRenderer = &Dtool_BaseParticleRenderer;
static void Dtool_PyModuleClassInit_BaseParticleRenderer(PyObject *module);

/**
 * Forward declarations for top-level class BoxEmitter
 */
typedef BoxEmitter BoxEmitter_localtype;
Define_Module_ClassRef(panda3d.physics, BoxEmitter, BoxEmitter_localtype, BoxEmitter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoxEmitter = &Dtool_BoxEmitter;
static void Dtool_PyModuleClassInit_BoxEmitter(PyObject *module);

/**
 * Forward declarations for top-level class ColorInterpolationFunctionConstant
 */
typedef ColorInterpolationFunctionConstant ColorInterpolationFunctionConstant_localtype;
Define_Module_ClassRef(panda3d.physics, ColorInterpolationFunctionConstant, ColorInterpolationFunctionConstant_localtype, ColorInterpolationFunctionConstant);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ColorInterpolationFunctionConstant = &Dtool_ColorInterpolationFunctionConstant;
static void Dtool_PyModuleClassInit_ColorInterpolationFunctionConstant(PyObject *module);

/**
 * Forward declarations for top-level class ColorInterpolationFunctionLinear
 */
typedef ColorInterpolationFunctionLinear ColorInterpolationFunctionLinear_localtype;
Define_Module_ClassRef(panda3d.physics, ColorInterpolationFunctionLinear, ColorInterpolationFunctionLinear_localtype, ColorInterpolationFunctionLinear);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ColorInterpolationFunctionLinear = &Dtool_ColorInterpolationFunctionLinear;
static void Dtool_PyModuleClassInit_ColorInterpolationFunctionLinear(PyObject *module);

/**
 * Forward declarations for top-level class ColorInterpolationFunctionStepwave
 */
typedef ColorInterpolationFunctionStepwave ColorInterpolationFunctionStepwave_localtype;
Define_Module_ClassRef(panda3d.physics, ColorInterpolationFunctionStepwave, ColorInterpolationFunctionStepwave_localtype, ColorInterpolationFunctionStepwave);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ColorInterpolationFunctionStepwave = &Dtool_ColorInterpolationFunctionStepwave;
static void Dtool_PyModuleClassInit_ColorInterpolationFunctionStepwave(PyObject *module);

/**
 * Forward declarations for top-level class ColorInterpolationFunctionSinusoid
 */
typedef ColorInterpolationFunctionSinusoid ColorInterpolationFunctionSinusoid_localtype;
Define_Module_ClassRef(panda3d.physics, ColorInterpolationFunctionSinusoid, ColorInterpolationFunctionSinusoid_localtype, ColorInterpolationFunctionSinusoid);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ColorInterpolationFunctionSinusoid = &Dtool_ColorInterpolationFunctionSinusoid;
static void Dtool_PyModuleClassInit_ColorInterpolationFunctionSinusoid(PyObject *module);

/**
 * Forward declarations for top-level class ColorInterpolationSegment
 */
typedef ColorInterpolationSegment ColorInterpolationSegment_localtype;
Define_Module_ClassRef(panda3d.physics, ColorInterpolationSegment, ColorInterpolationSegment_localtype, ColorInterpolationSegment);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ColorInterpolationSegment = &Dtool_ColorInterpolationSegment;
static void Dtool_PyModuleClassInit_ColorInterpolationSegment(PyObject *module);
bool Dtool_ConstCoerce_ColorInterpolationSegment(PyObject *args, CPT(ColorInterpolationSegment) &coerced);
bool Dtool_Coerce_ColorInterpolationSegment(PyObject *args, PT(ColorInterpolationSegment) &coerced);

/**
 * Forward declarations for top-level class ColorInterpolationManager
 */
typedef ColorInterpolationManager ColorInterpolationManager_localtype;
Define_Module_ClassRef(panda3d.physics, ColorInterpolationManager, ColorInterpolationManager_localtype, ColorInterpolationManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ColorInterpolationManager = &Dtool_ColorInterpolationManager;
static void Dtool_PyModuleClassInit_ColorInterpolationManager(PyObject *module);
bool Dtool_ConstCoerce_ColorInterpolationManager(PyObject *args, CPT(ColorInterpolationManager) &coerced);
bool Dtool_Coerce_ColorInterpolationManager(PyObject *args, PT(ColorInterpolationManager) &coerced);

/**
 * Forward declarations for top-level class DiscEmitter
 */
typedef DiscEmitter DiscEmitter_localtype;
Define_Module_ClassRef(panda3d.physics, DiscEmitter, DiscEmitter_localtype, DiscEmitter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DiscEmitter = &Dtool_DiscEmitter;
static void Dtool_PyModuleClassInit_DiscEmitter(PyObject *module);

/**
 * Forward declarations for top-level class GeomParticleRenderer
 */
typedef GeomParticleRenderer GeomParticleRenderer_localtype;
Define_Module_ClassRef(panda3d.physics, GeomParticleRenderer, GeomParticleRenderer_localtype, GeomParticleRenderer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomParticleRenderer = &Dtool_GeomParticleRenderer;
static void Dtool_PyModuleClassInit_GeomParticleRenderer(PyObject *module);
bool Dtool_ConstCoerce_GeomParticleRenderer(PyObject *args, CPT(GeomParticleRenderer) &coerced);
bool Dtool_Coerce_GeomParticleRenderer(PyObject *args, PT(GeomParticleRenderer) &coerced);

/**
 * Forward declarations for top-level class LineEmitter
 */
typedef LineEmitter LineEmitter_localtype;
Define_Module_ClassRef(panda3d.physics, LineEmitter, LineEmitter_localtype, LineEmitter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LineEmitter = &Dtool_LineEmitter;
static void Dtool_PyModuleClassInit_LineEmitter(PyObject *module);

/**
 * Forward declarations for top-level class LineParticleRenderer
 */
typedef LineParticleRenderer LineParticleRenderer_localtype;
Define_Module_ClassRef(panda3d.physics, LineParticleRenderer, LineParticleRenderer_localtype, LineParticleRenderer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LineParticleRenderer = &Dtool_LineParticleRenderer;
static void Dtool_PyModuleClassInit_LineParticleRenderer(PyObject *module);
bool Dtool_ConstCoerce_LineParticleRenderer(PyObject *args, CPT(LineParticleRenderer) &coerced);
bool Dtool_Coerce_LineParticleRenderer(PyObject *args, PT(LineParticleRenderer) &coerced);

/**
 * Forward declarations for top-level class ParticleSystem
 */
typedef ParticleSystem ParticleSystem_localtype;
Define_Module_ClassRef(panda3d.physics, ParticleSystem, ParticleSystem_localtype, ParticleSystem);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParticleSystem = &Dtool_ParticleSystem;
static void Dtool_PyModuleClassInit_ParticleSystem(PyObject *module);
bool Dtool_ConstCoerce_ParticleSystem(PyObject *args, CPT(ParticleSystem) &coerced);
bool Dtool_Coerce_ParticleSystem(PyObject *args, PT(ParticleSystem) &coerced);

/**
 * Forward declarations for top-level class PointEmitter
 */
typedef PointEmitter PointEmitter_localtype;
Define_Module_ClassRef(panda3d.physics, PointEmitter, PointEmitter_localtype, PointEmitter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointEmitter = &Dtool_PointEmitter;
static void Dtool_PyModuleClassInit_PointEmitter(PyObject *module);

/**
 * Forward declarations for top-level class PointParticleFactory
 */
typedef PointParticleFactory PointParticleFactory_localtype;
Define_Module_ClassRef(panda3d.physics, PointParticleFactory, PointParticleFactory_localtype, PointParticleFactory);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointParticleFactory = &Dtool_PointParticleFactory;
static void Dtool_PyModuleClassInit_PointParticleFactory(PyObject *module);

/**
 * Forward declarations for top-level class PointParticleRenderer
 */
typedef PointParticleRenderer PointParticleRenderer_localtype;
Define_Module_ClassRef(panda3d.physics, PointParticleRenderer, PointParticleRenderer_localtype, PointParticleRenderer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointParticleRenderer = &Dtool_PointParticleRenderer;
static void Dtool_PyModuleClassInit_PointParticleRenderer(PyObject *module);
bool Dtool_ConstCoerce_PointParticleRenderer(PyObject *args, CPT(PointParticleRenderer) &coerced);
bool Dtool_Coerce_PointParticleRenderer(PyObject *args, PT(PointParticleRenderer) &coerced);

/**
 * Forward declarations for top-level class RectangleEmitter
 */
typedef RectangleEmitter RectangleEmitter_localtype;
Define_Module_ClassRef(panda3d.physics, RectangleEmitter, RectangleEmitter_localtype, RectangleEmitter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RectangleEmitter = &Dtool_RectangleEmitter;
static void Dtool_PyModuleClassInit_RectangleEmitter(PyObject *module);

/**
 * Forward declarations for top-level class SparkleParticleRenderer
 */
typedef SparkleParticleRenderer SparkleParticleRenderer_localtype;
Define_Module_ClassRef(panda3d.physics, SparkleParticleRenderer, SparkleParticleRenderer_localtype, SparkleParticleRenderer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SparkleParticleRenderer = &Dtool_SparkleParticleRenderer;
static void Dtool_PyModuleClassInit_SparkleParticleRenderer(PyObject *module);
bool Dtool_ConstCoerce_SparkleParticleRenderer(PyObject *args, CPT(SparkleParticleRenderer) &coerced);
bool Dtool_Coerce_SparkleParticleRenderer(PyObject *args, PT(SparkleParticleRenderer) &coerced);

/**
 * Forward declarations for top-level class SphereSurfaceEmitter
 */
typedef SphereSurfaceEmitter SphereSurfaceEmitter_localtype;
Define_Module_ClassRef(panda3d.physics, SphereSurfaceEmitter, SphereSurfaceEmitter_localtype, SphereSurfaceEmitter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SphereSurfaceEmitter = &Dtool_SphereSurfaceEmitter;
static void Dtool_PyModuleClassInit_SphereSurfaceEmitter(PyObject *module);

/**
 * Forward declarations for top-level class SphereVolumeEmitter
 */
typedef SphereVolumeEmitter SphereVolumeEmitter_localtype;
Define_Module_ClassRef(panda3d.physics, SphereVolumeEmitter, SphereVolumeEmitter_localtype, SphereVolumeEmitter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SphereVolumeEmitter = &Dtool_SphereVolumeEmitter;
static void Dtool_PyModuleClassInit_SphereVolumeEmitter(PyObject *module);

/**
 * Forward declarations for top-level class SpriteAnim
 */
typedef SpriteAnim SpriteAnim_localtype;
Define_Module_ClassRef(panda3d.physics, SpriteAnim, SpriteAnim_localtype, SpriteAnim);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SpriteAnim = &Dtool_SpriteAnim;
static void Dtool_PyModuleClassInit_SpriteAnim(PyObject *module);

/**
 * Forward declarations for top-level class SpriteParticleRenderer
 */
typedef SpriteParticleRenderer SpriteParticleRenderer_localtype;
Define_Module_ClassRef(panda3d.physics, SpriteParticleRenderer, SpriteParticleRenderer_localtype, SpriteParticleRenderer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SpriteParticleRenderer = &Dtool_SpriteParticleRenderer;
static void Dtool_PyModuleClassInit_SpriteParticleRenderer(PyObject *module);
bool Dtool_ConstCoerce_SpriteParticleRenderer(PyObject *args, CPT(SpriteParticleRenderer) &coerced);
bool Dtool_Coerce_SpriteParticleRenderer(PyObject *args, PT(SpriteParticleRenderer) &coerced);

/**
 * Forward declarations for top-level class TangentRingEmitter
 */
typedef TangentRingEmitter TangentRingEmitter_localtype;
Define_Module_ClassRef(panda3d.physics, TangentRingEmitter, TangentRingEmitter_localtype, TangentRingEmitter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TangentRingEmitter = &Dtool_TangentRingEmitter;
static void Dtool_PyModuleClassInit_TangentRingEmitter(PyObject *module);

/**
 * Forward declarations for top-level class ZSpinParticleFactory
 */
typedef ZSpinParticleFactory ZSpinParticleFactory_localtype;
Define_Module_ClassRef(panda3d.physics, ZSpinParticleFactory, ZSpinParticleFactory_localtype, ZSpinParticleFactory);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ZSpinParticleFactory = &Dtool_ZSpinParticleFactory;
static void Dtool_PyModuleClassInit_ZSpinParticleFactory(PyObject *module);

/**
 * Forward declarations for top-level class ParticleSystemManager
 */
typedef ParticleSystemManager ParticleSystemManager_localtype;
Define_Module_Class(panda3d.physics, ParticleSystemManager, ParticleSystemManager_localtype, ParticleSystemManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParticleSystemManager = &Dtool_ParticleSystemManager;
static void Dtool_PyModuleClassInit_ParticleSystemManager(PyObject *module);
bool Dtool_ConstCoerce_ParticleSystemManager(PyObject *args, ParticleSystemManager const *&coerced, bool &manage);
bool Dtool_Coerce_ParticleSystemManager(PyObject *args, ParticleSystemManager *&coerced, bool &manage);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// LPoint2f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint2f;
inline static LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced) {
  nassertr(Dtool_Ptr_LPoint2f != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint2f->_Dtool_Coerce != NULL, NULL);
  return ((LPoint2f *(*)(PyObject *, LPoint2f &))Dtool_Ptr_LPoint2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2f = &Dtool_LPoint2f;
extern LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint3f;
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != NULL, NULL);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4f;
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVector3f;
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != NULL, NULL);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PandaNode;
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// GeomNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GeomNode;
#else
extern struct Dtool_PyTypedObject Dtool_GeomNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomNode = &Dtool_GeomNode;
#endif
// Texture
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Texture;
#else
extern struct Dtool_PyTypedObject Dtool_Texture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Texture = &Dtool_Texture;
#endif
// NodePath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePath;
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// Physical
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Physical;
inline static bool Dtool_ConstCoerce_Physical(PyObject *args, CPT(Physical) &coerced) {
  nassertr(Dtool_Ptr_Physical != NULL, false);
  nassertr(Dtool_Ptr_Physical->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(Physical) &))Dtool_Ptr_Physical->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_Physical(PyObject *args, PT(Physical) &coerced) {
  nassertr(Dtool_Ptr_Physical != NULL, false);
  nassertr(Dtool_Ptr_Physical->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(Physical) &))Dtool_Ptr_Physical->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Physical;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Physical = &Dtool_Physical;
extern bool Dtool_ConstCoerce_Physical(PyObject *args, CPT(Physical) &coerced);
extern bool Dtool_Coerce_Physical(PyObject *args, PT(Physical) &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class BaseParticleEmitter
 */
/**
 * Python function wrapper for:
 * virtual BaseParticleEmitter *BaseParticleEmitter::make_copy(void) = 0
 */
static PyObject *Dtool_BaseParticleEmitter_make_copy_4(PyObject *self, PyObject *) {
  BaseParticleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseParticleEmitter, (void **)&local_this, "BaseParticleEmitter.make_copy")) {
    return NULL;
  }
  // 1-virtual BaseParticleEmitter *BaseParticleEmitter::make_copy(void) = 0
  BaseParticleEmitter *return_value = (*local_this).make_copy();
  if (return_value != (BaseParticleEmitter *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (BaseParticleEmitter *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BaseParticleEmitter, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleEmitter_make_copy_4_comment =
  "C++ Interface:\n"
  "make_copy(const BaseParticleEmitter self)\n";
#else
static const char *Dtool_BaseParticleEmitter_make_copy_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BaseParticleEmitter::generate(LPoint3 &pos, LVector3 &vel)
 */
static PyObject *Dtool_BaseParticleEmitter_generate_5(PyObject *self, PyObject *args, PyObject *kwds) {
  BaseParticleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseParticleEmitter, (void **)&local_this, "BaseParticleEmitter.generate")) {
    return NULL;
  }
  // 1-void BaseParticleEmitter::generate(LPoint3 &pos, LVector3 &vel)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"pos", "vel", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:generate", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3 *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "BaseParticleEmitter.generate", "LPoint3f");
    }
    LVector3f param2_local;
    LVector3 *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "BaseParticleEmitter.generate", "LVector3f");
    }
    (*local_this).generate(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "generate(const BaseParticleEmitter self, LPoint3f pos, LVector3f vel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleEmitter_generate_5_comment =
  "C++ Interface:\n"
  "generate(const BaseParticleEmitter self, LPoint3f pos, LVector3f vel)\n"
  "\n"
  "/**\n"
  " * parent generation function\n"
  " */";
#else
static const char *Dtool_BaseParticleEmitter_generate_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BaseParticleEmitter::set_emission_type(BaseParticleEmitter::emissionType et)
 */
static PyObject *Dtool_BaseParticleEmitter_set_emission_type_6(PyObject *self, PyObject *arg) {
  BaseParticleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseParticleEmitter, (void **)&local_this, "BaseParticleEmitter.set_emission_type")) {
    return NULL;
  }
  // 1-inline void BaseParticleEmitter::set_emission_type(BaseParticleEmitter::emissionType et)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_emission_type((BaseParticleEmitter::emissionType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_emission_type(const BaseParticleEmitter self, int et)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleEmitter_set_emission_type_6_comment =
  "C++ Interface:\n"
  "set_emission_type(const BaseParticleEmitter self, int et)\n"
  "\n"
  "/**\n"
  " * emission type assignment\n"
  " */";
#else
static const char *Dtool_BaseParticleEmitter_set_emission_type_6_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BaseParticleEmitter::set_amplitude(PN_stdfloat a)
 */
static PyObject *Dtool_BaseParticleEmitter_set_amplitude_7(PyObject *self, PyObject *arg) {
  BaseParticleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseParticleEmitter, (void **)&local_this, "BaseParticleEmitter.set_amplitude")) {
    return NULL;
  }
  // 1-inline void BaseParticleEmitter::set_amplitude(PN_stdfloat a)
  if (PyNumber_Check(arg)) {
    (*local_this).set_amplitude((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_amplitude(const BaseParticleEmitter self, float a)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleEmitter_set_amplitude_7_comment =
  "C++ Interface:\n"
  "set_amplitude(const BaseParticleEmitter self, float a)\n"
  "\n"
  "/**\n"
  " * amplitude assignment\n"
  " */";
#else
static const char *Dtool_BaseParticleEmitter_set_amplitude_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BaseParticleEmitter::set_amplitude_spread(PN_stdfloat as)
 */
static PyObject *Dtool_BaseParticleEmitter_set_amplitude_spread_8(PyObject *self, PyObject *arg) {
  BaseParticleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseParticleEmitter, (void **)&local_this, "BaseParticleEmitter.set_amplitude_spread")) {
    return NULL;
  }
  // 1-inline void BaseParticleEmitter::set_amplitude_spread(PN_stdfloat as)
  if (PyNumber_Check(arg)) {
    (*local_this).set_amplitude_spread((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_amplitude_spread(const BaseParticleEmitter self, float as)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleEmitter_set_amplitude_spread_8_comment =
  "C++ Interface:\n"
  "set_amplitude_spread(const BaseParticleEmitter self, float as)\n"
  "\n"
  "/**\n"
  " * amplitude spread assignment\n"
  " */";
#else
static const char *Dtool_BaseParticleEmitter_set_amplitude_spread_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BaseParticleEmitter::set_offset_force(LVector3 const &of)
 */
static PyObject *Dtool_BaseParticleEmitter_set_offset_force_9(PyObject *self, PyObject *arg) {
  BaseParticleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseParticleEmitter, (void **)&local_this, "BaseParticleEmitter.set_offset_force")) {
    return NULL;
  }
  // 1-inline void BaseParticleEmitter::set_offset_force(LVector3 const &of)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BaseParticleEmitter.set_offset_force", "LVector3f");
  }
  (*local_this).set_offset_force(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_offset_force(const BaseParticleEmitter self, const LVector3f of)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleEmitter_set_offset_force_9_comment =
  "C++ Interface:\n"
  "set_offset_force(const BaseParticleEmitter self, const LVector3f of)\n"
  "\n"
  "// this is a constant force applied to all particles\n"
  "\n"
  "/**\n"
  " * user-defined force\n"
  " */";
#else
static const char *Dtool_BaseParticleEmitter_set_offset_force_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BaseParticleEmitter::set_explicit_launch_vector(LVector3 const &elv)
 */
static PyObject *Dtool_BaseParticleEmitter_set_explicit_launch_vector_10(PyObject *self, PyObject *arg) {
  BaseParticleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseParticleEmitter, (void **)&local_this, "BaseParticleEmitter.set_explicit_launch_vector")) {
    return NULL;
  }
  // 1-inline void BaseParticleEmitter::set_explicit_launch_vector(LVector3 const &elv)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BaseParticleEmitter.set_explicit_launch_vector", "LVector3f");
  }
  (*local_this).set_explicit_launch_vector(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_explicit_launch_vector(const BaseParticleEmitter self, const LVector3f elv)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleEmitter_set_explicit_launch_vector_10_comment =
  "C++ Interface:\n"
  "set_explicit_launch_vector(const BaseParticleEmitter self, const LVector3f elv)\n"
  "\n"
  "// this is a constant force applied to all particles\n"
  "\n"
  "/**\n"
  " * assignment of explicit emission launch vector\n"
  " */";
#else
static const char *Dtool_BaseParticleEmitter_set_explicit_launch_vector_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BaseParticleEmitter::set_radiate_origin(LPoint3 const &ro)
 */
static PyObject *Dtool_BaseParticleEmitter_set_radiate_origin_11(PyObject *self, PyObject *arg) {
  BaseParticleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseParticleEmitter, (void **)&local_this, "BaseParticleEmitter.set_radiate_origin")) {
    return NULL;
  }
  // 1-inline void BaseParticleEmitter::set_radiate_origin(LPoint3 const &ro)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BaseParticleEmitter.set_radiate_origin", "LPoint3f");
  }
  (*local_this).set_radiate_origin(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radiate_origin(const BaseParticleEmitter self, const LPoint3f ro)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleEmitter_set_radiate_origin_11_comment =
  "C++ Interface:\n"
  "set_radiate_origin(const BaseParticleEmitter self, const LPoint3f ro)\n"
  "\n"
  "/**\n"
  " * assignment of radiate emission origin point\n"
  " */";
#else
static const char *Dtool_BaseParticleEmitter_set_radiate_origin_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BaseParticleEmitter::emissionType BaseParticleEmitter::get_emission_type(void) const
 */
static PyObject *Dtool_BaseParticleEmitter_get_emission_type_12(PyObject *self, PyObject *) {
  BaseParticleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BaseParticleEmitter::emissionType BaseParticleEmitter::get_emission_type(void) const
  BaseParticleEmitter::emissionType return_value = (*(const BaseParticleEmitter*)local_this).get_emission_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleEmitter_get_emission_type_12_comment =
  "C++ Interface:\n"
  "get_emission_type(BaseParticleEmitter self)\n"
  "\n"
  "/**\n"
  " * emission type query\n"
  " */";
#else
static const char *Dtool_BaseParticleEmitter_get_emission_type_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat BaseParticleEmitter::get_amplitude(void) const
 */
static PyObject *Dtool_BaseParticleEmitter_get_amplitude_13(PyObject *self, PyObject *) {
  BaseParticleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat BaseParticleEmitter::get_amplitude(void) const
  PN_stdfloat return_value = (*(const BaseParticleEmitter*)local_this).get_amplitude();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleEmitter_get_amplitude_13_comment =
  "C++ Interface:\n"
  "get_amplitude(BaseParticleEmitter self)\n"
  "\n"
  "/**\n"
  " * amplitude query\n"
  " */";
#else
static const char *Dtool_BaseParticleEmitter_get_amplitude_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat BaseParticleEmitter::get_amplitude_spread(void) const
 */
static PyObject *Dtool_BaseParticleEmitter_get_amplitude_spread_14(PyObject *self, PyObject *) {
  BaseParticleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat BaseParticleEmitter::get_amplitude_spread(void) const
  PN_stdfloat return_value = (*(const BaseParticleEmitter*)local_this).get_amplitude_spread();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleEmitter_get_amplitude_spread_14_comment =
  "C++ Interface:\n"
  "get_amplitude_spread(BaseParticleEmitter self)\n"
  "\n"
  "/**\n"
  " * amplitude spread query\n"
  " */";
#else
static const char *Dtool_BaseParticleEmitter_get_amplitude_spread_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 BaseParticleEmitter::get_offset_force(void) const
 */
static PyObject *Dtool_BaseParticleEmitter_get_offset_force_15(PyObject *self, PyObject *) {
  BaseParticleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3 BaseParticleEmitter::get_offset_force(void) const
  LVector3 *return_value = new LVector3((*(const BaseParticleEmitter*)local_this).get_offset_force());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleEmitter_get_offset_force_15_comment =
  "C++ Interface:\n"
  "get_offset_force(BaseParticleEmitter self)\n"
  "\n"
  "/**\n"
  " * user-defined force\n"
  " */";
#else
static const char *Dtool_BaseParticleEmitter_get_offset_force_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 BaseParticleEmitter::get_explicit_launch_vector(void) const
 */
static PyObject *Dtool_BaseParticleEmitter_get_explicit_launch_vector_16(PyObject *self, PyObject *) {
  BaseParticleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3 BaseParticleEmitter::get_explicit_launch_vector(void) const
  LVector3 *return_value = new LVector3((*(const BaseParticleEmitter*)local_this).get_explicit_launch_vector());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleEmitter_get_explicit_launch_vector_16_comment =
  "C++ Interface:\n"
  "get_explicit_launch_vector(BaseParticleEmitter self)\n"
  "\n"
  "/**\n"
  " * query for explicit emission launch vector\n"
  " */";
#else
static const char *Dtool_BaseParticleEmitter_get_explicit_launch_vector_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 BaseParticleEmitter::get_radiate_origin(void) const
 */
static PyObject *Dtool_BaseParticleEmitter_get_radiate_origin_17(PyObject *self, PyObject *) {
  BaseParticleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 BaseParticleEmitter::get_radiate_origin(void) const
  LPoint3 *return_value = new LPoint3((*(const BaseParticleEmitter*)local_this).get_radiate_origin());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleEmitter_get_radiate_origin_17_comment =
  "C++ Interface:\n"
  "get_radiate_origin(BaseParticleEmitter self)\n"
  "\n"
  "/**\n"
  " * query for explicit emission launch vector\n"
  " */";
#else
static const char *Dtool_BaseParticleEmitter_get_radiate_origin_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void BaseParticleEmitter::output(ostream &out) const
 */
static PyObject *Dtool_BaseParticleEmitter_output_18(PyObject *self, PyObject *arg) {
  BaseParticleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void BaseParticleEmitter::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "BaseParticleEmitter.output", false, true);
  if (arg_this != NULL) {
    (*(const BaseParticleEmitter*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(BaseParticleEmitter self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleEmitter_output_18_comment =
  "C++ Interface:\n"
  "output(BaseParticleEmitter self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_BaseParticleEmitter_output_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void BaseParticleEmitter::write(ostream &out, int indent = 0) const
 */
static PyObject *Dtool_BaseParticleEmitter_write_19(PyObject *self, PyObject *args, PyObject *kwds) {
  BaseParticleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void BaseParticleEmitter::write(ostream &out, int indent = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BaseParticleEmitter.write", false, true);
    if (param1_this != NULL) {
      (*(const BaseParticleEmitter*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(BaseParticleEmitter self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleEmitter_write_19_comment =
  "C++ Interface:\n"
  "write(BaseParticleEmitter self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_BaseParticleEmitter_write_19_comment = NULL;
#endif

static int Dtool_Init_BaseParticleEmitter(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_BaseParticleEmitter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BaseParticleEmitter) {
    printf("BaseParticleEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BaseParticleEmitter *local_this = (BaseParticleEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BaseParticleEmitter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BaseParticleEmitter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BaseParticleEmitter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BaseParticleEmitter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class RingEmitter
 */
/**
 * Python function wrapper for:
 * inline void RingEmitter::set_radius(PN_stdfloat r)
 */
static PyObject *Dtool_RingEmitter_set_radius_22(PyObject *self, PyObject *arg) {
  RingEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RingEmitter, (void **)&local_this, "RingEmitter.set_radius")) {
    return NULL;
  }
  // 1-inline void RingEmitter::set_radius(PN_stdfloat r)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const RingEmitter self, float r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RingEmitter_set_radius_22_comment =
  "C++ Interface:\n"
  "set_radius(const RingEmitter self, float r)\n";
#else
static const char *Dtool_RingEmitter_set_radius_22_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RingEmitter::set_angle(PN_stdfloat angle)
 */
static PyObject *Dtool_RingEmitter_set_angle_23(PyObject *self, PyObject *arg) {
  RingEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RingEmitter, (void **)&local_this, "RingEmitter.set_angle")) {
    return NULL;
  }
  // 1-inline void RingEmitter::set_angle(PN_stdfloat angle)
  if (PyNumber_Check(arg)) {
    (*local_this).set_angle((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_angle(const RingEmitter self, float angle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RingEmitter_set_angle_23_comment =
  "C++ Interface:\n"
  "set_angle(const RingEmitter self, float angle)\n";
#else
static const char *Dtool_RingEmitter_set_angle_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RingEmitter::set_radius_spread(PN_stdfloat spread)
 */
static PyObject *Dtool_RingEmitter_set_radius_spread_24(PyObject *self, PyObject *arg) {
  RingEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RingEmitter, (void **)&local_this, "RingEmitter.set_radius_spread")) {
    return NULL;
  }
  // 1-inline void RingEmitter::set_radius_spread(PN_stdfloat spread)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius_spread((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius_spread(const RingEmitter self, float spread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RingEmitter_set_radius_spread_24_comment =
  "C++ Interface:\n"
  "set_radius_spread(const RingEmitter self, float spread)\n";
#else
static const char *Dtool_RingEmitter_set_radius_spread_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RingEmitter::set_uniform_emission(int uniform_emission)
 */
static PyObject *Dtool_RingEmitter_set_uniform_emission_25(PyObject *self, PyObject *arg) {
  RingEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RingEmitter, (void **)&local_this, "RingEmitter.set_uniform_emission")) {
    return NULL;
  }
  // 1-inline void RingEmitter::set_uniform_emission(int uniform_emission)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_uniform_emission((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uniform_emission(const RingEmitter self, int uniform_emission)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RingEmitter_set_uniform_emission_25_comment =
  "C++ Interface:\n"
  "set_uniform_emission(const RingEmitter self, int uniform_emission)\n";
#else
static const char *Dtool_RingEmitter_set_uniform_emission_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat RingEmitter::get_radius(void) const
 */
static PyObject *Dtool_RingEmitter_get_radius_26(PyObject *self, PyObject *) {
  RingEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RingEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat RingEmitter::get_radius(void) const
  PN_stdfloat return_value = (*(const RingEmitter*)local_this).get_radius();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RingEmitter_get_radius_26_comment =
  "C++ Interface:\n"
  "get_radius(RingEmitter self)\n";
#else
static const char *Dtool_RingEmitter_get_radius_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat RingEmitter::get_angle(void) const
 */
static PyObject *Dtool_RingEmitter_get_angle_27(PyObject *self, PyObject *) {
  RingEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RingEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat RingEmitter::get_angle(void) const
  PN_stdfloat return_value = (*(const RingEmitter*)local_this).get_angle();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RingEmitter_get_angle_27_comment =
  "C++ Interface:\n"
  "get_angle(RingEmitter self)\n";
#else
static const char *Dtool_RingEmitter_get_angle_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat RingEmitter::get_radius_spread(void) const
 */
static PyObject *Dtool_RingEmitter_get_radius_spread_28(PyObject *self, PyObject *) {
  RingEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RingEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat RingEmitter::get_radius_spread(void) const
  PN_stdfloat return_value = (*(const RingEmitter*)local_this).get_radius_spread();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RingEmitter_get_radius_spread_28_comment =
  "C++ Interface:\n"
  "get_radius_spread(RingEmitter self)\n";
#else
static const char *Dtool_RingEmitter_get_radius_spread_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int RingEmitter::get_uniform_emission(void) const
 */
static PyObject *Dtool_RingEmitter_get_uniform_emission_29(PyObject *self, PyObject *) {
  RingEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RingEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int RingEmitter::get_uniform_emission(void) const
  int return_value = (*(const RingEmitter*)local_this).get_uniform_emission();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RingEmitter_get_uniform_emission_29_comment =
  "C++ Interface:\n"
  "get_uniform_emission(RingEmitter self)\n";
#else
static const char *Dtool_RingEmitter_get_uniform_emission_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * RingEmitter::RingEmitter(void)
 * RingEmitter::RingEmitter(RingEmitter const &copy)
 */
static int Dtool_Init_RingEmitter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-RingEmitter::RingEmitter(void)
      RingEmitter *return_value = new RingEmitter();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RingEmitter, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-RingEmitter::RingEmitter(RingEmitter const &copy)
      RingEmitter const *arg_this = (RingEmitter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RingEmitter, 0, "RingEmitter.RingEmitter", true, true);
      if (arg_this != NULL) {
        RingEmitter *return_value = new RingEmitter(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RingEmitter, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "RingEmitter() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "RingEmitter()\n"
      "RingEmitter(const RingEmitter copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_RingEmitter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_RingEmitter) {
    printf("RingEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  RingEmitter *local_this = (RingEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_RingEmitter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseParticleEmitter) {
    return (BaseParticleEmitter *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseParticleEmitter *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_RingEmitter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_RingEmitter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseParticleEmitter) {
    BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
    return (RingEmitter*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RingEmitter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ArcEmitter
 */
/**
 * Python function wrapper for:
 * inline void ArcEmitter::set_start_angle(PN_stdfloat angle)
 */
static PyObject *Dtool_ArcEmitter_set_start_angle_32(PyObject *self, PyObject *arg) {
  ArcEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ArcEmitter, (void **)&local_this, "ArcEmitter.set_start_angle")) {
    return NULL;
  }
  // 1-inline void ArcEmitter::set_start_angle(PN_stdfloat angle)
  if (PyNumber_Check(arg)) {
    (*local_this).set_start_angle((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_angle(const ArcEmitter self, float angle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ArcEmitter_set_start_angle_32_comment =
  "C++ Interface:\n"
  "set_start_angle(const ArcEmitter self, float angle)\n";
#else
static const char *Dtool_ArcEmitter_set_start_angle_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ArcEmitter::set_end_angle(PN_stdfloat angle)
 */
static PyObject *Dtool_ArcEmitter_set_end_angle_33(PyObject *self, PyObject *arg) {
  ArcEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ArcEmitter, (void **)&local_this, "ArcEmitter.set_end_angle")) {
    return NULL;
  }
  // 1-inline void ArcEmitter::set_end_angle(PN_stdfloat angle)
  if (PyNumber_Check(arg)) {
    (*local_this).set_end_angle((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_angle(const ArcEmitter self, float angle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ArcEmitter_set_end_angle_33_comment =
  "C++ Interface:\n"
  "set_end_angle(const ArcEmitter self, float angle)\n";
#else
static const char *Dtool_ArcEmitter_set_end_angle_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ArcEmitter::set_arc(PN_stdfloat startAngle, PN_stdfloat endAngle)
 */
static PyObject *Dtool_ArcEmitter_set_arc_34(PyObject *self, PyObject *args, PyObject *kwds) {
  ArcEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ArcEmitter, (void **)&local_this, "ArcEmitter.set_arc")) {
    return NULL;
  }
  // 1-inline void ArcEmitter::set_arc(PN_stdfloat startAngle, PN_stdfloat endAngle)
  float param1;
  float param2;
  static const char *keyword_list[] = {"startAngle", "endAngle", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_arc", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_arc((PN_stdfloat)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_arc(const ArcEmitter self, float startAngle, float endAngle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ArcEmitter_set_arc_34_comment =
  "C++ Interface:\n"
  "set_arc(const ArcEmitter self, float startAngle, float endAngle)\n";
#else
static const char *Dtool_ArcEmitter_set_arc_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat ArcEmitter::get_start_angle(void)
 */
static PyObject *Dtool_ArcEmitter_get_start_angle_35(PyObject *self, PyObject *) {
  ArcEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ArcEmitter, (void **)&local_this, "ArcEmitter.get_start_angle")) {
    return NULL;
  }
  // 1-inline PN_stdfloat ArcEmitter::get_start_angle(void)
  PN_stdfloat return_value = (*local_this).get_start_angle();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ArcEmitter_get_start_angle_35_comment =
  "C++ Interface:\n"
  "get_start_angle(const ArcEmitter self)\n";
#else
static const char *Dtool_ArcEmitter_get_start_angle_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat ArcEmitter::get_end_angle(void)
 */
static PyObject *Dtool_ArcEmitter_get_end_angle_36(PyObject *self, PyObject *) {
  ArcEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ArcEmitter, (void **)&local_this, "ArcEmitter.get_end_angle")) {
    return NULL;
  }
  // 1-inline PN_stdfloat ArcEmitter::get_end_angle(void)
  PN_stdfloat return_value = (*local_this).get_end_angle();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ArcEmitter_get_end_angle_36_comment =
  "C++ Interface:\n"
  "get_end_angle(const ArcEmitter self)\n";
#else
static const char *Dtool_ArcEmitter_get_end_angle_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ArcEmitter::ArcEmitter(void)
 * ArcEmitter::ArcEmitter(ArcEmitter const &copy)
 */
static int Dtool_Init_ArcEmitter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-ArcEmitter::ArcEmitter(void)
      ArcEmitter *return_value = new ArcEmitter();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ArcEmitter, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-ArcEmitter::ArcEmitter(ArcEmitter const &copy)
      ArcEmitter const *arg_this = (ArcEmitter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ArcEmitter, 0, "ArcEmitter.ArcEmitter", true, true);
      if (arg_this != NULL) {
        ArcEmitter *return_value = new ArcEmitter(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ArcEmitter, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ArcEmitter() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ArcEmitter()\n"
      "ArcEmitter(const ArcEmitter copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ArcEmitter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ArcEmitter) {
    printf("ArcEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ArcEmitter *local_this = (ArcEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ArcEmitter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseParticleEmitter) {
    return (BaseParticleEmitter *)(RingEmitter *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseParticleEmitter *)(RingEmitter *) local_this;
  }
  if (requested_type == Dtool_Ptr_RingEmitter) {
    return (RingEmitter *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ArcEmitter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ArcEmitter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseParticleEmitter) {
    BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
    return (ArcEmitter*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ArcEmitter*)other_this;
  }
  if (from_type == Dtool_Ptr_RingEmitter) {
    RingEmitter* other_this = (RingEmitter*)from_this;
    return (ArcEmitter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BaseParticleFactory
 */
/**
 * Python function wrapper for:
 * inline void BaseParticleFactory::set_lifespan_base(PN_stdfloat lb)
 */
static PyObject *Dtool_BaseParticleFactory_set_lifespan_base_38(PyObject *self, PyObject *arg) {
  BaseParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseParticleFactory, (void **)&local_this, "BaseParticleFactory.set_lifespan_base")) {
    return NULL;
  }
  // 1-inline void BaseParticleFactory::set_lifespan_base(PN_stdfloat lb)
  if (PyNumber_Check(arg)) {
    (*local_this).set_lifespan_base((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lifespan_base(const BaseParticleFactory self, float lb)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleFactory_set_lifespan_base_38_comment =
  "C++ Interface:\n"
  "set_lifespan_base(const BaseParticleFactory self, float lb)\n"
  "\n"
  "/**\n"
  " * public\n"
  " */";
#else
static const char *Dtool_BaseParticleFactory_set_lifespan_base_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BaseParticleFactory::set_lifespan_spread(PN_stdfloat ls)
 */
static PyObject *Dtool_BaseParticleFactory_set_lifespan_spread_39(PyObject *self, PyObject *arg) {
  BaseParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseParticleFactory, (void **)&local_this, "BaseParticleFactory.set_lifespan_spread")) {
    return NULL;
  }
  // 1-inline void BaseParticleFactory::set_lifespan_spread(PN_stdfloat ls)
  if (PyNumber_Check(arg)) {
    (*local_this).set_lifespan_spread((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lifespan_spread(const BaseParticleFactory self, float ls)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleFactory_set_lifespan_spread_39_comment =
  "C++ Interface:\n"
  "set_lifespan_spread(const BaseParticleFactory self, float ls)\n"
  "\n"
  "/**\n"
  " * public\n"
  " */";
#else
static const char *Dtool_BaseParticleFactory_set_lifespan_spread_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BaseParticleFactory::set_mass_base(PN_stdfloat mb)
 */
static PyObject *Dtool_BaseParticleFactory_set_mass_base_40(PyObject *self, PyObject *arg) {
  BaseParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseParticleFactory, (void **)&local_this, "BaseParticleFactory.set_mass_base")) {
    return NULL;
  }
  // 1-inline void BaseParticleFactory::set_mass_base(PN_stdfloat mb)
  if (PyNumber_Check(arg)) {
    (*local_this).set_mass_base((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mass_base(const BaseParticleFactory self, float mb)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleFactory_set_mass_base_40_comment =
  "C++ Interface:\n"
  "set_mass_base(const BaseParticleFactory self, float mb)\n"
  "\n"
  "/**\n"
  " * public\n"
  " */";
#else
static const char *Dtool_BaseParticleFactory_set_mass_base_40_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BaseParticleFactory::set_mass_spread(PN_stdfloat ms)
 */
static PyObject *Dtool_BaseParticleFactory_set_mass_spread_41(PyObject *self, PyObject *arg) {
  BaseParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseParticleFactory, (void **)&local_this, "BaseParticleFactory.set_mass_spread")) {
    return NULL;
  }
  // 1-inline void BaseParticleFactory::set_mass_spread(PN_stdfloat ms)
  if (PyNumber_Check(arg)) {
    (*local_this).set_mass_spread((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mass_spread(const BaseParticleFactory self, float ms)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleFactory_set_mass_spread_41_comment =
  "C++ Interface:\n"
  "set_mass_spread(const BaseParticleFactory self, float ms)\n"
  "\n"
  "/**\n"
  " * public\n"
  " */";
#else
static const char *Dtool_BaseParticleFactory_set_mass_spread_41_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BaseParticleFactory::set_terminal_velocity_base(PN_stdfloat tvb)
 */
static PyObject *Dtool_BaseParticleFactory_set_terminal_velocity_base_42(PyObject *self, PyObject *arg) {
  BaseParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseParticleFactory, (void **)&local_this, "BaseParticleFactory.set_terminal_velocity_base")) {
    return NULL;
  }
  // 1-inline void BaseParticleFactory::set_terminal_velocity_base(PN_stdfloat tvb)
  if (PyNumber_Check(arg)) {
    (*local_this).set_terminal_velocity_base((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_terminal_velocity_base(const BaseParticleFactory self, float tvb)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleFactory_set_terminal_velocity_base_42_comment =
  "C++ Interface:\n"
  "set_terminal_velocity_base(const BaseParticleFactory self, float tvb)\n"
  "\n"
  "/**\n"
  " * public\n"
  " */";
#else
static const char *Dtool_BaseParticleFactory_set_terminal_velocity_base_42_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BaseParticleFactory::set_terminal_velocity_spread(PN_stdfloat tvs)
 */
static PyObject *Dtool_BaseParticleFactory_set_terminal_velocity_spread_43(PyObject *self, PyObject *arg) {
  BaseParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseParticleFactory, (void **)&local_this, "BaseParticleFactory.set_terminal_velocity_spread")) {
    return NULL;
  }
  // 1-inline void BaseParticleFactory::set_terminal_velocity_spread(PN_stdfloat tvs)
  if (PyNumber_Check(arg)) {
    (*local_this).set_terminal_velocity_spread((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_terminal_velocity_spread(const BaseParticleFactory self, float tvs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleFactory_set_terminal_velocity_spread_43_comment =
  "C++ Interface:\n"
  "set_terminal_velocity_spread(const BaseParticleFactory self, float tvs)\n"
  "\n"
  "/**\n"
  " * public\n"
  " */";
#else
static const char *Dtool_BaseParticleFactory_set_terminal_velocity_spread_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat BaseParticleFactory::get_lifespan_base(void) const
 */
static PyObject *Dtool_BaseParticleFactory_get_lifespan_base_44(PyObject *self, PyObject *) {
  BaseParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleFactory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat BaseParticleFactory::get_lifespan_base(void) const
  PN_stdfloat return_value = (*(const BaseParticleFactory*)local_this).get_lifespan_base();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleFactory_get_lifespan_base_44_comment =
  "C++ Interface:\n"
  "get_lifespan_base(BaseParticleFactory self)\n"
  "\n"
  "/**\n"
  " * public\n"
  " */";
#else
static const char *Dtool_BaseParticleFactory_get_lifespan_base_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat BaseParticleFactory::get_lifespan_spread(void) const
 */
static PyObject *Dtool_BaseParticleFactory_get_lifespan_spread_45(PyObject *self, PyObject *) {
  BaseParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleFactory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat BaseParticleFactory::get_lifespan_spread(void) const
  PN_stdfloat return_value = (*(const BaseParticleFactory*)local_this).get_lifespan_spread();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleFactory_get_lifespan_spread_45_comment =
  "C++ Interface:\n"
  "get_lifespan_spread(BaseParticleFactory self)\n"
  "\n"
  "/**\n"
  " * public\n"
  " */";
#else
static const char *Dtool_BaseParticleFactory_get_lifespan_spread_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat BaseParticleFactory::get_mass_base(void) const
 */
static PyObject *Dtool_BaseParticleFactory_get_mass_base_46(PyObject *self, PyObject *) {
  BaseParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleFactory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat BaseParticleFactory::get_mass_base(void) const
  PN_stdfloat return_value = (*(const BaseParticleFactory*)local_this).get_mass_base();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleFactory_get_mass_base_46_comment =
  "C++ Interface:\n"
  "get_mass_base(BaseParticleFactory self)\n"
  "\n"
  "/**\n"
  " * public\n"
  " */";
#else
static const char *Dtool_BaseParticleFactory_get_mass_base_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat BaseParticleFactory::get_mass_spread(void) const
 */
static PyObject *Dtool_BaseParticleFactory_get_mass_spread_47(PyObject *self, PyObject *) {
  BaseParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleFactory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat BaseParticleFactory::get_mass_spread(void) const
  PN_stdfloat return_value = (*(const BaseParticleFactory*)local_this).get_mass_spread();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleFactory_get_mass_spread_47_comment =
  "C++ Interface:\n"
  "get_mass_spread(BaseParticleFactory self)\n"
  "\n"
  "/**\n"
  " * public\n"
  " */";
#else
static const char *Dtool_BaseParticleFactory_get_mass_spread_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat BaseParticleFactory::get_terminal_velocity_base(void) const
 */
static PyObject *Dtool_BaseParticleFactory_get_terminal_velocity_base_48(PyObject *self, PyObject *) {
  BaseParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleFactory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat BaseParticleFactory::get_terminal_velocity_base(void) const
  PN_stdfloat return_value = (*(const BaseParticleFactory*)local_this).get_terminal_velocity_base();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleFactory_get_terminal_velocity_base_48_comment =
  "C++ Interface:\n"
  "get_terminal_velocity_base(BaseParticleFactory self)\n"
  "\n"
  "/**\n"
  " * public\n"
  " */";
#else
static const char *Dtool_BaseParticleFactory_get_terminal_velocity_base_48_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat BaseParticleFactory::get_terminal_velocity_spread(void) const
 */
static PyObject *Dtool_BaseParticleFactory_get_terminal_velocity_spread_49(PyObject *self, PyObject *) {
  BaseParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleFactory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat BaseParticleFactory::get_terminal_velocity_spread(void) const
  PN_stdfloat return_value = (*(const BaseParticleFactory*)local_this).get_terminal_velocity_spread();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleFactory_get_terminal_velocity_spread_49_comment =
  "C++ Interface:\n"
  "get_terminal_velocity_spread(BaseParticleFactory self)\n"
  "\n"
  "/**\n"
  " * public\n"
  " */";
#else
static const char *Dtool_BaseParticleFactory_get_terminal_velocity_spread_49_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void BaseParticleFactory::output(ostream &out) const
 */
static PyObject *Dtool_BaseParticleFactory_output_52(PyObject *self, PyObject *arg) {
  BaseParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleFactory, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void BaseParticleFactory::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "BaseParticleFactory.output", false, true);
  if (arg_this != NULL) {
    (*(const BaseParticleFactory*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(BaseParticleFactory self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleFactory_output_52_comment =
  "C++ Interface:\n"
  "output(BaseParticleFactory self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_BaseParticleFactory_output_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void BaseParticleFactory::write(ostream &out, int indent = 0) const
 */
static PyObject *Dtool_BaseParticleFactory_write_53(PyObject *self, PyObject *args, PyObject *kwds) {
  BaseParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleFactory, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void BaseParticleFactory::write(ostream &out, int indent = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BaseParticleFactory.write", false, true);
    if (param1_this != NULL) {
      (*(const BaseParticleFactory*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(BaseParticleFactory self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleFactory_write_53_comment =
  "C++ Interface:\n"
  "write(BaseParticleFactory self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_BaseParticleFactory_write_53_comment = NULL;
#endif

static int Dtool_Init_BaseParticleFactory(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_BaseParticleFactory(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BaseParticleFactory) {
    printf("BaseParticleFactory ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BaseParticleFactory *local_this = (BaseParticleFactory *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BaseParticleFactory) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BaseParticleFactory(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BaseParticleFactory) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BaseParticleFactory*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BaseParticleRenderer
 */
/**
 * Python function wrapper for:
 * inline GeomNode *BaseParticleRenderer::get_render_node(void) const
 */
static PyObject *Dtool_BaseParticleRenderer_get_render_node_57(PyObject *self, PyObject *) {
  BaseParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline GeomNode *BaseParticleRenderer::get_render_node(void) const
  GeomNode *return_value = (*(const BaseParticleRenderer*)local_this).get_render_node();
  if (return_value != (GeomNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (GeomNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeomNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleRenderer_get_render_node_57_comment =
  "C++ Interface:\n"
  "get_render_node(BaseParticleRenderer self)\n"
  "\n"
  "/**\n"
  " * Query the geomnode pointer\n"
  " */";
#else
static const char *Dtool_BaseParticleRenderer_get_render_node_57_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath BaseParticleRenderer::get_render_node_path(void) const
 */
static PyObject *Dtool_BaseParticleRenderer_get_render_node_path_58(PyObject *self, PyObject *) {
  BaseParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath BaseParticleRenderer::get_render_node_path(void) const
  NodePath *return_value = new NodePath((*(const BaseParticleRenderer*)local_this).get_render_node_path());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleRenderer_get_render_node_path_58_comment =
  "C++ Interface:\n"
  "get_render_node_path(BaseParticleRenderer self)\n"
  "\n"
  "/**\n"
  " * Query the geomnode pointer\n"
  " */";
#else
static const char *Dtool_BaseParticleRenderer_get_render_node_path_58_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BaseParticleRenderer::set_alpha_mode(BaseParticleRenderer::ParticleRendererAlphaMode am)
 */
static PyObject *Dtool_BaseParticleRenderer_set_alpha_mode_59(PyObject *self, PyObject *arg) {
  BaseParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseParticleRenderer, (void **)&local_this, "BaseParticleRenderer.set_alpha_mode")) {
    return NULL;
  }
  // 1-inline void BaseParticleRenderer::set_alpha_mode(BaseParticleRenderer::ParticleRendererAlphaMode am)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_alpha_mode((BaseParticleRenderer::ParticleRendererAlphaMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_mode(const BaseParticleRenderer self, int am)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleRenderer_set_alpha_mode_59_comment =
  "C++ Interface:\n"
  "set_alpha_mode(const BaseParticleRenderer self, int am)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_BaseParticleRenderer_set_alpha_mode_59_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BaseParticleRenderer::ParticleRendererAlphaMode BaseParticleRenderer::get_alpha_mode(void) const
 */
static PyObject *Dtool_BaseParticleRenderer_get_alpha_mode_60(PyObject *self, PyObject *) {
  BaseParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BaseParticleRenderer::ParticleRendererAlphaMode BaseParticleRenderer::get_alpha_mode(void) const
  BaseParticleRenderer::ParticleRendererAlphaMode return_value = (*(const BaseParticleRenderer*)local_this).get_alpha_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleRenderer_get_alpha_mode_60_comment =
  "C++ Interface:\n"
  "get_alpha_mode(BaseParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_BaseParticleRenderer_get_alpha_mode_60_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BaseParticleRenderer::set_user_alpha(PN_stdfloat ua)
 */
static PyObject *Dtool_BaseParticleRenderer_set_user_alpha_61(PyObject *self, PyObject *arg) {
  BaseParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseParticleRenderer, (void **)&local_this, "BaseParticleRenderer.set_user_alpha")) {
    return NULL;
  }
  // 1-inline void BaseParticleRenderer::set_user_alpha(PN_stdfloat ua)
  if (PyNumber_Check(arg)) {
    (*local_this).set_user_alpha((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_user_alpha(const BaseParticleRenderer self, float ua)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleRenderer_set_user_alpha_61_comment =
  "C++ Interface:\n"
  "set_user_alpha(const BaseParticleRenderer self, float ua)\n"
  "\n"
  "/**\n"
  " * sets alpha for \"user\" alpha mode\n"
  " */";
#else
static const char *Dtool_BaseParticleRenderer_set_user_alpha_61_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat BaseParticleRenderer::get_user_alpha(void) const
 */
static PyObject *Dtool_BaseParticleRenderer_get_user_alpha_62(PyObject *self, PyObject *) {
  BaseParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat BaseParticleRenderer::get_user_alpha(void) const
  PN_stdfloat return_value = (*(const BaseParticleRenderer*)local_this).get_user_alpha();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleRenderer_get_user_alpha_62_comment =
  "C++ Interface:\n"
  "get_user_alpha(BaseParticleRenderer self)\n"
  "\n"
  "/**\n"
  " * gets alpha for \"user\" alpha mode\n"
  " */";
#else
static const char *Dtool_BaseParticleRenderer_get_user_alpha_62_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BaseParticleRenderer::set_color_blend_mode(ColorBlendAttrib::Mode bm, ColorBlendAttrib::Operand oa = ::ColorBlendAttrib::O_zero, ColorBlendAttrib::Operand ob = ::ColorBlendAttrib::O_zero)
 */
static PyObject *Dtool_BaseParticleRenderer_set_color_blend_mode_63(PyObject *self, PyObject *args, PyObject *kwds) {
  BaseParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseParticleRenderer, (void **)&local_this, "BaseParticleRenderer.set_color_blend_mode")) {
    return NULL;
  }
  // 1-inline void BaseParticleRenderer::set_color_blend_mode(ColorBlendAttrib::Mode bm, ColorBlendAttrib::Operand oa = ::ColorBlendAttrib::O_zero, ColorBlendAttrib::Operand ob = ::ColorBlendAttrib::O_zero)
  int param1;
  int param2 = ColorBlendAttrib::O_zero;
  int param3 = ColorBlendAttrib::O_zero;
  static const char *keyword_list[] = {"bm", "oa", "ob", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i|ii:set_color_blend_mode", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_color_blend_mode((ColorBlendAttrib::Mode)param1, (ColorBlendAttrib::Operand)param2, (ColorBlendAttrib::Operand)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color_blend_mode(const BaseParticleRenderer self, int bm, int oa, int ob)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleRenderer_set_color_blend_mode_63_comment =
  "C++ Interface:\n"
  "set_color_blend_mode(const BaseParticleRenderer self, int bm, int oa, int ob)\n"
  "\n"
  "/**\n"
  " * sets the ColorBlendAttrib on the _render_node\n"
  " */";
#else
static const char *Dtool_BaseParticleRenderer_set_color_blend_mode_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BaseParticleRenderer::set_ignore_scale(bool ignore_scale)
 */
static PyObject *Dtool_BaseParticleRenderer_set_ignore_scale_64(PyObject *self, PyObject *arg) {
  BaseParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseParticleRenderer, (void **)&local_this, "BaseParticleRenderer.set_ignore_scale")) {
    return NULL;
  }
  // 1-void BaseParticleRenderer::set_ignore_scale(bool ignore_scale)
  (*local_this).set_ignore_scale((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ignore_scale(const BaseParticleRenderer self, bool ignore_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleRenderer_set_ignore_scale_64_comment =
  "C++ Interface:\n"
  "set_ignore_scale(const BaseParticleRenderer self, bool ignore_scale)\n"
  "\n"
  "/**\n"
  " * Sets the \"ignore scale\" flag.  When this is true, particles will be drawn\n"
  " * as if they had no scale, regardless of whatever scale might be inherited\n"
  " * from above the render node in the scene graph.\n"
  " *\n"
  " * This flag is mainly useful to support legacy code that was written for a\n"
  " * very early version of Panda, whose sprite particle renderer had a bug that\n"
  " * incorrectly ignored the inherited scale.\n"
  " */";
#else
static const char *Dtool_BaseParticleRenderer_set_ignore_scale_64_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BaseParticleRenderer::get_ignore_scale(void) const
 */
static PyObject *Dtool_BaseParticleRenderer_get_ignore_scale_65(PyObject *self, PyObject *) {
  BaseParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BaseParticleRenderer::get_ignore_scale(void) const
  bool return_value = (*(const BaseParticleRenderer*)local_this).get_ignore_scale();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleRenderer_get_ignore_scale_65_comment =
  "C++ Interface:\n"
  "get_ignore_scale(BaseParticleRenderer self)\n"
  "\n"
  "/**\n"
  " * Returns the \"ignore scale\" flag.  See set_ignore_scale().\n"
  " */";
#else
static const char *Dtool_BaseParticleRenderer_get_ignore_scale_65_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void BaseParticleRenderer::output(ostream &out) const
 */
static PyObject *Dtool_BaseParticleRenderer_output_66(PyObject *self, PyObject *arg) {
  BaseParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void BaseParticleRenderer::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "BaseParticleRenderer.output", false, true);
  if (arg_this != NULL) {
    (*(const BaseParticleRenderer*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(BaseParticleRenderer self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleRenderer_output_66_comment =
  "C++ Interface:\n"
  "output(BaseParticleRenderer self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_BaseParticleRenderer_output_66_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void BaseParticleRenderer::write(ostream &out, int indent = 0) const
 */
static PyObject *Dtool_BaseParticleRenderer_write_67(PyObject *self, PyObject *args, PyObject *kwds) {
  BaseParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void BaseParticleRenderer::write(ostream &out, int indent = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BaseParticleRenderer.write", false, true);
    if (param1_this != NULL) {
      (*(const BaseParticleRenderer*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(BaseParticleRenderer self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseParticleRenderer_write_67_comment =
  "C++ Interface:\n"
  "write(BaseParticleRenderer self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_BaseParticleRenderer_write_67_comment = NULL;
#endif

static int Dtool_Init_BaseParticleRenderer(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_BaseParticleRenderer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BaseParticleRenderer) {
    printf("BaseParticleRenderer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BaseParticleRenderer *local_this = (BaseParticleRenderer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BaseParticleRenderer) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BaseParticleRenderer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BaseParticleRenderer) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BaseParticleRenderer*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BoxEmitter
 */
/**
 * Python function wrapper for:
 * inline void BoxEmitter::set_min_bound(LPoint3 const &vmin)
 */
static PyObject *Dtool_BoxEmitter_set_min_bound_70(PyObject *self, PyObject *arg) {
  BoxEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BoxEmitter, (void **)&local_this, "BoxEmitter.set_min_bound")) {
    return NULL;
  }
  // 1-inline void BoxEmitter::set_min_bound(LPoint3 const &vmin)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BoxEmitter.set_min_bound", "LPoint3f");
  }
  (*local_this).set_min_bound(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_min_bound(const BoxEmitter self, const LPoint3f vmin)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BoxEmitter_set_min_bound_70_comment =
  "C++ Interface:\n"
  "set_min_bound(const BoxEmitter self, const LPoint3f vmin)\n"
  "\n"
  "/**\n"
  " * boundary assignment\n"
  " */";
#else
static const char *Dtool_BoxEmitter_set_min_bound_70_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BoxEmitter::set_max_bound(LPoint3 const &vmax)
 */
static PyObject *Dtool_BoxEmitter_set_max_bound_71(PyObject *self, PyObject *arg) {
  BoxEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BoxEmitter, (void **)&local_this, "BoxEmitter.set_max_bound")) {
    return NULL;
  }
  // 1-inline void BoxEmitter::set_max_bound(LPoint3 const &vmax)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BoxEmitter.set_max_bound", "LPoint3f");
  }
  (*local_this).set_max_bound(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_bound(const BoxEmitter self, const LPoint3f vmax)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BoxEmitter_set_max_bound_71_comment =
  "C++ Interface:\n"
  "set_max_bound(const BoxEmitter self, const LPoint3f vmax)\n"
  "\n"
  "/**\n"
  " * boundary assignment\n"
  " */";
#else
static const char *Dtool_BoxEmitter_set_max_bound_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 BoxEmitter::get_min_bound(void) const
 */
static PyObject *Dtool_BoxEmitter_get_min_bound_72(PyObject *self, PyObject *) {
  BoxEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoxEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 BoxEmitter::get_min_bound(void) const
  LPoint3 *return_value = new LPoint3((*(const BoxEmitter*)local_this).get_min_bound());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BoxEmitter_get_min_bound_72_comment =
  "C++ Interface:\n"
  "get_min_bound(BoxEmitter self)\n"
  "\n"
  "/**\n"
  " * boundary accessor\n"
  " */";
#else
static const char *Dtool_BoxEmitter_get_min_bound_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 BoxEmitter::get_max_bound(void) const
 */
static PyObject *Dtool_BoxEmitter_get_max_bound_73(PyObject *self, PyObject *) {
  BoxEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoxEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 BoxEmitter::get_max_bound(void) const
  LPoint3 *return_value = new LPoint3((*(const BoxEmitter*)local_this).get_max_bound());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BoxEmitter_get_max_bound_73_comment =
  "C++ Interface:\n"
  "get_max_bound(BoxEmitter self)\n"
  "\n"
  "/**\n"
  " * boundary accessor\n"
  " */";
#else
static const char *Dtool_BoxEmitter_get_max_bound_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * BoxEmitter::BoxEmitter(void)
 * BoxEmitter::BoxEmitter(BoxEmitter const &copy)
 */
static int Dtool_Init_BoxEmitter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-BoxEmitter::BoxEmitter(void)
      BoxEmitter *return_value = new BoxEmitter();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoxEmitter, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-BoxEmitter::BoxEmitter(BoxEmitter const &copy)
      BoxEmitter const *arg_this = (BoxEmitter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BoxEmitter, 0, "BoxEmitter.BoxEmitter", true, true);
      if (arg_this != NULL) {
        BoxEmitter *return_value = new BoxEmitter(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoxEmitter, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BoxEmitter() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BoxEmitter()\n"
      "BoxEmitter(const BoxEmitter copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BoxEmitter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BoxEmitter) {
    printf("BoxEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BoxEmitter *local_this = (BoxEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BoxEmitter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseParticleEmitter) {
    return (BaseParticleEmitter *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseParticleEmitter *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BoxEmitter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BoxEmitter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseParticleEmitter) {
    BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
    return (BoxEmitter*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BoxEmitter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ColorInterpolationFunctionConstant
 */
/**
 * Python function wrapper for:
 * inline LColor ColorInterpolationFunctionConstant::get_color_a(void) const
 */
static PyObject *Dtool_ColorInterpolationFunctionConstant_get_color_a_76(PyObject *self, PyObject *) {
  ColorInterpolationFunctionConstant *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorInterpolationFunctionConstant, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor ColorInterpolationFunctionConstant::get_color_a(void) const
  LColor *return_value = new LColor((*(const ColorInterpolationFunctionConstant*)local_this).get_color_a());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationFunctionConstant_get_color_a_76_comment =
  "C++ Interface:\n"
  "get_color_a(ColorInterpolationFunctionConstant self)\n";
#else
static const char *Dtool_ColorInterpolationFunctionConstant_get_color_a_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ColorInterpolationFunctionConstant::set_color_a(LColor const &c)
 */
static PyObject *Dtool_ColorInterpolationFunctionConstant_set_color_a_77(PyObject *self, PyObject *arg) {
  ColorInterpolationFunctionConstant *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ColorInterpolationFunctionConstant, (void **)&local_this, "ColorInterpolationFunctionConstant.set_color_a")) {
    return NULL;
  }
  // 1-inline void ColorInterpolationFunctionConstant::set_color_a(LColor const &c)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ColorInterpolationFunctionConstant.set_color_a", "LVecBase4f");
  }
  (*local_this).set_color_a(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color_a(const ColorInterpolationFunctionConstant self, const LVecBase4f c)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationFunctionConstant_set_color_a_77_comment =
  "C++ Interface:\n"
  "set_color_a(const ColorInterpolationFunctionConstant self, const LVecBase4f c)\n";
#else
static const char *Dtool_ColorInterpolationFunctionConstant_set_color_a_77_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ColorInterpolationFunctionConstant::get_class_type(void)
 */
static PyObject *Dtool_ColorInterpolationFunctionConstant_get_class_type_78(PyObject *, PyObject *) {
  // 1-static TypeHandle ColorInterpolationFunctionConstant::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ColorInterpolationFunctionConstant::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationFunctionConstant_get_class_type_78_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ColorInterpolationFunctionConstant_get_class_type_78_comment = NULL;
#endif

static int Dtool_Init_ColorInterpolationFunctionConstant(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ColorInterpolationFunctionConstant(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ColorInterpolationFunctionConstant) {
    printf("ColorInterpolationFunctionConstant ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ColorInterpolationFunctionConstant *local_this = (ColorInterpolationFunctionConstant *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ColorInterpolationFunctionConstant) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(ColorInterpolationFunction *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(ColorInterpolationFunction *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(ColorInterpolationFunction *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ColorInterpolationFunctionConstant(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ColorInterpolationFunctionConstant) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ColorInterpolationFunctionConstant*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ColorInterpolationFunctionConstant*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (ColorInterpolationFunctionConstant*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ColorInterpolationFunctionLinear
 */
/**
 * Python function wrapper for:
 * inline LColor ColorInterpolationFunctionLinear::get_color_b(void) const
 */
static PyObject *Dtool_ColorInterpolationFunctionLinear_get_color_b_81(PyObject *self, PyObject *) {
  ColorInterpolationFunctionLinear *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorInterpolationFunctionLinear, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor ColorInterpolationFunctionLinear::get_color_b(void) const
  LColor *return_value = new LColor((*(const ColorInterpolationFunctionLinear*)local_this).get_color_b());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationFunctionLinear_get_color_b_81_comment =
  "C++ Interface:\n"
  "get_color_b(ColorInterpolationFunctionLinear self)\n";
#else
static const char *Dtool_ColorInterpolationFunctionLinear_get_color_b_81_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ColorInterpolationFunctionLinear::set_color_b(LColor const &c)
 */
static PyObject *Dtool_ColorInterpolationFunctionLinear_set_color_b_82(PyObject *self, PyObject *arg) {
  ColorInterpolationFunctionLinear *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ColorInterpolationFunctionLinear, (void **)&local_this, "ColorInterpolationFunctionLinear.set_color_b")) {
    return NULL;
  }
  // 1-inline void ColorInterpolationFunctionLinear::set_color_b(LColor const &c)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ColorInterpolationFunctionLinear.set_color_b", "LVecBase4f");
  }
  (*local_this).set_color_b(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color_b(const ColorInterpolationFunctionLinear self, const LVecBase4f c)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationFunctionLinear_set_color_b_82_comment =
  "C++ Interface:\n"
  "set_color_b(const ColorInterpolationFunctionLinear self, const LVecBase4f c)\n";
#else
static const char *Dtool_ColorInterpolationFunctionLinear_set_color_b_82_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ColorInterpolationFunctionLinear::get_class_type(void)
 */
static PyObject *Dtool_ColorInterpolationFunctionLinear_get_class_type_83(PyObject *, PyObject *) {
  // 1-static TypeHandle ColorInterpolationFunctionLinear::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ColorInterpolationFunctionLinear::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationFunctionLinear_get_class_type_83_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ColorInterpolationFunctionLinear_get_class_type_83_comment = NULL;
#endif

static int Dtool_Init_ColorInterpolationFunctionLinear(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ColorInterpolationFunctionLinear(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ColorInterpolationFunctionLinear) {
    printf("ColorInterpolationFunctionLinear ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ColorInterpolationFunctionLinear *local_this = (ColorInterpolationFunctionLinear *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ColorInterpolationFunctionLinear) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ColorInterpolationFunctionConstant) {
    return (ColorInterpolationFunctionConstant *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(ColorInterpolationFunction *)(ColorInterpolationFunctionConstant *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(ColorInterpolationFunction *)(ColorInterpolationFunctionConstant *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(ColorInterpolationFunction *)(ColorInterpolationFunctionConstant *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ColorInterpolationFunctionLinear(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ColorInterpolationFunctionLinear) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ColorInterpolationFunctionConstant) {
    ColorInterpolationFunctionConstant* other_this = (ColorInterpolationFunctionConstant*)from_this;
    return (ColorInterpolationFunctionLinear*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ColorInterpolationFunctionLinear*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ColorInterpolationFunctionLinear*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (ColorInterpolationFunctionLinear*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ColorInterpolationFunctionStepwave
 */
/**
 * Python function wrapper for:
 * inline PN_stdfloat ColorInterpolationFunctionStepwave::get_width_a(void) const
 */
static PyObject *Dtool_ColorInterpolationFunctionStepwave_get_width_a_86(PyObject *self, PyObject *) {
  ColorInterpolationFunctionStepwave *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorInterpolationFunctionStepwave, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat ColorInterpolationFunctionStepwave::get_width_a(void) const
  PN_stdfloat return_value = (*(const ColorInterpolationFunctionStepwave*)local_this).get_width_a();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationFunctionStepwave_get_width_a_86_comment =
  "C++ Interface:\n"
  "get_width_a(ColorInterpolationFunctionStepwave self)\n";
#else
static const char *Dtool_ColorInterpolationFunctionStepwave_get_width_a_86_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat ColorInterpolationFunctionStepwave::get_width_b(void) const
 */
static PyObject *Dtool_ColorInterpolationFunctionStepwave_get_width_b_87(PyObject *self, PyObject *) {
  ColorInterpolationFunctionStepwave *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorInterpolationFunctionStepwave, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat ColorInterpolationFunctionStepwave::get_width_b(void) const
  PN_stdfloat return_value = (*(const ColorInterpolationFunctionStepwave*)local_this).get_width_b();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationFunctionStepwave_get_width_b_87_comment =
  "C++ Interface:\n"
  "get_width_b(ColorInterpolationFunctionStepwave self)\n";
#else
static const char *Dtool_ColorInterpolationFunctionStepwave_get_width_b_87_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ColorInterpolationFunctionStepwave::set_width_a(PN_stdfloat const w)
 */
static PyObject *Dtool_ColorInterpolationFunctionStepwave_set_width_a_88(PyObject *self, PyObject *arg) {
  ColorInterpolationFunctionStepwave *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ColorInterpolationFunctionStepwave, (void **)&local_this, "ColorInterpolationFunctionStepwave.set_width_a")) {
    return NULL;
  }
  // 1-inline void ColorInterpolationFunctionStepwave::set_width_a(PN_stdfloat const w)
  if (PyNumber_Check(arg)) {
    (*local_this).set_width_a((PN_stdfloat const)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_width_a(const ColorInterpolationFunctionStepwave self, float w)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationFunctionStepwave_set_width_a_88_comment =
  "C++ Interface:\n"
  "set_width_a(const ColorInterpolationFunctionStepwave self, float w)\n";
#else
static const char *Dtool_ColorInterpolationFunctionStepwave_set_width_a_88_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ColorInterpolationFunctionStepwave::set_width_b(PN_stdfloat const w)
 */
static PyObject *Dtool_ColorInterpolationFunctionStepwave_set_width_b_89(PyObject *self, PyObject *arg) {
  ColorInterpolationFunctionStepwave *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ColorInterpolationFunctionStepwave, (void **)&local_this, "ColorInterpolationFunctionStepwave.set_width_b")) {
    return NULL;
  }
  // 1-inline void ColorInterpolationFunctionStepwave::set_width_b(PN_stdfloat const w)
  if (PyNumber_Check(arg)) {
    (*local_this).set_width_b((PN_stdfloat const)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_width_b(const ColorInterpolationFunctionStepwave self, float w)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationFunctionStepwave_set_width_b_89_comment =
  "C++ Interface:\n"
  "set_width_b(const ColorInterpolationFunctionStepwave self, float w)\n";
#else
static const char *Dtool_ColorInterpolationFunctionStepwave_set_width_b_89_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ColorInterpolationFunctionStepwave::get_class_type(void)
 */
static PyObject *Dtool_ColorInterpolationFunctionStepwave_get_class_type_90(PyObject *, PyObject *) {
  // 1-static TypeHandle ColorInterpolationFunctionStepwave::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ColorInterpolationFunctionStepwave::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationFunctionStepwave_get_class_type_90_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ColorInterpolationFunctionStepwave_get_class_type_90_comment = NULL;
#endif

static int Dtool_Init_ColorInterpolationFunctionStepwave(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ColorInterpolationFunctionStepwave(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ColorInterpolationFunctionStepwave) {
    printf("ColorInterpolationFunctionStepwave ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ColorInterpolationFunctionStepwave *local_this = (ColorInterpolationFunctionStepwave *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ColorInterpolationFunctionStepwave) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ColorInterpolationFunctionConstant) {
    return (ColorInterpolationFunctionConstant *)(ColorInterpolationFunctionLinear *) local_this;
  }
  if (requested_type == Dtool_Ptr_ColorInterpolationFunctionLinear) {
    return (ColorInterpolationFunctionLinear *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(ColorInterpolationFunction *)(ColorInterpolationFunctionConstant *)(ColorInterpolationFunctionLinear *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(ColorInterpolationFunction *)(ColorInterpolationFunctionConstant *)(ColorInterpolationFunctionLinear *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(ColorInterpolationFunction *)(ColorInterpolationFunctionConstant *)(ColorInterpolationFunctionLinear *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ColorInterpolationFunctionStepwave(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ColorInterpolationFunctionStepwave) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ColorInterpolationFunctionConstant) {
    ColorInterpolationFunctionConstant* other_this = (ColorInterpolationFunctionConstant*)from_this;
    return (ColorInterpolationFunctionStepwave*)other_this;
  }
  if (from_type == Dtool_Ptr_ColorInterpolationFunctionLinear) {
    ColorInterpolationFunctionLinear* other_this = (ColorInterpolationFunctionLinear*)from_this;
    return (ColorInterpolationFunctionStepwave*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ColorInterpolationFunctionStepwave*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ColorInterpolationFunctionStepwave*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (ColorInterpolationFunctionStepwave*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ColorInterpolationFunctionSinusoid
 */
/**
 * Python function wrapper for:
 * inline PN_stdfloat ColorInterpolationFunctionSinusoid::get_period(void) const
 */
static PyObject *Dtool_ColorInterpolationFunctionSinusoid_get_period_93(PyObject *self, PyObject *) {
  ColorInterpolationFunctionSinusoid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorInterpolationFunctionSinusoid, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat ColorInterpolationFunctionSinusoid::get_period(void) const
  PN_stdfloat return_value = (*(const ColorInterpolationFunctionSinusoid*)local_this).get_period();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationFunctionSinusoid_get_period_93_comment =
  "C++ Interface:\n"
  "get_period(ColorInterpolationFunctionSinusoid self)\n";
#else
static const char *Dtool_ColorInterpolationFunctionSinusoid_get_period_93_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ColorInterpolationFunctionSinusoid::set_period(PN_stdfloat const p)
 */
static PyObject *Dtool_ColorInterpolationFunctionSinusoid_set_period_94(PyObject *self, PyObject *arg) {
  ColorInterpolationFunctionSinusoid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ColorInterpolationFunctionSinusoid, (void **)&local_this, "ColorInterpolationFunctionSinusoid.set_period")) {
    return NULL;
  }
  // 1-inline void ColorInterpolationFunctionSinusoid::set_period(PN_stdfloat const p)
  if (PyNumber_Check(arg)) {
    (*local_this).set_period((PN_stdfloat const)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_period(const ColorInterpolationFunctionSinusoid self, float p)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationFunctionSinusoid_set_period_94_comment =
  "C++ Interface:\n"
  "set_period(const ColorInterpolationFunctionSinusoid self, float p)\n";
#else
static const char *Dtool_ColorInterpolationFunctionSinusoid_set_period_94_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ColorInterpolationFunctionSinusoid::get_class_type(void)
 */
static PyObject *Dtool_ColorInterpolationFunctionSinusoid_get_class_type_95(PyObject *, PyObject *) {
  // 1-static TypeHandle ColorInterpolationFunctionSinusoid::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ColorInterpolationFunctionSinusoid::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationFunctionSinusoid_get_class_type_95_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ColorInterpolationFunctionSinusoid_get_class_type_95_comment = NULL;
#endif

static int Dtool_Init_ColorInterpolationFunctionSinusoid(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ColorInterpolationFunctionSinusoid(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ColorInterpolationFunctionSinusoid) {
    printf("ColorInterpolationFunctionSinusoid ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ColorInterpolationFunctionSinusoid *local_this = (ColorInterpolationFunctionSinusoid *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ColorInterpolationFunctionSinusoid) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ColorInterpolationFunctionConstant) {
    return (ColorInterpolationFunctionConstant *)(ColorInterpolationFunctionLinear *) local_this;
  }
  if (requested_type == Dtool_Ptr_ColorInterpolationFunctionLinear) {
    return (ColorInterpolationFunctionLinear *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(ColorInterpolationFunction *)(ColorInterpolationFunctionConstant *)(ColorInterpolationFunctionLinear *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(ColorInterpolationFunction *)(ColorInterpolationFunctionConstant *)(ColorInterpolationFunctionLinear *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(ColorInterpolationFunction *)(ColorInterpolationFunctionConstant *)(ColorInterpolationFunctionLinear *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ColorInterpolationFunctionSinusoid(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ColorInterpolationFunctionSinusoid) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ColorInterpolationFunctionConstant) {
    ColorInterpolationFunctionConstant* other_this = (ColorInterpolationFunctionConstant*)from_this;
    return (ColorInterpolationFunctionSinusoid*)other_this;
  }
  if (from_type == Dtool_Ptr_ColorInterpolationFunctionLinear) {
    ColorInterpolationFunctionLinear* other_this = (ColorInterpolationFunctionLinear*)from_this;
    return (ColorInterpolationFunctionSinusoid*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ColorInterpolationFunctionSinusoid*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ColorInterpolationFunctionSinusoid*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (ColorInterpolationFunctionSinusoid*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ColorInterpolationSegment
 */
/**
 * Python function wrapper for:
 * inline TypedReferenceCount *ColorInterpolationSegment::get_function(void) const
 */
static PyObject *Dtool_ColorInterpolationSegment_get_function_99(PyObject *self, PyObject *) {
  ColorInterpolationSegment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorInterpolationSegment, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline TypedReferenceCount *ColorInterpolationSegment::get_function(void) const
  TypedReferenceCount *return_value = (*(const ColorInterpolationSegment*)local_this).get_function();
  if (return_value != (TypedReferenceCount *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (TypedReferenceCount *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationSegment_get_function_99_comment =
  "C++ Interface:\n"
  "get_function(ColorInterpolationSegment self)\n"
  "\n"
  "// INLINE ColorInterpolationFunction* get_function() const;";
#else
static const char *Dtool_ColorInterpolationSegment_get_function_99_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat ColorInterpolationSegment::get_time_begin(void) const
 */
static PyObject *Dtool_ColorInterpolationSegment_get_time_begin_100(PyObject *self, PyObject *) {
  ColorInterpolationSegment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorInterpolationSegment, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat ColorInterpolationSegment::get_time_begin(void) const
  PN_stdfloat return_value = (*(const ColorInterpolationSegment*)local_this).get_time_begin();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationSegment_get_time_begin_100_comment =
  "C++ Interface:\n"
  "get_time_begin(ColorInterpolationSegment self)\n";
#else
static const char *Dtool_ColorInterpolationSegment_get_time_begin_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat ColorInterpolationSegment::get_time_end(void) const
 */
static PyObject *Dtool_ColorInterpolationSegment_get_time_end_101(PyObject *self, PyObject *) {
  ColorInterpolationSegment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorInterpolationSegment, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat ColorInterpolationSegment::get_time_end(void) const
  PN_stdfloat return_value = (*(const ColorInterpolationSegment*)local_this).get_time_end();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationSegment_get_time_end_101_comment =
  "C++ Interface:\n"
  "get_time_end(ColorInterpolationSegment self)\n";
#else
static const char *Dtool_ColorInterpolationSegment_get_time_end_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ColorInterpolationSegment::is_modulated(void) const
 */
static PyObject *Dtool_ColorInterpolationSegment_is_modulated_102(PyObject *self, PyObject *) {
  ColorInterpolationSegment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorInterpolationSegment, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ColorInterpolationSegment::is_modulated(void) const
  bool return_value = (*(const ColorInterpolationSegment*)local_this).is_modulated();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationSegment_is_modulated_102_comment =
  "C++ Interface:\n"
  "is_modulated(ColorInterpolationSegment self)\n";
#else
static const char *Dtool_ColorInterpolationSegment_is_modulated_102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ColorInterpolationSegment::get_id(void) const
 */
static PyObject *Dtool_ColorInterpolationSegment_get_id_103(PyObject *self, PyObject *) {
  ColorInterpolationSegment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorInterpolationSegment, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ColorInterpolationSegment::get_id(void) const
  int return_value = (*(const ColorInterpolationSegment*)local_this).get_id();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationSegment_get_id_103_comment =
  "C++ Interface:\n"
  "get_id(ColorInterpolationSegment self)\n";
#else
static const char *Dtool_ColorInterpolationSegment_get_id_103_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ColorInterpolationSegment::is_enabled(void) const
 */
static PyObject *Dtool_ColorInterpolationSegment_is_enabled_104(PyObject *self, PyObject *) {
  ColorInterpolationSegment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ColorInterpolationSegment, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ColorInterpolationSegment::is_enabled(void) const
  bool return_value = (*(const ColorInterpolationSegment*)local_this).is_enabled();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationSegment_is_enabled_104_comment =
  "C++ Interface:\n"
  "is_enabled(ColorInterpolationSegment self)\n";
#else
static const char *Dtool_ColorInterpolationSegment_is_enabled_104_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ColorInterpolationSegment::set_time_begin(PN_stdfloat const time)
 */
static PyObject *Dtool_ColorInterpolationSegment_set_time_begin_106(PyObject *self, PyObject *arg) {
  ColorInterpolationSegment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ColorInterpolationSegment, (void **)&local_this, "ColorInterpolationSegment.set_time_begin")) {
    return NULL;
  }
  // 1-inline void ColorInterpolationSegment::set_time_begin(PN_stdfloat const time)
  if (PyNumber_Check(arg)) {
    (*local_this).set_time_begin((PN_stdfloat const)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_time_begin(const ColorInterpolationSegment self, float time)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationSegment_set_time_begin_106_comment =
  "C++ Interface:\n"
  "set_time_begin(const ColorInterpolationSegment self, float time)\n";
#else
static const char *Dtool_ColorInterpolationSegment_set_time_begin_106_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ColorInterpolationSegment::set_time_end(PN_stdfloat const time)
 */
static PyObject *Dtool_ColorInterpolationSegment_set_time_end_107(PyObject *self, PyObject *arg) {
  ColorInterpolationSegment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ColorInterpolationSegment, (void **)&local_this, "ColorInterpolationSegment.set_time_end")) {
    return NULL;
  }
  // 1-inline void ColorInterpolationSegment::set_time_end(PN_stdfloat const time)
  if (PyNumber_Check(arg)) {
    (*local_this).set_time_end((PN_stdfloat const)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_time_end(const ColorInterpolationSegment self, float time)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationSegment_set_time_end_107_comment =
  "C++ Interface:\n"
  "set_time_end(const ColorInterpolationSegment self, float time)\n";
#else
static const char *Dtool_ColorInterpolationSegment_set_time_end_107_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ColorInterpolationSegment::set_is_modulated(bool const flag)
 */
static PyObject *Dtool_ColorInterpolationSegment_set_is_modulated_108(PyObject *self, PyObject *arg) {
  ColorInterpolationSegment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ColorInterpolationSegment, (void **)&local_this, "ColorInterpolationSegment.set_is_modulated")) {
    return NULL;
  }
  // 1-inline void ColorInterpolationSegment::set_is_modulated(bool const flag)
  (*local_this).set_is_modulated((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_is_modulated(const ColorInterpolationSegment self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationSegment_set_is_modulated_108_comment =
  "C++ Interface:\n"
  "set_is_modulated(const ColorInterpolationSegment self, bool flag)\n";
#else
static const char *Dtool_ColorInterpolationSegment_set_is_modulated_108_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ColorInterpolationSegment::set_enabled(bool const enabled)
 */
static PyObject *Dtool_ColorInterpolationSegment_set_enabled_109(PyObject *self, PyObject *arg) {
  ColorInterpolationSegment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ColorInterpolationSegment, (void **)&local_this, "ColorInterpolationSegment.set_enabled")) {
    return NULL;
  }
  // 1-inline void ColorInterpolationSegment::set_enabled(bool const enabled)
  (*local_this).set_enabled((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_enabled(const ColorInterpolationSegment self, bool enabled)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationSegment_set_enabled_109_comment =
  "C++ Interface:\n"
  "set_enabled(const ColorInterpolationSegment self, bool enabled)\n";
#else
static const char *Dtool_ColorInterpolationSegment_set_enabled_109_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Rejected Remap [ColorInterpolationSegment::ColorInterpolationSegment(ColorInterpolationFunction *function, PN_stdfloat const &time_begin, PN_stdfloat const &time_end, bool const is_modulated, int const id)]
 * ColorInterpolationSegment::ColorInterpolationSegment(ColorInterpolationSegment const &s)
 */
static int Dtool_Init_ColorInterpolationSegment(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ColorInterpolationSegment() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "s");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 's' (pos 1) not found");
    return -1;
  }
  // 1-ColorInterpolationSegment::ColorInterpolationSegment(ColorInterpolationSegment const &s)
  CPT(ColorInterpolationSegment) arg_this;
  if (!Dtool_ConstCoerce_ColorInterpolationSegment(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 0, "ColorInterpolationSegment.ColorInterpolationSegment", "ColorInterpolationSegment");
    return -1;
  }
  ColorInterpolationSegment *return_value = new ColorInterpolationSegment(*MOVE(arg_this));
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ColorInterpolationSegment, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ColorInterpolationSegment(const ColorInterpolationSegment s)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ColorInterpolationSegment(PyObject *args, CPT(ColorInterpolationSegment) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ColorInterpolationSegment, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_ColorInterpolationSegment(PyObject *args, PT(ColorInterpolationSegment) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ColorInterpolationSegment, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ColorInterpolationSegment(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ColorInterpolationSegment) {
    printf("ColorInterpolationSegment ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ColorInterpolationSegment *local_this = (ColorInterpolationSegment *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ColorInterpolationSegment) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ColorInterpolationSegment(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ColorInterpolationSegment) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ColorInterpolationSegment*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ColorInterpolationManager
 */
/**
 * Python function wrapper for:
 * int ColorInterpolationManager::add_constant(PN_stdfloat const time_begin = 0.0, PN_stdfloat const time_end = 1.0, LColor const &color = LColor(1.0, 1.0, 1.0, 1.0), bool const is_modulated = true)
 */
static PyObject *Dtool_ColorInterpolationManager_add_constant_112(PyObject *self, PyObject *args, PyObject *kwds) {
  ColorInterpolationManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ColorInterpolationManager, (void **)&local_this, "ColorInterpolationManager.add_constant")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-int ColorInterpolationManager::add_constant(PN_stdfloat const time_begin, PN_stdfloat const time_end, LColor const &color, bool const is_modulated)
      int return_value = (*local_this).add_constant();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "time_begin");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'time_begin' (pos 1) not found");
      }
      // 1-int ColorInterpolationManager::add_constant(PN_stdfloat const time_begin, PN_stdfloat const time_end, LColor const &color, bool const is_modulated)
      if (PyNumber_Check(arg)) {
        int return_value = (*local_this).add_constant((PN_stdfloat const)PyFloat_AsDouble(arg));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-int ColorInterpolationManager::add_constant(PN_stdfloat const time_begin, PN_stdfloat const time_end, LColor const &color, bool const is_modulated)
      float param1;
      float param2;
      static const char *keyword_list[] = {"time_begin", "time_end", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:add_constant", (char **)keyword_list, &param1, &param2)) {
        int return_value = (*local_this).add_constant((PN_stdfloat const)param1, (PN_stdfloat const)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 3:
  case 4:
    {
      // 1-int ColorInterpolationManager::add_constant(PN_stdfloat const time_begin, PN_stdfloat const time_end, LColor const &color, bool const is_modulated = true)
      float param1;
      float param2;
      PyObject *param3;
      PyObject *param4 = Py_True;
      static const char *keyword_list[] = {"time_begin", "time_end", "color", "is_modulated", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffO|O:add_constant", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        LVecBase4f param3_local;
        LColor const *param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
        if (!(param3_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "ColorInterpolationManager.add_constant", "LVecBase4f");
        }
        int return_value = (*local_this).add_constant((PN_stdfloat const)param1, (PN_stdfloat const)param2, *param3_this, (PyObject_IsTrue(param4) != 0));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_constant() takes 1, 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_constant(const ColorInterpolationManager self)\n"
      "add_constant(const ColorInterpolationManager self, float time_begin)\n"
      "add_constant(const ColorInterpolationManager self, float time_begin, float time_end)\n"
      "add_constant(const ColorInterpolationManager self, float time_begin, float time_end, const LVecBase4f color, bool is_modulated)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationManager_add_constant_112_comment =
  "C++ Interface:\n"
  "add_constant(const ColorInterpolationManager self)\n"
  "add_constant(const ColorInterpolationManager self, float time_begin)\n"
  "add_constant(const ColorInterpolationManager self, float time_begin, float time_end)\n"
  "add_constant(const ColorInterpolationManager self, float time_begin, float time_end, const LVecBase4f color, bool is_modulated)\n";
#else
static const char *Dtool_ColorInterpolationManager_add_constant_112_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int ColorInterpolationManager::add_linear(PN_stdfloat const time_begin = 0.0, PN_stdfloat const time_end = 1.0, LColor const &color_a = LColor(1.0, 0.0, 0.0, 1.0), LColor const &color_b = LColor(0.0, 1.0, 0.0, 1.0), bool const is_modulated = true)
 */
static PyObject *Dtool_ColorInterpolationManager_add_linear_113(PyObject *self, PyObject *args, PyObject *kwds) {
  ColorInterpolationManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ColorInterpolationManager, (void **)&local_this, "ColorInterpolationManager.add_linear")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-int ColorInterpolationManager::add_linear(PN_stdfloat const time_begin, PN_stdfloat const time_end, LColor const &color_a, LColor const &color_b, bool const is_modulated)
      int return_value = (*local_this).add_linear();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "time_begin");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'time_begin' (pos 1) not found");
      }
      // 1-int ColorInterpolationManager::add_linear(PN_stdfloat const time_begin, PN_stdfloat const time_end, LColor const &color_a, LColor const &color_b, bool const is_modulated)
      if (PyNumber_Check(arg)) {
        int return_value = (*local_this).add_linear((PN_stdfloat const)PyFloat_AsDouble(arg));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-int ColorInterpolationManager::add_linear(PN_stdfloat const time_begin, PN_stdfloat const time_end, LColor const &color_a, LColor const &color_b, bool const is_modulated)
      float param1;
      float param2;
      static const char *keyword_list[] = {"time_begin", "time_end", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:add_linear", (char **)keyword_list, &param1, &param2)) {
        int return_value = (*local_this).add_linear((PN_stdfloat const)param1, (PN_stdfloat const)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-int ColorInterpolationManager::add_linear(PN_stdfloat const time_begin, PN_stdfloat const time_end, LColor const &color_a, LColor const &color_b, bool const is_modulated)
      float param1;
      float param2;
      PyObject *param3;
      static const char *keyword_list[] = {"time_begin", "time_end", "color_a", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffO:add_linear", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase4f param3_local;
        LColor const *param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
        if (!(param3_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "ColorInterpolationManager.add_linear", "LVecBase4f");
        }
        int return_value = (*local_this).add_linear((PN_stdfloat const)param1, (PN_stdfloat const)param2, *param3_this);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 4:
  case 5:
    {
      // 1-int ColorInterpolationManager::add_linear(PN_stdfloat const time_begin, PN_stdfloat const time_end, LColor const &color_a, LColor const &color_b, bool const is_modulated = true)
      float param1;
      float param2;
      PyObject *param3;
      PyObject *param4;
      PyObject *param5 = Py_True;
      static const char *keyword_list[] = {"time_begin", "time_end", "color_a", "color_b", "is_modulated", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffOO|O:add_linear", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        LVecBase4f param3_local;
        LColor const *param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
        if (!(param3_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "ColorInterpolationManager.add_linear", "LVecBase4f");
        }
        LVecBase4f param4_local;
        LColor const *param4_this = Dtool_Coerce_LVecBase4f(param4, param4_local);
        if (!(param4_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param4, 4, "ColorInterpolationManager.add_linear", "LVecBase4f");
        }
        int return_value = (*local_this).add_linear((PN_stdfloat const)param1, (PN_stdfloat const)param2, *param3_this, *param4_this, (PyObject_IsTrue(param5) != 0));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_linear() takes 1, 2, 3, 4, 5 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_linear(const ColorInterpolationManager self)\n"
      "add_linear(const ColorInterpolationManager self, float time_begin)\n"
      "add_linear(const ColorInterpolationManager self, float time_begin, float time_end)\n"
      "add_linear(const ColorInterpolationManager self, float time_begin, float time_end, const LVecBase4f color_a)\n"
      "add_linear(const ColorInterpolationManager self, float time_begin, float time_end, const LVecBase4f color_a, const LVecBase4f color_b, bool is_modulated)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationManager_add_linear_113_comment =
  "C++ Interface:\n"
  "add_linear(const ColorInterpolationManager self)\n"
  "add_linear(const ColorInterpolationManager self, float time_begin)\n"
  "add_linear(const ColorInterpolationManager self, float time_begin, float time_end)\n"
  "add_linear(const ColorInterpolationManager self, float time_begin, float time_end, const LVecBase4f color_a)\n"
  "add_linear(const ColorInterpolationManager self, float time_begin, float time_end, const LVecBase4f color_a, const LVecBase4f color_b, bool is_modulated)\n";
#else
static const char *Dtool_ColorInterpolationManager_add_linear_113_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int ColorInterpolationManager::add_stepwave(PN_stdfloat const time_begin = 0.0, PN_stdfloat const time_end = 1.0, LColor const &color_a = LColor(1.0, 0.0, 0.0, 1.0), LColor const &color_b = LColor(0.0, 1.0, 0.0, 1.0), PN_stdfloat const width_a = 0.5, PN_stdfloat const width_b = 0.5, bool const is_modulated = true)
 */
static PyObject *Dtool_ColorInterpolationManager_add_stepwave_114(PyObject *self, PyObject *args, PyObject *kwds) {
  ColorInterpolationManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ColorInterpolationManager, (void **)&local_this, "ColorInterpolationManager.add_stepwave")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-int ColorInterpolationManager::add_stepwave(PN_stdfloat const time_begin, PN_stdfloat const time_end, LColor const &color_a, LColor const &color_b, PN_stdfloat const width_a, PN_stdfloat const width_b, bool const is_modulated)
      int return_value = (*local_this).add_stepwave();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "time_begin");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'time_begin' (pos 1) not found");
      }
      // 1-int ColorInterpolationManager::add_stepwave(PN_stdfloat const time_begin, PN_stdfloat const time_end, LColor const &color_a, LColor const &color_b, PN_stdfloat const width_a, PN_stdfloat const width_b, bool const is_modulated)
      if (PyNumber_Check(arg)) {
        int return_value = (*local_this).add_stepwave((PN_stdfloat const)PyFloat_AsDouble(arg));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-int ColorInterpolationManager::add_stepwave(PN_stdfloat const time_begin, PN_stdfloat const time_end, LColor const &color_a, LColor const &color_b, PN_stdfloat const width_a, PN_stdfloat const width_b, bool const is_modulated)
      float param1;
      float param2;
      static const char *keyword_list[] = {"time_begin", "time_end", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:add_stepwave", (char **)keyword_list, &param1, &param2)) {
        int return_value = (*local_this).add_stepwave((PN_stdfloat const)param1, (PN_stdfloat const)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-int ColorInterpolationManager::add_stepwave(PN_stdfloat const time_begin, PN_stdfloat const time_end, LColor const &color_a, LColor const &color_b, PN_stdfloat const width_a, PN_stdfloat const width_b, bool const is_modulated)
      float param1;
      float param2;
      PyObject *param3;
      static const char *keyword_list[] = {"time_begin", "time_end", "color_a", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffO:add_stepwave", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase4f param3_local;
        LColor const *param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
        if (!(param3_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "ColorInterpolationManager.add_stepwave", "LVecBase4f");
        }
        int return_value = (*local_this).add_stepwave((PN_stdfloat const)param1, (PN_stdfloat const)param2, *param3_this);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 4:
  case 5:
  case 6:
  case 7:
    {
      // 1-int ColorInterpolationManager::add_stepwave(PN_stdfloat const time_begin, PN_stdfloat const time_end, LColor const &color_a, LColor const &color_b, PN_stdfloat const width_a = 0.5, PN_stdfloat const width_b = 0.5, bool const is_modulated = true)
      float param1;
      float param2;
      PyObject *param3;
      PyObject *param4;
      float param5 = 0.5;
      float param6 = 0.5;
      PyObject *param7 = Py_True;
      static const char *keyword_list[] = {"time_begin", "time_end", "color_a", "color_b", "width_a", "width_b", "is_modulated", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffOO|ffO:add_stepwave", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
        LVecBase4f param3_local;
        LColor const *param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
        if (!(param3_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "ColorInterpolationManager.add_stepwave", "LVecBase4f");
        }
        LVecBase4f param4_local;
        LColor const *param4_this = Dtool_Coerce_LVecBase4f(param4, param4_local);
        if (!(param4_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param4, 4, "ColorInterpolationManager.add_stepwave", "LVecBase4f");
        }
        int return_value = (*local_this).add_stepwave((PN_stdfloat const)param1, (PN_stdfloat const)param2, *param3_this, *param4_this, (PN_stdfloat const)param5, (PN_stdfloat const)param6, (PyObject_IsTrue(param7) != 0));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_stepwave() takes 1, 2, 3, 4, 5, 6, 7 or 8 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_stepwave(const ColorInterpolationManager self)\n"
      "add_stepwave(const ColorInterpolationManager self, float time_begin)\n"
      "add_stepwave(const ColorInterpolationManager self, float time_begin, float time_end)\n"
      "add_stepwave(const ColorInterpolationManager self, float time_begin, float time_end, const LVecBase4f color_a)\n"
      "add_stepwave(const ColorInterpolationManager self, float time_begin, float time_end, const LVecBase4f color_a, const LVecBase4f color_b, float width_a, float width_b, bool is_modulated)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationManager_add_stepwave_114_comment =
  "C++ Interface:\n"
  "add_stepwave(const ColorInterpolationManager self)\n"
  "add_stepwave(const ColorInterpolationManager self, float time_begin)\n"
  "add_stepwave(const ColorInterpolationManager self, float time_begin, float time_end)\n"
  "add_stepwave(const ColorInterpolationManager self, float time_begin, float time_end, const LVecBase4f color_a)\n"
  "add_stepwave(const ColorInterpolationManager self, float time_begin, float time_end, const LVecBase4f color_a, const LVecBase4f color_b, float width_a, float width_b, bool is_modulated)\n";
#else
static const char *Dtool_ColorInterpolationManager_add_stepwave_114_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int ColorInterpolationManager::add_sinusoid(PN_stdfloat const time_begin = 0.0, PN_stdfloat const time_end = 1.0, LColor const &color_a = LColor(1.0, 0.0, 0.0, 1.0), LColor const &color_b = LColor(0.0, 1.0, 0.0, 1.0), PN_stdfloat const period = 1.0, bool const is_modulated = true)
 */
static PyObject *Dtool_ColorInterpolationManager_add_sinusoid_115(PyObject *self, PyObject *args, PyObject *kwds) {
  ColorInterpolationManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ColorInterpolationManager, (void **)&local_this, "ColorInterpolationManager.add_sinusoid")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-int ColorInterpolationManager::add_sinusoid(PN_stdfloat const time_begin, PN_stdfloat const time_end, LColor const &color_a, LColor const &color_b, PN_stdfloat const period, bool const is_modulated)
      int return_value = (*local_this).add_sinusoid();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "time_begin");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'time_begin' (pos 1) not found");
      }
      // 1-int ColorInterpolationManager::add_sinusoid(PN_stdfloat const time_begin, PN_stdfloat const time_end, LColor const &color_a, LColor const &color_b, PN_stdfloat const period, bool const is_modulated)
      if (PyNumber_Check(arg)) {
        int return_value = (*local_this).add_sinusoid((PN_stdfloat const)PyFloat_AsDouble(arg));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-int ColorInterpolationManager::add_sinusoid(PN_stdfloat const time_begin, PN_stdfloat const time_end, LColor const &color_a, LColor const &color_b, PN_stdfloat const period, bool const is_modulated)
      float param1;
      float param2;
      static const char *keyword_list[] = {"time_begin", "time_end", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:add_sinusoid", (char **)keyword_list, &param1, &param2)) {
        int return_value = (*local_this).add_sinusoid((PN_stdfloat const)param1, (PN_stdfloat const)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-int ColorInterpolationManager::add_sinusoid(PN_stdfloat const time_begin, PN_stdfloat const time_end, LColor const &color_a, LColor const &color_b, PN_stdfloat const period, bool const is_modulated)
      float param1;
      float param2;
      PyObject *param3;
      static const char *keyword_list[] = {"time_begin", "time_end", "color_a", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffO:add_sinusoid", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase4f param3_local;
        LColor const *param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
        if (!(param3_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "ColorInterpolationManager.add_sinusoid", "LVecBase4f");
        }
        int return_value = (*local_this).add_sinusoid((PN_stdfloat const)param1, (PN_stdfloat const)param2, *param3_this);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 4:
  case 5:
  case 6:
    {
      // 1-int ColorInterpolationManager::add_sinusoid(PN_stdfloat const time_begin, PN_stdfloat const time_end, LColor const &color_a, LColor const &color_b, PN_stdfloat const period = 1.0, bool const is_modulated = true)
      float param1;
      float param2;
      PyObject *param3;
      PyObject *param4;
      float param5 = 1.0;
      PyObject *param6 = Py_True;
      static const char *keyword_list[] = {"time_begin", "time_end", "color_a", "color_b", "period", "is_modulated", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffOO|fO:add_sinusoid", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        LVecBase4f param3_local;
        LColor const *param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
        if (!(param3_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "ColorInterpolationManager.add_sinusoid", "LVecBase4f");
        }
        LVecBase4f param4_local;
        LColor const *param4_this = Dtool_Coerce_LVecBase4f(param4, param4_local);
        if (!(param4_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param4, 4, "ColorInterpolationManager.add_sinusoid", "LVecBase4f");
        }
        int return_value = (*local_this).add_sinusoid((PN_stdfloat const)param1, (PN_stdfloat const)param2, *param3_this, *param4_this, (PN_stdfloat const)param5, (PyObject_IsTrue(param6) != 0));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_sinusoid() takes 1, 2, 3, 4, 5, 6 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_sinusoid(const ColorInterpolationManager self)\n"
      "add_sinusoid(const ColorInterpolationManager self, float time_begin)\n"
      "add_sinusoid(const ColorInterpolationManager self, float time_begin, float time_end)\n"
      "add_sinusoid(const ColorInterpolationManager self, float time_begin, float time_end, const LVecBase4f color_a)\n"
      "add_sinusoid(const ColorInterpolationManager self, float time_begin, float time_end, const LVecBase4f color_a, const LVecBase4f color_b, float period, bool is_modulated)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationManager_add_sinusoid_115_comment =
  "C++ Interface:\n"
  "add_sinusoid(const ColorInterpolationManager self)\n"
  "add_sinusoid(const ColorInterpolationManager self, float time_begin)\n"
  "add_sinusoid(const ColorInterpolationManager self, float time_begin, float time_end)\n"
  "add_sinusoid(const ColorInterpolationManager self, float time_begin, float time_end, const LVecBase4f color_a)\n"
  "add_sinusoid(const ColorInterpolationManager self, float time_begin, float time_end, const LVecBase4f color_a, const LVecBase4f color_b, float period, bool is_modulated)\n";
#else
static const char *Dtool_ColorInterpolationManager_add_sinusoid_115_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ColorInterpolationManager::set_default_color(LColor const &c)
 */
static PyObject *Dtool_ColorInterpolationManager_set_default_color_116(PyObject *self, PyObject *arg) {
  ColorInterpolationManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ColorInterpolationManager, (void **)&local_this, "ColorInterpolationManager.set_default_color")) {
    return NULL;
  }
  // 1-inline void ColorInterpolationManager::set_default_color(LColor const &c)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ColorInterpolationManager.set_default_color", "LVecBase4f");
  }
  (*local_this).set_default_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_default_color(const ColorInterpolationManager self, const LVecBase4f c)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationManager_set_default_color_116_comment =
  "C++ Interface:\n"
  "set_default_color(const ColorInterpolationManager self, const LVecBase4f c)\n";
#else
static const char *Dtool_ColorInterpolationManager_set_default_color_116_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ColorInterpolationSegment *ColorInterpolationManager::get_segment(int const seg_id)
 */
static PyObject *Dtool_ColorInterpolationManager_get_segment_117(PyObject *self, PyObject *arg) {
  ColorInterpolationManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ColorInterpolationManager, (void **)&local_this, "ColorInterpolationManager.get_segment")) {
    return NULL;
  }
  // 1-inline ColorInterpolationSegment *ColorInterpolationManager::get_segment(int const seg_id)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ColorInterpolationSegment *return_value = (*local_this).get_segment((int const)arg_val);
    if (return_value != (ColorInterpolationSegment *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (ColorInterpolationSegment *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ColorInterpolationSegment, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_segment(const ColorInterpolationManager self, int seg_id)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationManager_get_segment_117_comment =
  "C++ Interface:\n"
  "get_segment(const ColorInterpolationManager self, int seg_id)\n";
#else
static const char *Dtool_ColorInterpolationManager_get_segment_117_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string ColorInterpolationManager::get_segment_id_list(void)
 */
static PyObject *Dtool_ColorInterpolationManager_get_segment_id_list_118(PyObject *self, PyObject *) {
  ColorInterpolationManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ColorInterpolationManager, (void **)&local_this, "ColorInterpolationManager.get_segment_id_list")) {
    return NULL;
  }
  // 1-inline std::string ColorInterpolationManager::get_segment_id_list(void)
  std::string return_value = (*local_this).get_segment_id_list();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationManager_get_segment_id_list_118_comment =
  "C++ Interface:\n"
  "get_segment_id_list(const ColorInterpolationManager self)\n";
#else
static const char *Dtool_ColorInterpolationManager_get_segment_id_list_118_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ColorInterpolationManager::clear_segment(int const seg_id)
 */
static PyObject *Dtool_ColorInterpolationManager_clear_segment_119(PyObject *self, PyObject *arg) {
  ColorInterpolationManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ColorInterpolationManager, (void **)&local_this, "ColorInterpolationManager.clear_segment")) {
    return NULL;
  }
  // 1-void ColorInterpolationManager::clear_segment(int const seg_id)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).clear_segment((int const)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_segment(const ColorInterpolationManager self, int seg_id)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationManager_clear_segment_119_comment =
  "C++ Interface:\n"
  "clear_segment(const ColorInterpolationManager self, int seg_id)\n";
#else
static const char *Dtool_ColorInterpolationManager_clear_segment_119_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ColorInterpolationManager::clear_to_initial(void)
 */
static PyObject *Dtool_ColorInterpolationManager_clear_to_initial_120(PyObject *self, PyObject *) {
  ColorInterpolationManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ColorInterpolationManager, (void **)&local_this, "ColorInterpolationManager.clear_to_initial")) {
    return NULL;
  }
  // 1-void ColorInterpolationManager::clear_to_initial(void)
  (*local_this).clear_to_initial();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ColorInterpolationManager_clear_to_initial_120_comment =
  "C++ Interface:\n"
  "clear_to_initial(const ColorInterpolationManager self)\n";
#else
static const char *Dtool_ColorInterpolationManager_clear_to_initial_120_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ColorInterpolationManager::ColorInterpolationManager(void)
 * ColorInterpolationManager::ColorInterpolationManager(ColorInterpolationManager const &copy)
 * ColorInterpolationManager::ColorInterpolationManager(LColor const &c)
 */
static int Dtool_Init_ColorInterpolationManager(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-ColorInterpolationManager::ColorInterpolationManager(void)
      ColorInterpolationManager *return_value = new ColorInterpolationManager();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ColorInterpolationManager, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 ColorInterpolationManager::ColorInterpolationManager(ColorInterpolationManager const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ColorInterpolationManager", (char **)keyword_list, &param0)) {
          ColorInterpolationManager const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ColorInterpolationManager, (void **)&param0_this);
          if (param0_this != NULL) {
            ColorInterpolationManager *return_value = new ColorInterpolationManager(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ColorInterpolationManager, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 ColorInterpolationManager::ColorInterpolationManager(LColor const &c)
        PyObject *param0;
        static const char *keyword_list[] = {"c", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ColorInterpolationManager", (char **)keyword_list, &param0)) {
          LColor const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4f, (void **)&param0_this);
          if (param0_this != NULL) {
            ColorInterpolationManager *return_value = new ColorInterpolationManager(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ColorInterpolationManager, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 ColorInterpolationManager::ColorInterpolationManager(ColorInterpolationManager const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ColorInterpolationManager", (char **)keyword_list, &param0)) {
          CPT(ColorInterpolationManager) param0_this;
          if (Dtool_ConstCoerce_ColorInterpolationManager(param0, param0_this)) {
            ColorInterpolationManager *return_value = new ColorInterpolationManager(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ColorInterpolationManager, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 ColorInterpolationManager::ColorInterpolationManager(LColor const &c)
        PyObject *param0;
        static const char *keyword_list[] = {"c", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ColorInterpolationManager", (char **)keyword_list, &param0)) {
          LVecBase4f param0_local;
          LColor const *param0_this = Dtool_Coerce_LVecBase4f(param0, param0_local);
          if ((param0_this != NULL)) {
            ColorInterpolationManager *return_value = new ColorInterpolationManager(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ColorInterpolationManager, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ColorInterpolationManager() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ColorInterpolationManager()\n"
      "ColorInterpolationManager(const ColorInterpolationManager copy)\n"
      "ColorInterpolationManager(const LVecBase4f c)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ColorInterpolationManager(PyObject *args, CPT(ColorInterpolationManager) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ColorInterpolationManager, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ColorInterpolationManager::ColorInterpolationManager(LColor const &c)
    LColor const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
    if (arg_this != NULL) {
      ColorInterpolationManager *return_value = new ColorInterpolationManager(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ColorInterpolationManager(PyObject *args, PT(ColorInterpolationManager) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ColorInterpolationManager, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ColorInterpolationManager::ColorInterpolationManager(LColor const &c)
    LColor const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
    if (arg_this != NULL) {
      ColorInterpolationManager *return_value = new ColorInterpolationManager(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ColorInterpolationManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ColorInterpolationManager) {
    printf("ColorInterpolationManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ColorInterpolationManager *local_this = (ColorInterpolationManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ColorInterpolationManager) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ColorInterpolationManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ColorInterpolationManager) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ColorInterpolationManager*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DiscEmitter
 */
/**
 * Python function wrapper for:
 * inline void DiscEmitter::set_radius(PN_stdfloat r)
 */
static PyObject *Dtool_DiscEmitter_set_radius_123(PyObject *self, PyObject *arg) {
  DiscEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DiscEmitter, (void **)&local_this, "DiscEmitter.set_radius")) {
    return NULL;
  }
  // 1-inline void DiscEmitter::set_radius(PN_stdfloat r)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const DiscEmitter self, float r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DiscEmitter_set_radius_123_comment =
  "C++ Interface:\n"
  "set_radius(const DiscEmitter self, float r)\n";
#else
static const char *Dtool_DiscEmitter_set_radius_123_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DiscEmitter::set_outer_angle(PN_stdfloat o_angle)
 */
static PyObject *Dtool_DiscEmitter_set_outer_angle_124(PyObject *self, PyObject *arg) {
  DiscEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DiscEmitter, (void **)&local_this, "DiscEmitter.set_outer_angle")) {
    return NULL;
  }
  // 1-inline void DiscEmitter::set_outer_angle(PN_stdfloat o_angle)
  if (PyNumber_Check(arg)) {
    (*local_this).set_outer_angle((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_outer_angle(const DiscEmitter self, float o_angle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DiscEmitter_set_outer_angle_124_comment =
  "C++ Interface:\n"
  "set_outer_angle(const DiscEmitter self, float o_angle)\n";
#else
static const char *Dtool_DiscEmitter_set_outer_angle_124_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DiscEmitter::set_inner_angle(PN_stdfloat i_angle)
 */
static PyObject *Dtool_DiscEmitter_set_inner_angle_125(PyObject *self, PyObject *arg) {
  DiscEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DiscEmitter, (void **)&local_this, "DiscEmitter.set_inner_angle")) {
    return NULL;
  }
  // 1-inline void DiscEmitter::set_inner_angle(PN_stdfloat i_angle)
  if (PyNumber_Check(arg)) {
    (*local_this).set_inner_angle((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_inner_angle(const DiscEmitter self, float i_angle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DiscEmitter_set_inner_angle_125_comment =
  "C++ Interface:\n"
  "set_inner_angle(const DiscEmitter self, float i_angle)\n";
#else
static const char *Dtool_DiscEmitter_set_inner_angle_125_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DiscEmitter::set_outer_magnitude(PN_stdfloat o_mag)
 */
static PyObject *Dtool_DiscEmitter_set_outer_magnitude_126(PyObject *self, PyObject *arg) {
  DiscEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DiscEmitter, (void **)&local_this, "DiscEmitter.set_outer_magnitude")) {
    return NULL;
  }
  // 1-inline void DiscEmitter::set_outer_magnitude(PN_stdfloat o_mag)
  if (PyNumber_Check(arg)) {
    (*local_this).set_outer_magnitude((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_outer_magnitude(const DiscEmitter self, float o_mag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DiscEmitter_set_outer_magnitude_126_comment =
  "C++ Interface:\n"
  "set_outer_magnitude(const DiscEmitter self, float o_mag)\n";
#else
static const char *Dtool_DiscEmitter_set_outer_magnitude_126_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DiscEmitter::set_inner_magnitude(PN_stdfloat i_mag)
 */
static PyObject *Dtool_DiscEmitter_set_inner_magnitude_127(PyObject *self, PyObject *arg) {
  DiscEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DiscEmitter, (void **)&local_this, "DiscEmitter.set_inner_magnitude")) {
    return NULL;
  }
  // 1-inline void DiscEmitter::set_inner_magnitude(PN_stdfloat i_mag)
  if (PyNumber_Check(arg)) {
    (*local_this).set_inner_magnitude((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_inner_magnitude(const DiscEmitter self, float i_mag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DiscEmitter_set_inner_magnitude_127_comment =
  "C++ Interface:\n"
  "set_inner_magnitude(const DiscEmitter self, float i_mag)\n";
#else
static const char *Dtool_DiscEmitter_set_inner_magnitude_127_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DiscEmitter::set_cubic_lerping(bool clerp)
 */
static PyObject *Dtool_DiscEmitter_set_cubic_lerping_128(PyObject *self, PyObject *arg) {
  DiscEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DiscEmitter, (void **)&local_this, "DiscEmitter.set_cubic_lerping")) {
    return NULL;
  }
  // 1-inline void DiscEmitter::set_cubic_lerping(bool clerp)
  (*local_this).set_cubic_lerping((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cubic_lerping(const DiscEmitter self, bool clerp)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DiscEmitter_set_cubic_lerping_128_comment =
  "C++ Interface:\n"
  "set_cubic_lerping(const DiscEmitter self, bool clerp)\n";
#else
static const char *Dtool_DiscEmitter_set_cubic_lerping_128_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DiscEmitter::get_radius(void) const
 */
static PyObject *Dtool_DiscEmitter_get_radius_129(PyObject *self, PyObject *) {
  DiscEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DiscEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DiscEmitter::get_radius(void) const
  PN_stdfloat return_value = (*(const DiscEmitter*)local_this).get_radius();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DiscEmitter_get_radius_129_comment =
  "C++ Interface:\n"
  "get_radius(DiscEmitter self)\n";
#else
static const char *Dtool_DiscEmitter_get_radius_129_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DiscEmitter::get_outer_angle(void) const
 */
static PyObject *Dtool_DiscEmitter_get_outer_angle_130(PyObject *self, PyObject *) {
  DiscEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DiscEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DiscEmitter::get_outer_angle(void) const
  PN_stdfloat return_value = (*(const DiscEmitter*)local_this).get_outer_angle();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DiscEmitter_get_outer_angle_130_comment =
  "C++ Interface:\n"
  "get_outer_angle(DiscEmitter self)\n";
#else
static const char *Dtool_DiscEmitter_get_outer_angle_130_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DiscEmitter::get_inner_angle(void) const
 */
static PyObject *Dtool_DiscEmitter_get_inner_angle_131(PyObject *self, PyObject *) {
  DiscEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DiscEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DiscEmitter::get_inner_angle(void) const
  PN_stdfloat return_value = (*(const DiscEmitter*)local_this).get_inner_angle();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DiscEmitter_get_inner_angle_131_comment =
  "C++ Interface:\n"
  "get_inner_angle(DiscEmitter self)\n";
#else
static const char *Dtool_DiscEmitter_get_inner_angle_131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DiscEmitter::get_outer_magnitude(void) const
 */
static PyObject *Dtool_DiscEmitter_get_outer_magnitude_132(PyObject *self, PyObject *) {
  DiscEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DiscEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DiscEmitter::get_outer_magnitude(void) const
  PN_stdfloat return_value = (*(const DiscEmitter*)local_this).get_outer_magnitude();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DiscEmitter_get_outer_magnitude_132_comment =
  "C++ Interface:\n"
  "get_outer_magnitude(DiscEmitter self)\n";
#else
static const char *Dtool_DiscEmitter_get_outer_magnitude_132_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DiscEmitter::get_inner_magnitude(void) const
 */
static PyObject *Dtool_DiscEmitter_get_inner_magnitude_133(PyObject *self, PyObject *) {
  DiscEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DiscEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat DiscEmitter::get_inner_magnitude(void) const
  PN_stdfloat return_value = (*(const DiscEmitter*)local_this).get_inner_magnitude();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DiscEmitter_get_inner_magnitude_133_comment =
  "C++ Interface:\n"
  "get_inner_magnitude(DiscEmitter self)\n";
#else
static const char *Dtool_DiscEmitter_get_inner_magnitude_133_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DiscEmitter::get_cubic_lerping(void) const
 */
static PyObject *Dtool_DiscEmitter_get_cubic_lerping_134(PyObject *self, PyObject *) {
  DiscEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DiscEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DiscEmitter::get_cubic_lerping(void) const
  bool return_value = (*(const DiscEmitter*)local_this).get_cubic_lerping();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DiscEmitter_get_cubic_lerping_134_comment =
  "C++ Interface:\n"
  "get_cubic_lerping(DiscEmitter self)\n";
#else
static const char *Dtool_DiscEmitter_get_cubic_lerping_134_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DiscEmitter::DiscEmitter(void)
 * DiscEmitter::DiscEmitter(DiscEmitter const &copy)
 */
static int Dtool_Init_DiscEmitter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-DiscEmitter::DiscEmitter(void)
      DiscEmitter *return_value = new DiscEmitter();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DiscEmitter, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-DiscEmitter::DiscEmitter(DiscEmitter const &copy)
      DiscEmitter const *arg_this = (DiscEmitter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DiscEmitter, 0, "DiscEmitter.DiscEmitter", true, true);
      if (arg_this != NULL) {
        DiscEmitter *return_value = new DiscEmitter(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DiscEmitter, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DiscEmitter() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DiscEmitter()\n"
      "DiscEmitter(const DiscEmitter copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DiscEmitter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DiscEmitter) {
    printf("DiscEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DiscEmitter *local_this = (DiscEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DiscEmitter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseParticleEmitter) {
    return (BaseParticleEmitter *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseParticleEmitter *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DiscEmitter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DiscEmitter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseParticleEmitter) {
    BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
    return (DiscEmitter*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (DiscEmitter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class GeomParticleRenderer
 */
/**
 * Python function wrapper for:
 * inline void GeomParticleRenderer::set_geom_node(PandaNode *node)
 */
static PyObject *Dtool_GeomParticleRenderer_set_geom_node_137(PyObject *self, PyObject *arg) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomParticleRenderer, (void **)&local_this, "GeomParticleRenderer.set_geom_node")) {
    return NULL;
  }
  // 1-inline void GeomParticleRenderer::set_geom_node(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "GeomParticleRenderer.set_geom_node", false, true);
  if (arg_this != NULL) {
    (*local_this).set_geom_node(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_geom_node(const GeomParticleRenderer self, PandaNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_set_geom_node_137_comment =
  "C++ Interface:\n"
  "set_geom_node(const GeomParticleRenderer self, PandaNode node)\n";
#else
static const char *Dtool_GeomParticleRenderer_set_geom_node_137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode *GeomParticleRenderer::get_geom_node(void)
 */
static PyObject *Dtool_GeomParticleRenderer_get_geom_node_138(PyObject *self, PyObject *) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomParticleRenderer, (void **)&local_this, "GeomParticleRenderer.get_geom_node")) {
    return NULL;
  }
  // 1-inline PandaNode *GeomParticleRenderer::get_geom_node(void)
  PandaNode *return_value = (*local_this).get_geom_node();
  if (return_value != (PandaNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PandaNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_get_geom_node_138_comment =
  "C++ Interface:\n"
  "get_geom_node(const GeomParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_get_geom_node_138_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ColorInterpolationManager *GeomParticleRenderer::get_color_interpolation_manager(void) const
 */
static PyObject *Dtool_GeomParticleRenderer_get_color_interpolation_manager_139(PyObject *self, PyObject *) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ColorInterpolationManager *GeomParticleRenderer::get_color_interpolation_manager(void) const
  ColorInterpolationManager *return_value = (*(const GeomParticleRenderer*)local_this).get_color_interpolation_manager();
  if (return_value != (ColorInterpolationManager *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (ColorInterpolationManager *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ColorInterpolationManager, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_get_color_interpolation_manager_139_comment =
  "C++ Interface:\n"
  "get_color_interpolation_manager(GeomParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_get_color_interpolation_manager_139_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeomParticleRenderer::set_x_scale_flag(bool animate_x_ratio)
 */
static PyObject *Dtool_GeomParticleRenderer_set_x_scale_flag_140(PyObject *self, PyObject *arg) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomParticleRenderer, (void **)&local_this, "GeomParticleRenderer.set_x_scale_flag")) {
    return NULL;
  }
  // 1-inline void GeomParticleRenderer::set_x_scale_flag(bool animate_x_ratio)
  (*local_this).set_x_scale_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_x_scale_flag(const GeomParticleRenderer self, bool animate_x_ratio)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_set_x_scale_flag_140_comment =
  "C++ Interface:\n"
  "set_x_scale_flag(const GeomParticleRenderer self, bool animate_x_ratio)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_set_x_scale_flag_140_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeomParticleRenderer::set_y_scale_flag(bool animate_y_ratio)
 */
static PyObject *Dtool_GeomParticleRenderer_set_y_scale_flag_141(PyObject *self, PyObject *arg) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomParticleRenderer, (void **)&local_this, "GeomParticleRenderer.set_y_scale_flag")) {
    return NULL;
  }
  // 1-inline void GeomParticleRenderer::set_y_scale_flag(bool animate_y_ratio)
  (*local_this).set_y_scale_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_y_scale_flag(const GeomParticleRenderer self, bool animate_y_ratio)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_set_y_scale_flag_141_comment =
  "C++ Interface:\n"
  "set_y_scale_flag(const GeomParticleRenderer self, bool animate_y_ratio)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_set_y_scale_flag_141_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeomParticleRenderer::set_z_scale_flag(bool animate_z_ratio)
 */
static PyObject *Dtool_GeomParticleRenderer_set_z_scale_flag_142(PyObject *self, PyObject *arg) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomParticleRenderer, (void **)&local_this, "GeomParticleRenderer.set_z_scale_flag")) {
    return NULL;
  }
  // 1-inline void GeomParticleRenderer::set_z_scale_flag(bool animate_z_ratio)
  (*local_this).set_z_scale_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_z_scale_flag(const GeomParticleRenderer self, bool animate_z_ratio)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_set_z_scale_flag_142_comment =
  "C++ Interface:\n"
  "set_z_scale_flag(const GeomParticleRenderer self, bool animate_z_ratio)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_set_z_scale_flag_142_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeomParticleRenderer::set_initial_x_scale(PN_stdfloat initial_x_scale)
 */
static PyObject *Dtool_GeomParticleRenderer_set_initial_x_scale_143(PyObject *self, PyObject *arg) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomParticleRenderer, (void **)&local_this, "GeomParticleRenderer.set_initial_x_scale")) {
    return NULL;
  }
  // 1-inline void GeomParticleRenderer::set_initial_x_scale(PN_stdfloat initial_x_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_initial_x_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_initial_x_scale(const GeomParticleRenderer self, float initial_x_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_set_initial_x_scale_143_comment =
  "C++ Interface:\n"
  "set_initial_x_scale(const GeomParticleRenderer self, float initial_x_scale)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_set_initial_x_scale_143_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeomParticleRenderer::set_final_x_scale(PN_stdfloat final_x_scale)
 */
static PyObject *Dtool_GeomParticleRenderer_set_final_x_scale_144(PyObject *self, PyObject *arg) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomParticleRenderer, (void **)&local_this, "GeomParticleRenderer.set_final_x_scale")) {
    return NULL;
  }
  // 1-inline void GeomParticleRenderer::set_final_x_scale(PN_stdfloat final_x_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_final_x_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_final_x_scale(const GeomParticleRenderer self, float final_x_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_set_final_x_scale_144_comment =
  "C++ Interface:\n"
  "set_final_x_scale(const GeomParticleRenderer self, float final_x_scale)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_set_final_x_scale_144_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeomParticleRenderer::set_initial_y_scale(PN_stdfloat initial_y_scale)
 */
static PyObject *Dtool_GeomParticleRenderer_set_initial_y_scale_145(PyObject *self, PyObject *arg) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomParticleRenderer, (void **)&local_this, "GeomParticleRenderer.set_initial_y_scale")) {
    return NULL;
  }
  // 1-inline void GeomParticleRenderer::set_initial_y_scale(PN_stdfloat initial_y_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_initial_y_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_initial_y_scale(const GeomParticleRenderer self, float initial_y_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_set_initial_y_scale_145_comment =
  "C++ Interface:\n"
  "set_initial_y_scale(const GeomParticleRenderer self, float initial_y_scale)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_set_initial_y_scale_145_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeomParticleRenderer::set_final_y_scale(PN_stdfloat final_y_scale)
 */
static PyObject *Dtool_GeomParticleRenderer_set_final_y_scale_146(PyObject *self, PyObject *arg) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomParticleRenderer, (void **)&local_this, "GeomParticleRenderer.set_final_y_scale")) {
    return NULL;
  }
  // 1-inline void GeomParticleRenderer::set_final_y_scale(PN_stdfloat final_y_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_final_y_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_final_y_scale(const GeomParticleRenderer self, float final_y_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_set_final_y_scale_146_comment =
  "C++ Interface:\n"
  "set_final_y_scale(const GeomParticleRenderer self, float final_y_scale)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_set_final_y_scale_146_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeomParticleRenderer::set_initial_z_scale(PN_stdfloat initial_z_scale)
 */
static PyObject *Dtool_GeomParticleRenderer_set_initial_z_scale_147(PyObject *self, PyObject *arg) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomParticleRenderer, (void **)&local_this, "GeomParticleRenderer.set_initial_z_scale")) {
    return NULL;
  }
  // 1-inline void GeomParticleRenderer::set_initial_z_scale(PN_stdfloat initial_z_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_initial_z_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_initial_z_scale(const GeomParticleRenderer self, float initial_z_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_set_initial_z_scale_147_comment =
  "C++ Interface:\n"
  "set_initial_z_scale(const GeomParticleRenderer self, float initial_z_scale)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_set_initial_z_scale_147_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GeomParticleRenderer::set_final_z_scale(PN_stdfloat final_z_scale)
 */
static PyObject *Dtool_GeomParticleRenderer_set_final_z_scale_148(PyObject *self, PyObject *arg) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeomParticleRenderer, (void **)&local_this, "GeomParticleRenderer.set_final_z_scale")) {
    return NULL;
  }
  // 1-inline void GeomParticleRenderer::set_final_z_scale(PN_stdfloat final_z_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_final_z_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_final_z_scale(const GeomParticleRenderer self, float final_z_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_set_final_z_scale_148_comment =
  "C++ Interface:\n"
  "set_final_z_scale(const GeomParticleRenderer self, float final_z_scale)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_set_final_z_scale_148_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomParticleRenderer::get_x_scale_flag(void) const
 */
static PyObject *Dtool_GeomParticleRenderer_get_x_scale_flag_149(PyObject *self, PyObject *) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool GeomParticleRenderer::get_x_scale_flag(void) const
  bool return_value = (*(const GeomParticleRenderer*)local_this).get_x_scale_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_get_x_scale_flag_149_comment =
  "C++ Interface:\n"
  "get_x_scale_flag(GeomParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_get_x_scale_flag_149_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomParticleRenderer::get_y_scale_flag(void) const
 */
static PyObject *Dtool_GeomParticleRenderer_get_y_scale_flag_150(PyObject *self, PyObject *) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool GeomParticleRenderer::get_y_scale_flag(void) const
  bool return_value = (*(const GeomParticleRenderer*)local_this).get_y_scale_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_get_y_scale_flag_150_comment =
  "C++ Interface:\n"
  "get_y_scale_flag(GeomParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_get_y_scale_flag_150_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool GeomParticleRenderer::get_z_scale_flag(void) const
 */
static PyObject *Dtool_GeomParticleRenderer_get_z_scale_flag_151(PyObject *self, PyObject *) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool GeomParticleRenderer::get_z_scale_flag(void) const
  bool return_value = (*(const GeomParticleRenderer*)local_this).get_z_scale_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_get_z_scale_flag_151_comment =
  "C++ Interface:\n"
  "get_z_scale_flag(GeomParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_get_z_scale_flag_151_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat GeomParticleRenderer::get_initial_x_scale(void) const
 */
static PyObject *Dtool_GeomParticleRenderer_get_initial_x_scale_152(PyObject *self, PyObject *) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat GeomParticleRenderer::get_initial_x_scale(void) const
  PN_stdfloat return_value = (*(const GeomParticleRenderer*)local_this).get_initial_x_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_get_initial_x_scale_152_comment =
  "C++ Interface:\n"
  "get_initial_x_scale(GeomParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_get_initial_x_scale_152_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat GeomParticleRenderer::get_final_x_scale(void) const
 */
static PyObject *Dtool_GeomParticleRenderer_get_final_x_scale_153(PyObject *self, PyObject *) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat GeomParticleRenderer::get_final_x_scale(void) const
  PN_stdfloat return_value = (*(const GeomParticleRenderer*)local_this).get_final_x_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_get_final_x_scale_153_comment =
  "C++ Interface:\n"
  "get_final_x_scale(GeomParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_get_final_x_scale_153_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat GeomParticleRenderer::get_initial_y_scale(void) const
 */
static PyObject *Dtool_GeomParticleRenderer_get_initial_y_scale_154(PyObject *self, PyObject *) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat GeomParticleRenderer::get_initial_y_scale(void) const
  PN_stdfloat return_value = (*(const GeomParticleRenderer*)local_this).get_initial_y_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_get_initial_y_scale_154_comment =
  "C++ Interface:\n"
  "get_initial_y_scale(GeomParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_get_initial_y_scale_154_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat GeomParticleRenderer::get_final_y_scale(void) const
 */
static PyObject *Dtool_GeomParticleRenderer_get_final_y_scale_155(PyObject *self, PyObject *) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat GeomParticleRenderer::get_final_y_scale(void) const
  PN_stdfloat return_value = (*(const GeomParticleRenderer*)local_this).get_final_y_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_get_final_y_scale_155_comment =
  "C++ Interface:\n"
  "get_final_y_scale(GeomParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_get_final_y_scale_155_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat GeomParticleRenderer::get_initial_z_scale(void) const
 */
static PyObject *Dtool_GeomParticleRenderer_get_initial_z_scale_156(PyObject *self, PyObject *) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat GeomParticleRenderer::get_initial_z_scale(void) const
  PN_stdfloat return_value = (*(const GeomParticleRenderer*)local_this).get_initial_z_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_get_initial_z_scale_156_comment =
  "C++ Interface:\n"
  "get_initial_z_scale(GeomParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_get_initial_z_scale_156_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat GeomParticleRenderer::get_final_z_scale(void) const
 */
static PyObject *Dtool_GeomParticleRenderer_get_final_z_scale_157(PyObject *self, PyObject *) {
  GeomParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeomParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat GeomParticleRenderer::get_final_z_scale(void) const
  PN_stdfloat return_value = (*(const GeomParticleRenderer*)local_this).get_final_z_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GeomParticleRenderer_get_final_z_scale_157_comment =
  "C++ Interface:\n"
  "get_final_z_scale(GeomParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_GeomParticleRenderer_get_final_z_scale_157_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * GeomParticleRenderer::GeomParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode am = ::BaseParticleRenderer::PR_ALPHA_NONE, PandaNode *geom_node = (PandaNode *)(0))
 * GeomParticleRenderer::GeomParticleRenderer(GeomParticleRenderer const &copy)
 */
static int Dtool_Init_GeomParticleRenderer(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-GeomParticleRenderer::GeomParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode am, PandaNode *geom_node)
      GeomParticleRenderer *return_value = new GeomParticleRenderer();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomParticleRenderer, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 GeomParticleRenderer::GeomParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode am, PandaNode *geom_node = (PandaNode *)(0))
        int param0;
        PyObject *param1 = NULL;
        static const char *keyword_list[] = {"am", "geom_node", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i|O:GeomParticleRenderer", (char **)keyword_list, &param0, &param1)) {
          PandaNode *param1_this = (PandaNode *)(0);
          if (param1 != (PyObject *)NULL) {
            param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "GeomParticleRenderer.GeomParticleRenderer", false, false);
          }
          if ((param1 == NULL || param1_this != NULL)) {
            GeomParticleRenderer *return_value = new GeomParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomParticleRenderer, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: GeomParticleRenderer::GeomParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode am, PandaNode *geom_node = (PandaNode *)(0))
      {
        // -2 GeomParticleRenderer::GeomParticleRenderer(GeomParticleRenderer const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:GeomParticleRenderer", (char **)keyword_list, &param0)) {
          CPT(GeomParticleRenderer) param0_this;
          if (Dtool_ConstCoerce_GeomParticleRenderer(param0, param0_this)) {
            GeomParticleRenderer *return_value = new GeomParticleRenderer(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GeomParticleRenderer, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "GeomParticleRenderer() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GeomParticleRenderer()\n"
      "GeomParticleRenderer(int am, PandaNode geom_node)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_GeomParticleRenderer(PyObject *args, CPT(GeomParticleRenderer) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_GeomParticleRenderer, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-GeomParticleRenderer::GeomParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode am, PandaNode *geom_node)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      GeomParticleRenderer *return_value = new GeomParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)arg_val);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-GeomParticleRenderer::GeomParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode am, PandaNode *geom_node)
      int param0;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "iO:GeomParticleRenderer", &param0, &param1)) {
        PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "GeomParticleRenderer.GeomParticleRenderer", false, false);
        if (param1_this != NULL) {
          GeomParticleRenderer *return_value = new GeomParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_GeomParticleRenderer(PyObject *args, PT(GeomParticleRenderer) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_GeomParticleRenderer, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-GeomParticleRenderer::GeomParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode am, PandaNode *geom_node)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      GeomParticleRenderer *return_value = new GeomParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)arg_val);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-GeomParticleRenderer::GeomParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode am, PandaNode *geom_node)
      int param0;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "iO:GeomParticleRenderer", &param0, &param1)) {
        PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PandaNode, 1, "GeomParticleRenderer.GeomParticleRenderer", false, false);
        if (param1_this != NULL) {
          GeomParticleRenderer *return_value = new GeomParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_GeomParticleRenderer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_GeomParticleRenderer) {
    printf("GeomParticleRenderer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  GeomParticleRenderer *local_this = (GeomParticleRenderer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_GeomParticleRenderer) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseParticleRenderer) {
    return (BaseParticleRenderer *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseParticleRenderer *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_GeomParticleRenderer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_GeomParticleRenderer) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseParticleRenderer) {
    BaseParticleRenderer* other_this = (BaseParticleRenderer*)from_this;
    return (GeomParticleRenderer*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeomParticleRenderer*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LineEmitter
 */
/**
 * Python function wrapper for:
 * inline void LineEmitter::set_endpoint1(LPoint3 const &point)
 */
static PyObject *Dtool_LineEmitter_set_endpoint1_160(PyObject *self, PyObject *arg) {
  LineEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LineEmitter, (void **)&local_this, "LineEmitter.set_endpoint1")) {
    return NULL;
  }
  // 1-inline void LineEmitter::set_endpoint1(LPoint3 const &point)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LineEmitter.set_endpoint1", "LPoint3f");
  }
  (*local_this).set_endpoint1(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_endpoint1(const LineEmitter self, const LPoint3f point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LineEmitter_set_endpoint1_160_comment =
  "C++ Interface:\n"
  "set_endpoint1(const LineEmitter self, const LPoint3f point)\n"
  "\n"
  "/**\n"
  " * endpoint assignment\n"
  " */";
#else
static const char *Dtool_LineEmitter_set_endpoint1_160_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LineEmitter::set_endpoint2(LPoint3 const &point)
 */
static PyObject *Dtool_LineEmitter_set_endpoint2_161(PyObject *self, PyObject *arg) {
  LineEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LineEmitter, (void **)&local_this, "LineEmitter.set_endpoint2")) {
    return NULL;
  }
  // 1-inline void LineEmitter::set_endpoint2(LPoint3 const &point)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LineEmitter.set_endpoint2", "LPoint3f");
  }
  (*local_this).set_endpoint2(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_endpoint2(const LineEmitter self, const LPoint3f point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LineEmitter_set_endpoint2_161_comment =
  "C++ Interface:\n"
  "set_endpoint2(const LineEmitter self, const LPoint3f point)\n"
  "\n"
  "/**\n"
  " * endpoint assignment\n"
  " */";
#else
static const char *Dtool_LineEmitter_set_endpoint2_161_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 LineEmitter::get_endpoint1(void) const
 */
static PyObject *Dtool_LineEmitter_get_endpoint1_162(PyObject *self, PyObject *) {
  LineEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LineEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 LineEmitter::get_endpoint1(void) const
  LPoint3 *return_value = new LPoint3((*(const LineEmitter*)local_this).get_endpoint1());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LineEmitter_get_endpoint1_162_comment =
  "C++ Interface:\n"
  "get_endpoint1(LineEmitter self)\n"
  "\n"
  "/**\n"
  " * endpoint accessor\n"
  " */";
#else
static const char *Dtool_LineEmitter_get_endpoint1_162_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 LineEmitter::get_endpoint2(void) const
 */
static PyObject *Dtool_LineEmitter_get_endpoint2_163(PyObject *self, PyObject *) {
  LineEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LineEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 LineEmitter::get_endpoint2(void) const
  LPoint3 *return_value = new LPoint3((*(const LineEmitter*)local_this).get_endpoint2());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LineEmitter_get_endpoint2_163_comment =
  "C++ Interface:\n"
  "get_endpoint2(LineEmitter self)\n"
  "\n"
  "/**\n"
  " * endpoint accessor\n"
  " */";
#else
static const char *Dtool_LineEmitter_get_endpoint2_163_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LineEmitter::LineEmitter(void)
 * LineEmitter::LineEmitter(LineEmitter const &copy)
 */
static int Dtool_Init_LineEmitter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-LineEmitter::LineEmitter(void)
      LineEmitter *return_value = new LineEmitter();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LineEmitter, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-LineEmitter::LineEmitter(LineEmitter const &copy)
      LineEmitter const *arg_this = (LineEmitter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LineEmitter, 0, "LineEmitter.LineEmitter", true, true);
      if (arg_this != NULL) {
        LineEmitter *return_value = new LineEmitter(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LineEmitter, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LineEmitter() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LineEmitter()\n"
      "LineEmitter(const LineEmitter copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LineEmitter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LineEmitter) {
    printf("LineEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LineEmitter *local_this = (LineEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LineEmitter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseParticleEmitter) {
    return (BaseParticleEmitter *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseParticleEmitter *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LineEmitter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LineEmitter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseParticleEmitter) {
    BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
    return (LineEmitter*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LineEmitter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LineParticleRenderer
 */
/**
 * Python function wrapper for:
 * inline void LineParticleRenderer::set_head_color(LColor const &c)
 */
static PyObject *Dtool_LineParticleRenderer_set_head_color_166(PyObject *self, PyObject *arg) {
  LineParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LineParticleRenderer, (void **)&local_this, "LineParticleRenderer.set_head_color")) {
    return NULL;
  }
  // 1-inline void LineParticleRenderer::set_head_color(LColor const &c)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LineParticleRenderer.set_head_color", "LVecBase4f");
  }
  (*local_this).set_head_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_head_color(const LineParticleRenderer self, const LVecBase4f c)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LineParticleRenderer_set_head_color_166_comment =
  "C++ Interface:\n"
  "set_head_color(const LineParticleRenderer self, const LVecBase4f c)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LineParticleRenderer_set_head_color_166_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LineParticleRenderer::set_tail_color(LColor const &c)
 */
static PyObject *Dtool_LineParticleRenderer_set_tail_color_167(PyObject *self, PyObject *arg) {
  LineParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LineParticleRenderer, (void **)&local_this, "LineParticleRenderer.set_tail_color")) {
    return NULL;
  }
  // 1-inline void LineParticleRenderer::set_tail_color(LColor const &c)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LineParticleRenderer.set_tail_color", "LVecBase4f");
  }
  (*local_this).set_tail_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tail_color(const LineParticleRenderer self, const LVecBase4f c)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LineParticleRenderer_set_tail_color_167_comment =
  "C++ Interface:\n"
  "set_tail_color(const LineParticleRenderer self, const LVecBase4f c)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LineParticleRenderer_set_tail_color_167_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &LineParticleRenderer::get_head_color(void) const
 */
static PyObject *Dtool_LineParticleRenderer_get_head_color_168(PyObject *self, PyObject *) {
  LineParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LineParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor const &LineParticleRenderer::get_head_color(void) const
  LColor const *return_value = &((*(const LineParticleRenderer*)local_this).get_head_color());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LineParticleRenderer_get_head_color_168_comment =
  "C++ Interface:\n"
  "get_head_color(LineParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LineParticleRenderer_get_head_color_168_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &LineParticleRenderer::get_tail_color(void) const
 */
static PyObject *Dtool_LineParticleRenderer_get_tail_color_169(PyObject *self, PyObject *) {
  LineParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LineParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor const &LineParticleRenderer::get_tail_color(void) const
  LColor const *return_value = &((*(const LineParticleRenderer*)local_this).get_tail_color());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LineParticleRenderer_get_tail_color_169_comment =
  "C++ Interface:\n"
  "get_tail_color(LineParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LineParticleRenderer_get_tail_color_169_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LineParticleRenderer::set_line_scale_factor(PN_stdfloat sf)
 */
static PyObject *Dtool_LineParticleRenderer_set_line_scale_factor_170(PyObject *self, PyObject *arg) {
  LineParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LineParticleRenderer, (void **)&local_this, "LineParticleRenderer.set_line_scale_factor")) {
    return NULL;
  }
  // 1-inline void LineParticleRenderer::set_line_scale_factor(PN_stdfloat sf)
  if (PyNumber_Check(arg)) {
    (*local_this).set_line_scale_factor((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_line_scale_factor(const LineParticleRenderer self, float sf)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LineParticleRenderer_set_line_scale_factor_170_comment =
  "C++ Interface:\n"
  "set_line_scale_factor(const LineParticleRenderer self, float sf)\n"
  "\n"
  "/**\n"
  " * accessor\n"
  " */";
#else
static const char *Dtool_LineParticleRenderer_set_line_scale_factor_170_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LineParticleRenderer::get_line_scale_factor(void) const
 */
static PyObject *Dtool_LineParticleRenderer_get_line_scale_factor_171(PyObject *self, PyObject *) {
  LineParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LineParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat LineParticleRenderer::get_line_scale_factor(void) const
  PN_stdfloat return_value = (*(const LineParticleRenderer*)local_this).get_line_scale_factor();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LineParticleRenderer_get_line_scale_factor_171_comment =
  "C++ Interface:\n"
  "get_line_scale_factor(LineParticleRenderer self)\n"
  "\n"
  "/**\n"
  " * accessor\n"
  " */";
#else
static const char *Dtool_LineParticleRenderer_get_line_scale_factor_171_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LineParticleRenderer::LineParticleRenderer(void)
 * LineParticleRenderer::LineParticleRenderer(LColor const &head, LColor const &tail, BaseParticleRenderer::ParticleRendererAlphaMode alpha_mode)
 * LineParticleRenderer::LineParticleRenderer(LineParticleRenderer const &copy)
 */
static int Dtool_Init_LineParticleRenderer(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-LineParticleRenderer::LineParticleRenderer(void)
      LineParticleRenderer *return_value = new LineParticleRenderer();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LineParticleRenderer, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-LineParticleRenderer::LineParticleRenderer(LineParticleRenderer const &copy)
      CPT(LineParticleRenderer) arg_this;
      if (!Dtool_ConstCoerce_LineParticleRenderer(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "LineParticleRenderer.LineParticleRenderer", "LineParticleRenderer");
        return -1;
      }
      LineParticleRenderer *return_value = new LineParticleRenderer(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LineParticleRenderer, true, false);
    }
    break;
  case 3:
    {
      // 1-LineParticleRenderer::LineParticleRenderer(LColor const &head, LColor const &tail, BaseParticleRenderer::ParticleRendererAlphaMode alpha_mode)
      PyObject *param0;
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"head", "tail", "alpha_mode", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:LineParticleRenderer", (char **)keyword_list, &param0, &param1, &param2)) {
        LVecBase4f param0_local;
        LColor const *param0_this = Dtool_Coerce_LVecBase4f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LineParticleRenderer.LineParticleRenderer", "LVecBase4f");
          return -1;
        }
        LVecBase4f param1_local;
        LColor const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "LineParticleRenderer.LineParticleRenderer", "LVecBase4f");
          return -1;
        }
        LineParticleRenderer *return_value = new LineParticleRenderer(*param0_this, *param1_this, (BaseParticleRenderer::ParticleRendererAlphaMode)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LineParticleRenderer, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LineParticleRenderer() takes 0, 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LineParticleRenderer()\n"
      "LineParticleRenderer(const LineParticleRenderer copy)\n"
      "LineParticleRenderer(const LVecBase4f head, const LVecBase4f tail, int alpha_mode)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LineParticleRenderer(PyObject *args, CPT(LineParticleRenderer) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LineParticleRenderer, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-LineParticleRenderer::LineParticleRenderer(LColor const &head, LColor const &tail, BaseParticleRenderer::ParticleRendererAlphaMode alpha_mode)
      PyObject *param0;
      PyObject *param1;
      int param2;
      if (PyArg_ParseTuple(args, "OOi:LineParticleRenderer", &param0, &param1, &param2)) {
        LColor const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4f, (void **)&param0_this);
        LColor const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase4f, (void **)&param1_this);
        if (param0_this != NULL && param1_this != NULL) {
          LineParticleRenderer *return_value = new LineParticleRenderer(*param0_this, *param1_this, (BaseParticleRenderer::ParticleRendererAlphaMode)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_LineParticleRenderer(PyObject *args, PT(LineParticleRenderer) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LineParticleRenderer, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-LineParticleRenderer::LineParticleRenderer(LColor const &head, LColor const &tail, BaseParticleRenderer::ParticleRendererAlphaMode alpha_mode)
      PyObject *param0;
      PyObject *param1;
      int param2;
      if (PyArg_ParseTuple(args, "OOi:LineParticleRenderer", &param0, &param1, &param2)) {
        LColor const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4f, (void **)&param0_this);
        LColor const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase4f, (void **)&param1_this);
        if (param0_this != NULL && param1_this != NULL) {
          LineParticleRenderer *return_value = new LineParticleRenderer(*param0_this, *param1_this, (BaseParticleRenderer::ParticleRendererAlphaMode)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LineParticleRenderer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LineParticleRenderer) {
    printf("LineParticleRenderer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LineParticleRenderer *local_this = (LineParticleRenderer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LineParticleRenderer) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseParticleRenderer) {
    return (BaseParticleRenderer *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseParticleRenderer *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LineParticleRenderer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LineParticleRenderer) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseParticleRenderer) {
    BaseParticleRenderer* other_this = (BaseParticleRenderer*)from_this;
    return (LineParticleRenderer*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LineParticleRenderer*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParticleSystem
 */
/**
 * Python function wrapper for:
 * inline void ParticleSystem::set_pool_size(int size)
 */
static PyObject *Dtool_ParticleSystem_set_pool_size_175(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.set_pool_size")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::set_pool_size(int size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_pool_size((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pool_size(const ParticleSystem self, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_set_pool_size_175_comment =
  "C++ Interface:\n"
  "set_pool_size(const ParticleSystem self, int size)\n"
  "\n"
  "// accessqueries\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_set_pool_size_175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::set_birth_rate(PN_stdfloat new_br)
 */
static PyObject *Dtool_ParticleSystem_set_birth_rate_176(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.set_birth_rate")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::set_birth_rate(PN_stdfloat new_br)
  if (PyNumber_Check(arg)) {
    (*local_this).set_birth_rate((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_birth_rate(const ParticleSystem self, float new_br)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_set_birth_rate_176_comment =
  "C++ Interface:\n"
  "set_birth_rate(const ParticleSystem self, float new_br)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_set_birth_rate_176_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::set_soft_birth_rate(PN_stdfloat new_br)
 */
static PyObject *Dtool_ParticleSystem_set_soft_birth_rate_177(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.set_soft_birth_rate")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::set_soft_birth_rate(PN_stdfloat new_br)
  if (PyNumber_Check(arg)) {
    (*local_this).set_soft_birth_rate((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_soft_birth_rate(const ParticleSystem self, float new_br)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_set_soft_birth_rate_177_comment =
  "C++ Interface:\n"
  "set_soft_birth_rate(const ParticleSystem self, float new_br)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_set_soft_birth_rate_177_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::set_litter_size(int new_ls)
 */
static PyObject *Dtool_ParticleSystem_set_litter_size_178(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.set_litter_size")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::set_litter_size(int new_ls)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_litter_size((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_litter_size(const ParticleSystem self, int new_ls)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_set_litter_size_178_comment =
  "C++ Interface:\n"
  "set_litter_size(const ParticleSystem self, int new_ls)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_set_litter_size_178_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::set_litter_spread(int new_ls)
 */
static PyObject *Dtool_ParticleSystem_set_litter_spread_179(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.set_litter_spread")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::set_litter_spread(int new_ls)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_litter_spread((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_litter_spread(const ParticleSystem self, int new_ls)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_set_litter_spread_179_comment =
  "C++ Interface:\n"
  "set_litter_spread(const ParticleSystem self, int new_ls)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_set_litter_spread_179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::set_local_velocity_flag(bool lv)
 */
static PyObject *Dtool_ParticleSystem_set_local_velocity_flag_180(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.set_local_velocity_flag")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::set_local_velocity_flag(bool lv)
  (*local_this).set_local_velocity_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_local_velocity_flag(const ParticleSystem self, bool lv)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_set_local_velocity_flag_180_comment =
  "C++ Interface:\n"
  "set_local_velocity_flag(const ParticleSystem self, bool lv)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_set_local_velocity_flag_180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::set_system_grows_older_flag(bool sgo)
 */
static PyObject *Dtool_ParticleSystem_set_system_grows_older_flag_181(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.set_system_grows_older_flag")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::set_system_grows_older_flag(bool sgo)
  (*local_this).set_system_grows_older_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_system_grows_older_flag(const ParticleSystem self, bool sgo)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_set_system_grows_older_flag_181_comment =
  "C++ Interface:\n"
  "set_system_grows_older_flag(const ParticleSystem self, bool sgo)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_set_system_grows_older_flag_181_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::set_system_lifespan(PN_stdfloat sl)
 */
static PyObject *Dtool_ParticleSystem_set_system_lifespan_182(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.set_system_lifespan")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::set_system_lifespan(PN_stdfloat sl)
  if (PyNumber_Check(arg)) {
    (*local_this).set_system_lifespan((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_system_lifespan(const ParticleSystem self, float sl)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_set_system_lifespan_182_comment =
  "C++ Interface:\n"
  "set_system_lifespan(const ParticleSystem self, float sl)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_set_system_lifespan_182_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::set_system_age(PN_stdfloat age)
 */
static PyObject *Dtool_ParticleSystem_set_system_age_183(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.set_system_age")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::set_system_age(PN_stdfloat age)
  if (PyNumber_Check(arg)) {
    (*local_this).set_system_age((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_system_age(const ParticleSystem self, float age)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_set_system_age_183_comment =
  "C++ Interface:\n"
  "set_system_age(const ParticleSystem self, float age)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_set_system_age_183_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::set_active_system_flag(bool a)
 */
static PyObject *Dtool_ParticleSystem_set_active_system_flag_184(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.set_active_system_flag")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::set_active_system_flag(bool a)
  (*local_this).set_active_system_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_active_system_flag(const ParticleSystem self, bool a)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_set_active_system_flag_184_comment =
  "C++ Interface:\n"
  "set_active_system_flag(const ParticleSystem self, bool a)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_set_active_system_flag_184_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::set_spawn_on_death_flag(bool sod)
 */
static PyObject *Dtool_ParticleSystem_set_spawn_on_death_flag_185(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.set_spawn_on_death_flag")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::set_spawn_on_death_flag(bool sod)
  (*local_this).set_spawn_on_death_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_spawn_on_death_flag(const ParticleSystem self, bool sod)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_set_spawn_on_death_flag_185_comment =
  "C++ Interface:\n"
  "set_spawn_on_death_flag(const ParticleSystem self, bool sod)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_set_spawn_on_death_flag_185_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::set_spawn_render_node(PandaNode *node)
 */
static PyObject *Dtool_ParticleSystem_set_spawn_render_node_186(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.set_spawn_render_node")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::set_spawn_render_node(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "ParticleSystem.set_spawn_render_node", false, true);
  if (arg_this != NULL) {
    (*local_this).set_spawn_render_node(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_spawn_render_node(const ParticleSystem self, PandaNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_set_spawn_render_node_186_comment =
  "C++ Interface:\n"
  "set_spawn_render_node(const ParticleSystem self, PandaNode node)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_set_spawn_render_node_186_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::set_spawn_render_node_path(NodePath const &node)
 */
static PyObject *Dtool_ParticleSystem_set_spawn_render_node_path_187(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.set_spawn_render_node_path")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::set_spawn_render_node_path(NodePath const &node)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "ParticleSystem.set_spawn_render_node_path", true, true);
  if (arg_this != NULL) {
    (*local_this).set_spawn_render_node_path(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_spawn_render_node_path(const ParticleSystem self, const NodePath node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_set_spawn_render_node_path_187_comment =
  "C++ Interface:\n"
  "set_spawn_render_node_path(const ParticleSystem self, const NodePath node)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_set_spawn_render_node_path_187_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::set_template_system_flag(bool tsf)
 */
static PyObject *Dtool_ParticleSystem_set_template_system_flag_188(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.set_template_system_flag")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::set_template_system_flag(bool tsf)
  (*local_this).set_template_system_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_template_system_flag(const ParticleSystem self, bool tsf)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_set_template_system_flag_188_comment =
  "C++ Interface:\n"
  "set_template_system_flag(const ParticleSystem self, bool tsf)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_set_template_system_flag_188_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::set_render_parent(NodePath const &node)
 * inline void ParticleSystem::set_render_parent(PandaNode *node)
 */
static PyObject *Dtool_ParticleSystem_set_render_parent_189(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.set_render_parent")) {
    return NULL;
  }
  {
    // -2 inline void ParticleSystem::set_render_parent(PandaNode *node)
    PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "ParticleSystem.set_render_parent", false, false);
    if (arg_this != NULL) {
      (*local_this).set_render_parent(arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void ParticleSystem::set_render_parent(NodePath const &node)
    NodePath const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_NodePath, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_render_parent(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: inline void ParticleSystem::set_render_parent(PandaNode *node)
  // No coercion possible: inline void ParticleSystem::set_render_parent(NodePath const &node)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_render_parent(const ParticleSystem self, PandaNode node)\n"
      "set_render_parent(const ParticleSystem self, const NodePath node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_set_render_parent_189_comment =
  "C++ Interface:\n"
  "set_render_parent(const ParticleSystem self, PandaNode node)\n"
  "set_render_parent(const ParticleSystem self, const NodePath node)\n"
  "\n"
  "/**\n"
  "\n"
  " */\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_set_render_parent_189_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::set_renderer(BaseParticleRenderer *r)
 */
static PyObject *Dtool_ParticleSystem_set_renderer_190(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.set_renderer")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::set_renderer(BaseParticleRenderer *r)
  BaseParticleRenderer *arg_this = (BaseParticleRenderer *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BaseParticleRenderer, 1, "ParticleSystem.set_renderer", false, true);
  if (arg_this != NULL) {
    (*local_this).set_renderer(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_renderer(const ParticleSystem self, BaseParticleRenderer r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_set_renderer_190_comment =
  "C++ Interface:\n"
  "set_renderer(const ParticleSystem self, BaseParticleRenderer r)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_set_renderer_190_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::set_emitter(BaseParticleEmitter *e)
 */
static PyObject *Dtool_ParticleSystem_set_emitter_191(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.set_emitter")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::set_emitter(BaseParticleEmitter *e)
  BaseParticleEmitter *arg_this = (BaseParticleEmitter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BaseParticleEmitter, 1, "ParticleSystem.set_emitter", false, true);
  if (arg_this != NULL) {
    (*local_this).set_emitter(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_emitter(const ParticleSystem self, BaseParticleEmitter e)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_set_emitter_191_comment =
  "C++ Interface:\n"
  "set_emitter(const ParticleSystem self, BaseParticleEmitter e)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_set_emitter_191_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::set_factory(BaseParticleFactory *f)
 */
static PyObject *Dtool_ParticleSystem_set_factory_192(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.set_factory")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::set_factory(BaseParticleFactory *f)
  BaseParticleFactory *arg_this = (BaseParticleFactory *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BaseParticleFactory, 1, "ParticleSystem.set_factory", false, true);
  if (arg_this != NULL) {
    (*local_this).set_factory(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_factory(const ParticleSystem self, BaseParticleFactory f)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_set_factory_192_comment =
  "C++ Interface:\n"
  "set_factory(const ParticleSystem self, BaseParticleFactory f)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_set_factory_192_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::set_floor_z(PN_stdfloat z)
 */
static PyObject *Dtool_ParticleSystem_set_floor_z_193(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.set_floor_z")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::set_floor_z(PN_stdfloat z)
  if (PyNumber_Check(arg)) {
    (*local_this).set_floor_z((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_floor_z(const ParticleSystem self, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_set_floor_z_193_comment =
  "C++ Interface:\n"
  "set_floor_z(const ParticleSystem self, float z)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_set_floor_z_193_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::clear_floor_z(void)
 */
static PyObject *Dtool_ParticleSystem_clear_floor_z_194(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.clear_floor_z")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::clear_floor_z(void)
  (*local_this).clear_floor_z();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_clear_floor_z_194_comment =
  "C++ Interface:\n"
  "clear_floor_z(const ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_clear_floor_z_194_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ParticleSystem::get_pool_size(void) const
 */
static PyObject *Dtool_ParticleSystem_get_pool_size_195(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ParticleSystem::get_pool_size(void) const
  int return_value = (*(const ParticleSystem*)local_this).get_pool_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_pool_size_195_comment =
  "C++ Interface:\n"
  "get_pool_size(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_pool_size_195_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat ParticleSystem::get_birth_rate(void) const
 */
static PyObject *Dtool_ParticleSystem_get_birth_rate_196(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat ParticleSystem::get_birth_rate(void) const
  PN_stdfloat return_value = (*(const ParticleSystem*)local_this).get_birth_rate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_birth_rate_196_comment =
  "C++ Interface:\n"
  "get_birth_rate(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_birth_rate_196_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat ParticleSystem::get_soft_birth_rate(void) const
 */
static PyObject *Dtool_ParticleSystem_get_soft_birth_rate_197(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat ParticleSystem::get_soft_birth_rate(void) const
  PN_stdfloat return_value = (*(const ParticleSystem*)local_this).get_soft_birth_rate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_soft_birth_rate_197_comment =
  "C++ Interface:\n"
  "get_soft_birth_rate(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_soft_birth_rate_197_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ParticleSystem::get_litter_size(void) const
 */
static PyObject *Dtool_ParticleSystem_get_litter_size_198(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ParticleSystem::get_litter_size(void) const
  int return_value = (*(const ParticleSystem*)local_this).get_litter_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_litter_size_198_comment =
  "C++ Interface:\n"
  "get_litter_size(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_litter_size_198_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ParticleSystem::get_litter_spread(void) const
 */
static PyObject *Dtool_ParticleSystem_get_litter_spread_199(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ParticleSystem::get_litter_spread(void) const
  int return_value = (*(const ParticleSystem*)local_this).get_litter_spread();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_litter_spread_199_comment =
  "C++ Interface:\n"
  "get_litter_spread(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_litter_spread_199_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ParticleSystem::get_local_velocity_flag(void) const
 */
static PyObject *Dtool_ParticleSystem_get_local_velocity_flag_200(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ParticleSystem::get_local_velocity_flag(void) const
  bool return_value = (*(const ParticleSystem*)local_this).get_local_velocity_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_local_velocity_flag_200_comment =
  "C++ Interface:\n"
  "get_local_velocity_flag(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_local_velocity_flag_200_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ParticleSystem::get_system_grows_older_flag(void) const
 */
static PyObject *Dtool_ParticleSystem_get_system_grows_older_flag_201(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ParticleSystem::get_system_grows_older_flag(void) const
  bool return_value = (*(const ParticleSystem*)local_this).get_system_grows_older_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_system_grows_older_flag_201_comment =
  "C++ Interface:\n"
  "get_system_grows_older_flag(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_system_grows_older_flag_201_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat ParticleSystem::get_system_lifespan(void) const
 */
static PyObject *Dtool_ParticleSystem_get_system_lifespan_202(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat ParticleSystem::get_system_lifespan(void) const
  PN_stdfloat return_value = (*(const ParticleSystem*)local_this).get_system_lifespan();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_system_lifespan_202_comment =
  "C++ Interface:\n"
  "get_system_lifespan(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_system_lifespan_202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat ParticleSystem::get_system_age(void) const
 */
static PyObject *Dtool_ParticleSystem_get_system_age_203(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat ParticleSystem::get_system_age(void) const
  PN_stdfloat return_value = (*(const ParticleSystem*)local_this).get_system_age();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_system_age_203_comment =
  "C++ Interface:\n"
  "get_system_age(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_system_age_203_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ParticleSystem::get_active_system_flag(void) const
 */
static PyObject *Dtool_ParticleSystem_get_active_system_flag_204(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ParticleSystem::get_active_system_flag(void) const
  bool return_value = (*(const ParticleSystem*)local_this).get_active_system_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_active_system_flag_204_comment =
  "C++ Interface:\n"
  "get_active_system_flag(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_active_system_flag_204_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ParticleSystem::get_spawn_on_death_flag(void) const
 */
static PyObject *Dtool_ParticleSystem_get_spawn_on_death_flag_205(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ParticleSystem::get_spawn_on_death_flag(void) const
  bool return_value = (*(const ParticleSystem*)local_this).get_spawn_on_death_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_spawn_on_death_flag_205_comment =
  "C++ Interface:\n"
  "get_spawn_on_death_flag(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_spawn_on_death_flag_205_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode *ParticleSystem::get_spawn_render_node(void) const
 */
static PyObject *Dtool_ParticleSystem_get_spawn_render_node_206(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PandaNode *ParticleSystem::get_spawn_render_node(void) const
  PandaNode *return_value = (*(const ParticleSystem*)local_this).get_spawn_render_node();
  if (return_value != (PandaNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PandaNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_spawn_render_node_206_comment =
  "C++ Interface:\n"
  "get_spawn_render_node(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_spawn_render_node_206_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath ParticleSystem::get_spawn_render_node_path(void) const
 */
static PyObject *Dtool_ParticleSystem_get_spawn_render_node_path_207(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath ParticleSystem::get_spawn_render_node_path(void) const
  NodePath *return_value = new NodePath((*(const ParticleSystem*)local_this).get_spawn_render_node_path());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_spawn_render_node_path_207_comment =
  "C++ Interface:\n"
  "get_spawn_render_node_path(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_spawn_render_node_path_207_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ParticleSystem::get_i_was_spawned_flag(void) const
 */
static PyObject *Dtool_ParticleSystem_get_i_was_spawned_flag_208(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ParticleSystem::get_i_was_spawned_flag(void) const
  bool return_value = (*(const ParticleSystem*)local_this).get_i_was_spawned_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_i_was_spawned_flag_208_comment =
  "C++ Interface:\n"
  "get_i_was_spawned_flag(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_i_was_spawned_flag_208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ParticleSystem::get_living_particles(void) const
 */
static PyObject *Dtool_ParticleSystem_get_living_particles_209(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ParticleSystem::get_living_particles(void) const
  int return_value = (*(const ParticleSystem*)local_this).get_living_particles();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_living_particles_209_comment =
  "C++ Interface:\n"
  "get_living_particles(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_living_particles_209_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath ParticleSystem::get_render_parent(void) const
 */
static PyObject *Dtool_ParticleSystem_get_render_parent_210(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath ParticleSystem::get_render_parent(void) const
  NodePath *return_value = new NodePath((*(const ParticleSystem*)local_this).get_render_parent());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_render_parent_210_comment =
  "C++ Interface:\n"
  "get_render_parent(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_render_parent_210_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BaseParticleRenderer *ParticleSystem::get_renderer(void) const
 */
static PyObject *Dtool_ParticleSystem_get_renderer_211(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BaseParticleRenderer *ParticleSystem::get_renderer(void) const
  BaseParticleRenderer *return_value = (*(const ParticleSystem*)local_this).get_renderer();
  if (return_value != (BaseParticleRenderer *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (BaseParticleRenderer *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BaseParticleRenderer, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_renderer_211_comment =
  "C++ Interface:\n"
  "get_renderer(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_renderer_211_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BaseParticleEmitter *ParticleSystem::get_emitter(void) const
 */
static PyObject *Dtool_ParticleSystem_get_emitter_212(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BaseParticleEmitter *ParticleSystem::get_emitter(void) const
  BaseParticleEmitter *return_value = (*(const ParticleSystem*)local_this).get_emitter();
  if (return_value != (BaseParticleEmitter *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (BaseParticleEmitter *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BaseParticleEmitter, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_emitter_212_comment =
  "C++ Interface:\n"
  "get_emitter(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_emitter_212_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BaseParticleFactory *ParticleSystem::get_factory(void) const
 */
static PyObject *Dtool_ParticleSystem_get_factory_213(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BaseParticleFactory *ParticleSystem::get_factory(void) const
  BaseParticleFactory *return_value = (*(const ParticleSystem*)local_this).get_factory();
  if (return_value != (BaseParticleFactory *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (BaseParticleFactory *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BaseParticleFactory, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_factory_213_comment =
  "C++ Interface:\n"
  "get_factory(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_factory_213_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat ParticleSystem::get_floor_z(void) const
 */
static PyObject *Dtool_ParticleSystem_get_floor_z_214(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat ParticleSystem::get_floor_z(void) const
  PN_stdfloat return_value = (*(const ParticleSystem*)local_this).get_floor_z();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_floor_z_214_comment =
  "C++ Interface:\n"
  "get_floor_z(ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_get_floor_z_214_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::add_spawn_template(ParticleSystem *ps)
 */
static PyObject *Dtool_ParticleSystem_add_spawn_template_215(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.add_spawn_template")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::add_spawn_template(ParticleSystem *ps)
  PT(ParticleSystem) arg_this;
  if (!Dtool_Coerce_ParticleSystem(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParticleSystem.add_spawn_template", "ParticleSystem");
  }
  (*local_this).add_spawn_template(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_spawn_template(const ParticleSystem self, ParticleSystem ps)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_add_spawn_template_215_comment =
  "C++ Interface:\n"
  "add_spawn_template(const ParticleSystem self, ParticleSystem ps)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_add_spawn_template_215_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::clear_spawn_templates(void)
 */
static PyObject *Dtool_ParticleSystem_clear_spawn_templates_216(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.clear_spawn_templates")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::clear_spawn_templates(void)
  (*local_this).clear_spawn_templates();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_clear_spawn_templates_216_comment =
  "C++ Interface:\n"
  "clear_spawn_templates(const ParticleSystem self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ParticleSystem_clear_spawn_templates_216_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::render(void)
 */
static PyObject *Dtool_ParticleSystem_render_217(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.render")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::render(void)
  (*local_this).render();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_render_217_comment =
  "C++ Interface:\n"
  "render(const ParticleSystem self)\n"
  "\n"
  "/**\n"
  " * Populates an attached GeomNode structure with the particle geometry for\n"
  " * rendering.  This is a wrapper for accessability.\n"
  " */";
#else
static const char *Dtool_ParticleSystem_render_217_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::induce_labor(void)
 */
static PyObject *Dtool_ParticleSystem_induce_labor_218(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.induce_labor")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::induce_labor(void)
  (*local_this).induce_labor();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_induce_labor_218_comment =
  "C++ Interface:\n"
  "induce_labor(const ParticleSystem self)\n"
  "\n"
  "/**\n"
  " * Forces the birth of a particle litter this frame by resetting\n"
  " * _tics_since_birth\n"
  " */";
#else
static const char *Dtool_ParticleSystem_induce_labor_218_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::clear_to_initial(void)
 */
static PyObject *Dtool_ParticleSystem_clear_to_initial_219(PyObject *self, PyObject *) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.clear_to_initial")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::clear_to_initial(void)
  (*local_this).clear_to_initial();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_clear_to_initial_219_comment =
  "C++ Interface:\n"
  "clear_to_initial(const ParticleSystem self)\n"
  "\n"
  "/**\n"
  " * Resets the system to its start state by resizing to 0, then resizing back\n"
  " * to current size.\n"
  " */";
#else
static const char *Dtool_ParticleSystem_clear_to_initial_219_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::soft_stop(PN_stdfloat br = 0.0)
 */
static PyObject *Dtool_ParticleSystem_soft_stop_220(PyObject *self, PyObject *args, PyObject *kwds) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.soft_stop")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::soft_stop(PN_stdfloat br = 0.0)
  float param1 = 0.0;
  static const char *keyword_list[] = {"br", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|f:soft_stop", (char **)keyword_list, &param1)) {
    (*local_this).soft_stop((PN_stdfloat)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "soft_stop(const ParticleSystem self, float br)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_soft_stop_220_comment =
  "C++ Interface:\n"
  "soft_stop(const ParticleSystem self, float br)\n"
  "\n"
  "/**\n"
  " * Causes system to use birth rate set by set_soft_birth_rate()\n"
  " */";
#else
static const char *Dtool_ParticleSystem_soft_stop_220_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystem::soft_start(PN_stdfloat br = 0.0)
 */
static PyObject *Dtool_ParticleSystem_soft_start_221(PyObject *self, PyObject *args, PyObject *kwds) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.soft_start")) {
    return NULL;
  }
  // 1-inline void ParticleSystem::soft_start(PN_stdfloat br = 0.0)
  float param1 = 0.0;
  static const char *keyword_list[] = {"br", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|f:soft_start", (char **)keyword_list, &param1)) {
    (*local_this).soft_start((PN_stdfloat)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "soft_start(const ParticleSystem self, float br)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_soft_start_221_comment =
  "C++ Interface:\n"
  "soft_start(const ParticleSystem self, float br)\n"
  "\n"
  "/**\n"
  " * Causes system to use birth rate set by set_birth_rate()\n"
  " */";
#else
static const char *Dtool_ParticleSystem_soft_start_221_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ParticleSystem::update(PN_stdfloat dt)
 */
static PyObject *Dtool_ParticleSystem_update_222(PyObject *self, PyObject *arg) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystem, (void **)&local_this, "ParticleSystem.update")) {
    return NULL;
  }
  // 1-void ParticleSystem::update(PN_stdfloat dt)
  if (PyNumber_Check(arg)) {
    (*local_this).update((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "update(const ParticleSystem self, float dt)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_update_222_comment =
  "C++ Interface:\n"
  "update(const ParticleSystem self, float dt)\n";
#else
static const char *Dtool_ParticleSystem_update_222_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void ParticleSystem::write_free_particle_fifo(ostream &out, int indent = 0) const
 */
static PyObject *Dtool_ParticleSystem_write_free_particle_fifo_223(PyObject *self, PyObject *args, PyObject *kwds) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void ParticleSystem::write_free_particle_fifo(ostream &out, int indent = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write_free_particle_fifo", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "ParticleSystem.write_free_particle_fifo", false, true);
    if (param1_this != NULL) {
      (*(const ParticleSystem*)local_this).write_free_particle_fifo(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_free_particle_fifo(ParticleSystem self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_write_free_particle_fifo_223_comment =
  "C++ Interface:\n"
  "write_free_particle_fifo(ParticleSystem self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_ParticleSystem_write_free_particle_fifo_223_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void ParticleSystem::write_spawn_templates(ostream &out, int indent = 0) const
 */
static PyObject *Dtool_ParticleSystem_write_spawn_templates_224(PyObject *self, PyObject *args, PyObject *kwds) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void ParticleSystem::write_spawn_templates(ostream &out, int indent = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write_spawn_templates", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "ParticleSystem.write_spawn_templates", false, true);
    if (param1_this != NULL) {
      (*(const ParticleSystem*)local_this).write_spawn_templates(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_spawn_templates(ParticleSystem self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_write_spawn_templates_224_comment =
  "C++ Interface:\n"
  "write_spawn_templates(ParticleSystem self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_ParticleSystem_write_spawn_templates_224_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void ParticleSystem::write(ostream &out, int indent = 0) const
 */
static PyObject *Dtool_ParticleSystem_write_225(PyObject *self, PyObject *args, PyObject *kwds) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void ParticleSystem::write(ostream &out, int indent = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "ParticleSystem.write", false, true);
    if (param1_this != NULL) {
      (*(const ParticleSystem*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ParticleSystem self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_write_225_comment =
  "C++ Interface:\n"
  "write(ParticleSystem self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_ParticleSystem_write_225_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParticleSystem::get_class_type(void)
 */
static PyObject *Dtool_ParticleSystem_get_class_type_226(PyObject *, PyObject *) {
  // 1-static TypeHandle ParticleSystem::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ParticleSystem::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystem_get_class_type_226_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParticleSystem_get_class_type_226_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ParticleSystem::ParticleSystem(ParticleSystem const &copy)
 * ParticleSystem::ParticleSystem(int pool_size = 0)
 */
static int Dtool_Init_ParticleSystem(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-ParticleSystem::ParticleSystem(int pool_size)
      ParticleSystem *return_value = new ParticleSystem();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParticleSystem, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 ParticleSystem::ParticleSystem(ParticleSystem const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ParticleSystem", (char **)keyword_list, &param0)) {
          ParticleSystem const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ParticleSystem, (void **)&param0_this);
          if (param0_this != NULL) {
            ParticleSystem *return_value = new ParticleSystem(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParticleSystem, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 ParticleSystem::ParticleSystem(int pool_size)
        int param0;
        static const char *keyword_list[] = {"pool_size", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:ParticleSystem", (char **)keyword_list, &param0)) {
          ParticleSystem *return_value = new ParticleSystem((int)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParticleSystem, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 ParticleSystem::ParticleSystem(ParticleSystem const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ParticleSystem", (char **)keyword_list, &param0)) {
          CPT(ParticleSystem) param0_this;
          if (Dtool_ConstCoerce_ParticleSystem(param0, param0_this)) {
            ParticleSystem *return_value = new ParticleSystem(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParticleSystem, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: ParticleSystem::ParticleSystem(int pool_size)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ParticleSystem() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParticleSystem()\n"
      "ParticleSystem(const ParticleSystem copy)\n"
      "ParticleSystem(int pool_size)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParticleSystem(PyObject *args, CPT(ParticleSystem) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParticleSystem, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ParticleSystem::ParticleSystem(int pool_size)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      ParticleSystem *return_value = new ParticleSystem((int)arg_val);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParticleSystem(PyObject *args, PT(ParticleSystem) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParticleSystem, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ParticleSystem::ParticleSystem(int pool_size)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      ParticleSystem *return_value = new ParticleSystem((int)arg_val);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParticleSystem(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParticleSystem) {
    printf("ParticleSystem ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParticleSystem *local_this = (ParticleSystem *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParticleSystem) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Physical) {
    return (Physical *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(Physical *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(Physical *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(Physical *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParticleSystem(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParticleSystem) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Physical) {
    Physical* other_this = (Physical*)from_this;
    return (ParticleSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParticleSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParticleSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (ParticleSystem*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointEmitter
 */
/**
 * Python function wrapper for:
 * inline void PointEmitter::set_location(LPoint3 const &p)
 */
static PyObject *Dtool_PointEmitter_set_location_229(PyObject *self, PyObject *arg) {
  PointEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointEmitter, (void **)&local_this, "PointEmitter.set_location")) {
    return NULL;
  }
  // 1-inline void PointEmitter::set_location(LPoint3 const &p)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointEmitter.set_location", "LPoint3f");
  }
  (*local_this).set_location(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_location(const PointEmitter self, const LPoint3f p)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointEmitter_set_location_229_comment =
  "C++ Interface:\n"
  "set_location(const PointEmitter self, const LPoint3f p)\n"
  "\n"
  "/**\n"
  " * point setting\n"
  " */";
#else
static const char *Dtool_PointEmitter_set_location_229_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 PointEmitter::get_location(void) const
 */
static PyObject *Dtool_PointEmitter_get_location_230(PyObject *self, PyObject *) {
  PointEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 PointEmitter::get_location(void) const
  LPoint3 *return_value = new LPoint3((*(const PointEmitter*)local_this).get_location());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PointEmitter_get_location_230_comment =
  "C++ Interface:\n"
  "get_location(PointEmitter self)\n";
#else
static const char *Dtool_PointEmitter_get_location_230_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointEmitter::PointEmitter(void)
 * PointEmitter::PointEmitter(PointEmitter const &copy)
 */
static int Dtool_Init_PointEmitter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PointEmitter::PointEmitter(void)
      PointEmitter *return_value = new PointEmitter();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointEmitter, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-PointEmitter::PointEmitter(PointEmitter const &copy)
      PointEmitter const *arg_this = (PointEmitter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PointEmitter, 0, "PointEmitter.PointEmitter", true, true);
      if (arg_this != NULL) {
        PointEmitter *return_value = new PointEmitter(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointEmitter, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointEmitter() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointEmitter()\n"
      "PointEmitter(const PointEmitter copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PointEmitter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointEmitter) {
    printf("PointEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointEmitter *local_this = (PointEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointEmitter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseParticleEmitter) {
    return (BaseParticleEmitter *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseParticleEmitter *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointEmitter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointEmitter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseParticleEmitter) {
    BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
    return (PointEmitter*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PointEmitter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointParticleFactory
 */
/**
 * Python function wrapper for:
 * PointParticleFactory::PointParticleFactory(void)
 * PointParticleFactory::PointParticleFactory(PointParticleFactory const &copy)
 */
static int Dtool_Init_PointParticleFactory(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PointParticleFactory::PointParticleFactory(void)
      PointParticleFactory *return_value = new PointParticleFactory();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointParticleFactory, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-PointParticleFactory::PointParticleFactory(PointParticleFactory const &copy)
      PointParticleFactory const *arg_this = (PointParticleFactory *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PointParticleFactory, 0, "PointParticleFactory.PointParticleFactory", true, true);
      if (arg_this != NULL) {
        PointParticleFactory *return_value = new PointParticleFactory(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointParticleFactory, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointParticleFactory() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointParticleFactory()\n"
      "PointParticleFactory(const PointParticleFactory copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PointParticleFactory(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointParticleFactory) {
    printf("PointParticleFactory ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointParticleFactory *local_this = (PointParticleFactory *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointParticleFactory) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseParticleFactory) {
    return (BaseParticleFactory *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseParticleFactory *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointParticleFactory(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointParticleFactory) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseParticleFactory) {
    BaseParticleFactory* other_this = (BaseParticleFactory*)from_this;
    return (PointParticleFactory*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PointParticleFactory*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointParticleRenderer
 */
/**
 * Python function wrapper for:
 * inline void PointParticleRenderer::set_point_size(PN_stdfloat point_size)
 */
static PyObject *Dtool_PointParticleRenderer_set_point_size_236(PyObject *self, PyObject *arg) {
  PointParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointParticleRenderer, (void **)&local_this, "PointParticleRenderer.set_point_size")) {
    return NULL;
  }
  // 1-inline void PointParticleRenderer::set_point_size(PN_stdfloat point_size)
  if (PyNumber_Check(arg)) {
    (*local_this).set_point_size((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point_size(const PointParticleRenderer self, float point_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointParticleRenderer_set_point_size_236_comment =
  "C++ Interface:\n"
  "set_point_size(const PointParticleRenderer self, float point_size)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_PointParticleRenderer_set_point_size_236_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointParticleRenderer::set_start_color(LColor const &sc)
 */
static PyObject *Dtool_PointParticleRenderer_set_start_color_237(PyObject *self, PyObject *arg) {
  PointParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointParticleRenderer, (void **)&local_this, "PointParticleRenderer.set_start_color")) {
    return NULL;
  }
  // 1-inline void PointParticleRenderer::set_start_color(LColor const &sc)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointParticleRenderer.set_start_color", "LVecBase4f");
  }
  (*local_this).set_start_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_color(const PointParticleRenderer self, const LVecBase4f sc)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointParticleRenderer_set_start_color_237_comment =
  "C++ Interface:\n"
  "set_start_color(const PointParticleRenderer self, const LVecBase4f sc)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_PointParticleRenderer_set_start_color_237_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointParticleRenderer::set_end_color(LColor const &ec)
 */
static PyObject *Dtool_PointParticleRenderer_set_end_color_238(PyObject *self, PyObject *arg) {
  PointParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointParticleRenderer, (void **)&local_this, "PointParticleRenderer.set_end_color")) {
    return NULL;
  }
  // 1-inline void PointParticleRenderer::set_end_color(LColor const &ec)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointParticleRenderer.set_end_color", "LVecBase4f");
  }
  (*local_this).set_end_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_color(const PointParticleRenderer self, const LVecBase4f ec)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointParticleRenderer_set_end_color_238_comment =
  "C++ Interface:\n"
  "set_end_color(const PointParticleRenderer self, const LVecBase4f ec)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_PointParticleRenderer_set_end_color_238_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointParticleRenderer::set_blend_type(PointParticleRenderer::PointParticleBlendType bt)
 */
static PyObject *Dtool_PointParticleRenderer_set_blend_type_239(PyObject *self, PyObject *arg) {
  PointParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointParticleRenderer, (void **)&local_this, "PointParticleRenderer.set_blend_type")) {
    return NULL;
  }
  // 1-inline void PointParticleRenderer::set_blend_type(PointParticleRenderer::PointParticleBlendType bt)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_blend_type((PointParticleRenderer::PointParticleBlendType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blend_type(const PointParticleRenderer self, int bt)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointParticleRenderer_set_blend_type_239_comment =
  "C++ Interface:\n"
  "set_blend_type(const PointParticleRenderer self, int bt)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_PointParticleRenderer_set_blend_type_239_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointParticleRenderer::set_blend_method(BaseParticleRenderer::ParticleRendererBlendMethod bm)
 */
static PyObject *Dtool_PointParticleRenderer_set_blend_method_240(PyObject *self, PyObject *arg) {
  PointParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointParticleRenderer, (void **)&local_this, "PointParticleRenderer.set_blend_method")) {
    return NULL;
  }
  // 1-inline void PointParticleRenderer::set_blend_method(BaseParticleRenderer::ParticleRendererBlendMethod bm)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_blend_method((BaseParticleRenderer::ParticleRendererBlendMethod)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blend_method(const PointParticleRenderer self, int bm)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointParticleRenderer_set_blend_method_240_comment =
  "C++ Interface:\n"
  "set_blend_method(const PointParticleRenderer self, int bm)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_PointParticleRenderer_set_blend_method_240_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PointParticleRenderer::get_point_size(void) const
 */
static PyObject *Dtool_PointParticleRenderer_get_point_size_241(PyObject *self, PyObject *) {
  PointParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat PointParticleRenderer::get_point_size(void) const
  PN_stdfloat return_value = (*(const PointParticleRenderer*)local_this).get_point_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointParticleRenderer_get_point_size_241_comment =
  "C++ Interface:\n"
  "get_point_size(PointParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_PointParticleRenderer_get_point_size_241_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &PointParticleRenderer::get_start_color(void) const
 */
static PyObject *Dtool_PointParticleRenderer_get_start_color_242(PyObject *self, PyObject *) {
  PointParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor const &PointParticleRenderer::get_start_color(void) const
  LColor const *return_value = &((*(const PointParticleRenderer*)local_this).get_start_color());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PointParticleRenderer_get_start_color_242_comment =
  "C++ Interface:\n"
  "get_start_color(PointParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_PointParticleRenderer_get_start_color_242_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &PointParticleRenderer::get_end_color(void) const
 */
static PyObject *Dtool_PointParticleRenderer_get_end_color_243(PyObject *self, PyObject *) {
  PointParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor const &PointParticleRenderer::get_end_color(void) const
  LColor const *return_value = &((*(const PointParticleRenderer*)local_this).get_end_color());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PointParticleRenderer_get_end_color_243_comment =
  "C++ Interface:\n"
  "get_end_color(PointParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_PointParticleRenderer_get_end_color_243_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointParticleRenderer::PointParticleBlendType PointParticleRenderer::get_blend_type(void) const
 */
static PyObject *Dtool_PointParticleRenderer_get_blend_type_244(PyObject *self, PyObject *) {
  PointParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PointParticleRenderer::PointParticleBlendType PointParticleRenderer::get_blend_type(void) const
  PointParticleRenderer::PointParticleBlendType return_value = (*(const PointParticleRenderer*)local_this).get_blend_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointParticleRenderer_get_blend_type_244_comment =
  "C++ Interface:\n"
  "get_blend_type(PointParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_PointParticleRenderer_get_blend_type_244_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BaseParticleRenderer::ParticleRendererBlendMethod PointParticleRenderer::get_blend_method(void) const
 */
static PyObject *Dtool_PointParticleRenderer_get_blend_method_245(PyObject *self, PyObject *) {
  PointParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BaseParticleRenderer::ParticleRendererBlendMethod PointParticleRenderer::get_blend_method(void) const
  BaseParticleRenderer::ParticleRendererBlendMethod return_value = (*(const PointParticleRenderer*)local_this).get_blend_method();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointParticleRenderer_get_blend_method_245_comment =
  "C++ Interface:\n"
  "get_blend_method(PointParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_PointParticleRenderer_get_blend_method_245_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad = ::BaseParticleRenderer::PR_ALPHA_NONE, PN_stdfloat point_size = 1.0, PointParticleRenderer::PointParticleBlendType bt = ::PointParticleRenderer::PP_ONE_COLOR, BaseParticleRenderer::ParticleRendererBlendMethod bm = ::BaseParticleRenderer::PP_NO_BLEND, LColor const &sc = LColor(1.0, 1.0, 1.0, 1.0), LColor const &ec = LColor(1.0, 1.0, 1.0, 1.0))
 * PointParticleRenderer::PointParticleRenderer(PointParticleRenderer const &copy)
 */
static int Dtool_Init_PointParticleRenderer(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
      PointParticleRenderer *return_value = new PointParticleRenderer();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointParticleRenderer, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
        int param0;
        static const char *keyword_list[] = {"ad", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:PointParticleRenderer", (char **)keyword_list, &param0)) {
          PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointParticleRenderer, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 PointParticleRenderer::PointParticleRenderer(PointParticleRenderer const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointParticleRenderer", (char **)keyword_list, &param0)) {
          PointParticleRenderer const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointParticleRenderer, (void **)&param0_this);
          if (param0_this != NULL) {
            PointParticleRenderer *return_value = new PointParticleRenderer(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointParticleRenderer, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
        int param0;
        static const char *keyword_list[] = {"ad", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:PointParticleRenderer", (char **)keyword_list, &param0)) {
          PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointParticleRenderer, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 PointParticleRenderer::PointParticleRenderer(PointParticleRenderer const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointParticleRenderer", (char **)keyword_list, &param0)) {
          CPT(PointParticleRenderer) param0_this;
          if (Dtool_ConstCoerce_PointParticleRenderer(param0, param0_this)) {
            PointParticleRenderer *return_value = new PointParticleRenderer(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointParticleRenderer, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
      int param0;
      float param1;
      static const char *keyword_list[] = {"ad", "point_size", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "if:PointParticleRenderer", (char **)keyword_list, &param0, &param1)) {
        PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (PN_stdfloat)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointParticleRenderer, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
      int param0;
      float param1;
      int param2;
      static const char *keyword_list[] = {"ad", "point_size", "bt", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ifi:PointParticleRenderer", (char **)keyword_list, &param0, &param1, &param2)) {
        PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (PN_stdfloat)param1, (PointParticleRenderer::PointParticleBlendType)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointParticleRenderer, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
      int param0;
      float param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"ad", "point_size", "bt", "bm", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ifii:PointParticleRenderer", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (PN_stdfloat)param1, (PointParticleRenderer::PointParticleBlendType)param2, (BaseParticleRenderer::ParticleRendererBlendMethod)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointParticleRenderer, true, false);
      }
    }
    break;
  case 5:
    {
      // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
      int param0;
      float param1;
      int param2;
      int param3;
      PyObject *param4;
      static const char *keyword_list[] = {"ad", "point_size", "bt", "bm", "sc", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ifiiO:PointParticleRenderer", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
        LVecBase4f param4_local;
        LColor const *param4_this = Dtool_Coerce_LVecBase4f(param4, param4_local);
        if (!(param4_this != NULL)) {
          Dtool_Raise_ArgTypeError(param4, 4, "PointParticleRenderer.PointParticleRenderer", "LVecBase4f");
          return -1;
        }
        PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (PN_stdfloat)param1, (PointParticleRenderer::PointParticleBlendType)param2, (BaseParticleRenderer::ParticleRendererBlendMethod)param3, *param4_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointParticleRenderer, true, false);
      }
    }
    break;
  case 6:
    {
      // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
      int param0;
      float param1;
      int param2;
      int param3;
      PyObject *param4;
      PyObject *param5;
      static const char *keyword_list[] = {"ad", "point_size", "bt", "bm", "sc", "ec", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ifiiOO:PointParticleRenderer", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
        LVecBase4f param4_local;
        LColor const *param4_this = Dtool_Coerce_LVecBase4f(param4, param4_local);
        if (!(param4_this != NULL)) {
          Dtool_Raise_ArgTypeError(param4, 4, "PointParticleRenderer.PointParticleRenderer", "LVecBase4f");
          return -1;
        }
        LVecBase4f param5_local;
        LColor const *param5_this = Dtool_Coerce_LVecBase4f(param5, param5_local);
        if (!(param5_this != NULL)) {
          Dtool_Raise_ArgTypeError(param5, 5, "PointParticleRenderer.PointParticleRenderer", "LVecBase4f");
          return -1;
        }
        PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (PN_stdfloat)param1, (PointParticleRenderer::PointParticleBlendType)param2, (BaseParticleRenderer::ParticleRendererBlendMethod)param3, *param4_this, *param5_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointParticleRenderer, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointParticleRenderer() takes 0, 1, 2, 3, 4, 5 or 6 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointParticleRenderer()\n"
      "PointParticleRenderer(int ad)\n"
      "PointParticleRenderer(const PointParticleRenderer copy)\n"
      "PointParticleRenderer(int ad, float point_size)\n"
      "PointParticleRenderer(int ad, float point_size, int bt)\n"
      "PointParticleRenderer(int ad, float point_size, int bt, int bm)\n"
      "PointParticleRenderer(int ad, float point_size, int bt, int bm, const LVecBase4f sc)\n"
      "PointParticleRenderer(int ad, float point_size, int bt, int bm, const LVecBase4f sc, const LVecBase4f ec)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PointParticleRenderer(PyObject *args, CPT(PointParticleRenderer) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointParticleRenderer, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)arg_val);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
        int param0;
        float param1;
        if (PyArg_ParseTuple(args, "if:PointParticleRenderer", &param0, &param1)) {
          PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (PN_stdfloat)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
        int param0;
        float param1;
        int param2;
        if (PyArg_ParseTuple(args, "ifi:PointParticleRenderer", &param0, &param1, &param2)) {
          PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (PN_stdfloat)param1, (PointParticleRenderer::PointParticleBlendType)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
        int param0;
        float param1;
        int param2;
        int param3;
        if (PyArg_ParseTuple(args, "ifii:PointParticleRenderer", &param0, &param1, &param2, &param3)) {
          PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (PN_stdfloat)param1, (PointParticleRenderer::PointParticleBlendType)param2, (BaseParticleRenderer::ParticleRendererBlendMethod)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 5: {
        // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
        int param0;
        float param1;
        int param2;
        int param3;
        PyObject *param4;
        if (PyArg_ParseTuple(args, "ifiiO:PointParticleRenderer", &param0, &param1, &param2, &param3, &param4)) {
          LColor const *param4_this;
          DTOOL_Call_ExtractThisPointerForType(param4, Dtool_Ptr_LVecBase4f, (void **)&param4_this);
          if (param4_this != NULL) {
            PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (PN_stdfloat)param1, (PointParticleRenderer::PointParticleBlendType)param2, (BaseParticleRenderer::ParticleRendererBlendMethod)param3, *param4_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 6: {
        // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
        int param0;
        float param1;
        int param2;
        int param3;
        PyObject *param4;
        PyObject *param5;
        if (PyArg_ParseTuple(args, "ifiiOO:PointParticleRenderer", &param0, &param1, &param2, &param3, &param4, &param5)) {
          LColor const *param4_this;
          DTOOL_Call_ExtractThisPointerForType(param4, Dtool_Ptr_LVecBase4f, (void **)&param4_this);
          LColor const *param5_this;
          DTOOL_Call_ExtractThisPointerForType(param5, Dtool_Ptr_LVecBase4f, (void **)&param5_this);
          if (param4_this != NULL && param5_this != NULL) {
            PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (PN_stdfloat)param1, (PointParticleRenderer::PointParticleBlendType)param2, (BaseParticleRenderer::ParticleRendererBlendMethod)param3, *param4_this, *param5_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_PointParticleRenderer(PyObject *args, PT(PointParticleRenderer) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointParticleRenderer, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)arg_val);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
        int param0;
        float param1;
        if (PyArg_ParseTuple(args, "if:PointParticleRenderer", &param0, &param1)) {
          PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (PN_stdfloat)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
        int param0;
        float param1;
        int param2;
        if (PyArg_ParseTuple(args, "ifi:PointParticleRenderer", &param0, &param1, &param2)) {
          PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (PN_stdfloat)param1, (PointParticleRenderer::PointParticleBlendType)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
        int param0;
        float param1;
        int param2;
        int param3;
        if (PyArg_ParseTuple(args, "ifii:PointParticleRenderer", &param0, &param1, &param2, &param3)) {
          PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (PN_stdfloat)param1, (PointParticleRenderer::PointParticleBlendType)param2, (BaseParticleRenderer::ParticleRendererBlendMethod)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 5: {
        // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
        int param0;
        float param1;
        int param2;
        int param3;
        PyObject *param4;
        if (PyArg_ParseTuple(args, "ifiiO:PointParticleRenderer", &param0, &param1, &param2, &param3, &param4)) {
          LColor const *param4_this;
          DTOOL_Call_ExtractThisPointerForType(param4, Dtool_Ptr_LVecBase4f, (void **)&param4_this);
          if (param4_this != NULL) {
            PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (PN_stdfloat)param1, (PointParticleRenderer::PointParticleBlendType)param2, (BaseParticleRenderer::ParticleRendererBlendMethod)param3, *param4_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 6: {
        // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, PN_stdfloat point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LColor const &sc, LColor const &ec)
        int param0;
        float param1;
        int param2;
        int param3;
        PyObject *param4;
        PyObject *param5;
        if (PyArg_ParseTuple(args, "ifiiOO:PointParticleRenderer", &param0, &param1, &param2, &param3, &param4, &param5)) {
          LColor const *param4_this;
          DTOOL_Call_ExtractThisPointerForType(param4, Dtool_Ptr_LVecBase4f, (void **)&param4_this);
          LColor const *param5_this;
          DTOOL_Call_ExtractThisPointerForType(param5, Dtool_Ptr_LVecBase4f, (void **)&param5_this);
          if (param4_this != NULL && param5_this != NULL) {
            PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (PN_stdfloat)param1, (PointParticleRenderer::PointParticleBlendType)param2, (BaseParticleRenderer::ParticleRendererBlendMethod)param3, *param4_this, *param5_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_PointParticleRenderer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointParticleRenderer) {
    printf("PointParticleRenderer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointParticleRenderer *local_this = (PointParticleRenderer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointParticleRenderer) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseParticleRenderer) {
    return (BaseParticleRenderer *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseParticleRenderer *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointParticleRenderer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointParticleRenderer) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseParticleRenderer) {
    BaseParticleRenderer* other_this = (BaseParticleRenderer*)from_this;
    return (PointParticleRenderer*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PointParticleRenderer*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class RectangleEmitter
 */
/**
 * Python function wrapper for:
 * inline void RectangleEmitter::set_min_bound(LPoint2 const &vmin)
 */
static PyObject *Dtool_RectangleEmitter_set_min_bound_248(PyObject *self, PyObject *arg) {
  RectangleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RectangleEmitter, (void **)&local_this, "RectangleEmitter.set_min_bound")) {
    return NULL;
  }
  // 1-inline void RectangleEmitter::set_min_bound(LPoint2 const &vmin)
  LPoint2f arg_local;
  LPoint2 const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "RectangleEmitter.set_min_bound", "LPoint2f");
  }
  (*local_this).set_min_bound(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_min_bound(const RectangleEmitter self, const LPoint2f vmin)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RectangleEmitter_set_min_bound_248_comment =
  "C++ Interface:\n"
  "set_min_bound(const RectangleEmitter self, const LPoint2f vmin)\n"
  "\n"
  "/**\n"
  " * boundary set\n"
  " */";
#else
static const char *Dtool_RectangleEmitter_set_min_bound_248_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RectangleEmitter::set_max_bound(LPoint2 const &vmax)
 */
static PyObject *Dtool_RectangleEmitter_set_max_bound_249(PyObject *self, PyObject *arg) {
  RectangleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RectangleEmitter, (void **)&local_this, "RectangleEmitter.set_max_bound")) {
    return NULL;
  }
  // 1-inline void RectangleEmitter::set_max_bound(LPoint2 const &vmax)
  LPoint2f arg_local;
  LPoint2 const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "RectangleEmitter.set_max_bound", "LPoint2f");
  }
  (*local_this).set_max_bound(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_bound(const RectangleEmitter self, const LPoint2f vmax)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RectangleEmitter_set_max_bound_249_comment =
  "C++ Interface:\n"
  "set_max_bound(const RectangleEmitter self, const LPoint2f vmax)\n"
  "\n"
  "/**\n"
  " * boundary set\n"
  " */";
#else
static const char *Dtool_RectangleEmitter_set_max_bound_249_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2 RectangleEmitter::get_min_bound(void) const
 */
static PyObject *Dtool_RectangleEmitter_get_min_bound_250(PyObject *self, PyObject *) {
  RectangleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RectangleEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2 RectangleEmitter::get_min_bound(void) const
  LPoint2 *return_value = new LPoint2((*(const RectangleEmitter*)local_this).get_min_bound());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RectangleEmitter_get_min_bound_250_comment =
  "C++ Interface:\n"
  "get_min_bound(RectangleEmitter self)\n"
  "\n"
  "/**\n"
  " * boundary get\n"
  " */";
#else
static const char *Dtool_RectangleEmitter_get_min_bound_250_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2 RectangleEmitter::get_max_bound(void) const
 */
static PyObject *Dtool_RectangleEmitter_get_max_bound_251(PyObject *self, PyObject *) {
  RectangleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RectangleEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2 RectangleEmitter::get_max_bound(void) const
  LPoint2 *return_value = new LPoint2((*(const RectangleEmitter*)local_this).get_max_bound());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RectangleEmitter_get_max_bound_251_comment =
  "C++ Interface:\n"
  "get_max_bound(RectangleEmitter self)\n"
  "\n"
  "/**\n"
  " * boundary get\n"
  " */";
#else
static const char *Dtool_RectangleEmitter_get_max_bound_251_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * RectangleEmitter::RectangleEmitter(void)
 * RectangleEmitter::RectangleEmitter(RectangleEmitter const &copy)
 */
static int Dtool_Init_RectangleEmitter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-RectangleEmitter::RectangleEmitter(void)
      RectangleEmitter *return_value = new RectangleEmitter();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RectangleEmitter, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-RectangleEmitter::RectangleEmitter(RectangleEmitter const &copy)
      RectangleEmitter const *arg_this = (RectangleEmitter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RectangleEmitter, 0, "RectangleEmitter.RectangleEmitter", true, true);
      if (arg_this != NULL) {
        RectangleEmitter *return_value = new RectangleEmitter(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RectangleEmitter, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "RectangleEmitter() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "RectangleEmitter()\n"
      "RectangleEmitter(const RectangleEmitter copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_RectangleEmitter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_RectangleEmitter) {
    printf("RectangleEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  RectangleEmitter *local_this = (RectangleEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_RectangleEmitter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseParticleEmitter) {
    return (BaseParticleEmitter *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseParticleEmitter *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_RectangleEmitter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_RectangleEmitter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseParticleEmitter) {
    BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
    return (RectangleEmitter*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RectangleEmitter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class SparkleParticleRenderer
 */
/**
 * Python function wrapper for:
 * inline void SparkleParticleRenderer::set_center_color(LColor const &c)
 */
static PyObject *Dtool_SparkleParticleRenderer_set_center_color_255(PyObject *self, PyObject *arg) {
  SparkleParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparkleParticleRenderer, (void **)&local_this, "SparkleParticleRenderer.set_center_color")) {
    return NULL;
  }
  // 1-inline void SparkleParticleRenderer::set_center_color(LColor const &c)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SparkleParticleRenderer.set_center_color", "LVecBase4f");
  }
  (*local_this).set_center_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_center_color(const SparkleParticleRenderer self, const LVecBase4f c)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparkleParticleRenderer_set_center_color_255_comment =
  "C++ Interface:\n"
  "set_center_color(const SparkleParticleRenderer self, const LVecBase4f c)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SparkleParticleRenderer_set_center_color_255_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SparkleParticleRenderer::set_edge_color(LColor const &c)
 */
static PyObject *Dtool_SparkleParticleRenderer_set_edge_color_256(PyObject *self, PyObject *arg) {
  SparkleParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparkleParticleRenderer, (void **)&local_this, "SparkleParticleRenderer.set_edge_color")) {
    return NULL;
  }
  // 1-inline void SparkleParticleRenderer::set_edge_color(LColor const &c)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SparkleParticleRenderer.set_edge_color", "LVecBase4f");
  }
  (*local_this).set_edge_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_edge_color(const SparkleParticleRenderer self, const LVecBase4f c)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparkleParticleRenderer_set_edge_color_256_comment =
  "C++ Interface:\n"
  "set_edge_color(const SparkleParticleRenderer self, const LVecBase4f c)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SparkleParticleRenderer_set_edge_color_256_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SparkleParticleRenderer::set_birth_radius(PN_stdfloat radius)
 */
static PyObject *Dtool_SparkleParticleRenderer_set_birth_radius_257(PyObject *self, PyObject *arg) {
  SparkleParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparkleParticleRenderer, (void **)&local_this, "SparkleParticleRenderer.set_birth_radius")) {
    return NULL;
  }
  // 1-inline void SparkleParticleRenderer::set_birth_radius(PN_stdfloat radius)
  if (PyNumber_Check(arg)) {
    (*local_this).set_birth_radius((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_birth_radius(const SparkleParticleRenderer self, float radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparkleParticleRenderer_set_birth_radius_257_comment =
  "C++ Interface:\n"
  "set_birth_radius(const SparkleParticleRenderer self, float radius)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SparkleParticleRenderer_set_birth_radius_257_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SparkleParticleRenderer::set_death_radius(PN_stdfloat radius)
 */
static PyObject *Dtool_SparkleParticleRenderer_set_death_radius_258(PyObject *self, PyObject *arg) {
  SparkleParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparkleParticleRenderer, (void **)&local_this, "SparkleParticleRenderer.set_death_radius")) {
    return NULL;
  }
  // 1-inline void SparkleParticleRenderer::set_death_radius(PN_stdfloat radius)
  if (PyNumber_Check(arg)) {
    (*local_this).set_death_radius((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_death_radius(const SparkleParticleRenderer self, float radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparkleParticleRenderer_set_death_radius_258_comment =
  "C++ Interface:\n"
  "set_death_radius(const SparkleParticleRenderer self, float radius)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SparkleParticleRenderer_set_death_radius_258_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SparkleParticleRenderer::set_life_scale(SparkleParticleRenderer::SparkleParticleLifeScale )
 */
static PyObject *Dtool_SparkleParticleRenderer_set_life_scale_259(PyObject *self, PyObject *arg) {
  SparkleParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparkleParticleRenderer, (void **)&local_this, "SparkleParticleRenderer.set_life_scale")) {
    return NULL;
  }
  // 1-inline void SparkleParticleRenderer::set_life_scale(SparkleParticleRenderer::SparkleParticleLifeScale )
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_life_scale((SparkleParticleRenderer::SparkleParticleLifeScale)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_life_scale(const SparkleParticleRenderer self, int param0)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SparkleParticleRenderer_set_life_scale_259_comment =
  "C++ Interface:\n"
  "set_life_scale(const SparkleParticleRenderer self, int param0)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SparkleParticleRenderer_set_life_scale_259_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &SparkleParticleRenderer::get_center_color(void) const
 */
static PyObject *Dtool_SparkleParticleRenderer_get_center_color_260(PyObject *self, PyObject *) {
  SparkleParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparkleParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor const &SparkleParticleRenderer::get_center_color(void) const
  LColor const *return_value = &((*(const SparkleParticleRenderer*)local_this).get_center_color());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_SparkleParticleRenderer_get_center_color_260_comment =
  "C++ Interface:\n"
  "get_center_color(SparkleParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SparkleParticleRenderer_get_center_color_260_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &SparkleParticleRenderer::get_edge_color(void) const
 */
static PyObject *Dtool_SparkleParticleRenderer_get_edge_color_261(PyObject *self, PyObject *) {
  SparkleParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparkleParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor const &SparkleParticleRenderer::get_edge_color(void) const
  LColor const *return_value = &((*(const SparkleParticleRenderer*)local_this).get_edge_color());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_SparkleParticleRenderer_get_edge_color_261_comment =
  "C++ Interface:\n"
  "get_edge_color(SparkleParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SparkleParticleRenderer_get_edge_color_261_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SparkleParticleRenderer::get_birth_radius(void) const
 */
static PyObject *Dtool_SparkleParticleRenderer_get_birth_radius_262(PyObject *self, PyObject *) {
  SparkleParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparkleParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat SparkleParticleRenderer::get_birth_radius(void) const
  PN_stdfloat return_value = (*(const SparkleParticleRenderer*)local_this).get_birth_radius();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparkleParticleRenderer_get_birth_radius_262_comment =
  "C++ Interface:\n"
  "get_birth_radius(SparkleParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SparkleParticleRenderer_get_birth_radius_262_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SparkleParticleRenderer::get_death_radius(void) const
 */
static PyObject *Dtool_SparkleParticleRenderer_get_death_radius_263(PyObject *self, PyObject *) {
  SparkleParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparkleParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat SparkleParticleRenderer::get_death_radius(void) const
  PN_stdfloat return_value = (*(const SparkleParticleRenderer*)local_this).get_death_radius();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparkleParticleRenderer_get_death_radius_263_comment =
  "C++ Interface:\n"
  "get_death_radius(SparkleParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SparkleParticleRenderer_get_death_radius_263_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline SparkleParticleRenderer::SparkleParticleLifeScale SparkleParticleRenderer::get_life_scale(void) const
 */
static PyObject *Dtool_SparkleParticleRenderer_get_life_scale_264(PyObject *self, PyObject *) {
  SparkleParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparkleParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline SparkleParticleRenderer::SparkleParticleLifeScale SparkleParticleRenderer::get_life_scale(void) const
  SparkleParticleRenderer::SparkleParticleLifeScale return_value = (*(const SparkleParticleRenderer*)local_this).get_life_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparkleParticleRenderer_get_life_scale_264_comment =
  "C++ Interface:\n"
  "get_life_scale(SparkleParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SparkleParticleRenderer_get_life_scale_264_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * SparkleParticleRenderer::SparkleParticleRenderer(void)
 * SparkleParticleRenderer::SparkleParticleRenderer(LColor const &center, LColor const &edge, PN_stdfloat birth_radius, PN_stdfloat death_radius, SparkleParticleRenderer::SparkleParticleLifeScale life_scale, BaseParticleRenderer::ParticleRendererAlphaMode alpha_mode)
 * SparkleParticleRenderer::SparkleParticleRenderer(SparkleParticleRenderer const &copy)
 */
static int Dtool_Init_SparkleParticleRenderer(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-SparkleParticleRenderer::SparkleParticleRenderer(void)
      SparkleParticleRenderer *return_value = new SparkleParticleRenderer();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SparkleParticleRenderer, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-SparkleParticleRenderer::SparkleParticleRenderer(SparkleParticleRenderer const &copy)
      CPT(SparkleParticleRenderer) arg_this;
      if (!Dtool_ConstCoerce_SparkleParticleRenderer(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "SparkleParticleRenderer.SparkleParticleRenderer", "SparkleParticleRenderer");
        return -1;
      }
      SparkleParticleRenderer *return_value = new SparkleParticleRenderer(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SparkleParticleRenderer, true, false);
    }
    break;
  case 6:
    {
      // 1-SparkleParticleRenderer::SparkleParticleRenderer(LColor const &center, LColor const &edge, PN_stdfloat birth_radius, PN_stdfloat death_radius, SparkleParticleRenderer::SparkleParticleLifeScale life_scale, BaseParticleRenderer::ParticleRendererAlphaMode alpha_mode)
      PyObject *param0;
      PyObject *param1;
      float param2;
      float param3;
      int param4;
      int param5;
      static const char *keyword_list[] = {"center", "edge", "birth_radius", "death_radius", "life_scale", "alpha_mode", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOffii:SparkleParticleRenderer", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
        LVecBase4f param0_local;
        LColor const *param0_this = Dtool_Coerce_LVecBase4f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "SparkleParticleRenderer.SparkleParticleRenderer", "LVecBase4f");
          return -1;
        }
        LVecBase4f param1_local;
        LColor const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "SparkleParticleRenderer.SparkleParticleRenderer", "LVecBase4f");
          return -1;
        }
        SparkleParticleRenderer *return_value = new SparkleParticleRenderer(*param0_this, *param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (SparkleParticleRenderer::SparkleParticleLifeScale)param4, (BaseParticleRenderer::ParticleRendererAlphaMode)param5);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SparkleParticleRenderer, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SparkleParticleRenderer() takes 0, 1 or 6 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SparkleParticleRenderer()\n"
      "SparkleParticleRenderer(const SparkleParticleRenderer copy)\n"
      "SparkleParticleRenderer(const LVecBase4f center, const LVecBase4f edge, float birth_radius, float death_radius, int life_scale, int alpha_mode)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_SparkleParticleRenderer(PyObject *args, CPT(SparkleParticleRenderer) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SparkleParticleRenderer, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 6) {
      // 1-SparkleParticleRenderer::SparkleParticleRenderer(LColor const &center, LColor const &edge, PN_stdfloat birth_radius, PN_stdfloat death_radius, SparkleParticleRenderer::SparkleParticleLifeScale life_scale, BaseParticleRenderer::ParticleRendererAlphaMode alpha_mode)
      PyObject *param0;
      PyObject *param1;
      float param2;
      float param3;
      int param4;
      int param5;
      if (PyArg_ParseTuple(args, "OOffii:SparkleParticleRenderer", &param0, &param1, &param2, &param3, &param4, &param5)) {
        LColor const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4f, (void **)&param0_this);
        LColor const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase4f, (void **)&param1_this);
        if (param0_this != NULL && param1_this != NULL) {
          SparkleParticleRenderer *return_value = new SparkleParticleRenderer(*param0_this, *param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (SparkleParticleRenderer::SparkleParticleLifeScale)param4, (BaseParticleRenderer::ParticleRendererAlphaMode)param5);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_SparkleParticleRenderer(PyObject *args, PT(SparkleParticleRenderer) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SparkleParticleRenderer, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 6) {
      // 1-SparkleParticleRenderer::SparkleParticleRenderer(LColor const &center, LColor const &edge, PN_stdfloat birth_radius, PN_stdfloat death_radius, SparkleParticleRenderer::SparkleParticleLifeScale life_scale, BaseParticleRenderer::ParticleRendererAlphaMode alpha_mode)
      PyObject *param0;
      PyObject *param1;
      float param2;
      float param3;
      int param4;
      int param5;
      if (PyArg_ParseTuple(args, "OOffii:SparkleParticleRenderer", &param0, &param1, &param2, &param3, &param4, &param5)) {
        LColor const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4f, (void **)&param0_this);
        LColor const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase4f, (void **)&param1_this);
        if (param0_this != NULL && param1_this != NULL) {
          SparkleParticleRenderer *return_value = new SparkleParticleRenderer(*param0_this, *param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (SparkleParticleRenderer::SparkleParticleLifeScale)param4, (BaseParticleRenderer::ParticleRendererAlphaMode)param5);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_SparkleParticleRenderer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SparkleParticleRenderer) {
    printf("SparkleParticleRenderer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SparkleParticleRenderer *local_this = (SparkleParticleRenderer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SparkleParticleRenderer) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseParticleRenderer) {
    return (BaseParticleRenderer *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseParticleRenderer *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SparkleParticleRenderer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SparkleParticleRenderer) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseParticleRenderer) {
    BaseParticleRenderer* other_this = (BaseParticleRenderer*)from_this;
    return (SparkleParticleRenderer*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SparkleParticleRenderer*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class SphereSurfaceEmitter
 */
/**
 * Python function wrapper for:
 * inline void SphereSurfaceEmitter::set_radius(PN_stdfloat r)
 */
static PyObject *Dtool_SphereSurfaceEmitter_set_radius_267(PyObject *self, PyObject *arg) {
  SphereSurfaceEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SphereSurfaceEmitter, (void **)&local_this, "SphereSurfaceEmitter.set_radius")) {
    return NULL;
  }
  // 1-inline void SphereSurfaceEmitter::set_radius(PN_stdfloat r)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const SphereSurfaceEmitter self, float r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SphereSurfaceEmitter_set_radius_267_comment =
  "C++ Interface:\n"
  "set_radius(const SphereSurfaceEmitter self, float r)\n";
#else
static const char *Dtool_SphereSurfaceEmitter_set_radius_267_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SphereSurfaceEmitter::get_radius(void) const
 */
static PyObject *Dtool_SphereSurfaceEmitter_get_radius_268(PyObject *self, PyObject *) {
  SphereSurfaceEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SphereSurfaceEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat SphereSurfaceEmitter::get_radius(void) const
  PN_stdfloat return_value = (*(const SphereSurfaceEmitter*)local_this).get_radius();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SphereSurfaceEmitter_get_radius_268_comment =
  "C++ Interface:\n"
  "get_radius(SphereSurfaceEmitter self)\n";
#else
static const char *Dtool_SphereSurfaceEmitter_get_radius_268_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * SphereSurfaceEmitter::SphereSurfaceEmitter(void)
 * SphereSurfaceEmitter::SphereSurfaceEmitter(SphereSurfaceEmitter const &copy)
 */
static int Dtool_Init_SphereSurfaceEmitter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-SphereSurfaceEmitter::SphereSurfaceEmitter(void)
      SphereSurfaceEmitter *return_value = new SphereSurfaceEmitter();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SphereSurfaceEmitter, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-SphereSurfaceEmitter::SphereSurfaceEmitter(SphereSurfaceEmitter const &copy)
      SphereSurfaceEmitter const *arg_this = (SphereSurfaceEmitter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SphereSurfaceEmitter, 0, "SphereSurfaceEmitter.SphereSurfaceEmitter", true, true);
      if (arg_this != NULL) {
        SphereSurfaceEmitter *return_value = new SphereSurfaceEmitter(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SphereSurfaceEmitter, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SphereSurfaceEmitter() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SphereSurfaceEmitter()\n"
      "SphereSurfaceEmitter(const SphereSurfaceEmitter copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SphereSurfaceEmitter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SphereSurfaceEmitter) {
    printf("SphereSurfaceEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SphereSurfaceEmitter *local_this = (SphereSurfaceEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SphereSurfaceEmitter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseParticleEmitter) {
    return (BaseParticleEmitter *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseParticleEmitter *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SphereSurfaceEmitter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SphereSurfaceEmitter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseParticleEmitter) {
    BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
    return (SphereSurfaceEmitter*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SphereSurfaceEmitter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class SphereVolumeEmitter
 */
/**
 * Python function wrapper for:
 * inline void SphereVolumeEmitter::set_radius(PN_stdfloat r)
 */
static PyObject *Dtool_SphereVolumeEmitter_set_radius_271(PyObject *self, PyObject *arg) {
  SphereVolumeEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SphereVolumeEmitter, (void **)&local_this, "SphereVolumeEmitter.set_radius")) {
    return NULL;
  }
  // 1-inline void SphereVolumeEmitter::set_radius(PN_stdfloat r)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const SphereVolumeEmitter self, float r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SphereVolumeEmitter_set_radius_271_comment =
  "C++ Interface:\n"
  "set_radius(const SphereVolumeEmitter self, float r)\n";
#else
static const char *Dtool_SphereVolumeEmitter_set_radius_271_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SphereVolumeEmitter::get_radius(void) const
 */
static PyObject *Dtool_SphereVolumeEmitter_get_radius_272(PyObject *self, PyObject *) {
  SphereVolumeEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SphereVolumeEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat SphereVolumeEmitter::get_radius(void) const
  PN_stdfloat return_value = (*(const SphereVolumeEmitter*)local_this).get_radius();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SphereVolumeEmitter_get_radius_272_comment =
  "C++ Interface:\n"
  "get_radius(SphereVolumeEmitter self)\n";
#else
static const char *Dtool_SphereVolumeEmitter_get_radius_272_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * SphereVolumeEmitter::SphereVolumeEmitter(void)
 * SphereVolumeEmitter::SphereVolumeEmitter(SphereVolumeEmitter const &copy)
 */
static int Dtool_Init_SphereVolumeEmitter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-SphereVolumeEmitter::SphereVolumeEmitter(void)
      SphereVolumeEmitter *return_value = new SphereVolumeEmitter();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SphereVolumeEmitter, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-SphereVolumeEmitter::SphereVolumeEmitter(SphereVolumeEmitter const &copy)
      SphereVolumeEmitter const *arg_this = (SphereVolumeEmitter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SphereVolumeEmitter, 0, "SphereVolumeEmitter.SphereVolumeEmitter", true, true);
      if (arg_this != NULL) {
        SphereVolumeEmitter *return_value = new SphereVolumeEmitter(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SphereVolumeEmitter, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SphereVolumeEmitter() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SphereVolumeEmitter()\n"
      "SphereVolumeEmitter(const SphereVolumeEmitter copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SphereVolumeEmitter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SphereVolumeEmitter) {
    printf("SphereVolumeEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SphereVolumeEmitter *local_this = (SphereVolumeEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SphereVolumeEmitter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseParticleEmitter) {
    return (BaseParticleEmitter *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseParticleEmitter *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SphereVolumeEmitter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SphereVolumeEmitter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseParticleEmitter) {
    BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
    return (SphereVolumeEmitter*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SphereVolumeEmitter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class SpriteAnim
 */
/**
 * Python function wrapper for:
 * void SpriteAnim::set_source_info(std::string const &tex)
 * void SpriteAnim::set_source_info(std::string const &model, std::string const &node)
 */
static PyObject *Dtool_SpriteAnim_set_source_info_275(PyObject *self, PyObject *args, PyObject *kwds) {
  SpriteAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteAnim, (void **)&local_this, "SpriteAnim.set_source_info")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "tex");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'tex' (pos 1) not found");
      }
      // 1-void SpriteAnim::set_source_info(std::string const &tex)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        (*local_this).set_source_info(std::string(param1_str, param1_len));
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void SpriteAnim::set_source_info(std::string const &model, std::string const &node)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      char *param2_str = NULL;
      Py_ssize_t param2_len;
      static const char *keyword_list[] = {"model", "node", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:set_source_info", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
        (*local_this).set_source_info(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_source_info() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_source_info(const SpriteAnim self, str tex)\n"
      "set_source_info(const SpriteAnim self, str model, str node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteAnim_set_source_info_275_comment =
  "C++ Interface:\n"
  "set_source_info(const SpriteAnim self, str tex)\n"
  "set_source_info(const SpriteAnim self, str model, str node)\n";
#else
static const char *Dtool_SpriteAnim_set_source_info_275_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * SpriteAnim::SourceType SpriteAnim::get_source_type(void) const
 */
static PyObject *Dtool_SpriteAnim_get_source_type_276(PyObject *self, PyObject *) {
  SpriteAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteAnim, (void **)&local_this)) {
    return NULL;
  }
  // 1-SpriteAnim::SourceType SpriteAnim::get_source_type(void) const
  SpriteAnim::SourceType return_value = (*(const SpriteAnim*)local_this).get_source_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteAnim_get_source_type_276_comment =
  "C++ Interface:\n"
  "get_source_type(SpriteAnim self)\n";
#else
static const char *Dtool_SpriteAnim_get_source_type_276_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string SpriteAnim::get_tex_source(void) const
 */
static PyObject *Dtool_SpriteAnim_get_tex_source_277(PyObject *self, PyObject *) {
  SpriteAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteAnim, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string SpriteAnim::get_tex_source(void) const
  std::string return_value = (*(const SpriteAnim*)local_this).get_tex_source();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteAnim_get_tex_source_277_comment =
  "C++ Interface:\n"
  "get_tex_source(SpriteAnim self)\n";
#else
static const char *Dtool_SpriteAnim_get_tex_source_277_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string SpriteAnim::get_model_source(void) const
 */
static PyObject *Dtool_SpriteAnim_get_model_source_278(PyObject *self, PyObject *) {
  SpriteAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteAnim, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string SpriteAnim::get_model_source(void) const
  std::string return_value = (*(const SpriteAnim*)local_this).get_model_source();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteAnim_get_model_source_278_comment =
  "C++ Interface:\n"
  "get_model_source(SpriteAnim self)\n";
#else
static const char *Dtool_SpriteAnim_get_model_source_278_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string SpriteAnim::get_node_source(void) const
 */
static PyObject *Dtool_SpriteAnim_get_node_source_279(PyObject *self, PyObject *) {
  SpriteAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteAnim, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string SpriteAnim::get_node_source(void) const
  std::string return_value = (*(const SpriteAnim*)local_this).get_node_source();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteAnim_get_node_source_279_comment =
  "C++ Interface:\n"
  "get_node_source(SpriteAnim self)\n";
#else
static const char *Dtool_SpriteAnim_get_node_source_279_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int SpriteAnim::get_num_frames(void) const
 */
static PyObject *Dtool_SpriteAnim_get_num_frames_280(PyObject *self, PyObject *) {
  SpriteAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteAnim, (void **)&local_this)) {
    return NULL;
  }
  // 1-int SpriteAnim::get_num_frames(void) const
  int return_value = (*(const SpriteAnim*)local_this).get_num_frames();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteAnim_get_num_frames_280_comment =
  "C++ Interface:\n"
  "get_num_frames(SpriteAnim self)\n";
#else
static const char *Dtool_SpriteAnim_get_num_frames_280_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline SpriteAnim::SpriteAnim(SpriteAnim const &) = default
 */
static int Dtool_Init_SpriteAnim(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "SpriteAnim() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline SpriteAnim::SpriteAnim(SpriteAnim const &) = default
  SpriteAnim const *arg_this = (SpriteAnim *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SpriteAnim, 0, "SpriteAnim.SpriteAnim", true, true);
  if (arg_this != NULL) {
    SpriteAnim *return_value = new SpriteAnim(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SpriteAnim, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SpriteAnim(const SpriteAnim param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SpriteAnim(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SpriteAnim) {
    printf("SpriteAnim ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SpriteAnim *local_this = (SpriteAnim *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SpriteAnim) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SpriteAnim(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SpriteAnim) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SpriteAnim*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class SpriteParticleRenderer
 */
/**
 * Python function wrapper for:
 * void SpriteParticleRenderer::set_from_node(NodePath const &node_path, bool size_from_texels = false)
 * void SpriteParticleRenderer::set_from_node(NodePath const &node_path, std::string const &model, std::string const &node, bool size_from_texels = false)
 */
static PyObject *Dtool_SpriteParticleRenderer_set_from_node_285(PyObject *self, PyObject *args, PyObject *kwds) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.set_from_node")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "node_path");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'node_path' (pos 1) not found");
      }
      // 1-void SpriteParticleRenderer::set_from_node(NodePath const &node_path, bool size_from_texels)
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "SpriteParticleRenderer.set_from_node", true, true);
      if (arg_this != NULL) {
        (*local_this).set_from_node(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void SpriteParticleRenderer::set_from_node(NodePath const &node_path, bool size_from_texels)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"node_path", "size_from_texels", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_from_node", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "SpriteParticleRenderer.set_from_node", true, true);
        if (param1_this != NULL) {
          (*local_this).set_from_node(*param1_this, (PyObject_IsTrue(param2) != 0));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 3:
  case 4:
    {
      // 1-void SpriteParticleRenderer::set_from_node(NodePath const &node_path, std::string const &model, std::string const &node, bool size_from_texels = false)
      PyObject *param1;
      char *param2_str = NULL;
      Py_ssize_t param2_len;
      char *param3_str = NULL;
      Py_ssize_t param3_len;
      PyObject *param4 = Py_False;
      static const char *keyword_list[] = {"node_path", "model", "node", "size_from_texels", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#s#|O:set_from_node", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3_str, &param3_len, &param4)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "SpriteParticleRenderer.set_from_node", true, true);
        if (param1_this != NULL) {
          (*local_this).set_from_node(*param1_this, std::string(param2_str, param2_len), std::string(param3_str, param3_len), (PyObject_IsTrue(param4) != 0));
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_from_node() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_node(const SpriteParticleRenderer self, const NodePath node_path)\n"
      "set_from_node(const SpriteParticleRenderer self, const NodePath node_path, bool size_from_texels)\n"
      "set_from_node(const SpriteParticleRenderer self, const NodePath node_path, str model, str node, bool size_from_texels)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_set_from_node_285_comment =
  "C++ Interface:\n"
  "set_from_node(const SpriteParticleRenderer self, const NodePath node_path)\n"
  "set_from_node(const SpriteParticleRenderer self, const NodePath node_path, bool size_from_texels)\n"
  "set_from_node(const SpriteParticleRenderer self, const NodePath node_path, str model, str node, bool size_from_texels)\n"
  "\n"
  "/**\n"
  " * If the source type is important, use this one.\n"
  " *\n"
  " * model and node should lead to node_path like this: node_path =\n"
  " * loader.loadModel(model).find(node)\n"
  " *\n"
  " * This will remove all previously add textures and resize the renderer to\n"
  " * match the new geometry.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the properties on this renderer from the geometry referenced by the\n"
  " * indicated NodePath.  This should be a reference to a GeomNode or a\n"
  " * SequenceNode; it extracts out the texture and UV range from the node.\n"
  " *\n"
  " * This will remove all previously added textures and animations.  It will\n"
  " * also resize the renderer to match this new geometry.\n"
  " *\n"
  " * If node_path refers to a GeomNode(or has one beneath it) the texture, its\n"
  " * size, and UV data will be extracted from that.\n"
  " *\n"
  " * If node_path references a SequenceNode(or has one beneath it) with multiple\n"
  " * GeomNodes beneath it, the size data will correspond only to the first\n"
  " * GeomNode found with a valid texture, while the texture and UV information\n"
  " * will be stored for each individual node.\n"
  " *\n"
  " * If size_from_texels is true, the particle size is based on the number of\n"
  " * texels in the source image; otherwise, it is based on the size of the first\n"
  " * polygon found in the node.\n"
  " *\n"
  " * model and node are the two items used to construct node_path.  If the\n"
  " * source type is important, use set_from_node(NodePath,string,string,bool)\n"
  " * instead.\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_set_from_node_285_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void SpriteParticleRenderer::add_from_node(NodePath const &node_path, bool size_from_texels = false, bool resize = false)
 * void SpriteParticleRenderer::add_from_node(NodePath const &node_path, std::string const &model, std::string const &node, bool size_from_texels = false, bool resize = false)
 */
static PyObject *Dtool_SpriteParticleRenderer_add_from_node_286(PyObject *self, PyObject *args, PyObject *kwds) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.add_from_node")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "node_path");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'node_path' (pos 1) not found");
      }
      // 1-void SpriteParticleRenderer::add_from_node(NodePath const &node_path, bool size_from_texels, bool resize)
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "SpriteParticleRenderer.add_from_node", true, true);
      if (arg_this != NULL) {
        (*local_this).add_from_node(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void SpriteParticleRenderer::add_from_node(NodePath const &node_path, bool size_from_texels, bool resize)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"node_path", "size_from_texels", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_from_node", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "SpriteParticleRenderer.add_from_node", true, true);
        if (param1_this != NULL) {
          (*local_this).add_from_node(*param1_this, (PyObject_IsTrue(param2) != 0));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 3:
  case 4:
  case 5:
    {
      {
        // -2 void SpriteParticleRenderer::add_from_node(NodePath const &node_path, std::string const &model, std::string const &node, bool size_from_texels = false, bool resize = false)
        PyObject *param1;
        char *param2_str = NULL;
        Py_ssize_t param2_len;
        char *param3_str = NULL;
        Py_ssize_t param3_len;
        PyObject *param4 = Py_False;
        PyObject *param5 = Py_False;
        static const char *keyword_list[] = {"node_path", "model", "node", "size_from_texels", "resize", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#s#|OO:add_from_node", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3_str, &param3_len, &param4, &param5)) {
          NodePath const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_NodePath, (void **)&param1_this);
          if (param1_this != NULL) {
            (*local_this).add_from_node(*param1_this, std::string(param2_str, param2_len), std::string(param3_str, param3_len), (PyObject_IsTrue(param4) != 0), (PyObject_IsTrue(param5) != 0));
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void SpriteParticleRenderer::add_from_node(NodePath const &node_path, bool size_from_texels = false, bool resize = false)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"node_path", "size_from_texels", "resize", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:add_from_node", (char **)keyword_list, &param1, &param2, &param3)) {
          NodePath const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_NodePath, (void **)&param1_this);
          if (param1_this != NULL) {
            (*local_this).add_from_node(*param1_this, (PyObject_IsTrue(param2) != 0), (PyObject_IsTrue(param3) != 0));
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: void SpriteParticleRenderer::add_from_node(NodePath const &node_path, std::string const &model, std::string const &node, bool size_from_texels = false, bool resize = false)
      // No coercion possible: void SpriteParticleRenderer::add_from_node(NodePath const &node_path, bool size_from_texels = false, bool resize = false)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_from_node() takes 2, 3, 4, 5 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_from_node(const SpriteParticleRenderer self, const NodePath node_path)\n"
      "add_from_node(const SpriteParticleRenderer self, const NodePath node_path, bool size_from_texels)\n"
      "add_from_node(const SpriteParticleRenderer self, const NodePath node_path, str model, str node, bool size_from_texels, bool resize)\n"
      "add_from_node(const SpriteParticleRenderer self, const NodePath node_path, bool size_from_texels, bool resize)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_add_from_node_286_comment =
  "C++ Interface:\n"
  "add_from_node(const SpriteParticleRenderer self, const NodePath node_path)\n"
  "add_from_node(const SpriteParticleRenderer self, const NodePath node_path, bool size_from_texels)\n"
  "add_from_node(const SpriteParticleRenderer self, const NodePath node_path, str model, str node, bool size_from_texels, bool resize)\n"
  "add_from_node(const SpriteParticleRenderer self, const NodePath node_path, bool size_from_texels, bool resize)\n"
  "\n"
  "/**\n"
  " * This will allow the renderer to randomly choose from more than one texture\n"
  " * or sequence at particle birth.\n"
  " *\n"
  " * If the source type is important, use this one.\n"
  " *\n"
  " * model and node should lead to node_path like this: node_path =\n"
  " * loader.loadModel(model).find(node)\n"
  " *\n"
  " * If resize is true, or if there are no textures currently on the renderer,\n"
  " * it will force the renderer to use the size information from this node from\n"
  " * now on.  (Default is false)\n"
  " */\n"
  "\n"
  "/**\n"
  " * This will allow the renderer to randomly choose from more than one texture\n"
  " * or sequence at particle birth.\n"
  " *\n"
  " * If resize is true, or if there are no textures currently on the renderer,\n"
  " * it will force the renderer to use the size information from this node from\n"
  " * now on.  (Default is false)\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_add_from_node_286_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::set_texture(Texture *tex, PN_stdfloat texels_per_unit = 1.0)
 */
static PyObject *Dtool_SpriteParticleRenderer_set_texture_287(PyObject *self, PyObject *args, PyObject *kwds) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.set_texture")) {
    return NULL;
  }
  // 1-inline void SpriteParticleRenderer::set_texture(Texture *tex, PN_stdfloat texels_per_unit = 1.0)
  PyObject *param1;
  float param2 = 1.0;
  static const char *keyword_list[] = {"tex", "texels_per_unit", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|f:set_texture", (char **)keyword_list, &param1, &param2)) {
    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "SpriteParticleRenderer.set_texture", false, true);
    if (param1_this != NULL) {
      (*local_this).set_texture(param1_this, (PN_stdfloat)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture(const SpriteParticleRenderer self, Texture tex, float texels_per_unit)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_set_texture_287_comment =
  "C++ Interface:\n"
  "set_texture(const SpriteParticleRenderer self, Texture tex, float texels_per_unit)\n"
  "\n"
  "/**\n"
  " * Sets the renderer up to render the entire texture image.  The scale of each\n"
  " * particle is based on the size of the texture in each dimension, modified by\n"
  " * texels_per_unit.\n"
  " *\n"
  " * Used to set the size of the particles.  Will clear all previously loaded\n"
  " * textures and animations.\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_set_texture_287_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::add_texture(Texture *tex, PN_stdfloat texels_per_unit = 1.0, bool resize = false)
 */
static PyObject *Dtool_SpriteParticleRenderer_add_texture_288(PyObject *self, PyObject *args, PyObject *kwds) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.add_texture")) {
    return NULL;
  }
  // 1-inline void SpriteParticleRenderer::add_texture(Texture *tex, PN_stdfloat texels_per_unit = 1.0, bool resize = false)
  PyObject *param1;
  float param2 = 1.0;
  PyObject *param3 = Py_False;
  static const char *keyword_list[] = {"tex", "texels_per_unit", "resize", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|fO:add_texture", (char **)keyword_list, &param1, &param2, &param3)) {
    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "SpriteParticleRenderer.add_texture", false, true);
    if (param1_this != NULL) {
      (*local_this).add_texture(param1_this, (PN_stdfloat)param2, (PyObject_IsTrue(param3) != 0));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_texture(const SpriteParticleRenderer self, Texture tex, float texels_per_unit, bool resize)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_add_texture_288_comment =
  "C++ Interface:\n"
  "add_texture(const SpriteParticleRenderer self, Texture tex, float texels_per_unit, bool resize)\n"
  "\n"
  "/**\n"
  " * Adds texture to image pool, effectively creating a single frame animation\n"
  " * that can be selected at particle birth.  This should only be called after a\n"
  " * previous call to set_texture().\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_add_texture_288_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::remove_animation(int const n)
 */
static PyObject *Dtool_SpriteParticleRenderer_remove_animation_289(PyObject *self, PyObject *arg) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.remove_animation")) {
    return NULL;
  }
  // 1-inline void SpriteParticleRenderer::remove_animation(int const n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).remove_animation((int const)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_animation(const SpriteParticleRenderer self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_remove_animation_289_comment =
  "C++ Interface:\n"
  "remove_animation(const SpriteParticleRenderer self, int n)\n"
  "\n"
  "/**\n"
  " * Removes an animation texture set from the renderer.\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_remove_animation_289_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::set_ll_uv(LTexCoord const &ll_uv)
 * inline void SpriteParticleRenderer::set_ll_uv(LTexCoord const &ll_uv, int const anim, int const frame)
 */
static PyObject *Dtool_SpriteParticleRenderer_set_ll_uv_290(PyObject *self, PyObject *args, PyObject *kwds) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.set_ll_uv")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "ll_uv");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'll_uv' (pos 1) not found");
      }
      // 1-inline void SpriteParticleRenderer::set_ll_uv(LTexCoord const &ll_uv)
      LPoint2f arg_local;
      LTexCoord const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "SpriteParticleRenderer.set_ll_uv", "LPoint2f");
      }
      (*local_this).set_ll_uv(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void SpriteParticleRenderer::set_ll_uv(LTexCoord const &ll_uv, int const anim, int const frame)
      PyObject *param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"ll_uv", "anim", "frame", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_ll_uv", (char **)keyword_list, &param1, &param2, &param3)) {
        LPoint2f param1_local;
        LTexCoord const *param1_this = Dtool_Coerce_LPoint2f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "SpriteParticleRenderer.set_ll_uv", "LPoint2f");
        }
        (*local_this).set_ll_uv(*param1_this, (int const)param2, (int const)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_ll_uv() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ll_uv(const SpriteParticleRenderer self, const LPoint2f ll_uv)\n"
      "set_ll_uv(const SpriteParticleRenderer self, const LPoint2f ll_uv, int anim, int frame)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_set_ll_uv_290_comment =
  "C++ Interface:\n"
  "set_ll_uv(const SpriteParticleRenderer self, const LPoint2f ll_uv)\n"
  "set_ll_uv(const SpriteParticleRenderer self, const LPoint2f ll_uv, int anim, int frame)\n"
  "\n"
  "/**\n"
  " * Sets the UV coordinate of the lower-left corner of all the sprites\n"
  " * generated by this renderer.  Normally this is (0, 0), but it might be set\n"
  " * to something else to use only a portion of the texture.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the UV coordinate of the lower-left corner of all the sprites\n"
  " * generated by this renderer.  Normally this is (0, 0), but it might be set\n"
  " * to something else to use only a portion of the texture.\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_set_ll_uv_290_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::set_ur_uv(LTexCoord const &ur_uv)
 * inline void SpriteParticleRenderer::set_ur_uv(LTexCoord const &ur_uv, int const anim, int const frame)
 */
static PyObject *Dtool_SpriteParticleRenderer_set_ur_uv_291(PyObject *self, PyObject *args, PyObject *kwds) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.set_ur_uv")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "ur_uv");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'ur_uv' (pos 1) not found");
      }
      // 1-inline void SpriteParticleRenderer::set_ur_uv(LTexCoord const &ur_uv)
      LPoint2f arg_local;
      LTexCoord const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "SpriteParticleRenderer.set_ur_uv", "LPoint2f");
      }
      (*local_this).set_ur_uv(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void SpriteParticleRenderer::set_ur_uv(LTexCoord const &ur_uv, int const anim, int const frame)
      PyObject *param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"ur_uv", "anim", "frame", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_ur_uv", (char **)keyword_list, &param1, &param2, &param3)) {
        LPoint2f param1_local;
        LTexCoord const *param1_this = Dtool_Coerce_LPoint2f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "SpriteParticleRenderer.set_ur_uv", "LPoint2f");
        }
        (*local_this).set_ur_uv(*param1_this, (int const)param2, (int const)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_ur_uv() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ur_uv(const SpriteParticleRenderer self, const LPoint2f ur_uv)\n"
      "set_ur_uv(const SpriteParticleRenderer self, const LPoint2f ur_uv, int anim, int frame)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_set_ur_uv_291_comment =
  "C++ Interface:\n"
  "set_ur_uv(const SpriteParticleRenderer self, const LPoint2f ur_uv)\n"
  "set_ur_uv(const SpriteParticleRenderer self, const LPoint2f ur_uv, int anim, int frame)\n"
  "\n"
  "/**\n"
  " * Sets the UV coordinate of the upper-right corner of all the sprites\n"
  " * generated by this renderer.  Normally this is (1, 1), but it might be set\n"
  " * to something else to use only a portion of the texture.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the UV coordinate of the upper-right corner of all the sprites\n"
  " * generated by this renderer.  Normally this is (1, 1), but it might be set\n"
  " * to something else to use only a portion of the texture.\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_set_ur_uv_291_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::set_size(PN_stdfloat width, PN_stdfloat height)
 */
static PyObject *Dtool_SpriteParticleRenderer_set_size_292(PyObject *self, PyObject *args, PyObject *kwds) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.set_size")) {
    return NULL;
  }
  // 1-inline void SpriteParticleRenderer::set_size(PN_stdfloat width, PN_stdfloat height)
  float param1;
  float param2;
  static const char *keyword_list[] = {"width", "height", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_size", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_size((PN_stdfloat)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_size(const SpriteParticleRenderer self, float width, float height)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_set_size_292_comment =
  "C++ Interface:\n"
  "set_size(const SpriteParticleRenderer self, float width, float height)\n"
  "\n"
  "/**\n"
  " * Sets the size of each particle in world units.\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_set_size_292_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::set_color(LColor const &color)
 */
static PyObject *Dtool_SpriteParticleRenderer_set_color_293(PyObject *self, PyObject *arg) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.set_color")) {
    return NULL;
  }
  // 1-inline void SpriteParticleRenderer::set_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SpriteParticleRenderer.set_color", "LVecBase4f");
  }
  (*local_this).set_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color(const SpriteParticleRenderer self, const LVecBase4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_set_color_293_comment =
  "C++ Interface:\n"
  "set_color(const SpriteParticleRenderer self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_set_color_293_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::set_x_scale_flag(bool animate_x_ratio)
 */
static PyObject *Dtool_SpriteParticleRenderer_set_x_scale_flag_294(PyObject *self, PyObject *arg) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.set_x_scale_flag")) {
    return NULL;
  }
  // 1-inline void SpriteParticleRenderer::set_x_scale_flag(bool animate_x_ratio)
  (*local_this).set_x_scale_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_x_scale_flag(const SpriteParticleRenderer self, bool animate_x_ratio)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_set_x_scale_flag_294_comment =
  "C++ Interface:\n"
  "set_x_scale_flag(const SpriteParticleRenderer self, bool animate_x_ratio)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_set_x_scale_flag_294_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::set_y_scale_flag(bool animate_y_ratio)
 */
static PyObject *Dtool_SpriteParticleRenderer_set_y_scale_flag_295(PyObject *self, PyObject *arg) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.set_y_scale_flag")) {
    return NULL;
  }
  // 1-inline void SpriteParticleRenderer::set_y_scale_flag(bool animate_y_ratio)
  (*local_this).set_y_scale_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_y_scale_flag(const SpriteParticleRenderer self, bool animate_y_ratio)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_set_y_scale_flag_295_comment =
  "C++ Interface:\n"
  "set_y_scale_flag(const SpriteParticleRenderer self, bool animate_y_ratio)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_set_y_scale_flag_295_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::set_anim_angle_flag(bool animate_theta)
 */
static PyObject *Dtool_SpriteParticleRenderer_set_anim_angle_flag_296(PyObject *self, PyObject *arg) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.set_anim_angle_flag")) {
    return NULL;
  }
  // 1-inline void SpriteParticleRenderer::set_anim_angle_flag(bool animate_theta)
  (*local_this).set_anim_angle_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anim_angle_flag(const SpriteParticleRenderer self, bool animate_theta)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_set_anim_angle_flag_296_comment =
  "C++ Interface:\n"
  "set_anim_angle_flag(const SpriteParticleRenderer self, bool animate_theta)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_set_anim_angle_flag_296_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::set_initial_x_scale(PN_stdfloat initial_x_scale)
 */
static PyObject *Dtool_SpriteParticleRenderer_set_initial_x_scale_297(PyObject *self, PyObject *arg) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.set_initial_x_scale")) {
    return NULL;
  }
  // 1-inline void SpriteParticleRenderer::set_initial_x_scale(PN_stdfloat initial_x_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_initial_x_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_initial_x_scale(const SpriteParticleRenderer self, float initial_x_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_set_initial_x_scale_297_comment =
  "C++ Interface:\n"
  "set_initial_x_scale(const SpriteParticleRenderer self, float initial_x_scale)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_set_initial_x_scale_297_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::set_final_x_scale(PN_stdfloat final_x_scale)
 */
static PyObject *Dtool_SpriteParticleRenderer_set_final_x_scale_298(PyObject *self, PyObject *arg) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.set_final_x_scale")) {
    return NULL;
  }
  // 1-inline void SpriteParticleRenderer::set_final_x_scale(PN_stdfloat final_x_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_final_x_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_final_x_scale(const SpriteParticleRenderer self, float final_x_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_set_final_x_scale_298_comment =
  "C++ Interface:\n"
  "set_final_x_scale(const SpriteParticleRenderer self, float final_x_scale)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_set_final_x_scale_298_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::set_initial_y_scale(PN_stdfloat initial_y_scale)
 */
static PyObject *Dtool_SpriteParticleRenderer_set_initial_y_scale_299(PyObject *self, PyObject *arg) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.set_initial_y_scale")) {
    return NULL;
  }
  // 1-inline void SpriteParticleRenderer::set_initial_y_scale(PN_stdfloat initial_y_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_initial_y_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_initial_y_scale(const SpriteParticleRenderer self, float initial_y_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_set_initial_y_scale_299_comment =
  "C++ Interface:\n"
  "set_initial_y_scale(const SpriteParticleRenderer self, float initial_y_scale)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_set_initial_y_scale_299_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::set_final_y_scale(PN_stdfloat final_y_scale)
 */
static PyObject *Dtool_SpriteParticleRenderer_set_final_y_scale_300(PyObject *self, PyObject *arg) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.set_final_y_scale")) {
    return NULL;
  }
  // 1-inline void SpriteParticleRenderer::set_final_y_scale(PN_stdfloat final_y_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_final_y_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_final_y_scale(const SpriteParticleRenderer self, float final_y_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_set_final_y_scale_300_comment =
  "C++ Interface:\n"
  "set_final_y_scale(const SpriteParticleRenderer self, float final_y_scale)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_set_final_y_scale_300_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::set_nonanimated_theta(PN_stdfloat theta)
 */
static PyObject *Dtool_SpriteParticleRenderer_set_nonanimated_theta_301(PyObject *self, PyObject *arg) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.set_nonanimated_theta")) {
    return NULL;
  }
  // 1-inline void SpriteParticleRenderer::set_nonanimated_theta(PN_stdfloat theta)
  if (PyNumber_Check(arg)) {
    (*local_this).set_nonanimated_theta((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_nonanimated_theta(const SpriteParticleRenderer self, float theta)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_set_nonanimated_theta_301_comment =
  "C++ Interface:\n"
  "set_nonanimated_theta(const SpriteParticleRenderer self, float theta)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_set_nonanimated_theta_301_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::set_alpha_blend_method(BaseParticleRenderer::ParticleRendererBlendMethod bm)
 */
static PyObject *Dtool_SpriteParticleRenderer_set_alpha_blend_method_302(PyObject *self, PyObject *arg) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.set_alpha_blend_method")) {
    return NULL;
  }
  // 1-inline void SpriteParticleRenderer::set_alpha_blend_method(BaseParticleRenderer::ParticleRendererBlendMethod bm)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_alpha_blend_method((BaseParticleRenderer::ParticleRendererBlendMethod)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_blend_method(const SpriteParticleRenderer self, int bm)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_set_alpha_blend_method_302_comment =
  "C++ Interface:\n"
  "set_alpha_blend_method(const SpriteParticleRenderer self, int bm)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_set_alpha_blend_method_302_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::set_alpha_disable(bool ad)
 */
static PyObject *Dtool_SpriteParticleRenderer_set_alpha_disable_303(PyObject *self, PyObject *arg) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.set_alpha_disable")) {
    return NULL;
  }
  // 1-inline void SpriteParticleRenderer::set_alpha_disable(bool ad)
  (*local_this).set_alpha_disable((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_disable(const SpriteParticleRenderer self, bool ad)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_set_alpha_disable_303_comment =
  "C++ Interface:\n"
  "set_alpha_disable(const SpriteParticleRenderer self, bool ad)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_set_alpha_disable_303_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::set_animate_frames_enable(bool an)
 */
static PyObject *Dtool_SpriteParticleRenderer_set_animate_frames_enable_304(PyObject *self, PyObject *arg) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.set_animate_frames_enable")) {
    return NULL;
  }
  // 1-inline void SpriteParticleRenderer::set_animate_frames_enable(bool an)
  (*local_this).set_animate_frames_enable((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_animate_frames_enable(const SpriteParticleRenderer self, bool an)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_set_animate_frames_enable_304_comment =
  "C++ Interface:\n"
  "set_animate_frames_enable(const SpriteParticleRenderer self, bool an)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_set_animate_frames_enable_304_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::set_animate_frames_rate(PN_stdfloat r)
 */
static PyObject *Dtool_SpriteParticleRenderer_set_animate_frames_rate_305(PyObject *self, PyObject *arg) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.set_animate_frames_rate")) {
    return NULL;
  }
  // 1-inline void SpriteParticleRenderer::set_animate_frames_rate(PN_stdfloat r)
  if (PyNumber_Check(arg)) {
    (*local_this).set_animate_frames_rate((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_animate_frames_rate(const SpriteParticleRenderer self, float r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_set_animate_frames_rate_305_comment =
  "C++ Interface:\n"
  "set_animate_frames_rate(const SpriteParticleRenderer self, float r)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_set_animate_frames_rate_305_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SpriteParticleRenderer::set_animate_frames_index(int i)
 */
static PyObject *Dtool_SpriteParticleRenderer_set_animate_frames_index_306(PyObject *self, PyObject *arg) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SpriteParticleRenderer, (void **)&local_this, "SpriteParticleRenderer.set_animate_frames_index")) {
    return NULL;
  }
  // 1-inline void SpriteParticleRenderer::set_animate_frames_index(int i)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_animate_frames_index((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_animate_frames_index(const SpriteParticleRenderer self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_set_animate_frames_index_306_comment =
  "C++ Interface:\n"
  "set_animate_frames_index(const SpriteParticleRenderer self, int i)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_set_animate_frames_index_306_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Texture *SpriteParticleRenderer::get_texture(void) const
 * inline Texture *SpriteParticleRenderer::get_texture(int const anim, int const frame) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_texture_307(PyObject *self, PyObject *args, PyObject *kwds) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Texture *SpriteParticleRenderer::get_texture(void) const
      Texture *return_value = (*(const SpriteParticleRenderer*)local_this).get_texture();
      if (return_value != (Texture *)NULL) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != (Texture *)NULL) {
          unref_delete(return_value);
        }
        return NULL;
      }
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
    break;
  case 2:
    {
      // 1-inline Texture *SpriteParticleRenderer::get_texture(int const anim, int const frame) const
      int param1;
      int param2;
      static const char *keyword_list[] = {"anim", "frame", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_texture", (char **)keyword_list, &param1, &param2)) {
        Texture *return_value = (*(const SpriteParticleRenderer*)local_this).get_texture((int const)param1, (int const)param2);
        if (return_value != (Texture *)NULL) {
          return_value->ref();
        }
        if (Dtool_CheckErrorOccurred()) {
          if (return_value != (Texture *)NULL) {
            unref_delete(return_value);
          }
          return NULL;
        }
        if (return_value == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_texture() takes 1 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_texture(SpriteParticleRenderer self)\n"
      "get_texture(SpriteParticleRenderer self, int anim, int frame)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_texture_307_comment =
  "C++ Interface:\n"
  "get_texture(SpriteParticleRenderer self)\n"
  "get_texture(SpriteParticleRenderer self, int anim, int frame)\n"
  "\n"
  "/**\n"
  "\n"
  " */\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_texture_307_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SpriteParticleRenderer::get_num_anims(void) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_num_anims_308(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SpriteParticleRenderer::get_num_anims(void) const
  int return_value = (*(const SpriteParticleRenderer*)local_this).get_num_anims();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_num_anims_308_comment =
  "C++ Interface:\n"
  "get_num_anims(SpriteParticleRenderer self)\n";
#else
static const char *Dtool_SpriteParticleRenderer_get_num_anims_308_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline SpriteAnim *SpriteParticleRenderer::get_anim(int const n) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_anim_309(PyObject *self, PyObject *arg) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline SpriteAnim *SpriteParticleRenderer::get_anim(int const n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    SpriteAnim *return_value = (*(const SpriteParticleRenderer*)local_this).get_anim((int const)arg_val);
    if (return_value != (SpriteAnim *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (SpriteAnim *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SpriteAnim, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_anim(SpriteParticleRenderer self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_anim_309_comment =
  "C++ Interface:\n"
  "get_anim(SpriteParticleRenderer self, int n)\n";
#else
static const char *Dtool_SpriteParticleRenderer_get_anim_309_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline SpriteAnim *SpriteParticleRenderer::get_last_anim(void) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_last_anim_311(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline SpriteAnim *SpriteParticleRenderer::get_last_anim(void) const
  SpriteAnim *return_value = (*(const SpriteParticleRenderer*)local_this).get_last_anim();
  if (return_value != (SpriteAnim *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (SpriteAnim *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SpriteAnim, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_last_anim_311_comment =
  "C++ Interface:\n"
  "get_last_anim(SpriteParticleRenderer self)\n";
#else
static const char *Dtool_SpriteParticleRenderer_get_last_anim_311_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ColorInterpolationManager *SpriteParticleRenderer::get_color_interpolation_manager(void) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_color_interpolation_manager_312(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ColorInterpolationManager *SpriteParticleRenderer::get_color_interpolation_manager(void) const
  ColorInterpolationManager *return_value = (*(const SpriteParticleRenderer*)local_this).get_color_interpolation_manager();
  if (return_value != (ColorInterpolationManager *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (ColorInterpolationManager *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ColorInterpolationManager, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_color_interpolation_manager_312_comment =
  "C++ Interface:\n"
  "get_color_interpolation_manager(SpriteParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_color_interpolation_manager_312_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LTexCoord SpriteParticleRenderer::get_ll_uv(void) const
 * inline LTexCoord SpriteParticleRenderer::get_ll_uv(int const anim, int const frame) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_ll_uv_313(PyObject *self, PyObject *args, PyObject *kwds) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LTexCoord SpriteParticleRenderer::get_ll_uv(void) const
      LTexCoord *return_value = new LTexCoord((*(const SpriteParticleRenderer*)local_this).get_ll_uv());
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
    }
    break;
  case 2:
    {
      // 1-inline LTexCoord SpriteParticleRenderer::get_ll_uv(int const anim, int const frame) const
      int param1;
      int param2;
      static const char *keyword_list[] = {"anim", "frame", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_ll_uv", (char **)keyword_list, &param1, &param2)) {
        LTexCoord *return_value = new LTexCoord((*(const SpriteParticleRenderer*)local_this).get_ll_uv((int const)param1, (int const)param2));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_ll_uv() takes 1 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_ll_uv(SpriteParticleRenderer self)\n"
      "get_ll_uv(SpriteParticleRenderer self, int anim, int frame)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_ll_uv_313_comment =
  "C++ Interface:\n"
  "get_ll_uv(SpriteParticleRenderer self)\n"
  "get_ll_uv(SpriteParticleRenderer self, int anim, int frame)\n"
  "\n"
  "/**\n"
  " * Returns the UV coordinate of the lower-left corner; see set_ll_uv().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the UV coordinate of the lower-left corner; see set_ll_uv().\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_ll_uv_313_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LTexCoord SpriteParticleRenderer::get_ur_uv(void) const
 * inline LTexCoord SpriteParticleRenderer::get_ur_uv(int const anim, int const frame) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_ur_uv_314(PyObject *self, PyObject *args, PyObject *kwds) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LTexCoord SpriteParticleRenderer::get_ur_uv(void) const
      LTexCoord *return_value = new LTexCoord((*(const SpriteParticleRenderer*)local_this).get_ur_uv());
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
    }
    break;
  case 2:
    {
      // 1-inline LTexCoord SpriteParticleRenderer::get_ur_uv(int const anim, int const frame) const
      int param1;
      int param2;
      static const char *keyword_list[] = {"anim", "frame", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_ur_uv", (char **)keyword_list, &param1, &param2)) {
        LTexCoord *return_value = new LTexCoord((*(const SpriteParticleRenderer*)local_this).get_ur_uv((int const)param1, (int const)param2));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_ur_uv() takes 1 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_ur_uv(SpriteParticleRenderer self)\n"
      "get_ur_uv(SpriteParticleRenderer self, int anim, int frame)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_ur_uv_314_comment =
  "C++ Interface:\n"
  "get_ur_uv(SpriteParticleRenderer self)\n"
  "get_ur_uv(SpriteParticleRenderer self, int anim, int frame)\n"
  "\n"
  "/**\n"
  " * Returns the UV coordinate of the lower-left corner; see set_ur_uv().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the UV coordinate of the upper-right corner; see set_ur_uv().\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_ur_uv_314_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SpriteParticleRenderer::get_width(void) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_width_315(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat SpriteParticleRenderer::get_width(void) const
  PN_stdfloat return_value = (*(const SpriteParticleRenderer*)local_this).get_width();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_width_315_comment =
  "C++ Interface:\n"
  "get_width(SpriteParticleRenderer self)\n"
  "\n"
  "/**\n"
  " * Returns the width of each particle in world units.\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_width_315_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SpriteParticleRenderer::get_height(void) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_height_316(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat SpriteParticleRenderer::get_height(void) const
  PN_stdfloat return_value = (*(const SpriteParticleRenderer*)local_this).get_height();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_height_316_comment =
  "C++ Interface:\n"
  "get_height(SpriteParticleRenderer self)\n"
  "\n"
  "/**\n"
  " * Returns the height of each particle in world units.\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_height_316_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor SpriteParticleRenderer::get_color(void) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_color_317(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor SpriteParticleRenderer::get_color(void) const
  LColor *return_value = new LColor((*(const SpriteParticleRenderer*)local_this).get_color());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_color_317_comment =
  "C++ Interface:\n"
  "get_color(SpriteParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_color_317_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SpriteParticleRenderer::get_x_scale_flag(void) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_x_scale_flag_318(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool SpriteParticleRenderer::get_x_scale_flag(void) const
  bool return_value = (*(const SpriteParticleRenderer*)local_this).get_x_scale_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_x_scale_flag_318_comment =
  "C++ Interface:\n"
  "get_x_scale_flag(SpriteParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_x_scale_flag_318_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SpriteParticleRenderer::get_y_scale_flag(void) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_y_scale_flag_319(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool SpriteParticleRenderer::get_y_scale_flag(void) const
  bool return_value = (*(const SpriteParticleRenderer*)local_this).get_y_scale_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_y_scale_flag_319_comment =
  "C++ Interface:\n"
  "get_y_scale_flag(SpriteParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_y_scale_flag_319_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SpriteParticleRenderer::get_anim_angle_flag(void) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_anim_angle_flag_320(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool SpriteParticleRenderer::get_anim_angle_flag(void) const
  bool return_value = (*(const SpriteParticleRenderer*)local_this).get_anim_angle_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_anim_angle_flag_320_comment =
  "C++ Interface:\n"
  "get_anim_angle_flag(SpriteParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_anim_angle_flag_320_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SpriteParticleRenderer::get_initial_x_scale(void) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_initial_x_scale_321(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat SpriteParticleRenderer::get_initial_x_scale(void) const
  PN_stdfloat return_value = (*(const SpriteParticleRenderer*)local_this).get_initial_x_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_initial_x_scale_321_comment =
  "C++ Interface:\n"
  "get_initial_x_scale(SpriteParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_initial_x_scale_321_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SpriteParticleRenderer::get_final_x_scale(void) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_final_x_scale_322(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat SpriteParticleRenderer::get_final_x_scale(void) const
  PN_stdfloat return_value = (*(const SpriteParticleRenderer*)local_this).get_final_x_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_final_x_scale_322_comment =
  "C++ Interface:\n"
  "get_final_x_scale(SpriteParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_final_x_scale_322_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SpriteParticleRenderer::get_initial_y_scale(void) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_initial_y_scale_323(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat SpriteParticleRenderer::get_initial_y_scale(void) const
  PN_stdfloat return_value = (*(const SpriteParticleRenderer*)local_this).get_initial_y_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_initial_y_scale_323_comment =
  "C++ Interface:\n"
  "get_initial_y_scale(SpriteParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_initial_y_scale_323_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SpriteParticleRenderer::get_final_y_scale(void) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_final_y_scale_324(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat SpriteParticleRenderer::get_final_y_scale(void) const
  PN_stdfloat return_value = (*(const SpriteParticleRenderer*)local_this).get_final_y_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_final_y_scale_324_comment =
  "C++ Interface:\n"
  "get_final_y_scale(SpriteParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_final_y_scale_324_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SpriteParticleRenderer::get_nonanimated_theta(void) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_nonanimated_theta_325(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat SpriteParticleRenderer::get_nonanimated_theta(void) const
  PN_stdfloat return_value = (*(const SpriteParticleRenderer*)local_this).get_nonanimated_theta();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_nonanimated_theta_325_comment =
  "C++ Interface:\n"
  "get_nonanimated_theta(SpriteParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_nonanimated_theta_325_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BaseParticleRenderer::ParticleRendererBlendMethod SpriteParticleRenderer::get_alpha_blend_method(void) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_alpha_blend_method_326(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BaseParticleRenderer::ParticleRendererBlendMethod SpriteParticleRenderer::get_alpha_blend_method(void) const
  BaseParticleRenderer::ParticleRendererBlendMethod return_value = (*(const SpriteParticleRenderer*)local_this).get_alpha_blend_method();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_alpha_blend_method_326_comment =
  "C++ Interface:\n"
  "get_alpha_blend_method(SpriteParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_alpha_blend_method_326_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SpriteParticleRenderer::get_alpha_disable(void) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_alpha_disable_327(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool SpriteParticleRenderer::get_alpha_disable(void) const
  bool return_value = (*(const SpriteParticleRenderer*)local_this).get_alpha_disable();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_alpha_disable_327_comment =
  "C++ Interface:\n"
  "get_alpha_disable(SpriteParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_alpha_disable_327_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SpriteParticleRenderer::get_animate_frames_enable(void) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_animate_frames_enable_328(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool SpriteParticleRenderer::get_animate_frames_enable(void) const
  bool return_value = (*(const SpriteParticleRenderer*)local_this).get_animate_frames_enable();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_animate_frames_enable_328_comment =
  "C++ Interface:\n"
  "get_animate_frames_enable(SpriteParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_animate_frames_enable_328_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SpriteParticleRenderer::get_animate_frames_rate(void) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_animate_frames_rate_329(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat SpriteParticleRenderer::get_animate_frames_rate(void) const
  PN_stdfloat return_value = (*(const SpriteParticleRenderer*)local_this).get_animate_frames_rate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_animate_frames_rate_329_comment =
  "C++ Interface:\n"
  "get_animate_frames_rate(SpriteParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_animate_frames_rate_329_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SpriteParticleRenderer::get_animate_frames_index(void) const
 */
static PyObject *Dtool_SpriteParticleRenderer_get_animate_frames_index_330(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SpriteParticleRenderer::get_animate_frames_index(void) const
  int return_value = (*(const SpriteParticleRenderer*)local_this).get_animate_frames_index();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SpriteParticleRenderer_get_animate_frames_index_330_comment =
  "C++ Interface:\n"
  "get_animate_frames_index(SpriteParticleRenderer self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_SpriteParticleRenderer_get_animate_frames_index_330_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * SpriteParticleRenderer::SpriteParticleRenderer(SpriteParticleRenderer const &copy)
 * SpriteParticleRenderer::SpriteParticleRenderer(Texture *tex = (Texture *)(0))
 */
static int Dtool_Init_SpriteParticleRenderer(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-SpriteParticleRenderer::SpriteParticleRenderer(Texture *tex)
      SpriteParticleRenderer *return_value = new SpriteParticleRenderer();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SpriteParticleRenderer, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 SpriteParticleRenderer::SpriteParticleRenderer(SpriteParticleRenderer const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:SpriteParticleRenderer", (char **)keyword_list, &param0)) {
          SpriteParticleRenderer const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_SpriteParticleRenderer, (void **)&param0_this);
          if (param0_this != NULL) {
            SpriteParticleRenderer *return_value = new SpriteParticleRenderer(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SpriteParticleRenderer, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 SpriteParticleRenderer::SpriteParticleRenderer(Texture *tex)
        PyObject *param0;
        static const char *keyword_list[] = {"tex", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:SpriteParticleRenderer", (char **)keyword_list, &param0)) {
          Texture *param0_this = (Texture *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Texture, 0, "SpriteParticleRenderer.SpriteParticleRenderer", false, false);
          if (param0_this != NULL) {
            SpriteParticleRenderer *return_value = new SpriteParticleRenderer(param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SpriteParticleRenderer, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 SpriteParticleRenderer::SpriteParticleRenderer(SpriteParticleRenderer const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:SpriteParticleRenderer", (char **)keyword_list, &param0)) {
          CPT(SpriteParticleRenderer) param0_this;
          if (Dtool_ConstCoerce_SpriteParticleRenderer(param0, param0_this)) {
            SpriteParticleRenderer *return_value = new SpriteParticleRenderer(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SpriteParticleRenderer, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: SpriteParticleRenderer::SpriteParticleRenderer(Texture *tex)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SpriteParticleRenderer() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SpriteParticleRenderer()\n"
      "SpriteParticleRenderer(const SpriteParticleRenderer copy)\n"
      "SpriteParticleRenderer(Texture tex)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_SpriteParticleRenderer(PyObject *args, CPT(SpriteParticleRenderer) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SpriteParticleRenderer, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-SpriteParticleRenderer::SpriteParticleRenderer(Texture *tex)
    Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 0, "SpriteParticleRenderer.SpriteParticleRenderer", false, false);
    if (arg_this != NULL) {
      SpriteParticleRenderer *return_value = new SpriteParticleRenderer(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_SpriteParticleRenderer(PyObject *args, PT(SpriteParticleRenderer) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SpriteParticleRenderer, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-SpriteParticleRenderer::SpriteParticleRenderer(Texture *tex)
    Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 0, "SpriteParticleRenderer.SpriteParticleRenderer", false, false);
    if (arg_this != NULL) {
      SpriteParticleRenderer *return_value = new SpriteParticleRenderer(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_SpriteParticleRenderer_get_anims(PyObject *self, PyObject *) {
  SpriteParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SpriteParticleRenderer, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_anims();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_SpriteParticleRenderer_get_anim_309(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_SpriteParticleRenderer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SpriteParticleRenderer) {
    printf("SpriteParticleRenderer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SpriteParticleRenderer *local_this = (SpriteParticleRenderer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SpriteParticleRenderer) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseParticleRenderer) {
    return (BaseParticleRenderer *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseParticleRenderer *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SpriteParticleRenderer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SpriteParticleRenderer) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseParticleRenderer) {
    BaseParticleRenderer* other_this = (BaseParticleRenderer*)from_this;
    return (SpriteParticleRenderer*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SpriteParticleRenderer*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class TangentRingEmitter
 */
/**
 * Python function wrapper for:
 * inline void TangentRingEmitter::set_radius(PN_stdfloat r)
 */
static PyObject *Dtool_TangentRingEmitter_set_radius_333(PyObject *self, PyObject *arg) {
  TangentRingEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TangentRingEmitter, (void **)&local_this, "TangentRingEmitter.set_radius")) {
    return NULL;
  }
  // 1-inline void TangentRingEmitter::set_radius(PN_stdfloat r)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const TangentRingEmitter self, float r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TangentRingEmitter_set_radius_333_comment =
  "C++ Interface:\n"
  "set_radius(const TangentRingEmitter self, float r)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_TangentRingEmitter_set_radius_333_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TangentRingEmitter::set_radius_spread(PN_stdfloat spread)
 */
static PyObject *Dtool_TangentRingEmitter_set_radius_spread_334(PyObject *self, PyObject *arg) {
  TangentRingEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TangentRingEmitter, (void **)&local_this, "TangentRingEmitter.set_radius_spread")) {
    return NULL;
  }
  // 1-inline void TangentRingEmitter::set_radius_spread(PN_stdfloat spread)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius_spread((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius_spread(const TangentRingEmitter self, float spread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TangentRingEmitter_set_radius_spread_334_comment =
  "C++ Interface:\n"
  "set_radius_spread(const TangentRingEmitter self, float spread)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_TangentRingEmitter_set_radius_spread_334_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TangentRingEmitter::get_radius(void) const
 */
static PyObject *Dtool_TangentRingEmitter_get_radius_335(PyObject *self, PyObject *) {
  TangentRingEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TangentRingEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TangentRingEmitter::get_radius(void) const
  PN_stdfloat return_value = (*(const TangentRingEmitter*)local_this).get_radius();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TangentRingEmitter_get_radius_335_comment =
  "C++ Interface:\n"
  "get_radius(TangentRingEmitter self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_TangentRingEmitter_get_radius_335_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat TangentRingEmitter::get_radius_spread(void) const
 */
static PyObject *Dtool_TangentRingEmitter_get_radius_spread_336(PyObject *self, PyObject *) {
  TangentRingEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TangentRingEmitter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat TangentRingEmitter::get_radius_spread(void) const
  PN_stdfloat return_value = (*(const TangentRingEmitter*)local_this).get_radius_spread();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TangentRingEmitter_get_radius_spread_336_comment =
  "C++ Interface:\n"
  "get_radius_spread(TangentRingEmitter self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_TangentRingEmitter_get_radius_spread_336_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TangentRingEmitter::TangentRingEmitter(void)
 * TangentRingEmitter::TangentRingEmitter(TangentRingEmitter const &copy)
 */
static int Dtool_Init_TangentRingEmitter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-TangentRingEmitter::TangentRingEmitter(void)
      TangentRingEmitter *return_value = new TangentRingEmitter();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TangentRingEmitter, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-TangentRingEmitter::TangentRingEmitter(TangentRingEmitter const &copy)
      TangentRingEmitter const *arg_this = (TangentRingEmitter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TangentRingEmitter, 0, "TangentRingEmitter.TangentRingEmitter", true, true);
      if (arg_this != NULL) {
        TangentRingEmitter *return_value = new TangentRingEmitter(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TangentRingEmitter, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TangentRingEmitter() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TangentRingEmitter()\n"
      "TangentRingEmitter(const TangentRingEmitter copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TangentRingEmitter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TangentRingEmitter) {
    printf("TangentRingEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TangentRingEmitter *local_this = (TangentRingEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TangentRingEmitter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseParticleEmitter) {
    return (BaseParticleEmitter *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseParticleEmitter *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TangentRingEmitter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TangentRingEmitter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseParticleEmitter) {
    BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
    return (TangentRingEmitter*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TangentRingEmitter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ZSpinParticleFactory
 */
/**
 * Python function wrapper for:
 * inline void ZSpinParticleFactory::set_initial_angle(PN_stdfloat angle)
 */
static PyObject *Dtool_ZSpinParticleFactory_set_initial_angle_339(PyObject *self, PyObject *arg) {
  ZSpinParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ZSpinParticleFactory, (void **)&local_this, "ZSpinParticleFactory.set_initial_angle")) {
    return NULL;
  }
  // 1-inline void ZSpinParticleFactory::set_initial_angle(PN_stdfloat angle)
  if (PyNumber_Check(arg)) {
    (*local_this).set_initial_angle((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_initial_angle(const ZSpinParticleFactory self, float angle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ZSpinParticleFactory_set_initial_angle_339_comment =
  "C++ Interface:\n"
  "set_initial_angle(const ZSpinParticleFactory self, float angle)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ZSpinParticleFactory_set_initial_angle_339_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ZSpinParticleFactory::set_final_angle(PN_stdfloat angle)
 */
static PyObject *Dtool_ZSpinParticleFactory_set_final_angle_340(PyObject *self, PyObject *arg) {
  ZSpinParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ZSpinParticleFactory, (void **)&local_this, "ZSpinParticleFactory.set_final_angle")) {
    return NULL;
  }
  // 1-inline void ZSpinParticleFactory::set_final_angle(PN_stdfloat angle)
  if (PyNumber_Check(arg)) {
    (*local_this).set_final_angle((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_final_angle(const ZSpinParticleFactory self, float angle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ZSpinParticleFactory_set_final_angle_340_comment =
  "C++ Interface:\n"
  "set_final_angle(const ZSpinParticleFactory self, float angle)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ZSpinParticleFactory_set_final_angle_340_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ZSpinParticleFactory::set_initial_angle_spread(PN_stdfloat spread)
 */
static PyObject *Dtool_ZSpinParticleFactory_set_initial_angle_spread_341(PyObject *self, PyObject *arg) {
  ZSpinParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ZSpinParticleFactory, (void **)&local_this, "ZSpinParticleFactory.set_initial_angle_spread")) {
    return NULL;
  }
  // 1-inline void ZSpinParticleFactory::set_initial_angle_spread(PN_stdfloat spread)
  if (PyNumber_Check(arg)) {
    (*local_this).set_initial_angle_spread((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_initial_angle_spread(const ZSpinParticleFactory self, float spread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ZSpinParticleFactory_set_initial_angle_spread_341_comment =
  "C++ Interface:\n"
  "set_initial_angle_spread(const ZSpinParticleFactory self, float spread)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ZSpinParticleFactory_set_initial_angle_spread_341_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ZSpinParticleFactory::set_final_angle_spread(PN_stdfloat spread)
 */
static PyObject *Dtool_ZSpinParticleFactory_set_final_angle_spread_342(PyObject *self, PyObject *arg) {
  ZSpinParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ZSpinParticleFactory, (void **)&local_this, "ZSpinParticleFactory.set_final_angle_spread")) {
    return NULL;
  }
  // 1-inline void ZSpinParticleFactory::set_final_angle_spread(PN_stdfloat spread)
  if (PyNumber_Check(arg)) {
    (*local_this).set_final_angle_spread((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_final_angle_spread(const ZSpinParticleFactory self, float spread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ZSpinParticleFactory_set_final_angle_spread_342_comment =
  "C++ Interface:\n"
  "set_final_angle_spread(const ZSpinParticleFactory self, float spread)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ZSpinParticleFactory_set_final_angle_spread_342_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat ZSpinParticleFactory::get_initial_angle(void) const
 */
static PyObject *Dtool_ZSpinParticleFactory_get_initial_angle_343(PyObject *self, PyObject *) {
  ZSpinParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ZSpinParticleFactory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat ZSpinParticleFactory::get_initial_angle(void) const
  PN_stdfloat return_value = (*(const ZSpinParticleFactory*)local_this).get_initial_angle();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ZSpinParticleFactory_get_initial_angle_343_comment =
  "C++ Interface:\n"
  "get_initial_angle(ZSpinParticleFactory self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ZSpinParticleFactory_get_initial_angle_343_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat ZSpinParticleFactory::get_final_angle(void) const
 */
static PyObject *Dtool_ZSpinParticleFactory_get_final_angle_344(PyObject *self, PyObject *) {
  ZSpinParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ZSpinParticleFactory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat ZSpinParticleFactory::get_final_angle(void) const
  PN_stdfloat return_value = (*(const ZSpinParticleFactory*)local_this).get_final_angle();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ZSpinParticleFactory_get_final_angle_344_comment =
  "C++ Interface:\n"
  "get_final_angle(ZSpinParticleFactory self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ZSpinParticleFactory_get_final_angle_344_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat ZSpinParticleFactory::get_initial_angle_spread(void) const
 */
static PyObject *Dtool_ZSpinParticleFactory_get_initial_angle_spread_345(PyObject *self, PyObject *) {
  ZSpinParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ZSpinParticleFactory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat ZSpinParticleFactory::get_initial_angle_spread(void) const
  PN_stdfloat return_value = (*(const ZSpinParticleFactory*)local_this).get_initial_angle_spread();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ZSpinParticleFactory_get_initial_angle_spread_345_comment =
  "C++ Interface:\n"
  "get_initial_angle_spread(ZSpinParticleFactory self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ZSpinParticleFactory_get_initial_angle_spread_345_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat ZSpinParticleFactory::get_final_angle_spread(void) const
 */
static PyObject *Dtool_ZSpinParticleFactory_get_final_angle_spread_346(PyObject *self, PyObject *) {
  ZSpinParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ZSpinParticleFactory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat ZSpinParticleFactory::get_final_angle_spread(void) const
  PN_stdfloat return_value = (*(const ZSpinParticleFactory*)local_this).get_final_angle_spread();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ZSpinParticleFactory_get_final_angle_spread_346_comment =
  "C++ Interface:\n"
  "get_final_angle_spread(ZSpinParticleFactory self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ZSpinParticleFactory_get_final_angle_spread_346_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ZSpinParticleFactory::set_angular_velocity(PN_stdfloat v)
 */
static PyObject *Dtool_ZSpinParticleFactory_set_angular_velocity_347(PyObject *self, PyObject *arg) {
  ZSpinParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ZSpinParticleFactory, (void **)&local_this, "ZSpinParticleFactory.set_angular_velocity")) {
    return NULL;
  }
  // 1-inline void ZSpinParticleFactory::set_angular_velocity(PN_stdfloat v)
  if (PyNumber_Check(arg)) {
    (*local_this).set_angular_velocity((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_angular_velocity(const ZSpinParticleFactory self, float v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ZSpinParticleFactory_set_angular_velocity_347_comment =
  "C++ Interface:\n"
  "set_angular_velocity(const ZSpinParticleFactory self, float v)\n";
#else
static const char *Dtool_ZSpinParticleFactory_set_angular_velocity_347_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat ZSpinParticleFactory::get_angular_velocity(void) const
 */
static PyObject *Dtool_ZSpinParticleFactory_get_angular_velocity_348(PyObject *self, PyObject *) {
  ZSpinParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ZSpinParticleFactory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat ZSpinParticleFactory::get_angular_velocity(void) const
  PN_stdfloat return_value = (*(const ZSpinParticleFactory*)local_this).get_angular_velocity();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ZSpinParticleFactory_get_angular_velocity_348_comment =
  "C++ Interface:\n"
  "get_angular_velocity(ZSpinParticleFactory self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ZSpinParticleFactory_get_angular_velocity_348_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ZSpinParticleFactory::set_angular_velocity_spread(PN_stdfloat spread)
 */
static PyObject *Dtool_ZSpinParticleFactory_set_angular_velocity_spread_349(PyObject *self, PyObject *arg) {
  ZSpinParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ZSpinParticleFactory, (void **)&local_this, "ZSpinParticleFactory.set_angular_velocity_spread")) {
    return NULL;
  }
  // 1-inline void ZSpinParticleFactory::set_angular_velocity_spread(PN_stdfloat spread)
  if (PyNumber_Check(arg)) {
    (*local_this).set_angular_velocity_spread((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_angular_velocity_spread(const ZSpinParticleFactory self, float spread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ZSpinParticleFactory_set_angular_velocity_spread_349_comment =
  "C++ Interface:\n"
  "set_angular_velocity_spread(const ZSpinParticleFactory self, float spread)\n";
#else
static const char *Dtool_ZSpinParticleFactory_set_angular_velocity_spread_349_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat ZSpinParticleFactory::get_angular_velocity_spread(void) const
 */
static PyObject *Dtool_ZSpinParticleFactory_get_angular_velocity_spread_350(PyObject *self, PyObject *) {
  ZSpinParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ZSpinParticleFactory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat ZSpinParticleFactory::get_angular_velocity_spread(void) const
  PN_stdfloat return_value = (*(const ZSpinParticleFactory*)local_this).get_angular_velocity_spread();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ZSpinParticleFactory_get_angular_velocity_spread_350_comment =
  "C++ Interface:\n"
  "get_angular_velocity_spread(ZSpinParticleFactory self)\n";
#else
static const char *Dtool_ZSpinParticleFactory_get_angular_velocity_spread_350_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ZSpinParticleFactory::enable_angular_velocity(bool bEnabled)
 */
static PyObject *Dtool_ZSpinParticleFactory_enable_angular_velocity_351(PyObject *self, PyObject *arg) {
  ZSpinParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ZSpinParticleFactory, (void **)&local_this, "ZSpinParticleFactory.enable_angular_velocity")) {
    return NULL;
  }
  // 1-inline void ZSpinParticleFactory::enable_angular_velocity(bool bEnabled)
  (*local_this).enable_angular_velocity((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "enable_angular_velocity(const ZSpinParticleFactory self, bool bEnabled)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ZSpinParticleFactory_enable_angular_velocity_351_comment =
  "C++ Interface:\n"
  "enable_angular_velocity(const ZSpinParticleFactory self, bool bEnabled)\n";
#else
static const char *Dtool_ZSpinParticleFactory_enable_angular_velocity_351_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ZSpinParticleFactory::get_angular_velocity_enabled(void) const
 */
static PyObject *Dtool_ZSpinParticleFactory_get_angular_velocity_enabled_352(PyObject *self, PyObject *) {
  ZSpinParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ZSpinParticleFactory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ZSpinParticleFactory::get_angular_velocity_enabled(void) const
  bool return_value = (*(const ZSpinParticleFactory*)local_this).get_angular_velocity_enabled();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ZSpinParticleFactory_get_angular_velocity_enabled_352_comment =
  "C++ Interface:\n"
  "get_angular_velocity_enabled(ZSpinParticleFactory self)\n";
#else
static const char *Dtool_ZSpinParticleFactory_get_angular_velocity_enabled_352_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ZSpinParticleFactory::ZSpinParticleFactory(void)
 * ZSpinParticleFactory::ZSpinParticleFactory(ZSpinParticleFactory const &copy)
 */
static int Dtool_Init_ZSpinParticleFactory(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-ZSpinParticleFactory::ZSpinParticleFactory(void)
      ZSpinParticleFactory *return_value = new ZSpinParticleFactory();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ZSpinParticleFactory, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-ZSpinParticleFactory::ZSpinParticleFactory(ZSpinParticleFactory const &copy)
      ZSpinParticleFactory const *arg_this = (ZSpinParticleFactory *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ZSpinParticleFactory, 0, "ZSpinParticleFactory.ZSpinParticleFactory", true, true);
      if (arg_this != NULL) {
        ZSpinParticleFactory *return_value = new ZSpinParticleFactory(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ZSpinParticleFactory, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ZSpinParticleFactory() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ZSpinParticleFactory()\n"
      "ZSpinParticleFactory(const ZSpinParticleFactory copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ZSpinParticleFactory(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ZSpinParticleFactory) {
    printf("ZSpinParticleFactory ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ZSpinParticleFactory *local_this = (ZSpinParticleFactory *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ZSpinParticleFactory) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseParticleFactory) {
    return (BaseParticleFactory *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseParticleFactory *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ZSpinParticleFactory(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ZSpinParticleFactory) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseParticleFactory) {
    BaseParticleFactory* other_this = (BaseParticleFactory*)from_this;
    return (ZSpinParticleFactory*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ZSpinParticleFactory*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ParticleSystemManager
 */
/**
 * Python function wrapper for:
 * inline void ParticleSystemManager::set_frame_stepping(int every_nth_frame)
 */
static PyObject *Dtool_ParticleSystemManager_set_frame_stepping_356(PyObject *self, PyObject *arg) {
  ParticleSystemManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystemManager, (void **)&local_this, "ParticleSystemManager.set_frame_stepping")) {
    return NULL;
  }
  // 1-inline void ParticleSystemManager::set_frame_stepping(int every_nth_frame)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_frame_stepping((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_stepping(const ParticleSystemManager self, int every_nth_frame)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystemManager_set_frame_stepping_356_comment =
  "C++ Interface:\n"
  "set_frame_stepping(const ParticleSystemManager self, int every_nth_frame)\n";
#else
static const char *Dtool_ParticleSystemManager_set_frame_stepping_356_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ParticleSystemManager::get_frame_stepping(void) const
 */
static PyObject *Dtool_ParticleSystemManager_get_frame_stepping_357(PyObject *self, PyObject *) {
  ParticleSystemManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystemManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ParticleSystemManager::get_frame_stepping(void) const
  int return_value = (*(const ParticleSystemManager*)local_this).get_frame_stepping();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystemManager_get_frame_stepping_357_comment =
  "C++ Interface:\n"
  "get_frame_stepping(ParticleSystemManager self)\n";
#else
static const char *Dtool_ParticleSystemManager_get_frame_stepping_357_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystemManager::attach_particlesystem(ParticleSystem *ps)
 */
static PyObject *Dtool_ParticleSystemManager_attach_particlesystem_358(PyObject *self, PyObject *arg) {
  ParticleSystemManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystemManager, (void **)&local_this, "ParticleSystemManager.attach_particlesystem")) {
    return NULL;
  }
  // 1-inline void ParticleSystemManager::attach_particlesystem(ParticleSystem *ps)
  PT(ParticleSystem) arg_this;
  if (!Dtool_Coerce_ParticleSystem(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParticleSystemManager.attach_particlesystem", "ParticleSystem");
  }
  (*local_this).attach_particlesystem(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach_particlesystem(const ParticleSystemManager self, ParticleSystem ps)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystemManager_attach_particlesystem_358_comment =
  "C++ Interface:\n"
  "attach_particlesystem(const ParticleSystemManager self, ParticleSystem ps)\n";
#else
static const char *Dtool_ParticleSystemManager_attach_particlesystem_358_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ParticleSystemManager::remove_particlesystem(ParticleSystem *ps)
 */
static PyObject *Dtool_ParticleSystemManager_remove_particlesystem_359(PyObject *self, PyObject *arg) {
  ParticleSystemManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystemManager, (void **)&local_this, "ParticleSystemManager.remove_particlesystem")) {
    return NULL;
  }
  // 1-void ParticleSystemManager::remove_particlesystem(ParticleSystem *ps)
  PT(ParticleSystem) arg_this;
  if (!Dtool_Coerce_ParticleSystem(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParticleSystemManager.remove_particlesystem", "ParticleSystem");
  }
  (*local_this).remove_particlesystem(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_particlesystem(const ParticleSystemManager self, ParticleSystem ps)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystemManager_remove_particlesystem_359_comment =
  "C++ Interface:\n"
  "remove_particlesystem(const ParticleSystemManager self, ParticleSystem ps)\n"
  "\n"
  "/**\n"
  " * removes a ps from the maintenance list\n"
  " */";
#else
static const char *Dtool_ParticleSystemManager_remove_particlesystem_359_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ParticleSystemManager::clear(void)
 */
static PyObject *Dtool_ParticleSystemManager_clear_360(PyObject *self, PyObject *) {
  ParticleSystemManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystemManager, (void **)&local_this, "ParticleSystemManager.clear")) {
    return NULL;
  }
  // 1-inline void ParticleSystemManager::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystemManager_clear_360_comment =
  "C++ Interface:\n"
  "clear(const ParticleSystemManager self)\n";
#else
static const char *Dtool_ParticleSystemManager_clear_360_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ParticleSystemManager::do_particles(PN_stdfloat dt)
 * void ParticleSystemManager::do_particles(PN_stdfloat dt, ParticleSystem *ps, bool do_render = true)
 */
static PyObject *Dtool_ParticleSystemManager_do_particles_361(PyObject *self, PyObject *args, PyObject *kwds) {
  ParticleSystemManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParticleSystemManager, (void **)&local_this, "ParticleSystemManager.do_particles")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "dt");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'dt' (pos 1) not found");
      }
      // 1-void ParticleSystemManager::do_particles(PN_stdfloat dt)
      if (PyNumber_Check(arg)) {
        (*local_this).do_particles((PN_stdfloat)PyFloat_AsDouble(arg));
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
  case 3:
    {
      // 1-void ParticleSystemManager::do_particles(PN_stdfloat dt, ParticleSystem *ps, bool do_render = true)
      float param1;
      PyObject *param2;
      PyObject *param3 = Py_True;
      static const char *keyword_list[] = {"dt", "ps", "do_render", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fO|O:do_particles", (char **)keyword_list, &param1, &param2, &param3)) {
        PT(ParticleSystem) param2_this;
        if (!Dtool_Coerce_ParticleSystem(param2, param2_this)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "ParticleSystemManager.do_particles", "ParticleSystem");
        }
        (*local_this).do_particles((PN_stdfloat)param1, MOVE(param2_this), (PyObject_IsTrue(param3) != 0));
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "do_particles() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "do_particles(const ParticleSystemManager self, float dt)\n"
      "do_particles(const ParticleSystemManager self, float dt, ParticleSystem ps, bool do_render)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystemManager_do_particles_361_comment =
  "C++ Interface:\n"
  "do_particles(const ParticleSystemManager self, float dt)\n"
  "do_particles(const ParticleSystemManager self, float dt, ParticleSystem ps, bool do_render)\n"
  "\n"
  "/**\n"
  " * does an update and render for each ps in the list.  this is probably the\n"
  " * one you want to use.  Rendering is the expensive operation, and particles\n"
  " * REALLY should at least be updated every frame, so nth_frame stepping\n"
  " * applies only to rendering.\n"
  " */\n"
  "\n"
  "/**\n"
  " * does an update and an optional render for a specific ps.  Since rendering\n"
  " * is the expensive operation, multiple updates could be applied before\n"
  " * calling the final render.\n"
  " */";
#else
static const char *Dtool_ParticleSystemManager_do_particles_361_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void ParticleSystemManager::output(ostream &out) const
 */
static PyObject *Dtool_ParticleSystemManager_output_362(PyObject *self, PyObject *arg) {
  ParticleSystemManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystemManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void ParticleSystemManager::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ParticleSystemManager.output", false, true);
  if (arg_this != NULL) {
    (*(const ParticleSystemManager*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ParticleSystemManager self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystemManager_output_362_comment =
  "C++ Interface:\n"
  "output(ParticleSystemManager self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_ParticleSystemManager_output_362_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void ParticleSystemManager::write_ps_list(ostream &out, int indent = 0) const
 */
static PyObject *Dtool_ParticleSystemManager_write_ps_list_363(PyObject *self, PyObject *args, PyObject *kwds) {
  ParticleSystemManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystemManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void ParticleSystemManager::write_ps_list(ostream &out, int indent = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write_ps_list", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "ParticleSystemManager.write_ps_list", false, true);
    if (param1_this != NULL) {
      (*(const ParticleSystemManager*)local_this).write_ps_list(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_ps_list(ParticleSystemManager self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystemManager_write_ps_list_363_comment =
  "C++ Interface:\n"
  "write_ps_list(ParticleSystemManager self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_ParticleSystemManager_write_ps_list_363_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void ParticleSystemManager::write(ostream &out, int indent = 0) const
 */
static PyObject *Dtool_ParticleSystemManager_write_364(PyObject *self, PyObject *args, PyObject *kwds) {
  ParticleSystemManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystemManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void ParticleSystemManager::write(ostream &out, int indent = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "ParticleSystemManager.write", false, true);
    if (param1_this != NULL) {
      (*(const ParticleSystemManager*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ParticleSystemManager self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ParticleSystemManager_write_364_comment =
  "C++ Interface:\n"
  "write(ParticleSystemManager self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_ParticleSystemManager_write_364_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ParticleSystemManager::ParticleSystemManager(ParticleSystemManager const &) = default
 * ParticleSystemManager::ParticleSystemManager(int every_nth_frame = 1)
 */
static int Dtool_Init_ParticleSystemManager(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-ParticleSystemManager::ParticleSystemManager(int every_nth_frame)
      ParticleSystemManager *return_value = new ParticleSystemManager();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParticleSystemManager, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline ParticleSystemManager::ParticleSystemManager(ParticleSystemManager const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ParticleSystemManager", (char **)keyword_list, &param0)) {
          ParticleSystemManager const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ParticleSystemManager, (void **)&param0_this);
          if (param0_this != NULL) {
            ParticleSystemManager *return_value = new ParticleSystemManager(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParticleSystemManager, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 ParticleSystemManager::ParticleSystemManager(int every_nth_frame)
        int param0;
        static const char *keyword_list[] = {"every_nth_frame", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:ParticleSystemManager", (char **)keyword_list, &param0)) {
          ParticleSystemManager *return_value = new ParticleSystemManager((int)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParticleSystemManager, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ParticleSystemManager::ParticleSystemManager(ParticleSystemManager const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ParticleSystemManager", (char **)keyword_list, &param0)) {
          ParticleSystemManager const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_ParticleSystemManager(param0, param0_this, param0_manage)) {
            ParticleSystemManager *return_value = new ParticleSystemManager(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParticleSystemManager, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: ParticleSystemManager::ParticleSystemManager(int every_nth_frame)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ParticleSystemManager() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParticleSystemManager()\n"
      "ParticleSystemManager(const ParticleSystemManager param0)\n"
      "ParticleSystemManager(int every_nth_frame)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParticleSystemManager(PyObject *args, ParticleSystemManager const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParticleSystemManager, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ParticleSystemManager::ParticleSystemManager(int every_nth_frame)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      ParticleSystemManager *return_value = new ParticleSystemManager((int)arg_val);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParticleSystemManager(PyObject *args, ParticleSystemManager *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ParticleSystemManager, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ParticleSystemManager::ParticleSystemManager(int every_nth_frame)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      ParticleSystemManager *return_value = new ParticleSystemManager((int)arg_val);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParticleSystemManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ParticleSystemManager) {
    printf("ParticleSystemManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ParticleSystemManager *local_this = (ParticleSystemManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ParticleSystemManager) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ParticleSystemManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ParticleSystemManager) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for BaseParticleEmitter (BaseParticleEmitter)
 */
static PyMethodDef Dtool_Methods_BaseParticleEmitter[] = {
  {"make_copy", &Dtool_BaseParticleEmitter_make_copy_4, METH_NOARGS, (const char *)Dtool_BaseParticleEmitter_make_copy_4_comment},
  {"makeCopy", &Dtool_BaseParticleEmitter_make_copy_4, METH_NOARGS, (const char *)Dtool_BaseParticleEmitter_make_copy_4_comment},
  {"generate", (PyCFunction) &Dtool_BaseParticleEmitter_generate_5, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BaseParticleEmitter_generate_5_comment},
  {"set_emission_type", &Dtool_BaseParticleEmitter_set_emission_type_6, METH_O, (const char *)Dtool_BaseParticleEmitter_set_emission_type_6_comment},
  {"setEmissionType", &Dtool_BaseParticleEmitter_set_emission_type_6, METH_O, (const char *)Dtool_BaseParticleEmitter_set_emission_type_6_comment},
  {"set_amplitude", &Dtool_BaseParticleEmitter_set_amplitude_7, METH_O, (const char *)Dtool_BaseParticleEmitter_set_amplitude_7_comment},
  {"setAmplitude", &Dtool_BaseParticleEmitter_set_amplitude_7, METH_O, (const char *)Dtool_BaseParticleEmitter_set_amplitude_7_comment},
  {"set_amplitude_spread", &Dtool_BaseParticleEmitter_set_amplitude_spread_8, METH_O, (const char *)Dtool_BaseParticleEmitter_set_amplitude_spread_8_comment},
  {"setAmplitudeSpread", &Dtool_BaseParticleEmitter_set_amplitude_spread_8, METH_O, (const char *)Dtool_BaseParticleEmitter_set_amplitude_spread_8_comment},
  {"set_offset_force", &Dtool_BaseParticleEmitter_set_offset_force_9, METH_O, (const char *)Dtool_BaseParticleEmitter_set_offset_force_9_comment},
  {"setOffsetForce", &Dtool_BaseParticleEmitter_set_offset_force_9, METH_O, (const char *)Dtool_BaseParticleEmitter_set_offset_force_9_comment},
  {"set_explicit_launch_vector", &Dtool_BaseParticleEmitter_set_explicit_launch_vector_10, METH_O, (const char *)Dtool_BaseParticleEmitter_set_explicit_launch_vector_10_comment},
  {"setExplicitLaunchVector", &Dtool_BaseParticleEmitter_set_explicit_launch_vector_10, METH_O, (const char *)Dtool_BaseParticleEmitter_set_explicit_launch_vector_10_comment},
  {"set_radiate_origin", &Dtool_BaseParticleEmitter_set_radiate_origin_11, METH_O, (const char *)Dtool_BaseParticleEmitter_set_radiate_origin_11_comment},
  {"setRadiateOrigin", &Dtool_BaseParticleEmitter_set_radiate_origin_11, METH_O, (const char *)Dtool_BaseParticleEmitter_set_radiate_origin_11_comment},
  {"get_emission_type", &Dtool_BaseParticleEmitter_get_emission_type_12, METH_NOARGS, (const char *)Dtool_BaseParticleEmitter_get_emission_type_12_comment},
  {"getEmissionType", &Dtool_BaseParticleEmitter_get_emission_type_12, METH_NOARGS, (const char *)Dtool_BaseParticleEmitter_get_emission_type_12_comment},
  {"get_amplitude", &Dtool_BaseParticleEmitter_get_amplitude_13, METH_NOARGS, (const char *)Dtool_BaseParticleEmitter_get_amplitude_13_comment},
  {"getAmplitude", &Dtool_BaseParticleEmitter_get_amplitude_13, METH_NOARGS, (const char *)Dtool_BaseParticleEmitter_get_amplitude_13_comment},
  {"get_amplitude_spread", &Dtool_BaseParticleEmitter_get_amplitude_spread_14, METH_NOARGS, (const char *)Dtool_BaseParticleEmitter_get_amplitude_spread_14_comment},
  {"getAmplitudeSpread", &Dtool_BaseParticleEmitter_get_amplitude_spread_14, METH_NOARGS, (const char *)Dtool_BaseParticleEmitter_get_amplitude_spread_14_comment},
  {"get_offset_force", &Dtool_BaseParticleEmitter_get_offset_force_15, METH_NOARGS, (const char *)Dtool_BaseParticleEmitter_get_offset_force_15_comment},
  {"getOffsetForce", &Dtool_BaseParticleEmitter_get_offset_force_15, METH_NOARGS, (const char *)Dtool_BaseParticleEmitter_get_offset_force_15_comment},
  {"get_explicit_launch_vector", &Dtool_BaseParticleEmitter_get_explicit_launch_vector_16, METH_NOARGS, (const char *)Dtool_BaseParticleEmitter_get_explicit_launch_vector_16_comment},
  {"getExplicitLaunchVector", &Dtool_BaseParticleEmitter_get_explicit_launch_vector_16, METH_NOARGS, (const char *)Dtool_BaseParticleEmitter_get_explicit_launch_vector_16_comment},
  {"get_radiate_origin", &Dtool_BaseParticleEmitter_get_radiate_origin_17, METH_NOARGS, (const char *)Dtool_BaseParticleEmitter_get_radiate_origin_17_comment},
  {"getRadiateOrigin", &Dtool_BaseParticleEmitter_get_radiate_origin_17, METH_NOARGS, (const char *)Dtool_BaseParticleEmitter_get_radiate_origin_17_comment},
  {"output", &Dtool_BaseParticleEmitter_output_18, METH_O, (const char *)Dtool_BaseParticleEmitter_output_18_comment},
  {"write", (PyCFunction) &Dtool_BaseParticleEmitter_write_19, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BaseParticleEmitter_write_19_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     BaseParticleEmitter
//////////////////
static PyObject *Dtool_Repr_BaseParticleEmitter(PyObject *self) {
  BaseParticleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleEmitter, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     BaseParticleEmitter
//////////////////
static PyObject *Dtool_Str_BaseParticleEmitter(PyObject *self) {
  BaseParticleEmitter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleEmitter, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_BaseParticleEmitter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BaseParticleEmitter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_BaseParticleEmitter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_BaseParticleEmitter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_BaseParticleEmitter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.BaseParticleEmitter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BaseParticleEmitter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_BaseParticleEmitter,
    &Dtool_NumberMethods_BaseParticleEmitter,
    &Dtool_SequenceMethods_BaseParticleEmitter,
    &Dtool_MappingMethods_BaseParticleEmitter,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_BaseParticleEmitter,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_BaseParticleEmitter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BaseParticleEmitter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BaseParticleEmitter,
    PyType_GenericAlloc,
    Dtool_new_BaseParticleEmitter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BaseParticleEmitter,
  Dtool_UpcastInterface_BaseParticleEmitter,
  Dtool_DowncastInterface_BaseParticleEmitter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_BaseParticleEmitter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_BaseParticleEmitter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_BaseParticleEmitter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum BaseParticleEmitter::emissionType;
    PyDict_SetItemString(dict, "ET_EXPLICIT", Dtool_WrapValue(BaseParticleEmitter::ET_EXPLICIT));
    PyDict_SetItemString(dict, "ETEXPLICIT", Dtool_WrapValue(BaseParticleEmitter::ET_EXPLICIT));
    PyDict_SetItemString(dict, "ET_RADIATE", Dtool_WrapValue(BaseParticleEmitter::ET_RADIATE));
    PyDict_SetItemString(dict, "ETRADIATE", Dtool_WrapValue(BaseParticleEmitter::ET_RADIATE));
    PyDict_SetItemString(dict, "ET_CUSTOM", Dtool_WrapValue(BaseParticleEmitter::ET_CUSTOM));
    PyDict_SetItemString(dict, "ETCUSTOM", Dtool_WrapValue(BaseParticleEmitter::ET_CUSTOM));
    if (PyType_Ready((PyTypeObject *)&Dtool_BaseParticleEmitter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BaseParticleEmitter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BaseParticleEmitter);
  }
}

/**
 * Python method tables for RingEmitter (RingEmitter)
 */
static PyMethodDef Dtool_Methods_RingEmitter[] = {
  {"set_radius", &Dtool_RingEmitter_set_radius_22, METH_O, (const char *)Dtool_RingEmitter_set_radius_22_comment},
  {"setRadius", &Dtool_RingEmitter_set_radius_22, METH_O, (const char *)Dtool_RingEmitter_set_radius_22_comment},
  {"set_angle", &Dtool_RingEmitter_set_angle_23, METH_O, (const char *)Dtool_RingEmitter_set_angle_23_comment},
  {"setAngle", &Dtool_RingEmitter_set_angle_23, METH_O, (const char *)Dtool_RingEmitter_set_angle_23_comment},
  {"set_radius_spread", &Dtool_RingEmitter_set_radius_spread_24, METH_O, (const char *)Dtool_RingEmitter_set_radius_spread_24_comment},
  {"setRadiusSpread", &Dtool_RingEmitter_set_radius_spread_24, METH_O, (const char *)Dtool_RingEmitter_set_radius_spread_24_comment},
  {"set_uniform_emission", &Dtool_RingEmitter_set_uniform_emission_25, METH_O, (const char *)Dtool_RingEmitter_set_uniform_emission_25_comment},
  {"setUniformEmission", &Dtool_RingEmitter_set_uniform_emission_25, METH_O, (const char *)Dtool_RingEmitter_set_uniform_emission_25_comment},
  {"get_radius", &Dtool_RingEmitter_get_radius_26, METH_NOARGS, (const char *)Dtool_RingEmitter_get_radius_26_comment},
  {"getRadius", &Dtool_RingEmitter_get_radius_26, METH_NOARGS, (const char *)Dtool_RingEmitter_get_radius_26_comment},
  {"get_angle", &Dtool_RingEmitter_get_angle_27, METH_NOARGS, (const char *)Dtool_RingEmitter_get_angle_27_comment},
  {"getAngle", &Dtool_RingEmitter_get_angle_27, METH_NOARGS, (const char *)Dtool_RingEmitter_get_angle_27_comment},
  {"get_radius_spread", &Dtool_RingEmitter_get_radius_spread_28, METH_NOARGS, (const char *)Dtool_RingEmitter_get_radius_spread_28_comment},
  {"getRadiusSpread", &Dtool_RingEmitter_get_radius_spread_28, METH_NOARGS, (const char *)Dtool_RingEmitter_get_radius_spread_28_comment},
  {"get_uniform_emission", &Dtool_RingEmitter_get_uniform_emission_29, METH_NOARGS, (const char *)Dtool_RingEmitter_get_uniform_emission_29_comment},
  {"getUniformEmission", &Dtool_RingEmitter_get_uniform_emission_29, METH_NOARGS, (const char *)Dtool_RingEmitter_get_uniform_emission_29_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_RingEmitter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RingEmitter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_RingEmitter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_RingEmitter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_RingEmitter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.RingEmitter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_RingEmitter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_RingEmitter,
    &Dtool_SequenceMethods_RingEmitter,
    &Dtool_MappingMethods_RingEmitter,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_RingEmitter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Describes a planar ring region in which particles are generated.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_RingEmitter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_RingEmitter,
    PyType_GenericAlloc,
    Dtool_new_RingEmitter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RingEmitter,
  Dtool_UpcastInterface_RingEmitter,
  Dtool_DowncastInterface_RingEmitter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_RingEmitter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseParticleEmitter(NULL);
    Dtool_RingEmitter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseParticleEmitter);
    PyObject *dict = PyDict_New();
    Dtool_RingEmitter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RingEmitter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RingEmitter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RingEmitter);
  }
}

/**
 * Python method tables for ArcEmitter (ArcEmitter)
 */
static PyMethodDef Dtool_Methods_ArcEmitter[] = {
  {"set_start_angle", &Dtool_ArcEmitter_set_start_angle_32, METH_O, (const char *)Dtool_ArcEmitter_set_start_angle_32_comment},
  {"setStartAngle", &Dtool_ArcEmitter_set_start_angle_32, METH_O, (const char *)Dtool_ArcEmitter_set_start_angle_32_comment},
  {"set_end_angle", &Dtool_ArcEmitter_set_end_angle_33, METH_O, (const char *)Dtool_ArcEmitter_set_end_angle_33_comment},
  {"setEndAngle", &Dtool_ArcEmitter_set_end_angle_33, METH_O, (const char *)Dtool_ArcEmitter_set_end_angle_33_comment},
  {"set_arc", (PyCFunction) &Dtool_ArcEmitter_set_arc_34, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ArcEmitter_set_arc_34_comment},
  {"setArc", (PyCFunction) &Dtool_ArcEmitter_set_arc_34, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ArcEmitter_set_arc_34_comment},
  {"get_start_angle", &Dtool_ArcEmitter_get_start_angle_35, METH_NOARGS, (const char *)Dtool_ArcEmitter_get_start_angle_35_comment},
  {"getStartAngle", &Dtool_ArcEmitter_get_start_angle_35, METH_NOARGS, (const char *)Dtool_ArcEmitter_get_start_angle_35_comment},
  {"get_end_angle", &Dtool_ArcEmitter_get_end_angle_36, METH_NOARGS, (const char *)Dtool_ArcEmitter_get_end_angle_36_comment},
  {"getEndAngle", &Dtool_ArcEmitter_get_end_angle_36, METH_NOARGS, (const char *)Dtool_ArcEmitter_get_end_angle_36_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ArcEmitter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ArcEmitter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ArcEmitter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ArcEmitter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ArcEmitter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.ArcEmitter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ArcEmitter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ArcEmitter,
    &Dtool_SequenceMethods_ArcEmitter,
    &Dtool_MappingMethods_ArcEmitter,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ArcEmitter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Describes a planar ring region in which particles are generated.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ArcEmitter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ArcEmitter,
    PyType_GenericAlloc,
    Dtool_new_ArcEmitter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ArcEmitter,
  Dtool_UpcastInterface_ArcEmitter,
  Dtool_DowncastInterface_ArcEmitter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ArcEmitter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RingEmitter(NULL);
    Dtool_ArcEmitter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RingEmitter);
    PyObject *dict = PyDict_New();
    Dtool_ArcEmitter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ArcEmitter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ArcEmitter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ArcEmitter);
  }
}

/**
 * Python method tables for BaseParticleFactory (BaseParticleFactory)
 */
static PyMethodDef Dtool_Methods_BaseParticleFactory[] = {
  {"set_lifespan_base", &Dtool_BaseParticleFactory_set_lifespan_base_38, METH_O, (const char *)Dtool_BaseParticleFactory_set_lifespan_base_38_comment},
  {"setLifespanBase", &Dtool_BaseParticleFactory_set_lifespan_base_38, METH_O, (const char *)Dtool_BaseParticleFactory_set_lifespan_base_38_comment},
  {"set_lifespan_spread", &Dtool_BaseParticleFactory_set_lifespan_spread_39, METH_O, (const char *)Dtool_BaseParticleFactory_set_lifespan_spread_39_comment},
  {"setLifespanSpread", &Dtool_BaseParticleFactory_set_lifespan_spread_39, METH_O, (const char *)Dtool_BaseParticleFactory_set_lifespan_spread_39_comment},
  {"set_mass_base", &Dtool_BaseParticleFactory_set_mass_base_40, METH_O, (const char *)Dtool_BaseParticleFactory_set_mass_base_40_comment},
  {"setMassBase", &Dtool_BaseParticleFactory_set_mass_base_40, METH_O, (const char *)Dtool_BaseParticleFactory_set_mass_base_40_comment},
  {"set_mass_spread", &Dtool_BaseParticleFactory_set_mass_spread_41, METH_O, (const char *)Dtool_BaseParticleFactory_set_mass_spread_41_comment},
  {"setMassSpread", &Dtool_BaseParticleFactory_set_mass_spread_41, METH_O, (const char *)Dtool_BaseParticleFactory_set_mass_spread_41_comment},
  {"set_terminal_velocity_base", &Dtool_BaseParticleFactory_set_terminal_velocity_base_42, METH_O, (const char *)Dtool_BaseParticleFactory_set_terminal_velocity_base_42_comment},
  {"setTerminalVelocityBase", &Dtool_BaseParticleFactory_set_terminal_velocity_base_42, METH_O, (const char *)Dtool_BaseParticleFactory_set_terminal_velocity_base_42_comment},
  {"set_terminal_velocity_spread", &Dtool_BaseParticleFactory_set_terminal_velocity_spread_43, METH_O, (const char *)Dtool_BaseParticleFactory_set_terminal_velocity_spread_43_comment},
  {"setTerminalVelocitySpread", &Dtool_BaseParticleFactory_set_terminal_velocity_spread_43, METH_O, (const char *)Dtool_BaseParticleFactory_set_terminal_velocity_spread_43_comment},
  {"get_lifespan_base", &Dtool_BaseParticleFactory_get_lifespan_base_44, METH_NOARGS, (const char *)Dtool_BaseParticleFactory_get_lifespan_base_44_comment},
  {"getLifespanBase", &Dtool_BaseParticleFactory_get_lifespan_base_44, METH_NOARGS, (const char *)Dtool_BaseParticleFactory_get_lifespan_base_44_comment},
  {"get_lifespan_spread", &Dtool_BaseParticleFactory_get_lifespan_spread_45, METH_NOARGS, (const char *)Dtool_BaseParticleFactory_get_lifespan_spread_45_comment},
  {"getLifespanSpread", &Dtool_BaseParticleFactory_get_lifespan_spread_45, METH_NOARGS, (const char *)Dtool_BaseParticleFactory_get_lifespan_spread_45_comment},
  {"get_mass_base", &Dtool_BaseParticleFactory_get_mass_base_46, METH_NOARGS, (const char *)Dtool_BaseParticleFactory_get_mass_base_46_comment},
  {"getMassBase", &Dtool_BaseParticleFactory_get_mass_base_46, METH_NOARGS, (const char *)Dtool_BaseParticleFactory_get_mass_base_46_comment},
  {"get_mass_spread", &Dtool_BaseParticleFactory_get_mass_spread_47, METH_NOARGS, (const char *)Dtool_BaseParticleFactory_get_mass_spread_47_comment},
  {"getMassSpread", &Dtool_BaseParticleFactory_get_mass_spread_47, METH_NOARGS, (const char *)Dtool_BaseParticleFactory_get_mass_spread_47_comment},
  {"get_terminal_velocity_base", &Dtool_BaseParticleFactory_get_terminal_velocity_base_48, METH_NOARGS, (const char *)Dtool_BaseParticleFactory_get_terminal_velocity_base_48_comment},
  {"getTerminalVelocityBase", &Dtool_BaseParticleFactory_get_terminal_velocity_base_48, METH_NOARGS, (const char *)Dtool_BaseParticleFactory_get_terminal_velocity_base_48_comment},
  {"get_terminal_velocity_spread", &Dtool_BaseParticleFactory_get_terminal_velocity_spread_49, METH_NOARGS, (const char *)Dtool_BaseParticleFactory_get_terminal_velocity_spread_49_comment},
  {"getTerminalVelocitySpread", &Dtool_BaseParticleFactory_get_terminal_velocity_spread_49, METH_NOARGS, (const char *)Dtool_BaseParticleFactory_get_terminal_velocity_spread_49_comment},
  {"output", &Dtool_BaseParticleFactory_output_52, METH_O, (const char *)Dtool_BaseParticleFactory_output_52_comment},
  {"write", (PyCFunction) &Dtool_BaseParticleFactory_write_53, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BaseParticleFactory_write_53_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     BaseParticleFactory
//////////////////
static PyObject *Dtool_Repr_BaseParticleFactory(PyObject *self) {
  BaseParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleFactory, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     BaseParticleFactory
//////////////////
static PyObject *Dtool_Str_BaseParticleFactory(PyObject *self) {
  BaseParticleFactory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleFactory, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_BaseParticleFactory = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BaseParticleFactory = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_BaseParticleFactory = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_BaseParticleFactory = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_BaseParticleFactory = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.BaseParticleFactory",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BaseParticleFactory,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_BaseParticleFactory,
    &Dtool_NumberMethods_BaseParticleFactory,
    &Dtool_SequenceMethods_BaseParticleFactory,
    &Dtool_MappingMethods_BaseParticleFactory,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_BaseParticleFactory,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_BaseParticleFactory,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Pure Virtual base class for creating particles\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BaseParticleFactory,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BaseParticleFactory,
    PyType_GenericAlloc,
    Dtool_new_BaseParticleFactory,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BaseParticleFactory,
  Dtool_UpcastInterface_BaseParticleFactory,
  Dtool_DowncastInterface_BaseParticleFactory,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_BaseParticleFactory(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_BaseParticleFactory._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_BaseParticleFactory._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BaseParticleFactory) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BaseParticleFactory)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BaseParticleFactory);
  }
}

/**
 * Python method tables for BaseParticleRenderer (BaseParticleRenderer)
 */
static PyMethodDef Dtool_Methods_BaseParticleRenderer[] = {
  {"get_render_node", &Dtool_BaseParticleRenderer_get_render_node_57, METH_NOARGS, (const char *)Dtool_BaseParticleRenderer_get_render_node_57_comment},
  {"getRenderNode", &Dtool_BaseParticleRenderer_get_render_node_57, METH_NOARGS, (const char *)Dtool_BaseParticleRenderer_get_render_node_57_comment},
  {"get_render_node_path", &Dtool_BaseParticleRenderer_get_render_node_path_58, METH_NOARGS, (const char *)Dtool_BaseParticleRenderer_get_render_node_path_58_comment},
  {"getRenderNodePath", &Dtool_BaseParticleRenderer_get_render_node_path_58, METH_NOARGS, (const char *)Dtool_BaseParticleRenderer_get_render_node_path_58_comment},
  {"set_alpha_mode", &Dtool_BaseParticleRenderer_set_alpha_mode_59, METH_O, (const char *)Dtool_BaseParticleRenderer_set_alpha_mode_59_comment},
  {"setAlphaMode", &Dtool_BaseParticleRenderer_set_alpha_mode_59, METH_O, (const char *)Dtool_BaseParticleRenderer_set_alpha_mode_59_comment},
  {"get_alpha_mode", &Dtool_BaseParticleRenderer_get_alpha_mode_60, METH_NOARGS, (const char *)Dtool_BaseParticleRenderer_get_alpha_mode_60_comment},
  {"getAlphaMode", &Dtool_BaseParticleRenderer_get_alpha_mode_60, METH_NOARGS, (const char *)Dtool_BaseParticleRenderer_get_alpha_mode_60_comment},
  {"set_user_alpha", &Dtool_BaseParticleRenderer_set_user_alpha_61, METH_O, (const char *)Dtool_BaseParticleRenderer_set_user_alpha_61_comment},
  {"setUserAlpha", &Dtool_BaseParticleRenderer_set_user_alpha_61, METH_O, (const char *)Dtool_BaseParticleRenderer_set_user_alpha_61_comment},
  {"get_user_alpha", &Dtool_BaseParticleRenderer_get_user_alpha_62, METH_NOARGS, (const char *)Dtool_BaseParticleRenderer_get_user_alpha_62_comment},
  {"getUserAlpha", &Dtool_BaseParticleRenderer_get_user_alpha_62, METH_NOARGS, (const char *)Dtool_BaseParticleRenderer_get_user_alpha_62_comment},
  {"set_color_blend_mode", (PyCFunction) &Dtool_BaseParticleRenderer_set_color_blend_mode_63, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BaseParticleRenderer_set_color_blend_mode_63_comment},
  {"setColorBlendMode", (PyCFunction) &Dtool_BaseParticleRenderer_set_color_blend_mode_63, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BaseParticleRenderer_set_color_blend_mode_63_comment},
  {"set_ignore_scale", &Dtool_BaseParticleRenderer_set_ignore_scale_64, METH_O, (const char *)Dtool_BaseParticleRenderer_set_ignore_scale_64_comment},
  {"setIgnoreScale", &Dtool_BaseParticleRenderer_set_ignore_scale_64, METH_O, (const char *)Dtool_BaseParticleRenderer_set_ignore_scale_64_comment},
  {"get_ignore_scale", &Dtool_BaseParticleRenderer_get_ignore_scale_65, METH_NOARGS, (const char *)Dtool_BaseParticleRenderer_get_ignore_scale_65_comment},
  {"getIgnoreScale", &Dtool_BaseParticleRenderer_get_ignore_scale_65, METH_NOARGS, (const char *)Dtool_BaseParticleRenderer_get_ignore_scale_65_comment},
  {"output", &Dtool_BaseParticleRenderer_output_66, METH_O, (const char *)Dtool_BaseParticleRenderer_output_66_comment},
  {"write", (PyCFunction) &Dtool_BaseParticleRenderer_write_67, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BaseParticleRenderer_write_67_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     BaseParticleRenderer
//////////////////
static PyObject *Dtool_Repr_BaseParticleRenderer(PyObject *self) {
  BaseParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleRenderer, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     BaseParticleRenderer
//////////////////
static PyObject *Dtool_Str_BaseParticleRenderer(PyObject *self) {
  BaseParticleRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseParticleRenderer, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_BaseParticleRenderer = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BaseParticleRenderer = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_BaseParticleRenderer = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_BaseParticleRenderer = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_BaseParticleRenderer = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.BaseParticleRenderer",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BaseParticleRenderer,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_BaseParticleRenderer,
    &Dtool_NumberMethods_BaseParticleRenderer,
    &Dtool_SequenceMethods_BaseParticleRenderer,
    &Dtool_MappingMethods_BaseParticleRenderer,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_BaseParticleRenderer,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_BaseParticleRenderer,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Pure virtual particle renderer base class\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BaseParticleRenderer,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BaseParticleRenderer,
    PyType_GenericAlloc,
    Dtool_new_BaseParticleRenderer,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BaseParticleRenderer,
  Dtool_UpcastInterface_BaseParticleRenderer,
  Dtool_DowncastInterface_BaseParticleRenderer,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_BaseParticleRenderer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_BaseParticleRenderer._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = _PyDict_NewPresized(19);
    Dtool_BaseParticleRenderer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum BaseParticleRenderer::ParticleRendererAlphaMode;
    PyDict_SetItemString(dict, "PR_ALPHA_NONE", Dtool_WrapValue(BaseParticleRenderer::PR_ALPHA_NONE));
    PyDict_SetItemString(dict, "PRALPHANONE", Dtool_WrapValue(BaseParticleRenderer::PR_ALPHA_NONE));
    PyDict_SetItemString(dict, "PR_ALPHA_OUT", Dtool_WrapValue(BaseParticleRenderer::PR_ALPHA_OUT));
    PyDict_SetItemString(dict, "PRALPHAOUT", Dtool_WrapValue(BaseParticleRenderer::PR_ALPHA_OUT));
    PyDict_SetItemString(dict, "PR_ALPHA_IN", Dtool_WrapValue(BaseParticleRenderer::PR_ALPHA_IN));
    PyDict_SetItemString(dict, "PRALPHAIN", Dtool_WrapValue(BaseParticleRenderer::PR_ALPHA_IN));
    PyDict_SetItemString(dict, "PR_ALPHA_IN_OUT", Dtool_WrapValue(BaseParticleRenderer::PR_ALPHA_IN_OUT));
    PyDict_SetItemString(dict, "PRALPHAINOUT", Dtool_WrapValue(BaseParticleRenderer::PR_ALPHA_IN_OUT));
    PyDict_SetItemString(dict, "PR_ALPHA_USER", Dtool_WrapValue(BaseParticleRenderer::PR_ALPHA_USER));
    PyDict_SetItemString(dict, "PRALPHAUSER", Dtool_WrapValue(BaseParticleRenderer::PR_ALPHA_USER));
    PyDict_SetItemString(dict, "PR_NOT_INITIALIZED_YET", Dtool_WrapValue(BaseParticleRenderer::PR_NOT_INITIALIZED_YET));
    PyDict_SetItemString(dict, "PRNOTINITIALIZEDYET", Dtool_WrapValue(BaseParticleRenderer::PR_NOT_INITIALIZED_YET));
    // enum BaseParticleRenderer::ParticleRendererBlendMethod;
    PyDict_SetItemString(dict, "PP_NO_BLEND", Dtool_WrapValue(BaseParticleRenderer::PP_NO_BLEND));
    PyDict_SetItemString(dict, "PPNOBLEND", Dtool_WrapValue(BaseParticleRenderer::PP_NO_BLEND));
    PyDict_SetItemString(dict, "PP_BLEND_LINEAR", Dtool_WrapValue(BaseParticleRenderer::PP_BLEND_LINEAR));
    PyDict_SetItemString(dict, "PPBLENDLINEAR", Dtool_WrapValue(BaseParticleRenderer::PP_BLEND_LINEAR));
    PyDict_SetItemString(dict, "PP_BLEND_CUBIC", Dtool_WrapValue(BaseParticleRenderer::PP_BLEND_CUBIC));
    PyDict_SetItemString(dict, "PPBLENDCUBIC", Dtool_WrapValue(BaseParticleRenderer::PP_BLEND_CUBIC));
    if (PyType_Ready((PyTypeObject *)&Dtool_BaseParticleRenderer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BaseParticleRenderer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BaseParticleRenderer);
  }
}

/**
 * Python method tables for BoxEmitter (BoxEmitter)
 */
static PyMethodDef Dtool_Methods_BoxEmitter[] = {
  {"set_min_bound", &Dtool_BoxEmitter_set_min_bound_70, METH_O, (const char *)Dtool_BoxEmitter_set_min_bound_70_comment},
  {"setMinBound", &Dtool_BoxEmitter_set_min_bound_70, METH_O, (const char *)Dtool_BoxEmitter_set_min_bound_70_comment},
  {"set_max_bound", &Dtool_BoxEmitter_set_max_bound_71, METH_O, (const char *)Dtool_BoxEmitter_set_max_bound_71_comment},
  {"setMaxBound", &Dtool_BoxEmitter_set_max_bound_71, METH_O, (const char *)Dtool_BoxEmitter_set_max_bound_71_comment},
  {"get_min_bound", &Dtool_BoxEmitter_get_min_bound_72, METH_NOARGS, (const char *)Dtool_BoxEmitter_get_min_bound_72_comment},
  {"getMinBound", &Dtool_BoxEmitter_get_min_bound_72, METH_NOARGS, (const char *)Dtool_BoxEmitter_get_min_bound_72_comment},
  {"get_max_bound", &Dtool_BoxEmitter_get_max_bound_73, METH_NOARGS, (const char *)Dtool_BoxEmitter_get_max_bound_73_comment},
  {"getMaxBound", &Dtool_BoxEmitter_get_max_bound_73, METH_NOARGS, (const char *)Dtool_BoxEmitter_get_max_bound_73_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_BoxEmitter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BoxEmitter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_BoxEmitter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_BoxEmitter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_BoxEmitter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.BoxEmitter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BoxEmitter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_BoxEmitter,
    &Dtool_SequenceMethods_BoxEmitter,
    &Dtool_MappingMethods_BoxEmitter,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_BoxEmitter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Describes a voluminous box region in which particles are generated.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BoxEmitter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BoxEmitter,
    PyType_GenericAlloc,
    Dtool_new_BoxEmitter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BoxEmitter,
  Dtool_UpcastInterface_BoxEmitter,
  Dtool_DowncastInterface_BoxEmitter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_BoxEmitter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseParticleEmitter(NULL);
    Dtool_BoxEmitter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseParticleEmitter);
    PyObject *dict = PyDict_New();
    Dtool_BoxEmitter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BoxEmitter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BoxEmitter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BoxEmitter);
  }
}

/**
 * Python method tables for ColorInterpolationFunctionConstant (ColorInterpolationFunctionConstant)
 */
static PyMethodDef Dtool_Methods_ColorInterpolationFunctionConstant[] = {
  {"get_color_a", &Dtool_ColorInterpolationFunctionConstant_get_color_a_76, METH_NOARGS, (const char *)Dtool_ColorInterpolationFunctionConstant_get_color_a_76_comment},
  {"getColorA", &Dtool_ColorInterpolationFunctionConstant_get_color_a_76, METH_NOARGS, (const char *)Dtool_ColorInterpolationFunctionConstant_get_color_a_76_comment},
  {"set_color_a", &Dtool_ColorInterpolationFunctionConstant_set_color_a_77, METH_O, (const char *)Dtool_ColorInterpolationFunctionConstant_set_color_a_77_comment},
  {"setColorA", &Dtool_ColorInterpolationFunctionConstant_set_color_a_77, METH_O, (const char *)Dtool_ColorInterpolationFunctionConstant_set_color_a_77_comment},
  {"get_class_type", &Dtool_ColorInterpolationFunctionConstant_get_class_type_78, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorInterpolationFunctionConstant_get_class_type_78_comment},
  {"getClassType", &Dtool_ColorInterpolationFunctionConstant_get_class_type_78, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorInterpolationFunctionConstant_get_class_type_78_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ColorInterpolationFunctionConstant = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ColorInterpolationFunctionConstant = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ColorInterpolationFunctionConstant = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ColorInterpolationFunctionConstant = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ColorInterpolationFunctionConstant = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.ColorInterpolationFunctionConstant",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ColorInterpolationFunctionConstant,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ColorInterpolationFunctionConstant,
    &Dtool_SequenceMethods_ColorInterpolationFunctionConstant,
    &Dtool_MappingMethods_ColorInterpolationFunctionConstant,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ColorInterpolationFunctionConstant,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ColorInterpolationFunctionConstant,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ColorInterpolationFunctionConstant,
    PyType_GenericAlloc,
    Dtool_new_ColorInterpolationFunctionConstant,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ColorInterpolationFunctionConstant,
  Dtool_UpcastInterface_ColorInterpolationFunctionConstant,
  Dtool_DowncastInterface_ColorInterpolationFunctionConstant,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ColorInterpolationFunctionConstant(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ColorInterpolationFunctionConstant._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_ColorInterpolationFunctionConstant._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ColorInterpolationFunctionConstant) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ColorInterpolationFunctionConstant)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ColorInterpolationFunctionConstant);
  }
}

/**
 * Python method tables for ColorInterpolationFunctionLinear (ColorInterpolationFunctionLinear)
 */
static PyMethodDef Dtool_Methods_ColorInterpolationFunctionLinear[] = {
  {"get_color_b", &Dtool_ColorInterpolationFunctionLinear_get_color_b_81, METH_NOARGS, (const char *)Dtool_ColorInterpolationFunctionLinear_get_color_b_81_comment},
  {"getColorB", &Dtool_ColorInterpolationFunctionLinear_get_color_b_81, METH_NOARGS, (const char *)Dtool_ColorInterpolationFunctionLinear_get_color_b_81_comment},
  {"set_color_b", &Dtool_ColorInterpolationFunctionLinear_set_color_b_82, METH_O, (const char *)Dtool_ColorInterpolationFunctionLinear_set_color_b_82_comment},
  {"setColorB", &Dtool_ColorInterpolationFunctionLinear_set_color_b_82, METH_O, (const char *)Dtool_ColorInterpolationFunctionLinear_set_color_b_82_comment},
  {"get_class_type", &Dtool_ColorInterpolationFunctionLinear_get_class_type_83, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorInterpolationFunctionLinear_get_class_type_83_comment},
  {"getClassType", &Dtool_ColorInterpolationFunctionLinear_get_class_type_83, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorInterpolationFunctionLinear_get_class_type_83_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ColorInterpolationFunctionLinear = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ColorInterpolationFunctionLinear = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ColorInterpolationFunctionLinear = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ColorInterpolationFunctionLinear = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ColorInterpolationFunctionLinear = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.ColorInterpolationFunctionLinear",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ColorInterpolationFunctionLinear,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ColorInterpolationFunctionLinear,
    &Dtool_SequenceMethods_ColorInterpolationFunctionLinear,
    &Dtool_MappingMethods_ColorInterpolationFunctionLinear,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ColorInterpolationFunctionLinear,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ColorInterpolationFunctionLinear,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ColorInterpolationFunctionLinear,
    PyType_GenericAlloc,
    Dtool_new_ColorInterpolationFunctionLinear,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ColorInterpolationFunctionLinear,
  Dtool_UpcastInterface_ColorInterpolationFunctionLinear,
  Dtool_DowncastInterface_ColorInterpolationFunctionLinear,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ColorInterpolationFunctionLinear(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ColorInterpolationFunctionConstant(NULL);
    Dtool_ColorInterpolationFunctionLinear._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ColorInterpolationFunctionConstant);
    PyObject *dict = PyDict_New();
    Dtool_ColorInterpolationFunctionLinear._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ColorInterpolationFunctionLinear) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ColorInterpolationFunctionLinear)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ColorInterpolationFunctionLinear);
  }
}

/**
 * Python method tables for ColorInterpolationFunctionStepwave (ColorInterpolationFunctionStepwave)
 */
static PyMethodDef Dtool_Methods_ColorInterpolationFunctionStepwave[] = {
  {"get_width_a", &Dtool_ColorInterpolationFunctionStepwave_get_width_a_86, METH_NOARGS, (const char *)Dtool_ColorInterpolationFunctionStepwave_get_width_a_86_comment},
  {"getWidthA", &Dtool_ColorInterpolationFunctionStepwave_get_width_a_86, METH_NOARGS, (const char *)Dtool_ColorInterpolationFunctionStepwave_get_width_a_86_comment},
  {"get_width_b", &Dtool_ColorInterpolationFunctionStepwave_get_width_b_87, METH_NOARGS, (const char *)Dtool_ColorInterpolationFunctionStepwave_get_width_b_87_comment},
  {"getWidthB", &Dtool_ColorInterpolationFunctionStepwave_get_width_b_87, METH_NOARGS, (const char *)Dtool_ColorInterpolationFunctionStepwave_get_width_b_87_comment},
  {"set_width_a", &Dtool_ColorInterpolationFunctionStepwave_set_width_a_88, METH_O, (const char *)Dtool_ColorInterpolationFunctionStepwave_set_width_a_88_comment},
  {"setWidthA", &Dtool_ColorInterpolationFunctionStepwave_set_width_a_88, METH_O, (const char *)Dtool_ColorInterpolationFunctionStepwave_set_width_a_88_comment},
  {"set_width_b", &Dtool_ColorInterpolationFunctionStepwave_set_width_b_89, METH_O, (const char *)Dtool_ColorInterpolationFunctionStepwave_set_width_b_89_comment},
  {"setWidthB", &Dtool_ColorInterpolationFunctionStepwave_set_width_b_89, METH_O, (const char *)Dtool_ColorInterpolationFunctionStepwave_set_width_b_89_comment},
  {"get_class_type", &Dtool_ColorInterpolationFunctionStepwave_get_class_type_90, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorInterpolationFunctionStepwave_get_class_type_90_comment},
  {"getClassType", &Dtool_ColorInterpolationFunctionStepwave_get_class_type_90, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorInterpolationFunctionStepwave_get_class_type_90_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ColorInterpolationFunctionStepwave = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ColorInterpolationFunctionStepwave = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ColorInterpolationFunctionStepwave = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ColorInterpolationFunctionStepwave = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ColorInterpolationFunctionStepwave = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.ColorInterpolationFunctionStepwave",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ColorInterpolationFunctionStepwave,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ColorInterpolationFunctionStepwave,
    &Dtool_SequenceMethods_ColorInterpolationFunctionStepwave,
    &Dtool_MappingMethods_ColorInterpolationFunctionStepwave,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ColorInterpolationFunctionStepwave,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ColorInterpolationFunctionStepwave,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ColorInterpolationFunctionStepwave,
    PyType_GenericAlloc,
    Dtool_new_ColorInterpolationFunctionStepwave,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ColorInterpolationFunctionStepwave,
  Dtool_UpcastInterface_ColorInterpolationFunctionStepwave,
  Dtool_DowncastInterface_ColorInterpolationFunctionStepwave,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ColorInterpolationFunctionStepwave(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ColorInterpolationFunctionLinear(NULL);
    Dtool_ColorInterpolationFunctionStepwave._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ColorInterpolationFunctionLinear);
    PyObject *dict = PyDict_New();
    Dtool_ColorInterpolationFunctionStepwave._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ColorInterpolationFunctionStepwave) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ColorInterpolationFunctionStepwave)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ColorInterpolationFunctionStepwave);
  }
}

/**
 * Python method tables for ColorInterpolationFunctionSinusoid (ColorInterpolationFunctionSinusoid)
 */
static PyMethodDef Dtool_Methods_ColorInterpolationFunctionSinusoid[] = {
  {"get_period", &Dtool_ColorInterpolationFunctionSinusoid_get_period_93, METH_NOARGS, (const char *)Dtool_ColorInterpolationFunctionSinusoid_get_period_93_comment},
  {"getPeriod", &Dtool_ColorInterpolationFunctionSinusoid_get_period_93, METH_NOARGS, (const char *)Dtool_ColorInterpolationFunctionSinusoid_get_period_93_comment},
  {"set_period", &Dtool_ColorInterpolationFunctionSinusoid_set_period_94, METH_O, (const char *)Dtool_ColorInterpolationFunctionSinusoid_set_period_94_comment},
  {"setPeriod", &Dtool_ColorInterpolationFunctionSinusoid_set_period_94, METH_O, (const char *)Dtool_ColorInterpolationFunctionSinusoid_set_period_94_comment},
  {"get_class_type", &Dtool_ColorInterpolationFunctionSinusoid_get_class_type_95, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorInterpolationFunctionSinusoid_get_class_type_95_comment},
  {"getClassType", &Dtool_ColorInterpolationFunctionSinusoid_get_class_type_95, METH_NOARGS | METH_STATIC, (const char *)Dtool_ColorInterpolationFunctionSinusoid_get_class_type_95_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ColorInterpolationFunctionSinusoid = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ColorInterpolationFunctionSinusoid = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ColorInterpolationFunctionSinusoid = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ColorInterpolationFunctionSinusoid = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ColorInterpolationFunctionSinusoid = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.ColorInterpolationFunctionSinusoid",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ColorInterpolationFunctionSinusoid,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ColorInterpolationFunctionSinusoid,
    &Dtool_SequenceMethods_ColorInterpolationFunctionSinusoid,
    &Dtool_MappingMethods_ColorInterpolationFunctionSinusoid,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ColorInterpolationFunctionSinusoid,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ColorInterpolationFunctionSinusoid,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ColorInterpolationFunctionSinusoid,
    PyType_GenericAlloc,
    Dtool_new_ColorInterpolationFunctionSinusoid,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ColorInterpolationFunctionSinusoid,
  Dtool_UpcastInterface_ColorInterpolationFunctionSinusoid,
  Dtool_DowncastInterface_ColorInterpolationFunctionSinusoid,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ColorInterpolationFunctionSinusoid(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ColorInterpolationFunctionLinear(NULL);
    Dtool_ColorInterpolationFunctionSinusoid._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ColorInterpolationFunctionLinear);
    PyObject *dict = PyDict_New();
    Dtool_ColorInterpolationFunctionSinusoid._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ColorInterpolationFunctionSinusoid) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ColorInterpolationFunctionSinusoid)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ColorInterpolationFunctionSinusoid);
  }
}

/**
 * Python method tables for ColorInterpolationSegment (ColorInterpolationSegment)
 */
static PyMethodDef Dtool_Methods_ColorInterpolationSegment[] = {
  {"get_function", &Dtool_ColorInterpolationSegment_get_function_99, METH_NOARGS, (const char *)Dtool_ColorInterpolationSegment_get_function_99_comment},
  {"getFunction", &Dtool_ColorInterpolationSegment_get_function_99, METH_NOARGS, (const char *)Dtool_ColorInterpolationSegment_get_function_99_comment},
  {"get_time_begin", &Dtool_ColorInterpolationSegment_get_time_begin_100, METH_NOARGS, (const char *)Dtool_ColorInterpolationSegment_get_time_begin_100_comment},
  {"getTimeBegin", &Dtool_ColorInterpolationSegment_get_time_begin_100, METH_NOARGS, (const char *)Dtool_ColorInterpolationSegment_get_time_begin_100_comment},
  {"get_time_end", &Dtool_ColorInterpolationSegment_get_time_end_101, METH_NOARGS, (const char *)Dtool_ColorInterpolationSegment_get_time_end_101_comment},
  {"getTimeEnd", &Dtool_ColorInterpolationSegment_get_time_end_101, METH_NOARGS, (const char *)Dtool_ColorInterpolationSegment_get_time_end_101_comment},
  {"is_modulated", &Dtool_ColorInterpolationSegment_is_modulated_102, METH_NOARGS, (const char *)Dtool_ColorInterpolationSegment_is_modulated_102_comment},
  {"isModulated", &Dtool_ColorInterpolationSegment_is_modulated_102, METH_NOARGS, (const char *)Dtool_ColorInterpolationSegment_is_modulated_102_comment},
  {"get_id", &Dtool_ColorInterpolationSegment_get_id_103, METH_NOARGS, (const char *)Dtool_ColorInterpolationSegment_get_id_103_comment},
  {"getId", &Dtool_ColorInterpolationSegment_get_id_103, METH_NOARGS, (const char *)Dtool_ColorInterpolationSegment_get_id_103_comment},
  {"is_enabled", &Dtool_ColorInterpolationSegment_is_enabled_104, METH_NOARGS, (const char *)Dtool_ColorInterpolationSegment_is_enabled_104_comment},
  {"isEnabled", &Dtool_ColorInterpolationSegment_is_enabled_104, METH_NOARGS, (const char *)Dtool_ColorInterpolationSegment_is_enabled_104_comment},
  {"set_time_begin", &Dtool_ColorInterpolationSegment_set_time_begin_106, METH_O, (const char *)Dtool_ColorInterpolationSegment_set_time_begin_106_comment},
  {"setTimeBegin", &Dtool_ColorInterpolationSegment_set_time_begin_106, METH_O, (const char *)Dtool_ColorInterpolationSegment_set_time_begin_106_comment},
  {"set_time_end", &Dtool_ColorInterpolationSegment_set_time_end_107, METH_O, (const char *)Dtool_ColorInterpolationSegment_set_time_end_107_comment},
  {"setTimeEnd", &Dtool_ColorInterpolationSegment_set_time_end_107, METH_O, (const char *)Dtool_ColorInterpolationSegment_set_time_end_107_comment},
  {"set_is_modulated", &Dtool_ColorInterpolationSegment_set_is_modulated_108, METH_O, (const char *)Dtool_ColorInterpolationSegment_set_is_modulated_108_comment},
  {"setIsModulated", &Dtool_ColorInterpolationSegment_set_is_modulated_108, METH_O, (const char *)Dtool_ColorInterpolationSegment_set_is_modulated_108_comment},
  {"set_enabled", &Dtool_ColorInterpolationSegment_set_enabled_109, METH_O, (const char *)Dtool_ColorInterpolationSegment_set_enabled_109_comment},
  {"setEnabled", &Dtool_ColorInterpolationSegment_set_enabled_109, METH_O, (const char *)Dtool_ColorInterpolationSegment_set_enabled_109_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ColorInterpolationSegment = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ColorInterpolationSegment = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ColorInterpolationSegment = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ColorInterpolationSegment = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ColorInterpolationSegment = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.ColorInterpolationSegment",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ColorInterpolationSegment,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ColorInterpolationSegment,
    &Dtool_SequenceMethods_ColorInterpolationSegment,
    &Dtool_MappingMethods_ColorInterpolationSegment,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ColorInterpolationSegment,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ColorInterpolationSegment,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ColorInterpolationSegment,
    PyType_GenericAlloc,
    Dtool_new_ColorInterpolationSegment,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ColorInterpolationSegment,
  Dtool_UpcastInterface_ColorInterpolationSegment,
  Dtool_DowncastInterface_ColorInterpolationSegment,
  (CoerceFunction)Dtool_ConstCoerce_ColorInterpolationSegment,
  (CoerceFunction)Dtool_Coerce_ColorInterpolationSegment,
};

static void Dtool_PyModuleClassInit_ColorInterpolationSegment(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_ColorInterpolationSegment._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_ColorInterpolationSegment._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ColorInterpolationSegment) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ColorInterpolationSegment)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ColorInterpolationSegment);
  }
}

/**
 * Python method tables for ColorInterpolationManager (ColorInterpolationManager)
 */
static PyMethodDef Dtool_Methods_ColorInterpolationManager[] = {
  {"add_constant", (PyCFunction) &Dtool_ColorInterpolationManager_add_constant_112, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ColorInterpolationManager_add_constant_112_comment},
  {"addConstant", (PyCFunction) &Dtool_ColorInterpolationManager_add_constant_112, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ColorInterpolationManager_add_constant_112_comment},
  {"add_linear", (PyCFunction) &Dtool_ColorInterpolationManager_add_linear_113, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ColorInterpolationManager_add_linear_113_comment},
  {"addLinear", (PyCFunction) &Dtool_ColorInterpolationManager_add_linear_113, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ColorInterpolationManager_add_linear_113_comment},
  {"add_stepwave", (PyCFunction) &Dtool_ColorInterpolationManager_add_stepwave_114, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ColorInterpolationManager_add_stepwave_114_comment},
  {"addStepwave", (PyCFunction) &Dtool_ColorInterpolationManager_add_stepwave_114, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ColorInterpolationManager_add_stepwave_114_comment},
  {"add_sinusoid", (PyCFunction) &Dtool_ColorInterpolationManager_add_sinusoid_115, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ColorInterpolationManager_add_sinusoid_115_comment},
  {"addSinusoid", (PyCFunction) &Dtool_ColorInterpolationManager_add_sinusoid_115, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ColorInterpolationManager_add_sinusoid_115_comment},
  {"set_default_color", &Dtool_ColorInterpolationManager_set_default_color_116, METH_O, (const char *)Dtool_ColorInterpolationManager_set_default_color_116_comment},
  {"setDefaultColor", &Dtool_ColorInterpolationManager_set_default_color_116, METH_O, (const char *)Dtool_ColorInterpolationManager_set_default_color_116_comment},
  {"get_segment", &Dtool_ColorInterpolationManager_get_segment_117, METH_O, (const char *)Dtool_ColorInterpolationManager_get_segment_117_comment},
  {"getSegment", &Dtool_ColorInterpolationManager_get_segment_117, METH_O, (const char *)Dtool_ColorInterpolationManager_get_segment_117_comment},
  {"get_segment_id_list", &Dtool_ColorInterpolationManager_get_segment_id_list_118, METH_NOARGS, (const char *)Dtool_ColorInterpolationManager_get_segment_id_list_118_comment},
  {"getSegmentIdList", &Dtool_ColorInterpolationManager_get_segment_id_list_118, METH_NOARGS, (const char *)Dtool_ColorInterpolationManager_get_segment_id_list_118_comment},
  {"clear_segment", &Dtool_ColorInterpolationManager_clear_segment_119, METH_O, (const char *)Dtool_ColorInterpolationManager_clear_segment_119_comment},
  {"clearSegment", &Dtool_ColorInterpolationManager_clear_segment_119, METH_O, (const char *)Dtool_ColorInterpolationManager_clear_segment_119_comment},
  {"clear_to_initial", &Dtool_ColorInterpolationManager_clear_to_initial_120, METH_NOARGS, (const char *)Dtool_ColorInterpolationManager_clear_to_initial_120_comment},
  {"clearToInitial", &Dtool_ColorInterpolationManager_clear_to_initial_120, METH_NOARGS, (const char *)Dtool_ColorInterpolationManager_clear_to_initial_120_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ColorInterpolationManager = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ColorInterpolationManager = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ColorInterpolationManager = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ColorInterpolationManager = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ColorInterpolationManager = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.ColorInterpolationManager",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ColorInterpolationManager,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ColorInterpolationManager,
    &Dtool_SequenceMethods_ColorInterpolationManager,
    &Dtool_MappingMethods_ColorInterpolationManager,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ColorInterpolationManager,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ColorInterpolationManager,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ColorInterpolationManager,
    PyType_GenericAlloc,
    Dtool_new_ColorInterpolationManager,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ColorInterpolationManager,
  Dtool_UpcastInterface_ColorInterpolationManager,
  Dtool_DowncastInterface_ColorInterpolationManager,
  (CoerceFunction)Dtool_ConstCoerce_ColorInterpolationManager,
  (CoerceFunction)Dtool_Coerce_ColorInterpolationManager,
};

static void Dtool_PyModuleClassInit_ColorInterpolationManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_ColorInterpolationManager._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_ColorInterpolationManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ColorInterpolationManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ColorInterpolationManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ColorInterpolationManager);
  }
}

/**
 * Python method tables for DiscEmitter (DiscEmitter)
 */
static PyMethodDef Dtool_Methods_DiscEmitter[] = {
  {"set_radius", &Dtool_DiscEmitter_set_radius_123, METH_O, (const char *)Dtool_DiscEmitter_set_radius_123_comment},
  {"setRadius", &Dtool_DiscEmitter_set_radius_123, METH_O, (const char *)Dtool_DiscEmitter_set_radius_123_comment},
  {"set_outer_angle", &Dtool_DiscEmitter_set_outer_angle_124, METH_O, (const char *)Dtool_DiscEmitter_set_outer_angle_124_comment},
  {"setOuterAngle", &Dtool_DiscEmitter_set_outer_angle_124, METH_O, (const char *)Dtool_DiscEmitter_set_outer_angle_124_comment},
  {"set_inner_angle", &Dtool_DiscEmitter_set_inner_angle_125, METH_O, (const char *)Dtool_DiscEmitter_set_inner_angle_125_comment},
  {"setInnerAngle", &Dtool_DiscEmitter_set_inner_angle_125, METH_O, (const char *)Dtool_DiscEmitter_set_inner_angle_125_comment},
  {"set_outer_magnitude", &Dtool_DiscEmitter_set_outer_magnitude_126, METH_O, (const char *)Dtool_DiscEmitter_set_outer_magnitude_126_comment},
  {"setOuterMagnitude", &Dtool_DiscEmitter_set_outer_magnitude_126, METH_O, (const char *)Dtool_DiscEmitter_set_outer_magnitude_126_comment},
  {"set_inner_magnitude", &Dtool_DiscEmitter_set_inner_magnitude_127, METH_O, (const char *)Dtool_DiscEmitter_set_inner_magnitude_127_comment},
  {"setInnerMagnitude", &Dtool_DiscEmitter_set_inner_magnitude_127, METH_O, (const char *)Dtool_DiscEmitter_set_inner_magnitude_127_comment},
  {"set_cubic_lerping", &Dtool_DiscEmitter_set_cubic_lerping_128, METH_O, (const char *)Dtool_DiscEmitter_set_cubic_lerping_128_comment},
  {"setCubicLerping", &Dtool_DiscEmitter_set_cubic_lerping_128, METH_O, (const char *)Dtool_DiscEmitter_set_cubic_lerping_128_comment},
  {"get_radius", &Dtool_DiscEmitter_get_radius_129, METH_NOARGS, (const char *)Dtool_DiscEmitter_get_radius_129_comment},
  {"getRadius", &Dtool_DiscEmitter_get_radius_129, METH_NOARGS, (const char *)Dtool_DiscEmitter_get_radius_129_comment},
  {"get_outer_angle", &Dtool_DiscEmitter_get_outer_angle_130, METH_NOARGS, (const char *)Dtool_DiscEmitter_get_outer_angle_130_comment},
  {"getOuterAngle", &Dtool_DiscEmitter_get_outer_angle_130, METH_NOARGS, (const char *)Dtool_DiscEmitter_get_outer_angle_130_comment},
  {"get_inner_angle", &Dtool_DiscEmitter_get_inner_angle_131, METH_NOARGS, (const char *)Dtool_DiscEmitter_get_inner_angle_131_comment},
  {"getInnerAngle", &Dtool_DiscEmitter_get_inner_angle_131, METH_NOARGS, (const char *)Dtool_DiscEmitter_get_inner_angle_131_comment},
  {"get_outer_magnitude", &Dtool_DiscEmitter_get_outer_magnitude_132, METH_NOARGS, (const char *)Dtool_DiscEmitter_get_outer_magnitude_132_comment},
  {"getOuterMagnitude", &Dtool_DiscEmitter_get_outer_magnitude_132, METH_NOARGS, (const char *)Dtool_DiscEmitter_get_outer_magnitude_132_comment},
  {"get_inner_magnitude", &Dtool_DiscEmitter_get_inner_magnitude_133, METH_NOARGS, (const char *)Dtool_DiscEmitter_get_inner_magnitude_133_comment},
  {"getInnerMagnitude", &Dtool_DiscEmitter_get_inner_magnitude_133, METH_NOARGS, (const char *)Dtool_DiscEmitter_get_inner_magnitude_133_comment},
  {"get_cubic_lerping", &Dtool_DiscEmitter_get_cubic_lerping_134, METH_NOARGS, (const char *)Dtool_DiscEmitter_get_cubic_lerping_134_comment},
  {"getCubicLerping", &Dtool_DiscEmitter_get_cubic_lerping_134, METH_NOARGS, (const char *)Dtool_DiscEmitter_get_cubic_lerping_134_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DiscEmitter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DiscEmitter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DiscEmitter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DiscEmitter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DiscEmitter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.DiscEmitter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DiscEmitter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DiscEmitter,
    &Dtool_SequenceMethods_DiscEmitter,
    &Dtool_MappingMethods_DiscEmitter,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DiscEmitter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Describes a planar disc region from which particles are generated\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DiscEmitter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DiscEmitter,
    PyType_GenericAlloc,
    Dtool_new_DiscEmitter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DiscEmitter,
  Dtool_UpcastInterface_DiscEmitter,
  Dtool_DowncastInterface_DiscEmitter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DiscEmitter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseParticleEmitter(NULL);
    Dtool_DiscEmitter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseParticleEmitter);
    PyObject *dict = PyDict_New();
    Dtool_DiscEmitter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DiscEmitter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DiscEmitter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DiscEmitter);
  }
}

/**
 * Python method tables for GeomParticleRenderer (GeomParticleRenderer)
 */
static PyMethodDef Dtool_Methods_GeomParticleRenderer[] = {
  {"set_geom_node", &Dtool_GeomParticleRenderer_set_geom_node_137, METH_O, (const char *)Dtool_GeomParticleRenderer_set_geom_node_137_comment},
  {"setGeomNode", &Dtool_GeomParticleRenderer_set_geom_node_137, METH_O, (const char *)Dtool_GeomParticleRenderer_set_geom_node_137_comment},
  {"get_geom_node", &Dtool_GeomParticleRenderer_get_geom_node_138, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_geom_node_138_comment},
  {"getGeomNode", &Dtool_GeomParticleRenderer_get_geom_node_138, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_geom_node_138_comment},
  {"get_color_interpolation_manager", &Dtool_GeomParticleRenderer_get_color_interpolation_manager_139, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_color_interpolation_manager_139_comment},
  {"getColorInterpolationManager", &Dtool_GeomParticleRenderer_get_color_interpolation_manager_139, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_color_interpolation_manager_139_comment},
  {"set_x_scale_flag", &Dtool_GeomParticleRenderer_set_x_scale_flag_140, METH_O, (const char *)Dtool_GeomParticleRenderer_set_x_scale_flag_140_comment},
  {"setXScaleFlag", &Dtool_GeomParticleRenderer_set_x_scale_flag_140, METH_O, (const char *)Dtool_GeomParticleRenderer_set_x_scale_flag_140_comment},
  {"set_y_scale_flag", &Dtool_GeomParticleRenderer_set_y_scale_flag_141, METH_O, (const char *)Dtool_GeomParticleRenderer_set_y_scale_flag_141_comment},
  {"setYScaleFlag", &Dtool_GeomParticleRenderer_set_y_scale_flag_141, METH_O, (const char *)Dtool_GeomParticleRenderer_set_y_scale_flag_141_comment},
  {"set_z_scale_flag", &Dtool_GeomParticleRenderer_set_z_scale_flag_142, METH_O, (const char *)Dtool_GeomParticleRenderer_set_z_scale_flag_142_comment},
  {"setZScaleFlag", &Dtool_GeomParticleRenderer_set_z_scale_flag_142, METH_O, (const char *)Dtool_GeomParticleRenderer_set_z_scale_flag_142_comment},
  {"set_initial_x_scale", &Dtool_GeomParticleRenderer_set_initial_x_scale_143, METH_O, (const char *)Dtool_GeomParticleRenderer_set_initial_x_scale_143_comment},
  {"setInitialXScale", &Dtool_GeomParticleRenderer_set_initial_x_scale_143, METH_O, (const char *)Dtool_GeomParticleRenderer_set_initial_x_scale_143_comment},
  {"set_final_x_scale", &Dtool_GeomParticleRenderer_set_final_x_scale_144, METH_O, (const char *)Dtool_GeomParticleRenderer_set_final_x_scale_144_comment},
  {"setFinalXScale", &Dtool_GeomParticleRenderer_set_final_x_scale_144, METH_O, (const char *)Dtool_GeomParticleRenderer_set_final_x_scale_144_comment},
  {"set_initial_y_scale", &Dtool_GeomParticleRenderer_set_initial_y_scale_145, METH_O, (const char *)Dtool_GeomParticleRenderer_set_initial_y_scale_145_comment},
  {"setInitialYScale", &Dtool_GeomParticleRenderer_set_initial_y_scale_145, METH_O, (const char *)Dtool_GeomParticleRenderer_set_initial_y_scale_145_comment},
  {"set_final_y_scale", &Dtool_GeomParticleRenderer_set_final_y_scale_146, METH_O, (const char *)Dtool_GeomParticleRenderer_set_final_y_scale_146_comment},
  {"setFinalYScale", &Dtool_GeomParticleRenderer_set_final_y_scale_146, METH_O, (const char *)Dtool_GeomParticleRenderer_set_final_y_scale_146_comment},
  {"set_initial_z_scale", &Dtool_GeomParticleRenderer_set_initial_z_scale_147, METH_O, (const char *)Dtool_GeomParticleRenderer_set_initial_z_scale_147_comment},
  {"setInitialZScale", &Dtool_GeomParticleRenderer_set_initial_z_scale_147, METH_O, (const char *)Dtool_GeomParticleRenderer_set_initial_z_scale_147_comment},
  {"set_final_z_scale", &Dtool_GeomParticleRenderer_set_final_z_scale_148, METH_O, (const char *)Dtool_GeomParticleRenderer_set_final_z_scale_148_comment},
  {"setFinalZScale", &Dtool_GeomParticleRenderer_set_final_z_scale_148, METH_O, (const char *)Dtool_GeomParticleRenderer_set_final_z_scale_148_comment},
  {"get_x_scale_flag", &Dtool_GeomParticleRenderer_get_x_scale_flag_149, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_x_scale_flag_149_comment},
  {"getXScaleFlag", &Dtool_GeomParticleRenderer_get_x_scale_flag_149, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_x_scale_flag_149_comment},
  {"get_y_scale_flag", &Dtool_GeomParticleRenderer_get_y_scale_flag_150, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_y_scale_flag_150_comment},
  {"getYScaleFlag", &Dtool_GeomParticleRenderer_get_y_scale_flag_150, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_y_scale_flag_150_comment},
  {"get_z_scale_flag", &Dtool_GeomParticleRenderer_get_z_scale_flag_151, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_z_scale_flag_151_comment},
  {"getZScaleFlag", &Dtool_GeomParticleRenderer_get_z_scale_flag_151, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_z_scale_flag_151_comment},
  {"get_initial_x_scale", &Dtool_GeomParticleRenderer_get_initial_x_scale_152, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_initial_x_scale_152_comment},
  {"getInitialXScale", &Dtool_GeomParticleRenderer_get_initial_x_scale_152, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_initial_x_scale_152_comment},
  {"get_final_x_scale", &Dtool_GeomParticleRenderer_get_final_x_scale_153, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_final_x_scale_153_comment},
  {"getFinalXScale", &Dtool_GeomParticleRenderer_get_final_x_scale_153, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_final_x_scale_153_comment},
  {"get_initial_y_scale", &Dtool_GeomParticleRenderer_get_initial_y_scale_154, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_initial_y_scale_154_comment},
  {"getInitialYScale", &Dtool_GeomParticleRenderer_get_initial_y_scale_154, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_initial_y_scale_154_comment},
  {"get_final_y_scale", &Dtool_GeomParticleRenderer_get_final_y_scale_155, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_final_y_scale_155_comment},
  {"getFinalYScale", &Dtool_GeomParticleRenderer_get_final_y_scale_155, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_final_y_scale_155_comment},
  {"get_initial_z_scale", &Dtool_GeomParticleRenderer_get_initial_z_scale_156, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_initial_z_scale_156_comment},
  {"getInitialZScale", &Dtool_GeomParticleRenderer_get_initial_z_scale_156, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_initial_z_scale_156_comment},
  {"get_final_z_scale", &Dtool_GeomParticleRenderer_get_final_z_scale_157, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_final_z_scale_157_comment},
  {"getFinalZScale", &Dtool_GeomParticleRenderer_get_final_z_scale_157, METH_NOARGS, (const char *)Dtool_GeomParticleRenderer_get_final_z_scale_157_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_GeomParticleRenderer = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeomParticleRenderer = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_GeomParticleRenderer = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_GeomParticleRenderer = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_GeomParticleRenderer = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.GeomParticleRenderer",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_GeomParticleRenderer,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_GeomParticleRenderer,
    &Dtool_SequenceMethods_GeomParticleRenderer,
    &Dtool_MappingMethods_GeomParticleRenderer,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_GeomParticleRenderer,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_GeomParticleRenderer,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_GeomParticleRenderer,
    PyType_GenericAlloc,
    Dtool_new_GeomParticleRenderer,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeomParticleRenderer,
  Dtool_UpcastInterface_GeomParticleRenderer,
  Dtool_DowncastInterface_GeomParticleRenderer,
  (CoerceFunction)Dtool_ConstCoerce_GeomParticleRenderer,
  (CoerceFunction)Dtool_Coerce_GeomParticleRenderer,
};

static void Dtool_PyModuleClassInit_GeomParticleRenderer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseParticleRenderer(NULL);
    Dtool_GeomParticleRenderer._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseParticleRenderer);
    PyObject *dict = PyDict_New();
    Dtool_GeomParticleRenderer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeomParticleRenderer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeomParticleRenderer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeomParticleRenderer);
  }
}

/**
 * Python method tables for LineEmitter (LineEmitter)
 */
static PyMethodDef Dtool_Methods_LineEmitter[] = {
  {"set_endpoint1", &Dtool_LineEmitter_set_endpoint1_160, METH_O, (const char *)Dtool_LineEmitter_set_endpoint1_160_comment},
  {"setEndpoint1", &Dtool_LineEmitter_set_endpoint1_160, METH_O, (const char *)Dtool_LineEmitter_set_endpoint1_160_comment},
  {"set_endpoint2", &Dtool_LineEmitter_set_endpoint2_161, METH_O, (const char *)Dtool_LineEmitter_set_endpoint2_161_comment},
  {"setEndpoint2", &Dtool_LineEmitter_set_endpoint2_161, METH_O, (const char *)Dtool_LineEmitter_set_endpoint2_161_comment},
  {"get_endpoint1", &Dtool_LineEmitter_get_endpoint1_162, METH_NOARGS, (const char *)Dtool_LineEmitter_get_endpoint1_162_comment},
  {"getEndpoint1", &Dtool_LineEmitter_get_endpoint1_162, METH_NOARGS, (const char *)Dtool_LineEmitter_get_endpoint1_162_comment},
  {"get_endpoint2", &Dtool_LineEmitter_get_endpoint2_163, METH_NOARGS, (const char *)Dtool_LineEmitter_get_endpoint2_163_comment},
  {"getEndpoint2", &Dtool_LineEmitter_get_endpoint2_163, METH_NOARGS, (const char *)Dtool_LineEmitter_get_endpoint2_163_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LineEmitter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LineEmitter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LineEmitter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LineEmitter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LineEmitter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.LineEmitter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LineEmitter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LineEmitter,
    &Dtool_SequenceMethods_LineEmitter,
    &Dtool_MappingMethods_LineEmitter,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LineEmitter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Describes a linear region in which particles are generated.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LineEmitter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LineEmitter,
    PyType_GenericAlloc,
    Dtool_new_LineEmitter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LineEmitter,
  Dtool_UpcastInterface_LineEmitter,
  Dtool_DowncastInterface_LineEmitter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LineEmitter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseParticleEmitter(NULL);
    Dtool_LineEmitter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseParticleEmitter);
    PyObject *dict = PyDict_New();
    Dtool_LineEmitter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LineEmitter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LineEmitter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LineEmitter);
  }
}

/**
 * Python method tables for LineParticleRenderer (LineParticleRenderer)
 */
static PyMethodDef Dtool_Methods_LineParticleRenderer[] = {
  {"set_head_color", &Dtool_LineParticleRenderer_set_head_color_166, METH_O, (const char *)Dtool_LineParticleRenderer_set_head_color_166_comment},
  {"setHeadColor", &Dtool_LineParticleRenderer_set_head_color_166, METH_O, (const char *)Dtool_LineParticleRenderer_set_head_color_166_comment},
  {"set_tail_color", &Dtool_LineParticleRenderer_set_tail_color_167, METH_O, (const char *)Dtool_LineParticleRenderer_set_tail_color_167_comment},
  {"setTailColor", &Dtool_LineParticleRenderer_set_tail_color_167, METH_O, (const char *)Dtool_LineParticleRenderer_set_tail_color_167_comment},
  {"get_head_color", &Dtool_LineParticleRenderer_get_head_color_168, METH_NOARGS, (const char *)Dtool_LineParticleRenderer_get_head_color_168_comment},
  {"getHeadColor", &Dtool_LineParticleRenderer_get_head_color_168, METH_NOARGS, (const char *)Dtool_LineParticleRenderer_get_head_color_168_comment},
  {"get_tail_color", &Dtool_LineParticleRenderer_get_tail_color_169, METH_NOARGS, (const char *)Dtool_LineParticleRenderer_get_tail_color_169_comment},
  {"getTailColor", &Dtool_LineParticleRenderer_get_tail_color_169, METH_NOARGS, (const char *)Dtool_LineParticleRenderer_get_tail_color_169_comment},
  {"set_line_scale_factor", &Dtool_LineParticleRenderer_set_line_scale_factor_170, METH_O, (const char *)Dtool_LineParticleRenderer_set_line_scale_factor_170_comment},
  {"setLineScaleFactor", &Dtool_LineParticleRenderer_set_line_scale_factor_170, METH_O, (const char *)Dtool_LineParticleRenderer_set_line_scale_factor_170_comment},
  {"get_line_scale_factor", &Dtool_LineParticleRenderer_get_line_scale_factor_171, METH_NOARGS, (const char *)Dtool_LineParticleRenderer_get_line_scale_factor_171_comment},
  {"getLineScaleFactor", &Dtool_LineParticleRenderer_get_line_scale_factor_171, METH_NOARGS, (const char *)Dtool_LineParticleRenderer_get_line_scale_factor_171_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LineParticleRenderer = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LineParticleRenderer = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LineParticleRenderer = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LineParticleRenderer = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LineParticleRenderer = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.LineParticleRenderer",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LineParticleRenderer,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LineParticleRenderer,
    &Dtool_SequenceMethods_LineParticleRenderer,
    &Dtool_MappingMethods_LineParticleRenderer,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LineParticleRenderer,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LineParticleRenderer,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LineParticleRenderer,
    PyType_GenericAlloc,
    Dtool_new_LineParticleRenderer,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LineParticleRenderer,
  Dtool_UpcastInterface_LineParticleRenderer,
  Dtool_DowncastInterface_LineParticleRenderer,
  (CoerceFunction)Dtool_ConstCoerce_LineParticleRenderer,
  (CoerceFunction)Dtool_Coerce_LineParticleRenderer,
};

static void Dtool_PyModuleClassInit_LineParticleRenderer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseParticleRenderer(NULL);
    Dtool_LineParticleRenderer._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseParticleRenderer);
    PyObject *dict = PyDict_New();
    Dtool_LineParticleRenderer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LineParticleRenderer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LineParticleRenderer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LineParticleRenderer);
  }
}

/**
 * Python method tables for ParticleSystem (ParticleSystem)
 */
static PyMethodDef Dtool_Methods_ParticleSystem[] = {
  {"set_pool_size", &Dtool_ParticleSystem_set_pool_size_175, METH_O, (const char *)Dtool_ParticleSystem_set_pool_size_175_comment},
  {"setPoolSize", &Dtool_ParticleSystem_set_pool_size_175, METH_O, (const char *)Dtool_ParticleSystem_set_pool_size_175_comment},
  {"set_birth_rate", &Dtool_ParticleSystem_set_birth_rate_176, METH_O, (const char *)Dtool_ParticleSystem_set_birth_rate_176_comment},
  {"setBirthRate", &Dtool_ParticleSystem_set_birth_rate_176, METH_O, (const char *)Dtool_ParticleSystem_set_birth_rate_176_comment},
  {"set_soft_birth_rate", &Dtool_ParticleSystem_set_soft_birth_rate_177, METH_O, (const char *)Dtool_ParticleSystem_set_soft_birth_rate_177_comment},
  {"setSoftBirthRate", &Dtool_ParticleSystem_set_soft_birth_rate_177, METH_O, (const char *)Dtool_ParticleSystem_set_soft_birth_rate_177_comment},
  {"set_litter_size", &Dtool_ParticleSystem_set_litter_size_178, METH_O, (const char *)Dtool_ParticleSystem_set_litter_size_178_comment},
  {"setLitterSize", &Dtool_ParticleSystem_set_litter_size_178, METH_O, (const char *)Dtool_ParticleSystem_set_litter_size_178_comment},
  {"set_litter_spread", &Dtool_ParticleSystem_set_litter_spread_179, METH_O, (const char *)Dtool_ParticleSystem_set_litter_spread_179_comment},
  {"setLitterSpread", &Dtool_ParticleSystem_set_litter_spread_179, METH_O, (const char *)Dtool_ParticleSystem_set_litter_spread_179_comment},
  {"set_local_velocity_flag", &Dtool_ParticleSystem_set_local_velocity_flag_180, METH_O, (const char *)Dtool_ParticleSystem_set_local_velocity_flag_180_comment},
  {"setLocalVelocityFlag", &Dtool_ParticleSystem_set_local_velocity_flag_180, METH_O, (const char *)Dtool_ParticleSystem_set_local_velocity_flag_180_comment},
  {"set_system_grows_older_flag", &Dtool_ParticleSystem_set_system_grows_older_flag_181, METH_O, (const char *)Dtool_ParticleSystem_set_system_grows_older_flag_181_comment},
  {"setSystemGrowsOlderFlag", &Dtool_ParticleSystem_set_system_grows_older_flag_181, METH_O, (const char *)Dtool_ParticleSystem_set_system_grows_older_flag_181_comment},
  {"set_system_lifespan", &Dtool_ParticleSystem_set_system_lifespan_182, METH_O, (const char *)Dtool_ParticleSystem_set_system_lifespan_182_comment},
  {"setSystemLifespan", &Dtool_ParticleSystem_set_system_lifespan_182, METH_O, (const char *)Dtool_ParticleSystem_set_system_lifespan_182_comment},
  {"set_system_age", &Dtool_ParticleSystem_set_system_age_183, METH_O, (const char *)Dtool_ParticleSystem_set_system_age_183_comment},
  {"setSystemAge", &Dtool_ParticleSystem_set_system_age_183, METH_O, (const char *)Dtool_ParticleSystem_set_system_age_183_comment},
  {"set_active_system_flag", &Dtool_ParticleSystem_set_active_system_flag_184, METH_O, (const char *)Dtool_ParticleSystem_set_active_system_flag_184_comment},
  {"setActiveSystemFlag", &Dtool_ParticleSystem_set_active_system_flag_184, METH_O, (const char *)Dtool_ParticleSystem_set_active_system_flag_184_comment},
  {"set_spawn_on_death_flag", &Dtool_ParticleSystem_set_spawn_on_death_flag_185, METH_O, (const char *)Dtool_ParticleSystem_set_spawn_on_death_flag_185_comment},
  {"setSpawnOnDeathFlag", &Dtool_ParticleSystem_set_spawn_on_death_flag_185, METH_O, (const char *)Dtool_ParticleSystem_set_spawn_on_death_flag_185_comment},
  {"set_spawn_render_node", &Dtool_ParticleSystem_set_spawn_render_node_186, METH_O, (const char *)Dtool_ParticleSystem_set_spawn_render_node_186_comment},
  {"setSpawnRenderNode", &Dtool_ParticleSystem_set_spawn_render_node_186, METH_O, (const char *)Dtool_ParticleSystem_set_spawn_render_node_186_comment},
  {"set_spawn_render_node_path", &Dtool_ParticleSystem_set_spawn_render_node_path_187, METH_O, (const char *)Dtool_ParticleSystem_set_spawn_render_node_path_187_comment},
  {"setSpawnRenderNodePath", &Dtool_ParticleSystem_set_spawn_render_node_path_187, METH_O, (const char *)Dtool_ParticleSystem_set_spawn_render_node_path_187_comment},
  {"set_template_system_flag", &Dtool_ParticleSystem_set_template_system_flag_188, METH_O, (const char *)Dtool_ParticleSystem_set_template_system_flag_188_comment},
  {"setTemplateSystemFlag", &Dtool_ParticleSystem_set_template_system_flag_188, METH_O, (const char *)Dtool_ParticleSystem_set_template_system_flag_188_comment},
  {"set_render_parent", &Dtool_ParticleSystem_set_render_parent_189, METH_O, (const char *)Dtool_ParticleSystem_set_render_parent_189_comment},
  {"setRenderParent", &Dtool_ParticleSystem_set_render_parent_189, METH_O, (const char *)Dtool_ParticleSystem_set_render_parent_189_comment},
  {"set_renderer", &Dtool_ParticleSystem_set_renderer_190, METH_O, (const char *)Dtool_ParticleSystem_set_renderer_190_comment},
  {"setRenderer", &Dtool_ParticleSystem_set_renderer_190, METH_O, (const char *)Dtool_ParticleSystem_set_renderer_190_comment},
  {"set_emitter", &Dtool_ParticleSystem_set_emitter_191, METH_O, (const char *)Dtool_ParticleSystem_set_emitter_191_comment},
  {"setEmitter", &Dtool_ParticleSystem_set_emitter_191, METH_O, (const char *)Dtool_ParticleSystem_set_emitter_191_comment},
  {"set_factory", &Dtool_ParticleSystem_set_factory_192, METH_O, (const char *)Dtool_ParticleSystem_set_factory_192_comment},
  {"setFactory", &Dtool_ParticleSystem_set_factory_192, METH_O, (const char *)Dtool_ParticleSystem_set_factory_192_comment},
  {"set_floor_z", &Dtool_ParticleSystem_set_floor_z_193, METH_O, (const char *)Dtool_ParticleSystem_set_floor_z_193_comment},
  {"setFloorZ", &Dtool_ParticleSystem_set_floor_z_193, METH_O, (const char *)Dtool_ParticleSystem_set_floor_z_193_comment},
  {"clear_floor_z", &Dtool_ParticleSystem_clear_floor_z_194, METH_NOARGS, (const char *)Dtool_ParticleSystem_clear_floor_z_194_comment},
  {"clearFloorZ", &Dtool_ParticleSystem_clear_floor_z_194, METH_NOARGS, (const char *)Dtool_ParticleSystem_clear_floor_z_194_comment},
  {"get_pool_size", &Dtool_ParticleSystem_get_pool_size_195, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_pool_size_195_comment},
  {"getPoolSize", &Dtool_ParticleSystem_get_pool_size_195, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_pool_size_195_comment},
  {"get_birth_rate", &Dtool_ParticleSystem_get_birth_rate_196, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_birth_rate_196_comment},
  {"getBirthRate", &Dtool_ParticleSystem_get_birth_rate_196, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_birth_rate_196_comment},
  {"get_soft_birth_rate", &Dtool_ParticleSystem_get_soft_birth_rate_197, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_soft_birth_rate_197_comment},
  {"getSoftBirthRate", &Dtool_ParticleSystem_get_soft_birth_rate_197, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_soft_birth_rate_197_comment},
  {"get_litter_size", &Dtool_ParticleSystem_get_litter_size_198, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_litter_size_198_comment},
  {"getLitterSize", &Dtool_ParticleSystem_get_litter_size_198, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_litter_size_198_comment},
  {"get_litter_spread", &Dtool_ParticleSystem_get_litter_spread_199, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_litter_spread_199_comment},
  {"getLitterSpread", &Dtool_ParticleSystem_get_litter_spread_199, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_litter_spread_199_comment},
  {"get_local_velocity_flag", &Dtool_ParticleSystem_get_local_velocity_flag_200, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_local_velocity_flag_200_comment},
  {"getLocalVelocityFlag", &Dtool_ParticleSystem_get_local_velocity_flag_200, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_local_velocity_flag_200_comment},
  {"get_system_grows_older_flag", &Dtool_ParticleSystem_get_system_grows_older_flag_201, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_system_grows_older_flag_201_comment},
  {"getSystemGrowsOlderFlag", &Dtool_ParticleSystem_get_system_grows_older_flag_201, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_system_grows_older_flag_201_comment},
  {"get_system_lifespan", &Dtool_ParticleSystem_get_system_lifespan_202, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_system_lifespan_202_comment},
  {"getSystemLifespan", &Dtool_ParticleSystem_get_system_lifespan_202, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_system_lifespan_202_comment},
  {"get_system_age", &Dtool_ParticleSystem_get_system_age_203, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_system_age_203_comment},
  {"getSystemAge", &Dtool_ParticleSystem_get_system_age_203, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_system_age_203_comment},
  {"get_active_system_flag", &Dtool_ParticleSystem_get_active_system_flag_204, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_active_system_flag_204_comment},
  {"getActiveSystemFlag", &Dtool_ParticleSystem_get_active_system_flag_204, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_active_system_flag_204_comment},
  {"get_spawn_on_death_flag", &Dtool_ParticleSystem_get_spawn_on_death_flag_205, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_spawn_on_death_flag_205_comment},
  {"getSpawnOnDeathFlag", &Dtool_ParticleSystem_get_spawn_on_death_flag_205, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_spawn_on_death_flag_205_comment},
  {"get_spawn_render_node", &Dtool_ParticleSystem_get_spawn_render_node_206, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_spawn_render_node_206_comment},
  {"getSpawnRenderNode", &Dtool_ParticleSystem_get_spawn_render_node_206, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_spawn_render_node_206_comment},
  {"get_spawn_render_node_path", &Dtool_ParticleSystem_get_spawn_render_node_path_207, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_spawn_render_node_path_207_comment},
  {"getSpawnRenderNodePath", &Dtool_ParticleSystem_get_spawn_render_node_path_207, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_spawn_render_node_path_207_comment},
  {"get_i_was_spawned_flag", &Dtool_ParticleSystem_get_i_was_spawned_flag_208, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_i_was_spawned_flag_208_comment},
  {"getIWasSpawnedFlag", &Dtool_ParticleSystem_get_i_was_spawned_flag_208, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_i_was_spawned_flag_208_comment},
  {"get_living_particles", &Dtool_ParticleSystem_get_living_particles_209, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_living_particles_209_comment},
  {"getLivingParticles", &Dtool_ParticleSystem_get_living_particles_209, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_living_particles_209_comment},
  {"get_render_parent", &Dtool_ParticleSystem_get_render_parent_210, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_render_parent_210_comment},
  {"getRenderParent", &Dtool_ParticleSystem_get_render_parent_210, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_render_parent_210_comment},
  {"get_renderer", &Dtool_ParticleSystem_get_renderer_211, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_renderer_211_comment},
  {"getRenderer", &Dtool_ParticleSystem_get_renderer_211, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_renderer_211_comment},
  {"get_emitter", &Dtool_ParticleSystem_get_emitter_212, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_emitter_212_comment},
  {"getEmitter", &Dtool_ParticleSystem_get_emitter_212, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_emitter_212_comment},
  {"get_factory", &Dtool_ParticleSystem_get_factory_213, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_factory_213_comment},
  {"getFactory", &Dtool_ParticleSystem_get_factory_213, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_factory_213_comment},
  {"get_floor_z", &Dtool_ParticleSystem_get_floor_z_214, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_floor_z_214_comment},
  {"getFloorZ", &Dtool_ParticleSystem_get_floor_z_214, METH_NOARGS, (const char *)Dtool_ParticleSystem_get_floor_z_214_comment},
  {"add_spawn_template", &Dtool_ParticleSystem_add_spawn_template_215, METH_O, (const char *)Dtool_ParticleSystem_add_spawn_template_215_comment},
  {"addSpawnTemplate", &Dtool_ParticleSystem_add_spawn_template_215, METH_O, (const char *)Dtool_ParticleSystem_add_spawn_template_215_comment},
  {"clear_spawn_templates", &Dtool_ParticleSystem_clear_spawn_templates_216, METH_NOARGS, (const char *)Dtool_ParticleSystem_clear_spawn_templates_216_comment},
  {"clearSpawnTemplates", &Dtool_ParticleSystem_clear_spawn_templates_216, METH_NOARGS, (const char *)Dtool_ParticleSystem_clear_spawn_templates_216_comment},
  {"render", &Dtool_ParticleSystem_render_217, METH_NOARGS, (const char *)Dtool_ParticleSystem_render_217_comment},
  {"induce_labor", &Dtool_ParticleSystem_induce_labor_218, METH_NOARGS, (const char *)Dtool_ParticleSystem_induce_labor_218_comment},
  {"induceLabor", &Dtool_ParticleSystem_induce_labor_218, METH_NOARGS, (const char *)Dtool_ParticleSystem_induce_labor_218_comment},
  {"clear_to_initial", &Dtool_ParticleSystem_clear_to_initial_219, METH_NOARGS, (const char *)Dtool_ParticleSystem_clear_to_initial_219_comment},
  {"clearToInitial", &Dtool_ParticleSystem_clear_to_initial_219, METH_NOARGS, (const char *)Dtool_ParticleSystem_clear_to_initial_219_comment},
  {"soft_stop", (PyCFunction) &Dtool_ParticleSystem_soft_stop_220, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParticleSystem_soft_stop_220_comment},
  {"softStop", (PyCFunction) &Dtool_ParticleSystem_soft_stop_220, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParticleSystem_soft_stop_220_comment},
  {"soft_start", (PyCFunction) &Dtool_ParticleSystem_soft_start_221, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParticleSystem_soft_start_221_comment},
  {"softStart", (PyCFunction) &Dtool_ParticleSystem_soft_start_221, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParticleSystem_soft_start_221_comment},
  {"update", &Dtool_ParticleSystem_update_222, METH_O, (const char *)Dtool_ParticleSystem_update_222_comment},
  {"write_free_particle_fifo", (PyCFunction) &Dtool_ParticleSystem_write_free_particle_fifo_223, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParticleSystem_write_free_particle_fifo_223_comment},
  {"writeFreeParticleFifo", (PyCFunction) &Dtool_ParticleSystem_write_free_particle_fifo_223, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParticleSystem_write_free_particle_fifo_223_comment},
  {"write_spawn_templates", (PyCFunction) &Dtool_ParticleSystem_write_spawn_templates_224, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParticleSystem_write_spawn_templates_224_comment},
  {"writeSpawnTemplates", (PyCFunction) &Dtool_ParticleSystem_write_spawn_templates_224, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParticleSystem_write_spawn_templates_224_comment},
  {"write", (PyCFunction) &Dtool_ParticleSystem_write_225, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParticleSystem_write_225_comment},
  {"get_class_type", &Dtool_ParticleSystem_get_class_type_226, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParticleSystem_get_class_type_226_comment},
  {"getClassType", &Dtool_ParticleSystem_get_class_type_226, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParticleSystem_get_class_type_226_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     ParticleSystem
//////////////////
static PyObject *Dtool_Str_ParticleSystem(PyObject *self) {
  ParticleSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystem, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ParticleSystem = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParticleSystem = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ParticleSystem = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ParticleSystem = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ParticleSystem = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.ParticleSystem",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParticleSystem,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ParticleSystem,
    &Dtool_SequenceMethods_ParticleSystem,
    &Dtool_MappingMethods_ParticleSystem,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_ParticleSystem,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ParticleSystem,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Contains and manages a particle system.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParticleSystem,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParticleSystem,
    PyType_GenericAlloc,
    Dtool_new_ParticleSystem,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParticleSystem,
  Dtool_UpcastInterface_ParticleSystem,
  Dtool_DowncastInterface_ParticleSystem,
  (CoerceFunction)Dtool_ConstCoerce_ParticleSystem,
  (CoerceFunction)Dtool_Coerce_ParticleSystem,
};

static void Dtool_PyModuleClassInit_ParticleSystem(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Physical != NULL);
    assert(Dtool_Ptr_Physical->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Physical->_Dtool_ModuleClassInit(NULL);
    Dtool_ParticleSystem._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Physical);
    PyObject *dict = PyDict_New();
    Dtool_ParticleSystem._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParticleSystem) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParticleSystem)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParticleSystem);
  }
}

/**
 * Python method tables for PointEmitter (PointEmitter)
 */
static PyMethodDef Dtool_Methods_PointEmitter[] = {
  {"set_location", &Dtool_PointEmitter_set_location_229, METH_O, (const char *)Dtool_PointEmitter_set_location_229_comment},
  {"setLocation", &Dtool_PointEmitter_set_location_229, METH_O, (const char *)Dtool_PointEmitter_set_location_229_comment},
  {"get_location", &Dtool_PointEmitter_get_location_230, METH_NOARGS, (const char *)Dtool_PointEmitter_get_location_230_comment},
  {"getLocation", &Dtool_PointEmitter_get_location_230, METH_NOARGS, (const char *)Dtool_PointEmitter_get_location_230_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointEmitter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointEmitter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointEmitter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointEmitter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointEmitter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.PointEmitter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointEmitter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointEmitter,
    &Dtool_SequenceMethods_PointEmitter,
    &Dtool_MappingMethods_PointEmitter,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointEmitter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Describes a planar ring region in which particles are generated.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointEmitter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointEmitter,
    PyType_GenericAlloc,
    Dtool_new_PointEmitter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointEmitter,
  Dtool_UpcastInterface_PointEmitter,
  Dtool_DowncastInterface_PointEmitter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointEmitter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseParticleEmitter(NULL);
    Dtool_PointEmitter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseParticleEmitter);
    PyObject *dict = PyDict_New();
    Dtool_PointEmitter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointEmitter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointEmitter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointEmitter);
  }
}

/**
 * Python method tables for PointParticleFactory (PointParticleFactory)
 */
static PyMethodDef Dtool_Methods_PointParticleFactory[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointParticleFactory = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointParticleFactory = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointParticleFactory = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointParticleFactory = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointParticleFactory = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.PointParticleFactory",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointParticleFactory,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointParticleFactory,
    &Dtool_SequenceMethods_PointParticleFactory,
    &Dtool_MappingMethods_PointParticleFactory,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointParticleFactory,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointParticleFactory,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointParticleFactory,
    PyType_GenericAlloc,
    Dtool_new_PointParticleFactory,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointParticleFactory,
  Dtool_UpcastInterface_PointParticleFactory,
  Dtool_DowncastInterface_PointParticleFactory,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointParticleFactory(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseParticleFactory(NULL);
    Dtool_PointParticleFactory._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseParticleFactory);
    PyObject *dict = PyDict_New();
    Dtool_PointParticleFactory._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointParticleFactory) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointParticleFactory)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointParticleFactory);
  }
}

/**
 * Python method tables for PointParticleRenderer (PointParticleRenderer)
 */
static PyMethodDef Dtool_Methods_PointParticleRenderer[] = {
  {"set_point_size", &Dtool_PointParticleRenderer_set_point_size_236, METH_O, (const char *)Dtool_PointParticleRenderer_set_point_size_236_comment},
  {"setPointSize", &Dtool_PointParticleRenderer_set_point_size_236, METH_O, (const char *)Dtool_PointParticleRenderer_set_point_size_236_comment},
  {"set_start_color", &Dtool_PointParticleRenderer_set_start_color_237, METH_O, (const char *)Dtool_PointParticleRenderer_set_start_color_237_comment},
  {"setStartColor", &Dtool_PointParticleRenderer_set_start_color_237, METH_O, (const char *)Dtool_PointParticleRenderer_set_start_color_237_comment},
  {"set_end_color", &Dtool_PointParticleRenderer_set_end_color_238, METH_O, (const char *)Dtool_PointParticleRenderer_set_end_color_238_comment},
  {"setEndColor", &Dtool_PointParticleRenderer_set_end_color_238, METH_O, (const char *)Dtool_PointParticleRenderer_set_end_color_238_comment},
  {"set_blend_type", &Dtool_PointParticleRenderer_set_blend_type_239, METH_O, (const char *)Dtool_PointParticleRenderer_set_blend_type_239_comment},
  {"setBlendType", &Dtool_PointParticleRenderer_set_blend_type_239, METH_O, (const char *)Dtool_PointParticleRenderer_set_blend_type_239_comment},
  {"set_blend_method", &Dtool_PointParticleRenderer_set_blend_method_240, METH_O, (const char *)Dtool_PointParticleRenderer_set_blend_method_240_comment},
  {"setBlendMethod", &Dtool_PointParticleRenderer_set_blend_method_240, METH_O, (const char *)Dtool_PointParticleRenderer_set_blend_method_240_comment},
  {"get_point_size", &Dtool_PointParticleRenderer_get_point_size_241, METH_NOARGS, (const char *)Dtool_PointParticleRenderer_get_point_size_241_comment},
  {"getPointSize", &Dtool_PointParticleRenderer_get_point_size_241, METH_NOARGS, (const char *)Dtool_PointParticleRenderer_get_point_size_241_comment},
  {"get_start_color", &Dtool_PointParticleRenderer_get_start_color_242, METH_NOARGS, (const char *)Dtool_PointParticleRenderer_get_start_color_242_comment},
  {"getStartColor", &Dtool_PointParticleRenderer_get_start_color_242, METH_NOARGS, (const char *)Dtool_PointParticleRenderer_get_start_color_242_comment},
  {"get_end_color", &Dtool_PointParticleRenderer_get_end_color_243, METH_NOARGS, (const char *)Dtool_PointParticleRenderer_get_end_color_243_comment},
  {"getEndColor", &Dtool_PointParticleRenderer_get_end_color_243, METH_NOARGS, (const char *)Dtool_PointParticleRenderer_get_end_color_243_comment},
  {"get_blend_type", &Dtool_PointParticleRenderer_get_blend_type_244, METH_NOARGS, (const char *)Dtool_PointParticleRenderer_get_blend_type_244_comment},
  {"getBlendType", &Dtool_PointParticleRenderer_get_blend_type_244, METH_NOARGS, (const char *)Dtool_PointParticleRenderer_get_blend_type_244_comment},
  {"get_blend_method", &Dtool_PointParticleRenderer_get_blend_method_245, METH_NOARGS, (const char *)Dtool_PointParticleRenderer_get_blend_method_245_comment},
  {"getBlendMethod", &Dtool_PointParticleRenderer_get_blend_method_245, METH_NOARGS, (const char *)Dtool_PointParticleRenderer_get_blend_method_245_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointParticleRenderer = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointParticleRenderer = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointParticleRenderer = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointParticleRenderer = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointParticleRenderer = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.PointParticleRenderer",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointParticleRenderer,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointParticleRenderer,
    &Dtool_SequenceMethods_PointParticleRenderer,
    &Dtool_MappingMethods_PointParticleRenderer,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointParticleRenderer,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointParticleRenderer,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointParticleRenderer,
    PyType_GenericAlloc,
    Dtool_new_PointParticleRenderer,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointParticleRenderer,
  Dtool_UpcastInterface_PointParticleRenderer,
  Dtool_DowncastInterface_PointParticleRenderer,
  (CoerceFunction)Dtool_ConstCoerce_PointParticleRenderer,
  (CoerceFunction)Dtool_Coerce_PointParticleRenderer,
};

static void Dtool_PyModuleClassInit_PointParticleRenderer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseParticleRenderer(NULL);
    Dtool_PointParticleRenderer._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseParticleRenderer);
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_PointParticleRenderer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum PointParticleRenderer::PointParticleBlendType;
    PyDict_SetItemString(dict, "PP_ONE_COLOR", Dtool_WrapValue(PointParticleRenderer::PP_ONE_COLOR));
    PyDict_SetItemString(dict, "PPONECOLOR", Dtool_WrapValue(PointParticleRenderer::PP_ONE_COLOR));
    PyDict_SetItemString(dict, "PP_BLEND_LIFE", Dtool_WrapValue(PointParticleRenderer::PP_BLEND_LIFE));
    PyDict_SetItemString(dict, "PPBLENDLIFE", Dtool_WrapValue(PointParticleRenderer::PP_BLEND_LIFE));
    PyDict_SetItemString(dict, "PP_BLEND_VEL", Dtool_WrapValue(PointParticleRenderer::PP_BLEND_VEL));
    PyDict_SetItemString(dict, "PPBLENDVEL", Dtool_WrapValue(PointParticleRenderer::PP_BLEND_VEL));
    if (PyType_Ready((PyTypeObject *)&Dtool_PointParticleRenderer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointParticleRenderer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointParticleRenderer);
  }
}

/**
 * Python method tables for RectangleEmitter (RectangleEmitter)
 */
static PyMethodDef Dtool_Methods_RectangleEmitter[] = {
  {"set_min_bound", &Dtool_RectangleEmitter_set_min_bound_248, METH_O, (const char *)Dtool_RectangleEmitter_set_min_bound_248_comment},
  {"setMinBound", &Dtool_RectangleEmitter_set_min_bound_248, METH_O, (const char *)Dtool_RectangleEmitter_set_min_bound_248_comment},
  {"set_max_bound", &Dtool_RectangleEmitter_set_max_bound_249, METH_O, (const char *)Dtool_RectangleEmitter_set_max_bound_249_comment},
  {"setMaxBound", &Dtool_RectangleEmitter_set_max_bound_249, METH_O, (const char *)Dtool_RectangleEmitter_set_max_bound_249_comment},
  {"get_min_bound", &Dtool_RectangleEmitter_get_min_bound_250, METH_NOARGS, (const char *)Dtool_RectangleEmitter_get_min_bound_250_comment},
  {"getMinBound", &Dtool_RectangleEmitter_get_min_bound_250, METH_NOARGS, (const char *)Dtool_RectangleEmitter_get_min_bound_250_comment},
  {"get_max_bound", &Dtool_RectangleEmitter_get_max_bound_251, METH_NOARGS, (const char *)Dtool_RectangleEmitter_get_max_bound_251_comment},
  {"getMaxBound", &Dtool_RectangleEmitter_get_max_bound_251, METH_NOARGS, (const char *)Dtool_RectangleEmitter_get_max_bound_251_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_RectangleEmitter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RectangleEmitter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_RectangleEmitter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_RectangleEmitter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_RectangleEmitter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.RectangleEmitter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_RectangleEmitter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_RectangleEmitter,
    &Dtool_SequenceMethods_RectangleEmitter,
    &Dtool_MappingMethods_RectangleEmitter,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_RectangleEmitter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Describes a planar square region in which particles are generated.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_RectangleEmitter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_RectangleEmitter,
    PyType_GenericAlloc,
    Dtool_new_RectangleEmitter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RectangleEmitter,
  Dtool_UpcastInterface_RectangleEmitter,
  Dtool_DowncastInterface_RectangleEmitter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_RectangleEmitter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseParticleEmitter(NULL);
    Dtool_RectangleEmitter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseParticleEmitter);
    PyObject *dict = PyDict_New();
    Dtool_RectangleEmitter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RectangleEmitter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RectangleEmitter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RectangleEmitter);
  }
}

/**
 * Python method tables for SparkleParticleRenderer (SparkleParticleRenderer)
 */
static PyMethodDef Dtool_Methods_SparkleParticleRenderer[] = {
  {"set_center_color", &Dtool_SparkleParticleRenderer_set_center_color_255, METH_O, (const char *)Dtool_SparkleParticleRenderer_set_center_color_255_comment},
  {"setCenterColor", &Dtool_SparkleParticleRenderer_set_center_color_255, METH_O, (const char *)Dtool_SparkleParticleRenderer_set_center_color_255_comment},
  {"set_edge_color", &Dtool_SparkleParticleRenderer_set_edge_color_256, METH_O, (const char *)Dtool_SparkleParticleRenderer_set_edge_color_256_comment},
  {"setEdgeColor", &Dtool_SparkleParticleRenderer_set_edge_color_256, METH_O, (const char *)Dtool_SparkleParticleRenderer_set_edge_color_256_comment},
  {"set_birth_radius", &Dtool_SparkleParticleRenderer_set_birth_radius_257, METH_O, (const char *)Dtool_SparkleParticleRenderer_set_birth_radius_257_comment},
  {"setBirthRadius", &Dtool_SparkleParticleRenderer_set_birth_radius_257, METH_O, (const char *)Dtool_SparkleParticleRenderer_set_birth_radius_257_comment},
  {"set_death_radius", &Dtool_SparkleParticleRenderer_set_death_radius_258, METH_O, (const char *)Dtool_SparkleParticleRenderer_set_death_radius_258_comment},
  {"setDeathRadius", &Dtool_SparkleParticleRenderer_set_death_radius_258, METH_O, (const char *)Dtool_SparkleParticleRenderer_set_death_radius_258_comment},
  {"set_life_scale", &Dtool_SparkleParticleRenderer_set_life_scale_259, METH_O, (const char *)Dtool_SparkleParticleRenderer_set_life_scale_259_comment},
  {"setLifeScale", &Dtool_SparkleParticleRenderer_set_life_scale_259, METH_O, (const char *)Dtool_SparkleParticleRenderer_set_life_scale_259_comment},
  {"get_center_color", &Dtool_SparkleParticleRenderer_get_center_color_260, METH_NOARGS, (const char *)Dtool_SparkleParticleRenderer_get_center_color_260_comment},
  {"getCenterColor", &Dtool_SparkleParticleRenderer_get_center_color_260, METH_NOARGS, (const char *)Dtool_SparkleParticleRenderer_get_center_color_260_comment},
  {"get_edge_color", &Dtool_SparkleParticleRenderer_get_edge_color_261, METH_NOARGS, (const char *)Dtool_SparkleParticleRenderer_get_edge_color_261_comment},
  {"getEdgeColor", &Dtool_SparkleParticleRenderer_get_edge_color_261, METH_NOARGS, (const char *)Dtool_SparkleParticleRenderer_get_edge_color_261_comment},
  {"get_birth_radius", &Dtool_SparkleParticleRenderer_get_birth_radius_262, METH_NOARGS, (const char *)Dtool_SparkleParticleRenderer_get_birth_radius_262_comment},
  {"getBirthRadius", &Dtool_SparkleParticleRenderer_get_birth_radius_262, METH_NOARGS, (const char *)Dtool_SparkleParticleRenderer_get_birth_radius_262_comment},
  {"get_death_radius", &Dtool_SparkleParticleRenderer_get_death_radius_263, METH_NOARGS, (const char *)Dtool_SparkleParticleRenderer_get_death_radius_263_comment},
  {"getDeathRadius", &Dtool_SparkleParticleRenderer_get_death_radius_263, METH_NOARGS, (const char *)Dtool_SparkleParticleRenderer_get_death_radius_263_comment},
  {"get_life_scale", &Dtool_SparkleParticleRenderer_get_life_scale_264, METH_NOARGS, (const char *)Dtool_SparkleParticleRenderer_get_life_scale_264_comment},
  {"getLifeScale", &Dtool_SparkleParticleRenderer_get_life_scale_264, METH_NOARGS, (const char *)Dtool_SparkleParticleRenderer_get_life_scale_264_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_SparkleParticleRenderer = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SparkleParticleRenderer = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_SparkleParticleRenderer = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_SparkleParticleRenderer = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_SparkleParticleRenderer = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.SparkleParticleRenderer",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SparkleParticleRenderer,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_SparkleParticleRenderer,
    &Dtool_SequenceMethods_SparkleParticleRenderer,
    &Dtool_MappingMethods_SparkleParticleRenderer,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_SparkleParticleRenderer,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * pretty sparkly things.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SparkleParticleRenderer,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SparkleParticleRenderer,
    PyType_GenericAlloc,
    Dtool_new_SparkleParticleRenderer,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SparkleParticleRenderer,
  Dtool_UpcastInterface_SparkleParticleRenderer,
  Dtool_DowncastInterface_SparkleParticleRenderer,
  (CoerceFunction)Dtool_ConstCoerce_SparkleParticleRenderer,
  (CoerceFunction)Dtool_Coerce_SparkleParticleRenderer,
};

static void Dtool_PyModuleClassInit_SparkleParticleRenderer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseParticleRenderer(NULL);
    Dtool_SparkleParticleRenderer._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseParticleRenderer);
    PyObject *dict = PyDict_New();
    Dtool_SparkleParticleRenderer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum SparkleParticleRenderer::SparkleParticleLifeScale;
    PyDict_SetItemString(dict, "SP_NO_SCALE", Dtool_WrapValue(SparkleParticleRenderer::SP_NO_SCALE));
    PyDict_SetItemString(dict, "SPNOSCALE", Dtool_WrapValue(SparkleParticleRenderer::SP_NO_SCALE));
    PyDict_SetItemString(dict, "SP_SCALE", Dtool_WrapValue(SparkleParticleRenderer::SP_SCALE));
    PyDict_SetItemString(dict, "SPSCALE", Dtool_WrapValue(SparkleParticleRenderer::SP_SCALE));
    if (PyType_Ready((PyTypeObject *)&Dtool_SparkleParticleRenderer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SparkleParticleRenderer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SparkleParticleRenderer);
  }
}

/**
 * Python method tables for SphereSurfaceEmitter (SphereSurfaceEmitter)
 */
static PyMethodDef Dtool_Methods_SphereSurfaceEmitter[] = {
  {"set_radius", &Dtool_SphereSurfaceEmitter_set_radius_267, METH_O, (const char *)Dtool_SphereSurfaceEmitter_set_radius_267_comment},
  {"setRadius", &Dtool_SphereSurfaceEmitter_set_radius_267, METH_O, (const char *)Dtool_SphereSurfaceEmitter_set_radius_267_comment},
  {"get_radius", &Dtool_SphereSurfaceEmitter_get_radius_268, METH_NOARGS, (const char *)Dtool_SphereSurfaceEmitter_get_radius_268_comment},
  {"getRadius", &Dtool_SphereSurfaceEmitter_get_radius_268, METH_NOARGS, (const char *)Dtool_SphereSurfaceEmitter_get_radius_268_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_SphereSurfaceEmitter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SphereSurfaceEmitter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_SphereSurfaceEmitter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_SphereSurfaceEmitter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_SphereSurfaceEmitter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.SphereSurfaceEmitter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SphereSurfaceEmitter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_SphereSurfaceEmitter,
    &Dtool_SequenceMethods_SphereSurfaceEmitter,
    &Dtool_MappingMethods_SphereSurfaceEmitter,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_SphereSurfaceEmitter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Describes a curved space in which particles are generated.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SphereSurfaceEmitter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SphereSurfaceEmitter,
    PyType_GenericAlloc,
    Dtool_new_SphereSurfaceEmitter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SphereSurfaceEmitter,
  Dtool_UpcastInterface_SphereSurfaceEmitter,
  Dtool_DowncastInterface_SphereSurfaceEmitter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_SphereSurfaceEmitter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseParticleEmitter(NULL);
    Dtool_SphereSurfaceEmitter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseParticleEmitter);
    PyObject *dict = PyDict_New();
    Dtool_SphereSurfaceEmitter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SphereSurfaceEmitter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SphereSurfaceEmitter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SphereSurfaceEmitter);
  }
}

/**
 * Python method tables for SphereVolumeEmitter (SphereVolumeEmitter)
 */
static PyMethodDef Dtool_Methods_SphereVolumeEmitter[] = {
  {"set_radius", &Dtool_SphereVolumeEmitter_set_radius_271, METH_O, (const char *)Dtool_SphereVolumeEmitter_set_radius_271_comment},
  {"setRadius", &Dtool_SphereVolumeEmitter_set_radius_271, METH_O, (const char *)Dtool_SphereVolumeEmitter_set_radius_271_comment},
  {"get_radius", &Dtool_SphereVolumeEmitter_get_radius_272, METH_NOARGS, (const char *)Dtool_SphereVolumeEmitter_get_radius_272_comment},
  {"getRadius", &Dtool_SphereVolumeEmitter_get_radius_272, METH_NOARGS, (const char *)Dtool_SphereVolumeEmitter_get_radius_272_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_SphereVolumeEmitter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SphereVolumeEmitter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_SphereVolumeEmitter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_SphereVolumeEmitter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_SphereVolumeEmitter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.SphereVolumeEmitter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SphereVolumeEmitter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_SphereVolumeEmitter,
    &Dtool_SequenceMethods_SphereVolumeEmitter,
    &Dtool_MappingMethods_SphereVolumeEmitter,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_SphereVolumeEmitter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Describes a voluminous spherical region in which particles are generated.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SphereVolumeEmitter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SphereVolumeEmitter,
    PyType_GenericAlloc,
    Dtool_new_SphereVolumeEmitter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SphereVolumeEmitter,
  Dtool_UpcastInterface_SphereVolumeEmitter,
  Dtool_DowncastInterface_SphereVolumeEmitter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_SphereVolumeEmitter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseParticleEmitter(NULL);
    Dtool_SphereVolumeEmitter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseParticleEmitter);
    PyObject *dict = PyDict_New();
    Dtool_SphereVolumeEmitter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SphereVolumeEmitter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SphereVolumeEmitter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SphereVolumeEmitter);
  }
}

/**
 * Python method tables for SpriteAnim (SpriteAnim)
 */
static PyMethodDef Dtool_Methods_SpriteAnim[] = {
  {"set_source_info", (PyCFunction) &Dtool_SpriteAnim_set_source_info_275, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteAnim_set_source_info_275_comment},
  {"setSourceInfo", (PyCFunction) &Dtool_SpriteAnim_set_source_info_275, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteAnim_set_source_info_275_comment},
  {"get_source_type", &Dtool_SpriteAnim_get_source_type_276, METH_NOARGS, (const char *)Dtool_SpriteAnim_get_source_type_276_comment},
  {"getSourceType", &Dtool_SpriteAnim_get_source_type_276, METH_NOARGS, (const char *)Dtool_SpriteAnim_get_source_type_276_comment},
  {"get_tex_source", &Dtool_SpriteAnim_get_tex_source_277, METH_NOARGS, (const char *)Dtool_SpriteAnim_get_tex_source_277_comment},
  {"getTexSource", &Dtool_SpriteAnim_get_tex_source_277, METH_NOARGS, (const char *)Dtool_SpriteAnim_get_tex_source_277_comment},
  {"get_model_source", &Dtool_SpriteAnim_get_model_source_278, METH_NOARGS, (const char *)Dtool_SpriteAnim_get_model_source_278_comment},
  {"getModelSource", &Dtool_SpriteAnim_get_model_source_278, METH_NOARGS, (const char *)Dtool_SpriteAnim_get_model_source_278_comment},
  {"get_node_source", &Dtool_SpriteAnim_get_node_source_279, METH_NOARGS, (const char *)Dtool_SpriteAnim_get_node_source_279_comment},
  {"getNodeSource", &Dtool_SpriteAnim_get_node_source_279, METH_NOARGS, (const char *)Dtool_SpriteAnim_get_node_source_279_comment},
  {"get_num_frames", &Dtool_SpriteAnim_get_num_frames_280, METH_NOARGS, (const char *)Dtool_SpriteAnim_get_num_frames_280_comment},
  {"getNumFrames", &Dtool_SpriteAnim_get_num_frames_280, METH_NOARGS, (const char *)Dtool_SpriteAnim_get_num_frames_280_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_SpriteAnim = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SpriteAnim = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_SpriteAnim = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_SpriteAnim = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_SpriteAnim = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.SpriteAnim",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SpriteAnim,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_SpriteAnim,
    &Dtool_SequenceMethods_SpriteAnim,
    &Dtool_MappingMethods_SpriteAnim,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_SpriteAnim,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Helper class used by SpriteParticleRenderer to keep track of its textures\n"
    " * and their respective UVs and source types.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SpriteAnim,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SpriteAnim,
    PyType_GenericAlloc,
    Dtool_new_SpriteAnim,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SpriteAnim,
  Dtool_UpcastInterface_SpriteAnim,
  Dtool_DowncastInterface_SpriteAnim,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_SpriteAnim(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_SpriteAnim._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_SpriteAnim._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum SpriteAnim::SourceType;
    PyDict_SetItemString(dict, "ST_texture", Dtool_WrapValue(SpriteAnim::ST_texture));
    PyDict_SetItemString(dict, "STTexture", Dtool_WrapValue(SpriteAnim::ST_texture));
    PyDict_SetItemString(dict, "ST_from_node", Dtool_WrapValue(SpriteAnim::ST_from_node));
    PyDict_SetItemString(dict, "STFromNode", Dtool_WrapValue(SpriteAnim::ST_from_node));
    if (PyType_Ready((PyTypeObject *)&Dtool_SpriteAnim) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SpriteAnim)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SpriteAnim);
  }
}

/**
 * Python method tables for SpriteParticleRenderer (SpriteParticleRenderer)
 */
static PyMethodDef Dtool_Methods_SpriteParticleRenderer[] = {
  {"set_from_node", (PyCFunction) &Dtool_SpriteParticleRenderer_set_from_node_285, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_set_from_node_285_comment},
  {"setFromNode", (PyCFunction) &Dtool_SpriteParticleRenderer_set_from_node_285, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_set_from_node_285_comment},
  {"add_from_node", (PyCFunction) &Dtool_SpriteParticleRenderer_add_from_node_286, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_add_from_node_286_comment},
  {"addFromNode", (PyCFunction) &Dtool_SpriteParticleRenderer_add_from_node_286, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_add_from_node_286_comment},
  {"set_texture", (PyCFunction) &Dtool_SpriteParticleRenderer_set_texture_287, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_set_texture_287_comment},
  {"setTexture", (PyCFunction) &Dtool_SpriteParticleRenderer_set_texture_287, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_set_texture_287_comment},
  {"add_texture", (PyCFunction) &Dtool_SpriteParticleRenderer_add_texture_288, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_add_texture_288_comment},
  {"addTexture", (PyCFunction) &Dtool_SpriteParticleRenderer_add_texture_288, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_add_texture_288_comment},
  {"remove_animation", &Dtool_SpriteParticleRenderer_remove_animation_289, METH_O, (const char *)Dtool_SpriteParticleRenderer_remove_animation_289_comment},
  {"removeAnimation", &Dtool_SpriteParticleRenderer_remove_animation_289, METH_O, (const char *)Dtool_SpriteParticleRenderer_remove_animation_289_comment},
  {"set_ll_uv", (PyCFunction) &Dtool_SpriteParticleRenderer_set_ll_uv_290, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_set_ll_uv_290_comment},
  {"setLlUv", (PyCFunction) &Dtool_SpriteParticleRenderer_set_ll_uv_290, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_set_ll_uv_290_comment},
  {"set_ur_uv", (PyCFunction) &Dtool_SpriteParticleRenderer_set_ur_uv_291, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_set_ur_uv_291_comment},
  {"setUrUv", (PyCFunction) &Dtool_SpriteParticleRenderer_set_ur_uv_291, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_set_ur_uv_291_comment},
  {"set_size", (PyCFunction) &Dtool_SpriteParticleRenderer_set_size_292, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_set_size_292_comment},
  {"setSize", (PyCFunction) &Dtool_SpriteParticleRenderer_set_size_292, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_set_size_292_comment},
  {"set_color", &Dtool_SpriteParticleRenderer_set_color_293, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_color_293_comment},
  {"setColor", &Dtool_SpriteParticleRenderer_set_color_293, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_color_293_comment},
  {"set_x_scale_flag", &Dtool_SpriteParticleRenderer_set_x_scale_flag_294, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_x_scale_flag_294_comment},
  {"setXScaleFlag", &Dtool_SpriteParticleRenderer_set_x_scale_flag_294, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_x_scale_flag_294_comment},
  {"set_y_scale_flag", &Dtool_SpriteParticleRenderer_set_y_scale_flag_295, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_y_scale_flag_295_comment},
  {"setYScaleFlag", &Dtool_SpriteParticleRenderer_set_y_scale_flag_295, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_y_scale_flag_295_comment},
  {"set_anim_angle_flag", &Dtool_SpriteParticleRenderer_set_anim_angle_flag_296, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_anim_angle_flag_296_comment},
  {"setAnimAngleFlag", &Dtool_SpriteParticleRenderer_set_anim_angle_flag_296, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_anim_angle_flag_296_comment},
  {"set_initial_x_scale", &Dtool_SpriteParticleRenderer_set_initial_x_scale_297, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_initial_x_scale_297_comment},
  {"setInitialXScale", &Dtool_SpriteParticleRenderer_set_initial_x_scale_297, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_initial_x_scale_297_comment},
  {"set_final_x_scale", &Dtool_SpriteParticleRenderer_set_final_x_scale_298, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_final_x_scale_298_comment},
  {"setFinalXScale", &Dtool_SpriteParticleRenderer_set_final_x_scale_298, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_final_x_scale_298_comment},
  {"set_initial_y_scale", &Dtool_SpriteParticleRenderer_set_initial_y_scale_299, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_initial_y_scale_299_comment},
  {"setInitialYScale", &Dtool_SpriteParticleRenderer_set_initial_y_scale_299, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_initial_y_scale_299_comment},
  {"set_final_y_scale", &Dtool_SpriteParticleRenderer_set_final_y_scale_300, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_final_y_scale_300_comment},
  {"setFinalYScale", &Dtool_SpriteParticleRenderer_set_final_y_scale_300, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_final_y_scale_300_comment},
  {"set_nonanimated_theta", &Dtool_SpriteParticleRenderer_set_nonanimated_theta_301, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_nonanimated_theta_301_comment},
  {"setNonanimatedTheta", &Dtool_SpriteParticleRenderer_set_nonanimated_theta_301, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_nonanimated_theta_301_comment},
  {"set_alpha_blend_method", &Dtool_SpriteParticleRenderer_set_alpha_blend_method_302, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_alpha_blend_method_302_comment},
  {"setAlphaBlendMethod", &Dtool_SpriteParticleRenderer_set_alpha_blend_method_302, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_alpha_blend_method_302_comment},
  {"set_alpha_disable", &Dtool_SpriteParticleRenderer_set_alpha_disable_303, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_alpha_disable_303_comment},
  {"setAlphaDisable", &Dtool_SpriteParticleRenderer_set_alpha_disable_303, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_alpha_disable_303_comment},
  {"set_animate_frames_enable", &Dtool_SpriteParticleRenderer_set_animate_frames_enable_304, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_animate_frames_enable_304_comment},
  {"setAnimateFramesEnable", &Dtool_SpriteParticleRenderer_set_animate_frames_enable_304, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_animate_frames_enable_304_comment},
  {"set_animate_frames_rate", &Dtool_SpriteParticleRenderer_set_animate_frames_rate_305, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_animate_frames_rate_305_comment},
  {"setAnimateFramesRate", &Dtool_SpriteParticleRenderer_set_animate_frames_rate_305, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_animate_frames_rate_305_comment},
  {"set_animate_frames_index", &Dtool_SpriteParticleRenderer_set_animate_frames_index_306, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_animate_frames_index_306_comment},
  {"setAnimateFramesIndex", &Dtool_SpriteParticleRenderer_set_animate_frames_index_306, METH_O, (const char *)Dtool_SpriteParticleRenderer_set_animate_frames_index_306_comment},
  {"get_texture", (PyCFunction) &Dtool_SpriteParticleRenderer_get_texture_307, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_get_texture_307_comment},
  {"getTexture", (PyCFunction) &Dtool_SpriteParticleRenderer_get_texture_307, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_get_texture_307_comment},
  {"get_num_anims", &Dtool_SpriteParticleRenderer_get_num_anims_308, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_num_anims_308_comment},
  {"getNumAnims", &Dtool_SpriteParticleRenderer_get_num_anims_308, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_num_anims_308_comment},
  {"get_anim", &Dtool_SpriteParticleRenderer_get_anim_309, METH_O, (const char *)Dtool_SpriteParticleRenderer_get_anim_309_comment},
  {"getAnim", &Dtool_SpriteParticleRenderer_get_anim_309, METH_O, (const char *)Dtool_SpriteParticleRenderer_get_anim_309_comment},
  {"get_last_anim", &Dtool_SpriteParticleRenderer_get_last_anim_311, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_last_anim_311_comment},
  {"getLastAnim", &Dtool_SpriteParticleRenderer_get_last_anim_311, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_last_anim_311_comment},
  {"get_color_interpolation_manager", &Dtool_SpriteParticleRenderer_get_color_interpolation_manager_312, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_color_interpolation_manager_312_comment},
  {"getColorInterpolationManager", &Dtool_SpriteParticleRenderer_get_color_interpolation_manager_312, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_color_interpolation_manager_312_comment},
  {"get_ll_uv", (PyCFunction) &Dtool_SpriteParticleRenderer_get_ll_uv_313, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_get_ll_uv_313_comment},
  {"getLlUv", (PyCFunction) &Dtool_SpriteParticleRenderer_get_ll_uv_313, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_get_ll_uv_313_comment},
  {"get_ur_uv", (PyCFunction) &Dtool_SpriteParticleRenderer_get_ur_uv_314, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_get_ur_uv_314_comment},
  {"getUrUv", (PyCFunction) &Dtool_SpriteParticleRenderer_get_ur_uv_314, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SpriteParticleRenderer_get_ur_uv_314_comment},
  {"get_width", &Dtool_SpriteParticleRenderer_get_width_315, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_width_315_comment},
  {"getWidth", &Dtool_SpriteParticleRenderer_get_width_315, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_width_315_comment},
  {"get_height", &Dtool_SpriteParticleRenderer_get_height_316, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_height_316_comment},
  {"getHeight", &Dtool_SpriteParticleRenderer_get_height_316, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_height_316_comment},
  {"get_color", &Dtool_SpriteParticleRenderer_get_color_317, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_color_317_comment},
  {"getColor", &Dtool_SpriteParticleRenderer_get_color_317, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_color_317_comment},
  {"get_x_scale_flag", &Dtool_SpriteParticleRenderer_get_x_scale_flag_318, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_x_scale_flag_318_comment},
  {"getXScaleFlag", &Dtool_SpriteParticleRenderer_get_x_scale_flag_318, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_x_scale_flag_318_comment},
  {"get_y_scale_flag", &Dtool_SpriteParticleRenderer_get_y_scale_flag_319, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_y_scale_flag_319_comment},
  {"getYScaleFlag", &Dtool_SpriteParticleRenderer_get_y_scale_flag_319, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_y_scale_flag_319_comment},
  {"get_anim_angle_flag", &Dtool_SpriteParticleRenderer_get_anim_angle_flag_320, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_anim_angle_flag_320_comment},
  {"getAnimAngleFlag", &Dtool_SpriteParticleRenderer_get_anim_angle_flag_320, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_anim_angle_flag_320_comment},
  {"get_initial_x_scale", &Dtool_SpriteParticleRenderer_get_initial_x_scale_321, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_initial_x_scale_321_comment},
  {"getInitialXScale", &Dtool_SpriteParticleRenderer_get_initial_x_scale_321, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_initial_x_scale_321_comment},
  {"get_final_x_scale", &Dtool_SpriteParticleRenderer_get_final_x_scale_322, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_final_x_scale_322_comment},
  {"getFinalXScale", &Dtool_SpriteParticleRenderer_get_final_x_scale_322, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_final_x_scale_322_comment},
  {"get_initial_y_scale", &Dtool_SpriteParticleRenderer_get_initial_y_scale_323, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_initial_y_scale_323_comment},
  {"getInitialYScale", &Dtool_SpriteParticleRenderer_get_initial_y_scale_323, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_initial_y_scale_323_comment},
  {"get_final_y_scale", &Dtool_SpriteParticleRenderer_get_final_y_scale_324, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_final_y_scale_324_comment},
  {"getFinalYScale", &Dtool_SpriteParticleRenderer_get_final_y_scale_324, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_final_y_scale_324_comment},
  {"get_nonanimated_theta", &Dtool_SpriteParticleRenderer_get_nonanimated_theta_325, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_nonanimated_theta_325_comment},
  {"getNonanimatedTheta", &Dtool_SpriteParticleRenderer_get_nonanimated_theta_325, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_nonanimated_theta_325_comment},
  {"get_alpha_blend_method", &Dtool_SpriteParticleRenderer_get_alpha_blend_method_326, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_alpha_blend_method_326_comment},
  {"getAlphaBlendMethod", &Dtool_SpriteParticleRenderer_get_alpha_blend_method_326, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_alpha_blend_method_326_comment},
  {"get_alpha_disable", &Dtool_SpriteParticleRenderer_get_alpha_disable_327, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_alpha_disable_327_comment},
  {"getAlphaDisable", &Dtool_SpriteParticleRenderer_get_alpha_disable_327, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_alpha_disable_327_comment},
  {"get_animate_frames_enable", &Dtool_SpriteParticleRenderer_get_animate_frames_enable_328, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_animate_frames_enable_328_comment},
  {"getAnimateFramesEnable", &Dtool_SpriteParticleRenderer_get_animate_frames_enable_328, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_animate_frames_enable_328_comment},
  {"get_animate_frames_rate", &Dtool_SpriteParticleRenderer_get_animate_frames_rate_329, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_animate_frames_rate_329_comment},
  {"getAnimateFramesRate", &Dtool_SpriteParticleRenderer_get_animate_frames_rate_329, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_animate_frames_rate_329_comment},
  {"get_animate_frames_index", &Dtool_SpriteParticleRenderer_get_animate_frames_index_330, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_animate_frames_index_330_comment},
  {"getAnimateFramesIndex", &Dtool_SpriteParticleRenderer_get_animate_frames_index_330, METH_NOARGS, (const char *)Dtool_SpriteParticleRenderer_get_animate_frames_index_330_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_anims", (PyCFunction) &MakeSeq_SpriteParticleRenderer_get_anims, METH_NOARGS, NULL},
  { "getAnims", (PyCFunction) &MakeSeq_SpriteParticleRenderer_get_anims, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_SpriteParticleRenderer = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SpriteParticleRenderer = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_SpriteParticleRenderer = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_SpriteParticleRenderer = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_SpriteParticleRenderer = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.SpriteParticleRenderer",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SpriteParticleRenderer,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_SpriteParticleRenderer,
    &Dtool_SequenceMethods_SpriteParticleRenderer,
    &Dtool_MappingMethods_SpriteParticleRenderer,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_SpriteParticleRenderer,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Renders a particle system with high-speed nasty trick sprites.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SpriteParticleRenderer,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SpriteParticleRenderer,
    PyType_GenericAlloc,
    Dtool_new_SpriteParticleRenderer,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SpriteParticleRenderer,
  Dtool_UpcastInterface_SpriteParticleRenderer,
  Dtool_DowncastInterface_SpriteParticleRenderer,
  (CoerceFunction)Dtool_ConstCoerce_SpriteParticleRenderer,
  (CoerceFunction)Dtool_Coerce_SpriteParticleRenderer,
};

static void Dtool_PyModuleClassInit_SpriteParticleRenderer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseParticleRenderer(NULL);
    Dtool_SpriteParticleRenderer._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseParticleRenderer);
    PyObject *dict = PyDict_New();
    Dtool_SpriteParticleRenderer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SpriteParticleRenderer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SpriteParticleRenderer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SpriteParticleRenderer);
  }
}

/**
 * Python method tables for TangentRingEmitter (TangentRingEmitter)
 */
static PyMethodDef Dtool_Methods_TangentRingEmitter[] = {
  {"set_radius", &Dtool_TangentRingEmitter_set_radius_333, METH_O, (const char *)Dtool_TangentRingEmitter_set_radius_333_comment},
  {"setRadius", &Dtool_TangentRingEmitter_set_radius_333, METH_O, (const char *)Dtool_TangentRingEmitter_set_radius_333_comment},
  {"set_radius_spread", &Dtool_TangentRingEmitter_set_radius_spread_334, METH_O, (const char *)Dtool_TangentRingEmitter_set_radius_spread_334_comment},
  {"setRadiusSpread", &Dtool_TangentRingEmitter_set_radius_spread_334, METH_O, (const char *)Dtool_TangentRingEmitter_set_radius_spread_334_comment},
  {"get_radius", &Dtool_TangentRingEmitter_get_radius_335, METH_NOARGS, (const char *)Dtool_TangentRingEmitter_get_radius_335_comment},
  {"getRadius", &Dtool_TangentRingEmitter_get_radius_335, METH_NOARGS, (const char *)Dtool_TangentRingEmitter_get_radius_335_comment},
  {"get_radius_spread", &Dtool_TangentRingEmitter_get_radius_spread_336, METH_NOARGS, (const char *)Dtool_TangentRingEmitter_get_radius_spread_336_comment},
  {"getRadiusSpread", &Dtool_TangentRingEmitter_get_radius_spread_336, METH_NOARGS, (const char *)Dtool_TangentRingEmitter_get_radius_spread_336_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_TangentRingEmitter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TangentRingEmitter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_TangentRingEmitter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_TangentRingEmitter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_TangentRingEmitter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.TangentRingEmitter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TangentRingEmitter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TangentRingEmitter,
    &Dtool_SequenceMethods_TangentRingEmitter,
    &Dtool_MappingMethods_TangentRingEmitter,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_TangentRingEmitter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Describes a planar ring region in which tangent particles are generated,\n"
    " * and particles fly off tangential to the ring.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TangentRingEmitter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TangentRingEmitter,
    PyType_GenericAlloc,
    Dtool_new_TangentRingEmitter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TangentRingEmitter,
  Dtool_UpcastInterface_TangentRingEmitter,
  Dtool_DowncastInterface_TangentRingEmitter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_TangentRingEmitter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseParticleEmitter(NULL);
    Dtool_TangentRingEmitter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseParticleEmitter);
    PyObject *dict = PyDict_New();
    Dtool_TangentRingEmitter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TangentRingEmitter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TangentRingEmitter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TangentRingEmitter);
  }
}

/**
 * Python method tables for ZSpinParticleFactory (ZSpinParticleFactory)
 */
static PyMethodDef Dtool_Methods_ZSpinParticleFactory[] = {
  {"set_initial_angle", &Dtool_ZSpinParticleFactory_set_initial_angle_339, METH_O, (const char *)Dtool_ZSpinParticleFactory_set_initial_angle_339_comment},
  {"setInitialAngle", &Dtool_ZSpinParticleFactory_set_initial_angle_339, METH_O, (const char *)Dtool_ZSpinParticleFactory_set_initial_angle_339_comment},
  {"set_final_angle", &Dtool_ZSpinParticleFactory_set_final_angle_340, METH_O, (const char *)Dtool_ZSpinParticleFactory_set_final_angle_340_comment},
  {"setFinalAngle", &Dtool_ZSpinParticleFactory_set_final_angle_340, METH_O, (const char *)Dtool_ZSpinParticleFactory_set_final_angle_340_comment},
  {"set_initial_angle_spread", &Dtool_ZSpinParticleFactory_set_initial_angle_spread_341, METH_O, (const char *)Dtool_ZSpinParticleFactory_set_initial_angle_spread_341_comment},
  {"setInitialAngleSpread", &Dtool_ZSpinParticleFactory_set_initial_angle_spread_341, METH_O, (const char *)Dtool_ZSpinParticleFactory_set_initial_angle_spread_341_comment},
  {"set_final_angle_spread", &Dtool_ZSpinParticleFactory_set_final_angle_spread_342, METH_O, (const char *)Dtool_ZSpinParticleFactory_set_final_angle_spread_342_comment},
  {"setFinalAngleSpread", &Dtool_ZSpinParticleFactory_set_final_angle_spread_342, METH_O, (const char *)Dtool_ZSpinParticleFactory_set_final_angle_spread_342_comment},
  {"get_initial_angle", &Dtool_ZSpinParticleFactory_get_initial_angle_343, METH_NOARGS, (const char *)Dtool_ZSpinParticleFactory_get_initial_angle_343_comment},
  {"getInitialAngle", &Dtool_ZSpinParticleFactory_get_initial_angle_343, METH_NOARGS, (const char *)Dtool_ZSpinParticleFactory_get_initial_angle_343_comment},
  {"get_final_angle", &Dtool_ZSpinParticleFactory_get_final_angle_344, METH_NOARGS, (const char *)Dtool_ZSpinParticleFactory_get_final_angle_344_comment},
  {"getFinalAngle", &Dtool_ZSpinParticleFactory_get_final_angle_344, METH_NOARGS, (const char *)Dtool_ZSpinParticleFactory_get_final_angle_344_comment},
  {"get_initial_angle_spread", &Dtool_ZSpinParticleFactory_get_initial_angle_spread_345, METH_NOARGS, (const char *)Dtool_ZSpinParticleFactory_get_initial_angle_spread_345_comment},
  {"getInitialAngleSpread", &Dtool_ZSpinParticleFactory_get_initial_angle_spread_345, METH_NOARGS, (const char *)Dtool_ZSpinParticleFactory_get_initial_angle_spread_345_comment},
  {"get_final_angle_spread", &Dtool_ZSpinParticleFactory_get_final_angle_spread_346, METH_NOARGS, (const char *)Dtool_ZSpinParticleFactory_get_final_angle_spread_346_comment},
  {"getFinalAngleSpread", &Dtool_ZSpinParticleFactory_get_final_angle_spread_346, METH_NOARGS, (const char *)Dtool_ZSpinParticleFactory_get_final_angle_spread_346_comment},
  {"set_angular_velocity", &Dtool_ZSpinParticleFactory_set_angular_velocity_347, METH_O, (const char *)Dtool_ZSpinParticleFactory_set_angular_velocity_347_comment},
  {"setAngularVelocity", &Dtool_ZSpinParticleFactory_set_angular_velocity_347, METH_O, (const char *)Dtool_ZSpinParticleFactory_set_angular_velocity_347_comment},
  {"get_angular_velocity", &Dtool_ZSpinParticleFactory_get_angular_velocity_348, METH_NOARGS, (const char *)Dtool_ZSpinParticleFactory_get_angular_velocity_348_comment},
  {"getAngularVelocity", &Dtool_ZSpinParticleFactory_get_angular_velocity_348, METH_NOARGS, (const char *)Dtool_ZSpinParticleFactory_get_angular_velocity_348_comment},
  {"set_angular_velocity_spread", &Dtool_ZSpinParticleFactory_set_angular_velocity_spread_349, METH_O, (const char *)Dtool_ZSpinParticleFactory_set_angular_velocity_spread_349_comment},
  {"setAngularVelocitySpread", &Dtool_ZSpinParticleFactory_set_angular_velocity_spread_349, METH_O, (const char *)Dtool_ZSpinParticleFactory_set_angular_velocity_spread_349_comment},
  {"get_angular_velocity_spread", &Dtool_ZSpinParticleFactory_get_angular_velocity_spread_350, METH_NOARGS, (const char *)Dtool_ZSpinParticleFactory_get_angular_velocity_spread_350_comment},
  {"getAngularVelocitySpread", &Dtool_ZSpinParticleFactory_get_angular_velocity_spread_350, METH_NOARGS, (const char *)Dtool_ZSpinParticleFactory_get_angular_velocity_spread_350_comment},
  {"enable_angular_velocity", &Dtool_ZSpinParticleFactory_enable_angular_velocity_351, METH_O, (const char *)Dtool_ZSpinParticleFactory_enable_angular_velocity_351_comment},
  {"enableAngularVelocity", &Dtool_ZSpinParticleFactory_enable_angular_velocity_351, METH_O, (const char *)Dtool_ZSpinParticleFactory_enable_angular_velocity_351_comment},
  {"get_angular_velocity_enabled", &Dtool_ZSpinParticleFactory_get_angular_velocity_enabled_352, METH_NOARGS, (const char *)Dtool_ZSpinParticleFactory_get_angular_velocity_enabled_352_comment},
  {"getAngularVelocityEnabled", &Dtool_ZSpinParticleFactory_get_angular_velocity_enabled_352, METH_NOARGS, (const char *)Dtool_ZSpinParticleFactory_get_angular_velocity_enabled_352_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ZSpinParticleFactory = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ZSpinParticleFactory = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ZSpinParticleFactory = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ZSpinParticleFactory = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ZSpinParticleFactory = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.ZSpinParticleFactory",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ZSpinParticleFactory,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ZSpinParticleFactory,
    &Dtool_SequenceMethods_ZSpinParticleFactory,
    &Dtool_MappingMethods_ZSpinParticleFactory,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ZSpinParticleFactory,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ZSpinParticleFactory,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ZSpinParticleFactory,
    PyType_GenericAlloc,
    Dtool_new_ZSpinParticleFactory,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ZSpinParticleFactory,
  Dtool_UpcastInterface_ZSpinParticleFactory,
  Dtool_DowncastInterface_ZSpinParticleFactory,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ZSpinParticleFactory(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseParticleFactory(NULL);
    Dtool_ZSpinParticleFactory._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseParticleFactory);
    PyObject *dict = PyDict_New();
    Dtool_ZSpinParticleFactory._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ZSpinParticleFactory) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ZSpinParticleFactory)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ZSpinParticleFactory);
  }
}

/**
 * Python method tables for ParticleSystemManager (ParticleSystemManager)
 */
static PyMethodDef Dtool_Methods_ParticleSystemManager[] = {
  {"set_frame_stepping", &Dtool_ParticleSystemManager_set_frame_stepping_356, METH_O, (const char *)Dtool_ParticleSystemManager_set_frame_stepping_356_comment},
  {"setFrameStepping", &Dtool_ParticleSystemManager_set_frame_stepping_356, METH_O, (const char *)Dtool_ParticleSystemManager_set_frame_stepping_356_comment},
  {"get_frame_stepping", &Dtool_ParticleSystemManager_get_frame_stepping_357, METH_NOARGS, (const char *)Dtool_ParticleSystemManager_get_frame_stepping_357_comment},
  {"getFrameStepping", &Dtool_ParticleSystemManager_get_frame_stepping_357, METH_NOARGS, (const char *)Dtool_ParticleSystemManager_get_frame_stepping_357_comment},
  {"attach_particlesystem", &Dtool_ParticleSystemManager_attach_particlesystem_358, METH_O, (const char *)Dtool_ParticleSystemManager_attach_particlesystem_358_comment},
  {"attachParticlesystem", &Dtool_ParticleSystemManager_attach_particlesystem_358, METH_O, (const char *)Dtool_ParticleSystemManager_attach_particlesystem_358_comment},
  {"remove_particlesystem", &Dtool_ParticleSystemManager_remove_particlesystem_359, METH_O, (const char *)Dtool_ParticleSystemManager_remove_particlesystem_359_comment},
  {"removeParticlesystem", &Dtool_ParticleSystemManager_remove_particlesystem_359, METH_O, (const char *)Dtool_ParticleSystemManager_remove_particlesystem_359_comment},
  {"clear", &Dtool_ParticleSystemManager_clear_360, METH_NOARGS, (const char *)Dtool_ParticleSystemManager_clear_360_comment},
  {"do_particles", (PyCFunction) &Dtool_ParticleSystemManager_do_particles_361, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParticleSystemManager_do_particles_361_comment},
  {"doParticles", (PyCFunction) &Dtool_ParticleSystemManager_do_particles_361, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParticleSystemManager_do_particles_361_comment},
  {"output", &Dtool_ParticleSystemManager_output_362, METH_O, (const char *)Dtool_ParticleSystemManager_output_362_comment},
  {"write_ps_list", (PyCFunction) &Dtool_ParticleSystemManager_write_ps_list_363, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParticleSystemManager_write_ps_list_363_comment},
  {"writePsList", (PyCFunction) &Dtool_ParticleSystemManager_write_ps_list_363, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParticleSystemManager_write_ps_list_363_comment},
  {"write", (PyCFunction) &Dtool_ParticleSystemManager_write_364, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParticleSystemManager_write_364_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     ParticleSystemManager
//////////////////
static PyObject *Dtool_Repr_ParticleSystemManager(PyObject *self) {
  ParticleSystemManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystemManager, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ParticleSystemManager
//////////////////
static PyObject *Dtool_Str_ParticleSystemManager(PyObject *self) {
  ParticleSystemManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParticleSystemManager, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ParticleSystemManager = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_ParticleSystemManager = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.ParticleSystemManager",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ParticleSystemManager,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_ParticleSystemManager,
    &Dtool_NumberMethods_ParticleSystemManager,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_ParticleSystemManager,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Manages a set of individual ParticleSystem objects, so that each individual\n"
    " * one doesn't have to be updated and rendered every frame See Also :\n"
    " * particleSystemManager.cxx\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ParticleSystemManager,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ParticleSystemManager,
    PyType_GenericAlloc,
    Dtool_new_ParticleSystemManager,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParticleSystemManager,
  Dtool_UpcastInterface_ParticleSystemManager,
  Dtool_DowncastInterface_ParticleSystemManager,
  (CoerceFunction)Dtool_ConstCoerce_ParticleSystemManager,
  (CoerceFunction)Dtool_Coerce_ParticleSystemManager,
};

static void Dtool_PyModuleClassInit_ParticleSystemManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ParticleSystemManager._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_ParticleSystemManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParticleSystemManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParticleSystemManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParticleSystemManager);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3particlesystem_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("BaseParticleEmitter", Dtool_BaseParticleEmitter);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("RingEmitter", Dtool_RingEmitter);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ArcEmitter", Dtool_ArcEmitter);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("BaseParticleFactory", Dtool_BaseParticleFactory);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("BaseParticleRenderer", Dtool_BaseParticleRenderer);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("BoxEmitter", Dtool_BoxEmitter);
#endif
  Dtool_ColorInterpolationFunctionConstant._type = ColorInterpolationFunctionConstant::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ColorInterpolationFunctionConstant);
  Dtool_ColorInterpolationFunctionLinear._type = ColorInterpolationFunctionLinear::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ColorInterpolationFunctionLinear);
  Dtool_ColorInterpolationFunctionStepwave._type = ColorInterpolationFunctionStepwave::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ColorInterpolationFunctionStepwave);
  Dtool_ColorInterpolationFunctionSinusoid._type = ColorInterpolationFunctionSinusoid::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ColorInterpolationFunctionSinusoid);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ColorInterpolationSegment", Dtool_ColorInterpolationSegment);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ColorInterpolationManager", Dtool_ColorInterpolationManager);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DiscEmitter", Dtool_DiscEmitter);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("GeomParticleRenderer", Dtool_GeomParticleRenderer);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LineEmitter", Dtool_LineEmitter);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LineParticleRenderer", Dtool_LineParticleRenderer);
#endif
  Dtool_ParticleSystem._type = ParticleSystem::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ParticleSystem);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointEmitter", Dtool_PointEmitter);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointParticleFactory", Dtool_PointParticleFactory);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointParticleRenderer", Dtool_PointParticleRenderer);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("RectangleEmitter", Dtool_RectangleEmitter);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("SparkleParticleRenderer", Dtool_SparkleParticleRenderer);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("SphereSurfaceEmitter", Dtool_SphereSurfaceEmitter);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("SphereVolumeEmitter", Dtool_SphereVolumeEmitter);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("SpriteAnim", Dtool_SpriteAnim);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("SpriteParticleRenderer", Dtool_SpriteParticleRenderer);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("TangentRingEmitter", Dtool_TangentRingEmitter);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ZSpinParticleFactory", Dtool_ZSpinParticleFactory);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ParticleSystemManager", Dtool_ParticleSystemManager);
#endif
}

void Dtool_libp3particlesystem_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_LPoint2f = LookupRuntimeTypedClass(LPoint2f::get_class_type());
  Dtool_Ptr_LPoint3f = LookupRuntimeTypedClass(LPoint3f::get_class_type());
  Dtool_Ptr_LVecBase4f = LookupRuntimeTypedClass(LVecBase4f::get_class_type());
  Dtool_Ptr_LVector3f = LookupRuntimeTypedClass(LVector3f::get_class_type());
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_PandaNode = LookupRuntimeTypedClass(PandaNode::get_class_type());
  Dtool_Ptr_GeomNode = LookupRuntimeTypedClass(GeomNode::get_class_type());
  Dtool_Ptr_Texture = LookupRuntimeTypedClass(Texture::get_class_type());
  Dtool_Ptr_NodePath = LookupRuntimeTypedClass(NodePath::get_class_type());
  Dtool_Ptr_Physical = LookupRuntimeTypedClass(Physical::get_class_type());
#endif
}

void Dtool_libp3particlesystem_BuildInstants(PyObject *module) {
  (void) module;
  // BaseParticleEmitter
  Dtool_PyModuleClassInit_BaseParticleEmitter(module);
  PyModule_AddObject(module, "BaseParticleEmitter", (PyObject *)&Dtool_BaseParticleEmitter);
  // RingEmitter
  Dtool_PyModuleClassInit_RingEmitter(module);
  PyModule_AddObject(module, "RingEmitter", (PyObject *)&Dtool_RingEmitter);
  // ArcEmitter
  Dtool_PyModuleClassInit_ArcEmitter(module);
  PyModule_AddObject(module, "ArcEmitter", (PyObject *)&Dtool_ArcEmitter);
  // BaseParticleFactory
  Dtool_PyModuleClassInit_BaseParticleFactory(module);
  PyModule_AddObject(module, "BaseParticleFactory", (PyObject *)&Dtool_BaseParticleFactory);
  // BaseParticleRenderer
  Dtool_PyModuleClassInit_BaseParticleRenderer(module);
  PyModule_AddObject(module, "BaseParticleRenderer", (PyObject *)&Dtool_BaseParticleRenderer);
  // BoxEmitter
  Dtool_PyModuleClassInit_BoxEmitter(module);
  PyModule_AddObject(module, "BoxEmitter", (PyObject *)&Dtool_BoxEmitter);
  // ColorInterpolationFunctionConstant
  Dtool_PyModuleClassInit_ColorInterpolationFunctionConstant(module);
  PyModule_AddObject(module, "ColorInterpolationFunctionConstant", (PyObject *)&Dtool_ColorInterpolationFunctionConstant);
  // ColorInterpolationFunctionLinear
  Dtool_PyModuleClassInit_ColorInterpolationFunctionLinear(module);
  PyModule_AddObject(module, "ColorInterpolationFunctionLinear", (PyObject *)&Dtool_ColorInterpolationFunctionLinear);
  // ColorInterpolationFunctionStepwave
  Dtool_PyModuleClassInit_ColorInterpolationFunctionStepwave(module);
  PyModule_AddObject(module, "ColorInterpolationFunctionStepwave", (PyObject *)&Dtool_ColorInterpolationFunctionStepwave);
  // ColorInterpolationFunctionSinusoid
  Dtool_PyModuleClassInit_ColorInterpolationFunctionSinusoid(module);
  PyModule_AddObject(module, "ColorInterpolationFunctionSinusoid", (PyObject *)&Dtool_ColorInterpolationFunctionSinusoid);
  // ColorInterpolationSegment
  Dtool_PyModuleClassInit_ColorInterpolationSegment(module);
  PyModule_AddObject(module, "ColorInterpolationSegment", (PyObject *)&Dtool_ColorInterpolationSegment);
  // ColorInterpolationManager
  Dtool_PyModuleClassInit_ColorInterpolationManager(module);
  PyModule_AddObject(module, "ColorInterpolationManager", (PyObject *)&Dtool_ColorInterpolationManager);
  // DiscEmitter
  Dtool_PyModuleClassInit_DiscEmitter(module);
  PyModule_AddObject(module, "DiscEmitter", (PyObject *)&Dtool_DiscEmitter);
  // GeomParticleRenderer
  Dtool_PyModuleClassInit_GeomParticleRenderer(module);
  PyModule_AddObject(module, "GeomParticleRenderer", (PyObject *)&Dtool_GeomParticleRenderer);
  // LineEmitter
  Dtool_PyModuleClassInit_LineEmitter(module);
  PyModule_AddObject(module, "LineEmitter", (PyObject *)&Dtool_LineEmitter);
  // LineParticleRenderer
  Dtool_PyModuleClassInit_LineParticleRenderer(module);
  PyModule_AddObject(module, "LineParticleRenderer", (PyObject *)&Dtool_LineParticleRenderer);
  // ParticleSystem
  Dtool_PyModuleClassInit_ParticleSystem(module);
  PyModule_AddObject(module, "ParticleSystem", (PyObject *)&Dtool_ParticleSystem);
  // PointEmitter
  Dtool_PyModuleClassInit_PointEmitter(module);
  PyModule_AddObject(module, "PointEmitter", (PyObject *)&Dtool_PointEmitter);
  // PointParticleFactory
  Dtool_PyModuleClassInit_PointParticleFactory(module);
  PyModule_AddObject(module, "PointParticleFactory", (PyObject *)&Dtool_PointParticleFactory);
  // PointParticleRenderer
  Dtool_PyModuleClassInit_PointParticleRenderer(module);
  PyModule_AddObject(module, "PointParticleRenderer", (PyObject *)&Dtool_PointParticleRenderer);
  // RectangleEmitter
  Dtool_PyModuleClassInit_RectangleEmitter(module);
  PyModule_AddObject(module, "RectangleEmitter", (PyObject *)&Dtool_RectangleEmitter);
  // SparkleParticleRenderer
  Dtool_PyModuleClassInit_SparkleParticleRenderer(module);
  PyModule_AddObject(module, "SparkleParticleRenderer", (PyObject *)&Dtool_SparkleParticleRenderer);
  // SphereSurfaceEmitter
  Dtool_PyModuleClassInit_SphereSurfaceEmitter(module);
  PyModule_AddObject(module, "SphereSurfaceEmitter", (PyObject *)&Dtool_SphereSurfaceEmitter);
  // SphereVolumeEmitter
  Dtool_PyModuleClassInit_SphereVolumeEmitter(module);
  PyModule_AddObject(module, "SphereVolumeEmitter", (PyObject *)&Dtool_SphereVolumeEmitter);
  // SpriteAnim
  Dtool_PyModuleClassInit_SpriteAnim(module);
  PyModule_AddObject(module, "SpriteAnim", (PyObject *)&Dtool_SpriteAnim);
  // SpriteParticleRenderer
  Dtool_PyModuleClassInit_SpriteParticleRenderer(module);
  PyModule_AddObject(module, "SpriteParticleRenderer", (PyObject *)&Dtool_SpriteParticleRenderer);
  // TangentRingEmitter
  Dtool_PyModuleClassInit_TangentRingEmitter(module);
  PyModule_AddObject(module, "TangentRingEmitter", (PyObject *)&Dtool_TangentRingEmitter);
  // ZSpinParticleFactory
  Dtool_PyModuleClassInit_ZSpinParticleFactory(module);
  PyModule_AddObject(module, "ZSpinParticleFactory", (PyObject *)&Dtool_ZSpinParticleFactory);
  // ParticleSystemManager
  Dtool_PyModuleClassInit_ParticleSystemManager(module);
  PyModule_AddObject(module, "ParticleSystemManager", (PyObject *)&Dtool_ParticleSystemManager);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3particlesystem_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478214364,  /* file_identifier */
  "libp3particlesystem",  /* library_name */
  "BxOc",  /* library_hash_name */
  "panda3d.physics",  /* module_name */
  "libp3particlesystem.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  862  /* next_index */
};

Configure(_in_configure_libp3particlesystem);
ConfigureFn(_in_configure_libp3particlesystem) {
  interrogate_request_module(&_in_module_def);
}

