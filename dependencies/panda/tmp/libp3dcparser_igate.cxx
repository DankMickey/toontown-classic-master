/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir direct/src/dcparser -Idirect/src/dcparser -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3dcparser_igate.cxx -od built/pandac/input/libp3dcparser.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Idirect/src/dcparser -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -DWITHIN_PANDA=1 -module panda3d.direct -library libp3dcparser dcArrayParameter.h dcAtomicField.h dcClass.h dcClassParameter.h dcDeclaration.h dcField.h dcFile.h dcKeyword.h dcKeywordList.h dcLexerDefs.h dcMolecularField.h dcNumericRange.h dcPackData.h dcPacker.h dcPackerCatalog.h dcPackerInterface.h dcParameter.h dcParserDefs.h dcPython.h dcSimpleParameter.h dcSubatomicType.h dcSwitch.h dcSwitchParameter.h dcTypedef.h dcbase.h dcindent.h hashGenerator.h p3dcparser_composite1.cxx p3dcparser_composite2.cxx primeNumberGenerator.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3dcparser
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "configVariableBool.h"
#include "dcArrayParameter.h"
#include "dcAtomicField.h"
#include "dcClass.h"
#include "dcClassParameter.h"
#include "dcDeclaration.h"
#include "dcField.h"
#include "dcFile.h"
#include "dcKeyword.h"
#include "dcKeywordList.h"
#include "dcLexerDefs.h"
#include "dcMolecularField.h"
#include "dcNumericRange.h"
#include "dcPackData.h"
#include "dcPacker.h"
#include "dcPackerCatalog.h"
#include "dcPackerInterface.h"
#include "dcParameter.h"
#include "dcParserDefs.h"
#include "dcPython.h"
#include "dcSimpleParameter.h"
#include "dcSubatomicType.h"
#include "dcSwitch.h"
#include "dcSwitchParameter.h"
#include "dcTypedef.h"
#include "dcbase.h"
#include "dcindent.h"
#include "hashGenerator.h"
#include "indent.h"
#include <math.h>
#include "pStatCollector.h"
#include "primeNumberGenerator.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class DCPackerInterface
 */
typedef DCPackerInterface DCPackerInterface_localtype;
Define_Module_Class(panda3d.direct, DCPackerInterface, DCPackerInterface_localtype, DCPackerInterface);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCPackerInterface = &Dtool_DCPackerInterface;
static void Dtool_PyModuleClassInit_DCPackerInterface(PyObject *module);

/**
 * Forward declarations for top-level class DCKeywordList
 */
typedef DCKeywordList DCKeywordList_localtype;
Define_Module_Class(panda3d.direct, DCKeywordList, DCKeywordList_localtype, DCKeywordList);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCKeywordList = &Dtool_DCKeywordList;
static void Dtool_PyModuleClassInit_DCKeywordList(PyObject *module);

/**
 * Forward declarations for top-level class DCField
 */
typedef DCField DCField_localtype;
Define_Module_Class(panda3d.direct, DCField, DCField_localtype, DCField);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCField = &Dtool_DCField;
static void Dtool_PyModuleClassInit_DCField(PyObject *module);

/**
 * Forward declarations for top-level class DCPackData
 */
typedef DCPackData DCPackData_localtype;
Define_Module_Class(panda3d.direct, DCPackData, DCPackData_localtype, DCPackData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCPackData = &Dtool_DCPackData;
static void Dtool_PyModuleClassInit_DCPackData(PyObject *module);

/**
 * Forward declarations for top-level class DCPacker
 */
typedef DCPacker DCPacker_localtype;
Define_Module_Class(panda3d.direct, DCPacker, DCPacker_localtype, DCPacker);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCPacker = &Dtool_DCPacker;
static void Dtool_PyModuleClassInit_DCPacker(PyObject *module);

/**
 * Forward declarations for top-level class DCParameter
 */
typedef DCParameter DCParameter_localtype;
Define_Module_Class(panda3d.direct, DCParameter, DCParameter_localtype, DCParameter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCParameter = &Dtool_DCParameter;
static void Dtool_PyModuleClassInit_DCParameter(PyObject *module);

/**
 * Forward declarations for top-level class DCArrayParameter
 */
typedef DCArrayParameter DCArrayParameter_localtype;
Define_Module_Class(panda3d.direct, DCArrayParameter, DCArrayParameter_localtype, DCArrayParameter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCArrayParameter = &Dtool_DCArrayParameter;
static void Dtool_PyModuleClassInit_DCArrayParameter(PyObject *module);

/**
 * Forward declarations for top-level class DCAtomicField
 */
typedef DCAtomicField DCAtomicField_localtype;
Define_Module_Class(panda3d.direct, DCAtomicField, DCAtomicField_localtype, DCAtomicField);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCAtomicField = &Dtool_DCAtomicField;
static void Dtool_PyModuleClassInit_DCAtomicField(PyObject *module);

/**
 * Forward declarations for top-level class DCDeclaration
 */
typedef DCDeclaration DCDeclaration_localtype;
Define_Module_Class(panda3d.direct, DCDeclaration, DCDeclaration_localtype, DCDeclaration);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCDeclaration = &Dtool_DCDeclaration;
static void Dtool_PyModuleClassInit_DCDeclaration(PyObject *module);

/**
 * Forward declarations for top-level class DCClass
 */
typedef DCClass DCClass_localtype;
Define_Module_Class(panda3d.direct, DCClass, DCClass_localtype, DCClass);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCClass = &Dtool_DCClass;
static void Dtool_PyModuleClassInit_DCClass(PyObject *module);

/**
 * Forward declarations for top-level class DCClassParameter
 */
typedef DCClassParameter DCClassParameter_localtype;
Define_Module_Class(panda3d.direct, DCClassParameter, DCClassParameter_localtype, DCClassParameter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCClassParameter = &Dtool_DCClassParameter;
static void Dtool_PyModuleClassInit_DCClassParameter(PyObject *module);

/**
 * Forward declarations for top-level class DCFile
 */
typedef DCFile DCFile_localtype;
Define_Module_Class(panda3d.direct, DCFile, DCFile_localtype, DCFile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCFile = &Dtool_DCFile;
static void Dtool_PyModuleClassInit_DCFile(PyObject *module);

/**
 * Forward declarations for top-level class DCKeyword
 */
typedef DCKeyword DCKeyword_localtype;
Define_Module_Class(panda3d.direct, DCKeyword, DCKeyword_localtype, DCKeyword);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCKeyword = &Dtool_DCKeyword;
static void Dtool_PyModuleClassInit_DCKeyword(PyObject *module);

/**
 * Forward declarations for top-level class DCMolecularField
 */
typedef DCMolecularField DCMolecularField_localtype;
Define_Module_Class(panda3d.direct, DCMolecularField, DCMolecularField_localtype, DCMolecularField);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCMolecularField = &Dtool_DCMolecularField;
static void Dtool_PyModuleClassInit_DCMolecularField(PyObject *module);

/**
 * Forward declarations for top-level class DCSimpleParameter
 */
typedef DCSimpleParameter DCSimpleParameter_localtype;
Define_Module_Class(panda3d.direct, DCSimpleParameter, DCSimpleParameter_localtype, DCSimpleParameter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCSimpleParameter = &Dtool_DCSimpleParameter;
static void Dtool_PyModuleClassInit_DCSimpleParameter(PyObject *module);

/**
 * Forward declarations for top-level class DCSwitch
 */
typedef DCSwitch DCSwitch_localtype;
Define_Module_Class(panda3d.direct, DCSwitch, DCSwitch_localtype, DCSwitch);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCSwitch = &Dtool_DCSwitch;
static void Dtool_PyModuleClassInit_DCSwitch(PyObject *module);

/**
 * Forward declarations for top-level class DCSwitchParameter
 */
typedef DCSwitchParameter DCSwitchParameter_localtype;
Define_Module_Class(panda3d.direct, DCSwitchParameter, DCSwitchParameter_localtype, DCSwitchParameter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCSwitchParameter = &Dtool_DCSwitchParameter;
static void Dtool_PyModuleClassInit_DCSwitchParameter(PyObject *module);

/**
 * Forward declarations for top-level class DCTypedef
 */
typedef DCTypedef DCTypedef_localtype;
Define_Module_Class(panda3d.direct, DCTypedef, DCTypedef_localtype, DCTypedef);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCTypedef = &Dtool_DCTypedef;
static void Dtool_PyModuleClassInit_DCTypedef(PyObject *module);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// istream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_istream;
#else
extern struct Dtool_PyTypedObject Dtool_istream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_istream = &Dtool_istream;
#endif
// Filename
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Filename;
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != NULL, NULL);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != NULL, NULL);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// Datagram
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Datagram;
inline static bool Dtool_ConstCoerce_Datagram(PyObject *args, Datagram const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Datagram != NULL, false);
  nassertr(Dtool_Ptr_Datagram->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, Datagram const *&, bool&))Dtool_Ptr_Datagram->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_Datagram(PyObject *args, Datagram *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Datagram != NULL, false);
  nassertr(Dtool_Ptr_Datagram->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, Datagram *&, bool&))Dtool_Ptr_Datagram->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_Datagram;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Datagram = &Dtool_Datagram;
extern bool Dtool_ConstCoerce_Datagram(PyObject *args, Datagram const *&coerced, bool &manage);
extern bool Dtool_Coerce_Datagram(PyObject *args, Datagram *&coerced, bool &manage);
#endif
// DatagramIterator
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_DatagramIterator;
inline static DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced) {
  nassertr(Dtool_Ptr_DatagramIterator != NULL, NULL);
  nassertr(Dtool_Ptr_DatagramIterator->_Dtool_Coerce != NULL, NULL);
  return ((DatagramIterator *(*)(PyObject *, DatagramIterator &))Dtool_Ptr_DatagramIterator->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_DatagramIterator;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramIterator = &Dtool_DatagramIterator;
extern DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class DCPackerInterface
 */
/**
 * Python function wrapper for:
 * inline std::string const &DCPackerInterface::get_name(void) const
 */
static PyObject *Dtool_DCPackerInterface_get_name_5(PyObject *self, PyObject *) {
  DCPackerInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPackerInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &DCPackerInterface::get_name(void) const
  std::string const &return_value = (*(const DCPackerInterface*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPackerInterface_get_name_5_comment =
  "C++ Interface:\n"
  "get_name(DCPackerInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the name of this field, or empty string if the field is unnamed.\n"
  " */";
#else
static const char *Dtool_DCPackerInterface_get_name_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DCPackerInterface::find_seek_index(std::string const &name) const
 */
static PyObject *Dtool_DCPackerInterface_find_seek_index_6(PyObject *self, PyObject *arg) {
  DCPackerInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPackerInterface, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DCPackerInterface::find_seek_index(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    int return_value = (*(const DCPackerInterface*)local_this).find_seek_index(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_seek_index(DCPackerInterface self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPackerInterface_find_seek_index_6_comment =
  "C++ Interface:\n"
  "find_seek_index(DCPackerInterface self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the index number to be passed to a future call to DCPacker::seek()\n"
  " * to seek directly to the named field without having to look up the field\n"
  " * name in a table later, or -1 if the named field cannot be found.\n"
  " *\n"
  " * If the named field is nested within a switch or some similar dynamic\n"
  " * structure that reveals different fields based on the contents of the data,\n"
  " * this mechanism cannot be used to pre-fetch the field index number--you must\n"
  " * seek for the field by name.\n"
  " */";
#else
static const char *Dtool_DCPackerInterface_find_seek_index_6_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual DCField *DCPackerInterface::as_field(void)
 * virtual DCField const *DCPackerInterface::as_field(void) const
 */
static PyObject *Dtool_DCPackerInterface_as_field_7(PyObject *self, PyObject *) {
  DCPackerInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPackerInterface, (void **)&local_this)) {
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 virtual DCField *DCPackerInterface::as_field(void)
    DCField *return_value = (*local_this).as_field();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
  }

  {
    // -2 virtual DCField const *DCPackerInterface::as_field(void) const
    DCField const *return_value = (*(const DCPackerInterface*)local_this).as_field();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, true);
  }

  // No coercion possible: virtual DCField *DCPackerInterface::as_field(void)
  // No coercion possible: virtual DCField const *DCPackerInterface::as_field(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCPackerInterface_as_field_7_comment =
  "C++ Interface:\n"
  "as_field(const DCPackerInterface self)\n"
  "as_field(DCPackerInterface self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DCPackerInterface_as_field_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual DCSwitchParameter *DCPackerInterface::as_switch_parameter(void)
 * virtual DCSwitchParameter const *DCPackerInterface::as_switch_parameter(void) const
 */
static PyObject *Dtool_DCPackerInterface_as_switch_parameter_8(PyObject *self, PyObject *) {
  DCPackerInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPackerInterface, (void **)&local_this)) {
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 virtual DCSwitchParameter *DCPackerInterface::as_switch_parameter(void)
    DCSwitchParameter *return_value = (*local_this).as_switch_parameter();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCSwitchParameter, false, false);
  }

  {
    // -2 virtual DCSwitchParameter const *DCPackerInterface::as_switch_parameter(void) const
    DCSwitchParameter const *return_value = (*(const DCPackerInterface*)local_this).as_switch_parameter();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCSwitchParameter, false, true);
  }

  // No coercion possible: virtual DCSwitchParameter *DCPackerInterface::as_switch_parameter(void)
  // No coercion possible: virtual DCSwitchParameter const *DCPackerInterface::as_switch_parameter(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCPackerInterface_as_switch_parameter_8_comment =
  "C++ Interface:\n"
  "as_switch_parameter(const DCPackerInterface self)\n"
  "as_switch_parameter(DCPackerInterface self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DCPackerInterface_as_switch_parameter_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual DCClassParameter *DCPackerInterface::as_class_parameter(void)
 * virtual DCClassParameter const *DCPackerInterface::as_class_parameter(void) const
 */
static PyObject *Dtool_DCPackerInterface_as_class_parameter_9(PyObject *self, PyObject *) {
  DCPackerInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPackerInterface, (void **)&local_this)) {
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 virtual DCClassParameter *DCPackerInterface::as_class_parameter(void)
    DCClassParameter *return_value = (*local_this).as_class_parameter();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCClassParameter, false, false);
  }

  {
    // -2 virtual DCClassParameter const *DCPackerInterface::as_class_parameter(void) const
    DCClassParameter const *return_value = (*(const DCPackerInterface*)local_this).as_class_parameter();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCClassParameter, false, true);
  }

  // No coercion possible: virtual DCClassParameter *DCPackerInterface::as_class_parameter(void)
  // No coercion possible: virtual DCClassParameter const *DCPackerInterface::as_class_parameter(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCPackerInterface_as_class_parameter_9_comment =
  "C++ Interface:\n"
  "as_class_parameter(const DCPackerInterface self)\n"
  "as_class_parameter(DCPackerInterface self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DCPackerInterface_as_class_parameter_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCPackerInterface::check_match(DCPackerInterface const *other) const
 * bool DCPackerInterface::check_match(std::string const &description, DCFile *dcfile = 0) const
 */
static PyObject *Dtool_DCPackerInterface_check_match_10(PyObject *self, PyObject *args, PyObject *kwds) {
  DCPackerInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPackerInterface, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 bool DCPackerInterface::check_match(std::string const &description, DCFile *dcfile = 0) const
    char *param1_str = NULL;
    Py_ssize_t param1_len;
    PyObject *param2 = NULL;
    static const char *keyword_list[] = {"description", "dcfile", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|O:check_match", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
      DCFile *param2_this = 0;
      if (param2 != (PyObject *)NULL) {
        param2_this = (DCFile *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_DCFile, 2, "DCPackerInterface.check_match", false, false);
      }
      if ((param2 == NULL || param2_this != NULL)) {
        bool return_value = (*(const DCPackerInterface*)local_this).check_match(std::string(param1_str, param1_len), param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool DCPackerInterface::check_match(DCPackerInterface const *other) const
    PyObject *param1;
    static const char *keyword_list[] = {"other", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:check_match", (char **)keyword_list, &param1)) {
      DCPackerInterface const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_DCPackerInterface, (void **)&param1_this);
      if (param1_this != NULL) {
        bool return_value = (*(const DCPackerInterface*)local_this).check_match(param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool DCPackerInterface::check_match(std::string const &description, DCFile *dcfile = 0) const
  // No coercion possible: inline bool DCPackerInterface::check_match(DCPackerInterface const *other) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "check_match(DCPackerInterface self, str description, DCFile dcfile)\n"
      "check_match(DCPackerInterface self, const DCPackerInterface other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPackerInterface_check_match_10_comment =
  "C++ Interface:\n"
  "check_match(DCPackerInterface self, str description, DCFile dcfile)\n"
  "check_match(DCPackerInterface self, const DCPackerInterface other)\n"
  "\n"
  "/**\n"
  " * Returns true if the other interface is bitwise the same as this one--that\n"
  " * is, a uint32 only matches a uint32, etc.  Names of components, and range\n"
  " * limits, are not compared.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if this interface is bitwise the same as the interface\n"
  " * described with the indicated formatted string, e.g.  \"(uint8, uint8,\n"
  " * int16)\", or false otherwise.\n"
  " *\n"
  " * If DCFile is not NULL, it specifies the DCFile that was previously loaded,\n"
  " * from which some predefined structs and typedefs may be referenced in the\n"
  " * description string.\n"
  " */";
#else
static const char *Dtool_DCPackerInterface_check_match_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCField *DCPackerInterface::downcast_to_DCField(void)
 */
static PyObject *Dtool_DCPackerInterface_downcast_to_DCField_20(PyObject *self, PyObject *) {
  DCPackerInterface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPackerInterface, (void **)&local_this, "DCPackerInterface.downcast_to_DCField")) {
    return NULL;
  }
  // 1-DCField *DCPackerInterface::downcast_to_DCField(void)
  DCField *return_value = (DCField *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCPackerInterface_downcast_to_DCField_20_comment =
  "C++ Interface:\n"
  "downcast_to_DCField(const DCPackerInterface self)\n"
  "\n"
  "downcast from DCPackerInterface to DCField";
#else
static const char *Dtool_DCPackerInterface_downcast_to_DCField_20_comment = NULL;
#endif

static int Dtool_Init_DCPackerInterface(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCPackerInterface(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DCPackerInterface) {
    printf("DCPackerInterface ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DCPackerInterface *local_this = (DCPackerInterface *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DCPackerInterface) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DCPackerInterface(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DCPackerInterface) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DCKeywordList
 */
/**
 * Python function wrapper for:
 * bool DCKeywordList::has_keyword(DCKeyword const *keyword) const
 * bool DCKeywordList::has_keyword(std::string const &name) const
 */
static PyObject *Dtool_DCKeywordList_has_keyword_13(PyObject *self, PyObject *arg) {
  DCKeywordList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCKeywordList, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 bool DCKeywordList::has_keyword(DCKeyword const *keyword) const
    DCKeyword const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_DCKeyword, (void **)&arg_this);
    if (arg_this != NULL) {
      bool return_value = (*(const DCKeywordList*)local_this).has_keyword(arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool DCKeywordList::has_keyword(std::string const &name) const
    char *param1_str = NULL;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      bool return_value = (*(const DCKeywordList*)local_this).has_keyword(std::string(param1_str, param1_len));
      return Dtool_Return_Bool(return_value);
    }
    PyErr_Clear();
  }

  // No coercion possible: bool DCKeywordList::has_keyword(DCKeyword const *keyword) const
  // No coercion possible: bool DCKeywordList::has_keyword(std::string const &name) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_keyword(DCKeywordList self, const DCKeyword keyword)\n"
      "has_keyword(DCKeywordList self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCKeywordList_has_keyword_13_comment =
  "C++ Interface:\n"
  "has_keyword(DCKeywordList self, const DCKeyword keyword)\n"
  "has_keyword(DCKeywordList self, str name)\n"
  "\n"
  "/**\n"
  " * Returns true if this list includes the indicated keyword, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if this list includes the indicated keyword, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCKeywordList_has_keyword_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DCKeywordList::get_num_keywords(void) const
 */
static PyObject *Dtool_DCKeywordList_get_num_keywords_14(PyObject *self, PyObject *) {
  DCKeywordList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCKeywordList, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DCKeywordList::get_num_keywords(void) const
  int return_value = (*(const DCKeywordList*)local_this).get_num_keywords();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCKeywordList_get_num_keywords_14_comment =
  "C++ Interface:\n"
  "get_num_keywords(DCKeywordList self)\n"
  "\n"
  "/**\n"
  " * Returns the number of keywords in the list.\n"
  " */";
#else
static const char *Dtool_DCKeywordList_get_num_keywords_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCKeyword const *DCKeywordList::get_keyword(int n) const
 */
static PyObject *Dtool_DCKeywordList_get_keyword_15(PyObject *self, PyObject *arg) {
  DCKeywordList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCKeywordList, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCKeyword const *DCKeywordList::get_keyword(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCKeyword const *return_value = (*(const DCKeywordList*)local_this).get_keyword((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCKeyword, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_keyword(DCKeywordList self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCKeywordList_get_keyword_15_comment =
  "C++ Interface:\n"
  "get_keyword(DCKeywordList self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth keyword in the list.\n"
  " */";
#else
static const char *Dtool_DCKeywordList_get_keyword_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCKeyword const *DCKeywordList::get_keyword_by_name(std::string const &name) const
 */
static PyObject *Dtool_DCKeywordList_get_keyword_by_name_16(PyObject *self, PyObject *arg) {
  DCKeywordList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCKeywordList, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCKeyword const *DCKeywordList::get_keyword_by_name(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    DCKeyword const *return_value = (*(const DCKeywordList*)local_this).get_keyword_by_name(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCKeyword, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_keyword_by_name(DCKeywordList self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCKeywordList_get_keyword_by_name_16_comment =
  "C++ Interface:\n"
  "get_keyword_by_name(DCKeywordList self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the keyword in the list with the indicated name, or NULL if there\n"
  " * is no keyword in the list with that name.\n"
  " */";
#else
static const char *Dtool_DCKeywordList_get_keyword_by_name_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCKeywordList::compare_keywords(DCKeywordList const &other) const
 */
static PyObject *Dtool_DCKeywordList_compare_keywords_17(PyObject *self, PyObject *arg) {
  DCKeywordList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCKeywordList, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool DCKeywordList::compare_keywords(DCKeywordList const &other) const
  DCKeywordList const *arg_this = (DCKeywordList *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DCKeywordList, 1, "DCKeywordList.compare_keywords", true, true);
  if (arg_this != NULL) {
    bool return_value = (*(const DCKeywordList*)local_this).compare_keywords(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_keywords(DCKeywordList self, const DCKeywordList other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCKeywordList_compare_keywords_17_comment =
  "C++ Interface:\n"
  "compare_keywords(DCKeywordList self, const DCKeywordList other)\n"
  "\n"
  "/**\n"
  " * Returns true if this list has the same keywords as the other list, false if\n"
  " * some keywords differ.  Order is not considered important.\n"
  " */";
#else
static const char *Dtool_DCKeywordList_compare_keywords_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCField *DCKeywordList::downcast_to_DCField(void)
 */
static PyObject *Dtool_DCKeywordList_downcast_to_DCField_22(PyObject *self, PyObject *) {
  DCKeywordList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCKeywordList, (void **)&local_this, "DCKeywordList.downcast_to_DCField")) {
    return NULL;
  }
  // 1-DCField *DCKeywordList::downcast_to_DCField(void)
  DCField *return_value = (DCField *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCKeywordList_downcast_to_DCField_22_comment =
  "C++ Interface:\n"
  "downcast_to_DCField(const DCKeywordList self)\n"
  "\n"
  "downcast from DCKeywordList to DCField";
#else
static const char *Dtool_DCKeywordList_downcast_to_DCField_22_comment = NULL;
#endif

static int Dtool_Init_DCKeywordList(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCKeywordList(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DCKeywordList) {
    printf("DCKeywordList ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DCKeywordList *local_this = (DCKeywordList *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DCKeywordList) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DCKeywordList(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DCKeywordList) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DCField
 */
/**
 * Python function wrapper for:
 * inline int DCField::get_number(void) const
 */
static PyObject *Dtool_DCField_get_number_24(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DCField::get_number(void) const
  int return_value = (*(const DCField*)local_this).get_number();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_get_number_24_comment =
  "C++ Interface:\n"
  "get_number(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns a unique index number associated with this field.  This is defined\n"
  " * implicitly when the .dc file(s) are read.\n"
  " */";
#else
static const char *Dtool_DCField_get_number_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DCClass *DCField::get_class(void) const
 */
static PyObject *Dtool_DCField_get_class_25(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline DCClass *DCField::get_class(void) const
  DCClass *return_value = (*(const DCField*)local_this).get_class();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCClass, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCField_get_class_25_comment =
  "C++ Interface:\n"
  "get_class(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns the DCClass pointer for the class that contains this field.\n"
  " */";
#else
static const char *Dtool_DCField_get_class_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual DCField *DCField::as_field(void)
 * virtual DCField const *DCField::as_field(void) const
 */
static PyObject *Dtool_DCField_as_field_26(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 virtual DCField *DCField::as_field(void)
    DCField *return_value = (*local_this).as_field();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
  }

  {
    // -2 virtual DCField const *DCField::as_field(void) const
    DCField const *return_value = (*(const DCField*)local_this).as_field();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, true);
  }

  // No coercion possible: virtual DCField *DCField::as_field(void)
  // No coercion possible: virtual DCField const *DCField::as_field(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCField_as_field_26_comment =
  "C++ Interface:\n"
  "as_field(const DCField self)\n"
  "as_field(DCField self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DCField_as_field_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual DCAtomicField *DCField::as_atomic_field(void)
 * virtual DCAtomicField const *DCField::as_atomic_field(void) const
 */
static PyObject *Dtool_DCField_as_atomic_field_27(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 virtual DCAtomicField *DCField::as_atomic_field(void)
    DCAtomicField *return_value = (*local_this).as_atomic_field();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCAtomicField, false, false);
  }

  {
    // -2 virtual DCAtomicField const *DCField::as_atomic_field(void) const
    DCAtomicField const *return_value = (*(const DCField*)local_this).as_atomic_field();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCAtomicField, false, true);
  }

  // No coercion possible: virtual DCAtomicField *DCField::as_atomic_field(void)
  // No coercion possible: virtual DCAtomicField const *DCField::as_atomic_field(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCField_as_atomic_field_27_comment =
  "C++ Interface:\n"
  "as_atomic_field(const DCField self)\n"
  "as_atomic_field(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns the same field pointer converted to an atomic field pointer, if\n"
  " * this is in fact an atomic field; otherwise, returns NULL.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the same field pointer converted to an atomic field pointer, if\n"
  " * this is in fact an atomic field; otherwise, returns NULL.\n"
  " */";
#else
static const char *Dtool_DCField_as_atomic_field_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual DCMolecularField *DCField::as_molecular_field(void)
 * virtual DCMolecularField const *DCField::as_molecular_field(void) const
 */
static PyObject *Dtool_DCField_as_molecular_field_28(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 virtual DCMolecularField *DCField::as_molecular_field(void)
    DCMolecularField *return_value = (*local_this).as_molecular_field();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCMolecularField, false, false);
  }

  {
    // -2 virtual DCMolecularField const *DCField::as_molecular_field(void) const
    DCMolecularField const *return_value = (*(const DCField*)local_this).as_molecular_field();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCMolecularField, false, true);
  }

  // No coercion possible: virtual DCMolecularField *DCField::as_molecular_field(void)
  // No coercion possible: virtual DCMolecularField const *DCField::as_molecular_field(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCField_as_molecular_field_28_comment =
  "C++ Interface:\n"
  "as_molecular_field(const DCField self)\n"
  "as_molecular_field(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns the same field pointer converted to a molecular field pointer, if\n"
  " * this is in fact a molecular field; otherwise, returns NULL.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the same field pointer converted to a molecular field pointer, if\n"
  " * this is in fact a molecular field; otherwise, returns NULL.\n"
  " */";
#else
static const char *Dtool_DCField_as_molecular_field_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual DCParameter *DCField::as_parameter(void)
 * virtual DCParameter const *DCField::as_parameter(void) const
 */
static PyObject *Dtool_DCField_as_parameter_29(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 virtual DCParameter *DCField::as_parameter(void)
    DCParameter *return_value = (*local_this).as_parameter();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCParameter, false, false);
  }

  {
    // -2 virtual DCParameter const *DCField::as_parameter(void) const
    DCParameter const *return_value = (*(const DCField*)local_this).as_parameter();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCParameter, false, true);
  }

  // No coercion possible: virtual DCParameter *DCField::as_parameter(void)
  // No coercion possible: virtual DCParameter const *DCField::as_parameter(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCField_as_parameter_29_comment =
  "C++ Interface:\n"
  "as_parameter(const DCField self)\n"
  "as_parameter(DCField self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DCField_as_parameter_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string DCField::format_data(std::string const &packed_data, bool show_field_names = true)
 */
static PyObject *Dtool_DCField_format_data_30(PyObject *self, PyObject *args, PyObject *kwds) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCField, (void **)&local_this, "DCField.format_data")) {
    return NULL;
  }
  // 1-std::string DCField::format_data(std::string const &packed_data, bool show_field_names = true)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  PyObject *param2 = Py_True;
  static const char *keyword_list[] = {"packed_data", "show_field_names", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|O:format_data", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    std::string return_value = (*local_this).format_data(std::string(param1_str, param1_len), (PyObject_IsTrue(param2) != 0));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "format_data(const DCField self, str packed_data, bool show_field_names)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCField_format_data_30_comment =
  "C++ Interface:\n"
  "format_data(const DCField self, str packed_data, bool show_field_names)\n"
  "\n"
  "/**\n"
  " * Given a blob that represents the packed data for this field, returns a\n"
  " * string formatting it for human consumption.  Returns empty string if there\n"
  " * is an error.\n"
  " */";
#else
static const char *Dtool_DCField_format_data_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string DCField::parse_string(std::string const &formatted_string)
 */
static PyObject *Dtool_DCField_parse_string_31(PyObject *self, PyObject *arg) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCField, (void **)&local_this, "DCField.parse_string")) {
    return NULL;
  }
  // 1-std::string DCField::parse_string(std::string const &formatted_string)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    std::string return_value = (*local_this).parse_string(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "parse_string(const DCField self, str formatted_string)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCField_parse_string_31_comment =
  "C++ Interface:\n"
  "parse_string(const DCField self, str formatted_string)\n"
  "\n"
  "/**\n"
  " * Given a human-formatted string (for instance, as returned by format_data(),\n"
  " * above) that represents the value of this field, parse the string and return\n"
  " * the corresponding packed data.  Returns empty string if there is an error.\n"
  " */";
#else
static const char *Dtool_DCField_parse_string_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCField::validate_ranges(std::string const &packed_data) const
 */
static PyObject *Dtool_DCField_validate_ranges_32(PyObject *self, PyObject *arg) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool DCField::validate_ranges(std::string const &packed_data) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*(const DCField*)local_this).validate_ranges(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "validate_ranges(DCField self, str packed_data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCField_validate_ranges_32_comment =
  "C++ Interface:\n"
  "validate_ranges(DCField self, str packed_data)\n"
  "\n"
  "/**\n"
  " * Verifies that all of the packed values in the field data are within the\n"
  " * specified ranges and that there are no extra bytes on the end of the\n"
  " * record.  Returns true if all fields are valid, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_validate_ranges_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::has_default_value(void) const
 */
static PyObject *Dtool_DCField_has_default_value_33(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCField::has_default_value(void) const
  bool return_value = (*(const DCField*)local_this).has_default_value();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_has_default_value_33_comment =
  "C++ Interface:\n"
  "has_default_value(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if a default value has been explicitly established for this\n"
  " * field, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_has_default_value_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &DCField::get_default_value(void) const
 */
static PyObject *Dtool_DCField_get_default_value_34(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &DCField::get_default_value(void) const
  std::string const &return_value = (*(const DCField*)local_this).get_default_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_get_default_value_34_comment =
  "C++ Interface:\n"
  "get_default_value(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns the default value for this field.  If a default value has been\n"
  " * explicitly set (e.g.  has_default_value() returns true), returns that\n"
  " * value; otherwise, returns an implicit default for the field.\n"
  " */";
#else
static const char *Dtool_DCField_get_default_value_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_bogus_field(void) const
 */
static PyObject *Dtool_DCField_is_bogus_field_35(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCField::is_bogus_field(void) const
  bool return_value = (*(const DCField*)local_this).is_bogus_field();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_bogus_field_35_comment =
  "C++ Interface:\n"
  "is_bogus_field(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the field has been flagged as a bogus field.  This is set\n"
  " * for fields that are generated by the parser as placeholder for missing\n"
  " * fields, as when reading a partial file; it should not occur in a normal\n"
  " * valid dc file.\n"
  " */";
#else
static const char *Dtool_DCField_is_bogus_field_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_required(void) const
 */
static PyObject *Dtool_DCField_is_required_36(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCField::is_required(void) const
  bool return_value = (*(const DCField*)local_this).is_required();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_required_36_comment =
  "C++ Interface:\n"
  "is_required(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"required\" flag is set for this field, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_is_required_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_broadcast(void) const
 */
static PyObject *Dtool_DCField_is_broadcast_37(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCField::is_broadcast(void) const
  bool return_value = (*(const DCField*)local_this).is_broadcast();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_broadcast_37_comment =
  "C++ Interface:\n"
  "is_broadcast(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"broadcast\" flag is set for this field, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_is_broadcast_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_ram(void) const
 */
static PyObject *Dtool_DCField_is_ram_38(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCField::is_ram(void) const
  bool return_value = (*(const DCField*)local_this).is_ram();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_ram_38_comment =
  "C++ Interface:\n"
  "is_ram(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"ram\" flag is set for this field, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_is_ram_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_db(void) const
 */
static PyObject *Dtool_DCField_is_db_39(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCField::is_db(void) const
  bool return_value = (*(const DCField*)local_this).is_db();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_db_39_comment =
  "C++ Interface:\n"
  "is_db(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"db\" flag is set for this field, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_is_db_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_clsend(void) const
 */
static PyObject *Dtool_DCField_is_clsend_40(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCField::is_clsend(void) const
  bool return_value = (*(const DCField*)local_this).is_clsend();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_clsend_40_comment =
  "C++ Interface:\n"
  "is_clsend(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"clsend\" flag is set for this field, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_is_clsend_40_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_clrecv(void) const
 */
static PyObject *Dtool_DCField_is_clrecv_41(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCField::is_clrecv(void) const
  bool return_value = (*(const DCField*)local_this).is_clrecv();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_clrecv_41_comment =
  "C++ Interface:\n"
  "is_clrecv(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"clrecv\" flag is set for this field, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_is_clrecv_41_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_ownsend(void) const
 */
static PyObject *Dtool_DCField_is_ownsend_42(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCField::is_ownsend(void) const
  bool return_value = (*(const DCField*)local_this).is_ownsend();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_ownsend_42_comment =
  "C++ Interface:\n"
  "is_ownsend(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"ownsend\" flag is set for this field, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_is_ownsend_42_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_ownrecv(void) const
 */
static PyObject *Dtool_DCField_is_ownrecv_43(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCField::is_ownrecv(void) const
  bool return_value = (*(const DCField*)local_this).is_ownrecv();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_ownrecv_43_comment =
  "C++ Interface:\n"
  "is_ownrecv(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"ownrecv\" flag is set for this field, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_is_ownrecv_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_airecv(void) const
 */
static PyObject *Dtool_DCField_is_airecv_44(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCField::is_airecv(void) const
  bool return_value = (*(const DCField*)local_this).is_airecv();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_airecv_44_comment =
  "C++ Interface:\n"
  "is_airecv(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"airecv\" flag is set for this field, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_is_airecv_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCField::output(ostream &out) const
 */
static PyObject *Dtool_DCField_output_45(PyObject *self, PyObject *arg) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void DCField::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "DCField.output", false, true);
  if (arg_this != NULL) {
    (*(const DCField*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(DCField self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCField_output_45_comment =
  "C++ Interface:\n"
  "output(DCField self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_DCField_output_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCField::write(ostream &out, int indent_level) const
 */
static PyObject *Dtool_DCField_write_46(PyObject *self, PyObject *args, PyObject *kwds) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void DCField::write(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "DCField.write", false, true);
    if (param1_this != NULL) {
      (*(const DCField*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(DCField self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCField_write_46_comment =
  "C++ Interface:\n"
  "write(DCField self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_DCField_write_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCField::pack_args(DCPacker &packer, PyObject *sequence) const
 */
static PyObject *Dtool_DCField_pack_args_47(PyObject *self, PyObject *args, PyObject *kwds) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool DCField::pack_args(DCPacker &packer, PyObject *sequence) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"packer", "sequence", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:pack_args", (char **)keyword_list, &param1, &param2)) {
    DCPacker *param1_this = (DCPacker *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_DCPacker, 1, "DCField.pack_args", false, true);
    if (param1_this != NULL) {
      bool return_value = (*(const DCField*)local_this).pack_args(*param1_this, param2);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_args(DCField self, DCPacker packer, object sequence)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCField_pack_args_47_comment =
  "C++ Interface:\n"
  "pack_args(DCField self, DCPacker packer, object sequence)\n"
  "\n"
  "/**\n"
  " * Packs the Python arguments from the indicated tuple into the packer.\n"
  " * Returns true on success, false on failure.\n"
  " *\n"
  " * It is assumed that the packer is currently positioned on this field.\n"
  " */";
#else
static const char *Dtool_DCField_pack_args_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *DCField::unpack_args(DCPacker &packer) const
 */
static PyObject *Dtool_DCField_unpack_args_48(PyObject *self, PyObject *arg) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-PyObject *DCField::unpack_args(DCPacker &packer) const
  DCPacker *arg_this = (DCPacker *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DCPacker, 1, "DCField.unpack_args", false, true);
  if (arg_this != NULL) {
    PyObject *return_value = (*(const DCField*)local_this).unpack_args(*arg_this);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unpack_args(DCField self, DCPacker packer)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCField_unpack_args_48_comment =
  "C++ Interface:\n"
  "unpack_args(DCField self, DCPacker packer)\n"
  "\n"
  "/**\n"
  " * Unpacks the values from the packer, beginning at the current point in the\n"
  " * unpack_buffer, into a Python tuple and returns the tuple.\n"
  " *\n"
  " * It is assumed that the packer is currently positioned on this field.\n"
  " */";
#else
static const char *Dtool_DCField_unpack_args_48_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCField::receive_update(DCPacker &packer, PyObject *distobj) const
 */
static PyObject *Dtool_DCField_receive_update_49(PyObject *self, PyObject *args, PyObject *kwds) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DCField::receive_update(DCPacker &packer, PyObject *distobj) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"packer", "distobj", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:receive_update", (char **)keyword_list, &param1, &param2)) {
    DCPacker *param1_this = (DCPacker *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_DCPacker, 1, "DCField.receive_update", false, true);
    if (param1_this != NULL) {
      (*(const DCField*)local_this).receive_update(*param1_this, param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "receive_update(DCField self, DCPacker packer, object distobj)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCField_receive_update_49_comment =
  "C++ Interface:\n"
  "receive_update(DCField self, DCPacker packer, object distobj)\n"
  "\n"
  "/**\n"
  " * Extracts the update message out of the datagram and applies it to the\n"
  " * indicated object by calling the appropriate method.\n"
  " */";
#else
static const char *Dtool_DCField_receive_update_49_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Datagram DCField::client_format_update(DOID_TYPE do_id, PyObject *args) const
 */
static PyObject *Dtool_DCField_client_format_update_50(PyObject *self, PyObject *args, PyObject *kwds) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-Datagram DCField::client_format_update(DOID_TYPE do_id, PyObject *args) const
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"do_id", "args", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:client_format_update", (char **)keyword_list, &param1, &param2)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    Datagram *return_value = new Datagram((*(const DCField*)local_this).client_format_update((DOID_TYPE)param1, param2));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "client_format_update(DCField self, int do_id, object args)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCField_client_format_update_50_comment =
  "C++ Interface:\n"
  "client_format_update(DCField self, int do_id, object args)\n"
  "\n"
  "/**\n"
  " * Generates a datagram containing the message necessary to send an update for\n"
  " * the indicated distributed object from the client.\n"
  " */";
#else
static const char *Dtool_DCField_client_format_update_50_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Datagram DCField::ai_format_update(DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, PyObject *args) const
 */
static PyObject *Dtool_DCField_ai_format_update_51(PyObject *self, PyObject *args, PyObject *kwds) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-Datagram DCField::ai_format_update(DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, PyObject *args) const
  unsigned long param1;
  unsigned PY_LONG_LONG param2;
  unsigned PY_LONG_LONG param3;
  PyObject *param4;
  static const char *keyword_list[] = {"do_id", "to_id", "from_id", "args", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kKKO:ai_format_update", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    Datagram *return_value = new Datagram((*(const DCField*)local_this).ai_format_update((DOID_TYPE)param1, (CHANNEL_TYPE)param2, (CHANNEL_TYPE)param3, param4));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ai_format_update(DCField self, int do_id, long to_id, long from_id, object args)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCField_ai_format_update_51_comment =
  "C++ Interface:\n"
  "ai_format_update(DCField self, int do_id, long to_id, long from_id, object args)\n"
  "\n"
  "/**\n"
  " * Generates a datagram containing the message necessary to send an update for\n"
  " * the indicated distributed object from the AI.\n"
  " */";
#else
static const char *Dtool_DCField_ai_format_update_51_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Datagram DCField::ai_format_update_msg_type(DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, int msg_type, PyObject *args) const
 */
static PyObject *Dtool_DCField_ai_format_update_msg_type_52(PyObject *self, PyObject *args, PyObject *kwds) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }
  // 1-Datagram DCField::ai_format_update_msg_type(DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, int msg_type, PyObject *args) const
  unsigned long param1;
  unsigned PY_LONG_LONG param2;
  unsigned PY_LONG_LONG param3;
  int param4;
  PyObject *param5;
  static const char *keyword_list[] = {"do_id", "to_id", "from_id", "msg_type", "args", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kKKiO:ai_format_update_msg_type", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    Datagram *return_value = new Datagram((*(const DCField*)local_this).ai_format_update_msg_type((DOID_TYPE)param1, (CHANNEL_TYPE)param2, (CHANNEL_TYPE)param3, (int)param4, param5));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ai_format_update_msg_type(DCField self, int do_id, long to_id, long from_id, int msg_type, object args)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCField_ai_format_update_msg_type_52_comment =
  "C++ Interface:\n"
  "ai_format_update_msg_type(DCField self, int do_id, long to_id, long from_id, int msg_type, object args)\n"
  "\n"
  "/**\n"
  " * Generates a datagram containing the message necessary to send an update,\n"
  " * with the msg type, for the indicated distributed object from the AI.\n"
  " */";
#else
static const char *Dtool_DCField_ai_format_update_msg_type_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCPackerInterface *DCField::upcast_to_DCPackerInterface(void)
 */
static PyObject *Dtool_DCField_upcast_to_DCPackerInterface_19(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCField, (void **)&local_this, "DCField.upcast_to_DCPackerInterface")) {
    return NULL;
  }
  // 1-DCPackerInterface *DCField::upcast_to_DCPackerInterface(void)
  DCPackerInterface *return_value = (DCPackerInterface *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCPackerInterface, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCField_upcast_to_DCPackerInterface_19_comment =
  "C++ Interface:\n"
  "upcast_to_DCPackerInterface(const DCField self)\n"
  "\n"
  "upcast from DCField to DCPackerInterface";
#else
static const char *Dtool_DCField_upcast_to_DCPackerInterface_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCKeywordList *DCField::upcast_to_DCKeywordList(void)
 */
static PyObject *Dtool_DCField_upcast_to_DCKeywordList_21(PyObject *self, PyObject *) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCField, (void **)&local_this, "DCField.upcast_to_DCKeywordList")) {
    return NULL;
  }
  // 1-DCKeywordList *DCField::upcast_to_DCKeywordList(void)
  DCKeywordList *return_value = (DCKeywordList *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCKeywordList, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCField_upcast_to_DCKeywordList_21_comment =
  "C++ Interface:\n"
  "upcast_to_DCKeywordList(const DCField self)\n"
  "\n"
  "upcast from DCField to DCKeywordList";
#else
static const char *Dtool_DCField_upcast_to_DCKeywordList_21_comment = NULL;
#endif

static int Dtool_Init_DCField(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCField(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DCField) {
    printf("DCField ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DCField *local_this = (DCField *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DCField) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCKeywordList) {
    return (DCKeywordList *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCPackerInterface) {
    return (DCPackerInterface *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DCField(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DCField) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCKeywordList) {
    DCKeywordList* other_this = (DCKeywordList*)from_this;
    return (DCField*)other_this;
  }
  if (from_type == Dtool_Ptr_DCPackerInterface) {
    DCPackerInterface* other_this = (DCPackerInterface*)from_this;
    return (DCField*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DCPackData
 */
/**
 * Python function wrapper for:
 * inline void DCPackData::clear(void)
 */
static PyObject *Dtool_DCPackData_clear_56(PyObject *self, PyObject *) {
  DCPackData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPackData, (void **)&local_this, "DCPackData.clear")) {
    return NULL;
  }
  // 1-inline void DCPackData::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCPackData_clear_56_comment =
  "C++ Interface:\n"
  "clear(const DCPackData self)\n"
  "\n"
  "/**\n"
  " * Empties the contents of the data (without necessarily freeing its allocated\n"
  " * memory).\n"
  " */";
#else
static const char *Dtool_DCPackData_clear_56_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string DCPackData::get_string(void) const
 */
static PyObject *Dtool_DCPackData_get_string_57(PyObject *self, PyObject *) {
  DCPackData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPackData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string DCPackData::get_string(void) const
  std::string return_value = (*(const DCPackData*)local_this).get_string();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPackData_get_string_57_comment =
  "C++ Interface:\n"
  "get_string(DCPackData self)\n"
  "\n"
  "/**\n"
  " * Returns the data buffer as a string.  Also see get_data().\n"
  " */";
#else
static const char *Dtool_DCPackData_get_string_57_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t DCPackData::get_length(void) const
 */
static PyObject *Dtool_DCPackData_get_length_58(PyObject *self, PyObject *) {
  DCPackData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPackData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t DCPackData::get_length(void) const
  std::size_t return_value = (*(const DCPackData*)local_this).get_length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPackData_get_length_58_comment =
  "C++ Interface:\n"
  "get_length(DCPackData self)\n"
  "\n"
  "/**\n"
  " * Returns the current length of the buffer.  This is the number of useful\n"
  " * bytes stored in the buffer, not the amount of memory it takes up.\n"
  " */";
#else
static const char *Dtool_DCPackData_get_length_58_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DCPackData::DCPackData(void)
 * inline DCPackData::DCPackData(DCPackData const &) = default
 */
static int Dtool_Init_DCPackData(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline DCPackData::DCPackData(void)
      DCPackData *return_value = new DCPackData();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DCPackData, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline DCPackData::DCPackData(DCPackData const &) = default
      DCPackData const *arg_this = (DCPackData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DCPackData, 0, "DCPackData.DCPackData", true, true);
      if (arg_this != NULL) {
        DCPackData *return_value = new DCPackData(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DCPackData, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DCPackData() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DCPackData()\n"
      "DCPackData(const DCPackData param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DCPackData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DCPackData) {
    printf("DCPackData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DCPackData *local_this = (DCPackData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DCPackData) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DCPackData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DCPackData) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DCPacker
 */
/**
 * Python function wrapper for:
 * inline void DCPacker::clear_data(void)
 */
static PyObject *Dtool_DCPacker_clear_data_62(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.clear_data")) {
    return NULL;
  }
  // 1-inline void DCPacker::clear_data(void)
  (*local_this).clear_data();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_clear_data_62_comment =
  "C++ Interface:\n"
  "clear_data(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Empties the data in the pack buffer and unpack buffer.  This should be\n"
  " * called between calls to begin_pack(), unless you want to concatenate all of\n"
  " * the pack results together.\n"
  " */";
#else
static const char *Dtool_DCPacker_clear_data_62_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::begin_pack(DCPackerInterface const *root)
 */
static PyObject *Dtool_DCPacker_begin_pack_63(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.begin_pack")) {
    return NULL;
  }
  // 1-void DCPacker::begin_pack(DCPackerInterface const *root)
  DCPackerInterface const *arg_this = (DCPackerInterface *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DCPackerInterface, 1, "DCPacker.begin_pack", true, true);
  if (arg_this != NULL) {
    (*local_this).begin_pack(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "begin_pack(const DCPacker self, const DCPackerInterface root)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_begin_pack_63_comment =
  "C++ Interface:\n"
  "begin_pack(const DCPacker self, const DCPackerInterface root)\n"
  "\n"
  "/**\n"
  " * Begins a packing session.  The parameter is the DC object that describes\n"
  " * the packing format; it may be a DCParameter or DCField.\n"
  " *\n"
  " * Unless you call clear_data() between sessions, multiple packing sessions\n"
  " * will be concatenated together into the same buffer.  If you wish to add\n"
  " * bytes to the buffer between packing sessions, use append_data() or\n"
  " * get_write_pointer().\n"
  " */";
#else
static const char *Dtool_DCPacker_begin_pack_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCPacker::end_pack(void)
 */
static PyObject *Dtool_DCPacker_end_pack_64(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.end_pack")) {
    return NULL;
  }
  // 1-bool DCPacker::end_pack(void)
  bool return_value = (*local_this).end_pack();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_end_pack_64_comment =
  "C++ Interface:\n"
  "end_pack(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Finishes a packing session.\n"
  " *\n"
  " * The return value is true on success, or false if there has been some error\n"
  " * during packing.\n"
  " */";
#else
static const char *Dtool_DCPacker_end_pack_64_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::set_unpack_data(std::string const &data)
 */
static PyObject *Dtool_DCPacker_set_unpack_data_65(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.set_unpack_data")) {
    return NULL;
  }
  // 1-void DCPacker::set_unpack_data(std::string const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_unpack_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_unpack_data(const DCPacker self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_set_unpack_data_65_comment =
  "C++ Interface:\n"
  "set_unpack_data(const DCPacker self, str data)\n"
  "\n"
  "/**\n"
  " * Sets up the unpack_data pointer.  You may call this before calling the\n"
  " * version of begin_unpack() that takes only one parameter.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up the unpack_data pointer.  You may call this before calling the\n"
  " * version of begin_unpack() that takes only one parameter.\n"
  " */";
#else
static const char *Dtool_DCPacker_set_unpack_data_65_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::begin_unpack(DCPackerInterface const *root)
 */
static PyObject *Dtool_DCPacker_begin_unpack_66(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.begin_unpack")) {
    return NULL;
  }
  // 1-void DCPacker::begin_unpack(DCPackerInterface const *root)
  DCPackerInterface const *arg_this = (DCPackerInterface *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DCPackerInterface, 1, "DCPacker.begin_unpack", true, true);
  if (arg_this != NULL) {
    (*local_this).begin_unpack(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "begin_unpack(const DCPacker self, const DCPackerInterface root)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_begin_unpack_66_comment =
  "C++ Interface:\n"
  "begin_unpack(const DCPacker self, const DCPackerInterface root)\n"
  "\n"
  "/**\n"
  " * Begins an unpacking session.  You must have previously called\n"
  " * set_unpack_data() to specify a buffer to unpack.\n"
  " *\n"
  " * If there was data left in the buffer after a previous begin_unpack() ..\n"
  " * end_unpack() session, the new session will resume from the current point.\n"
  " * This method may be used, therefore, to unpack a sequence of objects from\n"
  " * the same buffer.\n"
  " */";
#else
static const char *Dtool_DCPacker_begin_unpack_66_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCPacker::end_unpack(void)
 */
static PyObject *Dtool_DCPacker_end_unpack_67(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.end_unpack")) {
    return NULL;
  }
  // 1-bool DCPacker::end_unpack(void)
  bool return_value = (*local_this).end_unpack();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_end_unpack_67_comment =
  "C++ Interface:\n"
  "end_unpack(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Finishes the unpacking session.\n"
  " *\n"
  " * The return value is true on success, or false if there has been some error\n"
  " * during unpacking (or if all fields have not been unpacked).\n"
  " */";
#else
static const char *Dtool_DCPacker_end_unpack_67_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::begin_repack(DCPackerInterface const *root)
 */
static PyObject *Dtool_DCPacker_begin_repack_68(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.begin_repack")) {
    return NULL;
  }
  // 1-void DCPacker::begin_repack(DCPackerInterface const *root)
  DCPackerInterface const *arg_this = (DCPackerInterface *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DCPackerInterface, 1, "DCPacker.begin_repack", true, true);
  if (arg_this != NULL) {
    (*local_this).begin_repack(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "begin_repack(const DCPacker self, const DCPackerInterface root)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_begin_repack_68_comment =
  "C++ Interface:\n"
  "begin_repack(const DCPacker self, const DCPackerInterface root)\n"
  "\n"
  "/**\n"
  " * Begins a repacking session.  You must have previously called\n"
  " * set_unpack_data() to specify a buffer to unpack.\n"
  " *\n"
  " * Unlike begin_pack() or begin_unpack() you may not concatenate the results\n"
  " * of multiple begin_repack() sessions in one buffer.\n"
  " *\n"
  " * Also, unlike in packing or unpacking modes, you may not walk through the\n"
  " * fields from beginning to end, or even pack two consecutive fields at once.\n"
  " * Instead, you must call seek() for each field you wish to modify and pack\n"
  " * only that one field; then call seek() again to modify another field.\n"
  " */";
#else
static const char *Dtool_DCPacker_begin_repack_68_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCPacker::end_repack(void)
 */
static PyObject *Dtool_DCPacker_end_repack_69(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.end_repack")) {
    return NULL;
  }
  // 1-bool DCPacker::end_repack(void)
  bool return_value = (*local_this).end_repack();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_end_repack_69_comment =
  "C++ Interface:\n"
  "end_repack(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Finishes the repacking session.\n"
  " *\n"
  " * The return value is true on success, or false if there has been some error\n"
  " * during repacking (or if all fields have not been repacked).\n"
  " */";
#else
static const char *Dtool_DCPacker_end_repack_69_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCPacker::seek(int seek_index)
 * bool DCPacker::seek(std::string const &field_name)
 */
static PyObject *Dtool_DCPacker_seek_70(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.seek")) {
    return NULL;
  }
  {
    // -2 bool DCPacker::seek(std::string const &field_name)
    char *param1_str = NULL;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      bool return_value = (*local_this).seek(std::string(param1_str, param1_len));
      return Dtool_Return_Bool(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 bool DCPacker::seek(int seek_index)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      bool return_value = (*local_this).seek((int)arg_val);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: bool DCPacker::seek(std::string const &field_name)
  // No coercion possible: bool DCPacker::seek(int seek_index)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "seek(const DCPacker self, str field_name)\n"
      "seek(const DCPacker self, int seek_index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_seek_70_comment =
  "C++ Interface:\n"
  "seek(const DCPacker self, str field_name)\n"
  "seek(const DCPacker self, int seek_index)\n"
  "\n"
  "/**\n"
  " * Sets the current unpack (or repack) position to the named field.  In unpack\n"
  " * mode, the next call to unpack_*() or push() will begin to read the named\n"
  " * field.  In repack mode, the next call to pack_*() or push() will modify the\n"
  " * named field.\n"
  " *\n"
  " * Returns true if successful, false if the field is not known (or if the\n"
  " * packer is in an invalid mode).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Seeks to the field indentified by seek_index, which was returned by an\n"
  " * earlier call to DCField::find_seek_index() to get the index of some nested\n"
  " * field.  Also see the version of seek() that accepts a field name.\n"
  " *\n"
  " * Returns true if successful, false if the field is not known (or if the\n"
  " * packer is in an invalid mode).\n"
  " */";
#else
static const char *Dtool_DCPacker_seek_70_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCPacker::has_nested_fields(void) const
 */
static PyObject *Dtool_DCPacker_has_nested_fields_71(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPacker, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCPacker::has_nested_fields(void) const
  bool return_value = (*(const DCPacker*)local_this).has_nested_fields();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_has_nested_fields_71_comment =
  "C++ Interface:\n"
  "has_nested_fields(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns true if the current field has any nested fields (and thus expects a\n"
  " * push() .. pop() interface), or false otherwise.  If this returns true,\n"
  " * get_num_nested_fields() may be called to determine how many nested fields\n"
  " * are expected.\n"
  " */";
#else
static const char *Dtool_DCPacker_has_nested_fields_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DCPacker::get_num_nested_fields(void) const
 */
static PyObject *Dtool_DCPacker_get_num_nested_fields_72(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPacker, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DCPacker::get_num_nested_fields(void) const
  int return_value = (*(const DCPacker*)local_this).get_num_nested_fields();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_num_nested_fields_72_comment =
  "C++ Interface:\n"
  "get_num_nested_fields(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the number of nested fields associated with the current field, if\n"
  " * has_nested_fields() returned true.\n"
  " *\n"
  " * The return value may be -1 to indicate that a variable number of nested\n"
  " * fields are accepted by this field type (e.g.  a variable-length array).\n"
  " *\n"
  " * Note that this method is unreliable to determine how many fields you must\n"
  " * traverse before you can call pop(), since particularly in the presence of a\n"
  " * DCSwitch, it may change during traversal.  Use more_nested_fields()\n"
  " * instead.\n"
  " */";
#else
static const char *Dtool_DCPacker_get_num_nested_fields_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCPacker::more_nested_fields(void) const
 */
static PyObject *Dtool_DCPacker_more_nested_fields_73(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPacker, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCPacker::more_nested_fields(void) const
  bool return_value = (*(const DCPacker*)local_this).more_nested_fields();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_more_nested_fields_73_comment =
  "C++ Interface:\n"
  "more_nested_fields(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns true if there are more nested fields to pack or unpack in the\n"
  " * current push sequence, false if it is time to call pop().\n"
  " */";
#else
static const char *Dtool_DCPacker_more_nested_fields_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DCPackerInterface const *DCPacker::get_current_parent(void) const
 */
static PyObject *Dtool_DCPacker_get_current_parent_74(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPacker, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline DCPackerInterface const *DCPacker::get_current_parent(void) const
  DCPackerInterface const *return_value = (*(const DCPacker*)local_this).get_current_parent();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCPackerInterface, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_current_parent_74_comment =
  "C++ Interface:\n"
  "get_current_parent(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the field that we left in our last call to push(): the owner of the\n"
  " * current level of fields.  This may be NULL at the beginning of the pack\n"
  " * operation.\n"
  " */";
#else
static const char *Dtool_DCPacker_get_current_parent_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DCPackerInterface const *DCPacker::get_current_field(void) const
 */
static PyObject *Dtool_DCPacker_get_current_field_75(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPacker, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline DCPackerInterface const *DCPacker::get_current_field(void) const
  DCPackerInterface const *return_value = (*(const DCPacker*)local_this).get_current_field();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCPackerInterface, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_current_field_75_comment =
  "C++ Interface:\n"
  "get_current_field(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the field that will be referenced by the next call to pack_*() or\n"
  " * unpack_*().  This will be NULL if we have unpacked (or packed) all fields,\n"
  " * or if it is time to call pop().\n"
  " */";
#else
static const char *Dtool_DCPacker_get_current_field_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DCSwitchParameter const *DCPacker::get_last_switch(void) const
 */
static PyObject *Dtool_DCPacker_get_last_switch_76(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPacker, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline DCSwitchParameter const *DCPacker::get_last_switch(void) const
  DCSwitchParameter const *return_value = (*(const DCPacker*)local_this).get_last_switch();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCSwitchParameter, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_last_switch_76_comment =
  "C++ Interface:\n"
  "get_last_switch(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the last DCSwitch instance that we have passed by and\n"
  " * selected one case of during the pack/unpack process.  Each time we\n"
  " * encounter a new DCSwitch and select a case, this will change state.\n"
  " *\n"
  " * This may be used to detect when a DCSwitch has been selected.  At the\n"
  " * moment this changes state, get_current_parent() will contain the particular\n"
  " * SwitchCase that was selected by the switch.\n"
  " */";
#else
static const char *Dtool_DCPacker_get_last_switch_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DCPackType DCPacker::get_pack_type(void) const
 */
static PyObject *Dtool_DCPacker_get_pack_type_77(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPacker, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline DCPackType DCPacker::get_pack_type(void) const
  DCPackType return_value = (*(const DCPacker*)local_this).get_pack_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_pack_type_77_comment =
  "C++ Interface:\n"
  "get_pack_type(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the type of value expected by the current field.  See the\n"
  " * enumerated type definition at the top of DCPackerInterface.h.  If this\n"
  " * returns one of PT_double, PT_int, PT_int64, or PT_string, then you should\n"
  " * call the corresponding pack_double(), pack_int() function (or\n"
  " * unpack_double(), unpack_int(), etc.) to transfer data.  Otherwise, you\n"
  " * should call push() and begin packing or unpacking the nested fields.\n"
  " */";
#else
static const char *Dtool_DCPacker_get_pack_type_77_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string DCPacker::get_current_field_name(void) const
 */
static PyObject *Dtool_DCPacker_get_current_field_name_78(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPacker, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string DCPacker::get_current_field_name(void) const
  std::string return_value = (*(const DCPacker*)local_this).get_current_field_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_current_field_name_78_comment =
  "C++ Interface:\n"
  "get_current_field_name(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the current field, if it has a name, or the empty\n"
  " * string if the field does not have a name or there is no current field.\n"
  " */";
#else
static const char *Dtool_DCPacker_get_current_field_name_78_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::push(void)
 */
static PyObject *Dtool_DCPacker_push_79(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.push")) {
    return NULL;
  }
  // 1-void DCPacker::push(void)
  (*local_this).push();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_push_79_comment =
  "C++ Interface:\n"
  "push(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Marks the beginning of a nested series of fields.\n"
  " *\n"
  " * This must be called before filling the elements of an array or the\n"
  " * individual fields in a structure field.  It must also be balanced by a\n"
  " * matching pop().\n"
  " *\n"
  " * It is necessary to use push() / pop() only if has_nested_fields() returns\n"
  " * true.\n"
  " */";
#else
static const char *Dtool_DCPacker_push_79_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::pop(void)
 */
static PyObject *Dtool_DCPacker_pop_80(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pop")) {
    return NULL;
  }
  // 1-void DCPacker::pop(void)
  (*local_this).pop();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pop_80_comment =
  "C++ Interface:\n"
  "pop(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Marks the end of a nested series of fields.\n"
  " *\n"
  " * This must be called to match a previous push() only after all the expected\n"
  " * number of nested fields have been packed.  It is an error to call it too\n"
  " * early, or too late.\n"
  " */";
#else
static const char *Dtool_DCPacker_pop_80_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::pack_double(double value)
 */
static PyObject *Dtool_DCPacker_pack_double_81(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pack_double")) {
    return NULL;
  }
  // 1-inline void DCPacker::pack_double(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).pack_double(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_double(const DCPacker self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pack_double_81_comment =
  "C++ Interface:\n"
  "pack_double(const DCPacker self, double value)\n"
  "\n"
  "/**\n"
  " * Packs the indicated numeric or string value into the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_pack_double_81_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::pack_int(int value)
 */
static PyObject *Dtool_DCPacker_pack_int_82(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pack_int")) {
    return NULL;
  }
  // 1-inline void DCPacker::pack_int(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).pack_int((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_int(const DCPacker self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pack_int_82_comment =
  "C++ Interface:\n"
  "pack_int(const DCPacker self, int value)\n"
  "\n"
  "/**\n"
  " * Packs the indicated numeric or string value into the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_pack_int_82_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::pack_uint(unsigned int value)
 */
static PyObject *Dtool_DCPacker_pack_uint_83(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pack_uint")) {
    return NULL;
  }
  // 1-inline void DCPacker::pack_uint(unsigned int value)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    (*local_this).pack_uint((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_uint(const DCPacker self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pack_uint_83_comment =
  "C++ Interface:\n"
  "pack_uint(const DCPacker self, int value)\n"
  "\n"
  "/**\n"
  " * Packs the indicated numeric or string value into the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_pack_uint_83_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::pack_int64(int64_t value)
 */
static PyObject *Dtool_DCPacker_pack_int64_84(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pack_int64")) {
    return NULL;
  }
  // 1-inline void DCPacker::pack_int64(int64_t value)
  PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "L:pack_int64", &param1)) {
    (*local_this).pack_int64((int64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_int64(const DCPacker self, long value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pack_int64_84_comment =
  "C++ Interface:\n"
  "pack_int64(const DCPacker self, long value)\n"
  "\n"
  "/**\n"
  " * Packs the indicated numeric or string value into the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_pack_int64_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::pack_uint64(uint64_t value)
 */
static PyObject *Dtool_DCPacker_pack_uint64_85(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pack_uint64")) {
    return NULL;
  }
  // 1-inline void DCPacker::pack_uint64(uint64_t value)
  unsigned PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "K:pack_uint64", &param1)) {
    (*local_this).pack_uint64((uint64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_uint64(const DCPacker self, long value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pack_uint64_85_comment =
  "C++ Interface:\n"
  "pack_uint64(const DCPacker self, long value)\n"
  "\n"
  "/**\n"
  " * Packs the indicated numeric or string value into the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_pack_uint64_85_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::pack_string(std::string const &value)
 */
static PyObject *Dtool_DCPacker_pack_string_86(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pack_string")) {
    return NULL;
  }
  // 1-inline void DCPacker::pack_string(std::string const &value)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).pack_string(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_string(const DCPacker self, str value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pack_string_86_comment =
  "C++ Interface:\n"
  "pack_string(const DCPacker self, str value)\n"
  "\n"
  "/**\n"
  " * Packs the indicated numeric or string value into the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_pack_string_86_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::pack_literal_value(std::string const &value)
 */
static PyObject *Dtool_DCPacker_pack_literal_value_87(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pack_literal_value")) {
    return NULL;
  }
  // 1-inline void DCPacker::pack_literal_value(std::string const &value)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).pack_literal_value(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_literal_value(const DCPacker self, str value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pack_literal_value_87_comment =
  "C++ Interface:\n"
  "pack_literal_value(const DCPacker self, str value)\n"
  "\n"
  "/**\n"
  " * Adds the indicated string value into the stream, representing a single pre-\n"
  " * packed field element, or a whole group of field elements at once.\n"
  " */";
#else
static const char *Dtool_DCPacker_pack_literal_value_87_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::pack_default_value(void)
 */
static PyObject *Dtool_DCPacker_pack_default_value_88(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pack_default_value")) {
    return NULL;
  }
  // 1-void DCPacker::pack_default_value(void)
  (*local_this).pack_default_value();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pack_default_value_88_comment =
  "C++ Interface:\n"
  "pack_default_value(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Adds the default value for the current element into the stream.  If no\n"
  " * default has been set for the current element, creates a sensible default.\n"
  " */";
#else
static const char *Dtool_DCPacker_pack_default_value_88_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double DCPacker::unpack_double(void)
 */
static PyObject *Dtool_DCPacker_unpack_double_89(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_double")) {
    return NULL;
  }
  // 1-inline double DCPacker::unpack_double(void)
  double return_value = (*local_this).unpack_double();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_double_89_comment =
  "C++ Interface:\n"
  "unpack_double(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_double_89_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DCPacker::unpack_int(void)
 */
static PyObject *Dtool_DCPacker_unpack_int_90(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_int")) {
    return NULL;
  }
  // 1-inline int DCPacker::unpack_int(void)
  int return_value = (*local_this).unpack_int();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_int_90_comment =
  "C++ Interface:\n"
  "unpack_int(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_int_90_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int DCPacker::unpack_uint(void)
 */
static PyObject *Dtool_DCPacker_unpack_uint_91(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_uint")) {
    return NULL;
  }
  // 1-inline unsigned int DCPacker::unpack_uint(void)
  unsigned int return_value = (*local_this).unpack_uint();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_uint_91_comment =
  "C++ Interface:\n"
  "unpack_uint(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_uint_91_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int64_t DCPacker::unpack_int64(void)
 */
static PyObject *Dtool_DCPacker_unpack_int64_92(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_int64")) {
    return NULL;
  }
  // 1-inline int64_t DCPacker::unpack_int64(void)
  int64_t return_value = (*local_this).unpack_int64();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_int64_92_comment =
  "C++ Interface:\n"
  "unpack_int64(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_int64_92_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint64_t DCPacker::unpack_uint64(void)
 */
static PyObject *Dtool_DCPacker_unpack_uint64_93(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_uint64")) {
    return NULL;
  }
  // 1-inline uint64_t DCPacker::unpack_uint64(void)
  uint64_t return_value = (*local_this).unpack_uint64();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_uint64_93_comment =
  "C++ Interface:\n"
  "unpack_uint64(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_uint64_93_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string DCPacker::unpack_string(void)
 */
static PyObject *Dtool_DCPacker_unpack_string_94(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_string")) {
    return NULL;
  }
  // 1-inline std::string DCPacker::unpack_string(void)
  std::string return_value = (*local_this).unpack_string();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_string_94_comment =
  "C++ Interface:\n"
  "unpack_string(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_string_94_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string DCPacker::unpack_literal_value(void)
 */
static PyObject *Dtool_DCPacker_unpack_literal_value_95(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_literal_value")) {
    return NULL;
  }
  // 1-inline std::string DCPacker::unpack_literal_value(void)
  std::string return_value = (*local_this).unpack_literal_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_literal_value_95_comment =
  "C++ Interface:\n"
  "unpack_literal_value(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the literal string that represents the packed value of the current\n"
  " * field, and advances the field pointer.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the literal string that represents the packed value of the current\n"
  " * field, and advances the field pointer.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_literal_value_95_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::unpack_validate(void)
 */
static PyObject *Dtool_DCPacker_unpack_validate_96(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_validate")) {
    return NULL;
  }
  // 1-void DCPacker::unpack_validate(void)
  (*local_this).unpack_validate();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_validate_96_comment =
  "C++ Interface:\n"
  "unpack_validate(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Internally unpacks the current numeric or string value and validates it\n"
  " * against the type range limits, but does not return the value.  If the\n"
  " * current field contains nested fields, validates all of them.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_validate_96_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::unpack_skip(void)
 */
static PyObject *Dtool_DCPacker_unpack_skip_97(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_skip")) {
    return NULL;
  }
  // 1-void DCPacker::unpack_skip(void)
  (*local_this).unpack_skip();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_skip_97_comment =
  "C++ Interface:\n"
  "unpack_skip(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Skips the current field without unpacking it and advances to the next\n"
  " * field.  If the current field contains nested fields, skips all of them.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_skip_97_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::pack_object(PyObject *object)
 */
static PyObject *Dtool_DCPacker_pack_object_98(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pack_object")) {
    return NULL;
  }
  // 1-void DCPacker::pack_object(PyObject *object)
  (*local_this).pack_object(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_object(const DCPacker self, object object)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pack_object_98_comment =
  "C++ Interface:\n"
  "pack_object(const DCPacker self, object object)\n"
  "\n"
  "/**\n"
  " * Packs the Python object of whatever type into the packer.  Each numeric\n"
  " * object and string object maps to the corresponding pack_value() call; a\n"
  " * tuple or sequence maps to a push() followed by all of the tuple's contents\n"
  " * followed by a pop().\n"
  " */";
#else
static const char *Dtool_DCPacker_pack_object_98_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *DCPacker::unpack_object(void)
 */
static PyObject *Dtool_DCPacker_unpack_object_99(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_object")) {
    return NULL;
  }
  // 1-PyObject *DCPacker::unpack_object(void)
  PyObject *return_value = (*local_this).unpack_object();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_object_99_comment =
  "C++ Interface:\n"
  "unpack_object(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks a Python object of the appropriate type from the stream for the\n"
  " * current field.  This may be an integer or a string for a simple field\n"
  " * object; if the current field represents a list of fields it will be a\n"
  " * tuple.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_object_99_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCPacker::parse_and_pack(istream &in)
 * bool DCPacker::parse_and_pack(std::string const &formatted_object)
 */
static PyObject *Dtool_DCPacker_parse_and_pack_100(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.parse_and_pack")) {
    return NULL;
  }
  {
    // -2 bool DCPacker::parse_and_pack(istream &in)
    istream *arg_this = (istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_istream, 1, "DCPacker.parse_and_pack", false, false);
    if (arg_this != NULL) {
      bool return_value = (*local_this).parse_and_pack(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool DCPacker::parse_and_pack(std::string const &formatted_object)
    char *param1_str = NULL;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      bool return_value = (*local_this).parse_and_pack(std::string(param1_str, param1_len));
      return Dtool_Return_Bool(return_value);
    }
    PyErr_Clear();
  }

  // No coercion possible: bool DCPacker::parse_and_pack(istream &in)
  // No coercion possible: bool DCPacker::parse_and_pack(std::string const &formatted_object)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "parse_and_pack(const DCPacker self, istream in)\n"
      "parse_and_pack(const DCPacker self, str formatted_object)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_parse_and_pack_100_comment =
  "C++ Interface:\n"
  "parse_and_pack(const DCPacker self, istream in)\n"
  "parse_and_pack(const DCPacker self, str formatted_object)\n"
  "\n"
  "/**\n"
  " * Parses an object's value according to the DC file syntax (e.g.  as a\n"
  " * default value string) and packs it.  Returns true on success, false on a\n"
  " * parse error.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Parses an object's value according to the DC file syntax (e.g.  as a\n"
  " * default value string) and packs it.  Returns true on success, false on a\n"
  " * parse error.\n"
  " */";
#else
static const char *Dtool_DCPacker_parse_and_pack_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string DCPacker::unpack_and_format(bool show_field_names = true)
 * void DCPacker::unpack_and_format(ostream &out, bool show_field_names = true)
 */
static PyObject *Dtool_DCPacker_unpack_and_format_101(PyObject *self, PyObject *args, PyObject *kwds) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_and_format")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-std::string DCPacker::unpack_and_format(bool show_field_names)
      std::string return_value = (*local_this).unpack_and_format();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 void DCPacker::unpack_and_format(ostream &out, bool show_field_names = true)
        PyObject *param1;
        PyObject *param2 = Py_True;
        static const char *keyword_list[] = {"out", "show_field_names", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:unpack_and_format", (char **)keyword_list, &param1, &param2)) {
          ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "DCPacker.unpack_and_format", false, false);
          if (param1_this != NULL) {
            (*local_this).unpack_and_format(*param1_this, (PyObject_IsTrue(param2) != 0));
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 std::string DCPacker::unpack_and_format(bool show_field_names = true)
        PyObject *param1;
        static const char *keyword_list[] = {"show_field_names", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:unpack_and_format", (char **)keyword_list, &param1)) {
          std::string return_value = (*local_this).unpack_and_format((PyObject_IsTrue(param1) != 0));
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
        PyErr_Clear();
      }

      // No coercion possible: void DCPacker::unpack_and_format(ostream &out, bool show_field_names = true)
      // No coercion possible: std::string DCPacker::unpack_and_format(bool show_field_names = true)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "unpack_and_format() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unpack_and_format(const DCPacker self)\n"
      "unpack_and_format(const DCPacker self, ostream out, bool show_field_names)\n"
      "unpack_and_format(const DCPacker self, bool show_field_names)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_and_format_101_comment =
  "C++ Interface:\n"
  "unpack_and_format(const DCPacker self)\n"
  "unpack_and_format(const DCPacker self, ostream out, bool show_field_names)\n"
  "unpack_and_format(const DCPacker self, bool show_field_names)\n"
  "\n"
  "/**\n"
  " * Unpacks an object and formats its value into a syntax suitable for parsing\n"
  " * in the dc file (e.g.  as a default value), or as an input to parse_object.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks an object and formats its value into a syntax suitable for parsing\n"
  " * in the dc file (e.g.  as a default value), or as an input to parse_object.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_and_format_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCPacker::had_parse_error(void) const
 */
static PyObject *Dtool_DCPacker_had_parse_error_102(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPacker, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCPacker::had_parse_error(void) const
  bool return_value = (*(const DCPacker*)local_this).had_parse_error();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_had_parse_error_102_comment =
  "C++ Interface:\n"
  "had_parse_error(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns true if there has been an parse error since the most recent call to\n"
  " * begin(); this can only happen if you call parse_and_pack().\n"
  " */";
#else
static const char *Dtool_DCPacker_had_parse_error_102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCPacker::had_pack_error(void) const
 */
static PyObject *Dtool_DCPacker_had_pack_error_103(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPacker, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCPacker::had_pack_error(void) const
  bool return_value = (*(const DCPacker*)local_this).had_pack_error();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_had_pack_error_103_comment =
  "C++ Interface:\n"
  "had_pack_error(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns true if there has been an packing error since the most recent call\n"
  " * to begin(); in particular, this may be called after end() has returned\n"
  " * false to determine the nature of the failure.\n"
  " *\n"
  " * A return value of true indicates there was a push/pop mismatch, or the\n"
  " * push/pop structure did not match the data structure, or there were the\n"
  " * wrong number of elements in a nested push/pop structure, or on unpack that\n"
  " * the data stream was truncated.\n"
  " */";
#else
static const char *Dtool_DCPacker_had_pack_error_103_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCPacker::had_range_error(void) const
 */
static PyObject *Dtool_DCPacker_had_range_error_104(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPacker, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCPacker::had_range_error(void) const
  bool return_value = (*(const DCPacker*)local_this).had_range_error();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_had_range_error_104_comment =
  "C++ Interface:\n"
  "had_range_error(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns true if there has been an range validation error since the most\n"
  " * recent call to begin(); in particular, this may be called after end() has\n"
  " * returned false to determine the nature of the failure.\n"
  " *\n"
  " * A return value of true indicates a value that was packed or unpacked did\n"
  " * not fit within the specified legal range for a parameter, or within the\n"
  " * limits of the field size.\n"
  " */";
#else
static const char *Dtool_DCPacker_had_range_error_104_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCPacker::had_error(void) const
 */
static PyObject *Dtool_DCPacker_had_error_105(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPacker, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCPacker::had_error(void) const
  bool return_value = (*(const DCPacker*)local_this).had_error();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_had_error_105_comment =
  "C++ Interface:\n"
  "had_error(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns true if there has been any error (either a pack error or a range\n"
  " * error) since the most recent call to begin().  If this returns true, then\n"
  " * the matching call to end() will indicate an error (false).\n"
  " */";
#else
static const char *Dtool_DCPacker_had_error_105_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t DCPacker::get_num_unpacked_bytes(void) const
 */
static PyObject *Dtool_DCPacker_get_num_unpacked_bytes_106(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPacker, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t DCPacker::get_num_unpacked_bytes(void) const
  std::size_t return_value = (*(const DCPacker*)local_this).get_num_unpacked_bytes();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_num_unpacked_bytes_106_comment =
  "C++ Interface:\n"
  "get_num_unpacked_bytes(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes that have been unpacked so far, or after\n"
  " * unpack_end(), the total number of bytes that were unpacked at all.  This\n"
  " * can be used to validate that all of the bytes in the buffer were actually\n"
  " * unpacked (which is not otherwise considered an error).\n"
  " */";
#else
static const char *Dtool_DCPacker_get_num_unpacked_bytes_106_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t DCPacker::get_length(void) const
 */
static PyObject *Dtool_DCPacker_get_length_107(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPacker, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t DCPacker::get_length(void) const
  std::size_t return_value = (*(const DCPacker*)local_this).get_length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_length_107_comment =
  "C++ Interface:\n"
  "get_length(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the current length of the buffer.  This is the number of useful\n"
  " * bytes stored in the buffer, not the amount of memory it takes up.\n"
  " */";
#else
static const char *Dtool_DCPacker_get_length_107_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string DCPacker::get_string(void) const
 */
static PyObject *Dtool_DCPacker_get_string_108(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPacker, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string DCPacker::get_string(void) const
  std::string return_value = (*(const DCPacker*)local_this).get_string();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_string_108_comment =
  "C++ Interface:\n"
  "get_string(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the packed data buffer as a string.  Also see get_data().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Copies the packed data into the indicated string.  Also see get_data().\n"
  " */";
#else
static const char *Dtool_DCPacker_get_string_108_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t DCPacker::get_unpack_length(void) const
 */
static PyObject *Dtool_DCPacker_get_unpack_length_109(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPacker, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t DCPacker::get_unpack_length(void) const
  std::size_t return_value = (*(const DCPacker*)local_this).get_unpack_length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_unpack_length_109_comment =
  "C++ Interface:\n"
  "get_unpack_length(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes in the unpack data buffer.  This is the\n"
  " * buffer used when unpacking; it is separate from the pack data returned by\n"
  " * get_length(), which is filled during packing.\n"
  " */";
#else
static const char *Dtool_DCPacker_get_unpack_length_109_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string DCPacker::get_unpack_string(void) const
 */
static PyObject *Dtool_DCPacker_get_unpack_string_110(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCPacker, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string DCPacker::get_unpack_string(void) const
  std::string return_value = (*(const DCPacker*)local_this).get_unpack_string();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_unpack_string_110_comment =
  "C++ Interface:\n"
  "get_unpack_string(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the unpack data buffer, as a string.  This is the buffer used when\n"
  " * unpacking; it is separate from the pack data returned by get_string(),\n"
  " * which is filled during packing.  Also see get_unpack_data().\n"
  " */";
#else
static const char *Dtool_DCPacker_get_unpack_string_110_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline int DCPacker::get_num_stack_elements_ever_allocated(void)
 */
static PyObject *Dtool_DCPacker_get_num_stack_elements_ever_allocated_111(PyObject *, PyObject *) {
  // 1-static inline int DCPacker::get_num_stack_elements_ever_allocated(void)
  int return_value = DCPacker::get_num_stack_elements_ever_allocated();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_num_stack_elements_ever_allocated_111_comment =
  "C++ Interface:\n"
  "get_num_stack_elements_ever_allocated()\n"
  "\n"
  "/**\n"
  " * Returns the number of DCPacker::StackElement pointers ever simultaneously\n"
  " * allocated; these are now either in active use or have been recycled into\n"
  " * the deleted DCPacker::StackElement pool to be used again.\n"
  " */";
#else
static const char *Dtool_DCPacker_get_num_stack_elements_ever_allocated_111_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_int8(int value)
 */
static PyObject *Dtool_DCPacker_raw_pack_int8_112(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_int8")) {
    return NULL;
  }
  // 1-inline void DCPacker::raw_pack_int8(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).raw_pack_int8((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_int8(const DCPacker self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_int8_112_comment =
  "C++ Interface:\n"
  "raw_pack_int8(const DCPacker self, int value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_int8_112_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_int16(int value)
 */
static PyObject *Dtool_DCPacker_raw_pack_int16_113(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_int16")) {
    return NULL;
  }
  // 1-inline void DCPacker::raw_pack_int16(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).raw_pack_int16((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_int16(const DCPacker self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_int16_113_comment =
  "C++ Interface:\n"
  "raw_pack_int16(const DCPacker self, int value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_int16_113_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_int32(int value)
 */
static PyObject *Dtool_DCPacker_raw_pack_int32_114(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_int32")) {
    return NULL;
  }
  // 1-inline void DCPacker::raw_pack_int32(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).raw_pack_int32((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_int32(const DCPacker self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_int32_114_comment =
  "C++ Interface:\n"
  "raw_pack_int32(const DCPacker self, int value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_int32_114_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_int64(int64_t value)
 */
static PyObject *Dtool_DCPacker_raw_pack_int64_115(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_int64")) {
    return NULL;
  }
  // 1-inline void DCPacker::raw_pack_int64(int64_t value)
  PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "L:raw_pack_int64", &param1)) {
    (*local_this).raw_pack_int64((int64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_int64(const DCPacker self, long value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_int64_115_comment =
  "C++ Interface:\n"
  "raw_pack_int64(const DCPacker self, long value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_int64_115_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_uint8(unsigned int value)
 */
static PyObject *Dtool_DCPacker_raw_pack_uint8_116(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_uint8")) {
    return NULL;
  }
  // 1-inline void DCPacker::raw_pack_uint8(unsigned int value)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    (*local_this).raw_pack_uint8((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_uint8(const DCPacker self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_uint8_116_comment =
  "C++ Interface:\n"
  "raw_pack_uint8(const DCPacker self, int value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_uint8_116_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_uint16(unsigned int value)
 */
static PyObject *Dtool_DCPacker_raw_pack_uint16_117(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_uint16")) {
    return NULL;
  }
  // 1-inline void DCPacker::raw_pack_uint16(unsigned int value)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    (*local_this).raw_pack_uint16((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_uint16(const DCPacker self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_uint16_117_comment =
  "C++ Interface:\n"
  "raw_pack_uint16(const DCPacker self, int value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_uint16_117_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_uint32(unsigned int value)
 */
static PyObject *Dtool_DCPacker_raw_pack_uint32_118(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_uint32")) {
    return NULL;
  }
  // 1-inline void DCPacker::raw_pack_uint32(unsigned int value)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    (*local_this).raw_pack_uint32((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_uint32(const DCPacker self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_uint32_118_comment =
  "C++ Interface:\n"
  "raw_pack_uint32(const DCPacker self, int value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_uint32_118_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_uint64(uint64_t value)
 */
static PyObject *Dtool_DCPacker_raw_pack_uint64_119(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_uint64")) {
    return NULL;
  }
  // 1-inline void DCPacker::raw_pack_uint64(uint64_t value)
  unsigned PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "K:raw_pack_uint64", &param1)) {
    (*local_this).raw_pack_uint64((uint64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_uint64(const DCPacker self, long value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_uint64_119_comment =
  "C++ Interface:\n"
  "raw_pack_uint64(const DCPacker self, long value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_uint64_119_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_float64(double value)
 */
static PyObject *Dtool_DCPacker_raw_pack_float64_120(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_float64")) {
    return NULL;
  }
  // 1-inline void DCPacker::raw_pack_float64(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).raw_pack_float64(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_float64(const DCPacker self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_float64_120_comment =
  "C++ Interface:\n"
  "raw_pack_float64(const DCPacker self, double value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_float64_120_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_string(std::string const &value)
 */
static PyObject *Dtool_DCPacker_raw_pack_string_121(PyObject *self, PyObject *arg) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_string")) {
    return NULL;
  }
  // 1-inline void DCPacker::raw_pack_string(std::string const &value)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).raw_pack_string(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_string(const DCPacker self, str value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_string_121_comment =
  "C++ Interface:\n"
  "raw_pack_string(const DCPacker self, str value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_string_121_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DCPacker::raw_unpack_int8(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_int8_122(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_int8")) {
    return NULL;
  }
  // 1-inline int DCPacker::raw_unpack_int8(void)
  int return_value = (*local_this).raw_unpack_int8();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_int8_122_comment =
  "C++ Interface:\n"
  "raw_unpack_int8(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_int8_122_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DCPacker::raw_unpack_int16(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_int16_123(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_int16")) {
    return NULL;
  }
  // 1-inline int DCPacker::raw_unpack_int16(void)
  int return_value = (*local_this).raw_unpack_int16();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_int16_123_comment =
  "C++ Interface:\n"
  "raw_unpack_int16(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_int16_123_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DCPacker::raw_unpack_int32(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_int32_124(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_int32")) {
    return NULL;
  }
  // 1-inline int DCPacker::raw_unpack_int32(void)
  int return_value = (*local_this).raw_unpack_int32();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_int32_124_comment =
  "C++ Interface:\n"
  "raw_unpack_int32(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_int32_124_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int64_t DCPacker::raw_unpack_int64(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_int64_125(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_int64")) {
    return NULL;
  }
  // 1-inline int64_t DCPacker::raw_unpack_int64(void)
  int64_t return_value = (*local_this).raw_unpack_int64();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_int64_125_comment =
  "C++ Interface:\n"
  "raw_unpack_int64(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_int64_125_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int DCPacker::raw_unpack_uint8(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_uint8_126(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_uint8")) {
    return NULL;
  }
  // 1-inline unsigned int DCPacker::raw_unpack_uint8(void)
  unsigned int return_value = (*local_this).raw_unpack_uint8();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_uint8_126_comment =
  "C++ Interface:\n"
  "raw_unpack_uint8(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_uint8_126_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int DCPacker::raw_unpack_uint16(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_uint16_127(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_uint16")) {
    return NULL;
  }
  // 1-inline unsigned int DCPacker::raw_unpack_uint16(void)
  unsigned int return_value = (*local_this).raw_unpack_uint16();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_uint16_127_comment =
  "C++ Interface:\n"
  "raw_unpack_uint16(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_uint16_127_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int DCPacker::raw_unpack_uint32(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_uint32_128(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_uint32")) {
    return NULL;
  }
  // 1-inline unsigned int DCPacker::raw_unpack_uint32(void)
  unsigned int return_value = (*local_this).raw_unpack_uint32();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_uint32_128_comment =
  "C++ Interface:\n"
  "raw_unpack_uint32(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_uint32_128_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint64_t DCPacker::raw_unpack_uint64(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_uint64_129(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_uint64")) {
    return NULL;
  }
  // 1-inline uint64_t DCPacker::raw_unpack_uint64(void)
  uint64_t return_value = (*local_this).raw_unpack_uint64();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_uint64_129_comment =
  "C++ Interface:\n"
  "raw_unpack_uint64(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_uint64_129_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double DCPacker::raw_unpack_float64(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_float64_130(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_float64")) {
    return NULL;
  }
  // 1-inline double DCPacker::raw_unpack_float64(void)
  double return_value = (*local_this).raw_unpack_float64();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_float64_130_comment =
  "C++ Interface:\n"
  "raw_unpack_float64(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_float64_130_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string DCPacker::raw_unpack_string(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_string_131(PyObject *self, PyObject *) {
  DCPacker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_string")) {
    return NULL;
  }
  // 1-inline std::string DCPacker::raw_unpack_string(void)
  std::string return_value = (*local_this).raw_unpack_string();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_string_131_comment =
  "C++ Interface:\n"
  "raw_unpack_string(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_string_131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCPacker::DCPacker(void)
 * inline DCPacker::DCPacker(DCPacker const &) = default
 */
static int Dtool_Init_DCPacker(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-DCPacker::DCPacker(void)
      DCPacker *return_value = new DCPacker();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DCPacker, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline DCPacker::DCPacker(DCPacker const &) = default
      DCPacker const *arg_this = (DCPacker *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DCPacker, 0, "DCPacker.DCPacker", true, true);
      if (arg_this != NULL) {
        DCPacker *return_value = new DCPacker(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DCPacker, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DCPacker() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DCPacker()\n"
      "DCPacker(const DCPacker param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DCPacker(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DCPacker) {
    printf("DCPacker ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DCPacker *local_this = (DCPacker *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DCPacker) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DCPacker(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DCPacker) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DCParameter
 */
/**
 * Python function wrapper for:
 * virtual DCSimpleParameter *DCParameter::as_simple_parameter(void)
 * virtual DCSimpleParameter const *DCParameter::as_simple_parameter(void) const
 */
static PyObject *Dtool_DCParameter_as_simple_parameter_133(PyObject *self, PyObject *) {
  DCParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCParameter, (void **)&local_this)) {
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 virtual DCSimpleParameter *DCParameter::as_simple_parameter(void)
    DCSimpleParameter *return_value = (*local_this).as_simple_parameter();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCSimpleParameter, false, false);
  }

  {
    // -2 virtual DCSimpleParameter const *DCParameter::as_simple_parameter(void) const
    DCSimpleParameter const *return_value = (*(const DCParameter*)local_this).as_simple_parameter();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCSimpleParameter, false, true);
  }

  // No coercion possible: virtual DCSimpleParameter *DCParameter::as_simple_parameter(void)
  // No coercion possible: virtual DCSimpleParameter const *DCParameter::as_simple_parameter(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCParameter_as_simple_parameter_133_comment =
  "C++ Interface:\n"
  "as_simple_parameter(const DCParameter self)\n"
  "as_simple_parameter(DCParameter self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DCParameter_as_simple_parameter_133_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual DCArrayParameter *DCParameter::as_array_parameter(void)
 * virtual DCArrayParameter const *DCParameter::as_array_parameter(void) const
 */
static PyObject *Dtool_DCParameter_as_array_parameter_134(PyObject *self, PyObject *) {
  DCParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCParameter, (void **)&local_this)) {
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 virtual DCArrayParameter *DCParameter::as_array_parameter(void)
    DCArrayParameter *return_value = (*local_this).as_array_parameter();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCArrayParameter, false, false);
  }

  {
    // -2 virtual DCArrayParameter const *DCParameter::as_array_parameter(void) const
    DCArrayParameter const *return_value = (*(const DCParameter*)local_this).as_array_parameter();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCArrayParameter, false, true);
  }

  // No coercion possible: virtual DCArrayParameter *DCParameter::as_array_parameter(void)
  // No coercion possible: virtual DCArrayParameter const *DCParameter::as_array_parameter(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCParameter_as_array_parameter_134_comment =
  "C++ Interface:\n"
  "as_array_parameter(const DCParameter self)\n"
  "as_array_parameter(DCParameter self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DCParameter_as_array_parameter_134_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual DCParameter *DCParameter::make_copy(void) const = 0
 */
static PyObject *Dtool_DCParameter_make_copy_135(PyObject *self, PyObject *) {
  DCParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual DCParameter *DCParameter::make_copy(void) const = 0
  DCParameter *return_value = (*(const DCParameter*)local_this).make_copy();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCParameter, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCParameter_make_copy_135_comment =
  "C++ Interface:\n"
  "make_copy(DCParameter self)\n";
#else
static const char *Dtool_DCParameter_make_copy_135_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool DCParameter::is_valid(void) const = 0
 */
static PyObject *Dtool_DCParameter_is_valid_136(PyObject *self, PyObject *) {
  DCParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool DCParameter::is_valid(void) const = 0
  bool return_value = (*(const DCParameter*)local_this).is_valid();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCParameter_is_valid_136_comment =
  "C++ Interface:\n"
  "is_valid(DCParameter self)\n";
#else
static const char *Dtool_DCParameter_is_valid_136_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCTypedef const *DCParameter::get_typedef(void) const
 */
static PyObject *Dtool_DCParameter_get_typedef_137(PyObject *self, PyObject *) {
  DCParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCTypedef const *DCParameter::get_typedef(void) const
  DCTypedef const *return_value = (*(const DCParameter*)local_this).get_typedef();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCTypedef, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DCParameter_get_typedef_137_comment =
  "C++ Interface:\n"
  "get_typedef(DCParameter self)\n"
  "\n"
  "/**\n"
  " * If this type has been referenced from a typedef, returns the DCTypedef\n"
  " * instance, or NULL if the type was declared on-the-fly.\n"
  " */";
#else
static const char *Dtool_DCParameter_get_typedef_137_comment = NULL;
#endif

static int Dtool_Init_DCParameter(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCParameter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DCParameter) {
    printf("DCParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DCParameter *local_this = (DCParameter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DCParameter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCField) {
    return (DCField *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCKeywordList) {
    return (DCKeywordList *)(DCField *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCPackerInterface) {
    return (DCPackerInterface *)(DCField *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DCParameter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DCParameter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCField) {
    DCField* other_this = (DCField*)from_this;
    return (DCParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCKeywordList) {
    DCKeywordList* other_this = (DCKeywordList*)from_this;
    return (DCParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCPackerInterface) {
    DCPackerInterface* other_this = (DCPackerInterface*)from_this;
    return (DCParameter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DCArrayParameter
 */
/**
 * Python function wrapper for:
 * DCParameter *DCArrayParameter::get_element_type(void) const
 */
static PyObject *Dtool_DCArrayParameter_get_element_type_139(PyObject *self, PyObject *) {
  DCArrayParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCArrayParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCParameter *DCArrayParameter::get_element_type(void) const
  DCParameter *return_value = (*(const DCArrayParameter*)local_this).get_element_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCParameter, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCArrayParameter_get_element_type_139_comment =
  "C++ Interface:\n"
  "get_element_type(DCArrayParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the type of the individual elements of this array.\n"
  " */";
#else
static const char *Dtool_DCArrayParameter_get_element_type_139_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DCArrayParameter::get_array_size(void) const
 */
static PyObject *Dtool_DCArrayParameter_get_array_size_140(PyObject *self, PyObject *) {
  DCArrayParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCArrayParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DCArrayParameter::get_array_size(void) const
  int return_value = (*(const DCArrayParameter*)local_this).get_array_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCArrayParameter_get_array_size_140_comment =
  "C++ Interface:\n"
  "get_array_size(DCArrayParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the fixed number of elements in this array, or -1 if the array may\n"
  " * contain a variable number of elements.\n"
  " */";
#else
static const char *Dtool_DCArrayParameter_get_array_size_140_comment = NULL;
#endif

static int Dtool_Init_DCArrayParameter(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCArrayParameter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DCArrayParameter) {
    printf("DCArrayParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DCArrayParameter *local_this = (DCArrayParameter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DCArrayParameter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCField) {
    return (DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCKeywordList) {
    return (DCKeywordList *)(DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCPackerInterface) {
    return (DCPackerInterface *)(DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCParameter) {
    return (DCParameter *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DCArrayParameter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DCArrayParameter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCField) {
    DCField* other_this = (DCField*)from_this;
    return (DCArrayParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCKeywordList) {
    DCKeywordList* other_this = (DCKeywordList*)from_this;
    return (DCArrayParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCPackerInterface) {
    DCPackerInterface* other_this = (DCPackerInterface*)from_this;
    return (DCArrayParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCParameter) {
    DCParameter* other_this = (DCParameter*)from_this;
    return (DCArrayParameter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DCAtomicField
 */
/**
 * Python function wrapper for:
 * int DCAtomicField::get_num_elements(void) const
 */
static PyObject *Dtool_DCAtomicField_get_num_elements_142(PyObject *self, PyObject *) {
  DCAtomicField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCAtomicField, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DCAtomicField::get_num_elements(void) const
  int return_value = (*(const DCAtomicField*)local_this).get_num_elements();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCAtomicField_get_num_elements_142_comment =
  "C++ Interface:\n"
  "get_num_elements(DCAtomicField self)\n"
  "\n"
  "/**\n"
  " * Returns the number of elements (parameters) of the atomic field.\n"
  " */";
#else
static const char *Dtool_DCAtomicField_get_num_elements_142_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCParameter *DCAtomicField::get_element(int n) const
 */
static PyObject *Dtool_DCAtomicField_get_element_143(PyObject *self, PyObject *arg) {
  DCAtomicField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCAtomicField, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCParameter *DCAtomicField::get_element(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCParameter *return_value = (*(const DCAtomicField*)local_this).get_element((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCParameter, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(DCAtomicField self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCAtomicField_get_element_143_comment =
  "C++ Interface:\n"
  "get_element(DCAtomicField self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the parameter object describing the nth element.\n"
  " */";
#else
static const char *Dtool_DCAtomicField_get_element_143_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string DCAtomicField::get_element_default(int n) const
 */
static PyObject *Dtool_DCAtomicField_get_element_default_144(PyObject *self, PyObject *arg) {
  DCAtomicField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCAtomicField, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string DCAtomicField::get_element_default(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (*(const DCAtomicField*)local_this).get_element_default((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element_default(DCAtomicField self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCAtomicField_get_element_default_144_comment =
  "C++ Interface:\n"
  "get_element_default(DCAtomicField self, int n)\n"
  "\n"
  "// These five methods are deprecated and will be removed soon.\n"
  "\n"
  "/**\n"
  " * Returns the pre-formatted default value associated with the nth element of\n"
  " * the field.  This is only valid if has_element_default() returns true, in\n"
  " * which case this string represents the bytes that should be assigned to the\n"
  " * field as a default value.\n"
  " *\n"
  " * If the element is an array-type element, the returned value will include\n"
  " * the two-byte length preceding the array data.\n"
  " *\n"
  " * This is deprecated; use get_element() instead.\n"
  " */";
#else
static const char *Dtool_DCAtomicField_get_element_default_144_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCAtomicField::has_element_default(int n) const
 */
static PyObject *Dtool_DCAtomicField_has_element_default_145(PyObject *self, PyObject *arg) {
  DCAtomicField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCAtomicField, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool DCAtomicField::has_element_default(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const DCAtomicField*)local_this).has_element_default((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_element_default(DCAtomicField self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCAtomicField_has_element_default_145_comment =
  "C++ Interface:\n"
  "has_element_default(DCAtomicField self, int n)\n"
  "\n"
  "/**\n"
  " * Returns true if the nth element of the field has a default value specified,\n"
  " * false otherwise.\n"
  " *\n"
  " * This is deprecated; use get_element() instead.\n"
  " */";
#else
static const char *Dtool_DCAtomicField_has_element_default_145_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string DCAtomicField::get_element_name(int n) const
 */
static PyObject *Dtool_DCAtomicField_get_element_name_146(PyObject *self, PyObject *arg) {
  DCAtomicField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCAtomicField, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string DCAtomicField::get_element_name(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (*(const DCAtomicField*)local_this).get_element_name((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element_name(DCAtomicField self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCAtomicField_get_element_name_146_comment =
  "C++ Interface:\n"
  "get_element_name(DCAtomicField self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the name of the nth element of the field.  This name is strictly\n"
  " * for documentary purposes; it does not generally affect operation.  If a\n"
  " * name is not specified, this will be the empty string.\n"
  " *\n"
  " * This method is deprecated; use get_element()->get_name() instead.\n"
  " */";
#else
static const char *Dtool_DCAtomicField_get_element_name_146_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCSubatomicType DCAtomicField::get_element_type(int n) const
 */
static PyObject *Dtool_DCAtomicField_get_element_type_147(PyObject *self, PyObject *arg) {
  DCAtomicField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCAtomicField, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCSubatomicType DCAtomicField::get_element_type(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCSubatomicType return_value = (*(const DCAtomicField*)local_this).get_element_type((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element_type(DCAtomicField self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCAtomicField_get_element_type_147_comment =
  "C++ Interface:\n"
  "get_element_type(DCAtomicField self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the numeric type of the nth element of the field.  This method is\n"
  " * deprecated; use get_element() instead.\n"
  " */";
#else
static const char *Dtool_DCAtomicField_get_element_type_147_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DCAtomicField::get_element_divisor(int n) const
 */
static PyObject *Dtool_DCAtomicField_get_element_divisor_148(PyObject *self, PyObject *arg) {
  DCAtomicField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCAtomicField, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DCAtomicField::get_element_divisor(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const DCAtomicField*)local_this).get_element_divisor((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element_divisor(DCAtomicField self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCAtomicField_get_element_divisor_148_comment =
  "C++ Interface:\n"
  "get_element_divisor(DCAtomicField self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the divisor associated with the nth element of the field.  This\n"
  " * implements an implicit fixed-point system; floating-point values are to be\n"
  " * multiplied by this value before encoding into a packet, and divided by this\n"
  " * number after decoding.\n"
  " *\n"
  " * This method is deprecated; use get_element()->get_divisor() instead.\n"
  " */";
#else
static const char *Dtool_DCAtomicField_get_element_divisor_148_comment = NULL;
#endif

static int Dtool_Init_DCAtomicField(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCAtomicField(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DCAtomicField) {
    printf("DCAtomicField ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DCAtomicField *local_this = (DCAtomicField *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DCAtomicField) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCField) {
    return (DCField *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCKeywordList) {
    return (DCKeywordList *)(DCField *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCPackerInterface) {
    return (DCPackerInterface *)(DCField *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DCAtomicField(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DCAtomicField) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCField) {
    DCField* other_this = (DCField*)from_this;
    return (DCAtomicField*)other_this;
  }
  if (from_type == Dtool_Ptr_DCKeywordList) {
    DCKeywordList* other_this = (DCKeywordList*)from_this;
    return (DCAtomicField*)other_this;
  }
  if (from_type == Dtool_Ptr_DCPackerInterface) {
    DCPackerInterface* other_this = (DCPackerInterface*)from_this;
    return (DCAtomicField*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DCDeclaration
 */
/**
 * Python function wrapper for:
 * virtual DCClass *DCDeclaration::as_class(void)
 * virtual DCClass const *DCDeclaration::as_class(void) const
 */
static PyObject *Dtool_DCDeclaration_as_class_151(PyObject *self, PyObject *) {
  DCDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCDeclaration, (void **)&local_this)) {
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 virtual DCClass *DCDeclaration::as_class(void)
    DCClass *return_value = (*local_this).as_class();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCClass, false, false);
  }

  {
    // -2 virtual DCClass const *DCDeclaration::as_class(void) const
    DCClass const *return_value = (*(const DCDeclaration*)local_this).as_class();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCClass, false, true);
  }

  // No coercion possible: virtual DCClass *DCDeclaration::as_class(void)
  // No coercion possible: virtual DCClass const *DCDeclaration::as_class(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCDeclaration_as_class_151_comment =
  "C++ Interface:\n"
  "as_class(const DCDeclaration self)\n"
  "as_class(DCDeclaration self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DCDeclaration_as_class_151_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual DCSwitch *DCDeclaration::as_switch(void)
 * virtual DCSwitch const *DCDeclaration::as_switch(void) const
 */
static PyObject *Dtool_DCDeclaration_as_switch_152(PyObject *self, PyObject *) {
  DCDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCDeclaration, (void **)&local_this)) {
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 virtual DCSwitch *DCDeclaration::as_switch(void)
    DCSwitch *return_value = (*local_this).as_switch();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCSwitch, false, false);
  }

  {
    // -2 virtual DCSwitch const *DCDeclaration::as_switch(void) const
    DCSwitch const *return_value = (*(const DCDeclaration*)local_this).as_switch();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCSwitch, false, true);
  }

  // No coercion possible: virtual DCSwitch *DCDeclaration::as_switch(void)
  // No coercion possible: virtual DCSwitch const *DCDeclaration::as_switch(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCDeclaration_as_switch_152_comment =
  "C++ Interface:\n"
  "as_switch(const DCDeclaration self)\n"
  "as_switch(DCDeclaration self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DCDeclaration_as_switch_152_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void DCDeclaration::output(ostream &out) const
 */
static PyObject *Dtool_DCDeclaration_output_153(PyObject *self, PyObject *arg) {
  DCDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCDeclaration, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void DCDeclaration::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "DCDeclaration.output", false, true);
  if (arg_this != NULL) {
    (*(const DCDeclaration*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(DCDeclaration self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCDeclaration_output_153_comment =
  "C++ Interface:\n"
  "output(DCDeclaration self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_DCDeclaration_output_153_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCDeclaration::write(ostream &out, int indent_level) const
 */
static PyObject *Dtool_DCDeclaration_write_154(PyObject *self, PyObject *args, PyObject *kwds) {
  DCDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCDeclaration, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DCDeclaration::write(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "DCDeclaration.write", false, true);
    if (param1_this != NULL) {
      (*(const DCDeclaration*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(DCDeclaration self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCDeclaration_write_154_comment =
  "C++ Interface:\n"
  "write(DCDeclaration self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_DCDeclaration_write_154_comment = NULL;
#endif

static int Dtool_Init_DCDeclaration(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCDeclaration(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DCDeclaration) {
    printf("DCDeclaration ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DCDeclaration *local_this = (DCDeclaration *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DCDeclaration) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DCDeclaration(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DCDeclaration) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DCClass
 */
/**
 * Python function wrapper for:
 * inline DCFile *DCClass::get_dc_file(void) const
 */
static PyObject *Dtool_DCClass_get_dc_file_156(PyObject *self, PyObject *) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline DCFile *DCClass::get_dc_file(void) const
  DCFile *return_value = (*(const DCClass*)local_this).get_dc_file();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCFile, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_dc_file_156_comment =
  "C++ Interface:\n"
  "get_dc_file(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns the DCFile object that contains the class.\n"
  " */";
#else
static const char *Dtool_DCClass_get_dc_file_156_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &DCClass::get_name(void) const
 */
static PyObject *Dtool_DCClass_get_name_157(PyObject *self, PyObject *) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &DCClass::get_name(void) const
  std::string const &return_value = (*(const DCClass*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_name_157_comment =
  "C++ Interface:\n"
  "get_name(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns the name of this class.\n"
  " */";
#else
static const char *Dtool_DCClass_get_name_157_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DCClass::get_number(void) const
 */
static PyObject *Dtool_DCClass_get_number_158(PyObject *self, PyObject *) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DCClass::get_number(void) const
  int return_value = (*(const DCClass*)local_this).get_number();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_number_158_comment =
  "C++ Interface:\n"
  "get_number(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns a unique index number associated with this class.  This is defined\n"
  " * implicitly when the .dc file(s) are read.\n"
  " */";
#else
static const char *Dtool_DCClass_get_number_158_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DCClass::get_num_parents(void) const
 */
static PyObject *Dtool_DCClass_get_num_parents_159(PyObject *self, PyObject *) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DCClass::get_num_parents(void) const
  int return_value = (*(const DCClass*)local_this).get_num_parents();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_num_parents_159_comment =
  "C++ Interface:\n"
  "get_num_parents(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns the number of base classes this class inherits from.\n"
  " */";
#else
static const char *Dtool_DCClass_get_num_parents_159_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCClass *DCClass::get_parent(int n) const
 */
static PyObject *Dtool_DCClass_get_parent_160(PyObject *self, PyObject *arg) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCClass *DCClass::get_parent(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCClass *return_value = (*(const DCClass*)local_this).get_parent((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCClass, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parent(DCClass self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_parent_160_comment =
  "C++ Interface:\n"
  "get_parent(DCClass self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth parent class this class inherits from.\n"
  " */";
#else
static const char *Dtool_DCClass_get_parent_160_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCClass::has_constructor(void) const
 */
static PyObject *Dtool_DCClass_has_constructor_161(PyObject *self, PyObject *) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool DCClass::has_constructor(void) const
  bool return_value = (*(const DCClass*)local_this).has_constructor();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_has_constructor_161_comment =
  "C++ Interface:\n"
  "has_constructor(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns true if this class has a constructor method, false if it just uses\n"
  " * the default constructor.\n"
  " */";
#else
static const char *Dtool_DCClass_has_constructor_161_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCField *DCClass::get_constructor(void) const
 */
static PyObject *Dtool_DCClass_get_constructor_162(PyObject *self, PyObject *) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCField *DCClass::get_constructor(void) const
  DCField *return_value = (*(const DCClass*)local_this).get_constructor();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_constructor_162_comment =
  "C++ Interface:\n"
  "get_constructor(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns the constructor method for this class if it is defined, or NULL if\n"
  " * the class uses the default constructor.\n"
  " */";
#else
static const char *Dtool_DCClass_get_constructor_162_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DCClass::get_num_fields(void) const
 */
static PyObject *Dtool_DCClass_get_num_fields_163(PyObject *self, PyObject *) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DCClass::get_num_fields(void) const
  int return_value = (*(const DCClass*)local_this).get_num_fields();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_num_fields_163_comment =
  "C++ Interface:\n"
  "get_num_fields(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns the number of fields defined directly in this class, ignoring\n"
  " * inheritance.\n"
  " */";
#else
static const char *Dtool_DCClass_get_num_fields_163_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCField *DCClass::get_field(int n) const
 */
static PyObject *Dtool_DCClass_get_field_164(PyObject *self, PyObject *arg) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCField *DCClass::get_field(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCField *return_value = (*(const DCClass*)local_this).get_field((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_field(DCClass self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_field_164_comment =
  "C++ Interface:\n"
  "get_field(DCClass self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth field in the class.  This is not necessarily the field with\n"
  " * index n; this is the nth field defined in the class directly, ignoring\n"
  " * inheritance.\n"
  " */";
#else
static const char *Dtool_DCClass_get_field_164_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCField *DCClass::get_field_by_name(std::string const &name) const
 */
static PyObject *Dtool_DCClass_get_field_by_name_165(PyObject *self, PyObject *arg) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCField *DCClass::get_field_by_name(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    DCField *return_value = (*(const DCClass*)local_this).get_field_by_name(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_field_by_name(DCClass self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_field_by_name_165_comment =
  "C++ Interface:\n"
  "get_field_by_name(DCClass self, str name)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the DCField that shares the indicated name.  If the\n"
  " * named field is not found in the current class, the parent classes will be\n"
  " * searched, so the value returned may not actually be a field within this\n"
  " * class.  Returns NULL if there is no such field defined.\n"
  " */";
#else
static const char *Dtool_DCClass_get_field_by_name_165_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCField *DCClass::get_field_by_index(int index_number) const
 */
static PyObject *Dtool_DCClass_get_field_by_index_166(PyObject *self, PyObject *arg) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCField *DCClass::get_field_by_index(int index_number) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCField *return_value = (*(const DCClass*)local_this).get_field_by_index((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_field_by_index(DCClass self, int index_number)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_field_by_index_166_comment =
  "C++ Interface:\n"
  "get_field_by_index(DCClass self, int index_number)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the DCField that has the indicated index number.  If\n"
  " * the numbered field is not found in the current class, the parent classes\n"
  " * will be searched, so the value returned may not actually be a field within\n"
  " * this class.  Returns NULL if there is no such field defined.\n"
  " */";
#else
static const char *Dtool_DCClass_get_field_by_index_166_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DCClass::get_num_inherited_fields(void) const
 */
static PyObject *Dtool_DCClass_get_num_inherited_fields_167(PyObject *self, PyObject *) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DCClass::get_num_inherited_fields(void) const
  int return_value = (*(const DCClass*)local_this).get_num_inherited_fields();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_num_inherited_fields_167_comment =
  "C++ Interface:\n"
  "get_num_inherited_fields(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of field fields defined in this class and all\n"
  " * ancestor classes.\n"
  " */";
#else
static const char *Dtool_DCClass_get_num_inherited_fields_167_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCField *DCClass::get_inherited_field(int n) const
 */
static PyObject *Dtool_DCClass_get_inherited_field_168(PyObject *self, PyObject *arg) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCField *DCClass::get_inherited_field(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCField *return_value = (*(const DCClass*)local_this).get_inherited_field((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_inherited_field(DCClass self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_inherited_field_168_comment =
  "C++ Interface:\n"
  "get_inherited_field(DCClass self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth field field in the class and all of its ancestors.\n"
  " *\n"
  " * This *used* to be the same thing as get_field_by_index(), back when the\n"
  " * fields were numbered sequentially within a class's inheritance hierarchy.\n"
  " * Now that fields have a globally unique index number, this is no longer\n"
  " * true.\n"
  " */";
#else
static const char *Dtool_DCClass_get_inherited_field_168_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCClass::is_struct(void) const
 */
static PyObject *Dtool_DCClass_is_struct_169(PyObject *self, PyObject *) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCClass::is_struct(void) const
  bool return_value = (*(const DCClass*)local_this).is_struct();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_is_struct_169_comment =
  "C++ Interface:\n"
  "is_struct(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns true if the class has been identified with the \"struct\" keyword in\n"
  " * the dc file, false if it was declared with \"dclass\".\n"
  " */";
#else
static const char *Dtool_DCClass_is_struct_169_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCClass::is_bogus_class(void) const
 */
static PyObject *Dtool_DCClass_is_bogus_class_170(PyObject *self, PyObject *) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCClass::is_bogus_class(void) const
  bool return_value = (*(const DCClass*)local_this).is_bogus_class();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_is_bogus_class_170_comment =
  "C++ Interface:\n"
  "is_bogus_class(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns true if the class has been flagged as a bogus class.  This is set\n"
  " * for classes that are generated by the parser as placeholder for missing\n"
  " * classes, as when reading a partial file; it should not occur in a normal\n"
  " * valid dc file.\n"
  " */";
#else
static const char *Dtool_DCClass_is_bogus_class_170_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCClass::inherits_from_bogus_class(void) const
 */
static PyObject *Dtool_DCClass_inherits_from_bogus_class_171(PyObject *self, PyObject *) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool DCClass::inherits_from_bogus_class(void) const
  bool return_value = (*(const DCClass*)local_this).inherits_from_bogus_class();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_inherits_from_bogus_class_171_comment =
  "C++ Interface:\n"
  "inherits_from_bogus_class(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns true if this class, or any class in the inheritance heirarchy for\n"
  " * this class, is a \"bogus\" class--a forward reference to an as-yet-undefined\n"
  " * class.\n"
  " */";
#else
static const char *Dtool_DCClass_inherits_from_bogus_class_171_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCClass::start_generate(void)
 */
static PyObject *Dtool_DCClass_start_generate_172(PyObject *self, PyObject *) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCClass, (void **)&local_this, "DCClass.start_generate")) {
    return NULL;
  }
  // 1-inline void DCClass::start_generate(void)
  (*local_this).start_generate();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCClass_start_generate_172_comment =
  "C++ Interface:\n"
  "start_generate(const DCClass self)\n"
  "\n"
  "/**\n"
  " * Starts the PStats timer going on the \"generate\" task, that is, marks the\n"
  " * beginning of the process of generating a new object, for the purposes of\n"
  " * timing this process.\n"
  " *\n"
  " * This should balance with a corresponding call to stop_generate().\n"
  " */";
#else
static const char *Dtool_DCClass_start_generate_172_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DCClass::stop_generate(void)
 */
static PyObject *Dtool_DCClass_stop_generate_173(PyObject *self, PyObject *) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCClass, (void **)&local_this, "DCClass.stop_generate")) {
    return NULL;
  }
  // 1-inline void DCClass::stop_generate(void)
  (*local_this).stop_generate();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCClass_stop_generate_173_comment =
  "C++ Interface:\n"
  "stop_generate(const DCClass self)\n"
  "\n"
  "/**\n"
  " * Stops the PStats timer on the \"generate\" task.  This should balance with a\n"
  " * preceding call to start_generate().\n"
  " */";
#else
static const char *Dtool_DCClass_stop_generate_173_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void DCClass::output(ostream &out) const
 */
static PyObject *Dtool_DCClass_output_174(PyObject *self, PyObject *arg) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void DCClass::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "DCClass.output", false, true);
  if (arg_this != NULL) {
    (*(const DCClass*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(DCClass self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_output_174_comment =
  "C++ Interface:\n"
  "output(DCClass self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_DCClass_output_174_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCClass::has_class_def(void) const
 */
static PyObject *Dtool_DCClass_has_class_def_175(PyObject *self, PyObject *) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool DCClass::has_class_def(void) const
  bool return_value = (*(const DCClass*)local_this).has_class_def();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_has_class_def_175_comment =
  "C++ Interface:\n"
  "has_class_def(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns true if the DCClass object has an associated Python class\n"
  " * definition, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCClass_has_class_def_175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCClass::set_class_def(PyObject *class_def)
 */
static PyObject *Dtool_DCClass_set_class_def_176(PyObject *self, PyObject *arg) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCClass, (void **)&local_this, "DCClass.set_class_def")) {
    return NULL;
  }
  // 1-void DCClass::set_class_def(PyObject *class_def)
  (*local_this).set_class_def(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_class_def(const DCClass self, object class_def)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_set_class_def_176_comment =
  "C++ Interface:\n"
  "set_class_def(const DCClass self, object class_def)\n"
  "\n"
  "/**\n"
  " * Sets the class object associated with this DistributedClass.  This object\n"
  " * will be used to construct new instances of the class.\n"
  " */";
#else
static const char *Dtool_DCClass_set_class_def_176_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *DCClass::get_class_def(void) const
 */
static PyObject *Dtool_DCClass_get_class_def_177(PyObject *self, PyObject *) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-PyObject *DCClass::get_class_def(void) const
  PyObject *return_value = (*(const DCClass*)local_this).get_class_def();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_class_def_177_comment =
  "C++ Interface:\n"
  "get_class_def(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns the class object that was previously associated with this\n"
  " * DistributedClass.  This will return a new reference to the object.\n"
  " */";
#else
static const char *Dtool_DCClass_get_class_def_177_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCClass::has_owner_class_def(void) const
 */
static PyObject *Dtool_DCClass_has_owner_class_def_178(PyObject *self, PyObject *) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool DCClass::has_owner_class_def(void) const
  bool return_value = (*(const DCClass*)local_this).has_owner_class_def();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_has_owner_class_def_178_comment =
  "C++ Interface:\n"
  "has_owner_class_def(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns true if the DCClass object has an associated Python owner class\n"
  " * definition, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCClass_has_owner_class_def_178_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCClass::set_owner_class_def(PyObject *owner_class_def)
 */
static PyObject *Dtool_DCClass_set_owner_class_def_179(PyObject *self, PyObject *arg) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCClass, (void **)&local_this, "DCClass.set_owner_class_def")) {
    return NULL;
  }
  // 1-void DCClass::set_owner_class_def(PyObject *owner_class_def)
  (*local_this).set_owner_class_def(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_owner_class_def(const DCClass self, object owner_class_def)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_set_owner_class_def_179_comment =
  "C++ Interface:\n"
  "set_owner_class_def(const DCClass self, object owner_class_def)\n"
  "\n"
  "/**\n"
  " * Sets the owner class object associated with this DistributedClass.  This\n"
  " * object will be used to construct new owner instances of the class.\n"
  " */";
#else
static const char *Dtool_DCClass_set_owner_class_def_179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *DCClass::get_owner_class_def(void) const
 */
static PyObject *Dtool_DCClass_get_owner_class_def_180(PyObject *self, PyObject *) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-PyObject *DCClass::get_owner_class_def(void) const
  PyObject *return_value = (*(const DCClass*)local_this).get_owner_class_def();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_owner_class_def_180_comment =
  "C++ Interface:\n"
  "get_owner_class_def(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns the owner class object that was previously associated with this\n"
  " * DistributedClass.  This will return a new reference to the object.\n"
  " */";
#else
static const char *Dtool_DCClass_get_owner_class_def_180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCClass::receive_update(PyObject *distobj, DatagramIterator &di) const
 */
static PyObject *Dtool_DCClass_receive_update_181(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DCClass::receive_update(PyObject *distobj, DatagramIterator &di) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"distobj", "di", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:receive_update", (char **)keyword_list, &param1, &param2)) {
    DatagramIterator param2_local;
    DatagramIterator *param2_this = Dtool_Coerce_DatagramIterator(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "DCClass.receive_update", "DatagramIterator");
    }
    (*(const DCClass*)local_this).receive_update(param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "receive_update(DCClass self, object distobj, DatagramIterator di)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_receive_update_181_comment =
  "C++ Interface:\n"
  "receive_update(DCClass self, object distobj, DatagramIterator di)\n"
  "\n"
  "/**\n"
  " * Extracts the update message out of the packer and applies it to the\n"
  " * indicated object by calling the appropriate method.\n"
  " */";
#else
static const char *Dtool_DCClass_receive_update_181_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCClass::receive_update_broadcast_required(PyObject *distobj, DatagramIterator &di) const
 */
static PyObject *Dtool_DCClass_receive_update_broadcast_required_182(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DCClass::receive_update_broadcast_required(PyObject *distobj, DatagramIterator &di) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"distobj", "di", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:receive_update_broadcast_required", (char **)keyword_list, &param1, &param2)) {
    DatagramIterator param2_local;
    DatagramIterator *param2_this = Dtool_Coerce_DatagramIterator(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "DCClass.receive_update_broadcast_required", "DatagramIterator");
    }
    (*(const DCClass*)local_this).receive_update_broadcast_required(param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "receive_update_broadcast_required(DCClass self, object distobj, DatagramIterator di)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_receive_update_broadcast_required_182_comment =
  "C++ Interface:\n"
  "receive_update_broadcast_required(DCClass self, object distobj, DatagramIterator di)\n"
  "\n"
  "/**\n"
  " * Processes a big datagram that includes all of the \"required\" fields that\n"
  " * are sent along with a normal \"generate with required\" message.  This is all\n"
  " * of the atomic fields that are marked \"broadcast required\".\n"
  " */";
#else
static const char *Dtool_DCClass_receive_update_broadcast_required_182_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCClass::receive_update_broadcast_required_owner(PyObject *distobj, DatagramIterator &di) const
 */
static PyObject *Dtool_DCClass_receive_update_broadcast_required_owner_183(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DCClass::receive_update_broadcast_required_owner(PyObject *distobj, DatagramIterator &di) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"distobj", "di", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:receive_update_broadcast_required_owner", (char **)keyword_list, &param1, &param2)) {
    DatagramIterator param2_local;
    DatagramIterator *param2_this = Dtool_Coerce_DatagramIterator(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "DCClass.receive_update_broadcast_required_owner", "DatagramIterator");
    }
    (*(const DCClass*)local_this).receive_update_broadcast_required_owner(param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "receive_update_broadcast_required_owner(DCClass self, object distobj, DatagramIterator di)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_receive_update_broadcast_required_owner_183_comment =
  "C++ Interface:\n"
  "receive_update_broadcast_required_owner(DCClass self, object distobj, DatagramIterator di)\n"
  "\n"
  "/**\n"
  " * Processes a big datagram that includes all of the \"required\" fields that\n"
  " * are sent along with a normal \"generate with required\" message.  This is all\n"
  " * of the atomic fields that are marked \"broadcast ownrecv\". Should be used\n"
  " * for 'owner-view' objects.\n"
  " */";
#else
static const char *Dtool_DCClass_receive_update_broadcast_required_owner_183_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCClass::receive_update_all_required(PyObject *distobj, DatagramIterator &di) const
 */
static PyObject *Dtool_DCClass_receive_update_all_required_184(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DCClass::receive_update_all_required(PyObject *distobj, DatagramIterator &di) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"distobj", "di", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:receive_update_all_required", (char **)keyword_list, &param1, &param2)) {
    DatagramIterator param2_local;
    DatagramIterator *param2_this = Dtool_Coerce_DatagramIterator(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "DCClass.receive_update_all_required", "DatagramIterator");
    }
    (*(const DCClass*)local_this).receive_update_all_required(param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "receive_update_all_required(DCClass self, object distobj, DatagramIterator di)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_receive_update_all_required_184_comment =
  "C++ Interface:\n"
  "receive_update_all_required(DCClass self, object distobj, DatagramIterator di)\n"
  "\n"
  "/**\n"
  " * Processes a big datagram that includes all of the \"required\" fields that\n"
  " * are sent when an avatar is created.  This is all of the atomic fields that\n"
  " * are marked \"required\", whether they are broadcast or not.\n"
  " */";
#else
static const char *Dtool_DCClass_receive_update_all_required_184_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCClass::receive_update_other(PyObject *distobj, DatagramIterator &di) const
 */
static PyObject *Dtool_DCClass_receive_update_other_185(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DCClass::receive_update_other(PyObject *distobj, DatagramIterator &di) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"distobj", "di", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:receive_update_other", (char **)keyword_list, &param1, &param2)) {
    DatagramIterator param2_local;
    DatagramIterator *param2_this = Dtool_Coerce_DatagramIterator(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "DCClass.receive_update_other", "DatagramIterator");
    }
    (*(const DCClass*)local_this).receive_update_other(param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "receive_update_other(DCClass self, object distobj, DatagramIterator di)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_receive_update_other_185_comment =
  "C++ Interface:\n"
  "receive_update_other(DCClass self, object distobj, DatagramIterator di)\n"
  "\n"
  "/**\n"
  " * Processes a datagram that lists some additional fields that are broadcast\n"
  " * in one chunk.\n"
  " */";
#else
static const char *Dtool_DCClass_receive_update_other_185_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DCClass::direct_update(PyObject *distobj, std::string const &field_name, Datagram const &datagram)
 * void DCClass::direct_update(PyObject *distobj, std::string const &field_name, std::string const &value_blob)
 */
static PyObject *Dtool_DCClass_direct_update_186(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCClass, (void **)&local_this, "DCClass.direct_update")) {
    return NULL;
  }
  {
    // -2 void DCClass::direct_update(PyObject *distobj, std::string const &field_name, Datagram const &datagram)
    PyObject *param1;
    char *param2_str = NULL;
    Py_ssize_t param2_len;
    PyObject *param3;
    static const char *keyword_list[] = {"distobj", "field_name", "datagram", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#O:direct_update", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3)) {
      Datagram const *param3_this;
      DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_Datagram, (void **)&param3_this);
      if (param3_this != NULL) {
        (*local_this).direct_update(param1, std::string(param2_str, param2_len), *param3_this);
        PyObject *exception = _PyErr_OCCURRED();
        if (exception == PyExc_TypeError) {
          // TypeError raised; continue to next overload type.
        } else if (exception != (PyObject *)NULL) {
          return NULL;
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            return Dtool_Raise_AssertionError();
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void DCClass::direct_update(PyObject *distobj, std::string const &field_name, std::string const &value_blob)
    PyObject *param1;
    char *param2_str = NULL;
    Py_ssize_t param2_len;
    char *param3_str = NULL;
    Py_ssize_t param3_len;
    static const char *keyword_list[] = {"distobj", "field_name", "value_blob", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#s#:direct_update", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3_str, &param3_len)) {
      (*local_this).direct_update(param1, std::string(param2_str, param2_len), std::string(param3_str, param3_len));
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void DCClass::direct_update(PyObject *distobj, std::string const &field_name, Datagram const &datagram)
    PyObject *param1;
    char *param2_str = NULL;
    Py_ssize_t param2_len;
    PyObject *param3;
    static const char *keyword_list[] = {"distobj", "field_name", "datagram", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#O:direct_update", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3)) {
      Datagram const *param3_this;
      bool param3_manage = false;
      if (Dtool_ConstCoerce_Datagram(param3, param3_this, param3_manage)) {
        (*local_this).direct_update(param1, std::string(param2_str, param2_len), *param3_this);
        if (param3_manage) {
          delete param3_this;
        }
        PyObject *exception = _PyErr_OCCURRED();
        if (exception == PyExc_TypeError) {
          // TypeError raised; continue to next overload type.
        } else if (exception != (PyObject *)NULL) {
          return NULL;
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            return Dtool_Raise_AssertionError();
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: void DCClass::direct_update(PyObject *distobj, std::string const &field_name, std::string const &value_blob)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "direct_update(const DCClass self, object distobj, str field_name, const Datagram datagram)\n"
      "direct_update(const DCClass self, object distobj, str field_name, str value_blob)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_direct_update_186_comment =
  "C++ Interface:\n"
  "direct_update(const DCClass self, object distobj, str field_name, const Datagram datagram)\n"
  "direct_update(const DCClass self, object distobj, str field_name, str value_blob)\n"
  "\n"
  "/**\n"
  " * Processes an update for a named field from a packed value blob.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Processes an update for a named field from a packed datagram.\n"
  " */";
#else
static const char *Dtool_DCClass_direct_update_186_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCClass::pack_required_field(DCPacker &packer, PyObject *distobj, DCField const *field) const
 * bool DCClass::pack_required_field(Datagram &datagram, PyObject *distobj, DCField const *field) const
 */
static PyObject *Dtool_DCClass_pack_required_field_187(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 bool DCClass::pack_required_field(Datagram &datagram, PyObject *distobj, DCField const *field) const
    PyObject *param1;
    PyObject *param2;
    PyObject *param3;
    static const char *keyword_list[] = {"datagram", "distobj", "field", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:pack_required_field", (char **)keyword_list, &param1, &param2, &param3)) {
      Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Datagram, 1, "DCClass.pack_required_field", false, false);
      DCField const *param3_this;
      DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_DCField, (void **)&param3_this);
      if (param1_this != NULL && param3_this != NULL) {
        bool return_value = (*(const DCClass*)local_this).pack_required_field(*param1_this, param2, param3_this);
        PyObject *exception = _PyErr_OCCURRED();
        if (exception == PyExc_TypeError) {
          // TypeError raised; continue to next overload type.
        } else if (exception != (PyObject *)NULL) {
          return NULL;
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            return Dtool_Raise_AssertionError();
          }
#endif
          return Dtool_WrapValue(return_value);
        }
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool DCClass::pack_required_field(DCPacker &packer, PyObject *distobj, DCField const *field) const
    PyObject *param1;
    PyObject *param2;
    PyObject *param3;
    static const char *keyword_list[] = {"packer", "distobj", "field", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:pack_required_field", (char **)keyword_list, &param1, &param2, &param3)) {
      DCPacker *param1_this = (DCPacker *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_DCPacker, 1, "DCClass.pack_required_field", false, false);
      DCField const *param3_this;
      DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_DCField, (void **)&param3_this);
      if (param1_this != NULL && param3_this != NULL) {
        bool return_value = (*(const DCClass*)local_this).pack_required_field(*param1_this, param2, param3_this);
        PyObject *exception = _PyErr_OCCURRED();
        if (exception == PyExc_TypeError) {
          // TypeError raised; continue to next overload type.
        } else if (exception != (PyObject *)NULL) {
          return NULL;
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            return Dtool_Raise_AssertionError();
          }
#endif
          return Dtool_WrapValue(return_value);
        }
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool DCClass::pack_required_field(Datagram &datagram, PyObject *distobj, DCField const *field) const
    PyObject *param1;
    PyObject *param2;
    PyObject *param3;
    static const char *keyword_list[] = {"datagram", "distobj", "field", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:pack_required_field", (char **)keyword_list, &param1, &param2, &param3)) {
      Datagram *param1_this;
      bool param1_manage = false;
      DCField const *param3_this;
      DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_DCField, (void **)&param3_this);
      if (Dtool_Coerce_Datagram(param1, param1_this, param1_manage) && param3_this != NULL) {
        bool return_value = (*(const DCClass*)local_this).pack_required_field(*param1_this, param2, param3_this);
        if (param1_manage) {
          delete param1_this;
        }
        PyObject *exception = _PyErr_OCCURRED();
        if (exception == PyExc_TypeError) {
          // TypeError raised; continue to next overload type.
        } else if (exception != (PyObject *)NULL) {
          return NULL;
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            return Dtool_Raise_AssertionError();
          }
#endif
          return Dtool_WrapValue(return_value);
        }
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool DCClass::pack_required_field(DCPacker &packer, PyObject *distobj, DCField const *field) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_required_field(DCClass self, Datagram datagram, object distobj, const DCField field)\n"
      "pack_required_field(DCClass self, DCPacker packer, object distobj, const DCField field)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_pack_required_field_187_comment =
  "C++ Interface:\n"
  "pack_required_field(DCClass self, Datagram datagram, object distobj, const DCField field)\n"
  "pack_required_field(DCClass self, DCPacker packer, object distobj, const DCField field)\n"
  "\n"
  "/**\n"
  " * Looks up the current value of the indicated field by calling the\n"
  " * appropriate get*() function, then packs that value into the datagram.  This\n"
  " * field is presumably either a required field or a specified optional field,\n"
  " * and we are building up a datagram for the generate-with-required message.\n"
  " *\n"
  " * Returns true on success, false on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Looks up the current value of the indicated field by calling the\n"
  " * appropriate get*() function, then packs that value into the packer.  This\n"
  " * field is presumably either a required field or a specified optional field,\n"
  " * and we are building up a datagram for the generate-with-required message.\n"
  " *\n"
  " * Returns true on success, false on failure.\n"
  " */";
#else
static const char *Dtool_DCClass_pack_required_field_187_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Datagram DCClass::client_format_update(std::string const &field_name, DOID_TYPE do_id, PyObject *args) const
 */
static PyObject *Dtool_DCClass_client_format_update_188(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-Datagram DCClass::client_format_update(std::string const &field_name, DOID_TYPE do_id, PyObject *args) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  unsigned long param2;
  PyObject *param3;
  static const char *keyword_list[] = {"field_name", "do_id", "args", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#kO:client_format_update", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    Datagram *return_value = new Datagram((*(const DCClass*)local_this).client_format_update(std::string(param1_str, param1_len), (DOID_TYPE)param2, param3));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "client_format_update(DCClass self, str field_name, int do_id, object args)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_client_format_update_188_comment =
  "C++ Interface:\n"
  "client_format_update(DCClass self, str field_name, int do_id, object args)\n"
  "\n"
  "/**\n"
  " * Generates a datagram containing the message necessary to send an update for\n"
  " * the indicated distributed object from the client.\n"
  " */";
#else
static const char *Dtool_DCClass_client_format_update_188_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Datagram DCClass::ai_format_update(std::string const &field_name, DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, PyObject *args) const
 */
static PyObject *Dtool_DCClass_ai_format_update_189(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-Datagram DCClass::ai_format_update(std::string const &field_name, DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, PyObject *args) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  unsigned long param2;
  unsigned PY_LONG_LONG param3;
  unsigned PY_LONG_LONG param4;
  PyObject *param5;
  static const char *keyword_list[] = {"field_name", "do_id", "to_id", "from_id", "args", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#kKKO:ai_format_update", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3, &param4, &param5)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    Datagram *return_value = new Datagram((*(const DCClass*)local_this).ai_format_update(std::string(param1_str, param1_len), (DOID_TYPE)param2, (CHANNEL_TYPE)param3, (CHANNEL_TYPE)param4, param5));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ai_format_update(DCClass self, str field_name, int do_id, long to_id, long from_id, object args)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_ai_format_update_189_comment =
  "C++ Interface:\n"
  "ai_format_update(DCClass self, str field_name, int do_id, long to_id, long from_id, object args)\n"
  "\n"
  "/**\n"
  " * Generates a datagram containing the message necessary to send an update for\n"
  " * the indicated distributed object from the AI.\n"
  " */";
#else
static const char *Dtool_DCClass_ai_format_update_189_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Datagram DCClass::ai_format_update_msg_type(std::string const &field_name, DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, int msg_type, PyObject *args) const
 */
static PyObject *Dtool_DCClass_ai_format_update_msg_type_190(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-Datagram DCClass::ai_format_update_msg_type(std::string const &field_name, DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, int msg_type, PyObject *args) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  unsigned long param2;
  unsigned PY_LONG_LONG param3;
  unsigned PY_LONG_LONG param4;
  int param5;
  PyObject *param6;
  static const char *keyword_list[] = {"field_name", "do_id", "to_id", "from_id", "msg_type", "args", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#kKKiO:ai_format_update_msg_type", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3, &param4, &param5, &param6)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    Datagram *return_value = new Datagram((*(const DCClass*)local_this).ai_format_update_msg_type(std::string(param1_str, param1_len), (DOID_TYPE)param2, (CHANNEL_TYPE)param3, (CHANNEL_TYPE)param4, (int)param5, param6));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ai_format_update_msg_type(DCClass self, str field_name, int do_id, long to_id, long from_id, int msg_type, object args)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_ai_format_update_msg_type_190_comment =
  "C++ Interface:\n"
  "ai_format_update_msg_type(DCClass self, str field_name, int do_id, long to_id, long from_id, int msg_type, object args)\n"
  "\n"
  "/**\n"
  " * Generates a datagram containing the message necessary to send an update,\n"
  " * using the indicated msg type for the indicated distributed object from the\n"
  " * AI.\n"
  " */";
#else
static const char *Dtool_DCClass_ai_format_update_msg_type_190_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Datagram DCClass::ai_format_generate(PyObject *distobj, DOID_TYPE do_id, ZONEID_TYPE parent_id, ZONEID_TYPE zone_id, CHANNEL_TYPE district_channel_id, CHANNEL_TYPE from_channel_id, PyObject *optional_fields) const
 */
static PyObject *Dtool_DCClass_ai_format_generate_191(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-Datagram DCClass::ai_format_generate(PyObject *distobj, DOID_TYPE do_id, ZONEID_TYPE parent_id, ZONEID_TYPE zone_id, CHANNEL_TYPE district_channel_id, CHANNEL_TYPE from_channel_id, PyObject *optional_fields) const
  PyObject *param1;
  unsigned long param2;
  unsigned long param3;
  unsigned long param4;
  unsigned PY_LONG_LONG param5;
  unsigned PY_LONG_LONG param6;
  PyObject *param7;
  static const char *keyword_list[] = {"distobj", "do_id", "parent_id", "zone_id", "district_channel_id", "from_channel_id", "optional_fields", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OkkkKKO:ai_format_generate", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param3 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param3);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param4 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param4);
    }
#endif
    Datagram *return_value = new Datagram((*(const DCClass*)local_this).ai_format_generate(param1, (DOID_TYPE)param2, (ZONEID_TYPE)param3, (ZONEID_TYPE)param4, (CHANNEL_TYPE)param5, (CHANNEL_TYPE)param6, param7));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ai_format_generate(DCClass self, object distobj, int do_id, int parent_id, int zone_id, long district_channel_id, long from_channel_id, object optional_fields)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_ai_format_generate_191_comment =
  "C++ Interface:\n"
  "ai_format_generate(DCClass self, object distobj, int do_id, int parent_id, int zone_id, long district_channel_id, long from_channel_id, object optional_fields)\n"
  "\n"
  "/**\n"
  " * Generates a datagram containing the message necessary to generate a new\n"
  " * distributed object from the AI. This requires querying the object for the\n"
  " * initial value of its required fields.\n"
  " *\n"
  " * optional_fields is a list of fieldNames to generate in addition to the\n"
  " * normal required fields.\n"
  " */";
#else
static const char *Dtool_DCClass_ai_format_generate_191_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Datagram DCClass::client_format_generate_CMU(PyObject *distobj, DOID_TYPE do_id, ZONEID_TYPE zone_id, PyObject *optional_fields) const
 */
static PyObject *Dtool_DCClass_client_format_generate_CMU_192(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }
  // 1-Datagram DCClass::client_format_generate_CMU(PyObject *distobj, DOID_TYPE do_id, ZONEID_TYPE zone_id, PyObject *optional_fields) const
  PyObject *param1;
  unsigned long param2;
  unsigned long param3;
  PyObject *param4;
  static const char *keyword_list[] = {"distobj", "do_id", "zone_id", "optional_fields", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OkkO:client_format_generate_CMU", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param3 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param3);
    }
#endif
    Datagram *return_value = new Datagram((*(const DCClass*)local_this).client_format_generate_CMU(param1, (DOID_TYPE)param2, (ZONEID_TYPE)param3, param4));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "client_format_generate_CMU(DCClass self, object distobj, int do_id, int zone_id, object optional_fields)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_client_format_generate_CMU_192_comment =
  "C++ Interface:\n"
  "client_format_generate_CMU(DCClass self, object distobj, int do_id, int zone_id, object optional_fields)\n"
  "\n"
  "/**\n"
  " * Generates a datagram containing the message necessary to generate a new\n"
  " * distributed object from the client.  This requires querying the object for\n"
  " * the initial value of its required fields.\n"
  " *\n"
  " * optional_fields is a list of fieldNames to generate in addition to the\n"
  " * normal required fields.\n"
  " *\n"
  " * This method is only called by the CMU implementation.\n"
  " */";
#else
static const char *Dtool_DCClass_client_format_generate_CMU_192_comment = NULL;
#endif

static int Dtool_Init_DCClass(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCClass(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DCClass) {
    printf("DCClass ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DCClass *local_this = (DCClass *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DCClass) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCDeclaration) {
    return (DCDeclaration *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DCClass(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DCClass) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCDeclaration) {
    DCDeclaration* other_this = (DCDeclaration*)from_this;
    return (DCClass*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DCClassParameter
 */
/**
 * Python function wrapper for:
 * DCClass const *DCClassParameter::get_class(void) const
 */
static PyObject *Dtool_DCClassParameter_get_class_194(PyObject *self, PyObject *) {
  DCClassParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClassParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCClass const *DCClassParameter::get_class(void) const
  DCClass const *return_value = (*(const DCClassParameter*)local_this).get_class();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCClass, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DCClassParameter_get_class_194_comment =
  "C++ Interface:\n"
  "get_class(DCClassParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the class object this parameter represents.\n"
  " */";
#else
static const char *Dtool_DCClassParameter_get_class_194_comment = NULL;
#endif

static int Dtool_Init_DCClassParameter(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCClassParameter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DCClassParameter) {
    printf("DCClassParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DCClassParameter *local_this = (DCClassParameter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DCClassParameter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCField) {
    return (DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCKeywordList) {
    return (DCKeywordList *)(DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCPackerInterface) {
    return (DCPackerInterface *)(DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCParameter) {
    return (DCParameter *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DCClassParameter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DCClassParameter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCField) {
    DCField* other_this = (DCField*)from_this;
    return (DCClassParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCKeywordList) {
    DCKeywordList* other_this = (DCKeywordList*)from_this;
    return (DCClassParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCPackerInterface) {
    DCPackerInterface* other_this = (DCPackerInterface*)from_this;
    return (DCClassParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCParameter) {
    DCParameter* other_this = (DCParameter*)from_this;
    return (DCClassParameter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DCFile
 */
/**
 * Python function wrapper for:
 * void DCFile::clear(void)
 */
static PyObject *Dtool_DCFile_clear_199(PyObject *self, PyObject *) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCFile, (void **)&local_this, "DCFile.clear")) {
    return NULL;
  }
  // 1-void DCFile::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCFile_clear_199_comment =
  "C++ Interface:\n"
  "clear(const DCFile self)\n"
  "\n"
  "/**\n"
  " * Removes all of the classes defined within the DCFile and prepares it for\n"
  " * reading a new file.\n"
  " */";
#else
static const char *Dtool_DCFile_clear_199_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCFile::read_all(void)
 */
static PyObject *Dtool_DCFile_read_all_200(PyObject *self, PyObject *) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCFile, (void **)&local_this, "DCFile.read_all")) {
    return NULL;
  }
  // 1-bool DCFile::read_all(void)
  bool return_value = (*local_this).read_all();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCFile_read_all_200_comment =
  "C++ Interface:\n"
  "read_all(const DCFile self)\n"
  "\n"
  "/**\n"
  " * This special method reads all of the .dc files named by the \"dc-file\"\n"
  " * config.prc variable, and loads them into the DCFile namespace.\n"
  " */";
#else
static const char *Dtool_DCFile_read_all_200_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCFile::read(Filename filename)
 * bool DCFile::read(istream &in, std::string const &filename = string())
 */
static PyObject *Dtool_DCFile_read_201(PyObject *self, PyObject *args, PyObject *kwds) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCFile, (void **)&local_this, "DCFile.read")) {
    return NULL;
  }
  {
    // -2 bool DCFile::read(istream &in, std::string const &filename = string())
    PyObject *param1;
    const char *param2_str = "";
    Py_ssize_t param2_len = 0;
    static const char *keyword_list[] = {"in", "filename", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:read", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
      istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_istream, 1, "DCFile.read", false, false);
      if (param1_this != NULL) {
        bool return_value = (*local_this).read(*param1_this, std::string(param2_str, param2_len));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool DCFile::read(istream &in, std::string const &filename = string())
  {
    // -2 bool DCFile::read(Filename filename)
    PyObject *param1;
    static const char *keyword_list[] = {"filename", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:read", (char **)keyword_list, &param1)) {
      Filename param1_local;
      Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != NULL)) {
        bool return_value = (*local_this).read(*param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read(const DCFile self, istream in, str filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_read_201_comment =
  "C++ Interface:\n"
  "read(const DCFile self, istream in, str filename)\n"
  "\n"
  "/**\n"
  " * Opens and reads the indicated .dc file by name.  The distributed classes\n"
  " * defined in the file will be appended to the set of distributed classes\n"
  " * already recorded, if any.\n"
  " *\n"
  " * Returns true if the file is successfully read, false if there was an error\n"
  " * (in which case the file might have been partially read).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Parses the already-opened input stream for distributed class descriptions.\n"
  " * The filename parameter is optional and is only used when reporting errors.\n"
  " *\n"
  " * The distributed classes defined in the file will be appended to the set of\n"
  " * distributed classes already recorded, if any.\n"
  " *\n"
  " * Returns true if the file is successfully read, false if there was an error\n"
  " * (in which case the file might have been partially read).\n"
  " */";
#else
static const char *Dtool_DCFile_read_201_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCFile::write(Filename filename, bool brief) const
 * bool DCFile::write(ostream &out, bool brief) const
 */
static PyObject *Dtool_DCFile_write_202(PyObject *self, PyObject *args, PyObject *kwds) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 bool DCFile::write(Filename filename, bool brief) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"filename", "brief", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:write", (char **)keyword_list, &param1, &param2)) {
      Filename *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
      if (param1_this != NULL) {
        bool return_value = (*(const DCFile*)local_this).write(*param1_this, (PyObject_IsTrue(param2) != 0));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool DCFile::write(ostream &out, bool brief) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"out", "brief", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:write", (char **)keyword_list, &param1, &param2)) {
      ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "DCFile.write", false, false);
      if (param1_this != NULL) {
        bool return_value = (*(const DCFile*)local_this).write(*param1_this, (PyObject_IsTrue(param2) != 0));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool DCFile::write(Filename filename, bool brief) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"filename", "brief", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:write", (char **)keyword_list, &param1, &param2)) {
      Filename param1_local;
      Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != NULL)) {
        bool return_value = (*(const DCFile*)local_this).write(*param1_this, (PyObject_IsTrue(param2) != 0));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool DCFile::write(ostream &out, bool brief) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(DCFile self, Filename filename, bool brief)\n"
      "write(DCFile self, ostream out, bool brief)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_write_202_comment =
  "C++ Interface:\n"
  "write(DCFile self, Filename filename, bool brief)\n"
  "write(DCFile self, ostream out, bool brief)\n"
  "\n"
  "/**\n"
  " * Opens the indicated filename for output and writes a parseable description\n"
  " * of all the known distributed classes to the file.\n"
  " *\n"
  " * Returns true if the description is successfully written, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Writes a parseable description of all the known distributed classes to the\n"
  " * stream.\n"
  " *\n"
  " * Returns true if the description is successfully written, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCFile_write_202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DCFile::get_num_classes(void) const
 */
static PyObject *Dtool_DCFile_get_num_classes_203(PyObject *self, PyObject *) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DCFile::get_num_classes(void) const
  int return_value = (*(const DCFile*)local_this).get_num_classes();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_num_classes_203_comment =
  "C++ Interface:\n"
  "get_num_classes(DCFile self)\n"
  "\n"
  "/**\n"
  " * Returns the number of classes read from the .dc file(s).\n"
  " */";
#else
static const char *Dtool_DCFile_get_num_classes_203_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCClass *DCFile::get_class(int n) const
 */
static PyObject *Dtool_DCFile_get_class_204(PyObject *self, PyObject *arg) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCClass *DCFile::get_class(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCClass *return_value = (*(const DCFile*)local_this).get_class((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCClass, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_class(DCFile self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_class_204_comment =
  "C++ Interface:\n"
  "get_class(DCFile self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth class read from the .dc file(s).\n"
  " */";
#else
static const char *Dtool_DCFile_get_class_204_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCClass *DCFile::get_class_by_name(std::string const &name) const
 */
static PyObject *Dtool_DCFile_get_class_by_name_205(PyObject *self, PyObject *arg) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCClass *DCFile::get_class_by_name(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    DCClass *return_value = (*(const DCFile*)local_this).get_class_by_name(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCClass, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_class_by_name(DCFile self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_class_by_name_205_comment =
  "C++ Interface:\n"
  "get_class_by_name(DCFile self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the class that has the indicated name, or NULL if there is no such\n"
  " * class.\n"
  " */";
#else
static const char *Dtool_DCFile_get_class_by_name_205_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCSwitch *DCFile::get_switch_by_name(std::string const &name) const
 */
static PyObject *Dtool_DCFile_get_switch_by_name_206(PyObject *self, PyObject *arg) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCSwitch *DCFile::get_switch_by_name(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    DCSwitch *return_value = (*(const DCFile*)local_this).get_switch_by_name(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCSwitch, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_switch_by_name(DCFile self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_switch_by_name_206_comment =
  "C++ Interface:\n"
  "get_switch_by_name(DCFile self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the switch that has the indicated name, or NULL if there is no such\n"
  " * switch.\n"
  " */";
#else
static const char *Dtool_DCFile_get_switch_by_name_206_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCField *DCFile::get_field_by_index(int index_number) const
 */
static PyObject *Dtool_DCFile_get_field_by_index_207(PyObject *self, PyObject *arg) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCField *DCFile::get_field_by_index(int index_number) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCField *return_value = (*(const DCFile*)local_this).get_field_by_index((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_field_by_index(DCFile self, int index_number)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_field_by_index_207_comment =
  "C++ Interface:\n"
  "get_field_by_index(DCFile self, int index_number)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the one DCField that has the indicated index number,\n"
  " * of all the DCFields across all classes in the file.\n"
  " *\n"
  " * This method is only valid if dc-multiple-inheritance is set true in the\n"
  " * Config.prc file.  Without this setting, different DCFields may share the\n"
  " * same index number, so this global lookup is not possible.\n"
  " */";
#else
static const char *Dtool_DCFile_get_field_by_index_207_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DCFile::all_objects_valid(void) const
 */
static PyObject *Dtool_DCFile_all_objects_valid_208(PyObject *self, PyObject *) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DCFile::all_objects_valid(void) const
  bool return_value = (*(const DCFile*)local_this).all_objects_valid();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCFile_all_objects_valid_208_comment =
  "C++ Interface:\n"
  "all_objects_valid(DCFile self)\n"
  "\n"
  "/**\n"
  " * Returns true if all of the classes read from the DC file were defined and\n"
  " * valid, or false if any of them were undefined (\"bogus classes\").  If this\n"
  " * is true, we might have read a partial file.\n"
  " */";
#else
static const char *Dtool_DCFile_all_objects_valid_208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DCFile::get_num_import_modules(void) const
 */
static PyObject *Dtool_DCFile_get_num_import_modules_209(PyObject *self, PyObject *) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DCFile::get_num_import_modules(void) const
  int return_value = (*(const DCFile*)local_this).get_num_import_modules();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_num_import_modules_209_comment =
  "C++ Interface:\n"
  "get_num_import_modules(DCFile self)\n"
  "\n"
  "/**\n"
  " * Returns the number of import lines read from the .dc file(s).\n"
  " */";
#else
static const char *Dtool_DCFile_get_num_import_modules_209_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string DCFile::get_import_module(int n) const
 */
static PyObject *Dtool_DCFile_get_import_module_210(PyObject *self, PyObject *arg) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string DCFile::get_import_module(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (*(const DCFile*)local_this).get_import_module((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_import_module(DCFile self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_import_module_210_comment =
  "C++ Interface:\n"
  "get_import_module(DCFile self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the module named by the nth import line read from the .dc file(s).\n"
  " */";
#else
static const char *Dtool_DCFile_get_import_module_210_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DCFile::get_num_import_symbols(int n) const
 */
static PyObject *Dtool_DCFile_get_num_import_symbols_211(PyObject *self, PyObject *arg) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DCFile::get_num_import_symbols(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const DCFile*)local_this).get_num_import_symbols((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_import_symbols(DCFile self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_num_import_symbols_211_comment =
  "C++ Interface:\n"
  "get_num_import_symbols(DCFile self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the number of symbols explicitly imported by the nth import line.\n"
  " * If this is 0, the line is \"import modulename\"; if it is more than 0, the\n"
  " * line is \"from modulename import symbol, symbol ... \".\n"
  " */";
#else
static const char *Dtool_DCFile_get_num_import_symbols_211_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string DCFile::get_import_symbol(int n, int i) const
 */
static PyObject *Dtool_DCFile_get_import_symbol_212(PyObject *self, PyObject *args, PyObject *kwds) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string DCFile::get_import_symbol(int n, int i) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"n", "i", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_import_symbol", (char **)keyword_list, &param1, &param2)) {
    std::string return_value = (*(const DCFile*)local_this).get_import_symbol((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_import_symbol(DCFile self, int n, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_import_symbol_212_comment =
  "C++ Interface:\n"
  "get_import_symbol(DCFile self, int n, int i)\n"
  "\n"
  "/**\n"
  " * Returns the ith symbol named by the nth import line read from the .dc\n"
  " * file(s).\n"
  " */";
#else
static const char *Dtool_DCFile_get_import_symbol_212_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DCFile::get_num_typedefs(void) const
 */
static PyObject *Dtool_DCFile_get_num_typedefs_213(PyObject *self, PyObject *) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DCFile::get_num_typedefs(void) const
  int return_value = (*(const DCFile*)local_this).get_num_typedefs();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_num_typedefs_213_comment =
  "C++ Interface:\n"
  "get_num_typedefs(DCFile self)\n"
  "\n"
  "/**\n"
  " * Returns the number of typedefs read from the .dc file(s).\n"
  " */";
#else
static const char *Dtool_DCFile_get_num_typedefs_213_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCTypedef *DCFile::get_typedef(int n) const
 */
static PyObject *Dtool_DCFile_get_typedef_214(PyObject *self, PyObject *arg) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCTypedef *DCFile::get_typedef(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCTypedef *return_value = (*(const DCFile*)local_this).get_typedef((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCTypedef, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_typedef(DCFile self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_typedef_214_comment =
  "C++ Interface:\n"
  "get_typedef(DCFile self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth typedef read from the .dc file(s).\n"
  " */";
#else
static const char *Dtool_DCFile_get_typedef_214_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCTypedef *DCFile::get_typedef_by_name(std::string const &name) const
 */
static PyObject *Dtool_DCFile_get_typedef_by_name_215(PyObject *self, PyObject *arg) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCTypedef *DCFile::get_typedef_by_name(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    DCTypedef *return_value = (*(const DCFile*)local_this).get_typedef_by_name(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCTypedef, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_typedef_by_name(DCFile self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_typedef_by_name_215_comment =
  "C++ Interface:\n"
  "get_typedef_by_name(DCFile self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the typedef that has the indicated name, or NULL if there is no\n"
  " * such typedef name.\n"
  " */";
#else
static const char *Dtool_DCFile_get_typedef_by_name_215_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DCFile::get_num_keywords(void) const
 */
static PyObject *Dtool_DCFile_get_num_keywords_216(PyObject *self, PyObject *) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DCFile::get_num_keywords(void) const
  int return_value = (*(const DCFile*)local_this).get_num_keywords();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_num_keywords_216_comment =
  "C++ Interface:\n"
  "get_num_keywords(DCFile self)\n"
  "\n"
  "/**\n"
  " * Returns the number of keywords read from the .dc file(s).\n"
  " */";
#else
static const char *Dtool_DCFile_get_num_keywords_216_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCKeyword const *DCFile::get_keyword(int n) const
 */
static PyObject *Dtool_DCFile_get_keyword_217(PyObject *self, PyObject *arg) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCKeyword const *DCFile::get_keyword(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCKeyword const *return_value = (*(const DCFile*)local_this).get_keyword((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCKeyword, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_keyword(DCFile self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_keyword_217_comment =
  "C++ Interface:\n"
  "get_keyword(DCFile self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth keyword read from the .dc file(s).\n"
  " */";
#else
static const char *Dtool_DCFile_get_keyword_217_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCKeyword const *DCFile::get_keyword_by_name(std::string const &name) const
 */
static PyObject *Dtool_DCFile_get_keyword_by_name_218(PyObject *self, PyObject *arg) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCKeyword const *DCFile::get_keyword_by_name(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    DCKeyword const *return_value = (*(const DCFile*)local_this).get_keyword_by_name(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCKeyword, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_keyword_by_name(DCFile self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_keyword_by_name_218_comment =
  "C++ Interface:\n"
  "get_keyword_by_name(DCFile self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the keyword that has the indicated name, or NULL if there is no\n"
  " * such keyword name.\n"
  " */";
#else
static const char *Dtool_DCFile_get_keyword_by_name_218_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * unsigned long int DCFile::get_hash(void) const
 */
static PyObject *Dtool_DCFile_get_hash_219(PyObject *self, PyObject *) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-unsigned long int DCFile::get_hash(void) const
  unsigned long int return_value = (*(const DCFile*)local_this).get_hash();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_hash_219_comment =
  "C++ Interface:\n"
  "get_hash(DCFile self)\n"
  "\n"
  "/**\n"
  " * Returns a 32-bit hash index associated with this file.  This number is\n"
  " * guaranteed to be consistent if the contents of the file have not changed,\n"
  " * and it is very likely to be different if the contents of the file do\n"
  " * change.\n"
  " */";
#else
static const char *Dtool_DCFile_get_hash_219_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCFile::DCFile(void)
 * inline DCFile::DCFile(DCFile const &) = default
 */
static int Dtool_Init_DCFile(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-DCFile::DCFile(void)
      DCFile *return_value = new DCFile();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DCFile, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline DCFile::DCFile(DCFile const &) = default
      DCFile const *arg_this = (DCFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DCFile, 0, "DCFile.DCFile", true, true);
      if (arg_this != NULL) {
        DCFile *return_value = new DCFile(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DCFile, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DCFile() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DCFile()\n"
      "DCFile(const DCFile param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DCFile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DCFile) {
    printf("DCFile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DCFile *local_this = (DCFile *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DCFile) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DCFile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DCFile) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DCKeyword
 */
/**
 * Python function wrapper for:
 * std::string const &DCKeyword::get_name(void) const
 */
static PyObject *Dtool_DCKeyword_get_name_221(PyObject *self, PyObject *) {
  DCKeyword *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCKeyword, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string const &DCKeyword::get_name(void) const
  std::string const &return_value = (*(const DCKeyword*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCKeyword_get_name_221_comment =
  "C++ Interface:\n"
  "get_name(DCKeyword self)\n"
  "\n"
  "/**\n"
  " * Returns the name of this keyword.\n"
  " */";
#else
static const char *Dtool_DCKeyword_get_name_221_comment = NULL;
#endif

static int Dtool_Init_DCKeyword(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCKeyword(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DCKeyword) {
    printf("DCKeyword ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DCKeyword *local_this = (DCKeyword *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DCKeyword) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCDeclaration) {
    return (DCDeclaration *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DCKeyword(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DCKeyword) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCDeclaration) {
    DCDeclaration* other_this = (DCDeclaration*)from_this;
    return (DCKeyword*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DCMolecularField
 */
/**
 * Python function wrapper for:
 * int DCMolecularField::get_num_atomics(void) const
 */
static PyObject *Dtool_DCMolecularField_get_num_atomics_223(PyObject *self, PyObject *) {
  DCMolecularField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCMolecularField, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DCMolecularField::get_num_atomics(void) const
  int return_value = (*(const DCMolecularField*)local_this).get_num_atomics();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCMolecularField_get_num_atomics_223_comment =
  "C++ Interface:\n"
  "get_num_atomics(DCMolecularField self)\n"
  "\n"
  "/**\n"
  " * Returns the number of atomic fields that make up this molecular field.\n"
  " */";
#else
static const char *Dtool_DCMolecularField_get_num_atomics_223_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCAtomicField *DCMolecularField::get_atomic(int n) const
 */
static PyObject *Dtool_DCMolecularField_get_atomic_224(PyObject *self, PyObject *arg) {
  DCMolecularField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCMolecularField, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCAtomicField *DCMolecularField::get_atomic(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCAtomicField *return_value = (*(const DCMolecularField*)local_this).get_atomic((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCAtomicField, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_atomic(DCMolecularField self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCMolecularField_get_atomic_224_comment =
  "C++ Interface:\n"
  "get_atomic(DCMolecularField self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth atomic field that makes up this molecular field.  This may\n"
  " * or may not be a field of this particular class; it might be defined in a\n"
  " * parent class.\n"
  " */";
#else
static const char *Dtool_DCMolecularField_get_atomic_224_comment = NULL;
#endif

static int Dtool_Init_DCMolecularField(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCMolecularField(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DCMolecularField) {
    printf("DCMolecularField ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DCMolecularField *local_this = (DCMolecularField *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DCMolecularField) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCField) {
    return (DCField *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCKeywordList) {
    return (DCKeywordList *)(DCField *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCPackerInterface) {
    return (DCPackerInterface *)(DCField *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DCMolecularField(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DCMolecularField) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCField) {
    DCField* other_this = (DCField*)from_this;
    return (DCMolecularField*)other_this;
  }
  if (from_type == Dtool_Ptr_DCKeywordList) {
    DCKeywordList* other_this = (DCKeywordList*)from_this;
    return (DCMolecularField*)other_this;
  }
  if (from_type == Dtool_Ptr_DCPackerInterface) {
    DCPackerInterface* other_this = (DCPackerInterface*)from_this;
    return (DCMolecularField*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DCSimpleParameter
 */
/**
 * Python function wrapper for:
 * DCSubatomicType DCSimpleParameter::get_type(void) const
 */
static PyObject *Dtool_DCSimpleParameter_get_type_227(PyObject *self, PyObject *) {
  DCSimpleParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCSimpleParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCSubatomicType DCSimpleParameter::get_type(void) const
  DCSubatomicType return_value = (*(const DCSimpleParameter*)local_this).get_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCSimpleParameter_get_type_227_comment =
  "C++ Interface:\n"
  "get_type(DCSimpleParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the particular subatomic type represented by this instance.\n"
  " */";
#else
static const char *Dtool_DCSimpleParameter_get_type_227_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCSimpleParameter::has_modulus(void) const
 */
static PyObject *Dtool_DCSimpleParameter_has_modulus_228(PyObject *self, PyObject *) {
  DCSimpleParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCSimpleParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool DCSimpleParameter::has_modulus(void) const
  bool return_value = (*(const DCSimpleParameter*)local_this).has_modulus();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCSimpleParameter_has_modulus_228_comment =
  "C++ Interface:\n"
  "has_modulus(DCSimpleParameter self)\n"
  "\n"
  "/**\n"
  " * Returns true if there is a modulus associated, false otherwise.,\n"
  " */";
#else
static const char *Dtool_DCSimpleParameter_has_modulus_228_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double DCSimpleParameter::get_modulus(void) const
 */
static PyObject *Dtool_DCSimpleParameter_get_modulus_229(PyObject *self, PyObject *) {
  DCSimpleParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCSimpleParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-double DCSimpleParameter::get_modulus(void) const
  double return_value = (*(const DCSimpleParameter*)local_this).get_modulus();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCSimpleParameter_get_modulus_229_comment =
  "C++ Interface:\n"
  "get_modulus(DCSimpleParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the modulus associated with this type, if any.  It is an error to\n"
  " * call this if has_modulus() returned false.\n"
  " *\n"
  " * If present, this is the modulus that is used to constrain the numeric value\n"
  " * of the field before it is packed (and range-checked).\n"
  " */";
#else
static const char *Dtool_DCSimpleParameter_get_modulus_229_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DCSimpleParameter::get_divisor(void) const
 */
static PyObject *Dtool_DCSimpleParameter_get_divisor_230(PyObject *self, PyObject *) {
  DCSimpleParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCSimpleParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DCSimpleParameter::get_divisor(void) const
  int return_value = (*(const DCSimpleParameter*)local_this).get_divisor();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCSimpleParameter_get_divisor_230_comment =
  "C++ Interface:\n"
  "get_divisor(DCSimpleParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the divisor associated with this type.  This is 1 by default, but\n"
  " * if this is other than one it represents the scale to apply when packing and\n"
  " * unpacking numeric values (to store fixed-point values in an integer field).\n"
  " * It is only meaningful for numeric-type fields.\n"
  " */";
#else
static const char *Dtool_DCSimpleParameter_get_divisor_230_comment = NULL;
#endif

static int Dtool_Init_DCSimpleParameter(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCSimpleParameter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DCSimpleParameter) {
    printf("DCSimpleParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DCSimpleParameter *local_this = (DCSimpleParameter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DCSimpleParameter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCField) {
    return (DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCKeywordList) {
    return (DCKeywordList *)(DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCPackerInterface) {
    return (DCPackerInterface *)(DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCParameter) {
    return (DCParameter *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DCSimpleParameter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DCSimpleParameter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCField) {
    DCField* other_this = (DCField*)from_this;
    return (DCSimpleParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCKeywordList) {
    DCKeywordList* other_this = (DCKeywordList*)from_this;
    return (DCSimpleParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCPackerInterface) {
    DCPackerInterface* other_this = (DCPackerInterface*)from_this;
    return (DCSimpleParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCParameter) {
    DCParameter* other_this = (DCParameter*)from_this;
    return (DCSimpleParameter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DCSwitch
 */
/**
 * Python function wrapper for:
 * std::string const &DCSwitch::get_name(void) const
 */
static PyObject *Dtool_DCSwitch_get_name_233(PyObject *self, PyObject *) {
  DCSwitch *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCSwitch, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string const &DCSwitch::get_name(void) const
  std::string const &return_value = (*(const DCSwitch*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_name_233_comment =
  "C++ Interface:\n"
  "get_name(DCSwitch self)\n"
  "\n"
  "/**\n"
  " * Returns the name of this switch.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_name_233_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCField *DCSwitch::get_key_parameter(void) const
 */
static PyObject *Dtool_DCSwitch_get_key_parameter_234(PyObject *self, PyObject *) {
  DCSwitch *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCSwitch, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCField *DCSwitch::get_key_parameter(void) const
  DCField *return_value = (*(const DCSwitch*)local_this).get_key_parameter();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_key_parameter_234_comment =
  "C++ Interface:\n"
  "get_key_parameter(DCSwitch self)\n"
  "\n"
  "/**\n"
  " * Returns the key parameter on which the switch is based.  The value of this\n"
  " * parameter in the record determines which one of the several cases within\n"
  " * the switch will be used.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_key_parameter_234_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DCSwitch::get_num_cases(void) const
 */
static PyObject *Dtool_DCSwitch_get_num_cases_235(PyObject *self, PyObject *) {
  DCSwitch *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCSwitch, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DCSwitch::get_num_cases(void) const
  int return_value = (*(const DCSwitch*)local_this).get_num_cases();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_num_cases_235_comment =
  "C++ Interface:\n"
  "get_num_cases(DCSwitch self)\n"
  "\n"
  "/**\n"
  " * Returns the number of different cases within the switch.  The legal values\n"
  " * for case_index range from 0 to get_num_cases() - 1.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_num_cases_235_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DCSwitch::get_case_by_value(std::string const &case_value) const
 */
static PyObject *Dtool_DCSwitch_get_case_by_value_236(PyObject *self, PyObject *arg) {
  DCSwitch *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCSwitch, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DCSwitch::get_case_by_value(std::string const &case_value) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    int return_value = (*(const DCSwitch*)local_this).get_case_by_value(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_case_by_value(DCSwitch self, str case_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_case_by_value_236_comment =
  "C++ Interface:\n"
  "get_case_by_value(DCSwitch self, str case_value)\n"
  "\n"
  "/**\n"
  " * Returns the index number of the case with the indicated packed value, or -1\n"
  " * if no case has this value.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_case_by_value_236_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCPackerInterface *DCSwitch::get_case(int n) const
 */
static PyObject *Dtool_DCSwitch_get_case_237(PyObject *self, PyObject *arg) {
  DCSwitch *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCSwitch, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCPackerInterface *DCSwitch::get_case(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCPackerInterface *return_value = (*(const DCSwitch*)local_this).get_case((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCPackerInterface, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_case(DCSwitch self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_case_237_comment =
  "C++ Interface:\n"
  "get_case(DCSwitch self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the DCPackerInterface that packs the nth case.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_case_237_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCPackerInterface *DCSwitch::get_default_case(void) const
 */
static PyObject *Dtool_DCSwitch_get_default_case_238(PyObject *self, PyObject *) {
  DCSwitch *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCSwitch, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCPackerInterface *DCSwitch::get_default_case(void) const
  DCPackerInterface *return_value = (*(const DCSwitch*)local_this).get_default_case();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCPackerInterface, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_default_case_238_comment =
  "C++ Interface:\n"
  "get_default_case(DCSwitch self)\n"
  "\n"
  "/**\n"
  " * Returns the DCPackerInterface that packs the default case, or NULL if there\n"
  " * is no default case.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_default_case_238_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string DCSwitch::get_value(int case_index) const
 */
static PyObject *Dtool_DCSwitch_get_value_239(PyObject *self, PyObject *arg) {
  DCSwitch *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCSwitch, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string DCSwitch::get_value(int case_index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (*(const DCSwitch*)local_this).get_value((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_value(DCSwitch self, int case_index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_value_239_comment =
  "C++ Interface:\n"
  "get_value(DCSwitch self, int case_index)\n"
  "\n"
  "/**\n"
  " * Returns the packed value associated with the indicated case.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_value_239_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DCSwitch::get_num_fields(int case_index) const
 */
static PyObject *Dtool_DCSwitch_get_num_fields_240(PyObject *self, PyObject *arg) {
  DCSwitch *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCSwitch, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DCSwitch::get_num_fields(int case_index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const DCSwitch*)local_this).get_num_fields((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_fields(DCSwitch self, int case_index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_num_fields_240_comment =
  "C++ Interface:\n"
  "get_num_fields(DCSwitch self, int case_index)\n"
  "\n"
  "/**\n"
  " * Returns the number of fields in the indicated case.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_num_fields_240_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCField *DCSwitch::get_field(int case_index, int n) const
 */
static PyObject *Dtool_DCSwitch_get_field_241(PyObject *self, PyObject *args, PyObject *kwds) {
  DCSwitch *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCSwitch, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCField *DCSwitch::get_field(int case_index, int n) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"case_index", "n", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_field", (char **)keyword_list, &param1, &param2)) {
    DCField *return_value = (*(const DCSwitch*)local_this).get_field((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_field(DCSwitch self, int case_index, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_field_241_comment =
  "C++ Interface:\n"
  "get_field(DCSwitch self, int case_index, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth field in the indicated case.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_field_241_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DCField *DCSwitch::get_field_by_name(int case_index, std::string const &name) const
 */
static PyObject *Dtool_DCSwitch_get_field_by_name_242(PyObject *self, PyObject *args, PyObject *kwds) {
  DCSwitch *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCSwitch, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCField *DCSwitch::get_field_by_name(int case_index, std::string const &name) const
  int param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"case_index", "name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "is#:get_field_by_name", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    DCField *return_value = (*(const DCSwitch*)local_this).get_field_by_name((int)param1, std::string(param2_str, param2_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_field_by_name(DCSwitch self, int case_index, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_field_by_name_242_comment =
  "C++ Interface:\n"
  "get_field_by_name(DCSwitch self, int case_index, str name)\n"
  "\n"
  "/**\n"
  " * Returns the field with the given name from the indicated case, or NULL if\n"
  " * no field has this name.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_field_by_name_242_comment = NULL;
#endif

static int Dtool_Init_DCSwitch(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCSwitch(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DCSwitch) {
    printf("DCSwitch ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DCSwitch *local_this = (DCSwitch *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DCSwitch) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCDeclaration) {
    return (DCDeclaration *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DCSwitch(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DCSwitch) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCDeclaration) {
    DCDeclaration* other_this = (DCDeclaration*)from_this;
    return (DCSwitch*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DCSwitchParameter
 */
/**
 * Python function wrapper for:
 * DCSwitch const *DCSwitchParameter::get_switch(void) const
 */
static PyObject *Dtool_DCSwitchParameter_get_switch_244(PyObject *self, PyObject *) {
  DCSwitchParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCSwitchParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-DCSwitch const *DCSwitchParameter::get_switch(void) const
  DCSwitch const *return_value = (*(const DCSwitchParameter*)local_this).get_switch();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCSwitch, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DCSwitchParameter_get_switch_244_comment =
  "C++ Interface:\n"
  "get_switch(DCSwitchParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the switch object this parameter represents.\n"
  " */";
#else
static const char *Dtool_DCSwitchParameter_get_switch_244_comment = NULL;
#endif

static int Dtool_Init_DCSwitchParameter(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCSwitchParameter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DCSwitchParameter) {
    printf("DCSwitchParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DCSwitchParameter *local_this = (DCSwitchParameter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DCSwitchParameter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCField) {
    return (DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCKeywordList) {
    return (DCKeywordList *)(DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCPackerInterface) {
    return (DCPackerInterface *)(DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCParameter) {
    return (DCParameter *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DCSwitchParameter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DCSwitchParameter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCField) {
    DCField* other_this = (DCField*)from_this;
    return (DCSwitchParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCKeywordList) {
    DCKeywordList* other_this = (DCKeywordList*)from_this;
    return (DCSwitchParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCPackerInterface) {
    DCPackerInterface* other_this = (DCPackerInterface*)from_this;
    return (DCSwitchParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCParameter) {
    DCParameter* other_this = (DCParameter*)from_this;
    return (DCSwitchParameter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DCTypedef
 */
/**
 * Python function wrapper for:
 * int DCTypedef::get_number(void) const
 */
static PyObject *Dtool_DCTypedef_get_number_247(PyObject *self, PyObject *) {
  DCTypedef *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCTypedef, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DCTypedef::get_number(void) const
  int return_value = (*(const DCTypedef*)local_this).get_number();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCTypedef_get_number_247_comment =
  "C++ Interface:\n"
  "get_number(DCTypedef self)\n"
  "\n"
  "/**\n"
  " * Returns a unique index number associated with this typedef definition.\n"
  " * This is defined implicitly when the .dc file(s) are read.\n"
  " */";
#else
static const char *Dtool_DCTypedef_get_number_247_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string const &DCTypedef::get_name(void) const
 */
static PyObject *Dtool_DCTypedef_get_name_248(PyObject *self, PyObject *) {
  DCTypedef *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCTypedef, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string const &DCTypedef::get_name(void) const
  std::string const &return_value = (*(const DCTypedef*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCTypedef_get_name_248_comment =
  "C++ Interface:\n"
  "get_name(DCTypedef self)\n"
  "\n"
  "/**\n"
  " * Returns the name of this typedef.\n"
  " */";
#else
static const char *Dtool_DCTypedef_get_name_248_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string DCTypedef::get_description(void) const
 */
static PyObject *Dtool_DCTypedef_get_description_249(PyObject *self, PyObject *) {
  DCTypedef *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCTypedef, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string DCTypedef::get_description(void) const
  std::string return_value = (*(const DCTypedef*)local_this).get_description();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCTypedef_get_description_249_comment =
  "C++ Interface:\n"
  "get_description(DCTypedef self)\n"
  "\n"
  "/**\n"
  " * Returns a brief decription of the typedef, useful for human consumption.\n"
  " */";
#else
static const char *Dtool_DCTypedef_get_description_249_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCTypedef::is_bogus_typedef(void) const
 */
static PyObject *Dtool_DCTypedef_is_bogus_typedef_250(PyObject *self, PyObject *) {
  DCTypedef *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCTypedef, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool DCTypedef::is_bogus_typedef(void) const
  bool return_value = (*(const DCTypedef*)local_this).is_bogus_typedef();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCTypedef_is_bogus_typedef_250_comment =
  "C++ Interface:\n"
  "is_bogus_typedef(DCTypedef self)\n"
  "\n"
  "/**\n"
  " * Returns true if the typedef has been flagged as a bogus typedef.  This is\n"
  " * set for typedefs that are generated by the parser as placeholder for\n"
  " * missing typedefs, as when reading a partial file; it should not occur in a\n"
  " * normal valid dc file.\n"
  " */";
#else
static const char *Dtool_DCTypedef_is_bogus_typedef_250_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DCTypedef::is_implicit_typedef(void) const
 */
static PyObject *Dtool_DCTypedef_is_implicit_typedef_251(PyObject *self, PyObject *) {
  DCTypedef *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCTypedef, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool DCTypedef::is_implicit_typedef(void) const
  bool return_value = (*(const DCTypedef*)local_this).is_implicit_typedef();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCTypedef_is_implicit_typedef_251_comment =
  "C++ Interface:\n"
  "is_implicit_typedef(DCTypedef self)\n"
  "\n"
  "/**\n"
  " * Returns true if the typedef has been flagged as an implicit typedef,\n"
  " * meaning it was created for a DCClass that was referenced inline as a type.\n"
  " */";
#else
static const char *Dtool_DCTypedef_is_implicit_typedef_251_comment = NULL;
#endif

static int Dtool_Init_DCTypedef(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCTypedef(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DCTypedef) {
    printf("DCTypedef ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DCTypedef *local_this = (DCTypedef *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DCTypedef) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCDeclaration) {
    return (DCDeclaration *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DCTypedef(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DCTypedef) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCDeclaration) {
    DCDeclaration* other_this = (DCDeclaration*)from_this;
    return (DCTypedef*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for DCPackerInterface (DCPackerInterface)
 */
static PyMethodDef Dtool_Methods_DCPackerInterface[] = {
  {"get_name", &Dtool_DCPackerInterface_get_name_5, METH_NOARGS, (const char *)Dtool_DCPackerInterface_get_name_5_comment},
  {"getName", &Dtool_DCPackerInterface_get_name_5, METH_NOARGS, (const char *)Dtool_DCPackerInterface_get_name_5_comment},
  {"find_seek_index", &Dtool_DCPackerInterface_find_seek_index_6, METH_O, (const char *)Dtool_DCPackerInterface_find_seek_index_6_comment},
  {"findSeekIndex", &Dtool_DCPackerInterface_find_seek_index_6, METH_O, (const char *)Dtool_DCPackerInterface_find_seek_index_6_comment},
  {"as_field", &Dtool_DCPackerInterface_as_field_7, METH_NOARGS, (const char *)Dtool_DCPackerInterface_as_field_7_comment},
  {"asField", &Dtool_DCPackerInterface_as_field_7, METH_NOARGS, (const char *)Dtool_DCPackerInterface_as_field_7_comment},
  {"as_switch_parameter", &Dtool_DCPackerInterface_as_switch_parameter_8, METH_NOARGS, (const char *)Dtool_DCPackerInterface_as_switch_parameter_8_comment},
  {"asSwitchParameter", &Dtool_DCPackerInterface_as_switch_parameter_8, METH_NOARGS, (const char *)Dtool_DCPackerInterface_as_switch_parameter_8_comment},
  {"as_class_parameter", &Dtool_DCPackerInterface_as_class_parameter_9, METH_NOARGS, (const char *)Dtool_DCPackerInterface_as_class_parameter_9_comment},
  {"asClassParameter", &Dtool_DCPackerInterface_as_class_parameter_9, METH_NOARGS, (const char *)Dtool_DCPackerInterface_as_class_parameter_9_comment},
  {"check_match", (PyCFunction) &Dtool_DCPackerInterface_check_match_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCPackerInterface_check_match_10_comment},
  {"checkMatch", (PyCFunction) &Dtool_DCPackerInterface_check_match_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCPackerInterface_check_match_10_comment},
  {"downcast_to_DCField", &Dtool_DCPackerInterface_downcast_to_DCField_20, METH_NOARGS, (const char *)Dtool_DCPackerInterface_downcast_to_DCField_20_comment},
  {"downcastToDCField", &Dtool_DCPackerInterface_downcast_to_DCField_20, METH_NOARGS, (const char *)Dtool_DCPackerInterface_downcast_to_DCField_20_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DCPackerInterface = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_DCPackerInterface = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.DCPackerInterface",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DCPackerInterface,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DCPackerInterface,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This defines the internal interface for packing values into a DCField.  The\n"
    " * various different DC objects inherit from this.\n"
    " *\n"
    " * Normally these methods are called only by the DCPacker object; the user\n"
    " * wouldn't normally call these directly.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DCPackerInterface,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DCPackerInterface,
    PyType_GenericAlloc,
    Dtool_new_DCPackerInterface,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCPackerInterface,
  Dtool_UpcastInterface_DCPackerInterface,
  Dtool_DowncastInterface_DCPackerInterface,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DCPackerInterface(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DCPackerInterface._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_DCPackerInterface._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCPackerInterface) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCPackerInterface)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCPackerInterface);
  }
}

/**
 * Python method tables for DCKeywordList (DCKeywordList)
 */
static PyMethodDef Dtool_Methods_DCKeywordList[] = {
  {"has_keyword", &Dtool_DCKeywordList_has_keyword_13, METH_O, (const char *)Dtool_DCKeywordList_has_keyword_13_comment},
  {"hasKeyword", &Dtool_DCKeywordList_has_keyword_13, METH_O, (const char *)Dtool_DCKeywordList_has_keyword_13_comment},
  {"get_num_keywords", &Dtool_DCKeywordList_get_num_keywords_14, METH_NOARGS, (const char *)Dtool_DCKeywordList_get_num_keywords_14_comment},
  {"getNumKeywords", &Dtool_DCKeywordList_get_num_keywords_14, METH_NOARGS, (const char *)Dtool_DCKeywordList_get_num_keywords_14_comment},
  {"get_keyword", &Dtool_DCKeywordList_get_keyword_15, METH_O, (const char *)Dtool_DCKeywordList_get_keyword_15_comment},
  {"getKeyword", &Dtool_DCKeywordList_get_keyword_15, METH_O, (const char *)Dtool_DCKeywordList_get_keyword_15_comment},
  {"get_keyword_by_name", &Dtool_DCKeywordList_get_keyword_by_name_16, METH_O, (const char *)Dtool_DCKeywordList_get_keyword_by_name_16_comment},
  {"getKeywordByName", &Dtool_DCKeywordList_get_keyword_by_name_16, METH_O, (const char *)Dtool_DCKeywordList_get_keyword_by_name_16_comment},
  {"compare_keywords", &Dtool_DCKeywordList_compare_keywords_17, METH_O, (const char *)Dtool_DCKeywordList_compare_keywords_17_comment},
  {"compareKeywords", &Dtool_DCKeywordList_compare_keywords_17, METH_O, (const char *)Dtool_DCKeywordList_compare_keywords_17_comment},
  {"downcast_to_DCField", &Dtool_DCKeywordList_downcast_to_DCField_22, METH_NOARGS, (const char *)Dtool_DCKeywordList_downcast_to_DCField_22_comment},
  {"downcastToDCField", &Dtool_DCKeywordList_downcast_to_DCField_22, METH_NOARGS, (const char *)Dtool_DCKeywordList_downcast_to_DCField_22_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DCKeywordList = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_DCKeywordList = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.DCKeywordList",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DCKeywordList,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DCKeywordList,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a list of keywords (see DCKeyword) that may be set on a particular\n"
    " * field.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DCKeywordList,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DCKeywordList,
    PyType_GenericAlloc,
    Dtool_new_DCKeywordList,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCKeywordList,
  Dtool_UpcastInterface_DCKeywordList,
  Dtool_DowncastInterface_DCKeywordList,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DCKeywordList(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DCKeywordList._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_DCKeywordList._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCKeywordList) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCKeywordList)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCKeywordList);
  }
}

/**
 * Python method tables for DCField (DCField)
 */
static PyMethodDef Dtool_Methods_DCField[] = {
  {"get_number", &Dtool_DCField_get_number_24, METH_NOARGS, (const char *)Dtool_DCField_get_number_24_comment},
  {"getNumber", &Dtool_DCField_get_number_24, METH_NOARGS, (const char *)Dtool_DCField_get_number_24_comment},
  {"get_class", &Dtool_DCField_get_class_25, METH_NOARGS, (const char *)Dtool_DCField_get_class_25_comment},
  {"getClass", &Dtool_DCField_get_class_25, METH_NOARGS, (const char *)Dtool_DCField_get_class_25_comment},
  {"as_field", &Dtool_DCField_as_field_26, METH_NOARGS, (const char *)Dtool_DCField_as_field_26_comment},
  {"asField", &Dtool_DCField_as_field_26, METH_NOARGS, (const char *)Dtool_DCField_as_field_26_comment},
  {"as_atomic_field", &Dtool_DCField_as_atomic_field_27, METH_NOARGS, (const char *)Dtool_DCField_as_atomic_field_27_comment},
  {"asAtomicField", &Dtool_DCField_as_atomic_field_27, METH_NOARGS, (const char *)Dtool_DCField_as_atomic_field_27_comment},
  {"as_molecular_field", &Dtool_DCField_as_molecular_field_28, METH_NOARGS, (const char *)Dtool_DCField_as_molecular_field_28_comment},
  {"asMolecularField", &Dtool_DCField_as_molecular_field_28, METH_NOARGS, (const char *)Dtool_DCField_as_molecular_field_28_comment},
  {"as_parameter", &Dtool_DCField_as_parameter_29, METH_NOARGS, (const char *)Dtool_DCField_as_parameter_29_comment},
  {"asParameter", &Dtool_DCField_as_parameter_29, METH_NOARGS, (const char *)Dtool_DCField_as_parameter_29_comment},
  {"format_data", (PyCFunction) &Dtool_DCField_format_data_30, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_format_data_30_comment},
  {"formatData", (PyCFunction) &Dtool_DCField_format_data_30, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_format_data_30_comment},
  {"parse_string", &Dtool_DCField_parse_string_31, METH_O, (const char *)Dtool_DCField_parse_string_31_comment},
  {"parseString", &Dtool_DCField_parse_string_31, METH_O, (const char *)Dtool_DCField_parse_string_31_comment},
  {"validate_ranges", &Dtool_DCField_validate_ranges_32, METH_O, (const char *)Dtool_DCField_validate_ranges_32_comment},
  {"validateRanges", &Dtool_DCField_validate_ranges_32, METH_O, (const char *)Dtool_DCField_validate_ranges_32_comment},
  {"has_default_value", &Dtool_DCField_has_default_value_33, METH_NOARGS, (const char *)Dtool_DCField_has_default_value_33_comment},
  {"hasDefaultValue", &Dtool_DCField_has_default_value_33, METH_NOARGS, (const char *)Dtool_DCField_has_default_value_33_comment},
  {"get_default_value", &Dtool_DCField_get_default_value_34, METH_NOARGS, (const char *)Dtool_DCField_get_default_value_34_comment},
  {"getDefaultValue", &Dtool_DCField_get_default_value_34, METH_NOARGS, (const char *)Dtool_DCField_get_default_value_34_comment},
  {"is_bogus_field", &Dtool_DCField_is_bogus_field_35, METH_NOARGS, (const char *)Dtool_DCField_is_bogus_field_35_comment},
  {"isBogusField", &Dtool_DCField_is_bogus_field_35, METH_NOARGS, (const char *)Dtool_DCField_is_bogus_field_35_comment},
  {"is_required", &Dtool_DCField_is_required_36, METH_NOARGS, (const char *)Dtool_DCField_is_required_36_comment},
  {"isRequired", &Dtool_DCField_is_required_36, METH_NOARGS, (const char *)Dtool_DCField_is_required_36_comment},
  {"is_broadcast", &Dtool_DCField_is_broadcast_37, METH_NOARGS, (const char *)Dtool_DCField_is_broadcast_37_comment},
  {"isBroadcast", &Dtool_DCField_is_broadcast_37, METH_NOARGS, (const char *)Dtool_DCField_is_broadcast_37_comment},
  {"is_ram", &Dtool_DCField_is_ram_38, METH_NOARGS, (const char *)Dtool_DCField_is_ram_38_comment},
  {"isRam", &Dtool_DCField_is_ram_38, METH_NOARGS, (const char *)Dtool_DCField_is_ram_38_comment},
  {"is_db", &Dtool_DCField_is_db_39, METH_NOARGS, (const char *)Dtool_DCField_is_db_39_comment},
  {"isDb", &Dtool_DCField_is_db_39, METH_NOARGS, (const char *)Dtool_DCField_is_db_39_comment},
  {"is_clsend", &Dtool_DCField_is_clsend_40, METH_NOARGS, (const char *)Dtool_DCField_is_clsend_40_comment},
  {"isClsend", &Dtool_DCField_is_clsend_40, METH_NOARGS, (const char *)Dtool_DCField_is_clsend_40_comment},
  {"is_clrecv", &Dtool_DCField_is_clrecv_41, METH_NOARGS, (const char *)Dtool_DCField_is_clrecv_41_comment},
  {"isClrecv", &Dtool_DCField_is_clrecv_41, METH_NOARGS, (const char *)Dtool_DCField_is_clrecv_41_comment},
  {"is_ownsend", &Dtool_DCField_is_ownsend_42, METH_NOARGS, (const char *)Dtool_DCField_is_ownsend_42_comment},
  {"isOwnsend", &Dtool_DCField_is_ownsend_42, METH_NOARGS, (const char *)Dtool_DCField_is_ownsend_42_comment},
  {"is_ownrecv", &Dtool_DCField_is_ownrecv_43, METH_NOARGS, (const char *)Dtool_DCField_is_ownrecv_43_comment},
  {"isOwnrecv", &Dtool_DCField_is_ownrecv_43, METH_NOARGS, (const char *)Dtool_DCField_is_ownrecv_43_comment},
  {"is_airecv", &Dtool_DCField_is_airecv_44, METH_NOARGS, (const char *)Dtool_DCField_is_airecv_44_comment},
  {"isAirecv", &Dtool_DCField_is_airecv_44, METH_NOARGS, (const char *)Dtool_DCField_is_airecv_44_comment},
  {"output", &Dtool_DCField_output_45, METH_O, (const char *)Dtool_DCField_output_45_comment},
  {"write", (PyCFunction) &Dtool_DCField_write_46, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_write_46_comment},
  {"pack_args", (PyCFunction) &Dtool_DCField_pack_args_47, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_pack_args_47_comment},
  {"packArgs", (PyCFunction) &Dtool_DCField_pack_args_47, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_pack_args_47_comment},
  {"unpack_args", &Dtool_DCField_unpack_args_48, METH_O, (const char *)Dtool_DCField_unpack_args_48_comment},
  {"unpackArgs", &Dtool_DCField_unpack_args_48, METH_O, (const char *)Dtool_DCField_unpack_args_48_comment},
  {"receive_update", (PyCFunction) &Dtool_DCField_receive_update_49, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_receive_update_49_comment},
  {"receiveUpdate", (PyCFunction) &Dtool_DCField_receive_update_49, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_receive_update_49_comment},
  {"client_format_update", (PyCFunction) &Dtool_DCField_client_format_update_50, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_client_format_update_50_comment},
  {"clientFormatUpdate", (PyCFunction) &Dtool_DCField_client_format_update_50, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_client_format_update_50_comment},
  {"ai_format_update", (PyCFunction) &Dtool_DCField_ai_format_update_51, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_ai_format_update_51_comment},
  {"aiFormatUpdate", (PyCFunction) &Dtool_DCField_ai_format_update_51, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_ai_format_update_51_comment},
  {"ai_format_update_msg_type", (PyCFunction) &Dtool_DCField_ai_format_update_msg_type_52, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_ai_format_update_msg_type_52_comment},
  {"aiFormatUpdateMsgType", (PyCFunction) &Dtool_DCField_ai_format_update_msg_type_52, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_ai_format_update_msg_type_52_comment},
  {"upcast_to_DCPackerInterface", &Dtool_DCField_upcast_to_DCPackerInterface_19, METH_NOARGS, (const char *)Dtool_DCField_upcast_to_DCPackerInterface_19_comment},
  {"upcastToDCPackerInterface", &Dtool_DCField_upcast_to_DCPackerInterface_19, METH_NOARGS, (const char *)Dtool_DCField_upcast_to_DCPackerInterface_19_comment},
  {"upcast_to_DCKeywordList", &Dtool_DCField_upcast_to_DCKeywordList_21, METH_NOARGS, (const char *)Dtool_DCField_upcast_to_DCKeywordList_21_comment},
  {"upcastToDCKeywordList", &Dtool_DCField_upcast_to_DCKeywordList_21, METH_NOARGS, (const char *)Dtool_DCField_upcast_to_DCKeywordList_21_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     DCField
//////////////////
static PyObject *Dtool_Repr_DCField(PyObject *self) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     DCField
//////////////////
static PyObject *Dtool_Str_DCField(PyObject *self) {
  DCField *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_DCField = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCField = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DCField = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DCField = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DCField = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.DCField",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DCField,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_DCField,
    &Dtool_NumberMethods_DCField,
    &Dtool_SequenceMethods_DCField,
    &Dtool_MappingMethods_DCField,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_DCField,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DCField,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A single field of a Distributed Class, either atomic or molecular.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DCField,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DCField,
    PyType_GenericAlloc,
    Dtool_new_DCField,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCField,
  Dtool_UpcastInterface_DCField,
  Dtool_DowncastInterface_DCField,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DCField(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCPackerInterface(NULL);
    Dtool_PyModuleClassInit_DCKeywordList(NULL);
    Dtool_DCField._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_DCPackerInterface, (PyTypeObject *)&Dtool_DCKeywordList);
    PyObject *dict = PyDict_New();
    Dtool_DCField._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCField) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCField)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCField);
  }
}

/**
 * Python method tables for DCPackData (DCPackData)
 */
static PyMethodDef Dtool_Methods_DCPackData[] = {
  {"clear", &Dtool_DCPackData_clear_56, METH_NOARGS, (const char *)Dtool_DCPackData_clear_56_comment},
  {"get_string", &Dtool_DCPackData_get_string_57, METH_NOARGS, (const char *)Dtool_DCPackData_get_string_57_comment},
  {"getString", &Dtool_DCPackData_get_string_57, METH_NOARGS, (const char *)Dtool_DCPackData_get_string_57_comment},
  {"get_length", &Dtool_DCPackData_get_length_58, METH_NOARGS, (const char *)Dtool_DCPackData_get_length_58_comment},
  {"getLength", &Dtool_DCPackData_get_length_58, METH_NOARGS, (const char *)Dtool_DCPackData_get_length_58_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DCPackData = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_DCPackData = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.DCPackData",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DCPackData,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DCPackData,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a block of data that receives the results of DCPacker.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DCPackData,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DCPackData,
    PyType_GenericAlloc,
    Dtool_new_DCPackData,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCPackData,
  Dtool_UpcastInterface_DCPackData,
  Dtool_DowncastInterface_DCPackData,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DCPackData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DCPackData._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_DCPackData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCPackData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCPackData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCPackData);
  }
}

/**
 * Python method tables for DCPacker (DCPacker)
 */
static PyMethodDef Dtool_Methods_DCPacker[] = {
  {"clear_data", &Dtool_DCPacker_clear_data_62, METH_NOARGS, (const char *)Dtool_DCPacker_clear_data_62_comment},
  {"clearData", &Dtool_DCPacker_clear_data_62, METH_NOARGS, (const char *)Dtool_DCPacker_clear_data_62_comment},
  {"begin_pack", &Dtool_DCPacker_begin_pack_63, METH_O, (const char *)Dtool_DCPacker_begin_pack_63_comment},
  {"beginPack", &Dtool_DCPacker_begin_pack_63, METH_O, (const char *)Dtool_DCPacker_begin_pack_63_comment},
  {"end_pack", &Dtool_DCPacker_end_pack_64, METH_NOARGS, (const char *)Dtool_DCPacker_end_pack_64_comment},
  {"endPack", &Dtool_DCPacker_end_pack_64, METH_NOARGS, (const char *)Dtool_DCPacker_end_pack_64_comment},
  {"set_unpack_data", &Dtool_DCPacker_set_unpack_data_65, METH_O, (const char *)Dtool_DCPacker_set_unpack_data_65_comment},
  {"setUnpackData", &Dtool_DCPacker_set_unpack_data_65, METH_O, (const char *)Dtool_DCPacker_set_unpack_data_65_comment},
  {"begin_unpack", &Dtool_DCPacker_begin_unpack_66, METH_O, (const char *)Dtool_DCPacker_begin_unpack_66_comment},
  {"beginUnpack", &Dtool_DCPacker_begin_unpack_66, METH_O, (const char *)Dtool_DCPacker_begin_unpack_66_comment},
  {"end_unpack", &Dtool_DCPacker_end_unpack_67, METH_NOARGS, (const char *)Dtool_DCPacker_end_unpack_67_comment},
  {"endUnpack", &Dtool_DCPacker_end_unpack_67, METH_NOARGS, (const char *)Dtool_DCPacker_end_unpack_67_comment},
  {"begin_repack", &Dtool_DCPacker_begin_repack_68, METH_O, (const char *)Dtool_DCPacker_begin_repack_68_comment},
  {"beginRepack", &Dtool_DCPacker_begin_repack_68, METH_O, (const char *)Dtool_DCPacker_begin_repack_68_comment},
  {"end_repack", &Dtool_DCPacker_end_repack_69, METH_NOARGS, (const char *)Dtool_DCPacker_end_repack_69_comment},
  {"endRepack", &Dtool_DCPacker_end_repack_69, METH_NOARGS, (const char *)Dtool_DCPacker_end_repack_69_comment},
  {"seek", &Dtool_DCPacker_seek_70, METH_O, (const char *)Dtool_DCPacker_seek_70_comment},
  {"has_nested_fields", &Dtool_DCPacker_has_nested_fields_71, METH_NOARGS, (const char *)Dtool_DCPacker_has_nested_fields_71_comment},
  {"hasNestedFields", &Dtool_DCPacker_has_nested_fields_71, METH_NOARGS, (const char *)Dtool_DCPacker_has_nested_fields_71_comment},
  {"get_num_nested_fields", &Dtool_DCPacker_get_num_nested_fields_72, METH_NOARGS, (const char *)Dtool_DCPacker_get_num_nested_fields_72_comment},
  {"getNumNestedFields", &Dtool_DCPacker_get_num_nested_fields_72, METH_NOARGS, (const char *)Dtool_DCPacker_get_num_nested_fields_72_comment},
  {"more_nested_fields", &Dtool_DCPacker_more_nested_fields_73, METH_NOARGS, (const char *)Dtool_DCPacker_more_nested_fields_73_comment},
  {"moreNestedFields", &Dtool_DCPacker_more_nested_fields_73, METH_NOARGS, (const char *)Dtool_DCPacker_more_nested_fields_73_comment},
  {"get_current_parent", &Dtool_DCPacker_get_current_parent_74, METH_NOARGS, (const char *)Dtool_DCPacker_get_current_parent_74_comment},
  {"getCurrentParent", &Dtool_DCPacker_get_current_parent_74, METH_NOARGS, (const char *)Dtool_DCPacker_get_current_parent_74_comment},
  {"get_current_field", &Dtool_DCPacker_get_current_field_75, METH_NOARGS, (const char *)Dtool_DCPacker_get_current_field_75_comment},
  {"getCurrentField", &Dtool_DCPacker_get_current_field_75, METH_NOARGS, (const char *)Dtool_DCPacker_get_current_field_75_comment},
  {"get_last_switch", &Dtool_DCPacker_get_last_switch_76, METH_NOARGS, (const char *)Dtool_DCPacker_get_last_switch_76_comment},
  {"getLastSwitch", &Dtool_DCPacker_get_last_switch_76, METH_NOARGS, (const char *)Dtool_DCPacker_get_last_switch_76_comment},
  {"get_pack_type", &Dtool_DCPacker_get_pack_type_77, METH_NOARGS, (const char *)Dtool_DCPacker_get_pack_type_77_comment},
  {"getPackType", &Dtool_DCPacker_get_pack_type_77, METH_NOARGS, (const char *)Dtool_DCPacker_get_pack_type_77_comment},
  {"get_current_field_name", &Dtool_DCPacker_get_current_field_name_78, METH_NOARGS, (const char *)Dtool_DCPacker_get_current_field_name_78_comment},
  {"getCurrentFieldName", &Dtool_DCPacker_get_current_field_name_78, METH_NOARGS, (const char *)Dtool_DCPacker_get_current_field_name_78_comment},
  {"push", &Dtool_DCPacker_push_79, METH_NOARGS, (const char *)Dtool_DCPacker_push_79_comment},
  {"pop", &Dtool_DCPacker_pop_80, METH_NOARGS, (const char *)Dtool_DCPacker_pop_80_comment},
  {"pack_double", &Dtool_DCPacker_pack_double_81, METH_O, (const char *)Dtool_DCPacker_pack_double_81_comment},
  {"packDouble", &Dtool_DCPacker_pack_double_81, METH_O, (const char *)Dtool_DCPacker_pack_double_81_comment},
  {"pack_int", &Dtool_DCPacker_pack_int_82, METH_O, (const char *)Dtool_DCPacker_pack_int_82_comment},
  {"packInt", &Dtool_DCPacker_pack_int_82, METH_O, (const char *)Dtool_DCPacker_pack_int_82_comment},
  {"pack_uint", &Dtool_DCPacker_pack_uint_83, METH_O, (const char *)Dtool_DCPacker_pack_uint_83_comment},
  {"packUint", &Dtool_DCPacker_pack_uint_83, METH_O, (const char *)Dtool_DCPacker_pack_uint_83_comment},
  {"pack_int64", &Dtool_DCPacker_pack_int64_84, METH_O, (const char *)Dtool_DCPacker_pack_int64_84_comment},
  {"packInt64", &Dtool_DCPacker_pack_int64_84, METH_O, (const char *)Dtool_DCPacker_pack_int64_84_comment},
  {"pack_uint64", &Dtool_DCPacker_pack_uint64_85, METH_O, (const char *)Dtool_DCPacker_pack_uint64_85_comment},
  {"packUint64", &Dtool_DCPacker_pack_uint64_85, METH_O, (const char *)Dtool_DCPacker_pack_uint64_85_comment},
  {"pack_string", &Dtool_DCPacker_pack_string_86, METH_O, (const char *)Dtool_DCPacker_pack_string_86_comment},
  {"packString", &Dtool_DCPacker_pack_string_86, METH_O, (const char *)Dtool_DCPacker_pack_string_86_comment},
  {"pack_literal_value", &Dtool_DCPacker_pack_literal_value_87, METH_O, (const char *)Dtool_DCPacker_pack_literal_value_87_comment},
  {"packLiteralValue", &Dtool_DCPacker_pack_literal_value_87, METH_O, (const char *)Dtool_DCPacker_pack_literal_value_87_comment},
  {"pack_default_value", &Dtool_DCPacker_pack_default_value_88, METH_NOARGS, (const char *)Dtool_DCPacker_pack_default_value_88_comment},
  {"packDefaultValue", &Dtool_DCPacker_pack_default_value_88, METH_NOARGS, (const char *)Dtool_DCPacker_pack_default_value_88_comment},
  {"unpack_double", &Dtool_DCPacker_unpack_double_89, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_double_89_comment},
  {"unpackDouble", &Dtool_DCPacker_unpack_double_89, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_double_89_comment},
  {"unpack_int", &Dtool_DCPacker_unpack_int_90, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_int_90_comment},
  {"unpackInt", &Dtool_DCPacker_unpack_int_90, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_int_90_comment},
  {"unpack_uint", &Dtool_DCPacker_unpack_uint_91, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_uint_91_comment},
  {"unpackUint", &Dtool_DCPacker_unpack_uint_91, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_uint_91_comment},
  {"unpack_int64", &Dtool_DCPacker_unpack_int64_92, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_int64_92_comment},
  {"unpackInt64", &Dtool_DCPacker_unpack_int64_92, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_int64_92_comment},
  {"unpack_uint64", &Dtool_DCPacker_unpack_uint64_93, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_uint64_93_comment},
  {"unpackUint64", &Dtool_DCPacker_unpack_uint64_93, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_uint64_93_comment},
  {"unpack_string", &Dtool_DCPacker_unpack_string_94, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_string_94_comment},
  {"unpackString", &Dtool_DCPacker_unpack_string_94, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_string_94_comment},
  {"unpack_literal_value", &Dtool_DCPacker_unpack_literal_value_95, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_literal_value_95_comment},
  {"unpackLiteralValue", &Dtool_DCPacker_unpack_literal_value_95, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_literal_value_95_comment},
  {"unpack_validate", &Dtool_DCPacker_unpack_validate_96, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_validate_96_comment},
  {"unpackValidate", &Dtool_DCPacker_unpack_validate_96, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_validate_96_comment},
  {"unpack_skip", &Dtool_DCPacker_unpack_skip_97, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_skip_97_comment},
  {"unpackSkip", &Dtool_DCPacker_unpack_skip_97, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_skip_97_comment},
  {"pack_object", &Dtool_DCPacker_pack_object_98, METH_O, (const char *)Dtool_DCPacker_pack_object_98_comment},
  {"packObject", &Dtool_DCPacker_pack_object_98, METH_O, (const char *)Dtool_DCPacker_pack_object_98_comment},
  {"unpack_object", &Dtool_DCPacker_unpack_object_99, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_object_99_comment},
  {"unpackObject", &Dtool_DCPacker_unpack_object_99, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_object_99_comment},
  {"parse_and_pack", &Dtool_DCPacker_parse_and_pack_100, METH_O, (const char *)Dtool_DCPacker_parse_and_pack_100_comment},
  {"parseAndPack", &Dtool_DCPacker_parse_and_pack_100, METH_O, (const char *)Dtool_DCPacker_parse_and_pack_100_comment},
  {"unpack_and_format", (PyCFunction) &Dtool_DCPacker_unpack_and_format_101, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCPacker_unpack_and_format_101_comment},
  {"unpackAndFormat", (PyCFunction) &Dtool_DCPacker_unpack_and_format_101, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCPacker_unpack_and_format_101_comment},
  {"had_parse_error", &Dtool_DCPacker_had_parse_error_102, METH_NOARGS, (const char *)Dtool_DCPacker_had_parse_error_102_comment},
  {"hadParseError", &Dtool_DCPacker_had_parse_error_102, METH_NOARGS, (const char *)Dtool_DCPacker_had_parse_error_102_comment},
  {"had_pack_error", &Dtool_DCPacker_had_pack_error_103, METH_NOARGS, (const char *)Dtool_DCPacker_had_pack_error_103_comment},
  {"hadPackError", &Dtool_DCPacker_had_pack_error_103, METH_NOARGS, (const char *)Dtool_DCPacker_had_pack_error_103_comment},
  {"had_range_error", &Dtool_DCPacker_had_range_error_104, METH_NOARGS, (const char *)Dtool_DCPacker_had_range_error_104_comment},
  {"hadRangeError", &Dtool_DCPacker_had_range_error_104, METH_NOARGS, (const char *)Dtool_DCPacker_had_range_error_104_comment},
  {"had_error", &Dtool_DCPacker_had_error_105, METH_NOARGS, (const char *)Dtool_DCPacker_had_error_105_comment},
  {"hadError", &Dtool_DCPacker_had_error_105, METH_NOARGS, (const char *)Dtool_DCPacker_had_error_105_comment},
  {"get_num_unpacked_bytes", &Dtool_DCPacker_get_num_unpacked_bytes_106, METH_NOARGS, (const char *)Dtool_DCPacker_get_num_unpacked_bytes_106_comment},
  {"getNumUnpackedBytes", &Dtool_DCPacker_get_num_unpacked_bytes_106, METH_NOARGS, (const char *)Dtool_DCPacker_get_num_unpacked_bytes_106_comment},
  {"get_length", &Dtool_DCPacker_get_length_107, METH_NOARGS, (const char *)Dtool_DCPacker_get_length_107_comment},
  {"getLength", &Dtool_DCPacker_get_length_107, METH_NOARGS, (const char *)Dtool_DCPacker_get_length_107_comment},
  {"get_string", &Dtool_DCPacker_get_string_108, METH_NOARGS, (const char *)Dtool_DCPacker_get_string_108_comment},
  {"getString", &Dtool_DCPacker_get_string_108, METH_NOARGS, (const char *)Dtool_DCPacker_get_string_108_comment},
  {"get_unpack_length", &Dtool_DCPacker_get_unpack_length_109, METH_NOARGS, (const char *)Dtool_DCPacker_get_unpack_length_109_comment},
  {"getUnpackLength", &Dtool_DCPacker_get_unpack_length_109, METH_NOARGS, (const char *)Dtool_DCPacker_get_unpack_length_109_comment},
  {"get_unpack_string", &Dtool_DCPacker_get_unpack_string_110, METH_NOARGS, (const char *)Dtool_DCPacker_get_unpack_string_110_comment},
  {"getUnpackString", &Dtool_DCPacker_get_unpack_string_110, METH_NOARGS, (const char *)Dtool_DCPacker_get_unpack_string_110_comment},
  {"get_num_stack_elements_ever_allocated", &Dtool_DCPacker_get_num_stack_elements_ever_allocated_111, METH_NOARGS | METH_STATIC, (const char *)Dtool_DCPacker_get_num_stack_elements_ever_allocated_111_comment},
  {"getNumStackElementsEverAllocated", &Dtool_DCPacker_get_num_stack_elements_ever_allocated_111, METH_NOARGS | METH_STATIC, (const char *)Dtool_DCPacker_get_num_stack_elements_ever_allocated_111_comment},
  {"raw_pack_int8", &Dtool_DCPacker_raw_pack_int8_112, METH_O, (const char *)Dtool_DCPacker_raw_pack_int8_112_comment},
  {"rawPackInt8", &Dtool_DCPacker_raw_pack_int8_112, METH_O, (const char *)Dtool_DCPacker_raw_pack_int8_112_comment},
  {"raw_pack_int16", &Dtool_DCPacker_raw_pack_int16_113, METH_O, (const char *)Dtool_DCPacker_raw_pack_int16_113_comment},
  {"rawPackInt16", &Dtool_DCPacker_raw_pack_int16_113, METH_O, (const char *)Dtool_DCPacker_raw_pack_int16_113_comment},
  {"raw_pack_int32", &Dtool_DCPacker_raw_pack_int32_114, METH_O, (const char *)Dtool_DCPacker_raw_pack_int32_114_comment},
  {"rawPackInt32", &Dtool_DCPacker_raw_pack_int32_114, METH_O, (const char *)Dtool_DCPacker_raw_pack_int32_114_comment},
  {"raw_pack_int64", &Dtool_DCPacker_raw_pack_int64_115, METH_O, (const char *)Dtool_DCPacker_raw_pack_int64_115_comment},
  {"rawPackInt64", &Dtool_DCPacker_raw_pack_int64_115, METH_O, (const char *)Dtool_DCPacker_raw_pack_int64_115_comment},
  {"raw_pack_uint8", &Dtool_DCPacker_raw_pack_uint8_116, METH_O, (const char *)Dtool_DCPacker_raw_pack_uint8_116_comment},
  {"rawPackUint8", &Dtool_DCPacker_raw_pack_uint8_116, METH_O, (const char *)Dtool_DCPacker_raw_pack_uint8_116_comment},
  {"raw_pack_uint16", &Dtool_DCPacker_raw_pack_uint16_117, METH_O, (const char *)Dtool_DCPacker_raw_pack_uint16_117_comment},
  {"rawPackUint16", &Dtool_DCPacker_raw_pack_uint16_117, METH_O, (const char *)Dtool_DCPacker_raw_pack_uint16_117_comment},
  {"raw_pack_uint32", &Dtool_DCPacker_raw_pack_uint32_118, METH_O, (const char *)Dtool_DCPacker_raw_pack_uint32_118_comment},
  {"rawPackUint32", &Dtool_DCPacker_raw_pack_uint32_118, METH_O, (const char *)Dtool_DCPacker_raw_pack_uint32_118_comment},
  {"raw_pack_uint64", &Dtool_DCPacker_raw_pack_uint64_119, METH_O, (const char *)Dtool_DCPacker_raw_pack_uint64_119_comment},
  {"rawPackUint64", &Dtool_DCPacker_raw_pack_uint64_119, METH_O, (const char *)Dtool_DCPacker_raw_pack_uint64_119_comment},
  {"raw_pack_float64", &Dtool_DCPacker_raw_pack_float64_120, METH_O, (const char *)Dtool_DCPacker_raw_pack_float64_120_comment},
  {"rawPackFloat64", &Dtool_DCPacker_raw_pack_float64_120, METH_O, (const char *)Dtool_DCPacker_raw_pack_float64_120_comment},
  {"raw_pack_string", &Dtool_DCPacker_raw_pack_string_121, METH_O, (const char *)Dtool_DCPacker_raw_pack_string_121_comment},
  {"rawPackString", &Dtool_DCPacker_raw_pack_string_121, METH_O, (const char *)Dtool_DCPacker_raw_pack_string_121_comment},
  {"raw_unpack_int8", &Dtool_DCPacker_raw_unpack_int8_122, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_int8_122_comment},
  {"rawUnpackInt8", &Dtool_DCPacker_raw_unpack_int8_122, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_int8_122_comment},
  {"raw_unpack_int16", &Dtool_DCPacker_raw_unpack_int16_123, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_int16_123_comment},
  {"rawUnpackInt16", &Dtool_DCPacker_raw_unpack_int16_123, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_int16_123_comment},
  {"raw_unpack_int32", &Dtool_DCPacker_raw_unpack_int32_124, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_int32_124_comment},
  {"rawUnpackInt32", &Dtool_DCPacker_raw_unpack_int32_124, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_int32_124_comment},
  {"raw_unpack_int64", &Dtool_DCPacker_raw_unpack_int64_125, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_int64_125_comment},
  {"rawUnpackInt64", &Dtool_DCPacker_raw_unpack_int64_125, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_int64_125_comment},
  {"raw_unpack_uint8", &Dtool_DCPacker_raw_unpack_uint8_126, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_uint8_126_comment},
  {"rawUnpackUint8", &Dtool_DCPacker_raw_unpack_uint8_126, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_uint8_126_comment},
  {"raw_unpack_uint16", &Dtool_DCPacker_raw_unpack_uint16_127, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_uint16_127_comment},
  {"rawUnpackUint16", &Dtool_DCPacker_raw_unpack_uint16_127, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_uint16_127_comment},
  {"raw_unpack_uint32", &Dtool_DCPacker_raw_unpack_uint32_128, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_uint32_128_comment},
  {"rawUnpackUint32", &Dtool_DCPacker_raw_unpack_uint32_128, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_uint32_128_comment},
  {"raw_unpack_uint64", &Dtool_DCPacker_raw_unpack_uint64_129, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_uint64_129_comment},
  {"rawUnpackUint64", &Dtool_DCPacker_raw_unpack_uint64_129, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_uint64_129_comment},
  {"raw_unpack_float64", &Dtool_DCPacker_raw_unpack_float64_130, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_float64_130_comment},
  {"rawUnpackFloat64", &Dtool_DCPacker_raw_unpack_float64_130, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_float64_130_comment},
  {"raw_unpack_string", &Dtool_DCPacker_raw_unpack_string_131, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_string_131_comment},
  {"rawUnpackString", &Dtool_DCPacker_raw_unpack_string_131, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_string_131_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DCPacker = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_DCPacker = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.DCPacker",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DCPacker,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DCPacker,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class can be used for packing a series of numeric and string data into\n"
    " * a binary stream, according to the DC specification.\n"
    " *\n"
    " * See also direct/src/doc/dcPacker.txt for a more complete description and\n"
    " * examples of using this class.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DCPacker,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DCPacker,
    PyType_GenericAlloc,
    Dtool_new_DCPacker,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCPacker,
  Dtool_UpcastInterface_DCPacker,
  Dtool_DowncastInterface_DCPacker,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DCPacker(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DCPacker._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_DCPacker._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCPacker) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCPacker)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCPacker);
  }
}

/**
 * Python method tables for DCParameter (DCParameter)
 */
static PyMethodDef Dtool_Methods_DCParameter[] = {
  {"as_simple_parameter", &Dtool_DCParameter_as_simple_parameter_133, METH_NOARGS, (const char *)Dtool_DCParameter_as_simple_parameter_133_comment},
  {"asSimpleParameter", &Dtool_DCParameter_as_simple_parameter_133, METH_NOARGS, (const char *)Dtool_DCParameter_as_simple_parameter_133_comment},
  {"as_array_parameter", &Dtool_DCParameter_as_array_parameter_134, METH_NOARGS, (const char *)Dtool_DCParameter_as_array_parameter_134_comment},
  {"asArrayParameter", &Dtool_DCParameter_as_array_parameter_134, METH_NOARGS, (const char *)Dtool_DCParameter_as_array_parameter_134_comment},
  {"make_copy", &Dtool_DCParameter_make_copy_135, METH_NOARGS, (const char *)Dtool_DCParameter_make_copy_135_comment},
  {"makeCopy", &Dtool_DCParameter_make_copy_135, METH_NOARGS, (const char *)Dtool_DCParameter_make_copy_135_comment},
  {"is_valid", &Dtool_DCParameter_is_valid_136, METH_NOARGS, (const char *)Dtool_DCParameter_is_valid_136_comment},
  {"isValid", &Dtool_DCParameter_is_valid_136, METH_NOARGS, (const char *)Dtool_DCParameter_is_valid_136_comment},
  {"get_typedef", &Dtool_DCParameter_get_typedef_137, METH_NOARGS, (const char *)Dtool_DCParameter_get_typedef_137_comment},
  {"getTypedef", &Dtool_DCParameter_get_typedef_137, METH_NOARGS, (const char *)Dtool_DCParameter_get_typedef_137_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DCParameter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCParameter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DCParameter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DCParameter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DCParameter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.DCParameter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DCParameter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DCParameter,
    &Dtool_SequenceMethods_DCParameter,
    &Dtool_MappingMethods_DCParameter,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DCParameter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Represents the type specification for a single parameter within a field\n"
    " * specification.  This may be a simple type, or it may be a class or an array\n"
    " * reference.\n"
    " *\n"
    " * This may also be a typedef reference to another type, which has the same\n"
    " * properties as the referenced type, but a different name.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DCParameter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DCParameter,
    PyType_GenericAlloc,
    Dtool_new_DCParameter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCParameter,
  Dtool_UpcastInterface_DCParameter,
  Dtool_DowncastInterface_DCParameter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DCParameter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCField(NULL);
    Dtool_DCParameter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCField);
    PyObject *dict = PyDict_New();
    Dtool_DCParameter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCParameter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCParameter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCParameter);
  }
}

/**
 * Python method tables for DCArrayParameter (DCArrayParameter)
 */
static PyMethodDef Dtool_Methods_DCArrayParameter[] = {
  {"get_element_type", &Dtool_DCArrayParameter_get_element_type_139, METH_NOARGS, (const char *)Dtool_DCArrayParameter_get_element_type_139_comment},
  {"getElementType", &Dtool_DCArrayParameter_get_element_type_139, METH_NOARGS, (const char *)Dtool_DCArrayParameter_get_element_type_139_comment},
  {"get_array_size", &Dtool_DCArrayParameter_get_array_size_140, METH_NOARGS, (const char *)Dtool_DCArrayParameter_get_array_size_140_comment},
  {"getArraySize", &Dtool_DCArrayParameter_get_array_size_140, METH_NOARGS, (const char *)Dtool_DCArrayParameter_get_array_size_140_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DCArrayParameter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCArrayParameter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DCArrayParameter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DCArrayParameter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DCArrayParameter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.DCArrayParameter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DCArrayParameter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DCArrayParameter,
    &Dtool_SequenceMethods_DCArrayParameter,
    &Dtool_MappingMethods_DCArrayParameter,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DCArrayParameter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents an array of some other kind of object, meaning this\n"
    " * parameter type accepts an arbitrary (or possibly fixed) number of nested\n"
    " * fields, all of which are of the same type.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DCArrayParameter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DCArrayParameter,
    PyType_GenericAlloc,
    Dtool_new_DCArrayParameter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCArrayParameter,
  Dtool_UpcastInterface_DCArrayParameter,
  Dtool_DowncastInterface_DCArrayParameter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DCArrayParameter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCParameter(NULL);
    Dtool_DCArrayParameter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCParameter);
    PyObject *dict = PyDict_New();
    Dtool_DCArrayParameter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCArrayParameter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCArrayParameter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCArrayParameter);
  }
}

/**
 * Python method tables for DCAtomicField (DCAtomicField)
 */
static PyMethodDef Dtool_Methods_DCAtomicField[] = {
  {"get_num_elements", &Dtool_DCAtomicField_get_num_elements_142, METH_NOARGS, (const char *)Dtool_DCAtomicField_get_num_elements_142_comment},
  {"getNumElements", &Dtool_DCAtomicField_get_num_elements_142, METH_NOARGS, (const char *)Dtool_DCAtomicField_get_num_elements_142_comment},
  {"get_element", &Dtool_DCAtomicField_get_element_143, METH_O, (const char *)Dtool_DCAtomicField_get_element_143_comment},
  {"getElement", &Dtool_DCAtomicField_get_element_143, METH_O, (const char *)Dtool_DCAtomicField_get_element_143_comment},
  {"get_element_default", &Dtool_DCAtomicField_get_element_default_144, METH_O, (const char *)Dtool_DCAtomicField_get_element_default_144_comment},
  {"getElementDefault", &Dtool_DCAtomicField_get_element_default_144, METH_O, (const char *)Dtool_DCAtomicField_get_element_default_144_comment},
  {"has_element_default", &Dtool_DCAtomicField_has_element_default_145, METH_O, (const char *)Dtool_DCAtomicField_has_element_default_145_comment},
  {"hasElementDefault", &Dtool_DCAtomicField_has_element_default_145, METH_O, (const char *)Dtool_DCAtomicField_has_element_default_145_comment},
  {"get_element_name", &Dtool_DCAtomicField_get_element_name_146, METH_O, (const char *)Dtool_DCAtomicField_get_element_name_146_comment},
  {"getElementName", &Dtool_DCAtomicField_get_element_name_146, METH_O, (const char *)Dtool_DCAtomicField_get_element_name_146_comment},
  {"get_element_type", &Dtool_DCAtomicField_get_element_type_147, METH_O, (const char *)Dtool_DCAtomicField_get_element_type_147_comment},
  {"getElementType", &Dtool_DCAtomicField_get_element_type_147, METH_O, (const char *)Dtool_DCAtomicField_get_element_type_147_comment},
  {"get_element_divisor", &Dtool_DCAtomicField_get_element_divisor_148, METH_O, (const char *)Dtool_DCAtomicField_get_element_divisor_148_comment},
  {"getElementDivisor", &Dtool_DCAtomicField_get_element_divisor_148, METH_O, (const char *)Dtool_DCAtomicField_get_element_divisor_148_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DCAtomicField = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCAtomicField = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DCAtomicField = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DCAtomicField = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DCAtomicField = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.DCAtomicField",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DCAtomicField,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DCAtomicField,
    &Dtool_SequenceMethods_DCAtomicField,
    &Dtool_MappingMethods_DCAtomicField,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DCAtomicField,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A single atomic field of a Distributed Class, as read from a .dc file.\n"
    " * This defines an interface to the Distributed Class, and is always\n"
    " * implemented as a remote procedure method.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DCAtomicField,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DCAtomicField,
    PyType_GenericAlloc,
    Dtool_new_DCAtomicField,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCAtomicField,
  Dtool_UpcastInterface_DCAtomicField,
  Dtool_DowncastInterface_DCAtomicField,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DCAtomicField(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCField(NULL);
    Dtool_DCAtomicField._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCField);
    PyObject *dict = PyDict_New();
    Dtool_DCAtomicField._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCAtomicField) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCAtomicField)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCAtomicField);
  }
}

/**
 * Python method tables for DCDeclaration (DCDeclaration)
 */
static PyMethodDef Dtool_Methods_DCDeclaration[] = {
  {"as_class", &Dtool_DCDeclaration_as_class_151, METH_NOARGS, (const char *)Dtool_DCDeclaration_as_class_151_comment},
  {"asClass", &Dtool_DCDeclaration_as_class_151, METH_NOARGS, (const char *)Dtool_DCDeclaration_as_class_151_comment},
  {"as_switch", &Dtool_DCDeclaration_as_switch_152, METH_NOARGS, (const char *)Dtool_DCDeclaration_as_switch_152_comment},
  {"asSwitch", &Dtool_DCDeclaration_as_switch_152, METH_NOARGS, (const char *)Dtool_DCDeclaration_as_switch_152_comment},
  {"output", &Dtool_DCDeclaration_output_153, METH_O, (const char *)Dtool_DCDeclaration_output_153_comment},
  {"write", (PyCFunction) &Dtool_DCDeclaration_write_154, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCDeclaration_write_154_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     DCDeclaration
//////////////////
static PyObject *Dtool_Repr_DCDeclaration(PyObject *self) {
  DCDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCDeclaration, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     DCDeclaration
//////////////////
static PyObject *Dtool_Str_DCDeclaration(PyObject *self) {
  DCDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCDeclaration, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_DCDeclaration = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_DCDeclaration = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.DCDeclaration",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DCDeclaration,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_DCDeclaration,
    &Dtool_NumberMethods_DCDeclaration,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_DCDeclaration,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a common interface for a declaration in a DC file.  Currently, this\n"
    " * is either a class or a typedef declaration (import declarations are still\n"
    " * collected together at the top, and don't inherit from this object).  Its\n"
    " * only purpose is so that classes and typedefs can be stored in one list\n"
    " * together so they can be ordered correctly on output.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DCDeclaration,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DCDeclaration,
    PyType_GenericAlloc,
    Dtool_new_DCDeclaration,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCDeclaration,
  Dtool_UpcastInterface_DCDeclaration,
  Dtool_DowncastInterface_DCDeclaration,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DCDeclaration(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DCDeclaration._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_DCDeclaration._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCDeclaration) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCDeclaration)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCDeclaration);
  }
}

/**
 * Python method tables for DCClass (DCClass)
 */
static PyMethodDef Dtool_Methods_DCClass[] = {
  {"get_dc_file", &Dtool_DCClass_get_dc_file_156, METH_NOARGS, (const char *)Dtool_DCClass_get_dc_file_156_comment},
  {"getDcFile", &Dtool_DCClass_get_dc_file_156, METH_NOARGS, (const char *)Dtool_DCClass_get_dc_file_156_comment},
  {"get_name", &Dtool_DCClass_get_name_157, METH_NOARGS, (const char *)Dtool_DCClass_get_name_157_comment},
  {"getName", &Dtool_DCClass_get_name_157, METH_NOARGS, (const char *)Dtool_DCClass_get_name_157_comment},
  {"get_number", &Dtool_DCClass_get_number_158, METH_NOARGS, (const char *)Dtool_DCClass_get_number_158_comment},
  {"getNumber", &Dtool_DCClass_get_number_158, METH_NOARGS, (const char *)Dtool_DCClass_get_number_158_comment},
  {"get_num_parents", &Dtool_DCClass_get_num_parents_159, METH_NOARGS, (const char *)Dtool_DCClass_get_num_parents_159_comment},
  {"getNumParents", &Dtool_DCClass_get_num_parents_159, METH_NOARGS, (const char *)Dtool_DCClass_get_num_parents_159_comment},
  {"get_parent", &Dtool_DCClass_get_parent_160, METH_O, (const char *)Dtool_DCClass_get_parent_160_comment},
  {"getParent", &Dtool_DCClass_get_parent_160, METH_O, (const char *)Dtool_DCClass_get_parent_160_comment},
  {"has_constructor", &Dtool_DCClass_has_constructor_161, METH_NOARGS, (const char *)Dtool_DCClass_has_constructor_161_comment},
  {"hasConstructor", &Dtool_DCClass_has_constructor_161, METH_NOARGS, (const char *)Dtool_DCClass_has_constructor_161_comment},
  {"get_constructor", &Dtool_DCClass_get_constructor_162, METH_NOARGS, (const char *)Dtool_DCClass_get_constructor_162_comment},
  {"getConstructor", &Dtool_DCClass_get_constructor_162, METH_NOARGS, (const char *)Dtool_DCClass_get_constructor_162_comment},
  {"get_num_fields", &Dtool_DCClass_get_num_fields_163, METH_NOARGS, (const char *)Dtool_DCClass_get_num_fields_163_comment},
  {"getNumFields", &Dtool_DCClass_get_num_fields_163, METH_NOARGS, (const char *)Dtool_DCClass_get_num_fields_163_comment},
  {"get_field", &Dtool_DCClass_get_field_164, METH_O, (const char *)Dtool_DCClass_get_field_164_comment},
  {"getField", &Dtool_DCClass_get_field_164, METH_O, (const char *)Dtool_DCClass_get_field_164_comment},
  {"get_field_by_name", &Dtool_DCClass_get_field_by_name_165, METH_O, (const char *)Dtool_DCClass_get_field_by_name_165_comment},
  {"getFieldByName", &Dtool_DCClass_get_field_by_name_165, METH_O, (const char *)Dtool_DCClass_get_field_by_name_165_comment},
  {"get_field_by_index", &Dtool_DCClass_get_field_by_index_166, METH_O, (const char *)Dtool_DCClass_get_field_by_index_166_comment},
  {"getFieldByIndex", &Dtool_DCClass_get_field_by_index_166, METH_O, (const char *)Dtool_DCClass_get_field_by_index_166_comment},
  {"get_num_inherited_fields", &Dtool_DCClass_get_num_inherited_fields_167, METH_NOARGS, (const char *)Dtool_DCClass_get_num_inherited_fields_167_comment},
  {"getNumInheritedFields", &Dtool_DCClass_get_num_inherited_fields_167, METH_NOARGS, (const char *)Dtool_DCClass_get_num_inherited_fields_167_comment},
  {"get_inherited_field", &Dtool_DCClass_get_inherited_field_168, METH_O, (const char *)Dtool_DCClass_get_inherited_field_168_comment},
  {"getInheritedField", &Dtool_DCClass_get_inherited_field_168, METH_O, (const char *)Dtool_DCClass_get_inherited_field_168_comment},
  {"is_struct", &Dtool_DCClass_is_struct_169, METH_NOARGS, (const char *)Dtool_DCClass_is_struct_169_comment},
  {"isStruct", &Dtool_DCClass_is_struct_169, METH_NOARGS, (const char *)Dtool_DCClass_is_struct_169_comment},
  {"is_bogus_class", &Dtool_DCClass_is_bogus_class_170, METH_NOARGS, (const char *)Dtool_DCClass_is_bogus_class_170_comment},
  {"isBogusClass", &Dtool_DCClass_is_bogus_class_170, METH_NOARGS, (const char *)Dtool_DCClass_is_bogus_class_170_comment},
  {"inherits_from_bogus_class", &Dtool_DCClass_inherits_from_bogus_class_171, METH_NOARGS, (const char *)Dtool_DCClass_inherits_from_bogus_class_171_comment},
  {"inheritsFromBogusClass", &Dtool_DCClass_inherits_from_bogus_class_171, METH_NOARGS, (const char *)Dtool_DCClass_inherits_from_bogus_class_171_comment},
  {"start_generate", &Dtool_DCClass_start_generate_172, METH_NOARGS, (const char *)Dtool_DCClass_start_generate_172_comment},
  {"startGenerate", &Dtool_DCClass_start_generate_172, METH_NOARGS, (const char *)Dtool_DCClass_start_generate_172_comment},
  {"stop_generate", &Dtool_DCClass_stop_generate_173, METH_NOARGS, (const char *)Dtool_DCClass_stop_generate_173_comment},
  {"stopGenerate", &Dtool_DCClass_stop_generate_173, METH_NOARGS, (const char *)Dtool_DCClass_stop_generate_173_comment},
  {"output", &Dtool_DCClass_output_174, METH_O, (const char *)Dtool_DCClass_output_174_comment},
  {"has_class_def", &Dtool_DCClass_has_class_def_175, METH_NOARGS, (const char *)Dtool_DCClass_has_class_def_175_comment},
  {"hasClassDef", &Dtool_DCClass_has_class_def_175, METH_NOARGS, (const char *)Dtool_DCClass_has_class_def_175_comment},
  {"set_class_def", &Dtool_DCClass_set_class_def_176, METH_O, (const char *)Dtool_DCClass_set_class_def_176_comment},
  {"setClassDef", &Dtool_DCClass_set_class_def_176, METH_O, (const char *)Dtool_DCClass_set_class_def_176_comment},
  {"get_class_def", &Dtool_DCClass_get_class_def_177, METH_NOARGS, (const char *)Dtool_DCClass_get_class_def_177_comment},
  {"getClassDef", &Dtool_DCClass_get_class_def_177, METH_NOARGS, (const char *)Dtool_DCClass_get_class_def_177_comment},
  {"has_owner_class_def", &Dtool_DCClass_has_owner_class_def_178, METH_NOARGS, (const char *)Dtool_DCClass_has_owner_class_def_178_comment},
  {"hasOwnerClassDef", &Dtool_DCClass_has_owner_class_def_178, METH_NOARGS, (const char *)Dtool_DCClass_has_owner_class_def_178_comment},
  {"set_owner_class_def", &Dtool_DCClass_set_owner_class_def_179, METH_O, (const char *)Dtool_DCClass_set_owner_class_def_179_comment},
  {"setOwnerClassDef", &Dtool_DCClass_set_owner_class_def_179, METH_O, (const char *)Dtool_DCClass_set_owner_class_def_179_comment},
  {"get_owner_class_def", &Dtool_DCClass_get_owner_class_def_180, METH_NOARGS, (const char *)Dtool_DCClass_get_owner_class_def_180_comment},
  {"getOwnerClassDef", &Dtool_DCClass_get_owner_class_def_180, METH_NOARGS, (const char *)Dtool_DCClass_get_owner_class_def_180_comment},
  {"receive_update", (PyCFunction) &Dtool_DCClass_receive_update_181, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_181_comment},
  {"receiveUpdate", (PyCFunction) &Dtool_DCClass_receive_update_181, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_181_comment},
  {"receive_update_broadcast_required", (PyCFunction) &Dtool_DCClass_receive_update_broadcast_required_182, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_broadcast_required_182_comment},
  {"receiveUpdateBroadcastRequired", (PyCFunction) &Dtool_DCClass_receive_update_broadcast_required_182, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_broadcast_required_182_comment},
  {"receive_update_broadcast_required_owner", (PyCFunction) &Dtool_DCClass_receive_update_broadcast_required_owner_183, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_broadcast_required_owner_183_comment},
  {"receiveUpdateBroadcastRequiredOwner", (PyCFunction) &Dtool_DCClass_receive_update_broadcast_required_owner_183, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_broadcast_required_owner_183_comment},
  {"receive_update_all_required", (PyCFunction) &Dtool_DCClass_receive_update_all_required_184, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_all_required_184_comment},
  {"receiveUpdateAllRequired", (PyCFunction) &Dtool_DCClass_receive_update_all_required_184, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_all_required_184_comment},
  {"receive_update_other", (PyCFunction) &Dtool_DCClass_receive_update_other_185, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_other_185_comment},
  {"receiveUpdateOther", (PyCFunction) &Dtool_DCClass_receive_update_other_185, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_other_185_comment},
  {"direct_update", (PyCFunction) &Dtool_DCClass_direct_update_186, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_direct_update_186_comment},
  {"directUpdate", (PyCFunction) &Dtool_DCClass_direct_update_186, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_direct_update_186_comment},
  {"pack_required_field", (PyCFunction) &Dtool_DCClass_pack_required_field_187, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_pack_required_field_187_comment},
  {"packRequiredField", (PyCFunction) &Dtool_DCClass_pack_required_field_187, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_pack_required_field_187_comment},
  {"client_format_update", (PyCFunction) &Dtool_DCClass_client_format_update_188, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_client_format_update_188_comment},
  {"clientFormatUpdate", (PyCFunction) &Dtool_DCClass_client_format_update_188, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_client_format_update_188_comment},
  {"ai_format_update", (PyCFunction) &Dtool_DCClass_ai_format_update_189, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_ai_format_update_189_comment},
  {"aiFormatUpdate", (PyCFunction) &Dtool_DCClass_ai_format_update_189, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_ai_format_update_189_comment},
  {"ai_format_update_msg_type", (PyCFunction) &Dtool_DCClass_ai_format_update_msg_type_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_ai_format_update_msg_type_190_comment},
  {"aiFormatUpdateMsgType", (PyCFunction) &Dtool_DCClass_ai_format_update_msg_type_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_ai_format_update_msg_type_190_comment},
  {"ai_format_generate", (PyCFunction) &Dtool_DCClass_ai_format_generate_191, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_ai_format_generate_191_comment},
  {"aiFormatGenerate", (PyCFunction) &Dtool_DCClass_ai_format_generate_191, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_ai_format_generate_191_comment},
  {"client_format_generate_CMU", (PyCFunction) &Dtool_DCClass_client_format_generate_CMU_192, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_client_format_generate_CMU_192_comment},
  {"clientFormatGenerateCMU", (PyCFunction) &Dtool_DCClass_client_format_generate_CMU_192, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_client_format_generate_CMU_192_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     DCClass
//////////////////
static PyObject *Dtool_Repr_DCClass(PyObject *self) {
  DCClass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_DCClass = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCClass = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DCClass = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DCClass = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DCClass = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.DCClass",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DCClass,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_DCClass,
    &Dtool_NumberMethods_DCClass,
    &Dtool_SequenceMethods_DCClass,
    &Dtool_MappingMethods_DCClass,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_DCClass,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DCClass,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a particular DistributedClass as read from an input .dc file.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DCClass,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DCClass,
    PyType_GenericAlloc,
    Dtool_new_DCClass,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCClass,
  Dtool_UpcastInterface_DCClass,
  Dtool_DowncastInterface_DCClass,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DCClass(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCDeclaration(NULL);
    Dtool_DCClass._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCDeclaration);
    PyObject *dict = PyDict_New();
    Dtool_DCClass._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCClass) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCClass)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCClass);
  }
}

/**
 * Python method tables for DCClassParameter (DCClassParameter)
 */
static PyMethodDef Dtool_Methods_DCClassParameter[] = {
  {"get_class", &Dtool_DCClassParameter_get_class_194, METH_NOARGS, (const char *)Dtool_DCClassParameter_get_class_194_comment},
  {"getClass", &Dtool_DCClassParameter_get_class_194, METH_NOARGS, (const char *)Dtool_DCClassParameter_get_class_194_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DCClassParameter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCClassParameter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DCClassParameter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DCClassParameter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DCClassParameter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.DCClassParameter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DCClassParameter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DCClassParameter,
    &Dtool_SequenceMethods_DCClassParameter,
    &Dtool_MappingMethods_DCClassParameter,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DCClassParameter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents a class (or struct) object used as a parameter itself.\n"
    " * This means that all the fields of the class get packed into the message.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DCClassParameter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DCClassParameter,
    PyType_GenericAlloc,
    Dtool_new_DCClassParameter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCClassParameter,
  Dtool_UpcastInterface_DCClassParameter,
  Dtool_DowncastInterface_DCClassParameter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DCClassParameter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCParameter(NULL);
    Dtool_DCClassParameter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCParameter);
    PyObject *dict = PyDict_New();
    Dtool_DCClassParameter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCClassParameter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCClassParameter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCClassParameter);
  }
}

/**
 * Python method tables for DCFile (DCFile)
 */
static PyMethodDef Dtool_Methods_DCFile[] = {
  {"clear", &Dtool_DCFile_clear_199, METH_NOARGS, (const char *)Dtool_DCFile_clear_199_comment},
  {"read_all", &Dtool_DCFile_read_all_200, METH_NOARGS, (const char *)Dtool_DCFile_read_all_200_comment},
  {"readAll", &Dtool_DCFile_read_all_200, METH_NOARGS, (const char *)Dtool_DCFile_read_all_200_comment},
  {"read", (PyCFunction) &Dtool_DCFile_read_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCFile_read_201_comment},
  {"write", (PyCFunction) &Dtool_DCFile_write_202, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCFile_write_202_comment},
  {"get_num_classes", &Dtool_DCFile_get_num_classes_203, METH_NOARGS, (const char *)Dtool_DCFile_get_num_classes_203_comment},
  {"getNumClasses", &Dtool_DCFile_get_num_classes_203, METH_NOARGS, (const char *)Dtool_DCFile_get_num_classes_203_comment},
  {"get_class", &Dtool_DCFile_get_class_204, METH_O, (const char *)Dtool_DCFile_get_class_204_comment},
  {"getClass", &Dtool_DCFile_get_class_204, METH_O, (const char *)Dtool_DCFile_get_class_204_comment},
  {"get_class_by_name", &Dtool_DCFile_get_class_by_name_205, METH_O, (const char *)Dtool_DCFile_get_class_by_name_205_comment},
  {"getClassByName", &Dtool_DCFile_get_class_by_name_205, METH_O, (const char *)Dtool_DCFile_get_class_by_name_205_comment},
  {"get_switch_by_name", &Dtool_DCFile_get_switch_by_name_206, METH_O, (const char *)Dtool_DCFile_get_switch_by_name_206_comment},
  {"getSwitchByName", &Dtool_DCFile_get_switch_by_name_206, METH_O, (const char *)Dtool_DCFile_get_switch_by_name_206_comment},
  {"get_field_by_index", &Dtool_DCFile_get_field_by_index_207, METH_O, (const char *)Dtool_DCFile_get_field_by_index_207_comment},
  {"getFieldByIndex", &Dtool_DCFile_get_field_by_index_207, METH_O, (const char *)Dtool_DCFile_get_field_by_index_207_comment},
  {"all_objects_valid", &Dtool_DCFile_all_objects_valid_208, METH_NOARGS, (const char *)Dtool_DCFile_all_objects_valid_208_comment},
  {"allObjectsValid", &Dtool_DCFile_all_objects_valid_208, METH_NOARGS, (const char *)Dtool_DCFile_all_objects_valid_208_comment},
  {"get_num_import_modules", &Dtool_DCFile_get_num_import_modules_209, METH_NOARGS, (const char *)Dtool_DCFile_get_num_import_modules_209_comment},
  {"getNumImportModules", &Dtool_DCFile_get_num_import_modules_209, METH_NOARGS, (const char *)Dtool_DCFile_get_num_import_modules_209_comment},
  {"get_import_module", &Dtool_DCFile_get_import_module_210, METH_O, (const char *)Dtool_DCFile_get_import_module_210_comment},
  {"getImportModule", &Dtool_DCFile_get_import_module_210, METH_O, (const char *)Dtool_DCFile_get_import_module_210_comment},
  {"get_num_import_symbols", &Dtool_DCFile_get_num_import_symbols_211, METH_O, (const char *)Dtool_DCFile_get_num_import_symbols_211_comment},
  {"getNumImportSymbols", &Dtool_DCFile_get_num_import_symbols_211, METH_O, (const char *)Dtool_DCFile_get_num_import_symbols_211_comment},
  {"get_import_symbol", (PyCFunction) &Dtool_DCFile_get_import_symbol_212, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCFile_get_import_symbol_212_comment},
  {"getImportSymbol", (PyCFunction) &Dtool_DCFile_get_import_symbol_212, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCFile_get_import_symbol_212_comment},
  {"get_num_typedefs", &Dtool_DCFile_get_num_typedefs_213, METH_NOARGS, (const char *)Dtool_DCFile_get_num_typedefs_213_comment},
  {"getNumTypedefs", &Dtool_DCFile_get_num_typedefs_213, METH_NOARGS, (const char *)Dtool_DCFile_get_num_typedefs_213_comment},
  {"get_typedef", &Dtool_DCFile_get_typedef_214, METH_O, (const char *)Dtool_DCFile_get_typedef_214_comment},
  {"getTypedef", &Dtool_DCFile_get_typedef_214, METH_O, (const char *)Dtool_DCFile_get_typedef_214_comment},
  {"get_typedef_by_name", &Dtool_DCFile_get_typedef_by_name_215, METH_O, (const char *)Dtool_DCFile_get_typedef_by_name_215_comment},
  {"getTypedefByName", &Dtool_DCFile_get_typedef_by_name_215, METH_O, (const char *)Dtool_DCFile_get_typedef_by_name_215_comment},
  {"get_num_keywords", &Dtool_DCFile_get_num_keywords_216, METH_NOARGS, (const char *)Dtool_DCFile_get_num_keywords_216_comment},
  {"getNumKeywords", &Dtool_DCFile_get_num_keywords_216, METH_NOARGS, (const char *)Dtool_DCFile_get_num_keywords_216_comment},
  {"get_keyword", &Dtool_DCFile_get_keyword_217, METH_O, (const char *)Dtool_DCFile_get_keyword_217_comment},
  {"getKeyword", &Dtool_DCFile_get_keyword_217, METH_O, (const char *)Dtool_DCFile_get_keyword_217_comment},
  {"get_keyword_by_name", &Dtool_DCFile_get_keyword_by_name_218, METH_O, (const char *)Dtool_DCFile_get_keyword_by_name_218_comment},
  {"getKeywordByName", &Dtool_DCFile_get_keyword_by_name_218, METH_O, (const char *)Dtool_DCFile_get_keyword_by_name_218_comment},
  {"get_hash", &Dtool_DCFile_get_hash_219, METH_NOARGS, (const char *)Dtool_DCFile_get_hash_219_comment},
  {"getHash", &Dtool_DCFile_get_hash_219, METH_NOARGS, (const char *)Dtool_DCFile_get_hash_219_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DCFile slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_DCFile_get_hash_219_tp_hash(PyObject *self) {
  DCFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

static PyNumberMethods Dtool_NumberMethods_DCFile = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_DCFile = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.DCFile",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DCFile,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &DTOOL_PyObject_ComparePointers,
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DCFile,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &Dtool_DCFile_get_hash_219_tp_hash,
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Represents the complete list of Distributed Class descriptions as read from\n"
    " * a .dc file.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
#if PY_MAJOR_VERSION >= 3
    &DTOOL_PyObject_RichCompare,
#else
    0, // tp_richcompare
#endif
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DCFile,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DCFile,
    PyType_GenericAlloc,
    Dtool_new_DCFile,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCFile,
  Dtool_UpcastInterface_DCFile,
  Dtool_DowncastInterface_DCFile,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DCFile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DCFile._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_DCFile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCFile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCFile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCFile);
  }
}

/**
 * Python method tables for DCKeyword (DCKeyword)
 */
static PyMethodDef Dtool_Methods_DCKeyword[] = {
  {"get_name", &Dtool_DCKeyword_get_name_221, METH_NOARGS, (const char *)Dtool_DCKeyword_get_name_221_comment},
  {"getName", &Dtool_DCKeyword_get_name_221, METH_NOARGS, (const char *)Dtool_DCKeyword_get_name_221_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DCKeyword = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCKeyword = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DCKeyword = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DCKeyword = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DCKeyword = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.DCKeyword",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DCKeyword,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DCKeyword,
    &Dtool_SequenceMethods_DCKeyword,
    &Dtool_MappingMethods_DCKeyword,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DCKeyword,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents a single keyword declaration in the dc file.  It is used to\n"
    " * define a communication property associated with a field, for instance\n"
    " * \"broadcast\" or \"airecv\".\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DCKeyword,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DCKeyword,
    PyType_GenericAlloc,
    Dtool_new_DCKeyword,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCKeyword,
  Dtool_UpcastInterface_DCKeyword,
  Dtool_DowncastInterface_DCKeyword,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DCKeyword(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCDeclaration(NULL);
    Dtool_DCKeyword._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCDeclaration);
    PyObject *dict = PyDict_New();
    Dtool_DCKeyword._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCKeyword) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCKeyword)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCKeyword);
  }
}

/**
 * Python method tables for DCMolecularField (DCMolecularField)
 */
static PyMethodDef Dtool_Methods_DCMolecularField[] = {
  {"get_num_atomics", &Dtool_DCMolecularField_get_num_atomics_223, METH_NOARGS, (const char *)Dtool_DCMolecularField_get_num_atomics_223_comment},
  {"getNumAtomics", &Dtool_DCMolecularField_get_num_atomics_223, METH_NOARGS, (const char *)Dtool_DCMolecularField_get_num_atomics_223_comment},
  {"get_atomic", &Dtool_DCMolecularField_get_atomic_224, METH_O, (const char *)Dtool_DCMolecularField_get_atomic_224_comment},
  {"getAtomic", &Dtool_DCMolecularField_get_atomic_224, METH_O, (const char *)Dtool_DCMolecularField_get_atomic_224_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DCMolecularField = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCMolecularField = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DCMolecularField = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DCMolecularField = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DCMolecularField = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.DCMolecularField",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DCMolecularField,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DCMolecularField,
    &Dtool_SequenceMethods_DCMolecularField,
    &Dtool_MappingMethods_DCMolecularField,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DCMolecularField,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A single molecular field of a Distributed Class, as read from a .dc file.\n"
    " * This represents a combination of two or more related atomic fields, that\n"
    " * will often be treated as a unit.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DCMolecularField,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DCMolecularField,
    PyType_GenericAlloc,
    Dtool_new_DCMolecularField,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCMolecularField,
  Dtool_UpcastInterface_DCMolecularField,
  Dtool_DowncastInterface_DCMolecularField,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DCMolecularField(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCField(NULL);
    Dtool_DCMolecularField._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCField);
    PyObject *dict = PyDict_New();
    Dtool_DCMolecularField._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCMolecularField) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCMolecularField)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCMolecularField);
  }
}

/**
 * Python method tables for DCSimpleParameter (DCSimpleParameter)
 */
static PyMethodDef Dtool_Methods_DCSimpleParameter[] = {
  {"get_type", &Dtool_DCSimpleParameter_get_type_227, METH_NOARGS, (const char *)Dtool_DCSimpleParameter_get_type_227_comment},
  {"getType", &Dtool_DCSimpleParameter_get_type_227, METH_NOARGS, (const char *)Dtool_DCSimpleParameter_get_type_227_comment},
  {"has_modulus", &Dtool_DCSimpleParameter_has_modulus_228, METH_NOARGS, (const char *)Dtool_DCSimpleParameter_has_modulus_228_comment},
  {"hasModulus", &Dtool_DCSimpleParameter_has_modulus_228, METH_NOARGS, (const char *)Dtool_DCSimpleParameter_has_modulus_228_comment},
  {"get_modulus", &Dtool_DCSimpleParameter_get_modulus_229, METH_NOARGS, (const char *)Dtool_DCSimpleParameter_get_modulus_229_comment},
  {"getModulus", &Dtool_DCSimpleParameter_get_modulus_229, METH_NOARGS, (const char *)Dtool_DCSimpleParameter_get_modulus_229_comment},
  {"get_divisor", &Dtool_DCSimpleParameter_get_divisor_230, METH_NOARGS, (const char *)Dtool_DCSimpleParameter_get_divisor_230_comment},
  {"getDivisor", &Dtool_DCSimpleParameter_get_divisor_230, METH_NOARGS, (const char *)Dtool_DCSimpleParameter_get_divisor_230_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DCSimpleParameter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCSimpleParameter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DCSimpleParameter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DCSimpleParameter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DCSimpleParameter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.DCSimpleParameter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DCSimpleParameter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DCSimpleParameter,
    &Dtool_SequenceMethods_DCSimpleParameter,
    &Dtool_MappingMethods_DCSimpleParameter,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DCSimpleParameter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the most fundamental kind of parameter type: a single number or\n"
    " * string, one of the DCSubatomicType elements.  It may also optionally have a\n"
    " * divisor, which is meaningful only for the numeric type elements (and\n"
    " * represents a fixed-point numeric convention).\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DCSimpleParameter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DCSimpleParameter,
    PyType_GenericAlloc,
    Dtool_new_DCSimpleParameter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCSimpleParameter,
  Dtool_UpcastInterface_DCSimpleParameter,
  Dtool_DowncastInterface_DCSimpleParameter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DCSimpleParameter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCParameter(NULL);
    Dtool_DCSimpleParameter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCParameter);
    PyObject *dict = PyDict_New();
    Dtool_DCSimpleParameter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCSimpleParameter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCSimpleParameter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCSimpleParameter);
  }
}

/**
 * Python method tables for DCSwitch (DCSwitch)
 */
static PyMethodDef Dtool_Methods_DCSwitch[] = {
  {"get_name", &Dtool_DCSwitch_get_name_233, METH_NOARGS, (const char *)Dtool_DCSwitch_get_name_233_comment},
  {"getName", &Dtool_DCSwitch_get_name_233, METH_NOARGS, (const char *)Dtool_DCSwitch_get_name_233_comment},
  {"get_key_parameter", &Dtool_DCSwitch_get_key_parameter_234, METH_NOARGS, (const char *)Dtool_DCSwitch_get_key_parameter_234_comment},
  {"getKeyParameter", &Dtool_DCSwitch_get_key_parameter_234, METH_NOARGS, (const char *)Dtool_DCSwitch_get_key_parameter_234_comment},
  {"get_num_cases", &Dtool_DCSwitch_get_num_cases_235, METH_NOARGS, (const char *)Dtool_DCSwitch_get_num_cases_235_comment},
  {"getNumCases", &Dtool_DCSwitch_get_num_cases_235, METH_NOARGS, (const char *)Dtool_DCSwitch_get_num_cases_235_comment},
  {"get_case_by_value", &Dtool_DCSwitch_get_case_by_value_236, METH_O, (const char *)Dtool_DCSwitch_get_case_by_value_236_comment},
  {"getCaseByValue", &Dtool_DCSwitch_get_case_by_value_236, METH_O, (const char *)Dtool_DCSwitch_get_case_by_value_236_comment},
  {"get_case", &Dtool_DCSwitch_get_case_237, METH_O, (const char *)Dtool_DCSwitch_get_case_237_comment},
  {"getCase", &Dtool_DCSwitch_get_case_237, METH_O, (const char *)Dtool_DCSwitch_get_case_237_comment},
  {"get_default_case", &Dtool_DCSwitch_get_default_case_238, METH_NOARGS, (const char *)Dtool_DCSwitch_get_default_case_238_comment},
  {"getDefaultCase", &Dtool_DCSwitch_get_default_case_238, METH_NOARGS, (const char *)Dtool_DCSwitch_get_default_case_238_comment},
  {"get_value", &Dtool_DCSwitch_get_value_239, METH_O, (const char *)Dtool_DCSwitch_get_value_239_comment},
  {"getValue", &Dtool_DCSwitch_get_value_239, METH_O, (const char *)Dtool_DCSwitch_get_value_239_comment},
  {"get_num_fields", &Dtool_DCSwitch_get_num_fields_240, METH_O, (const char *)Dtool_DCSwitch_get_num_fields_240_comment},
  {"getNumFields", &Dtool_DCSwitch_get_num_fields_240, METH_O, (const char *)Dtool_DCSwitch_get_num_fields_240_comment},
  {"get_field", (PyCFunction) &Dtool_DCSwitch_get_field_241, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCSwitch_get_field_241_comment},
  {"getField", (PyCFunction) &Dtool_DCSwitch_get_field_241, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCSwitch_get_field_241_comment},
  {"get_field_by_name", (PyCFunction) &Dtool_DCSwitch_get_field_by_name_242, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCSwitch_get_field_by_name_242_comment},
  {"getFieldByName", (PyCFunction) &Dtool_DCSwitch_get_field_by_name_242, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCSwitch_get_field_by_name_242_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DCSwitch = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCSwitch = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DCSwitch = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DCSwitch = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DCSwitch = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.DCSwitch",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DCSwitch,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DCSwitch,
    &Dtool_SequenceMethods_DCSwitch,
    &Dtool_MappingMethods_DCSwitch,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DCSwitch,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents a switch statement, which can appear inside a class body\n"
    " * and represents two or more alternative unpacking schemes based on the first\n"
    " * field read.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DCSwitch,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DCSwitch,
    PyType_GenericAlloc,
    Dtool_new_DCSwitch,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCSwitch,
  Dtool_UpcastInterface_DCSwitch,
  Dtool_DowncastInterface_DCSwitch,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DCSwitch(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCDeclaration(NULL);
    Dtool_DCSwitch._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCDeclaration);
    PyObject *dict = PyDict_New();
    Dtool_DCSwitch._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCSwitch) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCSwitch)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCSwitch);
  }
}

/**
 * Python method tables for DCSwitchParameter (DCSwitchParameter)
 */
static PyMethodDef Dtool_Methods_DCSwitchParameter[] = {
  {"get_switch", &Dtool_DCSwitchParameter_get_switch_244, METH_NOARGS, (const char *)Dtool_DCSwitchParameter_get_switch_244_comment},
  {"getSwitch", &Dtool_DCSwitchParameter_get_switch_244, METH_NOARGS, (const char *)Dtool_DCSwitchParameter_get_switch_244_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DCSwitchParameter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCSwitchParameter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DCSwitchParameter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DCSwitchParameter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DCSwitchParameter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.DCSwitchParameter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DCSwitchParameter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DCSwitchParameter,
    &Dtool_SequenceMethods_DCSwitchParameter,
    &Dtool_MappingMethods_DCSwitchParameter,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DCSwitchParameter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents a switch object used as a parameter itself, which packs the\n"
    " * appropriate fields of the switch into the message.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DCSwitchParameter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DCSwitchParameter,
    PyType_GenericAlloc,
    Dtool_new_DCSwitchParameter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCSwitchParameter,
  Dtool_UpcastInterface_DCSwitchParameter,
  Dtool_DowncastInterface_DCSwitchParameter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DCSwitchParameter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCParameter(NULL);
    Dtool_DCSwitchParameter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCParameter);
    PyObject *dict = PyDict_New();
    Dtool_DCSwitchParameter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCSwitchParameter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCSwitchParameter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCSwitchParameter);
  }
}

/**
 * Python method tables for DCTypedef (DCTypedef)
 */
static PyMethodDef Dtool_Methods_DCTypedef[] = {
  {"get_number", &Dtool_DCTypedef_get_number_247, METH_NOARGS, (const char *)Dtool_DCTypedef_get_number_247_comment},
  {"getNumber", &Dtool_DCTypedef_get_number_247, METH_NOARGS, (const char *)Dtool_DCTypedef_get_number_247_comment},
  {"get_name", &Dtool_DCTypedef_get_name_248, METH_NOARGS, (const char *)Dtool_DCTypedef_get_name_248_comment},
  {"getName", &Dtool_DCTypedef_get_name_248, METH_NOARGS, (const char *)Dtool_DCTypedef_get_name_248_comment},
  {"get_description", &Dtool_DCTypedef_get_description_249, METH_NOARGS, (const char *)Dtool_DCTypedef_get_description_249_comment},
  {"getDescription", &Dtool_DCTypedef_get_description_249, METH_NOARGS, (const char *)Dtool_DCTypedef_get_description_249_comment},
  {"is_bogus_typedef", &Dtool_DCTypedef_is_bogus_typedef_250, METH_NOARGS, (const char *)Dtool_DCTypedef_is_bogus_typedef_250_comment},
  {"isBogusTypedef", &Dtool_DCTypedef_is_bogus_typedef_250, METH_NOARGS, (const char *)Dtool_DCTypedef_is_bogus_typedef_250_comment},
  {"is_implicit_typedef", &Dtool_DCTypedef_is_implicit_typedef_251, METH_NOARGS, (const char *)Dtool_DCTypedef_is_implicit_typedef_251_comment},
  {"isImplicitTypedef", &Dtool_DCTypedef_is_implicit_typedef_251, METH_NOARGS, (const char *)Dtool_DCTypedef_is_implicit_typedef_251_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DCTypedef = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCTypedef = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DCTypedef = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DCTypedef = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DCTypedef = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.DCTypedef",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DCTypedef,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DCTypedef,
    &Dtool_SequenceMethods_DCTypedef,
    &Dtool_MappingMethods_DCTypedef,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DCTypedef,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents a single typedef declaration in the dc file.  It assigns a\n"
    " * particular type to a new name, just like a C typedef.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DCTypedef,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DCTypedef,
    PyType_GenericAlloc,
    Dtool_new_DCTypedef,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCTypedef,
  Dtool_UpcastInterface_DCTypedef,
  Dtool_DowncastInterface_DCTypedef,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DCTypedef(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCDeclaration(NULL);
    Dtool_DCTypedef._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCDeclaration);
    PyObject *dict = PyDict_New();
    Dtool_DCTypedef._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCTypedef) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCTypedef)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCTypedef);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3dcparser_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DCPackerInterface", Dtool_DCPackerInterface);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DCKeywordList", Dtool_DCKeywordList);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DCField", Dtool_DCField);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DCPackData", Dtool_DCPackData);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DCPacker", Dtool_DCPacker);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DCParameter", Dtool_DCParameter);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DCArrayParameter", Dtool_DCArrayParameter);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DCAtomicField", Dtool_DCAtomicField);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DCDeclaration", Dtool_DCDeclaration);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DCClass", Dtool_DCClass);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DCClassParameter", Dtool_DCClassParameter);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DCFile", Dtool_DCFile);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DCKeyword", Dtool_DCKeyword);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DCMolecularField", Dtool_DCMolecularField);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DCSimpleParameter", Dtool_DCSimpleParameter);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DCSwitch", Dtool_DCSwitch);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DCSwitchParameter", Dtool_DCSwitchParameter);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DCTypedef", Dtool_DCTypedef);
#endif
}

void Dtool_libp3dcparser_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_istream = LookupNamedClass("istream");
  Dtool_Ptr_Filename = LookupRuntimeTypedClass(Filename::get_class_type());
  Dtool_Ptr_Datagram = LookupRuntimeTypedClass(Datagram::get_class_type());
  Dtool_Ptr_DatagramIterator = LookupRuntimeTypedClass(DatagramIterator::get_class_type());
#endif
}

void Dtool_libp3dcparser_BuildInstants(PyObject *module) {
  (void) module;
  // enum DCSubatomicType
  PyModule_AddObject(module, "ST_int8", Dtool_WrapValue(::ST_int8));
  PyModule_AddObject(module, "STInt8", Dtool_WrapValue(::ST_int8));
  PyModule_AddObject(module, "ST_int16", Dtool_WrapValue(::ST_int16));
  PyModule_AddObject(module, "STInt16", Dtool_WrapValue(::ST_int16));
  PyModule_AddObject(module, "ST_int32", Dtool_WrapValue(::ST_int32));
  PyModule_AddObject(module, "STInt32", Dtool_WrapValue(::ST_int32));
  PyModule_AddObject(module, "ST_int64", Dtool_WrapValue(::ST_int64));
  PyModule_AddObject(module, "STInt64", Dtool_WrapValue(::ST_int64));
  PyModule_AddObject(module, "ST_uint8", Dtool_WrapValue(::ST_uint8));
  PyModule_AddObject(module, "STUint8", Dtool_WrapValue(::ST_uint8));
  PyModule_AddObject(module, "ST_uint16", Dtool_WrapValue(::ST_uint16));
  PyModule_AddObject(module, "STUint16", Dtool_WrapValue(::ST_uint16));
  PyModule_AddObject(module, "ST_uint32", Dtool_WrapValue(::ST_uint32));
  PyModule_AddObject(module, "STUint32", Dtool_WrapValue(::ST_uint32));
  PyModule_AddObject(module, "ST_uint64", Dtool_WrapValue(::ST_uint64));
  PyModule_AddObject(module, "STUint64", Dtool_WrapValue(::ST_uint64));
  PyModule_AddObject(module, "ST_float64", Dtool_WrapValue(::ST_float64));
  PyModule_AddObject(module, "STFloat64", Dtool_WrapValue(::ST_float64));
  PyModule_AddObject(module, "ST_string", Dtool_WrapValue(::ST_string));
  PyModule_AddObject(module, "STString", Dtool_WrapValue(::ST_string));
  PyModule_AddObject(module, "ST_blob", Dtool_WrapValue(::ST_blob));
  PyModule_AddObject(module, "STBlob", Dtool_WrapValue(::ST_blob));
  PyModule_AddObject(module, "ST_blob32", Dtool_WrapValue(::ST_blob32));
  PyModule_AddObject(module, "STBlob32", Dtool_WrapValue(::ST_blob32));
  PyModule_AddObject(module, "ST_int16array", Dtool_WrapValue(::ST_int16array));
  PyModule_AddObject(module, "STInt16array", Dtool_WrapValue(::ST_int16array));
  PyModule_AddObject(module, "ST_int32array", Dtool_WrapValue(::ST_int32array));
  PyModule_AddObject(module, "STInt32array", Dtool_WrapValue(::ST_int32array));
  PyModule_AddObject(module, "ST_uint16array", Dtool_WrapValue(::ST_uint16array));
  PyModule_AddObject(module, "STUint16array", Dtool_WrapValue(::ST_uint16array));
  PyModule_AddObject(module, "ST_uint32array", Dtool_WrapValue(::ST_uint32array));
  PyModule_AddObject(module, "STUint32array", Dtool_WrapValue(::ST_uint32array));
  PyModule_AddObject(module, "ST_int8array", Dtool_WrapValue(::ST_int8array));
  PyModule_AddObject(module, "STInt8array", Dtool_WrapValue(::ST_int8array));
  PyModule_AddObject(module, "ST_uint8array", Dtool_WrapValue(::ST_uint8array));
  PyModule_AddObject(module, "STUint8array", Dtool_WrapValue(::ST_uint8array));
  PyModule_AddObject(module, "ST_uint32uint8array", Dtool_WrapValue(::ST_uint32uint8array));
  PyModule_AddObject(module, "STUint32uint8array", Dtool_WrapValue(::ST_uint32uint8array));
  PyModule_AddObject(module, "ST_char", Dtool_WrapValue(::ST_char));
  PyModule_AddObject(module, "STChar", Dtool_WrapValue(::ST_char));
  PyModule_AddObject(module, "ST_invalid", Dtool_WrapValue(::ST_invalid));
  PyModule_AddObject(module, "STInvalid", Dtool_WrapValue(::ST_invalid));
  // enum DCPackType
  PyModule_AddObject(module, "PT_invalid", Dtool_WrapValue(::PT_invalid));
  PyModule_AddObject(module, "PTInvalid", Dtool_WrapValue(::PT_invalid));
  PyModule_AddObject(module, "PT_double", Dtool_WrapValue(::PT_double));
  PyModule_AddObject(module, "PTDouble", Dtool_WrapValue(::PT_double));
  PyModule_AddObject(module, "PT_int", Dtool_WrapValue(::PT_int));
  PyModule_AddObject(module, "PTInt", Dtool_WrapValue(::PT_int));
  PyModule_AddObject(module, "PT_uint", Dtool_WrapValue(::PT_uint));
  PyModule_AddObject(module, "PTUint", Dtool_WrapValue(::PT_uint));
  PyModule_AddObject(module, "PT_int64", Dtool_WrapValue(::PT_int64));
  PyModule_AddObject(module, "PTInt64", Dtool_WrapValue(::PT_int64));
  PyModule_AddObject(module, "PT_uint64", Dtool_WrapValue(::PT_uint64));
  PyModule_AddObject(module, "PTUint64", Dtool_WrapValue(::PT_uint64));
  PyModule_AddObject(module, "PT_string", Dtool_WrapValue(::PT_string));
  PyModule_AddObject(module, "PTString", Dtool_WrapValue(::PT_string));
  PyModule_AddObject(module, "PT_blob", Dtool_WrapValue(::PT_blob));
  PyModule_AddObject(module, "PTBlob", Dtool_WrapValue(::PT_blob));
  PyModule_AddObject(module, "PT_array", Dtool_WrapValue(::PT_array));
  PyModule_AddObject(module, "PTArray", Dtool_WrapValue(::PT_array));
  PyModule_AddObject(module, "PT_field", Dtool_WrapValue(::PT_field));
  PyModule_AddObject(module, "PTField", Dtool_WrapValue(::PT_field));
  PyModule_AddObject(module, "PT_class", Dtool_WrapValue(::PT_class));
  PyModule_AddObject(module, "PTClass", Dtool_WrapValue(::PT_class));
  PyModule_AddObject(module, "PT_switch", Dtool_WrapValue(::PT_switch));
  PyModule_AddObject(module, "PTSwitch", Dtool_WrapValue(::PT_switch));
  // DCPackerInterface
  Dtool_PyModuleClassInit_DCPackerInterface(module);
  PyModule_AddObject(module, "DCPackerInterface", (PyObject *)&Dtool_DCPackerInterface);
  // DCKeywordList
  Dtool_PyModuleClassInit_DCKeywordList(module);
  PyModule_AddObject(module, "DCKeywordList", (PyObject *)&Dtool_DCKeywordList);
  // DCField
  Dtool_PyModuleClassInit_DCField(module);
  PyModule_AddObject(module, "DCField", (PyObject *)&Dtool_DCField);
  // DCPackData
  Dtool_PyModuleClassInit_DCPackData(module);
  PyModule_AddObject(module, "DCPackData", (PyObject *)&Dtool_DCPackData);
  // DCPacker
  Dtool_PyModuleClassInit_DCPacker(module);
  PyModule_AddObject(module, "DCPacker", (PyObject *)&Dtool_DCPacker);
  // DCParameter
  Dtool_PyModuleClassInit_DCParameter(module);
  PyModule_AddObject(module, "DCParameter", (PyObject *)&Dtool_DCParameter);
  // DCArrayParameter
  Dtool_PyModuleClassInit_DCArrayParameter(module);
  PyModule_AddObject(module, "DCArrayParameter", (PyObject *)&Dtool_DCArrayParameter);
  // DCAtomicField
  Dtool_PyModuleClassInit_DCAtomicField(module);
  PyModule_AddObject(module, "DCAtomicField", (PyObject *)&Dtool_DCAtomicField);
  // DCDeclaration
  Dtool_PyModuleClassInit_DCDeclaration(module);
  PyModule_AddObject(module, "DCDeclaration", (PyObject *)&Dtool_DCDeclaration);
  // DCClass
  Dtool_PyModuleClassInit_DCClass(module);
  PyModule_AddObject(module, "DCClass", (PyObject *)&Dtool_DCClass);
  // DCClassParameter
  Dtool_PyModuleClassInit_DCClassParameter(module);
  PyModule_AddObject(module, "DCClassParameter", (PyObject *)&Dtool_DCClassParameter);
  // DCFile
  Dtool_PyModuleClassInit_DCFile(module);
  PyModule_AddObject(module, "DCFile", (PyObject *)&Dtool_DCFile);
  // DCKeyword
  Dtool_PyModuleClassInit_DCKeyword(module);
  PyModule_AddObject(module, "DCKeyword", (PyObject *)&Dtool_DCKeyword);
  // DCMolecularField
  Dtool_PyModuleClassInit_DCMolecularField(module);
  PyModule_AddObject(module, "DCMolecularField", (PyObject *)&Dtool_DCMolecularField);
  // DCSimpleParameter
  Dtool_PyModuleClassInit_DCSimpleParameter(module);
  PyModule_AddObject(module, "DCSimpleParameter", (PyObject *)&Dtool_DCSimpleParameter);
  // DCSwitch
  Dtool_PyModuleClassInit_DCSwitch(module);
  PyModule_AddObject(module, "DCSwitch", (PyObject *)&Dtool_DCSwitch);
  // DCSwitchParameter
  Dtool_PyModuleClassInit_DCSwitchParameter(module);
  PyModule_AddObject(module, "DCSwitchParameter", (PyObject *)&Dtool_DCSwitchParameter);
  // DCTypedef
  Dtool_PyModuleClassInit_DCTypedef(module);
  PyModule_AddObject(module, "DCTypedef", (PyObject *)&Dtool_DCTypedef);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3dcparser_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478214648,  /* file_identifier */
  "libp3dcparser",  /* library_name */
  "zIbG",  /* library_hash_name */
  "panda3d.direct",  /* module_name */
  "libp3dcparser.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  579  /* next_index */
};

Configure(_in_configure_libp3dcparser);
ConfigureFn(_in_configure_libp3dcparser) {
  interrogate_request_module(&_in_module_def);
}

