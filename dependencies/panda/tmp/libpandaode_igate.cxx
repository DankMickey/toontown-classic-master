/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/ode -Ipanda/src/ode -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libpandaode_igate.cxx -od built/pandac/input/libpandaode.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/ode -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/ode/include -Sthirdparty/win-libs-vc10/extras/include -DdSINGLE= -module panda3d.ode -library libpandaode config_ode.h odeAMotorJoint.h odeBallJoint.h odeBody.h odeBody_ext.h odeBoxGeom.h odeCappedCylinderGeom.h odeCollisionEntry.h odeContact.h odeContactGeom.h odeContactJoint.h odeCylinderGeom.h odeFixedJoint.h odeGeom.h odeGeom_ext.h odeHashSpace.h odeHinge2Joint.h odeHingeJoint.h odeJoint.h odeJointCollection.h odeJointGroup.h odeJoint_ext.h odeLMotorJoint.h odeMass.h odeNullJoint.h odePlane2dJoint.h odePlaneGeom.h odeQuadTreeSpace.h odeRayGeom.h odeSimpleSpace.h odeSliderJoint.h odeSpace.h odeSpace_ext.h odeSphereGeom.h odeSurfaceParameters.h odeTriMeshData.h odeTriMeshGeom.h odeUniversalJoint.h odeUtil.h odeUtil_ext.h odeWorld.h ode_includes.h p3ode_composite1.cxx p3ode_composite2.cxx p3ode_composite3.cxx p3ode_ext_composite.cxx 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libpandaode
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "config_ode.h"
#include "dconfig.h"
#include "dtoolbase.h"
#include "extension.h"
#include "geomNode.h"
#include "geomTriangles.h"
#include "geomTristrips.h"
#include "geomVertexData.h"
#include "geomVertexReader.h"
#include "luse.h"
#include "nodePathCollection.h"
#include "notifyCategoryProxy.h"
#include "odeAMotorJoint.h"
#include "odeBallJoint.h"
#include "odeBody.h"
#include "odeBody_ext.h"
#include "odeBoxGeom.h"
#include "odeCappedCylinderGeom.h"
#include "odeCollisionEntry.h"
#include "odeContact.h"
#include "odeContactGeom.h"
#include "odeContactJoint.h"
#include "odeCylinderGeom.h"
#include "odeFixedJoint.h"
#include "odeGeom.h"
#include "odeGeom_ext.h"
#include "odeHashSpace.h"
#include "odeHinge2Joint.h"
#include "odeHingeJoint.h"
#include "odeJoint.h"
#include "odeJointCollection.h"
#include "odeJointGroup.h"
#include "odeJoint_ext.h"
#include "odeLMotorJoint.h"
#include "odeMass.h"
#include "odeNullJoint.h"
#include "odePlane2dJoint.h"
#include "odePlaneGeom.h"
#include "odeQuadTreeSpace.h"
#include "odeRayGeom.h"
#include "odeSimpleSpace.h"
#include "odeSliderJoint.h"
#include "odeSpace.h"
#include "odeSpace_ext.h"
#include "odeSphereGeom.h"
#include "odeSurfaceParameters.h"
#include "odeTriMeshData.h"
#include "odeTriMeshGeom.h"
#include "odeUniversalJoint.h"
#include "odeUtil.h"
#include "odeUtil_ext.h"
#include "odeWorld.h"
#include "ode_includes.h"
#include "pandabase.h"
#include "py_panda.h"
#include "typedObject.h"
#include "typedReferenceCount.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class dxBody
 */
typedef dxBody dxBody_localtype;
Define_Module_Class_Private(panda3d.ode, dxBody, dxBody_localtype, dxBody);
static struct Dtool_PyTypedObject *const Dtool_Ptr_dxBody = &Dtool_dxBody;
static void Dtool_PyModuleClassInit_dxBody(PyObject *module);

/**
 * Forward declarations for top-level class dxGeom
 */
typedef dxGeom dxGeom_localtype;
Define_Module_Class_Private(panda3d.ode, dxGeom, dxGeom_localtype, dxGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_dxGeom = &Dtool_dxGeom;
static void Dtool_PyModuleClassInit_dxGeom(PyObject *module);

/**
 * Forward declarations for top-level class dxJoint
 */
typedef dxJoint dxJoint_localtype;
Define_Module_Class_Private(panda3d.ode, dxJoint, dxJoint_localtype, dxJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_dxJoint = &Dtool_dxJoint;
static void Dtool_PyModuleClassInit_dxJoint(PyObject *module);

/**
 * Forward declarations for top-level class dxJointGroup
 */
typedef dxJointGroup dxJointGroup_localtype;
Define_Module_Class_Private(panda3d.ode, dxJointGroup, dxJointGroup_localtype, dxJointGroup);
static struct Dtool_PyTypedObject *const Dtool_Ptr_dxJointGroup = &Dtool_dxJointGroup;
static void Dtool_PyModuleClassInit_dxJointGroup(PyObject *module);

/**
 * Forward declarations for top-level class dxSpace
 */
typedef dxSpace dxSpace_localtype;
Define_Module_Class_Private(panda3d.ode, dxSpace, dxSpace_localtype, dxSpace);
static struct Dtool_PyTypedObject *const Dtool_Ptr_dxSpace = &Dtool_dxSpace;
static void Dtool_PyModuleClassInit_dxSpace(PyObject *module);

/**
 * Forward declarations for top-level class dxTriMeshData
 */
typedef dxTriMeshData dxTriMeshData_localtype;
Define_Module_Class_Private(panda3d.ode, dxTriMeshData, dxTriMeshData_localtype, dxTriMeshData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_dxTriMeshData = &Dtool_dxTriMeshData;
static void Dtool_PyModuleClassInit_dxTriMeshData(PyObject *module);

/**
 * Forward declarations for top-level class dxWorld
 */
typedef dxWorld dxWorld_localtype;
Define_Module_Class_Private(panda3d.ode, dxWorld, dxWorld_localtype, dxWorld);
static struct Dtool_PyTypedObject *const Dtool_Ptr_dxWorld = &Dtool_dxWorld;
static void Dtool_PyModuleClassInit_dxWorld(PyObject *module);

/**
 * Forward declarations for top-level class OdeWorld
 */
typedef OdeWorld OdeWorld_localtype;
Define_Module_Class(panda3d.ode, OdeWorld, OdeWorld_localtype, OdeWorld);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeWorld = &Dtool_OdeWorld;
static void Dtool_PyModuleClassInit_OdeWorld(PyObject *module);

/**
 * Forward declarations for top-level class OdeJointGroup
 */
typedef OdeJointGroup OdeJointGroup_localtype;
Define_Module_Class(panda3d.ode, OdeJointGroup, OdeJointGroup_localtype, OdeJointGroup);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeJointGroup = &Dtool_OdeJointGroup;
static void Dtool_PyModuleClassInit_OdeJointGroup(PyObject *module);

/**
 * Forward declarations for top-level class OdeJointFeedback
 */
typedef OdeJointFeedback OdeJointFeedback_localtype;
Define_Module_Class(panda3d.ode, OdeJointFeedback, OdeJointFeedback_localtype, OdeJointFeedback);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeJointFeedback = &Dtool_OdeJointFeedback;
static void Dtool_PyModuleClassInit_OdeJointFeedback(PyObject *module);

/**
 * Forward declarations for top-level class OdeJoint
 */
typedef OdeJoint OdeJoint_localtype;
Define_Module_Class(panda3d.ode, OdeJoint, OdeJoint_localtype, OdeJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeJoint = &Dtool_OdeJoint;
static void Dtool_PyModuleClassInit_OdeJoint(PyObject *module);

/**
 * Forward declarations for top-level class OdeAMotorJoint
 */
typedef OdeAMotorJoint OdeAMotorJoint_localtype;
Define_Module_Class(panda3d.ode, OdeAMotorJoint, OdeAMotorJoint_localtype, OdeAMotorJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeAMotorJoint = &Dtool_OdeAMotorJoint;
static void Dtool_PyModuleClassInit_OdeAMotorJoint(PyObject *module);
bool Dtool_ConstCoerce_OdeAMotorJoint(PyObject *args, OdeAMotorJoint const *&coerced, bool &manage);
bool Dtool_Coerce_OdeAMotorJoint(PyObject *args, OdeAMotorJoint *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeBallJoint
 */
typedef OdeBallJoint OdeBallJoint_localtype;
Define_Module_Class(panda3d.ode, OdeBallJoint, OdeBallJoint_localtype, OdeBallJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeBallJoint = &Dtool_OdeBallJoint;
static void Dtool_PyModuleClassInit_OdeBallJoint(PyObject *module);
bool Dtool_ConstCoerce_OdeBallJoint(PyObject *args, OdeBallJoint const *&coerced, bool &manage);
bool Dtool_Coerce_OdeBallJoint(PyObject *args, OdeBallJoint *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeMass
 */
typedef OdeMass OdeMass_localtype;
Define_Module_ClassRef(panda3d.ode, OdeMass, OdeMass_localtype, OdeMass);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeMass = &Dtool_OdeMass;
static void Dtool_PyModuleClassInit_OdeMass(PyObject *module);

/**
 * Forward declarations for top-level class OdeBody
 */
typedef OdeBody OdeBody_localtype;
Define_Module_Class(panda3d.ode, OdeBody, OdeBody_localtype, OdeBody);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeBody = &Dtool_OdeBody;
static void Dtool_PyModuleClassInit_OdeBody(PyObject *module);
bool Dtool_ConstCoerce_OdeBody(PyObject *args, OdeBody const *&coerced, bool &manage);
bool Dtool_Coerce_OdeBody(PyObject *args, OdeBody *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeSpace
 */
typedef OdeSpace OdeSpace_localtype;
Define_Module_Class(panda3d.ode, OdeSpace, OdeSpace_localtype, OdeSpace);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeSpace = &Dtool_OdeSpace;
static void Dtool_PyModuleClassInit_OdeSpace(PyObject *module);

/**
 * Forward declarations for top-level class OdeGeom
 */
typedef OdeGeom OdeGeom_localtype;
Define_Module_Class(panda3d.ode, OdeGeom, OdeGeom_localtype, OdeGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeGeom = &Dtool_OdeGeom;
static void Dtool_PyModuleClassInit_OdeGeom(PyObject *module);

/**
 * Forward declarations for top-level class OdeBoxGeom
 */
typedef OdeBoxGeom OdeBoxGeom_localtype;
Define_Module_Class(panda3d.ode, OdeBoxGeom, OdeBoxGeom_localtype, OdeBoxGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeBoxGeom = &Dtool_OdeBoxGeom;
static void Dtool_PyModuleClassInit_OdeBoxGeom(PyObject *module);
bool Dtool_ConstCoerce_OdeBoxGeom(PyObject *args, OdeBoxGeom const *&coerced, bool &manage);
bool Dtool_Coerce_OdeBoxGeom(PyObject *args, OdeBoxGeom *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeCappedCylinderGeom
 */
typedef OdeCappedCylinderGeom OdeCappedCylinderGeom_localtype;
Define_Module_Class(panda3d.ode, OdeCappedCylinderGeom, OdeCappedCylinderGeom_localtype, OdeCappedCylinderGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeCappedCylinderGeom = &Dtool_OdeCappedCylinderGeom;
static void Dtool_PyModuleClassInit_OdeCappedCylinderGeom(PyObject *module);
bool Dtool_ConstCoerce_OdeCappedCylinderGeom(PyObject *args, OdeCappedCylinderGeom const *&coerced, bool &manage);
bool Dtool_Coerce_OdeCappedCylinderGeom(PyObject *args, OdeCappedCylinderGeom *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeContactGeom
 */
typedef OdeContactGeom OdeContactGeom_localtype;
Define_Module_ClassRef(panda3d.ode, OdeContactGeom, OdeContactGeom_localtype, OdeContactGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeContactGeom = &Dtool_OdeContactGeom;
static void Dtool_PyModuleClassInit_OdeContactGeom(PyObject *module);

/**
 * Forward declarations for top-level class OdeCollisionEntry
 */
typedef OdeCollisionEntry OdeCollisionEntry_localtype;
Define_Module_ClassRef(panda3d.ode, OdeCollisionEntry, OdeCollisionEntry_localtype, OdeCollisionEntry);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeCollisionEntry = &Dtool_OdeCollisionEntry;
static void Dtool_PyModuleClassInit_OdeCollisionEntry(PyObject *module);

/**
 * Forward declarations for top-level class OdeSurfaceParameters
 */
typedef OdeSurfaceParameters OdeSurfaceParameters_localtype;
Define_Module_Class(panda3d.ode, OdeSurfaceParameters, OdeSurfaceParameters_localtype, OdeSurfaceParameters);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeSurfaceParameters = &Dtool_OdeSurfaceParameters;
static void Dtool_PyModuleClassInit_OdeSurfaceParameters(PyObject *module);
bool Dtool_ConstCoerce_OdeSurfaceParameters(PyObject *args, OdeSurfaceParameters const *&coerced, bool &manage);
bool Dtool_Coerce_OdeSurfaceParameters(PyObject *args, OdeSurfaceParameters *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeContact
 */
typedef OdeContact OdeContact_localtype;
Define_Module_ClassRef(panda3d.ode, OdeContact, OdeContact_localtype, OdeContact);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeContact = &Dtool_OdeContact;
static void Dtool_PyModuleClassInit_OdeContact(PyObject *module);
bool Dtool_ConstCoerce_OdeContact(PyObject *args, CPT(OdeContact) &coerced);
bool Dtool_Coerce_OdeContact(PyObject *args, PT(OdeContact) &coerced);

/**
 * Forward declarations for top-level class OdeContactJoint
 */
typedef OdeContactJoint OdeContactJoint_localtype;
Define_Module_Class(panda3d.ode, OdeContactJoint, OdeContactJoint_localtype, OdeContactJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeContactJoint = &Dtool_OdeContactJoint;
static void Dtool_PyModuleClassInit_OdeContactJoint(PyObject *module);
bool Dtool_ConstCoerce_OdeContactJoint(PyObject *args, OdeContactJoint const *&coerced, bool &manage);
bool Dtool_Coerce_OdeContactJoint(PyObject *args, OdeContactJoint *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeCylinderGeom
 */
typedef OdeCylinderGeom OdeCylinderGeom_localtype;
Define_Module_Class(panda3d.ode, OdeCylinderGeom, OdeCylinderGeom_localtype, OdeCylinderGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeCylinderGeom = &Dtool_OdeCylinderGeom;
static void Dtool_PyModuleClassInit_OdeCylinderGeom(PyObject *module);
bool Dtool_ConstCoerce_OdeCylinderGeom(PyObject *args, OdeCylinderGeom const *&coerced, bool &manage);
bool Dtool_Coerce_OdeCylinderGeom(PyObject *args, OdeCylinderGeom *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeFixedJoint
 */
typedef OdeFixedJoint OdeFixedJoint_localtype;
Define_Module_Class(panda3d.ode, OdeFixedJoint, OdeFixedJoint_localtype, OdeFixedJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeFixedJoint = &Dtool_OdeFixedJoint;
static void Dtool_PyModuleClassInit_OdeFixedJoint(PyObject *module);
bool Dtool_ConstCoerce_OdeFixedJoint(PyObject *args, OdeFixedJoint const *&coerced, bool &manage);
bool Dtool_Coerce_OdeFixedJoint(PyObject *args, OdeFixedJoint *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeHashSpace
 */
typedef OdeHashSpace OdeHashSpace_localtype;
Define_Module_Class(panda3d.ode, OdeHashSpace, OdeHashSpace_localtype, OdeHashSpace);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeHashSpace = &Dtool_OdeHashSpace;
static void Dtool_PyModuleClassInit_OdeHashSpace(PyObject *module);
bool Dtool_ConstCoerce_OdeHashSpace(PyObject *args, OdeHashSpace const *&coerced, bool &manage);
bool Dtool_Coerce_OdeHashSpace(PyObject *args, OdeHashSpace *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeHinge2Joint
 */
typedef OdeHinge2Joint OdeHinge2Joint_localtype;
Define_Module_Class(panda3d.ode, OdeHinge2Joint, OdeHinge2Joint_localtype, OdeHinge2Joint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeHinge2Joint = &Dtool_OdeHinge2Joint;
static void Dtool_PyModuleClassInit_OdeHinge2Joint(PyObject *module);
bool Dtool_ConstCoerce_OdeHinge2Joint(PyObject *args, OdeHinge2Joint const *&coerced, bool &manage);
bool Dtool_Coerce_OdeHinge2Joint(PyObject *args, OdeHinge2Joint *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeHingeJoint
 */
typedef OdeHingeJoint OdeHingeJoint_localtype;
Define_Module_Class(panda3d.ode, OdeHingeJoint, OdeHingeJoint_localtype, OdeHingeJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeHingeJoint = &Dtool_OdeHingeJoint;
static void Dtool_PyModuleClassInit_OdeHingeJoint(PyObject *module);
bool Dtool_ConstCoerce_OdeHingeJoint(PyObject *args, OdeHingeJoint const *&coerced, bool &manage);
bool Dtool_Coerce_OdeHingeJoint(PyObject *args, OdeHingeJoint *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeJointCollection
 */
typedef OdeJointCollection OdeJointCollection_localtype;
Define_Module_Class(panda3d.ode, OdeJointCollection, OdeJointCollection_localtype, OdeJointCollection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeJointCollection = &Dtool_OdeJointCollection;
static void Dtool_PyModuleClassInit_OdeJointCollection(PyObject *module);

/**
 * Forward declarations for top-level class OdeLMotorJoint
 */
typedef OdeLMotorJoint OdeLMotorJoint_localtype;
Define_Module_Class(panda3d.ode, OdeLMotorJoint, OdeLMotorJoint_localtype, OdeLMotorJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeLMotorJoint = &Dtool_OdeLMotorJoint;
static void Dtool_PyModuleClassInit_OdeLMotorJoint(PyObject *module);
bool Dtool_ConstCoerce_OdeLMotorJoint(PyObject *args, OdeLMotorJoint const *&coerced, bool &manage);
bool Dtool_Coerce_OdeLMotorJoint(PyObject *args, OdeLMotorJoint *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeNullJoint
 */
typedef OdeNullJoint OdeNullJoint_localtype;
Define_Module_Class(panda3d.ode, OdeNullJoint, OdeNullJoint_localtype, OdeNullJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeNullJoint = &Dtool_OdeNullJoint;
static void Dtool_PyModuleClassInit_OdeNullJoint(PyObject *module);
bool Dtool_ConstCoerce_OdeNullJoint(PyObject *args, OdeNullJoint const *&coerced, bool &manage);
bool Dtool_Coerce_OdeNullJoint(PyObject *args, OdeNullJoint *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdePlane2dJoint
 */
typedef OdePlane2dJoint OdePlane2dJoint_localtype;
Define_Module_Class(panda3d.ode, OdePlane2dJoint, OdePlane2dJoint_localtype, OdePlane2dJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdePlane2dJoint = &Dtool_OdePlane2dJoint;
static void Dtool_PyModuleClassInit_OdePlane2dJoint(PyObject *module);
bool Dtool_ConstCoerce_OdePlane2dJoint(PyObject *args, OdePlane2dJoint const *&coerced, bool &manage);
bool Dtool_Coerce_OdePlane2dJoint(PyObject *args, OdePlane2dJoint *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdePlaneGeom
 */
typedef OdePlaneGeom OdePlaneGeom_localtype;
Define_Module_Class(panda3d.ode, OdePlaneGeom, OdePlaneGeom_localtype, OdePlaneGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdePlaneGeom = &Dtool_OdePlaneGeom;
static void Dtool_PyModuleClassInit_OdePlaneGeom(PyObject *module);
bool Dtool_ConstCoerce_OdePlaneGeom(PyObject *args, OdePlaneGeom const *&coerced, bool &manage);
bool Dtool_Coerce_OdePlaneGeom(PyObject *args, OdePlaneGeom *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeQuadTreeSpace
 */
typedef OdeQuadTreeSpace OdeQuadTreeSpace_localtype;
Define_Module_Class(panda3d.ode, OdeQuadTreeSpace, OdeQuadTreeSpace_localtype, OdeQuadTreeSpace);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeQuadTreeSpace = &Dtool_OdeQuadTreeSpace;
static void Dtool_PyModuleClassInit_OdeQuadTreeSpace(PyObject *module);
bool Dtool_ConstCoerce_OdeQuadTreeSpace(PyObject *args, OdeQuadTreeSpace const *&coerced, bool &manage);
bool Dtool_Coerce_OdeQuadTreeSpace(PyObject *args, OdeQuadTreeSpace *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeRayGeom
 */
typedef OdeRayGeom OdeRayGeom_localtype;
Define_Module_Class(panda3d.ode, OdeRayGeom, OdeRayGeom_localtype, OdeRayGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeRayGeom = &Dtool_OdeRayGeom;
static void Dtool_PyModuleClassInit_OdeRayGeom(PyObject *module);
bool Dtool_ConstCoerce_OdeRayGeom(PyObject *args, OdeRayGeom const *&coerced, bool &manage);
bool Dtool_Coerce_OdeRayGeom(PyObject *args, OdeRayGeom *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeSimpleSpace
 */
typedef OdeSimpleSpace OdeSimpleSpace_localtype;
Define_Module_Class(panda3d.ode, OdeSimpleSpace, OdeSimpleSpace_localtype, OdeSimpleSpace);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeSimpleSpace = &Dtool_OdeSimpleSpace;
static void Dtool_PyModuleClassInit_OdeSimpleSpace(PyObject *module);
bool Dtool_ConstCoerce_OdeSimpleSpace(PyObject *args, OdeSimpleSpace const *&coerced, bool &manage);
bool Dtool_Coerce_OdeSimpleSpace(PyObject *args, OdeSimpleSpace *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeSliderJoint
 */
typedef OdeSliderJoint OdeSliderJoint_localtype;
Define_Module_Class(panda3d.ode, OdeSliderJoint, OdeSliderJoint_localtype, OdeSliderJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeSliderJoint = &Dtool_OdeSliderJoint;
static void Dtool_PyModuleClassInit_OdeSliderJoint(PyObject *module);
bool Dtool_ConstCoerce_OdeSliderJoint(PyObject *args, OdeSliderJoint const *&coerced, bool &manage);
bool Dtool_Coerce_OdeSliderJoint(PyObject *args, OdeSliderJoint *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeSphereGeom
 */
typedef OdeSphereGeom OdeSphereGeom_localtype;
Define_Module_Class(panda3d.ode, OdeSphereGeom, OdeSphereGeom_localtype, OdeSphereGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeSphereGeom = &Dtool_OdeSphereGeom;
static void Dtool_PyModuleClassInit_OdeSphereGeom(PyObject *module);
bool Dtool_ConstCoerce_OdeSphereGeom(PyObject *args, OdeSphereGeom const *&coerced, bool &manage);
bool Dtool_Coerce_OdeSphereGeom(PyObject *args, OdeSphereGeom *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeTriMeshData
 */
typedef OdeTriMeshData OdeTriMeshData_localtype;
Define_Module_ClassRef(panda3d.ode, OdeTriMeshData, OdeTriMeshData_localtype, OdeTriMeshData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeTriMeshData = &Dtool_OdeTriMeshData;
static void Dtool_PyModuleClassInit_OdeTriMeshData(PyObject *module);
bool Dtool_ConstCoerce_OdeTriMeshData(PyObject *args, CPT(OdeTriMeshData) &coerced);
bool Dtool_Coerce_OdeTriMeshData(PyObject *args, PT(OdeTriMeshData) &coerced);

/**
 * Forward declarations for top-level class OdeTriMeshGeom
 */
typedef OdeTriMeshGeom OdeTriMeshGeom_localtype;
Define_Module_Class(panda3d.ode, OdeTriMeshGeom, OdeTriMeshGeom_localtype, OdeTriMeshGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeTriMeshGeom = &Dtool_OdeTriMeshGeom;
static void Dtool_PyModuleClassInit_OdeTriMeshGeom(PyObject *module);
bool Dtool_ConstCoerce_OdeTriMeshGeom(PyObject *args, OdeTriMeshGeom const *&coerced, bool &manage);
bool Dtool_Coerce_OdeTriMeshGeom(PyObject *args, OdeTriMeshGeom *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeUniversalJoint
 */
typedef OdeUniversalJoint OdeUniversalJoint_localtype;
Define_Module_Class(panda3d.ode, OdeUniversalJoint, OdeUniversalJoint_localtype, OdeUniversalJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeUniversalJoint = &Dtool_OdeUniversalJoint;
static void Dtool_PyModuleClassInit_OdeUniversalJoint(PyObject *module);
bool Dtool_ConstCoerce_OdeUniversalJoint(PyObject *args, OdeUniversalJoint const *&coerced, bool &manage);
bool Dtool_Coerce_OdeUniversalJoint(PyObject *args, OdeUniversalJoint *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OdeUtil
 */
typedef OdeUtil OdeUtil_localtype;
Define_Module_Class(panda3d.ode, OdeUtil, OdeUtil_localtype, OdeUtil);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeUtil = &Dtool_OdeUtil;
static void Dtool_PyModuleClassInit_OdeUtil(PyObject *module);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVector3f;
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != NULL, NULL);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3f;
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint3f;
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != NULL, NULL);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4f;
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LMatrix3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix3f;
inline static LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced) {
  nassertr(Dtool_Ptr_LMatrix3f != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix3f->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix3f *(*)(PyObject *, LMatrix3f &))Dtool_Ptr_LMatrix3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3f = &Dtool_LMatrix3f;
extern LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced);
#endif
// LQuaternionf
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LQuaternionf;
inline static LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced) {
  nassertr(Dtool_Ptr_LQuaternionf != NULL, NULL);
  nassertr(Dtool_Ptr_LQuaternionf->_Dtool_Coerce != NULL, NULL);
  return ((LQuaternionf *(*)(PyObject *, LQuaternionf &))Dtool_Ptr_LQuaternionf->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LQuaternionf;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LQuaternionf = &Dtool_LQuaternionf;
extern LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced);
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// BitMask< uint32_t, 32 >
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_BitMask_uint32_t_32;
inline static BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced) {
  nassertr(Dtool_Ptr_BitMask_uint32_t_32 != NULL, NULL);
  nassertr(Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce != NULL, NULL);
  return ((BitMask< uint32_t, 32 > *(*)(PyObject *, BitMask< uint32_t, 32 > &))Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_BitMask_uint32_t_32;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitMask_uint32_t_32 = &Dtool_BitMask_uint32_t_32;
extern BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced);
#endif
// NodePath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePath;
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class dxBody
 */
static int Dtool_Init_dxBody(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_dxBody(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_dxBody) {
    printf("dxBody ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  dxBody *local_this = (dxBody *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_dxBody) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_dxBody(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_dxBody) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class dxGeom
 */
static int Dtool_Init_dxGeom(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_dxGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_dxGeom) {
    printf("dxGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  dxGeom *local_this = (dxGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_dxGeom) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_dxGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_dxGeom) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class dxJoint
 */
static int Dtool_Init_dxJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_dxJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_dxJoint) {
    printf("dxJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  dxJoint *local_this = (dxJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_dxJoint) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_dxJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_dxJoint) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class dxJointGroup
 */
static int Dtool_Init_dxJointGroup(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_dxJointGroup(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_dxJointGroup) {
    printf("dxJointGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  dxJointGroup *local_this = (dxJointGroup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_dxJointGroup) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_dxJointGroup(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_dxJointGroup) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class dxSpace
 */
static int Dtool_Init_dxSpace(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_dxSpace(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_dxSpace) {
    printf("dxSpace ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  dxSpace *local_this = (dxSpace *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_dxSpace) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_dxSpace(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_dxSpace) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class dxTriMeshData
 */
static int Dtool_Init_dxTriMeshData(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_dxTriMeshData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_dxTriMeshData) {
    printf("dxTriMeshData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  dxTriMeshData *local_this = (dxTriMeshData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_dxTriMeshData) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_dxTriMeshData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_dxTriMeshData) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class dxWorld
 */
static int Dtool_Init_dxWorld(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_dxWorld(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_dxWorld) {
    printf("dxWorld ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  dxWorld *local_this = (dxWorld *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_dxWorld) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_dxWorld(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_dxWorld) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeWorld
 */
/**
 * Python function wrapper for:
 * void OdeWorld::destroy(void)
 */
static PyObject *Dtool_OdeWorld_destroy_11(PyObject *self, PyObject *) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.destroy")) {
    return NULL;
  }
  // 1-void OdeWorld::destroy(void)
  (*local_this).destroy();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_destroy_11_comment =
  "C++ Interface:\n"
  "destroy(const OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_destroy_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool OdeWorld::is_empty(void) const
 */
static PyObject *Dtool_OdeWorld_is_empty_12(PyObject *self, PyObject *) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeWorld, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool OdeWorld::is_empty(void) const
  bool return_value = (*(const OdeWorld*)local_this).is_empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_is_empty_12_comment =
  "C++ Interface:\n"
  "is_empty(OdeWorld self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ID is 0, meaning the OdeWorld does not point to a valid\n"
  " * world.  It is an error to call a method on an empty world.  Note that an\n"
  " * empty OdeWorld also evaluates to False.\n"
  " */";
#else
static const char *Dtool_OdeWorld_is_empty_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_gravity(LVecBase3f const &vec)
 * inline void OdeWorld::set_gravity(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeWorld_set_gravity_14(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_gravity")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "vec");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'vec' (pos 1) not found");
      }
      // 1-inline void OdeWorld::set_gravity(LVecBase3f const &vec)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeWorld.set_gravity", "LVecBase3f");
      }
      (*local_this).set_gravity(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeWorld::set_gravity(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_gravity", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_gravity((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_gravity() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_gravity(const OdeWorld self, const LVecBase3f vec)\n"
      "set_gravity(const OdeWorld self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_gravity_14_comment =
  "C++ Interface:\n"
  "set_gravity(const OdeWorld self, const LVecBase3f vec)\n"
  "set_gravity(const OdeWorld self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeWorld_set_gravity_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_erp(dReal erp)
 */
static PyObject *Dtool_OdeWorld_set_erp_15(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_erp")) {
    return NULL;
  }
  // 1-inline void OdeWorld::set_erp(dReal erp)
  if (PyNumber_Check(arg)) {
    (*local_this).set_erp((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_erp(const OdeWorld self, float erp)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_erp_15_comment =
  "C++ Interface:\n"
  "set_erp(const OdeWorld self, float erp)\n";
#else
static const char *Dtool_OdeWorld_set_erp_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_cfm(dReal cfm)
 */
static PyObject *Dtool_OdeWorld_set_cfm_16(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_cfm")) {
    return NULL;
  }
  // 1-inline void OdeWorld::set_cfm(dReal cfm)
  if (PyNumber_Check(arg)) {
    (*local_this).set_cfm((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cfm(const OdeWorld self, float cfm)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_cfm_16_comment =
  "C++ Interface:\n"
  "set_cfm(const OdeWorld self, float cfm)\n";
#else
static const char *Dtool_OdeWorld_set_cfm_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_quick_step_num_iterations(int num)
 */
static PyObject *Dtool_OdeWorld_set_quick_step_num_iterations_17(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_quick_step_num_iterations")) {
    return NULL;
  }
  // 1-inline void OdeWorld::set_quick_step_num_iterations(int num)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_quick_step_num_iterations((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_quick_step_num_iterations(const OdeWorld self, int num)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_quick_step_num_iterations_17_comment =
  "C++ Interface:\n"
  "set_quick_step_num_iterations(const OdeWorld self, int num)\n";
#else
static const char *Dtool_OdeWorld_set_quick_step_num_iterations_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_quick_step_w(dReal over_relaxation)
 */
static PyObject *Dtool_OdeWorld_set_quick_step_w_18(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_quick_step_w")) {
    return NULL;
  }
  // 1-inline void OdeWorld::set_quick_step_w(dReal over_relaxation)
  if (PyNumber_Check(arg)) {
    (*local_this).set_quick_step_w((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_quick_step_w(const OdeWorld self, float over_relaxation)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_quick_step_w_18_comment =
  "C++ Interface:\n"
  "set_quick_step_w(const OdeWorld self, float over_relaxation)\n";
#else
static const char *Dtool_OdeWorld_set_quick_step_w_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_contact_max_correcting_vel(dReal vel)
 */
static PyObject *Dtool_OdeWorld_set_contact_max_correcting_vel_19(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_contact_max_correcting_vel")) {
    return NULL;
  }
  // 1-inline void OdeWorld::set_contact_max_correcting_vel(dReal vel)
  if (PyNumber_Check(arg)) {
    (*local_this).set_contact_max_correcting_vel((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_contact_max_correcting_vel(const OdeWorld self, float vel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_contact_max_correcting_vel_19_comment =
  "C++ Interface:\n"
  "set_contact_max_correcting_vel(const OdeWorld self, float vel)\n";
#else
static const char *Dtool_OdeWorld_set_contact_max_correcting_vel_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_contact_surface_layer(dReal depth)
 */
static PyObject *Dtool_OdeWorld_set_contact_surface_layer_20(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_contact_surface_layer")) {
    return NULL;
  }
  // 1-inline void OdeWorld::set_contact_surface_layer(dReal depth)
  if (PyNumber_Check(arg)) {
    (*local_this).set_contact_surface_layer((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_contact_surface_layer(const OdeWorld self, float depth)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_contact_surface_layer_20_comment =
  "C++ Interface:\n"
  "set_contact_surface_layer(const OdeWorld self, float depth)\n";
#else
static const char *Dtool_OdeWorld_set_contact_surface_layer_20_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_auto_disable_linear_threshold(dReal linear_threshold)
 */
static PyObject *Dtool_OdeWorld_set_auto_disable_linear_threshold_21(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_auto_disable_linear_threshold")) {
    return NULL;
  }
  // 1-inline void OdeWorld::set_auto_disable_linear_threshold(dReal linear_threshold)
  if (PyNumber_Check(arg)) {
    (*local_this).set_auto_disable_linear_threshold((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_linear_threshold(const OdeWorld self, float linear_threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_auto_disable_linear_threshold_21_comment =
  "C++ Interface:\n"
  "set_auto_disable_linear_threshold(const OdeWorld self, float linear_threshold)\n";
#else
static const char *Dtool_OdeWorld_set_auto_disable_linear_threshold_21_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_auto_disable_angular_threshold(dReal angular_threshold)
 */
static PyObject *Dtool_OdeWorld_set_auto_disable_angular_threshold_22(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_auto_disable_angular_threshold")) {
    return NULL;
  }
  // 1-inline void OdeWorld::set_auto_disable_angular_threshold(dReal angular_threshold)
  if (PyNumber_Check(arg)) {
    (*local_this).set_auto_disable_angular_threshold((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_angular_threshold(const OdeWorld self, float angular_threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_auto_disable_angular_threshold_22_comment =
  "C++ Interface:\n"
  "set_auto_disable_angular_threshold(const OdeWorld self, float angular_threshold)\n";
#else
static const char *Dtool_OdeWorld_set_auto_disable_angular_threshold_22_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_auto_disable_steps(int steps)
 */
static PyObject *Dtool_OdeWorld_set_auto_disable_steps_23(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_auto_disable_steps")) {
    return NULL;
  }
  // 1-inline void OdeWorld::set_auto_disable_steps(int steps)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_auto_disable_steps((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_steps(const OdeWorld self, int steps)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_auto_disable_steps_23_comment =
  "C++ Interface:\n"
  "set_auto_disable_steps(const OdeWorld self, int steps)\n";
#else
static const char *Dtool_OdeWorld_set_auto_disable_steps_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_auto_disable_time(dReal time)
 */
static PyObject *Dtool_OdeWorld_set_auto_disable_time_24(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_auto_disable_time")) {
    return NULL;
  }
  // 1-inline void OdeWorld::set_auto_disable_time(dReal time)
  if (PyNumber_Check(arg)) {
    (*local_this).set_auto_disable_time((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_time(const OdeWorld self, float time)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_auto_disable_time_24_comment =
  "C++ Interface:\n"
  "set_auto_disable_time(const OdeWorld self, float time)\n";
#else
static const char *Dtool_OdeWorld_set_auto_disable_time_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_auto_disable_flag(int do_auto_disable)
 */
static PyObject *Dtool_OdeWorld_set_auto_disable_flag_25(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_auto_disable_flag")) {
    return NULL;
  }
  // 1-inline void OdeWorld::set_auto_disable_flag(int do_auto_disable)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_auto_disable_flag((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_flag(const OdeWorld self, int do_auto_disable)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_auto_disable_flag_25_comment =
  "C++ Interface:\n"
  "set_auto_disable_flag(const OdeWorld self, int do_auto_disable)\n";
#else
static const char *Dtool_OdeWorld_set_auto_disable_flag_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeWorld::get_gravity(void) const
 */
static PyObject *Dtool_OdeWorld_get_gravity_26(PyObject *self, PyObject *) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeWorld, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeWorld::get_gravity(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeWorld*)local_this).get_gravity());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_gravity_26_comment =
  "C++ Interface:\n"
  "get_gravity(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_gravity_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeWorld::get_erp(void) const
 */
static PyObject *Dtool_OdeWorld_get_erp_27(PyObject *self, PyObject *) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeWorld, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeWorld::get_erp(void) const
  dReal return_value = (*(const OdeWorld*)local_this).get_erp();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_erp_27_comment =
  "C++ Interface:\n"
  "get_erp(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_erp_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeWorld::get_cfm(void) const
 */
static PyObject *Dtool_OdeWorld_get_cfm_28(PyObject *self, PyObject *) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeWorld, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeWorld::get_cfm(void) const
  dReal return_value = (*(const OdeWorld*)local_this).get_cfm();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_cfm_28_comment =
  "C++ Interface:\n"
  "get_cfm(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_cfm_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeWorld::get_quick_step_num_iterations(void) const
 */
static PyObject *Dtool_OdeWorld_get_quick_step_num_iterations_29(PyObject *self, PyObject *) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeWorld, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeWorld::get_quick_step_num_iterations(void) const
  int return_value = (*(const OdeWorld*)local_this).get_quick_step_num_iterations();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_quick_step_num_iterations_29_comment =
  "C++ Interface:\n"
  "get_quick_step_num_iterations(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_quick_step_num_iterations_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeWorld::get_quick_step_w(void) const
 */
static PyObject *Dtool_OdeWorld_get_quick_step_w_30(PyObject *self, PyObject *) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeWorld, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeWorld::get_quick_step_w(void) const
  dReal return_value = (*(const OdeWorld*)local_this).get_quick_step_w();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_quick_step_w_30_comment =
  "C++ Interface:\n"
  "get_quick_step_w(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_quick_step_w_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeWorld::get_contact_max_correcting_vel(void) const
 */
static PyObject *Dtool_OdeWorld_get_contact_max_correcting_vel_31(PyObject *self, PyObject *) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeWorld, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeWorld::get_contact_max_correcting_vel(void) const
  dReal return_value = (*(const OdeWorld*)local_this).get_contact_max_correcting_vel();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_contact_max_correcting_vel_31_comment =
  "C++ Interface:\n"
  "get_contact_max_correcting_vel(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_contact_max_correcting_vel_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeWorld::get_contact_surface_layer(void) const
 */
static PyObject *Dtool_OdeWorld_get_contact_surface_layer_32(PyObject *self, PyObject *) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeWorld, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeWorld::get_contact_surface_layer(void) const
  dReal return_value = (*(const OdeWorld*)local_this).get_contact_surface_layer();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_contact_surface_layer_32_comment =
  "C++ Interface:\n"
  "get_contact_surface_layer(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_contact_surface_layer_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeWorld::get_auto_disable_linear_threshold(void) const
 */
static PyObject *Dtool_OdeWorld_get_auto_disable_linear_threshold_33(PyObject *self, PyObject *) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeWorld, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeWorld::get_auto_disable_linear_threshold(void) const
  dReal return_value = (*(const OdeWorld*)local_this).get_auto_disable_linear_threshold();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_auto_disable_linear_threshold_33_comment =
  "C++ Interface:\n"
  "get_auto_disable_linear_threshold(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_auto_disable_linear_threshold_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeWorld::get_auto_disable_angular_threshold(void) const
 */
static PyObject *Dtool_OdeWorld_get_auto_disable_angular_threshold_34(PyObject *self, PyObject *) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeWorld, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeWorld::get_auto_disable_angular_threshold(void) const
  dReal return_value = (*(const OdeWorld*)local_this).get_auto_disable_angular_threshold();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_auto_disable_angular_threshold_34_comment =
  "C++ Interface:\n"
  "get_auto_disable_angular_threshold(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_auto_disable_angular_threshold_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeWorld::get_auto_disable_steps(void) const
 */
static PyObject *Dtool_OdeWorld_get_auto_disable_steps_35(PyObject *self, PyObject *) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeWorld, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeWorld::get_auto_disable_steps(void) const
  int return_value = (*(const OdeWorld*)local_this).get_auto_disable_steps();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_auto_disable_steps_35_comment =
  "C++ Interface:\n"
  "get_auto_disable_steps(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_auto_disable_steps_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeWorld::get_auto_disable_time(void) const
 */
static PyObject *Dtool_OdeWorld_get_auto_disable_time_36(PyObject *self, PyObject *) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeWorld, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeWorld::get_auto_disable_time(void) const
  dReal return_value = (*(const OdeWorld*)local_this).get_auto_disable_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_auto_disable_time_36_comment =
  "C++ Interface:\n"
  "get_auto_disable_time(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_auto_disable_time_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeWorld::get_auto_disable_flag(void) const
 */
static PyObject *Dtool_OdeWorld_get_auto_disable_flag_37(PyObject *self, PyObject *) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeWorld, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeWorld::get_auto_disable_flag(void) const
  int return_value = (*(const OdeWorld*)local_this).get_auto_disable_flag();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_auto_disable_flag_37_comment =
  "C++ Interface:\n"
  "get_auto_disable_flag(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_auto_disable_flag_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeWorld::impulse_to_force(dReal stepsize, LVecBase3f const &impulse)
 * inline LVecBase3f OdeWorld::impulse_to_force(dReal stepsize, dReal ix, dReal iy, dReal iz)
 */
static PyObject *Dtool_OdeWorld_impulse_to_force_38(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.impulse_to_force")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline LVecBase3f OdeWorld::impulse_to_force(dReal stepsize, LVecBase3f const &impulse)
      float param1;
      PyObject *param2;
      static const char *keyword_list[] = {"stepsize", "impulse", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:impulse_to_force", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeWorld.impulse_to_force", "LVecBase3f");
        }
        LVecBase3f *return_value = new LVecBase3f((*local_this).impulse_to_force((dReal)param1, *param2_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LVecBase3f OdeWorld::impulse_to_force(dReal stepsize, dReal ix, dReal iy, dReal iz)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"stepsize", "ix", "iy", "iz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:impulse_to_force", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        LVecBase3f *return_value = new LVecBase3f((*local_this).impulse_to_force((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "impulse_to_force() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "impulse_to_force(const OdeWorld self, float stepsize, const LVecBase3f impulse)\n"
      "impulse_to_force(const OdeWorld self, float stepsize, float ix, float iy, float iz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_impulse_to_force_38_comment =
  "C++ Interface:\n"
  "impulse_to_force(const OdeWorld self, float stepsize, const LVecBase3f impulse)\n"
  "impulse_to_force(const OdeWorld self, float stepsize, float ix, float iy, float iz)\n";
#else
static const char *Dtool_OdeWorld_impulse_to_force_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::step(dReal stepsize)
 */
static PyObject *Dtool_OdeWorld_step_39(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.step")) {
    return NULL;
  }
  // 1-inline void OdeWorld::step(dReal stepsize)
  if (PyNumber_Check(arg)) {
    (*local_this).step((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "step(const OdeWorld self, float stepsize)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_step_39_comment =
  "C++ Interface:\n"
  "step(const OdeWorld self, float stepsize)\n";
#else
static const char *Dtool_OdeWorld_step_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::quick_step(dReal stepsize)
 */
static PyObject *Dtool_OdeWorld_quick_step_40(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.quick_step")) {
    return NULL;
  }
  // 1-inline void OdeWorld::quick_step(dReal stepsize)
  if (PyNumber_Check(arg)) {
    (*local_this).quick_step((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "quick_step(const OdeWorld self, float stepsize)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_quick_step_40_comment =
  "C++ Interface:\n"
  "quick_step(const OdeWorld self, float stepsize)\n";
#else
static const char *Dtool_OdeWorld_quick_step_40_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeWorld::compare_to(OdeWorld const &other) const
 */
static PyObject *Dtool_OdeWorld_compare_to_41(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeWorld, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeWorld::compare_to(OdeWorld const &other) const
  OdeWorld const *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 1, "OdeWorld.compare_to", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const OdeWorld*)local_this).compare_to(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(OdeWorld self, const OdeWorld other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_compare_to_41_comment =
  "C++ Interface:\n"
  "compare_to(OdeWorld self, const OdeWorld other)\n";
#else
static const char *Dtool_OdeWorld_compare_to_41_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeWorld::init_surface_table(uint8_t num_surfaces)
 */
static PyObject *Dtool_OdeWorld_init_surface_table_42(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.init_surface_table")) {
    return NULL;
  }
  // 1-void OdeWorld::init_surface_table(uint8_t num_surfaces)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > UCHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned byte",
                          param1);
    }
#endif
    (*local_this).init_surface_table((uint8_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "init_surface_table(const OdeWorld self, int num_surfaces)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_init_surface_table_42_comment =
  "C++ Interface:\n"
  "init_surface_table(const OdeWorld self, int num_surfaces)\n";
#else
static const char *Dtool_OdeWorld_init_surface_table_42_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeWorld::add_body_dampening(OdeBody &body, int surface)
 */
static PyObject *Dtool_OdeWorld_add_body_dampening_43(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.add_body_dampening")) {
    return NULL;
  }
  // 1-void OdeWorld::add_body_dampening(OdeBody &body, int surface)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"body", "surface", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:add_body_dampening", (char **)keyword_list, &param1, &param2)) {
    OdeBody *param1_this;
    bool param1_manage = false;
    if (!Dtool_Coerce_OdeBody(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "OdeWorld.add_body_dampening", "OdeBody");
    }
    (*local_this).add_body_dampening(*param1_this, (int)param2);
    if (param1_manage) {
      delete param1_this;
    }
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_body_dampening(const OdeWorld self, OdeBody body, int surface)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_add_body_dampening_43_comment =
  "C++ Interface:\n"
  "add_body_dampening(const OdeWorld self, OdeBody body, int surface)\n"
  "\n"
  "// void assign_surface_body(OdeBody& body, int surface);";
#else
static const char *Dtool_OdeWorld_add_body_dampening_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeWorld::set_surface_entry(uint8_t pos1, uint8_t pos2, dReal mu, dReal bounce, dReal bounce_vel, dReal soft_erp, dReal soft_cfm, dReal slip, dReal dampen)
 */
static PyObject *Dtool_OdeWorld_set_surface_entry_44(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_surface_entry")) {
    return NULL;
  }
  // 1-void OdeWorld::set_surface_entry(uint8_t pos1, uint8_t pos2, dReal mu, dReal bounce, dReal bounce_vel, dReal soft_erp, dReal soft_cfm, dReal slip, dReal dampen)
  long param1;
  long param2;
  float param3;
  float param4;
  float param5;
  float param6;
  float param7;
  float param8;
  float param9;
  static const char *keyword_list[] = {"pos1", "pos2", "mu", "bounce", "bounce_vel", "soft_erp", "soft_cfm", "slip", "dampen", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "llfffffff:set_surface_entry", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9)) {
#ifndef NDEBUG
    if (param1 < 0 || param1 > UCHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned byte",
                          param1);
    }
#endif
#ifndef NDEBUG
    if (param2 < 0 || param2 > UCHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned byte",
                          param2);
    }
#endif
    (*local_this).set_surface_entry((uint8_t)param1, (uint8_t)param2, (dReal)param3, (dReal)param4, (dReal)param5, (dReal)param6, (dReal)param7, (dReal)param8, (dReal)param9);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_surface_entry(const OdeWorld self, int pos1, int pos2, float mu, float bounce, float bounce_vel, float soft_erp, float soft_cfm, float slip, float dampen)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_surface_entry_44_comment =
  "C++ Interface:\n"
  "set_surface_entry(const OdeWorld self, int pos1, int pos2, float mu, float bounce, float bounce_vel, float soft_erp, float soft_cfm, float slip, float dampen)\n";
#else
static const char *Dtool_OdeWorld_set_surface_entry_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * float OdeWorld::apply_dampening(float dt, OdeBody &body)
 */
static PyObject *Dtool_OdeWorld_apply_dampening_45(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.apply_dampening")) {
    return NULL;
  }
  // 1-float OdeWorld::apply_dampening(float dt, OdeBody &body)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"dt", "body", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:apply_dampening", (char **)keyword_list, &param1, &param2)) {
    OdeBody *param2_this;
    bool param2_manage = false;
    if (!Dtool_Coerce_OdeBody(param2, param2_this, param2_manage)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "OdeWorld.apply_dampening", "OdeBody");
    }
    float return_value = (*local_this).apply_dampening((float)param1, *param2_this);
    if (param2_manage) {
      delete param2_this;
    }
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_dampening(const OdeWorld self, float dt, OdeBody body)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_apply_dampening_45_comment =
  "C++ Interface:\n"
  "apply_dampening(const OdeWorld self, float dt, OdeBody body)\n";
#else
static const char *Dtool_OdeWorld_apply_dampening_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeWorld::get_class_type(void)
 */
static PyObject *Dtool_OdeWorld_get_class_type_47(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeWorld::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeWorld::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_class_type_47_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeWorld_get_class_type_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeWorld::OdeWorld(void)
 * OdeWorld::OdeWorld(OdeWorld const &copy)
 */
static int Dtool_Init_OdeWorld(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-OdeWorld::OdeWorld(void)
      OdeWorld *return_value = new OdeWorld();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeWorld, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-OdeWorld::OdeWorld(OdeWorld const &copy)
      OdeWorld const *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeWorld.OdeWorld", true, true);
      if (arg_this != NULL) {
        OdeWorld *return_value = new OdeWorld(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeWorld, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeWorld() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeWorld()\n"
      "OdeWorld(const OdeWorld copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeWorld(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeWorld) {
    printf("OdeWorld ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeWorld *local_this = (OdeWorld *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeWorld) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeWorld(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeWorld) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeWorld*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeJointGroup
 */
/**
 * Python function wrapper for:
 * void OdeJointGroup::destroy(void)
 */
static PyObject *Dtool_OdeJointGroup_destroy_50(PyObject *self, PyObject *) {
  OdeJointGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJointGroup, (void **)&local_this, "OdeJointGroup.destroy")) {
    return NULL;
  }
  // 1-void OdeJointGroup::destroy(void)
  (*local_this).destroy();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeJointGroup_destroy_50_comment =
  "C++ Interface:\n"
  "destroy(const OdeJointGroup self)\n";
#else
static const char *Dtool_OdeJointGroup_destroy_50_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeJointGroup::empty(void) const
 */
static PyObject *Dtool_OdeJointGroup_empty_52(PyObject *self, PyObject *) {
  OdeJointGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJointGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void OdeJointGroup::empty(void) const
  (*(const OdeJointGroup*)local_this).empty();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeJointGroup_empty_52_comment =
  "C++ Interface:\n"
  "empty(OdeJointGroup self)\n";
#else
static const char *Dtool_OdeJointGroup_empty_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeJointGroup::compare_to(OdeJointGroup const &other) const
 */
static PyObject *Dtool_OdeJointGroup_compare_to_53(PyObject *self, PyObject *arg) {
  OdeJointGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJointGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeJointGroup::compare_to(OdeJointGroup const &other) const
  OdeJointGroup const *arg_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointGroup, 1, "OdeJointGroup.compare_to", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const OdeJointGroup*)local_this).compare_to(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(OdeJointGroup self, const OdeJointGroup other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeJointGroup_compare_to_53_comment =
  "C++ Interface:\n"
  "compare_to(OdeJointGroup self, const OdeJointGroup other)\n";
#else
static const char *Dtool_OdeJointGroup_compare_to_53_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeJointGroup::get_class_type(void)
 */
static PyObject *Dtool_OdeJointGroup_get_class_type_54(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeJointGroup::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeJointGroup::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeJointGroup_get_class_type_54_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeJointGroup_get_class_type_54_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeJointGroup::OdeJointGroup(void)
 * inline OdeJointGroup::OdeJointGroup(OdeJointGroup const &) = default
 */
static int Dtool_Init_OdeJointGroup(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-OdeJointGroup::OdeJointGroup(void)
      OdeJointGroup *return_value = new OdeJointGroup();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeJointGroup, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline OdeJointGroup::OdeJointGroup(OdeJointGroup const &) = default
      OdeJointGroup const *arg_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointGroup, 0, "OdeJointGroup.OdeJointGroup", true, true);
      if (arg_this != NULL) {
        OdeJointGroup *return_value = new OdeJointGroup(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeJointGroup, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeJointGroup() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeJointGroup()\n"
      "OdeJointGroup(const OdeJointGroup param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeJointGroup(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeJointGroup) {
    printf("OdeJointGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeJointGroup *local_this = (OdeJointGroup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeJointGroup) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeJointGroup(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeJointGroup) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeJointGroup*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeJointFeedback
 */
/**
 * Python function wrapper for:
 * inline LVector3f const OdeJointFeedback::get_force1(void) const
 */
static PyObject *Dtool_OdeJointFeedback_get_force1_57(PyObject *self, PyObject *) {
  OdeJointFeedback *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJointFeedback, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3f const OdeJointFeedback::get_force1(void) const
  LVector3f const *return_value = new LVector3f const((*(const OdeJointFeedback*)local_this).get_force1());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, true);
}

#ifndef NDEBUG
static const char *Dtool_OdeJointFeedback_get_force1_57_comment =
  "C++ Interface:\n"
  "get_force1(OdeJointFeedback self)\n";
#else
static const char *Dtool_OdeJointFeedback_get_force1_57_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3f const OdeJointFeedback::get_force2(void) const
 */
static PyObject *Dtool_OdeJointFeedback_get_force2_58(PyObject *self, PyObject *) {
  OdeJointFeedback *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJointFeedback, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3f const OdeJointFeedback::get_force2(void) const
  LVector3f const *return_value = new LVector3f const((*(const OdeJointFeedback*)local_this).get_force2());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, true);
}

#ifndef NDEBUG
static const char *Dtool_OdeJointFeedback_get_force2_58_comment =
  "C++ Interface:\n"
  "get_force2(OdeJointFeedback self)\n";
#else
static const char *Dtool_OdeJointFeedback_get_force2_58_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3f const OdeJointFeedback::get_torque1(void) const
 */
static PyObject *Dtool_OdeJointFeedback_get_torque1_59(PyObject *self, PyObject *) {
  OdeJointFeedback *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJointFeedback, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3f const OdeJointFeedback::get_torque1(void) const
  LVector3f const *return_value = new LVector3f const((*(const OdeJointFeedback*)local_this).get_torque1());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, true);
}

#ifndef NDEBUG
static const char *Dtool_OdeJointFeedback_get_torque1_59_comment =
  "C++ Interface:\n"
  "get_torque1(OdeJointFeedback self)\n";
#else
static const char *Dtool_OdeJointFeedback_get_torque1_59_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3f const OdeJointFeedback::get_torque2(void) const
 */
static PyObject *Dtool_OdeJointFeedback_get_torque2_60(PyObject *self, PyObject *) {
  OdeJointFeedback *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJointFeedback, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3f const OdeJointFeedback::get_torque2(void) const
  LVector3f const *return_value = new LVector3f const((*(const OdeJointFeedback*)local_this).get_torque2());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, true);
}

#ifndef NDEBUG
static const char *Dtool_OdeJointFeedback_get_torque2_60_comment =
  "C++ Interface:\n"
  "get_torque2(OdeJointFeedback self)\n";
#else
static const char *Dtool_OdeJointFeedback_get_torque2_60_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeJointFeedback::OdeJointFeedback(void) = default
 */
static int Dtool_Init_OdeJointFeedback(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "OdeJointFeedback() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline OdeJointFeedback::OdeJointFeedback(void) = default
  OdeJointFeedback *return_value = new OdeJointFeedback();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeJointFeedback, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeJointFeedback()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeJointFeedback(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeJointFeedback) {
    printf("OdeJointFeedback ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeJointFeedback *local_this = (OdeJointFeedback *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeJointFeedback) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeJointFeedback(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeJointFeedback) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeJoint
 */
/**
 * Python function wrapper for:
 * void OdeJoint::destroy(void)
 */
static PyObject *Dtool_OdeJoint_destroy_65(PyObject *self, PyObject *) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJoint, (void **)&local_this, "OdeJoint.destroy")) {
    return NULL;
  }
  // 1-void OdeJoint::destroy(void)
  (*local_this).destroy();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_destroy_65_comment =
  "C++ Interface:\n"
  "destroy(const OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_destroy_65_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool OdeJoint::is_empty(void) const
 */
static PyObject *Dtool_OdeJoint_is_empty_66(PyObject *self, PyObject *) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool OdeJoint::is_empty(void) const
  bool return_value = (*(const OdeJoint*)local_this).is_empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_is_empty_66_comment =
  "C++ Interface:\n"
  "is_empty(OdeJoint self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ID is 0, meaning the OdeJoint does not point to a valid\n"
  " * joint.  It is an error to call a method on an empty joint.  Note that an\n"
  " * empty OdeJoint also evaluates to False.\n"
  " */";
#else
static const char *Dtool_OdeJoint_is_empty_66_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeJoint::get_joint_type(void) const
 */
static PyObject *Dtool_OdeJoint_get_joint_type_68(PyObject *self, PyObject *) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeJoint::get_joint_type(void) const
  int return_value = (*(const OdeJoint*)local_this).get_joint_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_get_joint_type_68_comment =
  "C++ Interface:\n"
  "get_joint_type(OdeJoint self)\n"
  "\n"
  "/* INLINE void *get_data(); */";
#else
static const char *Dtool_OdeJoint_get_joint_type_68_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeBody OdeJoint::get_body(int index) const
 */
static PyObject *Dtool_OdeJoint_get_body_69(PyObject *self, PyObject *arg) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeBody OdeJoint::get_body(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    OdeBody *return_value = new OdeBody((*(const OdeJoint*)local_this).get_body((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeBody, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_body(OdeJoint self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_get_body_69_comment =
  "C++ Interface:\n"
  "get_body(OdeJoint self, int index)\n";
#else
static const char *Dtool_OdeJoint_get_body_69_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeJoint::set_feedback(OdeJointFeedback *)
 * inline void OdeJoint::set_feedback(bool flag = true)
 */
static PyObject *Dtool_OdeJoint_set_feedback_70(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJoint, (void **)&local_this, "OdeJoint.set_feedback")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void OdeJoint::set_feedback(bool flag)
      (*local_this).set_feedback();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      {
        // -2 inline void OdeJoint::set_feedback(OdeJointFeedback *)
        PyObject *param1;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_feedback", (char **)keyword_list, &param1)) {
          OdeJointFeedback *param1_this = (OdeJointFeedback *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointFeedback, 1, "OdeJoint.set_feedback", false, false);
          if (param1_this != NULL) {
            (*local_this).set_feedback(param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void OdeJoint::set_feedback(bool flag)
        PyObject *param1;
        static const char *keyword_list[] = {"flag", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_feedback", (char **)keyword_list, &param1)) {
          (*local_this).set_feedback((PyObject_IsTrue(param1) != 0));
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void OdeJoint::set_feedback(OdeJointFeedback *)
      // No coercion possible: inline void OdeJoint::set_feedback(bool flag)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_feedback() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_feedback(const OdeJoint self)\n"
      "set_feedback(const OdeJoint self, OdeJointFeedback param0)\n"
      "set_feedback(const OdeJoint self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_set_feedback_70_comment =
  "C++ Interface:\n"
  "set_feedback(const OdeJoint self)\n"
  "set_feedback(const OdeJoint self, OdeJointFeedback param0)\n"
  "set_feedback(const OdeJoint self, bool flag)\n";
#else
static const char *Dtool_OdeJoint_set_feedback_70_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeJointFeedback *OdeJoint::get_feedback(void)
 */
static PyObject *Dtool_OdeJoint_get_feedback_71(PyObject *self, PyObject *) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJoint, (void **)&local_this, "OdeJoint.get_feedback")) {
    return NULL;
  }
  // 1-inline OdeJointFeedback *OdeJoint::get_feedback(void)
  OdeJointFeedback *return_value = (*local_this).get_feedback();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OdeJointFeedback, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_get_feedback_71_comment =
  "C++ Interface:\n"
  "get_feedback(const OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_get_feedback_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeJoint::attach(OdeBody const *body1, OdeBody const *body2)
 */
static PyObject *Dtool_OdeJoint_attach_72(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJoint, (void **)&local_this, "OdeJoint.attach")) {
    return NULL;
  }
  // 1-void OdeJoint::attach(OdeBody const *body1, OdeBody const *body2)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"body1", "body2", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:attach", (char **)keyword_list, &param1, &param2)) {
    OdeBody const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_OdeBody(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "OdeJoint.attach", "OdeBody");
    }
    OdeBody const *param2_this;
    bool param2_manage = false;
    if (!Dtool_ConstCoerce_OdeBody(param2, param2_this, param2_manage)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "OdeJoint.attach", "OdeBody");
    }
    invoke_extension(local_this).attach(param1_this, param2_this);
    if (param1_manage) {
      delete param1_this;
    }
    if (param2_manage) {
      delete param2_this;
    }
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach(const OdeJoint self, const OdeBody body1, const OdeBody body2)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_attach_72_comment =
  "C++ Interface:\n"
  "attach(const OdeJoint self, const OdeBody body1, const OdeBody body2)\n";
#else
static const char *Dtool_OdeJoint_attach_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeJoint::attach_bodies(OdeBody const &body1, OdeBody const &body2)
 */
static PyObject *Dtool_OdeJoint_attach_bodies_73(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJoint, (void **)&local_this, "OdeJoint.attach_bodies")) {
    return NULL;
  }
  // 1-void OdeJoint::attach_bodies(OdeBody const &body1, OdeBody const &body2)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"body1", "body2", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:attach_bodies", (char **)keyword_list, &param1, &param2)) {
    OdeBody const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_OdeBody(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "OdeJoint.attach_bodies", "OdeBody");
    }
    OdeBody const *param2_this;
    bool param2_manage = false;
    if (!Dtool_ConstCoerce_OdeBody(param2, param2_this, param2_manage)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "OdeJoint.attach_bodies", "OdeBody");
    }
    (*local_this).attach_bodies(*param1_this, *param2_this);
    if (param1_manage) {
      delete param1_this;
    }
    if (param2_manage) {
      delete param2_this;
    }
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach_bodies(const OdeJoint self, const OdeBody body1, const OdeBody body2)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_attach_bodies_73_comment =
  "C++ Interface:\n"
  "attach_bodies(const OdeJoint self, const OdeBody body1, const OdeBody body2)\n"
  "\n"
  "/**\n"
  " * Attaches two OdeBody objects to this joint.  Order is important.  Consider\n"
  " * using the OdeJoint::attach extension function if you're using the Python\n"
  " * interface.\n"
  " */";
#else
static const char *Dtool_OdeJoint_attach_bodies_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeJoint::attach_body(OdeBody const &body, int index)
 */
static PyObject *Dtool_OdeJoint_attach_body_74(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJoint, (void **)&local_this, "OdeJoint.attach_body")) {
    return NULL;
  }
  // 1-void OdeJoint::attach_body(OdeBody const &body, int index)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"body", "index", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:attach_body", (char **)keyword_list, &param1, &param2)) {
    OdeBody const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_OdeBody(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "OdeJoint.attach_body", "OdeBody");
    }
    (*local_this).attach_body(*param1_this, (int)param2);
    if (param1_manage) {
      delete param1_this;
    }
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach_body(const OdeJoint self, const OdeBody body, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_attach_body_74_comment =
  "C++ Interface:\n"
  "attach_body(const OdeJoint self, const OdeBody body, int index)\n"
  "\n"
  "/**\n"
  " * Attaches a single OdeBody to this joint at the specified index (0 or 1).\n"
  " * The other index will be set to the environment (null). Consider using the\n"
  " * OdeJoint::attach extension function if you're using the Python interface.\n"
  " */";
#else
static const char *Dtool_OdeJoint_attach_body_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeJoint::detach(void)
 */
static PyObject *Dtool_OdeJoint_detach_75(PyObject *self, PyObject *) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJoint, (void **)&local_this, "OdeJoint.detach")) {
    return NULL;
  }
  // 1-void OdeJoint::detach(void)
  (*local_this).detach();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_detach_75_comment =
  "C++ Interface:\n"
  "detach(const OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_detach_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void OdeJoint::write(ostream &out = ::cout, unsigned int indent = 0) const
 */
static PyObject *Dtool_OdeJoint_write_76(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-virtual void OdeJoint::write(ostream &out, unsigned int indent) const
      (*(const OdeJoint*)local_this).write();
      return Dtool_Return_None();
    }
    break;
  case 1:
  case 2:
    {
      // 1-virtual void OdeJoint::write(ostream &out, unsigned int indent = 0) const
      PyObject *param1;
      unsigned long param2 = 0;
      static const char *keyword_list[] = {"out", "indent", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write", (char **)keyword_list, &param1, &param2)) {
        ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "OdeJoint.write", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param2 > UINT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %lu out of range for unsigned integer",
                              param2);
        }
#endif
        if (param1_this != NULL) {
          (*(const OdeJoint*)local_this).write(*param1_this, (unsigned int)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "write() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(OdeJoint self)\n"
      "write(OdeJoint self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_write_76_comment =
  "C++ Interface:\n"
  "write(OdeJoint self)\n"
  "write(OdeJoint self, ostream out, int indent)\n";
#else
static const char *Dtool_OdeJoint_write_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeJoint::compare_to(OdeJoint const &other) const
 */
static PyObject *Dtool_OdeJoint_compare_to_77(PyObject *self, PyObject *arg) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeJoint::compare_to(OdeJoint const &other) const
  OdeJoint const *arg_this = (OdeJoint *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJoint, 1, "OdeJoint.compare_to", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const OdeJoint*)local_this).compare_to(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(OdeJoint self, const OdeJoint other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_compare_to_77_comment =
  "C++ Interface:\n"
  "compare_to(OdeJoint self, const OdeJoint other)\n";
#else
static const char *Dtool_OdeJoint_compare_to_77_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *OdeJoint::convert(void) const
 */
static PyObject *Dtool_OdeJoint_convert_80(PyObject *self, PyObject *) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-PyObject *OdeJoint::convert(void) const
  PyObject *return_value = invoke_extension((const OdeJoint*)local_this).convert();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_80_comment =
  "C++ Interface:\n"
  "convert(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_80_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeBallJoint OdeJoint::convert_to_ball(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_ball_81(PyObject *self, PyObject *) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeBallJoint OdeJoint::convert_to_ball(void) const
  OdeBallJoint *return_value = new OdeBallJoint((*(const OdeJoint*)local_this).convert_to_ball());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeBallJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_ball_81_comment =
  "C++ Interface:\n"
  "convert_to_ball(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_ball_81_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeHingeJoint OdeJoint::convert_to_hinge(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_hinge_82(PyObject *self, PyObject *) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeHingeJoint OdeJoint::convert_to_hinge(void) const
  OdeHingeJoint *return_value = new OdeHingeJoint((*(const OdeJoint*)local_this).convert_to_hinge());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeHingeJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_hinge_82_comment =
  "C++ Interface:\n"
  "convert_to_hinge(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_hinge_82_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeSliderJoint OdeJoint::convert_to_slider(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_slider_83(PyObject *self, PyObject *) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeSliderJoint OdeJoint::convert_to_slider(void) const
  OdeSliderJoint *return_value = new OdeSliderJoint((*(const OdeJoint*)local_this).convert_to_slider());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeSliderJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_slider_83_comment =
  "C++ Interface:\n"
  "convert_to_slider(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_slider_83_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeContactJoint OdeJoint::convert_to_contact(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_contact_84(PyObject *self, PyObject *) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeContactJoint OdeJoint::convert_to_contact(void) const
  OdeContactJoint *return_value = new OdeContactJoint((*(const OdeJoint*)local_this).convert_to_contact());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeContactJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_contact_84_comment =
  "C++ Interface:\n"
  "convert_to_contact(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_contact_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeUniversalJoint OdeJoint::convert_to_universal(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_universal_85(PyObject *self, PyObject *) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeUniversalJoint OdeJoint::convert_to_universal(void) const
  OdeUniversalJoint *return_value = new OdeUniversalJoint((*(const OdeJoint*)local_this).convert_to_universal());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeUniversalJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_universal_85_comment =
  "C++ Interface:\n"
  "convert_to_universal(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_universal_85_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeHinge2Joint OdeJoint::convert_to_hinge2(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_hinge2_86(PyObject *self, PyObject *) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeHinge2Joint OdeJoint::convert_to_hinge2(void) const
  OdeHinge2Joint *return_value = new OdeHinge2Joint((*(const OdeJoint*)local_this).convert_to_hinge2());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeHinge2Joint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_hinge2_86_comment =
  "C++ Interface:\n"
  "convert_to_hinge2(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_hinge2_86_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeFixedJoint OdeJoint::convert_to_fixed(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_fixed_87(PyObject *self, PyObject *) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeFixedJoint OdeJoint::convert_to_fixed(void) const
  OdeFixedJoint *return_value = new OdeFixedJoint((*(const OdeJoint*)local_this).convert_to_fixed());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeFixedJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_fixed_87_comment =
  "C++ Interface:\n"
  "convert_to_fixed(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_fixed_87_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeNullJoint OdeJoint::convert_to_null(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_null_88(PyObject *self, PyObject *) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeNullJoint OdeJoint::convert_to_null(void) const
  OdeNullJoint *return_value = new OdeNullJoint((*(const OdeJoint*)local_this).convert_to_null());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeNullJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_null_88_comment =
  "C++ Interface:\n"
  "convert_to_null(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_null_88_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeAMotorJoint OdeJoint::convert_to_a_motor(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_a_motor_89(PyObject *self, PyObject *) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeAMotorJoint OdeJoint::convert_to_a_motor(void) const
  OdeAMotorJoint *return_value = new OdeAMotorJoint((*(const OdeJoint*)local_this).convert_to_a_motor());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeAMotorJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_a_motor_89_comment =
  "C++ Interface:\n"
  "convert_to_a_motor(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_a_motor_89_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeLMotorJoint OdeJoint::convert_to_l_motor(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_l_motor_90(PyObject *self, PyObject *) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeLMotorJoint OdeJoint::convert_to_l_motor(void) const
  OdeLMotorJoint *return_value = new OdeLMotorJoint((*(const OdeJoint*)local_this).convert_to_l_motor());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeLMotorJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_l_motor_90_comment =
  "C++ Interface:\n"
  "convert_to_l_motor(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_l_motor_90_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdePlane2dJoint OdeJoint::convert_to_plane2d(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_plane2d_91(PyObject *self, PyObject *) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdePlane2dJoint OdeJoint::convert_to_plane2d(void) const
  OdePlane2dJoint *return_value = new OdePlane2dJoint((*(const OdeJoint*)local_this).convert_to_plane2d());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdePlane2dJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_plane2d_91_comment =
  "C++ Interface:\n"
  "convert_to_plane2d(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_plane2d_91_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeJoint_get_class_type_92(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeJoint::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_get_class_type_92_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeJoint_get_class_type_92_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeJoint::OdeJoint(OdeJoint const &) = default
 */
static int Dtool_Init_OdeJoint(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "OdeJoint() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline OdeJoint::OdeJoint(OdeJoint const &) = default
  OdeJoint const *arg_this = (OdeJoint *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJoint, 0, "OdeJoint.OdeJoint", true, true);
  if (arg_this != NULL) {
    OdeJoint *return_value = new OdeJoint(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeJoint, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeJoint(const OdeJoint param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeJoint) {
    printf("OdeJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeJoint *local_this = (OdeJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeJoint*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeAMotorJoint
 */
/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_num_axes(int num)
 */
static PyObject *Dtool_OdeAMotorJoint_set_num_axes_96(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_num_axes")) {
    return NULL;
  }
  // 1-inline void OdeAMotorJoint::set_num_axes(int num)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_num_axes((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_axes(const OdeAMotorJoint self, int num)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_num_axes_96_comment =
  "C++ Interface:\n"
  "set_num_axes(const OdeAMotorJoint self, int num)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_num_axes_96_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_axis(int anum, int rel, LVecBase3f const &axis)
 * inline void OdeAMotorJoint::set_axis(int anum, int rel, dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeAMotorJoint_set_axis_97(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_axis")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-inline void OdeAMotorJoint::set_axis(int anum, int rel, LVecBase3f const &axis)
      int param1;
      int param2;
      PyObject *param3;
      static const char *keyword_list[] = {"anum", "rel", "axis", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_axis", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase3f param3_local;
        LVecBase3f const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "OdeAMotorJoint.set_axis", "LVecBase3f");
        }
        (*local_this).set_axis((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 5:
    {
      // 1-inline void OdeAMotorJoint::set_axis(int anum, int rel, dReal x, dReal y, dReal z)
      int param1;
      int param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"anum", "rel", "x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iifff:set_axis", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        (*local_this).set_axis((int)param1, (int)param2, (dReal)param3, (dReal)param4, (dReal)param5);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_axis() takes 4 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_axis(const OdeAMotorJoint self, int anum, int rel, const LVecBase3f axis)\n"
      "set_axis(const OdeAMotorJoint self, int anum, int rel, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_axis_97_comment =
  "C++ Interface:\n"
  "set_axis(const OdeAMotorJoint self, int anum, int rel, const LVecBase3f axis)\n"
  "set_axis(const OdeAMotorJoint self, int anum, int rel, float x, float y, float z)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_axis_97_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_angle(int anum, dReal angle)
 */
static PyObject *Dtool_OdeAMotorJoint_set_angle_98(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_angle")) {
    return NULL;
  }
  // 1-inline void OdeAMotorJoint::set_angle(int anum, dReal angle)
  int param1;
  float param2;
  static const char *keyword_list[] = {"anum", "angle", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_angle", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_angle((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_angle(const OdeAMotorJoint self, int anum, float angle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_angle_98_comment =
  "C++ Interface:\n"
  "set_angle(const OdeAMotorJoint self, int anum, float angle)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_angle_98_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_mode(int mode)
 */
static PyObject *Dtool_OdeAMotorJoint_set_mode_99(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_mode")) {
    return NULL;
  }
  // 1-inline void OdeAMotorJoint::set_mode(int mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_mode((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mode(const OdeAMotorJoint self, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_mode_99_comment =
  "C++ Interface:\n"
  "set_mode(const OdeAMotorJoint self, int mode)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_mode_99_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::add_torques(dReal torque1, dReal torque2, dReal torque3)
 */
static PyObject *Dtool_OdeAMotorJoint_add_torques_100(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.add_torques")) {
    return NULL;
  }
  // 1-inline void OdeAMotorJoint::add_torques(dReal torque1, dReal torque2, dReal torque3)
  float param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"torque1", "torque2", "torque3", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:add_torques", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).add_torques((dReal)param1, (dReal)param2, (dReal)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_torques(const OdeAMotorJoint self, float torque1, float torque2, float torque3)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_add_torques_100_comment =
  "C++ Interface:\n"
  "add_torques(const OdeAMotorJoint self, float torque1, float torque2, float torque3)\n";
#else
static const char *Dtool_OdeAMotorJoint_add_torques_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeAMotorJoint::get_num_axes(void) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_num_axes_101(PyObject *self, PyObject *) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeAMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeAMotorJoint::get_num_axes(void) const
  int return_value = (*(const OdeAMotorJoint*)local_this).get_num_axes();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_num_axes_101_comment =
  "C++ Interface:\n"
  "get_num_axes(OdeAMotorJoint self)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_num_axes_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeAMotorJoint::get_axis(int anum) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_axis_102(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeAMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeAMotorJoint::get_axis(int anum) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3f *return_value = new LVecBase3f((*(const OdeAMotorJoint*)local_this).get_axis((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_axis(OdeAMotorJoint self, int anum)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_axis_102_comment =
  "C++ Interface:\n"
  "get_axis(OdeAMotorJoint self, int anum)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_axis_102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeAMotorJoint::get_axis_rel(int anum) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_axis_rel_104(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeAMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeAMotorJoint::get_axis_rel(int anum) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const OdeAMotorJoint*)local_this).get_axis_rel((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_axis_rel(OdeAMotorJoint self, int anum)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_axis_rel_104_comment =
  "C++ Interface:\n"
  "get_axis_rel(OdeAMotorJoint self, int anum)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_axis_rel_104_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_angle(int anum) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_angle_105(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeAMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeAMotorJoint::get_angle(int anum) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeAMotorJoint*)local_this).get_angle((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_angle(OdeAMotorJoint self, int anum)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_angle_105_comment =
  "C++ Interface:\n"
  "get_angle(OdeAMotorJoint self, int anum)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_angle_105_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_angle_rate(int anum) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_angle_rate_106(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeAMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeAMotorJoint::get_angle_rate(int anum) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeAMotorJoint*)local_this).get_angle_rate((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_angle_rate(OdeAMotorJoint self, int anum)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_angle_rate_106_comment =
  "C++ Interface:\n"
  "get_angle_rate(OdeAMotorJoint self, int anum)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_angle_rate_106_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeAMotorJoint::get_mode(void) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_mode_107(PyObject *self, PyObject *) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeAMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeAMotorJoint::get_mode(void) const
  int return_value = (*(const OdeAMotorJoint*)local_this).get_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_mode_107_comment =
  "C++ Interface:\n"
  "get_mode(OdeAMotorJoint self)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_mode_107_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_param_lo_stop(int axis, dReal val)
 */
static PyObject *Dtool_OdeAMotorJoint_set_param_lo_stop_108(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_param_lo_stop")) {
    return NULL;
  }
  // 1-inline void OdeAMotorJoint::set_param_lo_stop(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_lo_stop", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_lo_stop((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_lo_stop(const OdeAMotorJoint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_param_lo_stop_108_comment =
  "C++ Interface:\n"
  "set_param_lo_stop(const OdeAMotorJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_param_lo_stop_108_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_param_hi_stop(int axis, dReal val)
 */
static PyObject *Dtool_OdeAMotorJoint_set_param_hi_stop_109(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_param_hi_stop")) {
    return NULL;
  }
  // 1-inline void OdeAMotorJoint::set_param_hi_stop(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_hi_stop", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_hi_stop((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_hi_stop(const OdeAMotorJoint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_param_hi_stop_109_comment =
  "C++ Interface:\n"
  "set_param_hi_stop(const OdeAMotorJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_param_hi_stop_109_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_param_vel(int axis, dReal val)
 */
static PyObject *Dtool_OdeAMotorJoint_set_param_vel_110(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_param_vel")) {
    return NULL;
  }
  // 1-inline void OdeAMotorJoint::set_param_vel(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_vel", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_vel((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_vel(const OdeAMotorJoint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_param_vel_110_comment =
  "C++ Interface:\n"
  "set_param_vel(const OdeAMotorJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_param_vel_110_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_param_f_max(int axis, dReal val)
 */
static PyObject *Dtool_OdeAMotorJoint_set_param_f_max_111(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_param_f_max")) {
    return NULL;
  }
  // 1-inline void OdeAMotorJoint::set_param_f_max(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_f_max", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_f_max((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_f_max(const OdeAMotorJoint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_param_f_max_111_comment =
  "C++ Interface:\n"
  "set_param_f_max(const OdeAMotorJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_param_f_max_111_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_param_fudge_factor(int axis, dReal val)
 */
static PyObject *Dtool_OdeAMotorJoint_set_param_fudge_factor_112(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_param_fudge_factor")) {
    return NULL;
  }
  // 1-inline void OdeAMotorJoint::set_param_fudge_factor(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_fudge_factor", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_fudge_factor((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_fudge_factor(const OdeAMotorJoint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_param_fudge_factor_112_comment =
  "C++ Interface:\n"
  "set_param_fudge_factor(const OdeAMotorJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_param_fudge_factor_112_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_param_bounce(int axis, dReal val)
 */
static PyObject *Dtool_OdeAMotorJoint_set_param_bounce_113(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_param_bounce")) {
    return NULL;
  }
  // 1-inline void OdeAMotorJoint::set_param_bounce(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_bounce", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_bounce((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_bounce(const OdeAMotorJoint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_param_bounce_113_comment =
  "C++ Interface:\n"
  "set_param_bounce(const OdeAMotorJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_param_bounce_113_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_param_CFM(int axis, dReal val)
 */
static PyObject *Dtool_OdeAMotorJoint_set_param_CFM_114(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_param_CFM")) {
    return NULL;
  }
  // 1-inline void OdeAMotorJoint::set_param_CFM(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_CFM", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_CFM((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_CFM(const OdeAMotorJoint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_param_CFM_114_comment =
  "C++ Interface:\n"
  "set_param_CFM(const OdeAMotorJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_param_CFM_114_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_param_stop_ERP(int axis, dReal val)
 */
static PyObject *Dtool_OdeAMotorJoint_set_param_stop_ERP_115(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_param_stop_ERP")) {
    return NULL;
  }
  // 1-inline void OdeAMotorJoint::set_param_stop_ERP(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_stop_ERP", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_stop_ERP((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_ERP(const OdeAMotorJoint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_param_stop_ERP_115_comment =
  "C++ Interface:\n"
  "set_param_stop_ERP(const OdeAMotorJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_param_stop_ERP_115_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_param_stop_CFM(int axis, dReal val)
 */
static PyObject *Dtool_OdeAMotorJoint_set_param_stop_CFM_116(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_param_stop_CFM")) {
    return NULL;
  }
  // 1-inline void OdeAMotorJoint::set_param_stop_CFM(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_stop_CFM", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_stop_CFM((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_CFM(const OdeAMotorJoint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_param_stop_CFM_116_comment =
  "C++ Interface:\n"
  "set_param_stop_CFM(const OdeAMotorJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_param_stop_CFM_116_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_param_lo_stop(int axis) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_param_lo_stop_117(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeAMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeAMotorJoint::get_param_lo_stop(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeAMotorJoint*)local_this).get_param_lo_stop((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_lo_stop(OdeAMotorJoint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_param_lo_stop_117_comment =
  "C++ Interface:\n"
  "get_param_lo_stop(OdeAMotorJoint self, int axis)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_param_lo_stop_117_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_param_hi_stop(int axis) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_param_hi_stop_118(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeAMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeAMotorJoint::get_param_hi_stop(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeAMotorJoint*)local_this).get_param_hi_stop((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_hi_stop(OdeAMotorJoint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_param_hi_stop_118_comment =
  "C++ Interface:\n"
  "get_param_hi_stop(OdeAMotorJoint self, int axis)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_param_hi_stop_118_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_param_vel(int axis) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_param_vel_119(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeAMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeAMotorJoint::get_param_vel(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeAMotorJoint*)local_this).get_param_vel((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_vel(OdeAMotorJoint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_param_vel_119_comment =
  "C++ Interface:\n"
  "get_param_vel(OdeAMotorJoint self, int axis)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_param_vel_119_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_param_f_max(int axis) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_param_f_max_120(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeAMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeAMotorJoint::get_param_f_max(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeAMotorJoint*)local_this).get_param_f_max((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_f_max(OdeAMotorJoint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_param_f_max_120_comment =
  "C++ Interface:\n"
  "get_param_f_max(OdeAMotorJoint self, int axis)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_param_f_max_120_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_param_fudge_factor(int axis) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_param_fudge_factor_121(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeAMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeAMotorJoint::get_param_fudge_factor(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeAMotorJoint*)local_this).get_param_fudge_factor((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_fudge_factor(OdeAMotorJoint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_param_fudge_factor_121_comment =
  "C++ Interface:\n"
  "get_param_fudge_factor(OdeAMotorJoint self, int axis)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_param_fudge_factor_121_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_param_bounce(int axis) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_param_bounce_122(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeAMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeAMotorJoint::get_param_bounce(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeAMotorJoint*)local_this).get_param_bounce((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_bounce(OdeAMotorJoint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_param_bounce_122_comment =
  "C++ Interface:\n"
  "get_param_bounce(OdeAMotorJoint self, int axis)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_param_bounce_122_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_param_CFM(int axis) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_param_CFM_123(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeAMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeAMotorJoint::get_param_CFM(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeAMotorJoint*)local_this).get_param_CFM((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_CFM(OdeAMotorJoint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_param_CFM_123_comment =
  "C++ Interface:\n"
  "get_param_CFM(OdeAMotorJoint self, int axis)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_param_CFM_123_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_param_stop_ERP(int axis) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_param_stop_ERP_124(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeAMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeAMotorJoint::get_param_stop_ERP(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeAMotorJoint*)local_this).get_param_stop_ERP((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_stop_ERP(OdeAMotorJoint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_param_stop_ERP_124_comment =
  "C++ Interface:\n"
  "get_param_stop_ERP(OdeAMotorJoint self, int axis)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_param_stop_ERP_124_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_param_stop_CFM(int axis) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_param_stop_CFM_125(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeAMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeAMotorJoint::get_param_stop_CFM(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeAMotorJoint*)local_this).get_param_stop_CFM((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_stop_CFM(OdeAMotorJoint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_param_stop_CFM_125_comment =
  "C++ Interface:\n"
  "get_param_stop_CFM(OdeAMotorJoint self, int axis)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_param_stop_CFM_125_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeAMotorJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeAMotorJoint_get_class_type_126(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeAMotorJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeAMotorJoint::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_class_type_126_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeAMotorJoint_get_class_type_126_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeAMotorJoint::OdeAMotorJoint(OdeAMotorJoint const &) = default
 * OdeAMotorJoint::OdeAMotorJoint(OdeWorld &world)
 * OdeAMotorJoint::OdeAMotorJoint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdeAMotorJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline OdeAMotorJoint::OdeAMotorJoint(OdeAMotorJoint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeAMotorJoint", (char **)keyword_list, &param0)) {
          OdeAMotorJoint const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_OdeAMotorJoint, (void **)&param0_this);
          if (param0_this != NULL) {
            OdeAMotorJoint *return_value = new OdeAMotorJoint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeAMotorJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdeAMotorJoint::OdeAMotorJoint(OdeWorld &world)
        PyObject *param0;
        static const char *keyword_list[] = {"world", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeAMotorJoint", (char **)keyword_list, &param0)) {
          OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeAMotorJoint.OdeAMotorJoint", false, false);
          if (param0_this != NULL) {
            OdeAMotorJoint *return_value = new OdeAMotorJoint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeAMotorJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline OdeAMotorJoint::OdeAMotorJoint(OdeAMotorJoint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeAMotorJoint", (char **)keyword_list, &param0)) {
          OdeAMotorJoint const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_OdeAMotorJoint(param0, param0_this, param0_manage)) {
            OdeAMotorJoint *return_value = new OdeAMotorJoint(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeAMotorJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: OdeAMotorJoint::OdeAMotorJoint(OdeWorld &world)
    }
    break;
  case 2:
    {
      // 1-OdeAMotorJoint::OdeAMotorJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeAMotorJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeAMotorJoint.OdeAMotorJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeAMotorJoint.OdeAMotorJoint", false, true);
        if (param0_this != NULL && param1_this != NULL) {
          OdeAMotorJoint *return_value = new OdeAMotorJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeAMotorJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeAMotorJoint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeAMotorJoint(const OdeAMotorJoint param0)\n"
      "OdeAMotorJoint(OdeWorld world)\n"
      "OdeAMotorJoint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeAMotorJoint(PyObject *args, OdeAMotorJoint const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeAMotorJoint, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeAMotorJoint::OdeAMotorJoint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeAMotorJoint.OdeAMotorJoint", false, false);
    if (arg_this != NULL) {
      OdeAMotorJoint *return_value = new OdeAMotorJoint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeAMotorJoint::OdeAMotorJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeAMotorJoint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeAMotorJoint.OdeAMotorJoint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeAMotorJoint.OdeAMotorJoint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeAMotorJoint *return_value = new OdeAMotorJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OdeAMotorJoint(PyObject *args, OdeAMotorJoint *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeAMotorJoint, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeAMotorJoint::OdeAMotorJoint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeAMotorJoint.OdeAMotorJoint", false, false);
    if (arg_this != NULL) {
      OdeAMotorJoint *return_value = new OdeAMotorJoint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeAMotorJoint::OdeAMotorJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeAMotorJoint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeAMotorJoint.OdeAMotorJoint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeAMotorJoint.OdeAMotorJoint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeAMotorJoint *return_value = new OdeAMotorJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_OdeAMotorJoint_get_axes(PyObject *self, PyObject *) {
  OdeAMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeAMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_axes();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_OdeAMotorJoint_get_axis_102(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_OdeAMotorJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeAMotorJoint) {
    printf("OdeAMotorJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeAMotorJoint *local_this = (OdeAMotorJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeAMotorJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeAMotorJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeAMotorJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeAMotorJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeAMotorJoint*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeBallJoint
 */
/**
 * Python function wrapper for:
 * inline void OdeBallJoint::set_anchor(LVecBase3f const &anchor)
 * inline void OdeBallJoint::set_anchor(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeBallJoint_set_anchor_129(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBallJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBallJoint, (void **)&local_this, "OdeBallJoint.set_anchor")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "anchor");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'anchor' (pos 1) not found");
      }
      // 1-inline void OdeBallJoint::set_anchor(LVecBase3f const &anchor)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBallJoint.set_anchor", "LVecBase3f");
      }
      (*local_this).set_anchor(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeBallJoint::set_anchor(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_anchor", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_anchor((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_anchor() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anchor(const OdeBallJoint self, const LVecBase3f anchor)\n"
      "set_anchor(const OdeBallJoint self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBallJoint_set_anchor_129_comment =
  "C++ Interface:\n"
  "set_anchor(const OdeBallJoint self, const LVecBase3f anchor)\n"
  "set_anchor(const OdeBallJoint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeBallJoint_set_anchor_129_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBallJoint::set_anchor2(LVecBase3f const &anchor)
 * inline void OdeBallJoint::set_anchor2(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeBallJoint_set_anchor2_130(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBallJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBallJoint, (void **)&local_this, "OdeBallJoint.set_anchor2")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "anchor");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'anchor' (pos 1) not found");
      }
      // 1-inline void OdeBallJoint::set_anchor2(LVecBase3f const &anchor)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBallJoint.set_anchor2", "LVecBase3f");
      }
      (*local_this).set_anchor2(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeBallJoint::set_anchor2(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_anchor2", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_anchor2((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_anchor2() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anchor2(const OdeBallJoint self, const LVecBase3f anchor)\n"
      "set_anchor2(const OdeBallJoint self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBallJoint_set_anchor2_130_comment =
  "C++ Interface:\n"
  "set_anchor2(const OdeBallJoint self, const LVecBase3f anchor)\n"
  "set_anchor2(const OdeBallJoint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeBallJoint_set_anchor2_130_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeBallJoint::get_anchor(void) const
 */
static PyObject *Dtool_OdeBallJoint_get_anchor_131(PyObject *self, PyObject *) {
  OdeBallJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBallJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeBallJoint::get_anchor(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeBallJoint*)local_this).get_anchor());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBallJoint_get_anchor_131_comment =
  "C++ Interface:\n"
  "get_anchor(OdeBallJoint self)\n";
#else
static const char *Dtool_OdeBallJoint_get_anchor_131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeBallJoint::get_anchor2(void) const
 */
static PyObject *Dtool_OdeBallJoint_get_anchor2_132(PyObject *self, PyObject *) {
  OdeBallJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBallJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeBallJoint::get_anchor2(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeBallJoint*)local_this).get_anchor2());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBallJoint_get_anchor2_132_comment =
  "C++ Interface:\n"
  "get_anchor2(OdeBallJoint self)\n";
#else
static const char *Dtool_OdeBallJoint_get_anchor2_132_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeBallJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeBallJoint_get_class_type_133(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeBallJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeBallJoint::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBallJoint_get_class_type_133_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeBallJoint_get_class_type_133_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeBallJoint::OdeBallJoint(OdeBallJoint const &) = default
 * OdeBallJoint::OdeBallJoint(OdeWorld &world)
 * OdeBallJoint::OdeBallJoint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdeBallJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline OdeBallJoint::OdeBallJoint(OdeBallJoint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeBallJoint", (char **)keyword_list, &param0)) {
          OdeBallJoint const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_OdeBallJoint, (void **)&param0_this);
          if (param0_this != NULL) {
            OdeBallJoint *return_value = new OdeBallJoint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeBallJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdeBallJoint::OdeBallJoint(OdeWorld &world)
        PyObject *param0;
        static const char *keyword_list[] = {"world", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeBallJoint", (char **)keyword_list, &param0)) {
          OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeBallJoint.OdeBallJoint", false, false);
          if (param0_this != NULL) {
            OdeBallJoint *return_value = new OdeBallJoint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeBallJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline OdeBallJoint::OdeBallJoint(OdeBallJoint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeBallJoint", (char **)keyword_list, &param0)) {
          OdeBallJoint const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_OdeBallJoint(param0, param0_this, param0_manage)) {
            OdeBallJoint *return_value = new OdeBallJoint(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeBallJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: OdeBallJoint::OdeBallJoint(OdeWorld &world)
    }
    break;
  case 2:
    {
      // 1-OdeBallJoint::OdeBallJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeBallJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeBallJoint.OdeBallJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeBallJoint.OdeBallJoint", false, true);
        if (param0_this != NULL && param1_this != NULL) {
          OdeBallJoint *return_value = new OdeBallJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeBallJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeBallJoint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeBallJoint(const OdeBallJoint param0)\n"
      "OdeBallJoint(OdeWorld world)\n"
      "OdeBallJoint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeBallJoint(PyObject *args, OdeBallJoint const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeBallJoint, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeBallJoint::OdeBallJoint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeBallJoint.OdeBallJoint", false, false);
    if (arg_this != NULL) {
      OdeBallJoint *return_value = new OdeBallJoint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeBallJoint::OdeBallJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeBallJoint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeBallJoint.OdeBallJoint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeBallJoint.OdeBallJoint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeBallJoint *return_value = new OdeBallJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OdeBallJoint(PyObject *args, OdeBallJoint *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeBallJoint, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeBallJoint::OdeBallJoint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeBallJoint.OdeBallJoint", false, false);
    if (arg_this != NULL) {
      OdeBallJoint *return_value = new OdeBallJoint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeBallJoint::OdeBallJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeBallJoint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeBallJoint.OdeBallJoint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeBallJoint.OdeBallJoint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeBallJoint *return_value = new OdeBallJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeBallJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeBallJoint) {
    printf("OdeBallJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeBallJoint *local_this = (OdeBallJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeBallJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeBallJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeBallJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeBallJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeBallJoint*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeMass
 */
/**
 * Python function wrapper for:
 * inline int OdeMass::check(void)
 */
static PyObject *Dtool_OdeMass_check_137(PyObject *self, PyObject *) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.check")) {
    return NULL;
  }
  // 1-inline int OdeMass::check(void)
  int return_value = (*local_this).check();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_check_137_comment =
  "C++ Interface:\n"
  "check(const OdeMass self)\n";
#else
static const char *Dtool_OdeMass_check_137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_zero(void)
 */
static PyObject *Dtool_OdeMass_set_zero_138(PyObject *self, PyObject *) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_zero")) {
    return NULL;
  }
  // 1-inline void OdeMass::set_zero(void)
  (*local_this).set_zero();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_zero_138_comment =
  "C++ Interface:\n"
  "set_zero(const OdeMass self)\n";
#else
static const char *Dtool_OdeMass_set_zero_138_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_parameters(dReal themass, LVecBase3f const &center, LMatrix3f const &r)
 * inline void OdeMass::set_parameters(dReal themass, dReal cgx, dReal cgy, dReal cgz, dReal I11, dReal I22, dReal I33, dReal I12, dReal I13, dReal I23)
 */
static PyObject *Dtool_OdeMass_set_parameters_139(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_parameters")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-inline void OdeMass::set_parameters(dReal themass, LVecBase3f const &center, LMatrix3f const &r)
      float param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"themass", "center", "r", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fOO:set_parameters", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeMass.set_parameters", "LVecBase3f");
        }
        LMatrix3f param3_local;
        LMatrix3f const *param3_this = Dtool_Coerce_LMatrix3f(param3, param3_local);
        if (!(param3_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "OdeMass.set_parameters", "LMatrix3f");
        }
        (*local_this).set_parameters((dReal)param1, *param2_this, *param3_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 10:
    {
      // 1-inline void OdeMass::set_parameters(dReal themass, dReal cgx, dReal cgy, dReal cgz, dReal I11, dReal I22, dReal I33, dReal I12, dReal I13, dReal I23)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      float param7;
      float param8;
      float param9;
      float param10;
      static const char *keyword_list[] = {"themass", "cgx", "cgy", "cgz", "I11", "I22", "I33", "I12", "I13", "I23", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffffffff:set_parameters", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10)) {
        (*local_this).set_parameters((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4, (dReal)param5, (dReal)param6, (dReal)param7, (dReal)param8, (dReal)param9, (dReal)param10);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_parameters() takes 4 or 11 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_parameters(const OdeMass self, float themass, const LVecBase3f center, const LMatrix3f r)\n"
      "set_parameters(const OdeMass self, float themass, float cgx, float cgy, float cgz, float I11, float I22, float I33, float I12, float I13, float I23)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_parameters_139_comment =
  "C++ Interface:\n"
  "set_parameters(const OdeMass self, float themass, const LVecBase3f center, const LMatrix3f r)\n"
  "set_parameters(const OdeMass self, float themass, float cgx, float cgy, float cgz, float I11, float I22, float I33, float I12, float I13, float I23)\n";
#else
static const char *Dtool_OdeMass_set_parameters_139_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_sphere(dReal density, dReal radius)
 */
static PyObject *Dtool_OdeMass_set_sphere_140(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_sphere")) {
    return NULL;
  }
  // 1-inline void OdeMass::set_sphere(dReal density, dReal radius)
  float param1;
  float param2;
  static const char *keyword_list[] = {"density", "radius", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_sphere", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_sphere((dReal)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sphere(const OdeMass self, float density, float radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_sphere_140_comment =
  "C++ Interface:\n"
  "set_sphere(const OdeMass self, float density, float radius)\n";
#else
static const char *Dtool_OdeMass_set_sphere_140_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_sphere_total(dReal total_mass, dReal radius)
 */
static PyObject *Dtool_OdeMass_set_sphere_total_141(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_sphere_total")) {
    return NULL;
  }
  // 1-inline void OdeMass::set_sphere_total(dReal total_mass, dReal radius)
  float param1;
  float param2;
  static const char *keyword_list[] = {"total_mass", "radius", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_sphere_total", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_sphere_total((dReal)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sphere_total(const OdeMass self, float total_mass, float radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_sphere_total_141_comment =
  "C++ Interface:\n"
  "set_sphere_total(const OdeMass self, float total_mass, float radius)\n";
#else
static const char *Dtool_OdeMass_set_sphere_total_141_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_capsule(dReal density, int direction, dReal radius, dReal length)
 */
static PyObject *Dtool_OdeMass_set_capsule_142(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_capsule")) {
    return NULL;
  }
  // 1-inline void OdeMass::set_capsule(dReal density, int direction, dReal radius, dReal length)
  float param1;
  int param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"density", "direction", "radius", "length", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fiff:set_capsule", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).set_capsule((dReal)param1, (int)param2, (dReal)param3, (dReal)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_capsule(const OdeMass self, float density, int direction, float radius, float length)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_capsule_142_comment =
  "C++ Interface:\n"
  "set_capsule(const OdeMass self, float density, int direction, float radius, float length)\n";
#else
static const char *Dtool_OdeMass_set_capsule_142_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_capsule_total(dReal total_mass, int direction, dReal radius, dReal length)
 */
static PyObject *Dtool_OdeMass_set_capsule_total_143(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_capsule_total")) {
    return NULL;
  }
  // 1-inline void OdeMass::set_capsule_total(dReal total_mass, int direction, dReal radius, dReal length)
  float param1;
  int param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"total_mass", "direction", "radius", "length", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fiff:set_capsule_total", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).set_capsule_total((dReal)param1, (int)param2, (dReal)param3, (dReal)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_capsule_total(const OdeMass self, float total_mass, int direction, float radius, float length)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_capsule_total_143_comment =
  "C++ Interface:\n"
  "set_capsule_total(const OdeMass self, float total_mass, int direction, float radius, float length)\n";
#else
static const char *Dtool_OdeMass_set_capsule_total_143_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_cylinder(dReal density, int direction, dReal radius, dReal length)
 */
static PyObject *Dtool_OdeMass_set_cylinder_144(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_cylinder")) {
    return NULL;
  }
  // 1-inline void OdeMass::set_cylinder(dReal density, int direction, dReal radius, dReal length)
  float param1;
  int param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"density", "direction", "radius", "length", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fiff:set_cylinder", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).set_cylinder((dReal)param1, (int)param2, (dReal)param3, (dReal)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cylinder(const OdeMass self, float density, int direction, float radius, float length)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_cylinder_144_comment =
  "C++ Interface:\n"
  "set_cylinder(const OdeMass self, float density, int direction, float radius, float length)\n";
#else
static const char *Dtool_OdeMass_set_cylinder_144_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_cylinder_total(dReal total_mass, int direction, dReal radius, dReal length)
 */
static PyObject *Dtool_OdeMass_set_cylinder_total_145(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_cylinder_total")) {
    return NULL;
  }
  // 1-inline void OdeMass::set_cylinder_total(dReal total_mass, int direction, dReal radius, dReal length)
  float param1;
  int param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"total_mass", "direction", "radius", "length", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fiff:set_cylinder_total", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).set_cylinder_total((dReal)param1, (int)param2, (dReal)param3, (dReal)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cylinder_total(const OdeMass self, float total_mass, int direction, float radius, float length)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_cylinder_total_145_comment =
  "C++ Interface:\n"
  "set_cylinder_total(const OdeMass self, float total_mass, int direction, float radius, float length)\n";
#else
static const char *Dtool_OdeMass_set_cylinder_total_145_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_box(dReal density, LVecBase3f const &size)
 * inline void OdeMass::set_box(dReal density, dReal lx, dReal ly, dReal lz)
 */
static PyObject *Dtool_OdeMass_set_box_146(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_box")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void OdeMass::set_box(dReal density, LVecBase3f const &size)
      float param1;
      PyObject *param2;
      static const char *keyword_list[] = {"density", "size", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:set_box", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeMass.set_box", "LVecBase3f");
        }
        (*local_this).set_box((dReal)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void OdeMass::set_box(dReal density, dReal lx, dReal ly, dReal lz)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"density", "lx", "ly", "lz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_box", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_box((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_box() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_box(const OdeMass self, float density, const LVecBase3f size)\n"
      "set_box(const OdeMass self, float density, float lx, float ly, float lz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_box_146_comment =
  "C++ Interface:\n"
  "set_box(const OdeMass self, float density, const LVecBase3f size)\n"
  "set_box(const OdeMass self, float density, float lx, float ly, float lz)\n";
#else
static const char *Dtool_OdeMass_set_box_146_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_box_total(dReal total_mass, LVecBase3f const &size)
 * inline void OdeMass::set_box_total(dReal total_mass, dReal lx, dReal ly, dReal lz)
 */
static PyObject *Dtool_OdeMass_set_box_total_147(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_box_total")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void OdeMass::set_box_total(dReal total_mass, LVecBase3f const &size)
      float param1;
      PyObject *param2;
      static const char *keyword_list[] = {"total_mass", "size", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:set_box_total", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeMass.set_box_total", "LVecBase3f");
        }
        (*local_this).set_box_total((dReal)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void OdeMass::set_box_total(dReal total_mass, dReal lx, dReal ly, dReal lz)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"total_mass", "lx", "ly", "lz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_box_total", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_box_total((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_box_total() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_box_total(const OdeMass self, float total_mass, const LVecBase3f size)\n"
      "set_box_total(const OdeMass self, float total_mass, float lx, float ly, float lz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_box_total_147_comment =
  "C++ Interface:\n"
  "set_box_total(const OdeMass self, float total_mass, const LVecBase3f size)\n"
  "set_box_total(const OdeMass self, float total_mass, float lx, float ly, float lz)\n";
#else
static const char *Dtool_OdeMass_set_box_total_147_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::adjust(dReal newmass)
 */
static PyObject *Dtool_OdeMass_adjust_148(PyObject *self, PyObject *arg) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.adjust")) {
    return NULL;
  }
  // 1-inline void OdeMass::adjust(dReal newmass)
  if (PyNumber_Check(arg)) {
    (*local_this).adjust((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "adjust(const OdeMass self, float newmass)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_adjust_148_comment =
  "C++ Interface:\n"
  "adjust(const OdeMass self, float newmass)\n";
#else
static const char *Dtool_OdeMass_adjust_148_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::translate(LVecBase3f const &pos)
 * inline void OdeMass::translate(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeMass_translate_149(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.translate")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pos");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'pos' (pos 1) not found");
      }
      // 1-inline void OdeMass::translate(LVecBase3f const &pos)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeMass.translate", "LVecBase3f");
      }
      (*local_this).translate(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeMass::translate(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:translate", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).translate((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "translate() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "translate(const OdeMass self, const LVecBase3f pos)\n"
      "translate(const OdeMass self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_translate_149_comment =
  "C++ Interface:\n"
  "translate(const OdeMass self, const LVecBase3f pos)\n"
  "translate(const OdeMass self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeMass_translate_149_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::rotate(LMatrix3f const &r)
 */
static PyObject *Dtool_OdeMass_rotate_150(PyObject *self, PyObject *arg) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.rotate")) {
    return NULL;
  }
  // 1-inline void OdeMass::rotate(LMatrix3f const &r)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeMass.rotate", "LMatrix3f");
  }
  (*local_this).rotate(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rotate(const OdeMass self, const LMatrix3f r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_rotate_150_comment =
  "C++ Interface:\n"
  "rotate(const OdeMass self, const LMatrix3f r)\n";
#else
static const char *Dtool_OdeMass_rotate_150_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::add(OdeMass &other)
 */
static PyObject *Dtool_OdeMass_add_151(PyObject *self, PyObject *arg) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.add")) {
    return NULL;
  }
  // 1-inline void OdeMass::add(OdeMass &other)
  OdeMass *arg_this = (OdeMass *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeMass, 1, "OdeMass.add", false, true);
  if (arg_this != NULL) {
    (*local_this).add(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add(const OdeMass self, OdeMass other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_add_151_comment =
  "C++ Interface:\n"
  "add(const OdeMass self, OdeMass other)\n";
#else
static const char *Dtool_OdeMass_add_151_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeMass::get_magnitude(void) const
 */
static PyObject *Dtool_OdeMass_get_magnitude_152(PyObject *self, PyObject *) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeMass, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeMass::get_magnitude(void) const
  dReal return_value = (*(const OdeMass*)local_this).get_magnitude();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_get_magnitude_152_comment =
  "C++ Interface:\n"
  "get_magnitude(OdeMass self)\n";
#else
static const char *Dtool_OdeMass_get_magnitude_152_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f OdeMass::get_center(void) const
 */
static PyObject *Dtool_OdeMass_get_center_153(PyObject *self, PyObject *) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeMass, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3f OdeMass::get_center(void) const
  LPoint3f *return_value = new LPoint3f((*(const OdeMass*)local_this).get_center());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_get_center_153_comment =
  "C++ Interface:\n"
  "get_center(OdeMass self)\n";
#else
static const char *Dtool_OdeMass_get_center_153_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3f OdeMass::get_inertial_tensor(void) const
 */
static PyObject *Dtool_OdeMass_get_inertial_tensor_154(PyObject *self, PyObject *) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeMass, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix3f OdeMass::get_inertial_tensor(void) const
  LMatrix3f *return_value = new LMatrix3f((*(const OdeMass*)local_this).get_inertial_tensor());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_get_inertial_tensor_154_comment =
  "C++ Interface:\n"
  "get_inertial_tensor(OdeMass self)\n";
#else
static const char *Dtool_OdeMass_get_inertial_tensor_154_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void OdeMass::write(ostream &out = ::cout, unsigned int indent = 0) const
 */
static PyObject *Dtool_OdeMass_write_155(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeMass, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-virtual void OdeMass::write(ostream &out, unsigned int indent) const
      (*(const OdeMass*)local_this).write();
      return Dtool_Return_None();
    }
    break;
  case 1:
  case 2:
    {
      // 1-virtual void OdeMass::write(ostream &out, unsigned int indent = 0) const
      PyObject *param1;
      unsigned long param2 = 0;
      static const char *keyword_list[] = {"out", "indent", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write", (char **)keyword_list, &param1, &param2)) {
        ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "OdeMass.write", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param2 > UINT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %lu out of range for unsigned integer",
                              param2);
        }
#endif
        if (param1_this != NULL) {
          (*(const OdeMass*)local_this).write(*param1_this, (unsigned int)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "write() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(OdeMass self)\n"
      "write(OdeMass self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_write_155_comment =
  "C++ Interface:\n"
  "write(OdeMass self)\n"
  "write(OdeMass self, ostream out, int indent)\n";
#else
static const char *Dtool_OdeMass_write_155_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeMass::get_class_type(void)
 */
static PyObject *Dtool_OdeMass_get_class_type_156(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeMass::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeMass::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_get_class_type_156_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeMass_get_class_type_156_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeMass::OdeMass(void)
 * OdeMass::OdeMass(OdeMass const &copy)
 */
static int Dtool_Init_OdeMass(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-OdeMass::OdeMass(void)
      OdeMass *return_value = new OdeMass();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeMass, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-OdeMass::OdeMass(OdeMass const &copy)
      OdeMass const *arg_this = (OdeMass *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeMass, 0, "OdeMass.OdeMass", true, true);
      if (arg_this != NULL) {
        OdeMass *return_value = new OdeMass(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeMass, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeMass() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeMass()\n"
      "OdeMass(const OdeMass copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeMass(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeMass) {
    printf("OdeMass ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeMass *local_this = (OdeMass *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeMass) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeMass(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeMass) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (OdeMass*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeMass*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (OdeMass*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeBody
 */
/**
 * Python function wrapper for:
 * void OdeBody::destroy(void)
 */
static PyObject *Dtool_OdeBody_destroy_159(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.destroy")) {
    return NULL;
  }
  // 1-void OdeBody::destroy(void)
  (*local_this).destroy();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_destroy_159_comment =
  "C++ Interface:\n"
  "destroy(const OdeBody self)\n";
#else
static const char *Dtool_OdeBody_destroy_159_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool OdeBody::is_empty(void) const
 */
static PyObject *Dtool_OdeBody_is_empty_160(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool OdeBody::is_empty(void) const
  bool return_value = (*(const OdeBody*)local_this).is_empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_is_empty_160_comment =
  "C++ Interface:\n"
  "is_empty(OdeBody self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ID is 0, meaning the OdeBody does not point to a valid\n"
  " * body.  It is an error to call a method on an empty body.  Note that an\n"
  " * empty OdeBody also evaluates to False.\n"
  " */";
#else
static const char *Dtool_OdeBody_is_empty_160_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_auto_disable_linear_threshold(dReal linear_threshold)
 */
static PyObject *Dtool_OdeBody_set_auto_disable_linear_threshold_162(PyObject *self, PyObject *arg) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_auto_disable_linear_threshold")) {
    return NULL;
  }
  // 1-inline void OdeBody::set_auto_disable_linear_threshold(dReal linear_threshold)
  if (PyNumber_Check(arg)) {
    (*local_this).set_auto_disable_linear_threshold((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_linear_threshold(const OdeBody self, float linear_threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_auto_disable_linear_threshold_162_comment =
  "C++ Interface:\n"
  "set_auto_disable_linear_threshold(const OdeBody self, float linear_threshold)\n";
#else
static const char *Dtool_OdeBody_set_auto_disable_linear_threshold_162_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_auto_disable_angular_threshold(dReal angular_threshold)
 */
static PyObject *Dtool_OdeBody_set_auto_disable_angular_threshold_163(PyObject *self, PyObject *arg) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_auto_disable_angular_threshold")) {
    return NULL;
  }
  // 1-inline void OdeBody::set_auto_disable_angular_threshold(dReal angular_threshold)
  if (PyNumber_Check(arg)) {
    (*local_this).set_auto_disable_angular_threshold((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_angular_threshold(const OdeBody self, float angular_threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_auto_disable_angular_threshold_163_comment =
  "C++ Interface:\n"
  "set_auto_disable_angular_threshold(const OdeBody self, float angular_threshold)\n";
#else
static const char *Dtool_OdeBody_set_auto_disable_angular_threshold_163_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_auto_disable_steps(int steps)
 */
static PyObject *Dtool_OdeBody_set_auto_disable_steps_164(PyObject *self, PyObject *arg) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_auto_disable_steps")) {
    return NULL;
  }
  // 1-inline void OdeBody::set_auto_disable_steps(int steps)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_auto_disable_steps((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_steps(const OdeBody self, int steps)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_auto_disable_steps_164_comment =
  "C++ Interface:\n"
  "set_auto_disable_steps(const OdeBody self, int steps)\n";
#else
static const char *Dtool_OdeBody_set_auto_disable_steps_164_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_auto_disable_time(dReal time)
 */
static PyObject *Dtool_OdeBody_set_auto_disable_time_165(PyObject *self, PyObject *arg) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_auto_disable_time")) {
    return NULL;
  }
  // 1-inline void OdeBody::set_auto_disable_time(dReal time)
  if (PyNumber_Check(arg)) {
    (*local_this).set_auto_disable_time((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_time(const OdeBody self, float time)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_auto_disable_time_165_comment =
  "C++ Interface:\n"
  "set_auto_disable_time(const OdeBody self, float time)\n";
#else
static const char *Dtool_OdeBody_set_auto_disable_time_165_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_auto_disable_flag(int do_auto_disable)
 */
static PyObject *Dtool_OdeBody_set_auto_disable_flag_166(PyObject *self, PyObject *arg) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_auto_disable_flag")) {
    return NULL;
  }
  // 1-inline void OdeBody::set_auto_disable_flag(int do_auto_disable)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_auto_disable_flag((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_flag(const OdeBody self, int do_auto_disable)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_auto_disable_flag_166_comment =
  "C++ Interface:\n"
  "set_auto_disable_flag(const OdeBody self, int do_auto_disable)\n";
#else
static const char *Dtool_OdeBody_set_auto_disable_flag_166_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_auto_disable_defaults(void)
 */
static PyObject *Dtool_OdeBody_set_auto_disable_defaults_167(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_auto_disable_defaults")) {
    return NULL;
  }
  // 1-inline void OdeBody::set_auto_disable_defaults(void)
  (*local_this).set_auto_disable_defaults();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_auto_disable_defaults_167_comment =
  "C++ Interface:\n"
  "set_auto_disable_defaults(const OdeBody self)\n";
#else
static const char *Dtool_OdeBody_set_auto_disable_defaults_167_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeBody::set_data(PyObject *data)
 */
static PyObject *Dtool_OdeBody_set_data_168(PyObject *self, PyObject *arg) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_data")) {
    return NULL;
  }
  // 1-void OdeBody::set_data(PyObject *data)
  (*local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const OdeBody self, object data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_data_168_comment =
  "C++ Interface:\n"
  "set_data(const OdeBody self, object data)\n";
#else
static const char *Dtool_OdeBody_set_data_168_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_position(LVecBase3f const &pos)
 * inline void OdeBody::set_position(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeBody_set_position_169(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_position")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pos");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'pos' (pos 1) not found");
      }
      // 1-inline void OdeBody::set_position(LVecBase3f const &pos)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.set_position", "LVecBase3f");
      }
      (*local_this).set_position(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::set_position(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_position", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_position((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_position() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_position(const OdeBody self, const LVecBase3f pos)\n"
      "set_position(const OdeBody self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_position_169_comment =
  "C++ Interface:\n"
  "set_position(const OdeBody self, const LVecBase3f pos)\n"
  "set_position(const OdeBody self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeBody_set_position_169_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_rotation(LMatrix3f const &r)
 */
static PyObject *Dtool_OdeBody_set_rotation_170(PyObject *self, PyObject *arg) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_rotation")) {
    return NULL;
  }
  // 1-inline void OdeBody::set_rotation(LMatrix3f const &r)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.set_rotation", "LMatrix3f");
  }
  (*local_this).set_rotation(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rotation(const OdeBody self, const LMatrix3f r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_rotation_170_comment =
  "C++ Interface:\n"
  "set_rotation(const OdeBody self, const LMatrix3f r)\n";
#else
static const char *Dtool_OdeBody_set_rotation_170_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_quaternion(LQuaternionf const &q)
 */
static PyObject *Dtool_OdeBody_set_quaternion_171(PyObject *self, PyObject *arg) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_quaternion")) {
    return NULL;
  }
  // 1-inline void OdeBody::set_quaternion(LQuaternionf const &q)
  LQuaternionf arg_local;
  LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.set_quaternion", "LQuaternionf");
  }
  (*local_this).set_quaternion(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_quaternion(const OdeBody self, const LQuaternionf q)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_quaternion_171_comment =
  "C++ Interface:\n"
  "set_quaternion(const OdeBody self, const LQuaternionf q)\n";
#else
static const char *Dtool_OdeBody_set_quaternion_171_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_linear_vel(LVecBase3f const &vel)
 * inline void OdeBody::set_linear_vel(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeBody_set_linear_vel_172(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_linear_vel")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "vel");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'vel' (pos 1) not found");
      }
      // 1-inline void OdeBody::set_linear_vel(LVecBase3f const &vel)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.set_linear_vel", "LVecBase3f");
      }
      (*local_this).set_linear_vel(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::set_linear_vel(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_linear_vel", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_linear_vel((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_linear_vel() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_linear_vel(const OdeBody self, const LVecBase3f vel)\n"
      "set_linear_vel(const OdeBody self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_linear_vel_172_comment =
  "C++ Interface:\n"
  "set_linear_vel(const OdeBody self, const LVecBase3f vel)\n"
  "set_linear_vel(const OdeBody self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeBody_set_linear_vel_172_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_angular_vel(LVecBase3f const &vel)
 * inline void OdeBody::set_angular_vel(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeBody_set_angular_vel_173(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_angular_vel")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "vel");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'vel' (pos 1) not found");
      }
      // 1-inline void OdeBody::set_angular_vel(LVecBase3f const &vel)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.set_angular_vel", "LVecBase3f");
      }
      (*local_this).set_angular_vel(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::set_angular_vel(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_angular_vel", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_angular_vel((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_angular_vel() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_angular_vel(const OdeBody self, const LVecBase3f vel)\n"
      "set_angular_vel(const OdeBody self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_angular_vel_173_comment =
  "C++ Interface:\n"
  "set_angular_vel(const OdeBody self, const LVecBase3f vel)\n"
  "set_angular_vel(const OdeBody self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeBody_set_angular_vel_173_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_mass(OdeMass &mass)
 */
static PyObject *Dtool_OdeBody_set_mass_174(PyObject *self, PyObject *arg) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_mass")) {
    return NULL;
  }
  // 1-inline void OdeBody::set_mass(OdeMass &mass)
  OdeMass *arg_this = (OdeMass *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeMass, 1, "OdeBody.set_mass", false, true);
  if (arg_this != NULL) {
    (*local_this).set_mass(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mass(const OdeBody self, OdeMass mass)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_mass_174_comment =
  "C++ Interface:\n"
  "set_mass(const OdeBody self, OdeMass mass)\n";
#else
static const char *Dtool_OdeBody_set_mass_174_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeBody::get_auto_disable_linear_threshold(void) const
 */
static PyObject *Dtool_OdeBody_get_auto_disable_linear_threshold_175(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeBody::get_auto_disable_linear_threshold(void) const
  dReal return_value = (*(const OdeBody*)local_this).get_auto_disable_linear_threshold();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_auto_disable_linear_threshold_175_comment =
  "C++ Interface:\n"
  "get_auto_disable_linear_threshold(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_auto_disable_linear_threshold_175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeBody::get_auto_disable_angular_threshold(void) const
 */
static PyObject *Dtool_OdeBody_get_auto_disable_angular_threshold_176(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeBody::get_auto_disable_angular_threshold(void) const
  dReal return_value = (*(const OdeBody*)local_this).get_auto_disable_angular_threshold();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_auto_disable_angular_threshold_176_comment =
  "C++ Interface:\n"
  "get_auto_disable_angular_threshold(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_auto_disable_angular_threshold_176_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeBody::get_auto_disable_steps(void) const
 */
static PyObject *Dtool_OdeBody_get_auto_disable_steps_177(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeBody::get_auto_disable_steps(void) const
  int return_value = (*(const OdeBody*)local_this).get_auto_disable_steps();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_auto_disable_steps_177_comment =
  "C++ Interface:\n"
  "get_auto_disable_steps(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_auto_disable_steps_177_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeBody::get_auto_disable_time(void) const
 */
static PyObject *Dtool_OdeBody_get_auto_disable_time_178(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeBody::get_auto_disable_time(void) const
  dReal return_value = (*(const OdeBody*)local_this).get_auto_disable_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_auto_disable_time_178_comment =
  "C++ Interface:\n"
  "get_auto_disable_time(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_auto_disable_time_178_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeBody::get_auto_disable_flag(void) const
 */
static PyObject *Dtool_OdeBody_get_auto_disable_flag_179(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeBody::get_auto_disable_flag(void) const
  int return_value = (*(const OdeBody*)local_this).get_auto_disable_flag();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_auto_disable_flag_179_comment =
  "C++ Interface:\n"
  "get_auto_disable_flag(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_auto_disable_flag_179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *OdeBody::get_data(void) const
 */
static PyObject *Dtool_OdeBody_get_data_180(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-PyObject *OdeBody::get_data(void) const
  PyObject *return_value = (*(const OdeBody*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_data_180_comment =
  "C++ Interface:\n"
  "get_data(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_data_180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeBody::get_position(void) const
 */
static PyObject *Dtool_OdeBody_get_position_181(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeBody::get_position(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeBody*)local_this).get_position());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_position_181_comment =
  "C++ Interface:\n"
  "get_position(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_position_181_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3f OdeBody::get_rotation(void) const
 */
static PyObject *Dtool_OdeBody_get_rotation_182(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix3f OdeBody::get_rotation(void) const
  LMatrix3f *return_value = new LMatrix3f((*(const OdeBody*)local_this).get_rotation());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_rotation_182_comment =
  "C++ Interface:\n"
  "get_rotation(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_rotation_182_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4f OdeBody::get_quaternion(void) const
 */
static PyObject *Dtool_OdeBody_get_quaternion_183(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4f OdeBody::get_quaternion(void) const
  LVecBase4f *return_value = new LVecBase4f((*(const OdeBody*)local_this).get_quaternion());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_quaternion_183_comment =
  "C++ Interface:\n"
  "get_quaternion(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_quaternion_183_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeBody::get_linear_vel(void) const
 */
static PyObject *Dtool_OdeBody_get_linear_vel_184(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeBody::get_linear_vel(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeBody*)local_this).get_linear_vel());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_linear_vel_184_comment =
  "C++ Interface:\n"
  "get_linear_vel(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_linear_vel_184_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeBody::get_angular_vel(void) const
 */
static PyObject *Dtool_OdeBody_get_angular_vel_185(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeBody::get_angular_vel(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeBody*)local_this).get_angular_vel());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_angular_vel_185_comment =
  "C++ Interface:\n"
  "get_angular_vel(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_angular_vel_185_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeMass OdeBody::get_mass(void) const
 */
static PyObject *Dtool_OdeBody_get_mass_186(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline OdeMass OdeBody::get_mass(void) const
  OdeMass *return_value = new OdeMass((*(const OdeBody*)local_this).get_mass());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (return_value != (OdeMass *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (OdeMass *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeMass, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_mass_186_comment =
  "C++ Interface:\n"
  "get_mass(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_mass_186_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::add_force(LVecBase3f const &f)
 * inline void OdeBody::add_force(dReal fx, dReal fy, dReal fz)
 */
static PyObject *Dtool_OdeBody_add_force_187(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.add_force")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "f");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'f' (pos 1) not found");
      }
      // 1-inline void OdeBody::add_force(LVecBase3f const &f)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.add_force", "LVecBase3f");
      }
      (*local_this).add_force(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::add_force(dReal fx, dReal fy, dReal fz)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"fx", "fy", "fz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:add_force", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).add_force((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_force() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_force(const OdeBody self, const LVecBase3f f)\n"
      "add_force(const OdeBody self, float fx, float fy, float fz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_add_force_187_comment =
  "C++ Interface:\n"
  "add_force(const OdeBody self, const LVecBase3f f)\n"
  "add_force(const OdeBody self, float fx, float fy, float fz)\n";
#else
static const char *Dtool_OdeBody_add_force_187_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::add_torque(LVecBase3f const &f)
 * inline void OdeBody::add_torque(dReal fx, dReal fy, dReal fz)
 */
static PyObject *Dtool_OdeBody_add_torque_188(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.add_torque")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "f");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'f' (pos 1) not found");
      }
      // 1-inline void OdeBody::add_torque(LVecBase3f const &f)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.add_torque", "LVecBase3f");
      }
      (*local_this).add_torque(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::add_torque(dReal fx, dReal fy, dReal fz)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"fx", "fy", "fz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:add_torque", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).add_torque((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_torque() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_torque(const OdeBody self, const LVecBase3f f)\n"
      "add_torque(const OdeBody self, float fx, float fy, float fz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_add_torque_188_comment =
  "C++ Interface:\n"
  "add_torque(const OdeBody self, const LVecBase3f f)\n"
  "add_torque(const OdeBody self, float fx, float fy, float fz)\n";
#else
static const char *Dtool_OdeBody_add_torque_188_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::add_rel_force(LVecBase3f const &f)
 * inline void OdeBody::add_rel_force(dReal fx, dReal fy, dReal fz)
 */
static PyObject *Dtool_OdeBody_add_rel_force_189(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.add_rel_force")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "f");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'f' (pos 1) not found");
      }
      // 1-inline void OdeBody::add_rel_force(LVecBase3f const &f)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.add_rel_force", "LVecBase3f");
      }
      (*local_this).add_rel_force(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::add_rel_force(dReal fx, dReal fy, dReal fz)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"fx", "fy", "fz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:add_rel_force", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).add_rel_force((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_rel_force() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_rel_force(const OdeBody self, const LVecBase3f f)\n"
      "add_rel_force(const OdeBody self, float fx, float fy, float fz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_add_rel_force_189_comment =
  "C++ Interface:\n"
  "add_rel_force(const OdeBody self, const LVecBase3f f)\n"
  "add_rel_force(const OdeBody self, float fx, float fy, float fz)\n";
#else
static const char *Dtool_OdeBody_add_rel_force_189_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::add_rel_torque(LVecBase3f const &f)
 * inline void OdeBody::add_rel_torque(dReal fx, dReal fy, dReal fz)
 */
static PyObject *Dtool_OdeBody_add_rel_torque_190(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.add_rel_torque")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "f");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'f' (pos 1) not found");
      }
      // 1-inline void OdeBody::add_rel_torque(LVecBase3f const &f)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.add_rel_torque", "LVecBase3f");
      }
      (*local_this).add_rel_torque(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::add_rel_torque(dReal fx, dReal fy, dReal fz)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"fx", "fy", "fz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:add_rel_torque", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).add_rel_torque((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_rel_torque() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_rel_torque(const OdeBody self, const LVecBase3f f)\n"
      "add_rel_torque(const OdeBody self, float fx, float fy, float fz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_add_rel_torque_190_comment =
  "C++ Interface:\n"
  "add_rel_torque(const OdeBody self, const LVecBase3f f)\n"
  "add_rel_torque(const OdeBody self, float fx, float fy, float fz)\n";
#else
static const char *Dtool_OdeBody_add_rel_torque_190_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::add_force_at_pos(LVecBase3f const &f, LVecBase3f const &pos)
 * inline void OdeBody::add_force_at_pos(dReal fx, dReal fy, dReal fz, dReal px, dReal py, dReal pz)
 */
static PyObject *Dtool_OdeBody_add_force_at_pos_191(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.add_force_at_pos")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void OdeBody::add_force_at_pos(LVecBase3f const &f, LVecBase3f const &pos)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"f", "pos", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_force_at_pos", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "OdeBody.add_force_at_pos", "LVecBase3f");
        }
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeBody.add_force_at_pos", "LVecBase3f");
        }
        (*local_this).add_force_at_pos(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void OdeBody::add_force_at_pos(dReal fx, dReal fy, dReal fz, dReal px, dReal py, dReal pz)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"fx", "fy", "fz", "px", "py", "pz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:add_force_at_pos", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        (*local_this).add_force_at_pos((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4, (dReal)param5, (dReal)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_force_at_pos() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_force_at_pos(const OdeBody self, const LVecBase3f f, const LVecBase3f pos)\n"
      "add_force_at_pos(const OdeBody self, float fx, float fy, float fz, float px, float py, float pz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_add_force_at_pos_191_comment =
  "C++ Interface:\n"
  "add_force_at_pos(const OdeBody self, const LVecBase3f f, const LVecBase3f pos)\n"
  "add_force_at_pos(const OdeBody self, float fx, float fy, float fz, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_add_force_at_pos_191_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::add_force_at_rel_pos(LVecBase3f const &f, LVecBase3f const &pos)
 * inline void OdeBody::add_force_at_rel_pos(dReal fx, dReal fy, dReal fz, dReal px, dReal py, dReal pz)
 */
static PyObject *Dtool_OdeBody_add_force_at_rel_pos_192(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.add_force_at_rel_pos")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void OdeBody::add_force_at_rel_pos(LVecBase3f const &f, LVecBase3f const &pos)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"f", "pos", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_force_at_rel_pos", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "OdeBody.add_force_at_rel_pos", "LVecBase3f");
        }
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeBody.add_force_at_rel_pos", "LVecBase3f");
        }
        (*local_this).add_force_at_rel_pos(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void OdeBody::add_force_at_rel_pos(dReal fx, dReal fy, dReal fz, dReal px, dReal py, dReal pz)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"fx", "fy", "fz", "px", "py", "pz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:add_force_at_rel_pos", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        (*local_this).add_force_at_rel_pos((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4, (dReal)param5, (dReal)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_force_at_rel_pos() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_force_at_rel_pos(const OdeBody self, const LVecBase3f f, const LVecBase3f pos)\n"
      "add_force_at_rel_pos(const OdeBody self, float fx, float fy, float fz, float px, float py, float pz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_add_force_at_rel_pos_192_comment =
  "C++ Interface:\n"
  "add_force_at_rel_pos(const OdeBody self, const LVecBase3f f, const LVecBase3f pos)\n"
  "add_force_at_rel_pos(const OdeBody self, float fx, float fy, float fz, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_add_force_at_rel_pos_192_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::add_rel_force_at_pos(LVecBase3f const &f, LVecBase3f const &pos)
 * inline void OdeBody::add_rel_force_at_pos(dReal fx, dReal fy, dReal fz, dReal px, dReal py, dReal pz)
 */
static PyObject *Dtool_OdeBody_add_rel_force_at_pos_193(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.add_rel_force_at_pos")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void OdeBody::add_rel_force_at_pos(LVecBase3f const &f, LVecBase3f const &pos)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"f", "pos", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_rel_force_at_pos", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "OdeBody.add_rel_force_at_pos", "LVecBase3f");
        }
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeBody.add_rel_force_at_pos", "LVecBase3f");
        }
        (*local_this).add_rel_force_at_pos(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void OdeBody::add_rel_force_at_pos(dReal fx, dReal fy, dReal fz, dReal px, dReal py, dReal pz)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"fx", "fy", "fz", "px", "py", "pz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:add_rel_force_at_pos", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        (*local_this).add_rel_force_at_pos((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4, (dReal)param5, (dReal)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_rel_force_at_pos() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_rel_force_at_pos(const OdeBody self, const LVecBase3f f, const LVecBase3f pos)\n"
      "add_rel_force_at_pos(const OdeBody self, float fx, float fy, float fz, float px, float py, float pz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_add_rel_force_at_pos_193_comment =
  "C++ Interface:\n"
  "add_rel_force_at_pos(const OdeBody self, const LVecBase3f f, const LVecBase3f pos)\n"
  "add_rel_force_at_pos(const OdeBody self, float fx, float fy, float fz, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_add_rel_force_at_pos_193_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::add_rel_force_at_rel_pos(LVecBase3f const &f, LVecBase3f const &pos)
 * inline void OdeBody::add_rel_force_at_rel_pos(dReal fx, dReal fy, dReal fz, dReal px, dReal py, dReal pz)
 */
static PyObject *Dtool_OdeBody_add_rel_force_at_rel_pos_194(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.add_rel_force_at_rel_pos")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void OdeBody::add_rel_force_at_rel_pos(LVecBase3f const &f, LVecBase3f const &pos)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"f", "pos", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_rel_force_at_rel_pos", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "OdeBody.add_rel_force_at_rel_pos", "LVecBase3f");
        }
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeBody.add_rel_force_at_rel_pos", "LVecBase3f");
        }
        (*local_this).add_rel_force_at_rel_pos(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void OdeBody::add_rel_force_at_rel_pos(dReal fx, dReal fy, dReal fz, dReal px, dReal py, dReal pz)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"fx", "fy", "fz", "px", "py", "pz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:add_rel_force_at_rel_pos", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        (*local_this).add_rel_force_at_rel_pos((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4, (dReal)param5, (dReal)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_rel_force_at_rel_pos() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_rel_force_at_rel_pos(const OdeBody self, const LVecBase3f f, const LVecBase3f pos)\n"
      "add_rel_force_at_rel_pos(const OdeBody self, float fx, float fy, float fz, float px, float py, float pz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_add_rel_force_at_rel_pos_194_comment =
  "C++ Interface:\n"
  "add_rel_force_at_rel_pos(const OdeBody self, const LVecBase3f f, const LVecBase3f pos)\n"
  "add_rel_force_at_rel_pos(const OdeBody self, float fx, float fy, float fz, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_add_rel_force_at_rel_pos_194_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_force(LVecBase3f const &f)
 * inline void OdeBody::set_force(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeBody_set_force_195(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_force")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "f");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'f' (pos 1) not found");
      }
      // 1-inline void OdeBody::set_force(LVecBase3f const &f)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.set_force", "LVecBase3f");
      }
      (*local_this).set_force(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::set_force(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_force", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_force((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_force() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_force(const OdeBody self, const LVecBase3f f)\n"
      "set_force(const OdeBody self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_force_195_comment =
  "C++ Interface:\n"
  "set_force(const OdeBody self, const LVecBase3f f)\n"
  "set_force(const OdeBody self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeBody_set_force_195_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_torque(LVecBase3f const &f)
 * inline void OdeBody::set_torque(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeBody_set_torque_196(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_torque")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "f");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'f' (pos 1) not found");
      }
      // 1-inline void OdeBody::set_torque(LVecBase3f const &f)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.set_torque", "LVecBase3f");
      }
      (*local_this).set_torque(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::set_torque(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_torque", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_torque((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_torque() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_torque(const OdeBody self, const LVecBase3f f)\n"
      "set_torque(const OdeBody self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_torque_196_comment =
  "C++ Interface:\n"
  "set_torque(const OdeBody self, const LVecBase3f f)\n"
  "set_torque(const OdeBody self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeBody_set_torque_196_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f OdeBody::get_rel_point_pos(LVecBase3f const &pos) const
 * inline LPoint3f OdeBody::get_rel_point_pos(dReal px, dReal py, dReal pz) const
 */
static PyObject *Dtool_OdeBody_get_rel_point_pos_197(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pos");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'pos' (pos 1) not found");
      }
      // 1-inline LPoint3f OdeBody::get_rel_point_pos(LVecBase3f const &pos) const
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.get_rel_point_pos", "LVecBase3f");
      }
      LPoint3f *return_value = new LPoint3f((*(const OdeBody*)local_this).get_rel_point_pos(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
    }
    break;
  case 3:
    {
      // 1-inline LPoint3f OdeBody::get_rel_point_pos(dReal px, dReal py, dReal pz) const
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"px", "py", "pz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:get_rel_point_pos", (char **)keyword_list, &param1, &param2, &param3)) {
        LPoint3f *return_value = new LPoint3f((*(const OdeBody*)local_this).get_rel_point_pos((dReal)param1, (dReal)param2, (dReal)param3));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_rel_point_pos() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_rel_point_pos(OdeBody self, const LVecBase3f pos)\n"
      "get_rel_point_pos(OdeBody self, float px, float py, float pz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_rel_point_pos_197_comment =
  "C++ Interface:\n"
  "get_rel_point_pos(OdeBody self, const LVecBase3f pos)\n"
  "get_rel_point_pos(OdeBody self, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_get_rel_point_pos_197_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f OdeBody::get_rel_point_vel(LVecBase3f const &pos) const
 * inline LPoint3f OdeBody::get_rel_point_vel(dReal px, dReal py, dReal pz) const
 */
static PyObject *Dtool_OdeBody_get_rel_point_vel_198(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pos");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'pos' (pos 1) not found");
      }
      // 1-inline LPoint3f OdeBody::get_rel_point_vel(LVecBase3f const &pos) const
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.get_rel_point_vel", "LVecBase3f");
      }
      LPoint3f *return_value = new LPoint3f((*(const OdeBody*)local_this).get_rel_point_vel(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
    }
    break;
  case 3:
    {
      // 1-inline LPoint3f OdeBody::get_rel_point_vel(dReal px, dReal py, dReal pz) const
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"px", "py", "pz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:get_rel_point_vel", (char **)keyword_list, &param1, &param2, &param3)) {
        LPoint3f *return_value = new LPoint3f((*(const OdeBody*)local_this).get_rel_point_vel((dReal)param1, (dReal)param2, (dReal)param3));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_rel_point_vel() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_rel_point_vel(OdeBody self, const LVecBase3f pos)\n"
      "get_rel_point_vel(OdeBody self, float px, float py, float pz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_rel_point_vel_198_comment =
  "C++ Interface:\n"
  "get_rel_point_vel(OdeBody self, const LVecBase3f pos)\n"
  "get_rel_point_vel(OdeBody self, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_get_rel_point_vel_198_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f OdeBody::get_point_vel(LVecBase3f const &pos) const
 * inline LPoint3f OdeBody::get_point_vel(dReal px, dReal py, dReal pz) const
 */
static PyObject *Dtool_OdeBody_get_point_vel_199(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pos");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'pos' (pos 1) not found");
      }
      // 1-inline LPoint3f OdeBody::get_point_vel(LVecBase3f const &pos) const
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.get_point_vel", "LVecBase3f");
      }
      LPoint3f *return_value = new LPoint3f((*(const OdeBody*)local_this).get_point_vel(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
    }
    break;
  case 3:
    {
      // 1-inline LPoint3f OdeBody::get_point_vel(dReal px, dReal py, dReal pz) const
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"px", "py", "pz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:get_point_vel", (char **)keyword_list, &param1, &param2, &param3)) {
        LPoint3f *return_value = new LPoint3f((*(const OdeBody*)local_this).get_point_vel((dReal)param1, (dReal)param2, (dReal)param3));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_point_vel() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point_vel(OdeBody self, const LVecBase3f pos)\n"
      "get_point_vel(OdeBody self, float px, float py, float pz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_point_vel_199_comment =
  "C++ Interface:\n"
  "get_point_vel(OdeBody self, const LVecBase3f pos)\n"
  "get_point_vel(OdeBody self, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_get_point_vel_199_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f OdeBody::get_pos_rel_point(LVecBase3f const &pos) const
 * inline LPoint3f OdeBody::get_pos_rel_point(dReal px, dReal py, dReal pz) const
 */
static PyObject *Dtool_OdeBody_get_pos_rel_point_200(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pos");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'pos' (pos 1) not found");
      }
      // 1-inline LPoint3f OdeBody::get_pos_rel_point(LVecBase3f const &pos) const
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.get_pos_rel_point", "LVecBase3f");
      }
      LPoint3f *return_value = new LPoint3f((*(const OdeBody*)local_this).get_pos_rel_point(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
    }
    break;
  case 3:
    {
      // 1-inline LPoint3f OdeBody::get_pos_rel_point(dReal px, dReal py, dReal pz) const
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"px", "py", "pz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:get_pos_rel_point", (char **)keyword_list, &param1, &param2, &param3)) {
        LPoint3f *return_value = new LPoint3f((*(const OdeBody*)local_this).get_pos_rel_point((dReal)param1, (dReal)param2, (dReal)param3));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_pos_rel_point() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pos_rel_point(OdeBody self, const LVecBase3f pos)\n"
      "get_pos_rel_point(OdeBody self, float px, float py, float pz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_pos_rel_point_200_comment =
  "C++ Interface:\n"
  "get_pos_rel_point(OdeBody self, const LVecBase3f pos)\n"
  "get_pos_rel_point(OdeBody self, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_get_pos_rel_point_200_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeBody::vector_to_world(LVecBase3f const &pos) const
 * inline LVecBase3f OdeBody::vector_to_world(dReal px, dReal py, dReal pz) const
 */
static PyObject *Dtool_OdeBody_vector_to_world_201(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pos");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'pos' (pos 1) not found");
      }
      // 1-inline LVecBase3f OdeBody::vector_to_world(LVecBase3f const &pos) const
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.vector_to_world", "LVecBase3f");
      }
      LVecBase3f *return_value = new LVecBase3f((*(const OdeBody*)local_this).vector_to_world(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
    break;
  case 3:
    {
      // 1-inline LVecBase3f OdeBody::vector_to_world(dReal px, dReal py, dReal pz) const
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"px", "py", "pz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:vector_to_world", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase3f *return_value = new LVecBase3f((*(const OdeBody*)local_this).vector_to_world((dReal)param1, (dReal)param2, (dReal)param3));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "vector_to_world() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "vector_to_world(OdeBody self, const LVecBase3f pos)\n"
      "vector_to_world(OdeBody self, float px, float py, float pz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_vector_to_world_201_comment =
  "C++ Interface:\n"
  "vector_to_world(OdeBody self, const LVecBase3f pos)\n"
  "vector_to_world(OdeBody self, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_vector_to_world_201_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeBody::vector_from_world(LVecBase3f const &pos) const
 * inline LVecBase3f OdeBody::vector_from_world(dReal px, dReal py, dReal pz) const
 */
static PyObject *Dtool_OdeBody_vector_from_world_202(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pos");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'pos' (pos 1) not found");
      }
      // 1-inline LVecBase3f OdeBody::vector_from_world(LVecBase3f const &pos) const
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.vector_from_world", "LVecBase3f");
      }
      LVecBase3f *return_value = new LVecBase3f((*(const OdeBody*)local_this).vector_from_world(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
    break;
  case 3:
    {
      // 1-inline LVecBase3f OdeBody::vector_from_world(dReal px, dReal py, dReal pz) const
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"px", "py", "pz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:vector_from_world", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase3f *return_value = new LVecBase3f((*(const OdeBody*)local_this).vector_from_world((dReal)param1, (dReal)param2, (dReal)param3));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "vector_from_world() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "vector_from_world(OdeBody self, const LVecBase3f pos)\n"
      "vector_from_world(OdeBody self, float px, float py, float pz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_vector_from_world_202_comment =
  "C++ Interface:\n"
  "vector_from_world(OdeBody self, const LVecBase3f pos)\n"
  "vector_from_world(OdeBody self, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_vector_from_world_202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_finite_rotation_mode(int mode)
 */
static PyObject *Dtool_OdeBody_set_finite_rotation_mode_203(PyObject *self, PyObject *arg) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_finite_rotation_mode")) {
    return NULL;
  }
  // 1-inline void OdeBody::set_finite_rotation_mode(int mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_finite_rotation_mode((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_finite_rotation_mode(const OdeBody self, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_finite_rotation_mode_203_comment =
  "C++ Interface:\n"
  "set_finite_rotation_mode(const OdeBody self, int mode)\n";
#else
static const char *Dtool_OdeBody_set_finite_rotation_mode_203_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_finite_rotation_axis(LVecBase3f const &axis)
 * inline void OdeBody::set_finite_rotation_axis(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeBody_set_finite_rotation_axis_204(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_finite_rotation_axis")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "axis");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'axis' (pos 1) not found");
      }
      // 1-inline void OdeBody::set_finite_rotation_axis(LVecBase3f const &axis)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.set_finite_rotation_axis", "LVecBase3f");
      }
      (*local_this).set_finite_rotation_axis(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::set_finite_rotation_axis(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_finite_rotation_axis", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_finite_rotation_axis((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_finite_rotation_axis() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_finite_rotation_axis(const OdeBody self, const LVecBase3f axis)\n"
      "set_finite_rotation_axis(const OdeBody self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_finite_rotation_axis_204_comment =
  "C++ Interface:\n"
  "set_finite_rotation_axis(const OdeBody self, const LVecBase3f axis)\n"
  "set_finite_rotation_axis(const OdeBody self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeBody_set_finite_rotation_axis_204_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeBody::get_finite_rotation_mode(void) const
 */
static PyObject *Dtool_OdeBody_get_finite_rotation_mode_205(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeBody::get_finite_rotation_mode(void) const
  int return_value = (*(const OdeBody*)local_this).get_finite_rotation_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_finite_rotation_mode_205_comment =
  "C++ Interface:\n"
  "get_finite_rotation_mode(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_finite_rotation_mode_205_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeBody::get_finite_rotation_axis(void) const
 */
static PyObject *Dtool_OdeBody_get_finite_rotation_axis_206(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeBody::get_finite_rotation_axis(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeBody*)local_this).get_finite_rotation_axis());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_finite_rotation_axis_206_comment =
  "C++ Interface:\n"
  "get_finite_rotation_axis(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_finite_rotation_axis_206_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeBody::get_num_joints(void) const
 */
static PyObject *Dtool_OdeBody_get_num_joints_207(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeBody::get_num_joints(void) const
  int return_value = (*(const OdeBody*)local_this).get_num_joints();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_num_joints_207_comment =
  "C++ Interface:\n"
  "get_num_joints(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_num_joints_207_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeJoint OdeBody::get_joint(int index) const
 */
static PyObject *Dtool_OdeBody_get_joint_208(PyObject *self, PyObject *arg) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeJoint OdeBody::get_joint(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    OdeJoint *return_value = new OdeJoint((*(const OdeBody*)local_this).get_joint((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeJoint, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_joint(OdeBody self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_joint_208_comment =
  "C++ Interface:\n"
  "get_joint(OdeBody self, int index)\n";
#else
static const char *Dtool_OdeBody_get_joint_208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *OdeBody::get_converted_joint(int i) const
 */
static PyObject *Dtool_OdeBody_get_converted_joint_210(PyObject *self, PyObject *arg) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *OdeBody::get_converted_joint(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PyObject *return_value = invoke_extension((const OdeBody*)local_this).get_converted_joint((int)arg_val);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_converted_joint(OdeBody self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_converted_joint_210_comment =
  "C++ Interface:\n"
  "get_converted_joint(OdeBody self, int i)\n";
#else
static const char *Dtool_OdeBody_get_converted_joint_210_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::enable(void)
 */
static PyObject *Dtool_OdeBody_enable_211(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.enable")) {
    return NULL;
  }
  // 1-inline void OdeBody::enable(void)
  (*local_this).enable();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_enable_211_comment =
  "C++ Interface:\n"
  "enable(const OdeBody self)\n";
#else
static const char *Dtool_OdeBody_enable_211_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::disable(void)
 */
static PyObject *Dtool_OdeBody_disable_212(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.disable")) {
    return NULL;
  }
  // 1-inline void OdeBody::disable(void)
  (*local_this).disable();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_disable_212_comment =
  "C++ Interface:\n"
  "disable(const OdeBody self)\n";
#else
static const char *Dtool_OdeBody_disable_212_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeBody::is_enabled(void) const
 */
static PyObject *Dtool_OdeBody_is_enabled_213(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeBody::is_enabled(void) const
  int return_value = (*(const OdeBody*)local_this).is_enabled();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_is_enabled_213_comment =
  "C++ Interface:\n"
  "is_enabled(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_is_enabled_213_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_gravity_mode(int mode)
 */
static PyObject *Dtool_OdeBody_set_gravity_mode_214(PyObject *self, PyObject *arg) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_gravity_mode")) {
    return NULL;
  }
  // 1-inline void OdeBody::set_gravity_mode(int mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_gravity_mode((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_gravity_mode(const OdeBody self, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_gravity_mode_214_comment =
  "C++ Interface:\n"
  "set_gravity_mode(const OdeBody self, int mode)\n";
#else
static const char *Dtool_OdeBody_set_gravity_mode_214_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeBody::get_gravity_mode(void) const
 */
static PyObject *Dtool_OdeBody_get_gravity_mode_215(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeBody::get_gravity_mode(void) const
  int return_value = (*(const OdeBody*)local_this).get_gravity_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_gravity_mode_215_comment =
  "C++ Interface:\n"
  "get_gravity_mode(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_gravity_mode_215_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void OdeBody::write(ostream &out = ::cout, unsigned int indent = 0) const
 */
static PyObject *Dtool_OdeBody_write_216(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-virtual void OdeBody::write(ostream &out, unsigned int indent) const
      (*(const OdeBody*)local_this).write();
      return Dtool_Return_None();
    }
    break;
  case 1:
  case 2:
    {
      // 1-virtual void OdeBody::write(ostream &out, unsigned int indent = 0) const
      PyObject *param1;
      unsigned long param2 = 0;
      static const char *keyword_list[] = {"out", "indent", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write", (char **)keyword_list, &param1, &param2)) {
        ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "OdeBody.write", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param2 > UINT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %lu out of range for unsigned integer",
                              param2);
        }
#endif
        if (param1_this != NULL) {
          (*(const OdeBody*)local_this).write(*param1_this, (unsigned int)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "write() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(OdeBody self)\n"
      "write(OdeBody self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_write_216_comment =
  "C++ Interface:\n"
  "write(OdeBody self)\n"
  "write(OdeBody self, ostream out, int indent)\n";
#else
static const char *Dtool_OdeBody_write_216_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeBody::compare_to(OdeBody const &other) const
 */
static PyObject *Dtool_OdeBody_compare_to_218(PyObject *self, PyObject *arg) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeBody::compare_to(OdeBody const &other) const
  OdeBody const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_OdeBody(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.compare_to", "OdeBody");
  }
  int return_value = (*(const OdeBody*)local_this).compare_to(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(OdeBody self, const OdeBody other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_compare_to_218_comment =
  "C++ Interface:\n"
  "compare_to(OdeBody self, const OdeBody other)\n";
#else
static const char *Dtool_OdeBody_compare_to_218_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeBody::get_class_type(void)
 */
static PyObject *Dtool_OdeBody_get_class_type_219(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeBody::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeBody::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_class_type_219_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeBody_get_class_type_219_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeBody::OdeBody(OdeBody const &) = default
 * OdeBody::OdeBody(OdeWorld &world)
 */
static int Dtool_Init_OdeBody(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "OdeBody() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline OdeBody::OdeBody(OdeBody const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeBody", (char **)keyword_list, &param0)) {
      OdeBody const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_OdeBody, (void **)&param0_this);
      if (param0_this != NULL) {
        OdeBody *return_value = new OdeBody(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeBody, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 OdeBody::OdeBody(OdeWorld &world)
    PyObject *param0;
    static const char *keyword_list[] = {"world", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeBody", (char **)keyword_list, &param0)) {
      OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeBody.OdeBody", false, false);
      if (param0_this != NULL) {
        OdeBody *return_value = new OdeBody(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeBody, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline OdeBody::OdeBody(OdeBody const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeBody", (char **)keyword_list, &param0)) {
      OdeBody const *param0_this;
      bool param0_manage = false;
      if (Dtool_ConstCoerce_OdeBody(param0, param0_this, param0_manage)) {
        OdeBody *return_value = new OdeBody(*param0_this);
        if (param0_manage) {
          delete param0_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeBody, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: OdeBody::OdeBody(OdeWorld &world)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeBody(const OdeBody param0)\n"
      "OdeBody(OdeWorld world)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeBody(PyObject *args, OdeBody const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeBody, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeBody::OdeBody(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeBody.OdeBody", false, false);
    if (arg_this != NULL) {
      OdeBody *return_value = new OdeBody(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_OdeBody(PyObject *args, OdeBody *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeBody, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeBody::OdeBody(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeBody.OdeBody", false, false);
    if (arg_this != NULL) {
      OdeBody *return_value = new OdeBody(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_OdeBody_get_joints(PyObject *self, PyObject *) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_joints();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_OdeBody_get_joint_208(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_OdeBody(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeBody) {
    printf("OdeBody ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeBody *local_this = (OdeBody *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeBody) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeBody(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeBody) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeBody*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeSpace
 */
/**
 * Python function wrapper for:
 * void OdeSpace::destroy(void)
 */
static PyObject *Dtool_OdeSpace_destroy_221(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.destroy")) {
    return NULL;
  }
  // 1-void OdeSpace::destroy(void)
  (*local_this).destroy();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_destroy_221_comment =
  "C++ Interface:\n"
  "destroy(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_destroy_221_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool OdeSpace::is_empty(void) const
 */
static PyObject *Dtool_OdeSpace_is_empty_222(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSpace, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool OdeSpace::is_empty(void) const
  bool return_value = (*(const OdeSpace*)local_this).is_empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_is_empty_222_comment =
  "C++ Interface:\n"
  "is_empty(OdeSpace self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ID is 0, meaning the OdeSpace does not point to a valid\n"
  " * space.  It is an error to call a method on an empty space.  Note that an\n"
  " * empty OdeSpace also evaluates to False.\n"
  " */";
#else
static const char *Dtool_OdeSpace_is_empty_222_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSpace::set_cleanup(int mode)
 */
static PyObject *Dtool_OdeSpace_set_cleanup_223(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.set_cleanup")) {
    return NULL;
  }
  // 1-inline void OdeSpace::set_cleanup(int mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_cleanup((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cleanup(const OdeSpace self, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_set_cleanup_223_comment =
  "C++ Interface:\n"
  "set_cleanup(const OdeSpace self, int mode)\n";
#else
static const char *Dtool_OdeSpace_set_cleanup_223_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeSpace::get_cleanup(void) const
 */
static PyObject *Dtool_OdeSpace_get_cleanup_224(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSpace, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeSpace::get_cleanup(void) const
  int return_value = (*(const OdeSpace*)local_this).get_cleanup();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_cleanup_224_comment =
  "C++ Interface:\n"
  "get_cleanup(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_get_cleanup_224_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int OdeSpace::query(OdeGeom const &geom) const
 * int OdeSpace::query(OdeSpace const &space) const
 */
static PyObject *Dtool_OdeSpace_query_225(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSpace, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 int OdeSpace::query(OdeGeom const &geom) const
    OdeGeom const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_OdeGeom, (void **)&arg_this);
    if (arg_this != NULL) {
      int return_value = (*(const OdeSpace*)local_this).query(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 int OdeSpace::query(OdeSpace const &space) const
    OdeSpace const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_OdeSpace, (void **)&arg_this);
    if (arg_this != NULL) {
      int return_value = (*(const OdeSpace*)local_this).query(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: int OdeSpace::query(OdeGeom const &geom) const
  // No coercion possible: int OdeSpace::query(OdeSpace const &space) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "query(OdeSpace self, const OdeGeom geom)\n"
      "query(OdeSpace self, const OdeSpace space)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_query_225_comment =
  "C++ Interface:\n"
  "query(OdeSpace self, const OdeGeom geom)\n"
  "query(OdeSpace self, const OdeSpace space)\n";
#else
static const char *Dtool_OdeSpace_query_225_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeSpace::get_num_geoms(void) const
 */
static PyObject *Dtool_OdeSpace_get_num_geoms_226(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSpace, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeSpace::get_num_geoms(void) const
  int return_value = (*(const OdeSpace*)local_this).get_num_geoms();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_num_geoms_226_comment =
  "C++ Interface:\n"
  "get_num_geoms(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_get_num_geoms_226_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSpace::get_AABB(LVecBase3f &min, LVecBase3f &max) const
 */
static PyObject *Dtool_OdeSpace_get_AABB_227(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSpace, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void OdeSpace::get_AABB(LVecBase3f &min, LVecBase3f &max) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"min", "max", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_AABB", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param1_local;
    LVecBase3f *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "OdeSpace.get_AABB", "LVecBase3f");
    }
    LVecBase3f param2_local;
    LVecBase3f *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "OdeSpace.get_AABB", "LVecBase3f");
    }
    (*(const OdeSpace*)local_this).get_AABB(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_AABB(OdeSpace self, LVecBase3f min, LVecBase3f max)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_AABB_227_comment =
  "C++ Interface:\n"
  "get_AABB(OdeSpace self, LVecBase3f min, LVecBase3f max)\n";
#else
static const char *Dtool_OdeSpace_get_AABB_227_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *OdeSpace::get_AA_bounds(void) const
 */
static PyObject *Dtool_OdeSpace_get_AA_bounds_228(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSpace, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *OdeSpace::get_AA_bounds(void) const
  PyObject *return_value = invoke_extension((const OdeSpace*)local_this).get_AA_bounds();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_AA_bounds_228_comment =
  "C++ Interface:\n"
  "get_AA_bounds(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_get_AA_bounds_228_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeSpace::is_space(void)
 */
static PyObject *Dtool_OdeSpace_is_space_229(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.is_space")) {
    return NULL;
  }
  // 1-inline int OdeSpace::is_space(void)
  int return_value = (*local_this).is_space();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_is_space_229_comment =
  "C++ Interface:\n"
  "is_space(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_is_space_229_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeSpace::get_class(void) const
 */
static PyObject *Dtool_OdeSpace_get_class_230(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSpace, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeSpace::get_class(void) const
  int return_value = (*(const OdeSpace*)local_this).get_class();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_class_230_comment =
  "C++ Interface:\n"
  "get_class(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_get_class_230_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSpace::set_category_bits(BitMask32 const &bits)
 */
static PyObject *Dtool_OdeSpace_set_category_bits_231(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.set_category_bits")) {
    return NULL;
  }
  // 1-inline void OdeSpace::set_category_bits(BitMask32 const &bits)
  BitMask< uint32_t, 32 > arg_local;
  BitMask32 const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeSpace.set_category_bits", "BitMask");
  }
  (*local_this).set_category_bits(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_category_bits(const OdeSpace self, const BitMask bits)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_set_category_bits_231_comment =
  "C++ Interface:\n"
  "set_category_bits(const OdeSpace self, const BitMask bits)\n";
#else
static const char *Dtool_OdeSpace_set_category_bits_231_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSpace::set_collide_bits(BitMask32 const &bits)
 */
static PyObject *Dtool_OdeSpace_set_collide_bits_232(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.set_collide_bits")) {
    return NULL;
  }
  // 1-inline void OdeSpace::set_collide_bits(BitMask32 const &bits)
  BitMask< uint32_t, 32 > arg_local;
  BitMask32 const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeSpace.set_collide_bits", "BitMask");
  }
  (*local_this).set_collide_bits(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collide_bits(const OdeSpace self, const BitMask bits)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_set_collide_bits_232_comment =
  "C++ Interface:\n"
  "set_collide_bits(const OdeSpace self, const BitMask bits)\n";
#else
static const char *Dtool_OdeSpace_set_collide_bits_232_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitMask32 OdeSpace::get_category_bits(void)
 */
static PyObject *Dtool_OdeSpace_get_category_bits_233(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.get_category_bits")) {
    return NULL;
  }
  // 1-inline BitMask32 OdeSpace::get_category_bits(void)
  BitMask32 *return_value = new BitMask32((*local_this).get_category_bits());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_category_bits_233_comment =
  "C++ Interface:\n"
  "get_category_bits(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_get_category_bits_233_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitMask32 OdeSpace::get_collide_bits(void)
 */
static PyObject *Dtool_OdeSpace_get_collide_bits_234(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.get_collide_bits")) {
    return NULL;
  }
  // 1-inline BitMask32 OdeSpace::get_collide_bits(void)
  BitMask32 *return_value = new BitMask32((*local_this).get_collide_bits());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_collide_bits_234_comment =
  "C++ Interface:\n"
  "get_collide_bits(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_get_collide_bits_234_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSpace::enable(void)
 */
static PyObject *Dtool_OdeSpace_enable_235(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.enable")) {
    return NULL;
  }
  // 1-inline void OdeSpace::enable(void)
  (*local_this).enable();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_enable_235_comment =
  "C++ Interface:\n"
  "enable(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_enable_235_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSpace::disable(void)
 */
static PyObject *Dtool_OdeSpace_disable_236(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.disable")) {
    return NULL;
  }
  // 1-inline void OdeSpace::disable(void)
  (*local_this).disable();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_disable_236_comment =
  "C++ Interface:\n"
  "disable(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_disable_236_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeSpace::is_enabled(void)
 */
static PyObject *Dtool_OdeSpace_is_enabled_237(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.is_enabled")) {
    return NULL;
  }
  // 1-inline int OdeSpace::is_enabled(void)
  int return_value = (*local_this).is_enabled();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_is_enabled_237_comment =
  "C++ Interface:\n"
  "is_enabled(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_is_enabled_237_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeSpace::set_auto_collide_world(OdeWorld &)
 */
static PyObject *Dtool_OdeSpace_set_auto_collide_world_238(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.set_auto_collide_world")) {
    return NULL;
  }
  // 1-void OdeSpace::set_auto_collide_world(OdeWorld &)
  OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 1, "OdeSpace.set_auto_collide_world", false, true);
  if (arg_this != NULL) {
    (*local_this).set_auto_collide_world(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_collide_world(const OdeSpace self, OdeWorld param0)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_set_auto_collide_world_238_comment =
  "C++ Interface:\n"
  "set_auto_collide_world(const OdeSpace self, OdeWorld param0)\n";
#else
static const char *Dtool_OdeSpace_set_auto_collide_world_238_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeSpace::set_auto_collide_joint_group(OdeJointGroup &)
 */
static PyObject *Dtool_OdeSpace_set_auto_collide_joint_group_239(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.set_auto_collide_joint_group")) {
    return NULL;
  }
  // 1-void OdeSpace::set_auto_collide_joint_group(OdeJointGroup &)
  OdeJointGroup *arg_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointGroup, 1, "OdeSpace.set_auto_collide_joint_group", false, true);
  if (arg_this != NULL) {
    (*local_this).set_auto_collide_joint_group(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_collide_joint_group(const OdeSpace self, OdeJointGroup param0)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_set_auto_collide_joint_group_239_comment =
  "C++ Interface:\n"
  "set_auto_collide_joint_group(const OdeSpace self, OdeJointGroup param0)\n";
#else
static const char *Dtool_OdeSpace_set_auto_collide_joint_group_239_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeSpace::add(OdeGeom &geom)
 * void OdeSpace::add(OdeSpace &space)
 */
static PyObject *Dtool_OdeSpace_add_240(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.add")) {
    return NULL;
  }
  {
    // -2 void OdeSpace::add(OdeGeom &geom)
    OdeGeom *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 1, "OdeSpace.add", false, false);
    if (arg_this != NULL) {
      (*local_this).add(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void OdeSpace::add(OdeSpace &space)
    OdeSpace *arg_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeSpace, 1, "OdeSpace.add", false, false);
    if (arg_this != NULL) {
      (*local_this).add(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: void OdeSpace::add(OdeGeom &geom)
  // No coercion possible: void OdeSpace::add(OdeSpace &space)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add(const OdeSpace self, OdeGeom geom)\n"
      "add(const OdeSpace self, OdeSpace space)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_add_240_comment =
  "C++ Interface:\n"
  "add(const OdeSpace self, OdeGeom geom)\n"
  "add(const OdeSpace self, OdeSpace space)\n";
#else
static const char *Dtool_OdeSpace_add_240_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeSpace::remove(OdeGeom &geom)
 * void OdeSpace::remove(OdeSpace &space)
 */
static PyObject *Dtool_OdeSpace_remove_241(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.remove")) {
    return NULL;
  }
  {
    // -2 void OdeSpace::remove(OdeGeom &geom)
    OdeGeom *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 1, "OdeSpace.remove", false, false);
    if (arg_this != NULL) {
      (*local_this).remove(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void OdeSpace::remove(OdeSpace &space)
    OdeSpace *arg_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeSpace, 1, "OdeSpace.remove", false, false);
    if (arg_this != NULL) {
      (*local_this).remove(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: void OdeSpace::remove(OdeGeom &geom)
  // No coercion possible: void OdeSpace::remove(OdeSpace &space)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove(const OdeSpace self, OdeGeom geom)\n"
      "remove(const OdeSpace self, OdeSpace space)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_remove_241_comment =
  "C++ Interface:\n"
  "remove(const OdeSpace self, OdeGeom geom)\n"
  "remove(const OdeSpace self, OdeSpace space)\n";
#else
static const char *Dtool_OdeSpace_remove_241_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeSpace::clean(void)
 */
static PyObject *Dtool_OdeSpace_clean_242(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.clean")) {
    return NULL;
  }
  // 1-void OdeSpace::clean(void)
  (*local_this).clean();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_clean_242_comment =
  "C++ Interface:\n"
  "clean(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_clean_242_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeGeom OdeSpace::get_geom(int i)
 */
static PyObject *Dtool_OdeSpace_get_geom_243(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.get_geom")) {
    return NULL;
  }
  // 1-OdeGeom OdeSpace::get_geom(int i)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    OdeGeom *return_value = new OdeGeom((*local_this).get_geom((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeGeom, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_geom(const OdeSpace self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_geom_243_comment =
  "C++ Interface:\n"
  "get_geom(const OdeSpace self, int i)\n";
#else
static const char *Dtool_OdeSpace_get_geom_243_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeSpace OdeSpace::get_space(void) const
 */
static PyObject *Dtool_OdeSpace_get_space_244(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSpace, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline OdeSpace OdeSpace::get_space(void) const
  OdeSpace *return_value = new OdeSpace((*(const OdeSpace*)local_this).get_space());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeSpace, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_space_244_comment =
  "C++ Interface:\n"
  "get_space(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_get_space_244_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void OdeSpace::write(ostream &out = ::cout, unsigned int indent = 0) const
 */
static PyObject *Dtool_OdeSpace_write_245(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSpace, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-virtual void OdeSpace::write(ostream &out, unsigned int indent) const
      (*(const OdeSpace*)local_this).write();
      return Dtool_Return_None();
    }
    break;
  case 1:
  case 2:
    {
      // 1-virtual void OdeSpace::write(ostream &out, unsigned int indent = 0) const
      PyObject *param1;
      unsigned long param2 = 0;
      static const char *keyword_list[] = {"out", "indent", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write", (char **)keyword_list, &param1, &param2)) {
        ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "OdeSpace.write", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param2 > UINT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %lu out of range for unsigned integer",
                              param2);
        }
#endif
        if (param1_this != NULL) {
          (*(const OdeSpace*)local_this).write(*param1_this, (unsigned int)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "write() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(OdeSpace self)\n"
      "write(OdeSpace self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_write_245_comment =
  "C++ Interface:\n"
  "write(OdeSpace self)\n"
  "write(OdeSpace self, ostream out, int indent)\n";
#else
static const char *Dtool_OdeSpace_write_245_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeSimpleSpace OdeSpace::convert_to_simple_space(void) const
 */
static PyObject *Dtool_OdeSpace_convert_to_simple_space_247(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSpace, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeSimpleSpace OdeSpace::convert_to_simple_space(void) const
  OdeSimpleSpace *return_value = new OdeSimpleSpace((*(const OdeSpace*)local_this).convert_to_simple_space());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeSimpleSpace, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_convert_to_simple_space_247_comment =
  "C++ Interface:\n"
  "convert_to_simple_space(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_convert_to_simple_space_247_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeHashSpace OdeSpace::convert_to_hash_space(void) const
 */
static PyObject *Dtool_OdeSpace_convert_to_hash_space_248(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSpace, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeHashSpace OdeSpace::convert_to_hash_space(void) const
  OdeHashSpace *return_value = new OdeHashSpace((*(const OdeSpace*)local_this).convert_to_hash_space());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeHashSpace, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_convert_to_hash_space_248_comment =
  "C++ Interface:\n"
  "convert_to_hash_space(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_convert_to_hash_space_248_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeQuadTreeSpace OdeSpace::convert_to_quad_tree_space(void) const
 */
static PyObject *Dtool_OdeSpace_convert_to_quad_tree_space_249(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSpace, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeQuadTreeSpace OdeSpace::convert_to_quad_tree_space(void) const
  OdeQuadTreeSpace *return_value = new OdeQuadTreeSpace((*(const OdeSpace*)local_this).convert_to_quad_tree_space());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeQuadTreeSpace, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_convert_to_quad_tree_space_249_comment =
  "C++ Interface:\n"
  "convert_to_quad_tree_space(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_convert_to_quad_tree_space_249_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *OdeSpace::convert(void) const
 */
static PyObject *Dtool_OdeSpace_convert_250(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSpace, (void **)&local_this)) {
    return NULL;
  }
  // 1-PyObject *OdeSpace::convert(void) const
  PyObject *return_value = invoke_extension((const OdeSpace*)local_this).convert();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_convert_250_comment =
  "C++ Interface:\n"
  "convert(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_convert_250_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *OdeSpace::get_converted_geom(int i) const
 */
static PyObject *Dtool_OdeSpace_get_converted_geom_251(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSpace, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *OdeSpace::get_converted_geom(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PyObject *return_value = invoke_extension((const OdeSpace*)local_this).get_converted_geom((int)arg_val);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_converted_geom(OdeSpace self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_converted_geom_251_comment =
  "C++ Interface:\n"
  "get_converted_geom(OdeSpace self, int i)\n";
#else
static const char *Dtool_OdeSpace_get_converted_geom_251_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *OdeSpace::get_converted_space(void) const
 */
static PyObject *Dtool_OdeSpace_get_converted_space_252(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSpace, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *OdeSpace::get_converted_space(void) const
  PyObject *return_value = invoke_extension((const OdeSpace*)local_this).get_converted_space();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_converted_space_252_comment =
  "C++ Interface:\n"
  "get_converted_space(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_get_converted_space_252_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeSpace::auto_collide(void)
 */
static PyObject *Dtool_OdeSpace_auto_collide_253(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.auto_collide")) {
    return NULL;
  }
  // 1-void OdeSpace::auto_collide(void)
  (*local_this).auto_collide();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_auto_collide_253_comment =
  "C++ Interface:\n"
  "auto_collide(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_auto_collide_253_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int OdeSpace::collide(PyObject *arg, PyObject *near_callback)
 */
static PyObject *Dtool_OdeSpace_collide_254(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.collide")) {
    return NULL;
  }
  // 1-int OdeSpace::collide(PyObject *arg, PyObject *near_callback)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"arg", "near_callback", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:collide", (char **)keyword_list, &param1, &param2)) {
    int return_value = invoke_extension(local_this).collide(param1, param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "collide(const OdeSpace self, object arg, object near_callback)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_collide_254_comment =
  "C++ Interface:\n"
  "collide(const OdeSpace self, object arg, object near_callback)\n";
#else
static const char *Dtool_OdeSpace_collide_254_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int OdeSpace::set_collide_id(OdeGeom &geom, int collide_id)
 * Rejected Remap [int OdeSpace::set_collide_id(int collide_id, dGeomID id)]
 */
static PyObject *Dtool_OdeSpace_set_collide_id_255(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.set_collide_id")) {
    return NULL;
  }
  // 1-int OdeSpace::set_collide_id(OdeGeom &geom, int collide_id)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"geom", "collide_id", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:set_collide_id", (char **)keyword_list, &param1, &param2)) {
    OdeGeom *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeGeom, 1, "OdeSpace.set_collide_id", false, true);
    if (param1_this != NULL) {
      int return_value = (*local_this).set_collide_id(*param1_this, (int)param2);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collide_id(const OdeSpace self, OdeGeom geom, int collide_id)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_set_collide_id_255_comment =
  "C++ Interface:\n"
  "set_collide_id(const OdeSpace self, OdeGeom geom, int collide_id)\n";
#else
static const char *Dtool_OdeSpace_set_collide_id_255_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeSpace::set_surface_type(OdeGeom &geom, int surface_type)
 * Rejected Remap [void OdeSpace::set_surface_type(int surface_type, dGeomID id)]
 */
static PyObject *Dtool_OdeSpace_set_surface_type_256(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.set_surface_type")) {
    return NULL;
  }
  // 1-void OdeSpace::set_surface_type(OdeGeom &geom, int surface_type)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"geom", "surface_type", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:set_surface_type", (char **)keyword_list, &param1, &param2)) {
    OdeGeom *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeGeom, 1, "OdeSpace.set_surface_type", false, true);
    if (param1_this != NULL) {
      (*local_this).set_surface_type(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_surface_type(const OdeSpace self, OdeGeom geom, int surface_type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_set_surface_type_256_comment =
  "C++ Interface:\n"
  "set_surface_type(const OdeSpace self, OdeGeom geom, int surface_type)\n";
#else
static const char *Dtool_OdeSpace_set_surface_type_256_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int OdeSpace::get_surface_type(OdeGeom &geom)
 * Rejected Remap [int OdeSpace::get_surface_type(dGeomID o1)]
 */
static PyObject *Dtool_OdeSpace_get_surface_type_257(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.get_surface_type")) {
    return NULL;
  }
  // 1-int OdeSpace::get_surface_type(OdeGeom &geom)
  OdeGeom *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 1, "OdeSpace.get_surface_type", false, true);
  if (arg_this != NULL) {
    int return_value = (*local_this).get_surface_type(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_surface_type(const OdeSpace self, OdeGeom geom)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_surface_type_257_comment =
  "C++ Interface:\n"
  "get_surface_type(const OdeSpace self, OdeGeom geom)\n";
#else
static const char *Dtool_OdeSpace_get_surface_type_257_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int OdeSpace::get_collide_id(OdeGeom &geom)
 * Rejected Remap [int OdeSpace::get_collide_id(dGeomID o1)]
 */
static PyObject *Dtool_OdeSpace_get_collide_id_258(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.get_collide_id")) {
    return NULL;
  }
  // 1-int OdeSpace::get_collide_id(OdeGeom &geom)
  OdeGeom *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 1, "OdeSpace.get_collide_id", false, true);
  if (arg_this != NULL) {
    int return_value = (*local_this).get_collide_id(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_collide_id(const OdeSpace self, OdeGeom geom)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_collide_id_258_comment =
  "C++ Interface:\n"
  "get_collide_id(const OdeSpace self, OdeGeom geom)\n";
#else
static const char *Dtool_OdeSpace_get_collide_id_258_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSpace::set_collision_event(std::string const &event_name)
 */
static PyObject *Dtool_OdeSpace_set_collision_event_259(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.set_collision_event")) {
    return NULL;
  }
  // 1-inline void OdeSpace::set_collision_event(std::string const &event_name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_collision_event(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collision_event(const OdeSpace self, str event_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_set_collision_event_259_comment =
  "C++ Interface:\n"
  "set_collision_event(const OdeSpace self, str event_name)\n";
#else
static const char *Dtool_OdeSpace_set_collision_event_259_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string OdeSpace::get_collision_event(void)
 */
static PyObject *Dtool_OdeSpace_get_collision_event_260(PyObject *self, PyObject *) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.get_collision_event")) {
    return NULL;
  }
  // 1-inline std::string OdeSpace::get_collision_event(void)
  std::string return_value = (*local_this).get_collision_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_collision_event_260_comment =
  "C++ Interface:\n"
  "get_collision_event(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_get_collision_event_260_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeSpace::get_class_type(void)
 */
static PyObject *Dtool_OdeSpace_get_class_type_261(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeSpace::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeSpace::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_class_type_261_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeSpace_get_class_type_261_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeSpace::OdeSpace(OdeSpace const &) = default
 */
static int Dtool_Init_OdeSpace(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "OdeSpace() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline OdeSpace::OdeSpace(OdeSpace const &) = default
  OdeSpace const *arg_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeSpace, 0, "OdeSpace.OdeSpace", true, true);
  if (arg_this != NULL) {
    OdeSpace *return_value = new OdeSpace(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSpace, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeSpace(const OdeSpace param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeSpace(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeSpace) {
    printf("OdeSpace ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeSpace *local_this = (OdeSpace *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeSpace) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeSpace(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeSpace) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeSpace*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeGeom
 */
/**
 * Python function wrapper for:
 * void OdeGeom::destroy(void)
 */
static PyObject *Dtool_OdeGeom_destroy_265(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.destroy")) {
    return NULL;
  }
  // 1-void OdeGeom::destroy(void)
  (*local_this).destroy();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_destroy_265_comment =
  "C++ Interface:\n"
  "destroy(const OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_destroy_265_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool OdeGeom::is_empty(void) const
 */
static PyObject *Dtool_OdeGeom_is_empty_266(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool OdeGeom::is_empty(void) const
  bool return_value = (*(const OdeGeom*)local_this).is_empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_is_empty_266_comment =
  "C++ Interface:\n"
  "is_empty(OdeGeom self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ID is 0, meaning the OdeGeom does not point to a valid\n"
  " * geom.  It is an error to call a method on an empty geom.  Note that an\n"
  " * empty OdeGeom also evaluates to False.\n"
  " */";
#else
static const char *Dtool_OdeGeom_is_empty_266_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_body(OdeBody &body)
 */
static PyObject *Dtool_OdeGeom_set_body_268(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_body")) {
    return NULL;
  }
  // 1-inline void OdeGeom::set_body(OdeBody &body)
  OdeBody *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_OdeBody(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_body", "OdeBody");
  }
  (*local_this).set_body(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_body(const OdeGeom self, OdeBody body)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_body_268_comment =
  "C++ Interface:\n"
  "set_body(const OdeGeom self, OdeBody body)\n"
  "\n"
  "// INLINE void set_data(void* data);";
#else
static const char *Dtool_OdeGeom_set_body_268_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool OdeGeom::has_body(void) const
 */
static PyObject *Dtool_OdeGeom_has_body_269(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool OdeGeom::has_body(void) const
  bool return_value = (*(const OdeGeom*)local_this).has_body();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_has_body_269_comment =
  "C++ Interface:\n"
  "has_body(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_has_body_269_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeBody OdeGeom::get_body(void) const
 */
static PyObject *Dtool_OdeGeom_get_body_270(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline OdeBody OdeGeom::get_body(void) const
  OdeBody *return_value = new OdeBody((*(const OdeGeom*)local_this).get_body());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeBody, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_body_270_comment =
  "C++ Interface:\n"
  "get_body(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_body_270_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_position(LVecBase3f const &pos)
 * inline void OdeGeom::set_position(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeGeom_set_position_271(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_position")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pos");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'pos' (pos 1) not found");
      }
      // 1-inline void OdeGeom::set_position(LVecBase3f const &pos)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_position", "LVecBase3f");
      }
      (*local_this).set_position(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeGeom::set_position(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_position", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_position((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_position() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_position(const OdeGeom self, const LVecBase3f pos)\n"
      "set_position(const OdeGeom self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_position_271_comment =
  "C++ Interface:\n"
  "set_position(const OdeGeom self, const LVecBase3f pos)\n"
  "set_position(const OdeGeom self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeGeom_set_position_271_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_rotation(LMatrix3f const &r)
 */
static PyObject *Dtool_OdeGeom_set_rotation_272(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_rotation")) {
    return NULL;
  }
  // 1-inline void OdeGeom::set_rotation(LMatrix3f const &r)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_rotation", "LMatrix3f");
  }
  (*local_this).set_rotation(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rotation(const OdeGeom self, const LMatrix3f r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_rotation_272_comment =
  "C++ Interface:\n"
  "set_rotation(const OdeGeom self, const LMatrix3f r)\n";
#else
static const char *Dtool_OdeGeom_set_rotation_272_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_quaternion(LQuaternionf const &q)
 */
static PyObject *Dtool_OdeGeom_set_quaternion_273(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_quaternion")) {
    return NULL;
  }
  // 1-inline void OdeGeom::set_quaternion(LQuaternionf const &q)
  LQuaternionf arg_local;
  LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_quaternion", "LQuaternionf");
  }
  (*local_this).set_quaternion(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_quaternion(const OdeGeom self, const LQuaternionf q)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_quaternion_273_comment =
  "C++ Interface:\n"
  "set_quaternion(const OdeGeom self, const LQuaternionf q)\n";
#else
static const char *Dtool_OdeGeom_set_quaternion_273_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f OdeGeom::get_position(void) const
 */
static PyObject *Dtool_OdeGeom_get_position_274(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3f OdeGeom::get_position(void) const
  LPoint3f *return_value = new LPoint3f((*(const OdeGeom*)local_this).get_position());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_position_274_comment =
  "C++ Interface:\n"
  "get_position(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_position_274_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3f OdeGeom::get_rotation(void) const
 */
static PyObject *Dtool_OdeGeom_get_rotation_275(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix3f OdeGeom::get_rotation(void) const
  LMatrix3f *return_value = new LMatrix3f((*(const OdeGeom*)local_this).get_rotation());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_rotation_275_comment =
  "C++ Interface:\n"
  "get_rotation(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_rotation_275_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LQuaternionf OdeGeom::get_quaternion(void) const
 */
static PyObject *Dtool_OdeGeom_get_quaternion_276(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LQuaternionf OdeGeom::get_quaternion(void) const
  LQuaternionf *return_value = new LQuaternionf((*(const OdeGeom*)local_this).get_quaternion());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_quaternion_276_comment =
  "C++ Interface:\n"
  "get_quaternion(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_quaternion_276_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::get_AABB(LVecBase3f &min, LVecBase3f &max) const
 */
static PyObject *Dtool_OdeGeom_get_AABB_277(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void OdeGeom::get_AABB(LVecBase3f &min, LVecBase3f &max) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"min", "max", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_AABB", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param1_local;
    LVecBase3f *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "OdeGeom.get_AABB", "LVecBase3f");
    }
    LVecBase3f param2_local;
    LVecBase3f *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "OdeGeom.get_AABB", "LVecBase3f");
    }
    (*(const OdeGeom*)local_this).get_AABB(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_AABB(OdeGeom self, LVecBase3f min, LVecBase3f max)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_AABB_277_comment =
  "C++ Interface:\n"
  "get_AABB(OdeGeom self, LVecBase3f min, LVecBase3f max)\n";
#else
static const char *Dtool_OdeGeom_get_AABB_277_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *OdeGeom::get_AA_bounds(void) const
 */
static PyObject *Dtool_OdeGeom_get_AA_bounds_278(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *OdeGeom::get_AA_bounds(void) const
  PyObject *return_value = invoke_extension((const OdeGeom*)local_this).get_AA_bounds();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_AA_bounds_278_comment =
  "C++ Interface:\n"
  "get_AA_bounds(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_AA_bounds_278_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeGeom::is_space(void)
 */
static PyObject *Dtool_OdeGeom_is_space_279(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.is_space")) {
    return NULL;
  }
  // 1-inline int OdeGeom::is_space(void)
  int return_value = (*local_this).is_space();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_is_space_279_comment =
  "C++ Interface:\n"
  "is_space(const OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_is_space_279_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeGeom::get_class(void) const
 */
static PyObject *Dtool_OdeGeom_get_class_280(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeGeom::get_class(void) const
  int return_value = (*(const OdeGeom*)local_this).get_class();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_class_280_comment =
  "C++ Interface:\n"
  "get_class(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_class_280_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_category_bits(BitMask32 const &bits)
 */
static PyObject *Dtool_OdeGeom_set_category_bits_281(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_category_bits")) {
    return NULL;
  }
  // 1-inline void OdeGeom::set_category_bits(BitMask32 const &bits)
  BitMask< uint32_t, 32 > arg_local;
  BitMask32 const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_category_bits", "BitMask");
  }
  (*local_this).set_category_bits(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_category_bits(const OdeGeom self, const BitMask bits)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_category_bits_281_comment =
  "C++ Interface:\n"
  "set_category_bits(const OdeGeom self, const BitMask bits)\n";
#else
static const char *Dtool_OdeGeom_set_category_bits_281_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_collide_bits(BitMask32 const &bits)
 */
static PyObject *Dtool_OdeGeom_set_collide_bits_282(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_collide_bits")) {
    return NULL;
  }
  // 1-inline void OdeGeom::set_collide_bits(BitMask32 const &bits)
  BitMask< uint32_t, 32 > arg_local;
  BitMask32 const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_collide_bits", "BitMask");
  }
  (*local_this).set_collide_bits(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collide_bits(const OdeGeom self, const BitMask bits)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_collide_bits_282_comment =
  "C++ Interface:\n"
  "set_collide_bits(const OdeGeom self, const BitMask bits)\n";
#else
static const char *Dtool_OdeGeom_set_collide_bits_282_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitMask32 OdeGeom::get_category_bits(void)
 */
static PyObject *Dtool_OdeGeom_get_category_bits_283(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.get_category_bits")) {
    return NULL;
  }
  // 1-inline BitMask32 OdeGeom::get_category_bits(void)
  BitMask32 *return_value = new BitMask32((*local_this).get_category_bits());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_category_bits_283_comment =
  "C++ Interface:\n"
  "get_category_bits(const OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_category_bits_283_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitMask32 OdeGeom::get_collide_bits(void)
 */
static PyObject *Dtool_OdeGeom_get_collide_bits_284(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.get_collide_bits")) {
    return NULL;
  }
  // 1-inline BitMask32 OdeGeom::get_collide_bits(void)
  BitMask32 *return_value = new BitMask32((*local_this).get_collide_bits());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_collide_bits_284_comment =
  "C++ Interface:\n"
  "get_collide_bits(const OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_collide_bits_284_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::enable(void)
 */
static PyObject *Dtool_OdeGeom_enable_285(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.enable")) {
    return NULL;
  }
  // 1-inline void OdeGeom::enable(void)
  (*local_this).enable();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_enable_285_comment =
  "C++ Interface:\n"
  "enable(const OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_enable_285_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::disable(void)
 */
static PyObject *Dtool_OdeGeom_disable_286(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.disable")) {
    return NULL;
  }
  // 1-inline void OdeGeom::disable(void)
  (*local_this).disable();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_disable_286_comment =
  "C++ Interface:\n"
  "disable(const OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_disable_286_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeGeom::is_enabled(void)
 */
static PyObject *Dtool_OdeGeom_is_enabled_287(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.is_enabled")) {
    return NULL;
  }
  // 1-inline int OdeGeom::is_enabled(void)
  int return_value = (*local_this).is_enabled();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_is_enabled_287_comment =
  "C++ Interface:\n"
  "is_enabled(const OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_is_enabled_287_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_offset_position(LVecBase3f const &pos)
 * inline void OdeGeom::set_offset_position(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeGeom_set_offset_position_288(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_offset_position")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pos");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'pos' (pos 1) not found");
      }
      // 1-inline void OdeGeom::set_offset_position(LVecBase3f const &pos)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_offset_position", "LVecBase3f");
      }
      (*local_this).set_offset_position(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeGeom::set_offset_position(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_offset_position", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_offset_position((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_offset_position() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_offset_position(const OdeGeom self, const LVecBase3f pos)\n"
      "set_offset_position(const OdeGeom self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_offset_position_288_comment =
  "C++ Interface:\n"
  "set_offset_position(const OdeGeom self, const LVecBase3f pos)\n"
  "set_offset_position(const OdeGeom self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeGeom_set_offset_position_288_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_offset_rotation(LMatrix3f const &r)
 */
static PyObject *Dtool_OdeGeom_set_offset_rotation_289(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_offset_rotation")) {
    return NULL;
  }
  // 1-inline void OdeGeom::set_offset_rotation(LMatrix3f const &r)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_offset_rotation", "LMatrix3f");
  }
  (*local_this).set_offset_rotation(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_offset_rotation(const OdeGeom self, const LMatrix3f r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_offset_rotation_289_comment =
  "C++ Interface:\n"
  "set_offset_rotation(const OdeGeom self, const LMatrix3f r)\n";
#else
static const char *Dtool_OdeGeom_set_offset_rotation_289_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_offset_quaternion(LQuaternionf const &q)
 */
static PyObject *Dtool_OdeGeom_set_offset_quaternion_290(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_offset_quaternion")) {
    return NULL;
  }
  // 1-inline void OdeGeom::set_offset_quaternion(LQuaternionf const &q)
  LQuaternionf arg_local;
  LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_offset_quaternion", "LQuaternionf");
  }
  (*local_this).set_offset_quaternion(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_offset_quaternion(const OdeGeom self, const LQuaternionf q)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_offset_quaternion_290_comment =
  "C++ Interface:\n"
  "set_offset_quaternion(const OdeGeom self, const LQuaternionf q)\n";
#else
static const char *Dtool_OdeGeom_set_offset_quaternion_290_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_offset_world_position(LVecBase3f const &pos)
 * inline void OdeGeom::set_offset_world_position(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeGeom_set_offset_world_position_291(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_offset_world_position")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pos");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'pos' (pos 1) not found");
      }
      // 1-inline void OdeGeom::set_offset_world_position(LVecBase3f const &pos)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_offset_world_position", "LVecBase3f");
      }
      (*local_this).set_offset_world_position(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeGeom::set_offset_world_position(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_offset_world_position", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_offset_world_position((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_offset_world_position() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_offset_world_position(const OdeGeom self, const LVecBase3f pos)\n"
      "set_offset_world_position(const OdeGeom self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_offset_world_position_291_comment =
  "C++ Interface:\n"
  "set_offset_world_position(const OdeGeom self, const LVecBase3f pos)\n"
  "set_offset_world_position(const OdeGeom self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeGeom_set_offset_world_position_291_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_offset_world_rotation(LMatrix3f const &r)
 */
static PyObject *Dtool_OdeGeom_set_offset_world_rotation_292(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_offset_world_rotation")) {
    return NULL;
  }
  // 1-inline void OdeGeom::set_offset_world_rotation(LMatrix3f const &r)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_offset_world_rotation", "LMatrix3f");
  }
  (*local_this).set_offset_world_rotation(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_offset_world_rotation(const OdeGeom self, const LMatrix3f r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_offset_world_rotation_292_comment =
  "C++ Interface:\n"
  "set_offset_world_rotation(const OdeGeom self, const LMatrix3f r)\n";
#else
static const char *Dtool_OdeGeom_set_offset_world_rotation_292_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_offset_world_quaternion(LQuaternionf const &q)
 */
static PyObject *Dtool_OdeGeom_set_offset_world_quaternion_293(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_offset_world_quaternion")) {
    return NULL;
  }
  // 1-inline void OdeGeom::set_offset_world_quaternion(LQuaternionf const &q)
  LQuaternionf arg_local;
  LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_offset_world_quaternion", "LQuaternionf");
  }
  (*local_this).set_offset_world_quaternion(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_offset_world_quaternion(const OdeGeom self, const LQuaternionf q)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_offset_world_quaternion_293_comment =
  "C++ Interface:\n"
  "set_offset_world_quaternion(const OdeGeom self, const LQuaternionf q)\n";
#else
static const char *Dtool_OdeGeom_set_offset_world_quaternion_293_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::clear_offset(void)
 */
static PyObject *Dtool_OdeGeom_clear_offset_294(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.clear_offset")) {
    return NULL;
  }
  // 1-inline void OdeGeom::clear_offset(void)
  (*local_this).clear_offset();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_clear_offset_294_comment =
  "C++ Interface:\n"
  "clear_offset(const OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_clear_offset_294_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeGeom::is_offset(void)
 */
static PyObject *Dtool_OdeGeom_is_offset_295(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.is_offset")) {
    return NULL;
  }
  // 1-inline int OdeGeom::is_offset(void)
  int return_value = (*local_this).is_offset();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_is_offset_295_comment =
  "C++ Interface:\n"
  "is_offset(const OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_is_offset_295_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f OdeGeom::get_offset_position(void) const
 */
static PyObject *Dtool_OdeGeom_get_offset_position_296(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3f OdeGeom::get_offset_position(void) const
  LPoint3f *return_value = new LPoint3f((*(const OdeGeom*)local_this).get_offset_position());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_offset_position_296_comment =
  "C++ Interface:\n"
  "get_offset_position(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_offset_position_296_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3f OdeGeom::get_offset_rotation(void) const
 */
static PyObject *Dtool_OdeGeom_get_offset_rotation_297(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix3f OdeGeom::get_offset_rotation(void) const
  LMatrix3f *return_value = new LMatrix3f((*(const OdeGeom*)local_this).get_offset_rotation());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_offset_rotation_297_comment =
  "C++ Interface:\n"
  "get_offset_rotation(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_offset_rotation_297_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LQuaternionf OdeGeom::get_offset_quaternion(void) const
 */
static PyObject *Dtool_OdeGeom_get_offset_quaternion_298(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LQuaternionf OdeGeom::get_offset_quaternion(void) const
  LQuaternionf *return_value = new LQuaternionf((*(const OdeGeom*)local_this).get_offset_quaternion());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_offset_quaternion_298_comment =
  "C++ Interface:\n"
  "get_offset_quaternion(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_offset_quaternion_298_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeSpace OdeGeom::get_space(void) const
 */
static PyObject *Dtool_OdeGeom_get_space_299(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeSpace OdeGeom::get_space(void) const
  OdeSpace *return_value = new OdeSpace((*(const OdeGeom*)local_this).get_space());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeSpace, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_space_299_comment =
  "C++ Interface:\n"
  "get_space(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_space_299_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *OdeGeom::get_converted_space(void) const
 */
static PyObject *Dtool_OdeGeom_get_converted_space_300(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *OdeGeom::get_converted_space(void) const
  PyObject *return_value = invoke_extension((const OdeGeom*)local_this).get_converted_space();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_converted_space_300_comment =
  "C++ Interface:\n"
  "get_converted_space(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_converted_space_300_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void OdeGeom::write(ostream &out = ::cout, unsigned int indent = 0) const
 */
static PyObject *Dtool_OdeGeom_write_301(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-virtual void OdeGeom::write(ostream &out, unsigned int indent) const
      (*(const OdeGeom*)local_this).write();
      return Dtool_Return_None();
    }
    break;
  case 1:
  case 2:
    {
      // 1-virtual void OdeGeom::write(ostream &out, unsigned int indent = 0) const
      PyObject *param1;
      unsigned long param2 = 0;
      static const char *keyword_list[] = {"out", "indent", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write", (char **)keyword_list, &param1, &param2)) {
        ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "OdeGeom.write", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param2 > UINT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %lu out of range for unsigned integer",
                              param2);
        }
#endif
        if (param1_this != NULL) {
          (*(const OdeGeom*)local_this).write(*param1_this, (unsigned int)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "write() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(OdeGeom self)\n"
      "write(OdeGeom self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_write_301_comment =
  "C++ Interface:\n"
  "write(OdeGeom self)\n"
  "write(OdeGeom self, ostream out, int indent)\n";
#else
static const char *Dtool_OdeGeom_write_301_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeGeom::compare_to(OdeGeom const &other) const
 */
static PyObject *Dtool_OdeGeom_compare_to_303(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeGeom::compare_to(OdeGeom const &other) const
  OdeGeom const *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 1, "OdeGeom.compare_to", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const OdeGeom*)local_this).compare_to(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(OdeGeom self, const OdeGeom other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_compare_to_303_comment =
  "C++ Interface:\n"
  "compare_to(OdeGeom self, const OdeGeom other)\n";
#else
static const char *Dtool_OdeGeom_compare_to_303_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *OdeGeom::convert(void) const
 */
static PyObject *Dtool_OdeGeom_convert_304(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-PyObject *OdeGeom::convert(void) const
  PyObject *return_value = invoke_extension((const OdeGeom*)local_this).convert();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_304_comment =
  "C++ Interface:\n"
  "convert(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_convert_304_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeBoxGeom OdeGeom::convert_to_box(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_box_305(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeBoxGeom OdeGeom::convert_to_box(void) const
  OdeBoxGeom *return_value = new OdeBoxGeom((*(const OdeGeom*)local_this).convert_to_box());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeBoxGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_box_305_comment =
  "C++ Interface:\n"
  "convert_to_box(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_convert_to_box_305_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeCappedCylinderGeom OdeGeom::convert_to_capped_cylinder(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_capped_cylinder_306(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeCappedCylinderGeom OdeGeom::convert_to_capped_cylinder(void) const
  OdeCappedCylinderGeom *return_value = new OdeCappedCylinderGeom((*(const OdeGeom*)local_this).convert_to_capped_cylinder());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeCappedCylinderGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_capped_cylinder_306_comment =
  "C++ Interface:\n"
  "convert_to_capped_cylinder(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_convert_to_capped_cylinder_306_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeCylinderGeom OdeGeom::convert_to_cylinder(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_cylinder_307(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeCylinderGeom OdeGeom::convert_to_cylinder(void) const
  OdeCylinderGeom *return_value = new OdeCylinderGeom((*(const OdeGeom*)local_this).convert_to_cylinder());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeCylinderGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_cylinder_307_comment =
  "C++ Interface:\n"
  "convert_to_cylinder(OdeGeom self)\n"
  "\n"
  "// OdeConvexGeom convert_to_convex() const;";
#else
static const char *Dtool_OdeGeom_convert_to_cylinder_307_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdePlaneGeom OdeGeom::convert_to_plane(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_plane_308(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdePlaneGeom OdeGeom::convert_to_plane(void) const
  OdePlaneGeom *return_value = new OdePlaneGeom((*(const OdeGeom*)local_this).convert_to_plane());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdePlaneGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_plane_308_comment =
  "C++ Interface:\n"
  "convert_to_plane(OdeGeom self)\n"
  "\n"
  "// OdeHeightfieldGeom convert_to_heightfield() const;";
#else
static const char *Dtool_OdeGeom_convert_to_plane_308_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeRayGeom OdeGeom::convert_to_ray(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_ray_309(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeRayGeom OdeGeom::convert_to_ray(void) const
  OdeRayGeom *return_value = new OdeRayGeom((*(const OdeGeom*)local_this).convert_to_ray());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeRayGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_ray_309_comment =
  "C++ Interface:\n"
  "convert_to_ray(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_convert_to_ray_309_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeSphereGeom OdeGeom::convert_to_sphere(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_sphere_310(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeSphereGeom OdeGeom::convert_to_sphere(void) const
  OdeSphereGeom *return_value = new OdeSphereGeom((*(const OdeGeom*)local_this).convert_to_sphere());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeSphereGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_sphere_310_comment =
  "C++ Interface:\n"
  "convert_to_sphere(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_convert_to_sphere_310_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeTriMeshGeom OdeGeom::convert_to_tri_mesh(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_tri_mesh_311(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeTriMeshGeom OdeGeom::convert_to_tri_mesh(void) const
  OdeTriMeshGeom *return_value = new OdeTriMeshGeom((*(const OdeGeom*)local_this).convert_to_tri_mesh());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeTriMeshGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_tri_mesh_311_comment =
  "C++ Interface:\n"
  "convert_to_tri_mesh(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_convert_to_tri_mesh_311_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeSimpleSpace OdeGeom::convert_to_simple_space(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_simple_space_312(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeSimpleSpace OdeGeom::convert_to_simple_space(void) const
  OdeSimpleSpace *return_value = new OdeSimpleSpace((*(const OdeGeom*)local_this).convert_to_simple_space());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeSimpleSpace, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_simple_space_312_comment =
  "C++ Interface:\n"
  "convert_to_simple_space(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_convert_to_simple_space_312_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeHashSpace OdeGeom::convert_to_hash_space(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_hash_space_313(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeHashSpace OdeGeom::convert_to_hash_space(void) const
  OdeHashSpace *return_value = new OdeHashSpace((*(const OdeGeom*)local_this).convert_to_hash_space());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeHashSpace, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_hash_space_313_comment =
  "C++ Interface:\n"
  "convert_to_hash_space(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_convert_to_hash_space_313_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeQuadTreeSpace OdeGeom::convert_to_quad_tree_space(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_quad_tree_space_314(PyObject *self, PyObject *) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeQuadTreeSpace OdeGeom::convert_to_quad_tree_space(void) const
  OdeQuadTreeSpace *return_value = new OdeQuadTreeSpace((*(const OdeGeom*)local_this).convert_to_quad_tree_space());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeQuadTreeSpace, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_quad_tree_space_314_comment =
  "C++ Interface:\n"
  "convert_to_quad_tree_space(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_convert_to_quad_tree_space_314_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeGeom::get_class_type(void)
 */
static PyObject *Dtool_OdeGeom_get_class_type_315(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeGeom::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeGeom::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_class_type_315_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeGeom_get_class_type_315_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeGeom::OdeGeom(OdeGeom const &) = default
 */
static int Dtool_Init_OdeGeom(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "OdeGeom() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline OdeGeom::OdeGeom(OdeGeom const &) = default
  OdeGeom const *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 0, "OdeGeom.OdeGeom", true, true);
  if (arg_this != NULL) {
    OdeGeom *return_value = new OdeGeom(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeGeom, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeGeom(const OdeGeom param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeGeom) {
    printf("OdeGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeGeom *local_this = (OdeGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeGeom) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeGeom) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeGeom*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeBoxGeom
 */
/**
 * Python function wrapper for:
 * inline void OdeBoxGeom::set_lengths(LVecBase3f const &size)
 * inline void OdeBoxGeom::set_lengths(dReal lx, dReal ly, dReal lz)
 */
static PyObject *Dtool_OdeBoxGeom_set_lengths_319(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBoxGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBoxGeom, (void **)&local_this, "OdeBoxGeom.set_lengths")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "size");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'size' (pos 1) not found");
      }
      // 1-inline void OdeBoxGeom::set_lengths(LVecBase3f const &size)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBoxGeom.set_lengths", "LVecBase3f");
      }
      (*local_this).set_lengths(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeBoxGeom::set_lengths(dReal lx, dReal ly, dReal lz)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"lx", "ly", "lz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_lengths", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_lengths((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_lengths() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lengths(const OdeBoxGeom self, const LVecBase3f size)\n"
      "set_lengths(const OdeBoxGeom self, float lx, float ly, float lz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBoxGeom_set_lengths_319_comment =
  "C++ Interface:\n"
  "set_lengths(const OdeBoxGeom self, const LVecBase3f size)\n"
  "set_lengths(const OdeBoxGeom self, float lx, float ly, float lz)\n";
#else
static const char *Dtool_OdeBoxGeom_set_lengths_319_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeBoxGeom::get_lengths(void)
 */
static PyObject *Dtool_OdeBoxGeom_get_lengths_320(PyObject *self, PyObject *) {
  OdeBoxGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBoxGeom, (void **)&local_this, "OdeBoxGeom.get_lengths")) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeBoxGeom::get_lengths(void)
  LVecBase3f *return_value = new LVecBase3f((*local_this).get_lengths());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBoxGeom_get_lengths_320_comment =
  "C++ Interface:\n"
  "get_lengths(const OdeBoxGeom self)\n";
#else
static const char *Dtool_OdeBoxGeom_get_lengths_320_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeBoxGeom::get_point_depth(LPoint3f const &p)
 * inline dReal OdeBoxGeom::get_point_depth(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeBoxGeom_get_point_depth_321(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBoxGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBoxGeom, (void **)&local_this, "OdeBoxGeom.get_point_depth")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "p");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'p' (pos 1) not found");
      }
      // 1-inline dReal OdeBoxGeom::get_point_depth(LPoint3f const &p)
      LPoint3f arg_local;
      LPoint3f const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeBoxGeom.get_point_depth", "LPoint3f");
      }
      dReal return_value = (*local_this).get_point_depth(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 3:
    {
      // 1-inline dReal OdeBoxGeom::get_point_depth(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:get_point_depth", (char **)keyword_list, &param1, &param2, &param3)) {
        dReal return_value = (*local_this).get_point_depth((dReal)param1, (dReal)param2, (dReal)param3);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_point_depth() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point_depth(const OdeBoxGeom self, const LPoint3f p)\n"
      "get_point_depth(const OdeBoxGeom self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeBoxGeom_get_point_depth_321_comment =
  "C++ Interface:\n"
  "get_point_depth(const OdeBoxGeom self, const LPoint3f p)\n"
  "get_point_depth(const OdeBoxGeom self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeBoxGeom_get_point_depth_321_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeBoxGeom::get_class_type(void)
 */
static PyObject *Dtool_OdeBoxGeom_get_class_type_322(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeBoxGeom::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeBoxGeom::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBoxGeom_get_class_type_322_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeBoxGeom_get_class_type_322_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeBoxGeom::OdeBoxGeom(OdeBoxGeom const &) = default
 * OdeBoxGeom::OdeBoxGeom(OdeSpace &space, LVecBase3f const &size)
 * OdeBoxGeom::OdeBoxGeom(OdeSpace &space, dReal lx, dReal ly, dReal lz)
 * OdeBoxGeom::OdeBoxGeom(dReal lx, dReal ly, dReal lz)
 */
static int Dtool_Init_OdeBoxGeom(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline OdeBoxGeom::OdeBoxGeom(OdeBoxGeom const &) = default
      OdeBoxGeom const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_OdeBoxGeom(arg, arg_this, arg_manage)) {
        Dtool_Raise_ArgTypeError(arg, 0, "OdeBoxGeom.OdeBoxGeom", "OdeBoxGeom");
        return -1;
      }
      OdeBoxGeom *return_value = new OdeBoxGeom(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeBoxGeom, true, false);
    }
    break;
  case 2:
    {
      // 1-OdeBoxGeom::OdeBoxGeom(OdeSpace &space, LVecBase3f const &size)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"space", "size", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeBoxGeom", (char **)keyword_list, &param0, &param1)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeBoxGeom.OdeBoxGeom", false, true);
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "OdeBoxGeom.OdeBoxGeom", "LVecBase3f");
          return -1;
        }
        if (param0_this != NULL) {
          OdeBoxGeom *return_value = new OdeBoxGeom(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeBoxGeom, true, false);
        }
      }
    }
    break;
  case 3:
    {
      // 1-OdeBoxGeom::OdeBoxGeom(dReal lx, dReal ly, dReal lz)
      float param0;
      float param1;
      float param2;
      static const char *keyword_list[] = {"lx", "ly", "lz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:OdeBoxGeom", (char **)keyword_list, &param0, &param1, &param2)) {
        OdeBoxGeom *return_value = new OdeBoxGeom((dReal)param0, (dReal)param1, (dReal)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeBoxGeom, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-OdeBoxGeom::OdeBoxGeom(OdeSpace &space, dReal lx, dReal ly, dReal lz)
      PyObject *param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"space", "lx", "ly", "lz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:OdeBoxGeom", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeBoxGeom.OdeBoxGeom", false, true);
        if (param0_this != NULL) {
          OdeBoxGeom *return_value = new OdeBoxGeom(*param0_this, (dReal)param1, (dReal)param2, (dReal)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeBoxGeom, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeBoxGeom() takes 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeBoxGeom(const OdeBoxGeom param0)\n"
      "OdeBoxGeom(OdeSpace space, const LVecBase3f size)\n"
      "OdeBoxGeom(float lx, float ly, float lz)\n"
      "OdeBoxGeom(OdeSpace space, float lx, float ly, float lz)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeBoxGeom(PyObject *args, OdeBoxGeom const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeBoxGeom, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-OdeBoxGeom::OdeBoxGeom(OdeSpace &space, LVecBase3f const &size)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "OdeBoxGeom", 2, 2, &param0, &param1)) {
          OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeBoxGeom.OdeBoxGeom", false, false);
          LVecBase3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            OdeBoxGeom *return_value = new OdeBoxGeom(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-OdeBoxGeom::OdeBoxGeom(dReal lx, dReal ly, dReal lz)
        float param0;
        float param1;
        float param2;
        if (PyArg_ParseTuple(args, "fff:OdeBoxGeom", &param0, &param1, &param2)) {
          OdeBoxGeom *return_value = new OdeBoxGeom((dReal)param0, (dReal)param1, (dReal)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-OdeBoxGeom::OdeBoxGeom(OdeSpace &space, dReal lx, dReal ly, dReal lz)
        PyObject *param0;
        float param1;
        float param2;
        float param3;
        if (PyArg_ParseTuple(args, "Offf:OdeBoxGeom", &param0, &param1, &param2, &param3)) {
          OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeBoxGeom.OdeBoxGeom", false, false);
          if (param0_this != NULL) {
            OdeBoxGeom *return_value = new OdeBoxGeom(*param0_this, (dReal)param1, (dReal)param2, (dReal)param3);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_OdeBoxGeom(PyObject *args, OdeBoxGeom *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeBoxGeom, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-OdeBoxGeom::OdeBoxGeom(OdeSpace &space, LVecBase3f const &size)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "OdeBoxGeom", 2, 2, &param0, &param1)) {
          OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeBoxGeom.OdeBoxGeom", false, false);
          LVecBase3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            OdeBoxGeom *return_value = new OdeBoxGeom(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-OdeBoxGeom::OdeBoxGeom(dReal lx, dReal ly, dReal lz)
        float param0;
        float param1;
        float param2;
        if (PyArg_ParseTuple(args, "fff:OdeBoxGeom", &param0, &param1, &param2)) {
          OdeBoxGeom *return_value = new OdeBoxGeom((dReal)param0, (dReal)param1, (dReal)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-OdeBoxGeom::OdeBoxGeom(OdeSpace &space, dReal lx, dReal ly, dReal lz)
        PyObject *param0;
        float param1;
        float param2;
        float param3;
        if (PyArg_ParseTuple(args, "Offf:OdeBoxGeom", &param0, &param1, &param2, &param3)) {
          OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeBoxGeom.OdeBoxGeom", false, false);
          if (param0_this != NULL) {
            OdeBoxGeom *return_value = new OdeBoxGeom(*param0_this, (dReal)param1, (dReal)param2, (dReal)param3);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeBoxGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeBoxGeom) {
    printf("OdeBoxGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeBoxGeom *local_this = (OdeBoxGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeBoxGeom) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeGeom) {
    return (OdeGeom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeGeom *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeBoxGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeBoxGeom) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeGeom) {
    OdeGeom* other_this = (OdeGeom*)from_this;
    return (OdeBoxGeom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeBoxGeom*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeCappedCylinderGeom
 */
/**
 * Python function wrapper for:
 * inline void OdeCappedCylinderGeom::set_params(dReal radius, dReal length)
 */
static PyObject *Dtool_OdeCappedCylinderGeom_set_params_325(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeCappedCylinderGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeCappedCylinderGeom, (void **)&local_this, "OdeCappedCylinderGeom.set_params")) {
    return NULL;
  }
  // 1-inline void OdeCappedCylinderGeom::set_params(dReal radius, dReal length)
  float param1;
  float param2;
  static const char *keyword_list[] = {"radius", "length", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_params", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_params((dReal)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_params(const OdeCappedCylinderGeom self, float radius, float length)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeCappedCylinderGeom_set_params_325_comment =
  "C++ Interface:\n"
  "set_params(const OdeCappedCylinderGeom self, float radius, float length)\n";
#else
static const char *Dtool_OdeCappedCylinderGeom_set_params_325_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeCappedCylinderGeom::get_radius(void) const
 */
static PyObject *Dtool_OdeCappedCylinderGeom_get_radius_327(PyObject *self, PyObject *) {
  OdeCappedCylinderGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCappedCylinderGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeCappedCylinderGeom::get_radius(void) const
  dReal return_value = (*(const OdeCappedCylinderGeom*)local_this).get_radius();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeCappedCylinderGeom_get_radius_327_comment =
  "C++ Interface:\n"
  "get_radius(OdeCappedCylinderGeom self)\n";
#else
static const char *Dtool_OdeCappedCylinderGeom_get_radius_327_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeCappedCylinderGeom::get_length(void) const
 */
static PyObject *Dtool_OdeCappedCylinderGeom_get_length_328(PyObject *self, PyObject *) {
  OdeCappedCylinderGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCappedCylinderGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeCappedCylinderGeom::get_length(void) const
  dReal return_value = (*(const OdeCappedCylinderGeom*)local_this).get_length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeCappedCylinderGeom_get_length_328_comment =
  "C++ Interface:\n"
  "get_length(OdeCappedCylinderGeom self)\n";
#else
static const char *Dtool_OdeCappedCylinderGeom_get_length_328_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeCappedCylinderGeom::get_point_depth(LPoint3f const &p) const
 * inline dReal OdeCappedCylinderGeom::get_point_depth(dReal x, dReal y, dReal z) const
 */
static PyObject *Dtool_OdeCappedCylinderGeom_get_point_depth_329(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeCappedCylinderGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCappedCylinderGeom, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "p");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'p' (pos 1) not found");
      }
      // 1-inline dReal OdeCappedCylinderGeom::get_point_depth(LPoint3f const &p) const
      LPoint3f arg_local;
      LPoint3f const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeCappedCylinderGeom.get_point_depth", "LPoint3f");
      }
      dReal return_value = (*(const OdeCappedCylinderGeom*)local_this).get_point_depth(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 3:
    {
      // 1-inline dReal OdeCappedCylinderGeom::get_point_depth(dReal x, dReal y, dReal z) const
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:get_point_depth", (char **)keyword_list, &param1, &param2, &param3)) {
        dReal return_value = (*(const OdeCappedCylinderGeom*)local_this).get_point_depth((dReal)param1, (dReal)param2, (dReal)param3);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_point_depth() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point_depth(OdeCappedCylinderGeom self, const LPoint3f p)\n"
      "get_point_depth(OdeCappedCylinderGeom self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeCappedCylinderGeom_get_point_depth_329_comment =
  "C++ Interface:\n"
  "get_point_depth(OdeCappedCylinderGeom self, const LPoint3f p)\n"
  "get_point_depth(OdeCappedCylinderGeom self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeCappedCylinderGeom_get_point_depth_329_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeCappedCylinderGeom::get_class_type(void)
 */
static PyObject *Dtool_OdeCappedCylinderGeom_get_class_type_330(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeCappedCylinderGeom::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeCappedCylinderGeom::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeCappedCylinderGeom_get_class_type_330_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeCappedCylinderGeom_get_class_type_330_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeCappedCylinderGeom::OdeCappedCylinderGeom(OdeCappedCylinderGeom const &) = default
 * OdeCappedCylinderGeom::OdeCappedCylinderGeom(OdeSpace &space, dReal radius, dReal length)
 * OdeCappedCylinderGeom::OdeCappedCylinderGeom(dReal radius, dReal length)
 */
static int Dtool_Init_OdeCappedCylinderGeom(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline OdeCappedCylinderGeom::OdeCappedCylinderGeom(OdeCappedCylinderGeom const &) = default
      OdeCappedCylinderGeom const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_OdeCappedCylinderGeom(arg, arg_this, arg_manage)) {
        Dtool_Raise_ArgTypeError(arg, 0, "OdeCappedCylinderGeom.OdeCappedCylinderGeom", "OdeCappedCylinderGeom");
        return -1;
      }
      OdeCappedCylinderGeom *return_value = new OdeCappedCylinderGeom(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeCappedCylinderGeom, true, false);
    }
    break;
  case 2:
    {
      // 1-OdeCappedCylinderGeom::OdeCappedCylinderGeom(dReal radius, dReal length)
      float param0;
      float param1;
      static const char *keyword_list[] = {"radius", "length", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:OdeCappedCylinderGeom", (char **)keyword_list, &param0, &param1)) {
        OdeCappedCylinderGeom *return_value = new OdeCappedCylinderGeom((dReal)param0, (dReal)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeCappedCylinderGeom, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-OdeCappedCylinderGeom::OdeCappedCylinderGeom(OdeSpace &space, dReal radius, dReal length)
      PyObject *param0;
      float param1;
      float param2;
      static const char *keyword_list[] = {"space", "radius", "length", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:OdeCappedCylinderGeom", (char **)keyword_list, &param0, &param1, &param2)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeCappedCylinderGeom.OdeCappedCylinderGeom", false, true);
        if (param0_this != NULL) {
          OdeCappedCylinderGeom *return_value = new OdeCappedCylinderGeom(*param0_this, (dReal)param1, (dReal)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeCappedCylinderGeom, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeCappedCylinderGeom() takes 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeCappedCylinderGeom(const OdeCappedCylinderGeom param0)\n"
      "OdeCappedCylinderGeom(float radius, float length)\n"
      "OdeCappedCylinderGeom(OdeSpace space, float radius, float length)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeCappedCylinderGeom(PyObject *args, OdeCappedCylinderGeom const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeCappedCylinderGeom, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-OdeCappedCylinderGeom::OdeCappedCylinderGeom(dReal radius, dReal length)
        float param0;
        float param1;
        if (PyArg_ParseTuple(args, "ff:OdeCappedCylinderGeom", &param0, &param1)) {
          OdeCappedCylinderGeom *return_value = new OdeCappedCylinderGeom((dReal)param0, (dReal)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-OdeCappedCylinderGeom::OdeCappedCylinderGeom(OdeSpace &space, dReal radius, dReal length)
        PyObject *param0;
        float param1;
        float param2;
        if (PyArg_ParseTuple(args, "Off:OdeCappedCylinderGeom", &param0, &param1, &param2)) {
          OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeCappedCylinderGeom.OdeCappedCylinderGeom", false, false);
          if (param0_this != NULL) {
            OdeCappedCylinderGeom *return_value = new OdeCappedCylinderGeom(*param0_this, (dReal)param1, (dReal)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_OdeCappedCylinderGeom(PyObject *args, OdeCappedCylinderGeom *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeCappedCylinderGeom, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-OdeCappedCylinderGeom::OdeCappedCylinderGeom(dReal radius, dReal length)
        float param0;
        float param1;
        if (PyArg_ParseTuple(args, "ff:OdeCappedCylinderGeom", &param0, &param1)) {
          OdeCappedCylinderGeom *return_value = new OdeCappedCylinderGeom((dReal)param0, (dReal)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-OdeCappedCylinderGeom::OdeCappedCylinderGeom(OdeSpace &space, dReal radius, dReal length)
        PyObject *param0;
        float param1;
        float param2;
        if (PyArg_ParseTuple(args, "Off:OdeCappedCylinderGeom", &param0, &param1, &param2)) {
          OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeCappedCylinderGeom.OdeCappedCylinderGeom", false, false);
          if (param0_this != NULL) {
            OdeCappedCylinderGeom *return_value = new OdeCappedCylinderGeom(*param0_this, (dReal)param1, (dReal)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeCappedCylinderGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeCappedCylinderGeom) {
    printf("OdeCappedCylinderGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeCappedCylinderGeom *local_this = (OdeCappedCylinderGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeCappedCylinderGeom) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeGeom) {
    return (OdeGeom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeGeom *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeCappedCylinderGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeCappedCylinderGeom) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeGeom) {
    OdeGeom* other_this = (OdeGeom*)from_this;
    return (OdeCappedCylinderGeom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeCappedCylinderGeom*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeContactGeom
 */
/**
 * Python function wrapper for:
 * inline LVecBase3f OdeContactGeom::get_pos(void) const
 */
static PyObject *Dtool_OdeContactGeom_get_pos_333(PyObject *self, PyObject *) {
  OdeContactGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeContactGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeContactGeom::get_pos(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeContactGeom*)local_this).get_pos());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_get_pos_333_comment =
  "C++ Interface:\n"
  "get_pos(OdeContactGeom self)\n";
#else
static const char *Dtool_OdeContactGeom_get_pos_333_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeContactGeom::get_normal(void) const
 */
static PyObject *Dtool_OdeContactGeom_get_normal_334(PyObject *self, PyObject *) {
  OdeContactGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeContactGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeContactGeom::get_normal(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeContactGeom*)local_this).get_normal());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_get_normal_334_comment =
  "C++ Interface:\n"
  "get_normal(OdeContactGeom self)\n";
#else
static const char *Dtool_OdeContactGeom_get_normal_334_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeContactGeom::get_depth(void) const
 */
static PyObject *Dtool_OdeContactGeom_get_depth_335(PyObject *self, PyObject *) {
  OdeContactGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeContactGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeContactGeom::get_depth(void) const
  dReal return_value = (*(const OdeContactGeom*)local_this).get_depth();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_get_depth_335_comment =
  "C++ Interface:\n"
  "get_depth(OdeContactGeom self)\n";
#else
static const char *Dtool_OdeContactGeom_get_depth_335_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeGeom OdeContactGeom::get_g1(void) const
 */
static PyObject *Dtool_OdeContactGeom_get_g1_336(PyObject *self, PyObject *) {
  OdeContactGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeContactGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline OdeGeom OdeContactGeom::get_g1(void) const
  OdeGeom *return_value = new OdeGeom((*(const OdeContactGeom*)local_this).get_g1());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_get_g1_336_comment =
  "C++ Interface:\n"
  "get_g1(OdeContactGeom self)\n";
#else
static const char *Dtool_OdeContactGeom_get_g1_336_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeGeom OdeContactGeom::get_g2(void) const
 */
static PyObject *Dtool_OdeContactGeom_get_g2_337(PyObject *self, PyObject *) {
  OdeContactGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeContactGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline OdeGeom OdeContactGeom::get_g2(void) const
  OdeGeom *return_value = new OdeGeom((*(const OdeContactGeom*)local_this).get_g2());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_get_g2_337_comment =
  "C++ Interface:\n"
  "get_g2(OdeContactGeom self)\n";
#else
static const char *Dtool_OdeContactGeom_get_g2_337_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeContactGeom::get_side1(void) const
 */
static PyObject *Dtool_OdeContactGeom_get_side1_338(PyObject *self, PyObject *) {
  OdeContactGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeContactGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeContactGeom::get_side1(void) const
  int return_value = (*(const OdeContactGeom*)local_this).get_side1();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_get_side1_338_comment =
  "C++ Interface:\n"
  "get_side1(OdeContactGeom self)\n";
#else
static const char *Dtool_OdeContactGeom_get_side1_338_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeContactGeom::get_side2(void) const
 */
static PyObject *Dtool_OdeContactGeom_get_side2_339(PyObject *self, PyObject *) {
  OdeContactGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeContactGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeContactGeom::get_side2(void) const
  int return_value = (*(const OdeContactGeom*)local_this).get_side2();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_get_side2_339_comment =
  "C++ Interface:\n"
  "get_side2(OdeContactGeom self)\n";
#else
static const char *Dtool_OdeContactGeom_get_side2_339_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeContactGeom::set_pos(LVecBase3f const &pos)
 */
static PyObject *Dtool_OdeContactGeom_set_pos_340(PyObject *self, PyObject *arg) {
  OdeContactGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeContactGeom, (void **)&local_this, "OdeContactGeom.set_pos")) {
    return NULL;
  }
  // 1-inline void OdeContactGeom::set_pos(LVecBase3f const &pos)
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeContactGeom.set_pos", "LVecBase3f");
  }
  (*local_this).set_pos(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos(const OdeContactGeom self, const LVecBase3f pos)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_set_pos_340_comment =
  "C++ Interface:\n"
  "set_pos(const OdeContactGeom self, const LVecBase3f pos)\n";
#else
static const char *Dtool_OdeContactGeom_set_pos_340_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeContactGeom::set_normal(LVecBase3f const &normal)
 */
static PyObject *Dtool_OdeContactGeom_set_normal_341(PyObject *self, PyObject *arg) {
  OdeContactGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeContactGeom, (void **)&local_this, "OdeContactGeom.set_normal")) {
    return NULL;
  }
  // 1-inline void OdeContactGeom::set_normal(LVecBase3f const &normal)
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeContactGeom.set_normal", "LVecBase3f");
  }
  (*local_this).set_normal(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_normal(const OdeContactGeom self, const LVecBase3f normal)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_set_normal_341_comment =
  "C++ Interface:\n"
  "set_normal(const OdeContactGeom self, const LVecBase3f normal)\n";
#else
static const char *Dtool_OdeContactGeom_set_normal_341_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeContactGeom::set_depth(dReal const depth)
 */
static PyObject *Dtool_OdeContactGeom_set_depth_342(PyObject *self, PyObject *arg) {
  OdeContactGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeContactGeom, (void **)&local_this, "OdeContactGeom.set_depth")) {
    return NULL;
  }
  // 1-inline void OdeContactGeom::set_depth(dReal const depth)
  if (PyNumber_Check(arg)) {
    (*local_this).set_depth((dReal const)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_depth(const OdeContactGeom self, float depth)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_set_depth_342_comment =
  "C++ Interface:\n"
  "set_depth(const OdeContactGeom self, float depth)\n";
#else
static const char *Dtool_OdeContactGeom_set_depth_342_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeContactGeom::set_g1(OdeGeom const &geom)
 */
static PyObject *Dtool_OdeContactGeom_set_g1_343(PyObject *self, PyObject *arg) {
  OdeContactGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeContactGeom, (void **)&local_this, "OdeContactGeom.set_g1")) {
    return NULL;
  }
  // 1-inline void OdeContactGeom::set_g1(OdeGeom const &geom)
  OdeGeom const *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 1, "OdeContactGeom.set_g1", true, true);
  if (arg_this != NULL) {
    (*local_this).set_g1(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_g1(const OdeContactGeom self, const OdeGeom geom)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_set_g1_343_comment =
  "C++ Interface:\n"
  "set_g1(const OdeContactGeom self, const OdeGeom geom)\n";
#else
static const char *Dtool_OdeContactGeom_set_g1_343_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeContactGeom::set_g2(OdeGeom const &geom)
 */
static PyObject *Dtool_OdeContactGeom_set_g2_344(PyObject *self, PyObject *arg) {
  OdeContactGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeContactGeom, (void **)&local_this, "OdeContactGeom.set_g2")) {
    return NULL;
  }
  // 1-inline void OdeContactGeom::set_g2(OdeGeom const &geom)
  OdeGeom const *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 1, "OdeContactGeom.set_g2", true, true);
  if (arg_this != NULL) {
    (*local_this).set_g2(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_g2(const OdeContactGeom self, const OdeGeom geom)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_set_g2_344_comment =
  "C++ Interface:\n"
  "set_g2(const OdeContactGeom self, const OdeGeom geom)\n";
#else
static const char *Dtool_OdeContactGeom_set_g2_344_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeContactGeom::get_class_type(void)
 */
static PyObject *Dtool_OdeContactGeom_get_class_type_345(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeContactGeom::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeContactGeom::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_get_class_type_345_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeContactGeom_get_class_type_345_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeContactGeom::OdeContactGeom(void)
 * OdeContactGeom::OdeContactGeom(OdeContactGeom const &copy)
 */
static int Dtool_Init_OdeContactGeom(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-OdeContactGeom::OdeContactGeom(void)
      OdeContactGeom *return_value = new OdeContactGeom();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeContactGeom, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-OdeContactGeom::OdeContactGeom(OdeContactGeom const &copy)
      OdeContactGeom const *arg_this = (OdeContactGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeContactGeom, 0, "OdeContactGeom.OdeContactGeom", true, true);
      if (arg_this != NULL) {
        OdeContactGeom *return_value = new OdeContactGeom(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeContactGeom, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeContactGeom() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeContactGeom()\n"
      "OdeContactGeom(const OdeContactGeom copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeContactGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeContactGeom) {
    printf("OdeContactGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeContactGeom *local_this = (OdeContactGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeContactGeom) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeContactGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeContactGeom) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (OdeContactGeom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeContactGeom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (OdeContactGeom*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeCollisionEntry
 */
/**
 * Python function wrapper for:
 * inline OdeGeom OdeCollisionEntry::get_geom1(void) const
 */
static PyObject *Dtool_OdeCollisionEntry_get_geom1_347(PyObject *self, PyObject *) {
  OdeCollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline OdeGeom OdeCollisionEntry::get_geom1(void) const
  OdeGeom *return_value = new OdeGeom((*(const OdeCollisionEntry*)local_this).get_geom1());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeCollisionEntry_get_geom1_347_comment =
  "C++ Interface:\n"
  "get_geom1(OdeCollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the first geom in the collision.\n"
  " */";
#else
static const char *Dtool_OdeCollisionEntry_get_geom1_347_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeGeom OdeCollisionEntry::get_geom2(void) const
 */
static PyObject *Dtool_OdeCollisionEntry_get_geom2_348(PyObject *self, PyObject *) {
  OdeCollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline OdeGeom OdeCollisionEntry::get_geom2(void) const
  OdeGeom *return_value = new OdeGeom((*(const OdeCollisionEntry*)local_this).get_geom2());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeCollisionEntry_get_geom2_348_comment =
  "C++ Interface:\n"
  "get_geom2(OdeCollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the second geom in the collision.\n"
  " */";
#else
static const char *Dtool_OdeCollisionEntry_get_geom2_348_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeBody OdeCollisionEntry::get_body1(void) const
 */
static PyObject *Dtool_OdeCollisionEntry_get_body1_349(PyObject *self, PyObject *) {
  OdeCollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline OdeBody OdeCollisionEntry::get_body1(void) const
  OdeBody *return_value = new OdeBody((*(const OdeCollisionEntry*)local_this).get_body1());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeBody, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeCollisionEntry_get_body1_349_comment =
  "C++ Interface:\n"
  "get_body1(OdeCollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the first body in the collision.\n"
  " */";
#else
static const char *Dtool_OdeCollisionEntry_get_body1_349_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeBody OdeCollisionEntry::get_body2(void) const
 */
static PyObject *Dtool_OdeCollisionEntry_get_body2_350(PyObject *self, PyObject *) {
  OdeCollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline OdeBody OdeCollisionEntry::get_body2(void) const
  OdeBody *return_value = new OdeBody((*(const OdeCollisionEntry*)local_this).get_body2());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeBody, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeCollisionEntry_get_body2_350_comment =
  "C++ Interface:\n"
  "get_body2(OdeCollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the second body in the collision.\n"
  " */";
#else
static const char *Dtool_OdeCollisionEntry_get_body2_350_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t OdeCollisionEntry::get_num_contacts(void) const
 */
static PyObject *Dtool_OdeCollisionEntry_get_num_contacts_351(PyObject *self, PyObject *) {
  OdeCollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t OdeCollisionEntry::get_num_contacts(void) const
  std::size_t return_value = (*(const OdeCollisionEntry*)local_this).get_num_contacts();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeCollisionEntry_get_num_contacts_351_comment =
  "C++ Interface:\n"
  "get_num_contacts(OdeCollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the number of contacts in the collision.\n"
  " */";
#else
static const char *Dtool_OdeCollisionEntry_get_num_contacts_351_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f OdeCollisionEntry::get_contact_point(std::size_t n) const
 */
static PyObject *Dtool_OdeCollisionEntry_get_contact_point_352(PyObject *self, PyObject *arg) {
  OdeCollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3f OdeCollisionEntry::get_contact_point(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_contact_point", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    LPoint3f *return_value = new LPoint3f((*(const OdeCollisionEntry*)local_this).get_contact_point((std::size_t)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_contact_point(OdeCollisionEntry self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeCollisionEntry_get_contact_point_352_comment =
  "C++ Interface:\n"
  "get_contact_point(OdeCollisionEntry self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth contact point in the collision.  This does exactly the same\n"
  " * as get_contact_geom(n).get_pos().\n"
  " */";
#else
static const char *Dtool_OdeCollisionEntry_get_contact_point_352_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeContactGeom OdeCollisionEntry::get_contact_geom(std::size_t n) const
 */
static PyObject *Dtool_OdeCollisionEntry_get_contact_geom_353(PyObject *self, PyObject *arg) {
  OdeCollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline OdeContactGeom OdeCollisionEntry::get_contact_geom(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_contact_geom", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    OdeContactGeom *return_value = new OdeContactGeom((*(const OdeCollisionEntry*)local_this).get_contact_geom((std::size_t)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (return_value != (OdeContactGeom *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (OdeContactGeom *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeContactGeom, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_contact_geom(OdeCollisionEntry self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeCollisionEntry_get_contact_geom_353_comment =
  "C++ Interface:\n"
  "get_contact_geom(OdeCollisionEntry self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth contact geom in the collision.\n"
  " */";
#else
static const char *Dtool_OdeCollisionEntry_get_contact_geom_353_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool OdeCollisionEntry::is_empty(void) const
 */
static PyObject *Dtool_OdeCollisionEntry_is_empty_358(PyObject *self, PyObject *) {
  OdeCollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool OdeCollisionEntry::is_empty(void) const
  bool return_value = (*(const OdeCollisionEntry*)local_this).is_empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeCollisionEntry_is_empty_358_comment =
  "C++ Interface:\n"
  "is_empty(OdeCollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns true if the entry holds no contacts.\n"
  " */";
#else
static const char *Dtool_OdeCollisionEntry_is_empty_358_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeCollisionEntry::get_class_type(void)
 */
static PyObject *Dtool_OdeCollisionEntry_get_class_type_359(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeCollisionEntry::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeCollisionEntry::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeCollisionEntry_get_class_type_359_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeCollisionEntry_get_class_type_359_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeCollisionEntry::OdeCollisionEntry(OdeCollisionEntry const &) = default
 */
static int Dtool_Init_OdeCollisionEntry(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "OdeCollisionEntry() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline OdeCollisionEntry::OdeCollisionEntry(OdeCollisionEntry const &) = default
  OdeCollisionEntry const *arg_this = (OdeCollisionEntry *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeCollisionEntry, 0, "OdeCollisionEntry.OdeCollisionEntry", true, true);
  if (arg_this != NULL) {
    OdeCollisionEntry *return_value = new OdeCollisionEntry(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeCollisionEntry, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeCollisionEntry(const OdeCollisionEntry param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_OdeCollisionEntry_get_contact_points(PyObject *self, PyObject *) {
  OdeCollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_contacts();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_OdeCollisionEntry_get_contact_point_352(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_OdeCollisionEntry_get_contact_geoms(PyObject *self, PyObject *) {
  OdeCollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_contacts();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_OdeCollisionEntry_get_contact_geom_353(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_OdeCollisionEntry(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeCollisionEntry) {
    printf("OdeCollisionEntry ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeCollisionEntry *local_this = (OdeCollisionEntry *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeCollisionEntry) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeCollisionEntry(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeCollisionEntry) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (OdeCollisionEntry*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeCollisionEntry*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (OdeCollisionEntry*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeSurfaceParameters
 */
/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_mode(int mode)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_mode_364(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_mode")) {
    return NULL;
  }
  // 1-inline void OdeSurfaceParameters::set_mode(int mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_mode((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mode(const OdeSurfaceParameters self, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_mode_364_comment =
  "C++ Interface:\n"
  "set_mode(const OdeSurfaceParameters self, int mode)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_mode_364_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_mu(dReal mu)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_mu_365(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_mu")) {
    return NULL;
  }
  // 1-inline void OdeSurfaceParameters::set_mu(dReal mu)
  if (PyNumber_Check(arg)) {
    (*local_this).set_mu((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mu(const OdeSurfaceParameters self, float mu)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_mu_365_comment =
  "C++ Interface:\n"
  "set_mu(const OdeSurfaceParameters self, float mu)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_mu_365_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_mu2(dReal mu2)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_mu2_366(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_mu2")) {
    return NULL;
  }
  // 1-inline void OdeSurfaceParameters::set_mu2(dReal mu2)
  if (PyNumber_Check(arg)) {
    (*local_this).set_mu2((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mu2(const OdeSurfaceParameters self, float mu2)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_mu2_366_comment =
  "C++ Interface:\n"
  "set_mu2(const OdeSurfaceParameters self, float mu2)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_mu2_366_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_bounce(dReal bounce)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_bounce_367(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_bounce")) {
    return NULL;
  }
  // 1-inline void OdeSurfaceParameters::set_bounce(dReal bounce)
  if (PyNumber_Check(arg)) {
    (*local_this).set_bounce((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bounce(const OdeSurfaceParameters self, float bounce)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_bounce_367_comment =
  "C++ Interface:\n"
  "set_bounce(const OdeSurfaceParameters self, float bounce)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_bounce_367_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_bounce_vel(dReal bounce_vel)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_bounce_vel_368(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_bounce_vel")) {
    return NULL;
  }
  // 1-inline void OdeSurfaceParameters::set_bounce_vel(dReal bounce_vel)
  if (PyNumber_Check(arg)) {
    (*local_this).set_bounce_vel((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bounce_vel(const OdeSurfaceParameters self, float bounce_vel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_bounce_vel_368_comment =
  "C++ Interface:\n"
  "set_bounce_vel(const OdeSurfaceParameters self, float bounce_vel)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_bounce_vel_368_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_soft_erp(dReal soft_erp)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_soft_erp_369(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_soft_erp")) {
    return NULL;
  }
  // 1-inline void OdeSurfaceParameters::set_soft_erp(dReal soft_erp)
  if (PyNumber_Check(arg)) {
    (*local_this).set_soft_erp((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_soft_erp(const OdeSurfaceParameters self, float soft_erp)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_soft_erp_369_comment =
  "C++ Interface:\n"
  "set_soft_erp(const OdeSurfaceParameters self, float soft_erp)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_soft_erp_369_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_soft_cfm(dReal soft_cfm)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_soft_cfm_370(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_soft_cfm")) {
    return NULL;
  }
  // 1-inline void OdeSurfaceParameters::set_soft_cfm(dReal soft_cfm)
  if (PyNumber_Check(arg)) {
    (*local_this).set_soft_cfm((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_soft_cfm(const OdeSurfaceParameters self, float soft_cfm)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_soft_cfm_370_comment =
  "C++ Interface:\n"
  "set_soft_cfm(const OdeSurfaceParameters self, float soft_cfm)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_soft_cfm_370_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_motion1(dReal motion)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_motion1_371(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_motion1")) {
    return NULL;
  }
  // 1-inline void OdeSurfaceParameters::set_motion1(dReal motion)
  if (PyNumber_Check(arg)) {
    (*local_this).set_motion1((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_motion1(const OdeSurfaceParameters self, float motion)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_motion1_371_comment =
  "C++ Interface:\n"
  "set_motion1(const OdeSurfaceParameters self, float motion)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_motion1_371_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_motion2(dReal motion)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_motion2_372(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_motion2")) {
    return NULL;
  }
  // 1-inline void OdeSurfaceParameters::set_motion2(dReal motion)
  if (PyNumber_Check(arg)) {
    (*local_this).set_motion2((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_motion2(const OdeSurfaceParameters self, float motion)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_motion2_372_comment =
  "C++ Interface:\n"
  "set_motion2(const OdeSurfaceParameters self, float motion)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_motion2_372_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_slip1(dReal slip)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_slip1_373(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_slip1")) {
    return NULL;
  }
  // 1-inline void OdeSurfaceParameters::set_slip1(dReal slip)
  if (PyNumber_Check(arg)) {
    (*local_this).set_slip1((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_slip1(const OdeSurfaceParameters self, float slip)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_slip1_373_comment =
  "C++ Interface:\n"
  "set_slip1(const OdeSurfaceParameters self, float slip)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_slip1_373_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_slip2(dReal slip)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_slip2_374(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_slip2")) {
    return NULL;
  }
  // 1-inline void OdeSurfaceParameters::set_slip2(dReal slip)
  if (PyNumber_Check(arg)) {
    (*local_this).set_slip2((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_slip2(const OdeSurfaceParameters self, float slip)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_slip2_374_comment =
  "C++ Interface:\n"
  "set_slip2(const OdeSurfaceParameters self, float slip)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_slip2_374_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeSurfaceParameters::get_mode(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_mode_375(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSurfaceParameters, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeSurfaceParameters::get_mode(void) const
  int return_value = (*(const OdeSurfaceParameters*)local_this).get_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_mode_375_comment =
  "C++ Interface:\n"
  "get_mode(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_mode_375_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_mu(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_mu_376(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSurfaceParameters, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSurfaceParameters::get_mu(void) const
  dReal return_value = (*(const OdeSurfaceParameters*)local_this).get_mu();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_mu_376_comment =
  "C++ Interface:\n"
  "get_mu(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_mu_376_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_mu2(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_mu2_377(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSurfaceParameters, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSurfaceParameters::get_mu2(void) const
  dReal return_value = (*(const OdeSurfaceParameters*)local_this).get_mu2();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_mu2_377_comment =
  "C++ Interface:\n"
  "get_mu2(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_mu2_377_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_bounce(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_bounce_378(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSurfaceParameters, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSurfaceParameters::get_bounce(void) const
  dReal return_value = (*(const OdeSurfaceParameters*)local_this).get_bounce();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_bounce_378_comment =
  "C++ Interface:\n"
  "get_bounce(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_bounce_378_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_bounce_vel(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_bounce_vel_379(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSurfaceParameters, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSurfaceParameters::get_bounce_vel(void) const
  dReal return_value = (*(const OdeSurfaceParameters*)local_this).get_bounce_vel();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_bounce_vel_379_comment =
  "C++ Interface:\n"
  "get_bounce_vel(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_bounce_vel_379_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_soft_erp(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_soft_erp_380(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSurfaceParameters, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSurfaceParameters::get_soft_erp(void) const
  dReal return_value = (*(const OdeSurfaceParameters*)local_this).get_soft_erp();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_soft_erp_380_comment =
  "C++ Interface:\n"
  "get_soft_erp(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_soft_erp_380_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_soft_cfm(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_soft_cfm_381(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSurfaceParameters, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSurfaceParameters::get_soft_cfm(void) const
  dReal return_value = (*(const OdeSurfaceParameters*)local_this).get_soft_cfm();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_soft_cfm_381_comment =
  "C++ Interface:\n"
  "get_soft_cfm(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_soft_cfm_381_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_motion1(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_motion1_382(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSurfaceParameters, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSurfaceParameters::get_motion1(void) const
  dReal return_value = (*(const OdeSurfaceParameters*)local_this).get_motion1();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_motion1_382_comment =
  "C++ Interface:\n"
  "get_motion1(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_motion1_382_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_motion2(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_motion2_383(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSurfaceParameters, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSurfaceParameters::get_motion2(void) const
  dReal return_value = (*(const OdeSurfaceParameters*)local_this).get_motion2();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_motion2_383_comment =
  "C++ Interface:\n"
  "get_motion2(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_motion2_383_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_slip1(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_slip1_384(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSurfaceParameters, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSurfaceParameters::get_slip1(void) const
  dReal return_value = (*(const OdeSurfaceParameters*)local_this).get_slip1();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_slip1_384_comment =
  "C++ Interface:\n"
  "get_slip1(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_slip1_384_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_slip2(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_slip2_385(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSurfaceParameters, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSurfaceParameters::get_slip2(void) const
  dReal return_value = (*(const OdeSurfaceParameters*)local_this).get_slip2();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_slip2_385_comment =
  "C++ Interface:\n"
  "get_slip2(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_slip2_385_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeSurfaceParameters::get_class_type(void)
 */
static PyObject *Dtool_OdeSurfaceParameters_get_class_type_386(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeSurfaceParameters::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeSurfaceParameters::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_class_type_386_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_class_type_386_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeSurfaceParameters::OdeSurfaceParameters(int mode = 0, dReal mu = 0)
 */
static int Dtool_Init_OdeSurfaceParameters(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-OdeSurfaceParameters::OdeSurfaceParameters(int mode = 0, dReal mu = 0)
  int param0 = 0;
  float param1 = 0;
  static const char *keyword_list[] = {"mode", "mu", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|if:OdeSurfaceParameters", (char **)keyword_list, &param0, &param1)) {
    OdeSurfaceParameters *return_value = new OdeSurfaceParameters((int)param0, (dReal)param1);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSurfaceParameters, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeSurfaceParameters(int mode, float mu)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeSurfaceParameters(PyObject *args, OdeSurfaceParameters const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeSurfaceParameters, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeSurfaceParameters::OdeSurfaceParameters(int mode, dReal mu)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      OdeSurfaceParameters *return_value = new OdeSurfaceParameters((int)arg_val);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeSurfaceParameters::OdeSurfaceParameters(int mode, dReal mu)
      int param0;
      float param1;
      if (PyArg_ParseTuple(args, "if:OdeSurfaceParameters", &param0, &param1)) {
        OdeSurfaceParameters *return_value = new OdeSurfaceParameters((int)param0, (dReal)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OdeSurfaceParameters(PyObject *args, OdeSurfaceParameters *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeSurfaceParameters, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeSurfaceParameters::OdeSurfaceParameters(int mode, dReal mu)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      OdeSurfaceParameters *return_value = new OdeSurfaceParameters((int)arg_val);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeSurfaceParameters::OdeSurfaceParameters(int mode, dReal mu)
      int param0;
      float param1;
      if (PyArg_ParseTuple(args, "if:OdeSurfaceParameters", &param0, &param1)) {
        OdeSurfaceParameters *return_value = new OdeSurfaceParameters((int)param0, (dReal)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeSurfaceParameters(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeSurfaceParameters) {
    printf("OdeSurfaceParameters ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeSurfaceParameters *local_this = (OdeSurfaceParameters *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeSurfaceParameters) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeSurfaceParameters(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeSurfaceParameters) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeSurfaceParameters*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeContact
 */
/**
 * Python function wrapper for:
 * inline OdeSurfaceParameters OdeContact::get_surface(void) const
 */
static PyObject *Dtool_OdeContact_get_surface_389(PyObject *self, PyObject *) {
  OdeContact *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeContact, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline OdeSurfaceParameters OdeContact::get_surface(void) const
  OdeSurfaceParameters *return_value = new OdeSurfaceParameters((*(const OdeContact*)local_this).get_surface());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeSurfaceParameters, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeContact_get_surface_389_comment =
  "C++ Interface:\n"
  "get_surface(OdeContact self)\n";
#else
static const char *Dtool_OdeContact_get_surface_389_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeContactGeom OdeContact::get_geom(void)
 */
static PyObject *Dtool_OdeContact_get_geom_390(PyObject *self, PyObject *) {
  OdeContact *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeContact, (void **)&local_this, "OdeContact.get_geom")) {
    return NULL;
  }
  // 1-inline OdeContactGeom OdeContact::get_geom(void)
  OdeContactGeom *return_value = new OdeContactGeom((*local_this).get_geom());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (return_value != (OdeContactGeom *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (OdeContactGeom *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeContactGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeContact_get_geom_390_comment =
  "C++ Interface:\n"
  "get_geom(const OdeContact self)\n";
#else
static const char *Dtool_OdeContact_get_geom_390_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeContact::get_fdir1(void) const
 */
static PyObject *Dtool_OdeContact_get_fdir1_391(PyObject *self, PyObject *) {
  OdeContact *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeContact, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeContact::get_fdir1(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeContact*)local_this).get_fdir1());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeContact_get_fdir1_391_comment =
  "C++ Interface:\n"
  "get_fdir1(OdeContact self)\n";
#else
static const char *Dtool_OdeContact_get_fdir1_391_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeContact::set_surface(OdeSurfaceParameters const &surface_parameters)
 */
static PyObject *Dtool_OdeContact_set_surface_392(PyObject *self, PyObject *arg) {
  OdeContact *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeContact, (void **)&local_this, "OdeContact.set_surface")) {
    return NULL;
  }
  // 1-inline void OdeContact::set_surface(OdeSurfaceParameters const &surface_parameters)
  OdeSurfaceParameters const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_OdeSurfaceParameters(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeContact.set_surface", "OdeSurfaceParameters");
  }
  (*local_this).set_surface(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_surface(const OdeContact self, const OdeSurfaceParameters surface_parameters)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeContact_set_surface_392_comment =
  "C++ Interface:\n"
  "set_surface(const OdeContact self, const OdeSurfaceParameters surface_parameters)\n";
#else
static const char *Dtool_OdeContact_set_surface_392_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeContact::set_geom(OdeContactGeom const &contact_geom)
 */
static PyObject *Dtool_OdeContact_set_geom_393(PyObject *self, PyObject *arg) {
  OdeContact *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeContact, (void **)&local_this, "OdeContact.set_geom")) {
    return NULL;
  }
  // 1-inline void OdeContact::set_geom(OdeContactGeom const &contact_geom)
  OdeContactGeom const *arg_this = (OdeContactGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeContactGeom, 1, "OdeContact.set_geom", true, true);
  if (arg_this != NULL) {
    (*local_this).set_geom(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_geom(const OdeContact self, const OdeContactGeom contact_geom)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeContact_set_geom_393_comment =
  "C++ Interface:\n"
  "set_geom(const OdeContact self, const OdeContactGeom contact_geom)\n";
#else
static const char *Dtool_OdeContact_set_geom_393_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeContact::set_fdir1(LVecBase3f const &fdir1)
 */
static PyObject *Dtool_OdeContact_set_fdir1_394(PyObject *self, PyObject *arg) {
  OdeContact *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeContact, (void **)&local_this, "OdeContact.set_fdir1")) {
    return NULL;
  }
  // 1-inline void OdeContact::set_fdir1(LVecBase3f const &fdir1)
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeContact.set_fdir1", "LVecBase3f");
  }
  (*local_this).set_fdir1(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fdir1(const OdeContact self, const LVecBase3f fdir1)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeContact_set_fdir1_394_comment =
  "C++ Interface:\n"
  "set_fdir1(const OdeContact self, const LVecBase3f fdir1)\n";
#else
static const char *Dtool_OdeContact_set_fdir1_394_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeContact::get_class_type(void)
 */
static PyObject *Dtool_OdeContact_get_class_type_395(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeContact::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeContact::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeContact_get_class_type_395_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeContact_get_class_type_395_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeContact::OdeContact(void)
 * Rejected Remap [OdeContact::OdeContact(dContact const &contact)]
 */
static int Dtool_Init_OdeContact(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "OdeContact() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-OdeContact::OdeContact(void)
  OdeContact *return_value = new OdeContact();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeContact, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeContact()\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeContact(PyObject *args, CPT(OdeContact) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeContact, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_OdeContact(PyObject *args, PT(OdeContact) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeContact, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeContact(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeContact) {
    printf("OdeContact ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeContact *local_this = (OdeContact *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeContact) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeContact(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeContact) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (OdeContact*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeContact*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (OdeContact*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeContactJoint
 */
/**
 * Python function wrapper for:
 * static TypeHandle OdeContactJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeContactJoint_get_class_type_398(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeContactJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeContactJoint::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeContactJoint_get_class_type_398_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeContactJoint_get_class_type_398_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeContactJoint::OdeContactJoint(OdeContactJoint const &) = default
 * OdeContactJoint::OdeContactJoint(OdeWorld &world, OdeContact const &contact)
 * OdeContactJoint::OdeContactJoint(OdeWorld &world, OdeJointGroup &joint_group, OdeContact const &contact)
 */
static int Dtool_Init_OdeContactJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline OdeContactJoint::OdeContactJoint(OdeContactJoint const &) = default
      OdeContactJoint const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_OdeContactJoint(arg, arg_this, arg_manage)) {
        Dtool_Raise_ArgTypeError(arg, 0, "OdeContactJoint.OdeContactJoint", "OdeContactJoint");
        return -1;
      }
      OdeContactJoint *return_value = new OdeContactJoint(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeContactJoint, true, false);
    }
    break;
  case 2:
    {
      // 1-OdeContactJoint::OdeContactJoint(OdeWorld &world, OdeContact const &contact)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "contact", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeContactJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeContactJoint.OdeContactJoint", false, true);
        CPT(OdeContact) param1_this;
        if (!Dtool_ConstCoerce_OdeContact(param1, param1_this)) {
          Dtool_Raise_ArgTypeError(param1, 1, "OdeContactJoint.OdeContactJoint", "OdeContact");
          return -1;
        }
        if (param0_this != NULL) {
          OdeContactJoint *return_value = new OdeContactJoint(*param0_this, *MOVE(param1_this));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeContactJoint, true, false);
        }
      }
    }
    break;
  case 3:
    {
      // 1-OdeContactJoint::OdeContactJoint(OdeWorld &world, OdeJointGroup &joint_group, OdeContact const &contact)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"world", "joint_group", "contact", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:OdeContactJoint", (char **)keyword_list, &param0, &param1, &param2)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeContactJoint.OdeContactJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeContactJoint.OdeContactJoint", false, true);
        CPT(OdeContact) param2_this;
        if (!Dtool_ConstCoerce_OdeContact(param2, param2_this)) {
          Dtool_Raise_ArgTypeError(param2, 2, "OdeContactJoint.OdeContactJoint", "OdeContact");
          return -1;
        }
        if (param0_this != NULL && param1_this != NULL) {
          OdeContactJoint *return_value = new OdeContactJoint(*param0_this, *param1_this, *MOVE(param2_this));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeContactJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeContactJoint() takes 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeContactJoint(const OdeContactJoint param0)\n"
      "OdeContactJoint(OdeWorld world, const OdeContact contact)\n"
      "OdeContactJoint(OdeWorld world, OdeJointGroup joint_group, const OdeContact contact)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeContactJoint(PyObject *args, OdeContactJoint const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeContactJoint, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-OdeContactJoint::OdeContactJoint(OdeWorld &world, OdeContact const &contact)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "OdeContactJoint", 2, 2, &param0, &param1)) {
          OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeContactJoint.OdeContactJoint", false, false);
          OdeContact const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_OdeContact, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            OdeContactJoint *return_value = new OdeContactJoint(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-OdeContactJoint::OdeContactJoint(OdeWorld &world, OdeJointGroup &joint_group, OdeContact const &contact)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        if (PyArg_UnpackTuple(args, "OdeContactJoint", 3, 3, &param0, &param1, &param2)) {
          OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeContactJoint.OdeContactJoint", false, false);
          OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeContactJoint.OdeContactJoint", false, false);
          OdeContact const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_OdeContact, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            OdeContactJoint *return_value = new OdeContactJoint(*param0_this, *param1_this, *param2_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_OdeContactJoint(PyObject *args, OdeContactJoint *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeContactJoint, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-OdeContactJoint::OdeContactJoint(OdeWorld &world, OdeContact const &contact)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "OdeContactJoint", 2, 2, &param0, &param1)) {
          OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeContactJoint.OdeContactJoint", false, false);
          OdeContact const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_OdeContact, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            OdeContactJoint *return_value = new OdeContactJoint(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-OdeContactJoint::OdeContactJoint(OdeWorld &world, OdeJointGroup &joint_group, OdeContact const &contact)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        if (PyArg_UnpackTuple(args, "OdeContactJoint", 3, 3, &param0, &param1, &param2)) {
          OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeContactJoint.OdeContactJoint", false, false);
          OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeContactJoint.OdeContactJoint", false, false);
          OdeContact const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_OdeContact, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            OdeContactJoint *return_value = new OdeContactJoint(*param0_this, *param1_this, *param2_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeContactJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeContactJoint) {
    printf("OdeContactJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeContactJoint *local_this = (OdeContactJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeContactJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeContactJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeContactJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeContactJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeContactJoint*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeCylinderGeom
 */
/**
 * Python function wrapper for:
 * inline void OdeCylinderGeom::set_params(dReal radius, dReal length)
 */
static PyObject *Dtool_OdeCylinderGeom_set_params_401(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeCylinderGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeCylinderGeom, (void **)&local_this, "OdeCylinderGeom.set_params")) {
    return NULL;
  }
  // 1-inline void OdeCylinderGeom::set_params(dReal radius, dReal length)
  float param1;
  float param2;
  static const char *keyword_list[] = {"radius", "length", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_params", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_params((dReal)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_params(const OdeCylinderGeom self, float radius, float length)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeCylinderGeom_set_params_401_comment =
  "C++ Interface:\n"
  "set_params(const OdeCylinderGeom self, float radius, float length)\n";
#else
static const char *Dtool_OdeCylinderGeom_set_params_401_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeCylinderGeom::get_radius(void) const
 */
static PyObject *Dtool_OdeCylinderGeom_get_radius_403(PyObject *self, PyObject *) {
  OdeCylinderGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCylinderGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeCylinderGeom::get_radius(void) const
  dReal return_value = (*(const OdeCylinderGeom*)local_this).get_radius();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeCylinderGeom_get_radius_403_comment =
  "C++ Interface:\n"
  "get_radius(OdeCylinderGeom self)\n";
#else
static const char *Dtool_OdeCylinderGeom_get_radius_403_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeCylinderGeom::get_length(void) const
 */
static PyObject *Dtool_OdeCylinderGeom_get_length_404(PyObject *self, PyObject *) {
  OdeCylinderGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCylinderGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeCylinderGeom::get_length(void) const
  dReal return_value = (*(const OdeCylinderGeom*)local_this).get_length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeCylinderGeom_get_length_404_comment =
  "C++ Interface:\n"
  "get_length(OdeCylinderGeom self)\n";
#else
static const char *Dtool_OdeCylinderGeom_get_length_404_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeCylinderGeom::get_class_type(void)
 */
static PyObject *Dtool_OdeCylinderGeom_get_class_type_405(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeCylinderGeom::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeCylinderGeom::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeCylinderGeom_get_class_type_405_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeCylinderGeom_get_class_type_405_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeCylinderGeom::OdeCylinderGeom(OdeCylinderGeom const &) = default
 * OdeCylinderGeom::OdeCylinderGeom(OdeSpace &space, dReal radius, dReal length)
 * OdeCylinderGeom::OdeCylinderGeom(dReal radius, dReal length)
 */
static int Dtool_Init_OdeCylinderGeom(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline OdeCylinderGeom::OdeCylinderGeom(OdeCylinderGeom const &) = default
      OdeCylinderGeom const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_OdeCylinderGeom(arg, arg_this, arg_manage)) {
        Dtool_Raise_ArgTypeError(arg, 0, "OdeCylinderGeom.OdeCylinderGeom", "OdeCylinderGeom");
        return -1;
      }
      OdeCylinderGeom *return_value = new OdeCylinderGeom(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeCylinderGeom, true, false);
    }
    break;
  case 2:
    {
      // 1-OdeCylinderGeom::OdeCylinderGeom(dReal radius, dReal length)
      float param0;
      float param1;
      static const char *keyword_list[] = {"radius", "length", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:OdeCylinderGeom", (char **)keyword_list, &param0, &param1)) {
        OdeCylinderGeom *return_value = new OdeCylinderGeom((dReal)param0, (dReal)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeCylinderGeom, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-OdeCylinderGeom::OdeCylinderGeom(OdeSpace &space, dReal radius, dReal length)
      PyObject *param0;
      float param1;
      float param2;
      static const char *keyword_list[] = {"space", "radius", "length", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:OdeCylinderGeom", (char **)keyword_list, &param0, &param1, &param2)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeCylinderGeom.OdeCylinderGeom", false, true);
        if (param0_this != NULL) {
          OdeCylinderGeom *return_value = new OdeCylinderGeom(*param0_this, (dReal)param1, (dReal)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeCylinderGeom, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeCylinderGeom() takes 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeCylinderGeom(const OdeCylinderGeom param0)\n"
      "OdeCylinderGeom(float radius, float length)\n"
      "OdeCylinderGeom(OdeSpace space, float radius, float length)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeCylinderGeom(PyObject *args, OdeCylinderGeom const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeCylinderGeom, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-OdeCylinderGeom::OdeCylinderGeom(dReal radius, dReal length)
        float param0;
        float param1;
        if (PyArg_ParseTuple(args, "ff:OdeCylinderGeom", &param0, &param1)) {
          OdeCylinderGeom *return_value = new OdeCylinderGeom((dReal)param0, (dReal)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-OdeCylinderGeom::OdeCylinderGeom(OdeSpace &space, dReal radius, dReal length)
        PyObject *param0;
        float param1;
        float param2;
        if (PyArg_ParseTuple(args, "Off:OdeCylinderGeom", &param0, &param1, &param2)) {
          OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeCylinderGeom.OdeCylinderGeom", false, false);
          if (param0_this != NULL) {
            OdeCylinderGeom *return_value = new OdeCylinderGeom(*param0_this, (dReal)param1, (dReal)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_OdeCylinderGeom(PyObject *args, OdeCylinderGeom *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeCylinderGeom, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-OdeCylinderGeom::OdeCylinderGeom(dReal radius, dReal length)
        float param0;
        float param1;
        if (PyArg_ParseTuple(args, "ff:OdeCylinderGeom", &param0, &param1)) {
          OdeCylinderGeom *return_value = new OdeCylinderGeom((dReal)param0, (dReal)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-OdeCylinderGeom::OdeCylinderGeom(OdeSpace &space, dReal radius, dReal length)
        PyObject *param0;
        float param1;
        float param2;
        if (PyArg_ParseTuple(args, "Off:OdeCylinderGeom", &param0, &param1, &param2)) {
          OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeCylinderGeom.OdeCylinderGeom", false, false);
          if (param0_this != NULL) {
            OdeCylinderGeom *return_value = new OdeCylinderGeom(*param0_this, (dReal)param1, (dReal)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeCylinderGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeCylinderGeom) {
    printf("OdeCylinderGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeCylinderGeom *local_this = (OdeCylinderGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeCylinderGeom) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeGeom) {
    return (OdeGeom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeGeom *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeCylinderGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeCylinderGeom) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeGeom) {
    OdeGeom* other_this = (OdeGeom*)from_this;
    return (OdeCylinderGeom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeCylinderGeom*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeFixedJoint
 */
/**
 * Python function wrapper for:
 * inline void OdeFixedJoint::set(void)
 */
static PyObject *Dtool_OdeFixedJoint_set_408(PyObject *self, PyObject *) {
  OdeFixedJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeFixedJoint, (void **)&local_this, "OdeFixedJoint.set")) {
    return NULL;
  }
  // 1-inline void OdeFixedJoint::set(void)
  (*local_this).set();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeFixedJoint_set_408_comment =
  "C++ Interface:\n"
  "set(const OdeFixedJoint self)\n";
#else
static const char *Dtool_OdeFixedJoint_set_408_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeFixedJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeFixedJoint_get_class_type_409(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeFixedJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeFixedJoint::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeFixedJoint_get_class_type_409_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeFixedJoint_get_class_type_409_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeFixedJoint::OdeFixedJoint(OdeFixedJoint const &) = default
 * OdeFixedJoint::OdeFixedJoint(OdeWorld &world)
 * OdeFixedJoint::OdeFixedJoint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdeFixedJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline OdeFixedJoint::OdeFixedJoint(OdeFixedJoint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeFixedJoint", (char **)keyword_list, &param0)) {
          OdeFixedJoint const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_OdeFixedJoint, (void **)&param0_this);
          if (param0_this != NULL) {
            OdeFixedJoint *return_value = new OdeFixedJoint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeFixedJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdeFixedJoint::OdeFixedJoint(OdeWorld &world)
        PyObject *param0;
        static const char *keyword_list[] = {"world", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeFixedJoint", (char **)keyword_list, &param0)) {
          OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeFixedJoint.OdeFixedJoint", false, false);
          if (param0_this != NULL) {
            OdeFixedJoint *return_value = new OdeFixedJoint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeFixedJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline OdeFixedJoint::OdeFixedJoint(OdeFixedJoint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeFixedJoint", (char **)keyword_list, &param0)) {
          OdeFixedJoint const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_OdeFixedJoint(param0, param0_this, param0_manage)) {
            OdeFixedJoint *return_value = new OdeFixedJoint(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeFixedJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: OdeFixedJoint::OdeFixedJoint(OdeWorld &world)
    }
    break;
  case 2:
    {
      // 1-OdeFixedJoint::OdeFixedJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeFixedJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeFixedJoint.OdeFixedJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeFixedJoint.OdeFixedJoint", false, true);
        if (param0_this != NULL && param1_this != NULL) {
          OdeFixedJoint *return_value = new OdeFixedJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeFixedJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeFixedJoint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeFixedJoint(const OdeFixedJoint param0)\n"
      "OdeFixedJoint(OdeWorld world)\n"
      "OdeFixedJoint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeFixedJoint(PyObject *args, OdeFixedJoint const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeFixedJoint, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeFixedJoint::OdeFixedJoint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeFixedJoint.OdeFixedJoint", false, false);
    if (arg_this != NULL) {
      OdeFixedJoint *return_value = new OdeFixedJoint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeFixedJoint::OdeFixedJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeFixedJoint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeFixedJoint.OdeFixedJoint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeFixedJoint.OdeFixedJoint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeFixedJoint *return_value = new OdeFixedJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OdeFixedJoint(PyObject *args, OdeFixedJoint *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeFixedJoint, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeFixedJoint::OdeFixedJoint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeFixedJoint.OdeFixedJoint", false, false);
    if (arg_this != NULL) {
      OdeFixedJoint *return_value = new OdeFixedJoint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeFixedJoint::OdeFixedJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeFixedJoint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeFixedJoint.OdeFixedJoint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeFixedJoint.OdeFixedJoint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeFixedJoint *return_value = new OdeFixedJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeFixedJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeFixedJoint) {
    printf("OdeFixedJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeFixedJoint *local_this = (OdeFixedJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeFixedJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeFixedJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeFixedJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeFixedJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeFixedJoint*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeHashSpace
 */
/**
 * Python function wrapper for:
 * inline void OdeHashSpace::set_levels(int minlevel, int maxlevel)
 */
static PyObject *Dtool_OdeHashSpace_set_levels_412(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHashSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHashSpace, (void **)&local_this, "OdeHashSpace.set_levels")) {
    return NULL;
  }
  // 1-inline void OdeHashSpace::set_levels(int minlevel, int maxlevel)
  int param1;
  int param2;
  static const char *keyword_list[] = {"minlevel", "maxlevel", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_levels", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_levels((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_levels(const OdeHashSpace self, int minlevel, int maxlevel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHashSpace_set_levels_412_comment =
  "C++ Interface:\n"
  "set_levels(const OdeHashSpace self, int minlevel, int maxlevel)\n";
#else
static const char *Dtool_OdeHashSpace_set_levels_412_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeHashSpace::get_min_level(void) const
 */
static PyObject *Dtool_OdeHashSpace_get_min_level_413(PyObject *self, PyObject *) {
  OdeHashSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHashSpace, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeHashSpace::get_min_level(void) const
  int return_value = (*(const OdeHashSpace*)local_this).get_min_level();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHashSpace_get_min_level_413_comment =
  "C++ Interface:\n"
  "get_min_level(OdeHashSpace self)\n";
#else
static const char *Dtool_OdeHashSpace_get_min_level_413_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeHashSpace::get_max_level(void) const
 */
static PyObject *Dtool_OdeHashSpace_get_max_level_414(PyObject *self, PyObject *) {
  OdeHashSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHashSpace, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeHashSpace::get_max_level(void) const
  int return_value = (*(const OdeHashSpace*)local_this).get_max_level();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHashSpace_get_max_level_414_comment =
  "C++ Interface:\n"
  "get_max_level(OdeHashSpace self)\n";
#else
static const char *Dtool_OdeHashSpace_get_max_level_414_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeHashSpace::get_class_type(void)
 */
static PyObject *Dtool_OdeHashSpace_get_class_type_415(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeHashSpace::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeHashSpace::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHashSpace_get_class_type_415_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeHashSpace_get_class_type_415_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeHashSpace::OdeHashSpace(void)
 * inline OdeHashSpace::OdeHashSpace(OdeHashSpace const &) = default
 * OdeHashSpace::OdeHashSpace(OdeSpace &space)
 */
static int Dtool_Init_OdeHashSpace(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-OdeHashSpace::OdeHashSpace(void)
      OdeHashSpace *return_value = new OdeHashSpace();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeHashSpace, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline OdeHashSpace::OdeHashSpace(OdeHashSpace const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeHashSpace", (char **)keyword_list, &param0)) {
          OdeHashSpace const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_OdeHashSpace, (void **)&param0_this);
          if (param0_this != NULL) {
            OdeHashSpace *return_value = new OdeHashSpace(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeHashSpace, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdeHashSpace::OdeHashSpace(OdeSpace &space)
        PyObject *param0;
        static const char *keyword_list[] = {"space", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeHashSpace", (char **)keyword_list, &param0)) {
          OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeHashSpace.OdeHashSpace", false, false);
          if (param0_this != NULL) {
            OdeHashSpace *return_value = new OdeHashSpace(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeHashSpace, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline OdeHashSpace::OdeHashSpace(OdeHashSpace const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeHashSpace", (char **)keyword_list, &param0)) {
          OdeHashSpace const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_OdeHashSpace(param0, param0_this, param0_manage)) {
            OdeHashSpace *return_value = new OdeHashSpace(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeHashSpace, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: OdeHashSpace::OdeHashSpace(OdeSpace &space)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeHashSpace() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeHashSpace()\n"
      "OdeHashSpace(const OdeHashSpace param0)\n"
      "OdeHashSpace(OdeSpace space)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeHashSpace(PyObject *args, OdeHashSpace const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeHashSpace, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeHashSpace::OdeHashSpace(OdeSpace &space)
    OdeSpace *arg_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeSpace, 0, "OdeHashSpace.OdeHashSpace", false, false);
    if (arg_this != NULL) {
      OdeHashSpace *return_value = new OdeHashSpace(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_OdeHashSpace(PyObject *args, OdeHashSpace *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeHashSpace, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeHashSpace::OdeHashSpace(OdeSpace &space)
    OdeSpace *arg_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeSpace, 0, "OdeHashSpace.OdeHashSpace", false, false);
    if (arg_this != NULL) {
      OdeHashSpace *return_value = new OdeHashSpace(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_OdeHashSpace(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeHashSpace) {
    printf("OdeHashSpace ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeHashSpace *local_this = (OdeHashSpace *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeHashSpace) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeSpace) {
    return (OdeSpace *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeSpace *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeHashSpace(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeHashSpace) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeSpace) {
    OdeSpace* other_this = (OdeSpace*)from_this;
    return (OdeHashSpace*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeHashSpace*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeHinge2Joint
 */
/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_anchor(LVecBase3f const &anchor)
 * inline void OdeHinge2Joint::set_anchor(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeHinge2Joint_set_anchor_418(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_anchor")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "anchor");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'anchor' (pos 1) not found");
      }
      // 1-inline void OdeHinge2Joint::set_anchor(LVecBase3f const &anchor)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeHinge2Joint.set_anchor", "LVecBase3f");
      }
      (*local_this).set_anchor(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeHinge2Joint::set_anchor(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_anchor", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_anchor((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_anchor() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anchor(const OdeHinge2Joint self, const LVecBase3f anchor)\n"
      "set_anchor(const OdeHinge2Joint self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_anchor_418_comment =
  "C++ Interface:\n"
  "set_anchor(const OdeHinge2Joint self, const LVecBase3f anchor)\n"
  "set_anchor(const OdeHinge2Joint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_anchor_418_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_axis1(LVecBase3f const &axis)
 * inline void OdeHinge2Joint::set_axis1(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeHinge2Joint_set_axis1_419(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_axis1")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "axis");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'axis' (pos 1) not found");
      }
      // 1-inline void OdeHinge2Joint::set_axis1(LVecBase3f const &axis)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeHinge2Joint.set_axis1", "LVecBase3f");
      }
      (*local_this).set_axis1(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeHinge2Joint::set_axis1(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_axis1", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_axis1((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_axis1() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_axis1(const OdeHinge2Joint self, const LVecBase3f axis)\n"
      "set_axis1(const OdeHinge2Joint self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_axis1_419_comment =
  "C++ Interface:\n"
  "set_axis1(const OdeHinge2Joint self, const LVecBase3f axis)\n"
  "set_axis1(const OdeHinge2Joint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_axis1_419_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_axis2(LVecBase3f const &axis)
 * inline void OdeHinge2Joint::set_axis2(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeHinge2Joint_set_axis2_420(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_axis2")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "axis");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'axis' (pos 1) not found");
      }
      // 1-inline void OdeHinge2Joint::set_axis2(LVecBase3f const &axis)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeHinge2Joint.set_axis2", "LVecBase3f");
      }
      (*local_this).set_axis2(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeHinge2Joint::set_axis2(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_axis2", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_axis2((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_axis2() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_axis2(const OdeHinge2Joint self, const LVecBase3f axis)\n"
      "set_axis2(const OdeHinge2Joint self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_axis2_420_comment =
  "C++ Interface:\n"
  "set_axis2(const OdeHinge2Joint self, const LVecBase3f axis)\n"
  "set_axis2(const OdeHinge2Joint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_axis2_420_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::add_torques(dReal torque1, dReal torque2)
 */
static PyObject *Dtool_OdeHinge2Joint_add_torques_421(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.add_torques")) {
    return NULL;
  }
  // 1-inline void OdeHinge2Joint::add_torques(dReal torque1, dReal torque2)
  float param1;
  float param2;
  static const char *keyword_list[] = {"torque1", "torque2", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:add_torques", (char **)keyword_list, &param1, &param2)) {
    (*local_this).add_torques((dReal)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_torques(const OdeHinge2Joint self, float torque1, float torque2)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_add_torques_421_comment =
  "C++ Interface:\n"
  "add_torques(const OdeHinge2Joint self, float torque1, float torque2)\n";
#else
static const char *Dtool_OdeHinge2Joint_add_torques_421_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeHinge2Joint::get_anchor(void) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_anchor_422(PyObject *self, PyObject *) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHinge2Joint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeHinge2Joint::get_anchor(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeHinge2Joint*)local_this).get_anchor());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_anchor_422_comment =
  "C++ Interface:\n"
  "get_anchor(OdeHinge2Joint self)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_anchor_422_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeHinge2Joint::get_anchor2(void) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_anchor2_423(PyObject *self, PyObject *) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHinge2Joint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeHinge2Joint::get_anchor2(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeHinge2Joint*)local_this).get_anchor2());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_anchor2_423_comment =
  "C++ Interface:\n"
  "get_anchor2(OdeHinge2Joint self)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_anchor2_423_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeHinge2Joint::get_axis1(void) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_axis1_424(PyObject *self, PyObject *) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHinge2Joint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeHinge2Joint::get_axis1(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeHinge2Joint*)local_this).get_axis1());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_axis1_424_comment =
  "C++ Interface:\n"
  "get_axis1(OdeHinge2Joint self)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_axis1_424_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeHinge2Joint::get_axis2(void) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_axis2_425(PyObject *self, PyObject *) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHinge2Joint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeHinge2Joint::get_axis2(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeHinge2Joint*)local_this).get_axis2());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_axis2_425_comment =
  "C++ Interface:\n"
  "get_axis2(OdeHinge2Joint self)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_axis2_425_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_angle1(void) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_angle1_426(PyObject *self, PyObject *) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHinge2Joint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHinge2Joint::get_angle1(void) const
  dReal return_value = (*(const OdeHinge2Joint*)local_this).get_angle1();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_angle1_426_comment =
  "C++ Interface:\n"
  "get_angle1(OdeHinge2Joint self)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_angle1_426_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_angle1_rate(void) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_angle1_rate_427(PyObject *self, PyObject *) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHinge2Joint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHinge2Joint::get_angle1_rate(void) const
  dReal return_value = (*(const OdeHinge2Joint*)local_this).get_angle1_rate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_angle1_rate_427_comment =
  "C++ Interface:\n"
  "get_angle1_rate(OdeHinge2Joint self)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_angle1_rate_427_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_angle2_rate(void) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_angle2_rate_428(PyObject *self, PyObject *) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHinge2Joint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHinge2Joint::get_angle2_rate(void) const
  dReal return_value = (*(const OdeHinge2Joint*)local_this).get_angle2_rate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_angle2_rate_428_comment =
  "C++ Interface:\n"
  "get_angle2_rate(OdeHinge2Joint self)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_angle2_rate_428_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_lo_stop(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_lo_stop_429(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_lo_stop")) {
    return NULL;
  }
  // 1-inline void OdeHinge2Joint::set_param_lo_stop(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_lo_stop", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_lo_stop((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_lo_stop(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_lo_stop_429_comment =
  "C++ Interface:\n"
  "set_param_lo_stop(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_lo_stop_429_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_hi_stop(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_hi_stop_430(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_hi_stop")) {
    return NULL;
  }
  // 1-inline void OdeHinge2Joint::set_param_hi_stop(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_hi_stop", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_hi_stop((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_hi_stop(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_hi_stop_430_comment =
  "C++ Interface:\n"
  "set_param_hi_stop(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_hi_stop_430_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_vel(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_vel_431(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_vel")) {
    return NULL;
  }
  // 1-inline void OdeHinge2Joint::set_param_vel(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_vel", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_vel((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_vel(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_vel_431_comment =
  "C++ Interface:\n"
  "set_param_vel(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_vel_431_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_f_max(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_f_max_432(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_f_max")) {
    return NULL;
  }
  // 1-inline void OdeHinge2Joint::set_param_f_max(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_f_max", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_f_max((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_f_max(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_f_max_432_comment =
  "C++ Interface:\n"
  "set_param_f_max(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_f_max_432_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_fudge_factor(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_fudge_factor_433(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_fudge_factor")) {
    return NULL;
  }
  // 1-inline void OdeHinge2Joint::set_param_fudge_factor(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_fudge_factor", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_fudge_factor((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_fudge_factor(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_fudge_factor_433_comment =
  "C++ Interface:\n"
  "set_param_fudge_factor(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_fudge_factor_433_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_bounce(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_bounce_434(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_bounce")) {
    return NULL;
  }
  // 1-inline void OdeHinge2Joint::set_param_bounce(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_bounce", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_bounce((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_bounce(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_bounce_434_comment =
  "C++ Interface:\n"
  "set_param_bounce(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_bounce_434_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_CFM(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_CFM_435(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_CFM")) {
    return NULL;
  }
  // 1-inline void OdeHinge2Joint::set_param_CFM(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_CFM", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_CFM((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_CFM(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_CFM_435_comment =
  "C++ Interface:\n"
  "set_param_CFM(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_CFM_435_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_stop_ERP(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_stop_ERP_436(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_stop_ERP")) {
    return NULL;
  }
  // 1-inline void OdeHinge2Joint::set_param_stop_ERP(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_stop_ERP", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_stop_ERP((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_ERP(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_stop_ERP_436_comment =
  "C++ Interface:\n"
  "set_param_stop_ERP(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_stop_ERP_436_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_stop_CFM(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_stop_CFM_437(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_stop_CFM")) {
    return NULL;
  }
  // 1-inline void OdeHinge2Joint::set_param_stop_CFM(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_stop_CFM", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_stop_CFM((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_CFM(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_stop_CFM_437_comment =
  "C++ Interface:\n"
  "set_param_stop_CFM(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_stop_CFM_437_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_suspension_ERP(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_suspension_ERP_438(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_suspension_ERP")) {
    return NULL;
  }
  // 1-inline void OdeHinge2Joint::set_param_suspension_ERP(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_suspension_ERP", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_suspension_ERP((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_suspension_ERP(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_suspension_ERP_438_comment =
  "C++ Interface:\n"
  "set_param_suspension_ERP(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_suspension_ERP_438_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_suspension_CFM(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_suspension_CFM_439(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_suspension_CFM")) {
    return NULL;
  }
  // 1-inline void OdeHinge2Joint::set_param_suspension_CFM(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_suspension_CFM", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_suspension_CFM((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_suspension_CFM(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_suspension_CFM_439_comment =
  "C++ Interface:\n"
  "set_param_suspension_CFM(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_suspension_CFM_439_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_lo_stop(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_lo_stop_440(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHinge2Joint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_lo_stop(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeHinge2Joint*)local_this).get_param_lo_stop((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_lo_stop(OdeHinge2Joint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_lo_stop_440_comment =
  "C++ Interface:\n"
  "get_param_lo_stop(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_lo_stop_440_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_hi_stop(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_hi_stop_441(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHinge2Joint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_hi_stop(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeHinge2Joint*)local_this).get_param_hi_stop((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_hi_stop(OdeHinge2Joint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_hi_stop_441_comment =
  "C++ Interface:\n"
  "get_param_hi_stop(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_hi_stop_441_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_vel(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_vel_442(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHinge2Joint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_vel(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeHinge2Joint*)local_this).get_param_vel((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_vel(OdeHinge2Joint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_vel_442_comment =
  "C++ Interface:\n"
  "get_param_vel(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_vel_442_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_f_max(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_f_max_443(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHinge2Joint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_f_max(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeHinge2Joint*)local_this).get_param_f_max((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_f_max(OdeHinge2Joint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_f_max_443_comment =
  "C++ Interface:\n"
  "get_param_f_max(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_f_max_443_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_fudge_factor(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_fudge_factor_444(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHinge2Joint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_fudge_factor(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeHinge2Joint*)local_this).get_param_fudge_factor((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_fudge_factor(OdeHinge2Joint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_fudge_factor_444_comment =
  "C++ Interface:\n"
  "get_param_fudge_factor(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_fudge_factor_444_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_bounce(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_bounce_445(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHinge2Joint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_bounce(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeHinge2Joint*)local_this).get_param_bounce((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_bounce(OdeHinge2Joint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_bounce_445_comment =
  "C++ Interface:\n"
  "get_param_bounce(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_bounce_445_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_CFM(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_CFM_446(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHinge2Joint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_CFM(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeHinge2Joint*)local_this).get_param_CFM((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_CFM(OdeHinge2Joint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_CFM_446_comment =
  "C++ Interface:\n"
  "get_param_CFM(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_CFM_446_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_stop_ERP(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_stop_ERP_447(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHinge2Joint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_stop_ERP(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeHinge2Joint*)local_this).get_param_stop_ERP((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_stop_ERP(OdeHinge2Joint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_stop_ERP_447_comment =
  "C++ Interface:\n"
  "get_param_stop_ERP(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_stop_ERP_447_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_stop_CFM(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_stop_CFM_448(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHinge2Joint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_stop_CFM(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeHinge2Joint*)local_this).get_param_stop_CFM((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_stop_CFM(OdeHinge2Joint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_stop_CFM_448_comment =
  "C++ Interface:\n"
  "get_param_stop_CFM(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_stop_CFM_448_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_suspension_ERP(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_suspension_ERP_449(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHinge2Joint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_suspension_ERP(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeHinge2Joint*)local_this).get_param_suspension_ERP((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_suspension_ERP(OdeHinge2Joint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_suspension_ERP_449_comment =
  "C++ Interface:\n"
  "get_param_suspension_ERP(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_suspension_ERP_449_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_suspension_CFM(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_suspension_CFM_450(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHinge2Joint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_suspension_CFM(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeHinge2Joint*)local_this).get_param_suspension_CFM((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_suspension_CFM(OdeHinge2Joint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_suspension_CFM_450_comment =
  "C++ Interface:\n"
  "get_param_suspension_CFM(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_suspension_CFM_450_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeHinge2Joint::get_class_type(void)
 */
static PyObject *Dtool_OdeHinge2Joint_get_class_type_451(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeHinge2Joint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeHinge2Joint::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_class_type_451_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeHinge2Joint_get_class_type_451_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeHinge2Joint::OdeHinge2Joint(OdeHinge2Joint const &) = default
 * OdeHinge2Joint::OdeHinge2Joint(OdeWorld &world)
 * OdeHinge2Joint::OdeHinge2Joint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdeHinge2Joint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline OdeHinge2Joint::OdeHinge2Joint(OdeHinge2Joint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeHinge2Joint", (char **)keyword_list, &param0)) {
          OdeHinge2Joint const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_OdeHinge2Joint, (void **)&param0_this);
          if (param0_this != NULL) {
            OdeHinge2Joint *return_value = new OdeHinge2Joint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeHinge2Joint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdeHinge2Joint::OdeHinge2Joint(OdeWorld &world)
        PyObject *param0;
        static const char *keyword_list[] = {"world", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeHinge2Joint", (char **)keyword_list, &param0)) {
          OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeHinge2Joint.OdeHinge2Joint", false, false);
          if (param0_this != NULL) {
            OdeHinge2Joint *return_value = new OdeHinge2Joint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeHinge2Joint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline OdeHinge2Joint::OdeHinge2Joint(OdeHinge2Joint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeHinge2Joint", (char **)keyword_list, &param0)) {
          OdeHinge2Joint const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_OdeHinge2Joint(param0, param0_this, param0_manage)) {
            OdeHinge2Joint *return_value = new OdeHinge2Joint(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeHinge2Joint, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: OdeHinge2Joint::OdeHinge2Joint(OdeWorld &world)
    }
    break;
  case 2:
    {
      // 1-OdeHinge2Joint::OdeHinge2Joint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeHinge2Joint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeHinge2Joint.OdeHinge2Joint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeHinge2Joint.OdeHinge2Joint", false, true);
        if (param0_this != NULL && param1_this != NULL) {
          OdeHinge2Joint *return_value = new OdeHinge2Joint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeHinge2Joint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeHinge2Joint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeHinge2Joint(const OdeHinge2Joint param0)\n"
      "OdeHinge2Joint(OdeWorld world)\n"
      "OdeHinge2Joint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeHinge2Joint(PyObject *args, OdeHinge2Joint const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeHinge2Joint, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeHinge2Joint::OdeHinge2Joint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeHinge2Joint.OdeHinge2Joint", false, false);
    if (arg_this != NULL) {
      OdeHinge2Joint *return_value = new OdeHinge2Joint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeHinge2Joint::OdeHinge2Joint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeHinge2Joint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeHinge2Joint.OdeHinge2Joint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeHinge2Joint.OdeHinge2Joint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeHinge2Joint *return_value = new OdeHinge2Joint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OdeHinge2Joint(PyObject *args, OdeHinge2Joint *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeHinge2Joint, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeHinge2Joint::OdeHinge2Joint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeHinge2Joint.OdeHinge2Joint", false, false);
    if (arg_this != NULL) {
      OdeHinge2Joint *return_value = new OdeHinge2Joint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeHinge2Joint::OdeHinge2Joint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeHinge2Joint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeHinge2Joint.OdeHinge2Joint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeHinge2Joint.OdeHinge2Joint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeHinge2Joint *return_value = new OdeHinge2Joint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeHinge2Joint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeHinge2Joint) {
    printf("OdeHinge2Joint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeHinge2Joint *local_this = (OdeHinge2Joint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeHinge2Joint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeHinge2Joint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeHinge2Joint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeHinge2Joint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeHinge2Joint*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeHingeJoint
 */
/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_anchor(LVecBase3f const &anchor)
 * inline void OdeHingeJoint::set_anchor(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeHingeJoint_set_anchor_454(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_anchor")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "anchor");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'anchor' (pos 1) not found");
      }
      // 1-inline void OdeHingeJoint::set_anchor(LVecBase3f const &anchor)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeHingeJoint.set_anchor", "LVecBase3f");
      }
      (*local_this).set_anchor(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeHingeJoint::set_anchor(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_anchor", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_anchor((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_anchor() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anchor(const OdeHingeJoint self, const LVecBase3f anchor)\n"
      "set_anchor(const OdeHingeJoint self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_anchor_454_comment =
  "C++ Interface:\n"
  "set_anchor(const OdeHingeJoint self, const LVecBase3f anchor)\n"
  "set_anchor(const OdeHingeJoint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeHingeJoint_set_anchor_454_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_anchor_delta(LVecBase3f const &anchor, LVecBase3f const &vec)
 * inline void OdeHingeJoint::set_anchor_delta(dReal x, dReal y, dReal z, dReal ax, dReal ay, dReal az)
 */
static PyObject *Dtool_OdeHingeJoint_set_anchor_delta_455(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_anchor_delta")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void OdeHingeJoint::set_anchor_delta(LVecBase3f const &anchor, LVecBase3f const &vec)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"anchor", "vec", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_anchor_delta", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "OdeHingeJoint.set_anchor_delta", "LVecBase3f");
        }
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeHingeJoint.set_anchor_delta", "LVecBase3f");
        }
        (*local_this).set_anchor_delta(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void OdeHingeJoint::set_anchor_delta(dReal x, dReal y, dReal z, dReal ax, dReal ay, dReal az)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"x", "y", "z", "ax", "ay", "az", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:set_anchor_delta", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        (*local_this).set_anchor_delta((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4, (dReal)param5, (dReal)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_anchor_delta() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anchor_delta(const OdeHingeJoint self, const LVecBase3f anchor, const LVecBase3f vec)\n"
      "set_anchor_delta(const OdeHingeJoint self, float x, float y, float z, float ax, float ay, float az)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_anchor_delta_455_comment =
  "C++ Interface:\n"
  "set_anchor_delta(const OdeHingeJoint self, const LVecBase3f anchor, const LVecBase3f vec)\n"
  "set_anchor_delta(const OdeHingeJoint self, float x, float y, float z, float ax, float ay, float az)\n";
#else
static const char *Dtool_OdeHingeJoint_set_anchor_delta_455_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_axis(LVecBase3f const &axis)
 * inline void OdeHingeJoint::set_axis(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeHingeJoint_set_axis_456(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_axis")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "axis");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'axis' (pos 1) not found");
      }
      // 1-inline void OdeHingeJoint::set_axis(LVecBase3f const &axis)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeHingeJoint.set_axis", "LVecBase3f");
      }
      (*local_this).set_axis(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeHingeJoint::set_axis(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_axis", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_axis((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_axis() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_axis(const OdeHingeJoint self, const LVecBase3f axis)\n"
      "set_axis(const OdeHingeJoint self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_axis_456_comment =
  "C++ Interface:\n"
  "set_axis(const OdeHingeJoint self, const LVecBase3f axis)\n"
  "set_axis(const OdeHingeJoint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeHingeJoint_set_axis_456_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::add_torque(dReal torque)
 */
static PyObject *Dtool_OdeHingeJoint_add_torque_457(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.add_torque")) {
    return NULL;
  }
  // 1-inline void OdeHingeJoint::add_torque(dReal torque)
  if (PyNumber_Check(arg)) {
    (*local_this).add_torque((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_torque(const OdeHingeJoint self, float torque)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_add_torque_457_comment =
  "C++ Interface:\n"
  "add_torque(const OdeHingeJoint self, float torque)\n";
#else
static const char *Dtool_OdeHingeJoint_add_torque_457_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeHingeJoint::get_anchor(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_anchor_458(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHingeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeHingeJoint::get_anchor(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeHingeJoint*)local_this).get_anchor());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_anchor_458_comment =
  "C++ Interface:\n"
  "get_anchor(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_anchor_458_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeHingeJoint::get_anchor2(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_anchor2_459(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHingeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeHingeJoint::get_anchor2(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeHingeJoint*)local_this).get_anchor2());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_anchor2_459_comment =
  "C++ Interface:\n"
  "get_anchor2(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_anchor2_459_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeHingeJoint::get_axis(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_axis_460(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHingeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeHingeJoint::get_axis(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeHingeJoint*)local_this).get_axis());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_axis_460_comment =
  "C++ Interface:\n"
  "get_axis(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_axis_460_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_angle(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_angle_461(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHingeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHingeJoint::get_angle(void) const
  dReal return_value = (*(const OdeHingeJoint*)local_this).get_angle();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_angle_461_comment =
  "C++ Interface:\n"
  "get_angle(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_angle_461_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_angle_rate(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_angle_rate_462(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHingeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHingeJoint::get_angle_rate(void) const
  dReal return_value = (*(const OdeHingeJoint*)local_this).get_angle_rate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_angle_rate_462_comment =
  "C++ Interface:\n"
  "get_angle_rate(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_angle_rate_462_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_param_lo_stop(dReal val)
 */
static PyObject *Dtool_OdeHingeJoint_set_param_lo_stop_463(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_param_lo_stop")) {
    return NULL;
  }
  // 1-inline void OdeHingeJoint::set_param_lo_stop(dReal val)
  if (PyNumber_Check(arg)) {
    (*local_this).set_param_lo_stop((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_lo_stop(const OdeHingeJoint self, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_param_lo_stop_463_comment =
  "C++ Interface:\n"
  "set_param_lo_stop(const OdeHingeJoint self, float val)\n";
#else
static const char *Dtool_OdeHingeJoint_set_param_lo_stop_463_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_param_hi_stop(dReal val)
 */
static PyObject *Dtool_OdeHingeJoint_set_param_hi_stop_464(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_param_hi_stop")) {
    return NULL;
  }
  // 1-inline void OdeHingeJoint::set_param_hi_stop(dReal val)
  if (PyNumber_Check(arg)) {
    (*local_this).set_param_hi_stop((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_hi_stop(const OdeHingeJoint self, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_param_hi_stop_464_comment =
  "C++ Interface:\n"
  "set_param_hi_stop(const OdeHingeJoint self, float val)\n";
#else
static const char *Dtool_OdeHingeJoint_set_param_hi_stop_464_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_param_vel(dReal val)
 */
static PyObject *Dtool_OdeHingeJoint_set_param_vel_465(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_param_vel")) {
    return NULL;
  }
  // 1-inline void OdeHingeJoint::set_param_vel(dReal val)
  if (PyNumber_Check(arg)) {
    (*local_this).set_param_vel((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_vel(const OdeHingeJoint self, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_param_vel_465_comment =
  "C++ Interface:\n"
  "set_param_vel(const OdeHingeJoint self, float val)\n";
#else
static const char *Dtool_OdeHingeJoint_set_param_vel_465_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_param_f_max(dReal val)
 */
static PyObject *Dtool_OdeHingeJoint_set_param_f_max_466(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_param_f_max")) {
    return NULL;
  }
  // 1-inline void OdeHingeJoint::set_param_f_max(dReal val)
  if (PyNumber_Check(arg)) {
    (*local_this).set_param_f_max((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_f_max(const OdeHingeJoint self, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_param_f_max_466_comment =
  "C++ Interface:\n"
  "set_param_f_max(const OdeHingeJoint self, float val)\n";
#else
static const char *Dtool_OdeHingeJoint_set_param_f_max_466_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_param_fudge_factor(dReal val)
 */
static PyObject *Dtool_OdeHingeJoint_set_param_fudge_factor_467(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_param_fudge_factor")) {
    return NULL;
  }
  // 1-inline void OdeHingeJoint::set_param_fudge_factor(dReal val)
  if (PyNumber_Check(arg)) {
    (*local_this).set_param_fudge_factor((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_fudge_factor(const OdeHingeJoint self, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_param_fudge_factor_467_comment =
  "C++ Interface:\n"
  "set_param_fudge_factor(const OdeHingeJoint self, float val)\n";
#else
static const char *Dtool_OdeHingeJoint_set_param_fudge_factor_467_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_param_bounce(dReal val)
 */
static PyObject *Dtool_OdeHingeJoint_set_param_bounce_468(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_param_bounce")) {
    return NULL;
  }
  // 1-inline void OdeHingeJoint::set_param_bounce(dReal val)
  if (PyNumber_Check(arg)) {
    (*local_this).set_param_bounce((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_bounce(const OdeHingeJoint self, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_param_bounce_468_comment =
  "C++ Interface:\n"
  "set_param_bounce(const OdeHingeJoint self, float val)\n";
#else
static const char *Dtool_OdeHingeJoint_set_param_bounce_468_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_param_CFM(dReal val)
 */
static PyObject *Dtool_OdeHingeJoint_set_param_CFM_469(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_param_CFM")) {
    return NULL;
  }
  // 1-inline void OdeHingeJoint::set_param_CFM(dReal val)
  if (PyNumber_Check(arg)) {
    (*local_this).set_param_CFM((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_CFM(const OdeHingeJoint self, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_param_CFM_469_comment =
  "C++ Interface:\n"
  "set_param_CFM(const OdeHingeJoint self, float val)\n";
#else
static const char *Dtool_OdeHingeJoint_set_param_CFM_469_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_param_stop_ERP(dReal val)
 */
static PyObject *Dtool_OdeHingeJoint_set_param_stop_ERP_470(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_param_stop_ERP")) {
    return NULL;
  }
  // 1-inline void OdeHingeJoint::set_param_stop_ERP(dReal val)
  if (PyNumber_Check(arg)) {
    (*local_this).set_param_stop_ERP((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_ERP(const OdeHingeJoint self, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_param_stop_ERP_470_comment =
  "C++ Interface:\n"
  "set_param_stop_ERP(const OdeHingeJoint self, float val)\n";
#else
static const char *Dtool_OdeHingeJoint_set_param_stop_ERP_470_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_param_stop_CFM(dReal val)
 */
static PyObject *Dtool_OdeHingeJoint_set_param_stop_CFM_471(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_param_stop_CFM")) {
    return NULL;
  }
  // 1-inline void OdeHingeJoint::set_param_stop_CFM(dReal val)
  if (PyNumber_Check(arg)) {
    (*local_this).set_param_stop_CFM((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_CFM(const OdeHingeJoint self, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_param_stop_CFM_471_comment =
  "C++ Interface:\n"
  "set_param_stop_CFM(const OdeHingeJoint self, float val)\n";
#else
static const char *Dtool_OdeHingeJoint_set_param_stop_CFM_471_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_param_lo_stop(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_param_lo_stop_472(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHingeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHingeJoint::get_param_lo_stop(void) const
  dReal return_value = (*(const OdeHingeJoint*)local_this).get_param_lo_stop();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_param_lo_stop_472_comment =
  "C++ Interface:\n"
  "get_param_lo_stop(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_param_lo_stop_472_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_param_hi_stop(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_param_hi_stop_473(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHingeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHingeJoint::get_param_hi_stop(void) const
  dReal return_value = (*(const OdeHingeJoint*)local_this).get_param_hi_stop();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_param_hi_stop_473_comment =
  "C++ Interface:\n"
  "get_param_hi_stop(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_param_hi_stop_473_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_param_vel(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_param_vel_474(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHingeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHingeJoint::get_param_vel(void) const
  dReal return_value = (*(const OdeHingeJoint*)local_this).get_param_vel();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_param_vel_474_comment =
  "C++ Interface:\n"
  "get_param_vel(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_param_vel_474_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_param_f_max(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_param_f_max_475(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHingeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHingeJoint::get_param_f_max(void) const
  dReal return_value = (*(const OdeHingeJoint*)local_this).get_param_f_max();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_param_f_max_475_comment =
  "C++ Interface:\n"
  "get_param_f_max(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_param_f_max_475_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_param_fudge_factor(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_param_fudge_factor_476(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHingeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHingeJoint::get_param_fudge_factor(void) const
  dReal return_value = (*(const OdeHingeJoint*)local_this).get_param_fudge_factor();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_param_fudge_factor_476_comment =
  "C++ Interface:\n"
  "get_param_fudge_factor(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_param_fudge_factor_476_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_param_bounce(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_param_bounce_477(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHingeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHingeJoint::get_param_bounce(void) const
  dReal return_value = (*(const OdeHingeJoint*)local_this).get_param_bounce();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_param_bounce_477_comment =
  "C++ Interface:\n"
  "get_param_bounce(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_param_bounce_477_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_param_CFM(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_param_CFM_478(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHingeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHingeJoint::get_param_CFM(void) const
  dReal return_value = (*(const OdeHingeJoint*)local_this).get_param_CFM();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_param_CFM_478_comment =
  "C++ Interface:\n"
  "get_param_CFM(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_param_CFM_478_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_param_stop_ERP(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_param_stop_ERP_479(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHingeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHingeJoint::get_param_stop_ERP(void) const
  dReal return_value = (*(const OdeHingeJoint*)local_this).get_param_stop_ERP();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_param_stop_ERP_479_comment =
  "C++ Interface:\n"
  "get_param_stop_ERP(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_param_stop_ERP_479_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_param_stop_CFM(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_param_stop_CFM_480(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeHingeJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeHingeJoint::get_param_stop_CFM(void) const
  dReal return_value = (*(const OdeHingeJoint*)local_this).get_param_stop_CFM();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_param_stop_CFM_480_comment =
  "C++ Interface:\n"
  "get_param_stop_CFM(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_param_stop_CFM_480_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeHingeJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeHingeJoint_get_class_type_481(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeHingeJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeHingeJoint::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_class_type_481_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeHingeJoint_get_class_type_481_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeHingeJoint::OdeHingeJoint(OdeHingeJoint const &) = default
 * OdeHingeJoint::OdeHingeJoint(OdeWorld &world)
 * OdeHingeJoint::OdeHingeJoint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdeHingeJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline OdeHingeJoint::OdeHingeJoint(OdeHingeJoint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeHingeJoint", (char **)keyword_list, &param0)) {
          OdeHingeJoint const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_OdeHingeJoint, (void **)&param0_this);
          if (param0_this != NULL) {
            OdeHingeJoint *return_value = new OdeHingeJoint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeHingeJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdeHingeJoint::OdeHingeJoint(OdeWorld &world)
        PyObject *param0;
        static const char *keyword_list[] = {"world", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeHingeJoint", (char **)keyword_list, &param0)) {
          OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeHingeJoint.OdeHingeJoint", false, false);
          if (param0_this != NULL) {
            OdeHingeJoint *return_value = new OdeHingeJoint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeHingeJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline OdeHingeJoint::OdeHingeJoint(OdeHingeJoint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeHingeJoint", (char **)keyword_list, &param0)) {
          OdeHingeJoint const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_OdeHingeJoint(param0, param0_this, param0_manage)) {
            OdeHingeJoint *return_value = new OdeHingeJoint(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeHingeJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: OdeHingeJoint::OdeHingeJoint(OdeWorld &world)
    }
    break;
  case 2:
    {
      // 1-OdeHingeJoint::OdeHingeJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeHingeJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeHingeJoint.OdeHingeJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeHingeJoint.OdeHingeJoint", false, true);
        if (param0_this != NULL && param1_this != NULL) {
          OdeHingeJoint *return_value = new OdeHingeJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeHingeJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeHingeJoint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeHingeJoint(const OdeHingeJoint param0)\n"
      "OdeHingeJoint(OdeWorld world)\n"
      "OdeHingeJoint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeHingeJoint(PyObject *args, OdeHingeJoint const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeHingeJoint, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeHingeJoint::OdeHingeJoint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeHingeJoint.OdeHingeJoint", false, false);
    if (arg_this != NULL) {
      OdeHingeJoint *return_value = new OdeHingeJoint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeHingeJoint::OdeHingeJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeHingeJoint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeHingeJoint.OdeHingeJoint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeHingeJoint.OdeHingeJoint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeHingeJoint *return_value = new OdeHingeJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OdeHingeJoint(PyObject *args, OdeHingeJoint *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeHingeJoint, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeHingeJoint::OdeHingeJoint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeHingeJoint.OdeHingeJoint", false, false);
    if (arg_this != NULL) {
      OdeHingeJoint *return_value = new OdeHingeJoint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeHingeJoint::OdeHingeJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeHingeJoint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeHingeJoint.OdeHingeJoint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeHingeJoint.OdeHingeJoint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeHingeJoint *return_value = new OdeHingeJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeHingeJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeHingeJoint) {
    printf("OdeHingeJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeHingeJoint *local_this = (OdeHingeJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeHingeJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeHingeJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeHingeJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeHingeJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeHingeJoint*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeJointCollection
 */
/**
 * Python function wrapper for:
 * void OdeJointCollection::operator =(OdeJointCollection const &copy)
 */
static PyObject *Dtool_OdeJointCollection_operator_484(PyObject *self, PyObject *arg) {
  OdeJointCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJointCollection, (void **)&local_this, "OdeJointCollection.assign")) {
    return NULL;
  }
  // 1-void OdeJointCollection::operator =(OdeJointCollection const &copy)
  OdeJointCollection const *arg_this = (OdeJointCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointCollection, 1, "OdeJointCollection.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    OdeJointCollection *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OdeJointCollection, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const OdeJointCollection self, const OdeJointCollection copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_operator_484_comment =
  "C++ Interface:\n"
  "assign(const OdeJointCollection self, const OdeJointCollection copy)\n";
#else
static const char *Dtool_OdeJointCollection_operator_484_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeJointCollection::add_joint(OdeJoint const &joint)
 */
static PyObject *Dtool_OdeJointCollection_add_joint_486(PyObject *self, PyObject *arg) {
  OdeJointCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJointCollection, (void **)&local_this, "OdeJointCollection.add_joint")) {
    return NULL;
  }
  // 1-void OdeJointCollection::add_joint(OdeJoint const &joint)
  OdeJoint const *arg_this = (OdeJoint *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJoint, 1, "OdeJointCollection.add_joint", true, true);
  if (arg_this != NULL) {
    (*local_this).add_joint(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_joint(const OdeJointCollection self, const OdeJoint joint)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_add_joint_486_comment =
  "C++ Interface:\n"
  "add_joint(const OdeJointCollection self, const OdeJoint joint)\n";
#else
static const char *Dtool_OdeJointCollection_add_joint_486_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool OdeJointCollection::remove_joint(OdeJoint const &joint)
 */
static PyObject *Dtool_OdeJointCollection_remove_joint_487(PyObject *self, PyObject *arg) {
  OdeJointCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJointCollection, (void **)&local_this, "OdeJointCollection.remove_joint")) {
    return NULL;
  }
  // 1-bool OdeJointCollection::remove_joint(OdeJoint const &joint)
  OdeJoint const *arg_this = (OdeJoint *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJoint, 1, "OdeJointCollection.remove_joint", true, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).remove_joint(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_joint(const OdeJointCollection self, const OdeJoint joint)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_remove_joint_487_comment =
  "C++ Interface:\n"
  "remove_joint(const OdeJointCollection self, const OdeJoint joint)\n";
#else
static const char *Dtool_OdeJointCollection_remove_joint_487_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeJointCollection::add_joints_from(OdeJointCollection const &other)
 */
static PyObject *Dtool_OdeJointCollection_add_joints_from_488(PyObject *self, PyObject *arg) {
  OdeJointCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJointCollection, (void **)&local_this, "OdeJointCollection.add_joints_from")) {
    return NULL;
  }
  // 1-void OdeJointCollection::add_joints_from(OdeJointCollection const &other)
  OdeJointCollection const *arg_this = (OdeJointCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointCollection, 1, "OdeJointCollection.add_joints_from", true, true);
  if (arg_this != NULL) {
    (*local_this).add_joints_from(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_joints_from(const OdeJointCollection self, const OdeJointCollection other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_add_joints_from_488_comment =
  "C++ Interface:\n"
  "add_joints_from(const OdeJointCollection self, const OdeJointCollection other)\n";
#else
static const char *Dtool_OdeJointCollection_add_joints_from_488_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeJointCollection::remove_joints_from(OdeJointCollection const &other)
 */
static PyObject *Dtool_OdeJointCollection_remove_joints_from_489(PyObject *self, PyObject *arg) {
  OdeJointCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJointCollection, (void **)&local_this, "OdeJointCollection.remove_joints_from")) {
    return NULL;
  }
  // 1-void OdeJointCollection::remove_joints_from(OdeJointCollection const &other)
  OdeJointCollection const *arg_this = (OdeJointCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointCollection, 1, "OdeJointCollection.remove_joints_from", true, true);
  if (arg_this != NULL) {
    (*local_this).remove_joints_from(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_joints_from(const OdeJointCollection self, const OdeJointCollection other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_remove_joints_from_489_comment =
  "C++ Interface:\n"
  "remove_joints_from(const OdeJointCollection self, const OdeJointCollection other)\n";
#else
static const char *Dtool_OdeJointCollection_remove_joints_from_489_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeJointCollection::remove_duplicate_joints(void)
 */
static PyObject *Dtool_OdeJointCollection_remove_duplicate_joints_490(PyObject *self, PyObject *) {
  OdeJointCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJointCollection, (void **)&local_this, "OdeJointCollection.remove_duplicate_joints")) {
    return NULL;
  }
  // 1-void OdeJointCollection::remove_duplicate_joints(void)
  (*local_this).remove_duplicate_joints();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_remove_duplicate_joints_490_comment =
  "C++ Interface:\n"
  "remove_duplicate_joints(const OdeJointCollection self)\n";
#else
static const char *Dtool_OdeJointCollection_remove_duplicate_joints_490_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool OdeJointCollection::has_joint(OdeJoint const &joint) const
 */
static PyObject *Dtool_OdeJointCollection_has_joint_491(PyObject *self, PyObject *arg) {
  OdeJointCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJointCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool OdeJointCollection::has_joint(OdeJoint const &joint) const
  OdeJoint const *arg_this = (OdeJoint *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJoint, 1, "OdeJointCollection.has_joint", true, true);
  if (arg_this != NULL) {
    bool return_value = (*(const OdeJointCollection*)local_this).has_joint(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_joint(OdeJointCollection self, const OdeJoint joint)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_has_joint_491_comment =
  "C++ Interface:\n"
  "has_joint(OdeJointCollection self, const OdeJoint joint)\n";
#else
static const char *Dtool_OdeJointCollection_has_joint_491_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeJointCollection::clear(void)
 */
static PyObject *Dtool_OdeJointCollection_clear_492(PyObject *self, PyObject *) {
  OdeJointCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJointCollection, (void **)&local_this, "OdeJointCollection.clear")) {
    return NULL;
  }
  // 1-void OdeJointCollection::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_clear_492_comment =
  "C++ Interface:\n"
  "clear(const OdeJointCollection self)\n";
#else
static const char *Dtool_OdeJointCollection_clear_492_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool OdeJointCollection::is_empty(void) const
 */
static PyObject *Dtool_OdeJointCollection_is_empty_493(PyObject *self, PyObject *) {
  OdeJointCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJointCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool OdeJointCollection::is_empty(void) const
  bool return_value = (*(const OdeJointCollection*)local_this).is_empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_is_empty_493_comment =
  "C++ Interface:\n"
  "is_empty(OdeJointCollection self)\n";
#else
static const char *Dtool_OdeJointCollection_is_empty_493_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int OdeJointCollection::get_num_joints(void) const
 */
static PyObject *Dtool_OdeJointCollection_get_num_joints_494(PyObject *self, PyObject *) {
  OdeJointCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJointCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-int OdeJointCollection::get_num_joints(void) const
  int return_value = (*(const OdeJointCollection*)local_this).get_num_joints();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_get_num_joints_494_comment =
  "C++ Interface:\n"
  "get_num_joints(OdeJointCollection self)\n";
#else
static const char *Dtool_OdeJointCollection_get_num_joints_494_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeJoint OdeJointCollection::get_joint(int index) const
 */
static PyObject *Dtool_OdeJointCollection_get_joint_495(PyObject *self, PyObject *arg) {
  OdeJointCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJointCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-OdeJoint OdeJointCollection::get_joint(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    OdeJoint *return_value = new OdeJoint((*(const OdeJointCollection*)local_this).get_joint((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeJoint, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_joint(OdeJointCollection self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_get_joint_495_comment =
  "C++ Interface:\n"
  "get_joint(OdeJointCollection self, int index)\n";
#else
static const char *Dtool_OdeJointCollection_get_joint_495_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeJointCollection::OdeJointCollection(void)
 * OdeJointCollection::OdeJointCollection(OdeJointCollection const &copy)
 */
static int Dtool_Init_OdeJointCollection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-OdeJointCollection::OdeJointCollection(void)
      OdeJointCollection *return_value = new OdeJointCollection();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeJointCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-OdeJointCollection::OdeJointCollection(OdeJointCollection const &copy)
      OdeJointCollection const *arg_this = (OdeJointCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointCollection, 0, "OdeJointCollection.OdeJointCollection", true, true);
      if (arg_this != NULL) {
        OdeJointCollection *return_value = new OdeJointCollection(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeJointCollection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeJointCollection() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeJointCollection()\n"
      "OdeJointCollection(const OdeJointCollection copy)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_OdeJointCollection_get_joints(PyObject *self, PyObject *) {
  OdeJointCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJointCollection, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_joints();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_OdeJointCollection_get_joint_495(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_OdeJointCollection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeJointCollection) {
    printf("OdeJointCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeJointCollection *local_this = (OdeJointCollection *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeJointCollection) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeJointCollection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeJointCollection) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeLMotorJoint
 */
/**
 * Python function wrapper for:
 * inline void OdeLMotorJoint::set_num_axes(int num)
 */
static PyObject *Dtool_OdeLMotorJoint_set_num_axes_503(PyObject *self, PyObject *arg) {
  OdeLMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeLMotorJoint, (void **)&local_this, "OdeLMotorJoint.set_num_axes")) {
    return NULL;
  }
  // 1-inline void OdeLMotorJoint::set_num_axes(int num)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_num_axes((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_axes(const OdeLMotorJoint self, int num)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeLMotorJoint_set_num_axes_503_comment =
  "C++ Interface:\n"
  "set_num_axes(const OdeLMotorJoint self, int num)\n";
#else
static const char *Dtool_OdeLMotorJoint_set_num_axes_503_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeLMotorJoint::set_axis(int anum, int rel, LVecBase3f const &axis)
 * inline void OdeLMotorJoint::set_axis(int anum, int rel, dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeLMotorJoint_set_axis_504(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeLMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeLMotorJoint, (void **)&local_this, "OdeLMotorJoint.set_axis")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-inline void OdeLMotorJoint::set_axis(int anum, int rel, LVecBase3f const &axis)
      int param1;
      int param2;
      PyObject *param3;
      static const char *keyword_list[] = {"anum", "rel", "axis", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_axis", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase3f param3_local;
        LVecBase3f const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "OdeLMotorJoint.set_axis", "LVecBase3f");
        }
        (*local_this).set_axis((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 5:
    {
      // 1-inline void OdeLMotorJoint::set_axis(int anum, int rel, dReal x, dReal y, dReal z)
      int param1;
      int param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"anum", "rel", "x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iifff:set_axis", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        (*local_this).set_axis((int)param1, (int)param2, (dReal)param3, (dReal)param4, (dReal)param5);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_axis() takes 4 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_axis(const OdeLMotorJoint self, int anum, int rel, const LVecBase3f axis)\n"
      "set_axis(const OdeLMotorJoint self, int anum, int rel, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeLMotorJoint_set_axis_504_comment =
  "C++ Interface:\n"
  "set_axis(const OdeLMotorJoint self, int anum, int rel, const LVecBase3f axis)\n"
  "set_axis(const OdeLMotorJoint self, int anum, int rel, float x, float y, float z)\n";
#else
static const char *Dtool_OdeLMotorJoint_set_axis_504_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeLMotorJoint::set_param(int parameter, dReal value)
 */
static PyObject *Dtool_OdeLMotorJoint_set_param_505(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeLMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeLMotorJoint, (void **)&local_this, "OdeLMotorJoint.set_param")) {
    return NULL;
  }
  // 1-inline void OdeLMotorJoint::set_param(int parameter, dReal value)
  int param1;
  float param2;
  static const char *keyword_list[] = {"parameter", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param(const OdeLMotorJoint self, int parameter, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeLMotorJoint_set_param_505_comment =
  "C++ Interface:\n"
  "set_param(const OdeLMotorJoint self, int parameter, float value)\n";
#else
static const char *Dtool_OdeLMotorJoint_set_param_505_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeLMotorJoint::get_num_axes(void) const
 */
static PyObject *Dtool_OdeLMotorJoint_get_num_axes_506(PyObject *self, PyObject *) {
  OdeLMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeLMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeLMotorJoint::get_num_axes(void) const
  int return_value = (*(const OdeLMotorJoint*)local_this).get_num_axes();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeLMotorJoint_get_num_axes_506_comment =
  "C++ Interface:\n"
  "get_num_axes(OdeLMotorJoint self)\n";
#else
static const char *Dtool_OdeLMotorJoint_get_num_axes_506_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeLMotorJoint::get_axis(int anum) const
 */
static PyObject *Dtool_OdeLMotorJoint_get_axis_507(PyObject *self, PyObject *arg) {
  OdeLMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeLMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeLMotorJoint::get_axis(int anum) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3f *return_value = new LVecBase3f((*(const OdeLMotorJoint*)local_this).get_axis((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_axis(OdeLMotorJoint self, int anum)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeLMotorJoint_get_axis_507_comment =
  "C++ Interface:\n"
  "get_axis(OdeLMotorJoint self, int anum)\n";
#else
static const char *Dtool_OdeLMotorJoint_get_axis_507_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeLMotorJoint::get_param(int parameter) const
 */
static PyObject *Dtool_OdeLMotorJoint_get_param_509(PyObject *self, PyObject *arg) {
  OdeLMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeLMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeLMotorJoint::get_param(int parameter) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeLMotorJoint*)local_this).get_param((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param(OdeLMotorJoint self, int parameter)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeLMotorJoint_get_param_509_comment =
  "C++ Interface:\n"
  "get_param(OdeLMotorJoint self, int parameter)\n";
#else
static const char *Dtool_OdeLMotorJoint_get_param_509_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeLMotorJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeLMotorJoint_get_class_type_510(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeLMotorJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeLMotorJoint::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeLMotorJoint_get_class_type_510_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeLMotorJoint_get_class_type_510_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeLMotorJoint::OdeLMotorJoint(OdeLMotorJoint const &) = default
 * OdeLMotorJoint::OdeLMotorJoint(OdeWorld &world)
 * OdeLMotorJoint::OdeLMotorJoint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdeLMotorJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline OdeLMotorJoint::OdeLMotorJoint(OdeLMotorJoint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeLMotorJoint", (char **)keyword_list, &param0)) {
          OdeLMotorJoint const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_OdeLMotorJoint, (void **)&param0_this);
          if (param0_this != NULL) {
            OdeLMotorJoint *return_value = new OdeLMotorJoint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeLMotorJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdeLMotorJoint::OdeLMotorJoint(OdeWorld &world)
        PyObject *param0;
        static const char *keyword_list[] = {"world", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeLMotorJoint", (char **)keyword_list, &param0)) {
          OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeLMotorJoint.OdeLMotorJoint", false, false);
          if (param0_this != NULL) {
            OdeLMotorJoint *return_value = new OdeLMotorJoint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeLMotorJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline OdeLMotorJoint::OdeLMotorJoint(OdeLMotorJoint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeLMotorJoint", (char **)keyword_list, &param0)) {
          OdeLMotorJoint const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_OdeLMotorJoint(param0, param0_this, param0_manage)) {
            OdeLMotorJoint *return_value = new OdeLMotorJoint(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeLMotorJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: OdeLMotorJoint::OdeLMotorJoint(OdeWorld &world)
    }
    break;
  case 2:
    {
      // 1-OdeLMotorJoint::OdeLMotorJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeLMotorJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeLMotorJoint.OdeLMotorJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeLMotorJoint.OdeLMotorJoint", false, true);
        if (param0_this != NULL && param1_this != NULL) {
          OdeLMotorJoint *return_value = new OdeLMotorJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeLMotorJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeLMotorJoint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeLMotorJoint(const OdeLMotorJoint param0)\n"
      "OdeLMotorJoint(OdeWorld world)\n"
      "OdeLMotorJoint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeLMotorJoint(PyObject *args, OdeLMotorJoint const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeLMotorJoint, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeLMotorJoint::OdeLMotorJoint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeLMotorJoint.OdeLMotorJoint", false, false);
    if (arg_this != NULL) {
      OdeLMotorJoint *return_value = new OdeLMotorJoint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeLMotorJoint::OdeLMotorJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeLMotorJoint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeLMotorJoint.OdeLMotorJoint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeLMotorJoint.OdeLMotorJoint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeLMotorJoint *return_value = new OdeLMotorJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OdeLMotorJoint(PyObject *args, OdeLMotorJoint *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeLMotorJoint, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeLMotorJoint::OdeLMotorJoint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeLMotorJoint.OdeLMotorJoint", false, false);
    if (arg_this != NULL) {
      OdeLMotorJoint *return_value = new OdeLMotorJoint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeLMotorJoint::OdeLMotorJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeLMotorJoint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeLMotorJoint.OdeLMotorJoint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeLMotorJoint.OdeLMotorJoint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeLMotorJoint *return_value = new OdeLMotorJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_OdeLMotorJoint_get_axes(PyObject *self, PyObject *) {
  OdeLMotorJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeLMotorJoint, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_axes();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_OdeLMotorJoint_get_axis_507(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_OdeLMotorJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeLMotorJoint) {
    printf("OdeLMotorJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeLMotorJoint *local_this = (OdeLMotorJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeLMotorJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeLMotorJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeLMotorJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeLMotorJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeLMotorJoint*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeNullJoint
 */
/**
 * Python function wrapper for:
 * static TypeHandle OdeNullJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeNullJoint_get_class_type_513(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeNullJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeNullJoint::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeNullJoint_get_class_type_513_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeNullJoint_get_class_type_513_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeNullJoint::OdeNullJoint(OdeNullJoint const &) = default
 * OdeNullJoint::OdeNullJoint(OdeWorld &world)
 * OdeNullJoint::OdeNullJoint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdeNullJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline OdeNullJoint::OdeNullJoint(OdeNullJoint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeNullJoint", (char **)keyword_list, &param0)) {
          OdeNullJoint const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_OdeNullJoint, (void **)&param0_this);
          if (param0_this != NULL) {
            OdeNullJoint *return_value = new OdeNullJoint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeNullJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdeNullJoint::OdeNullJoint(OdeWorld &world)
        PyObject *param0;
        static const char *keyword_list[] = {"world", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeNullJoint", (char **)keyword_list, &param0)) {
          OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeNullJoint.OdeNullJoint", false, false);
          if (param0_this != NULL) {
            OdeNullJoint *return_value = new OdeNullJoint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeNullJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline OdeNullJoint::OdeNullJoint(OdeNullJoint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeNullJoint", (char **)keyword_list, &param0)) {
          OdeNullJoint const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_OdeNullJoint(param0, param0_this, param0_manage)) {
            OdeNullJoint *return_value = new OdeNullJoint(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeNullJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: OdeNullJoint::OdeNullJoint(OdeWorld &world)
    }
    break;
  case 2:
    {
      // 1-OdeNullJoint::OdeNullJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeNullJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeNullJoint.OdeNullJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeNullJoint.OdeNullJoint", false, true);
        if (param0_this != NULL && param1_this != NULL) {
          OdeNullJoint *return_value = new OdeNullJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeNullJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeNullJoint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeNullJoint(const OdeNullJoint param0)\n"
      "OdeNullJoint(OdeWorld world)\n"
      "OdeNullJoint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeNullJoint(PyObject *args, OdeNullJoint const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeNullJoint, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeNullJoint::OdeNullJoint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeNullJoint.OdeNullJoint", false, false);
    if (arg_this != NULL) {
      OdeNullJoint *return_value = new OdeNullJoint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeNullJoint::OdeNullJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeNullJoint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeNullJoint.OdeNullJoint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeNullJoint.OdeNullJoint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeNullJoint *return_value = new OdeNullJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OdeNullJoint(PyObject *args, OdeNullJoint *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeNullJoint, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeNullJoint::OdeNullJoint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeNullJoint.OdeNullJoint", false, false);
    if (arg_this != NULL) {
      OdeNullJoint *return_value = new OdeNullJoint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeNullJoint::OdeNullJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeNullJoint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeNullJoint.OdeNullJoint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeNullJoint.OdeNullJoint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeNullJoint *return_value = new OdeNullJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeNullJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeNullJoint) {
    printf("OdeNullJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeNullJoint *local_this = (OdeNullJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeNullJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeNullJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeNullJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeNullJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeNullJoint*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdePlane2dJoint
 */
/**
 * Python function wrapper for:
 * inline void OdePlane2dJoint::set_x_param(int parameter, dReal value)
 */
static PyObject *Dtool_OdePlane2dJoint_set_x_param_516(PyObject *self, PyObject *args, PyObject *kwds) {
  OdePlane2dJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdePlane2dJoint, (void **)&local_this, "OdePlane2dJoint.set_x_param")) {
    return NULL;
  }
  // 1-inline void OdePlane2dJoint::set_x_param(int parameter, dReal value)
  int param1;
  float param2;
  static const char *keyword_list[] = {"parameter", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_x_param", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_x_param((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_x_param(const OdePlane2dJoint self, int parameter, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdePlane2dJoint_set_x_param_516_comment =
  "C++ Interface:\n"
  "set_x_param(const OdePlane2dJoint self, int parameter, float value)\n";
#else
static const char *Dtool_OdePlane2dJoint_set_x_param_516_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdePlane2dJoint::set_y_param(int parameter, dReal value)
 */
static PyObject *Dtool_OdePlane2dJoint_set_y_param_517(PyObject *self, PyObject *args, PyObject *kwds) {
  OdePlane2dJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdePlane2dJoint, (void **)&local_this, "OdePlane2dJoint.set_y_param")) {
    return NULL;
  }
  // 1-inline void OdePlane2dJoint::set_y_param(int parameter, dReal value)
  int param1;
  float param2;
  static const char *keyword_list[] = {"parameter", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_y_param", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_y_param((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_y_param(const OdePlane2dJoint self, int parameter, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdePlane2dJoint_set_y_param_517_comment =
  "C++ Interface:\n"
  "set_y_param(const OdePlane2dJoint self, int parameter, float value)\n";
#else
static const char *Dtool_OdePlane2dJoint_set_y_param_517_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdePlane2dJoint::set_angle_param(int parameter, dReal value)
 */
static PyObject *Dtool_OdePlane2dJoint_set_angle_param_518(PyObject *self, PyObject *args, PyObject *kwds) {
  OdePlane2dJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdePlane2dJoint, (void **)&local_this, "OdePlane2dJoint.set_angle_param")) {
    return NULL;
  }
  // 1-inline void OdePlane2dJoint::set_angle_param(int parameter, dReal value)
  int param1;
  float param2;
  static const char *keyword_list[] = {"parameter", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_angle_param", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_angle_param((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_angle_param(const OdePlane2dJoint self, int parameter, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdePlane2dJoint_set_angle_param_518_comment =
  "C++ Interface:\n"
  "set_angle_param(const OdePlane2dJoint self, int parameter, float value)\n";
#else
static const char *Dtool_OdePlane2dJoint_set_angle_param_518_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdePlane2dJoint::get_class_type(void)
 */
static PyObject *Dtool_OdePlane2dJoint_get_class_type_519(PyObject *, PyObject *) {
  // 1-static TypeHandle OdePlane2dJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdePlane2dJoint::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdePlane2dJoint_get_class_type_519_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdePlane2dJoint_get_class_type_519_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdePlane2dJoint::OdePlane2dJoint(OdePlane2dJoint const &) = default
 * OdePlane2dJoint::OdePlane2dJoint(OdeWorld &world)
 * OdePlane2dJoint::OdePlane2dJoint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdePlane2dJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline OdePlane2dJoint::OdePlane2dJoint(OdePlane2dJoint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdePlane2dJoint", (char **)keyword_list, &param0)) {
          OdePlane2dJoint const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_OdePlane2dJoint, (void **)&param0_this);
          if (param0_this != NULL) {
            OdePlane2dJoint *return_value = new OdePlane2dJoint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdePlane2dJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdePlane2dJoint::OdePlane2dJoint(OdeWorld &world)
        PyObject *param0;
        static const char *keyword_list[] = {"world", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdePlane2dJoint", (char **)keyword_list, &param0)) {
          OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdePlane2dJoint.OdePlane2dJoint", false, false);
          if (param0_this != NULL) {
            OdePlane2dJoint *return_value = new OdePlane2dJoint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdePlane2dJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline OdePlane2dJoint::OdePlane2dJoint(OdePlane2dJoint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdePlane2dJoint", (char **)keyword_list, &param0)) {
          OdePlane2dJoint const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_OdePlane2dJoint(param0, param0_this, param0_manage)) {
            OdePlane2dJoint *return_value = new OdePlane2dJoint(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdePlane2dJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: OdePlane2dJoint::OdePlane2dJoint(OdeWorld &world)
    }
    break;
  case 2:
    {
      // 1-OdePlane2dJoint::OdePlane2dJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdePlane2dJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdePlane2dJoint.OdePlane2dJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdePlane2dJoint.OdePlane2dJoint", false, true);
        if (param0_this != NULL && param1_this != NULL) {
          OdePlane2dJoint *return_value = new OdePlane2dJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdePlane2dJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdePlane2dJoint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdePlane2dJoint(const OdePlane2dJoint param0)\n"
      "OdePlane2dJoint(OdeWorld world)\n"
      "OdePlane2dJoint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdePlane2dJoint(PyObject *args, OdePlane2dJoint const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdePlane2dJoint, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdePlane2dJoint::OdePlane2dJoint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdePlane2dJoint.OdePlane2dJoint", false, false);
    if (arg_this != NULL) {
      OdePlane2dJoint *return_value = new OdePlane2dJoint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdePlane2dJoint::OdePlane2dJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdePlane2dJoint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdePlane2dJoint.OdePlane2dJoint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdePlane2dJoint.OdePlane2dJoint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdePlane2dJoint *return_value = new OdePlane2dJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OdePlane2dJoint(PyObject *args, OdePlane2dJoint *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdePlane2dJoint, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdePlane2dJoint::OdePlane2dJoint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdePlane2dJoint.OdePlane2dJoint", false, false);
    if (arg_this != NULL) {
      OdePlane2dJoint *return_value = new OdePlane2dJoint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdePlane2dJoint::OdePlane2dJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdePlane2dJoint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdePlane2dJoint.OdePlane2dJoint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdePlane2dJoint.OdePlane2dJoint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdePlane2dJoint *return_value = new OdePlane2dJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdePlane2dJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdePlane2dJoint) {
    printf("OdePlane2dJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdePlane2dJoint *local_this = (OdePlane2dJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdePlane2dJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdePlane2dJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdePlane2dJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdePlane2dJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdePlane2dJoint*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdePlaneGeom
 */
/**
 * Python function wrapper for:
 * inline void OdePlaneGeom::set_params(LVecBase4f const &params)
 * inline void OdePlaneGeom::set_params(dReal a, dReal b, dReal c, dReal d)
 */
static PyObject *Dtool_OdePlaneGeom_set_params_522(PyObject *self, PyObject *args, PyObject *kwds) {
  OdePlaneGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdePlaneGeom, (void **)&local_this, "OdePlaneGeom.set_params")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "params");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'params' (pos 1) not found");
      }
      // 1-inline void OdePlaneGeom::set_params(LVecBase4f const &params)
      LVecBase4f arg_local;
      LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdePlaneGeom.set_params", "LVecBase4f");
      }
      (*local_this).set_params(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void OdePlaneGeom::set_params(dReal a, dReal b, dReal c, dReal d)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"a", "b", "c", "d", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_params", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_params((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_params() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_params(const OdePlaneGeom self, const LVecBase4f params)\n"
      "set_params(const OdePlaneGeom self, float a, float b, float c, float d)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdePlaneGeom_set_params_522_comment =
  "C++ Interface:\n"
  "set_params(const OdePlaneGeom self, const LVecBase4f params)\n"
  "set_params(const OdePlaneGeom self, float a, float b, float c, float d)\n";
#else
static const char *Dtool_OdePlaneGeom_set_params_522_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4f OdePlaneGeom::get_params(void) const
 */
static PyObject *Dtool_OdePlaneGeom_get_params_523(PyObject *self, PyObject *) {
  OdePlaneGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdePlaneGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4f OdePlaneGeom::get_params(void) const
  LVecBase4f *return_value = new LVecBase4f((*(const OdePlaneGeom*)local_this).get_params());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdePlaneGeom_get_params_523_comment =
  "C++ Interface:\n"
  "get_params(OdePlaneGeom self)\n";
#else
static const char *Dtool_OdePlaneGeom_get_params_523_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdePlaneGeom::get_point_depth(LPoint3f const &p) const
 * inline dReal OdePlaneGeom::get_point_depth(dReal x, dReal y, dReal z) const
 */
static PyObject *Dtool_OdePlaneGeom_get_point_depth_524(PyObject *self, PyObject *args, PyObject *kwds) {
  OdePlaneGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdePlaneGeom, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "p");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'p' (pos 1) not found");
      }
      // 1-inline dReal OdePlaneGeom::get_point_depth(LPoint3f const &p) const
      LPoint3f arg_local;
      LPoint3f const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdePlaneGeom.get_point_depth", "LPoint3f");
      }
      dReal return_value = (*(const OdePlaneGeom*)local_this).get_point_depth(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 3:
    {
      // 1-inline dReal OdePlaneGeom::get_point_depth(dReal x, dReal y, dReal z) const
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:get_point_depth", (char **)keyword_list, &param1, &param2, &param3)) {
        dReal return_value = (*(const OdePlaneGeom*)local_this).get_point_depth((dReal)param1, (dReal)param2, (dReal)param3);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_point_depth() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point_depth(OdePlaneGeom self, const LPoint3f p)\n"
      "get_point_depth(OdePlaneGeom self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdePlaneGeom_get_point_depth_524_comment =
  "C++ Interface:\n"
  "get_point_depth(OdePlaneGeom self, const LPoint3f p)\n"
  "get_point_depth(OdePlaneGeom self, float x, float y, float z)\n";
#else
static const char *Dtool_OdePlaneGeom_get_point_depth_524_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdePlaneGeom::get_class_type(void)
 */
static PyObject *Dtool_OdePlaneGeom_get_class_type_525(PyObject *, PyObject *) {
  // 1-static TypeHandle OdePlaneGeom::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdePlaneGeom::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdePlaneGeom_get_class_type_525_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdePlaneGeom_get_class_type_525_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdePlaneGeom::OdePlaneGeom(LVecBase4f const &params)
 * inline OdePlaneGeom::OdePlaneGeom(OdePlaneGeom const &) = default
 * OdePlaneGeom::OdePlaneGeom(OdeSpace &space, LVecBase4f const &params)
 * OdePlaneGeom::OdePlaneGeom(OdeSpace &space, dReal a, dReal b, dReal c, dReal d)
 * OdePlaneGeom::OdePlaneGeom(dReal a, dReal b, dReal c, dReal d)
 */
static int Dtool_Init_OdePlaneGeom(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline OdePlaneGeom::OdePlaneGeom(OdePlaneGeom const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdePlaneGeom", (char **)keyword_list, &param0)) {
          OdePlaneGeom const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_OdePlaneGeom, (void **)&param0_this);
          if (param0_this != NULL) {
            OdePlaneGeom *return_value = new OdePlaneGeom(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdePlaneGeom, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdePlaneGeom::OdePlaneGeom(LVecBase4f const &params)
        PyObject *param0;
        static const char *keyword_list[] = {"params", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdePlaneGeom", (char **)keyword_list, &param0)) {
          LVecBase4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4f, (void **)&param0_this);
          if (param0_this != NULL) {
            OdePlaneGeom *return_value = new OdePlaneGeom(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdePlaneGeom, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline OdePlaneGeom::OdePlaneGeom(OdePlaneGeom const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdePlaneGeom", (char **)keyword_list, &param0)) {
          OdePlaneGeom const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_OdePlaneGeom(param0, param0_this, param0_manage)) {
            OdePlaneGeom *return_value = new OdePlaneGeom(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdePlaneGeom, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdePlaneGeom::OdePlaneGeom(LVecBase4f const &params)
        PyObject *param0;
        static const char *keyword_list[] = {"params", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdePlaneGeom", (char **)keyword_list, &param0)) {
          LVecBase4f param0_local;
          LVecBase4f const *param0_this = Dtool_Coerce_LVecBase4f(param0, param0_local);
          if ((param0_this != NULL)) {
            OdePlaneGeom *return_value = new OdePlaneGeom(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdePlaneGeom, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-OdePlaneGeom::OdePlaneGeom(OdeSpace &space, LVecBase4f const &params)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"space", "params", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdePlaneGeom", (char **)keyword_list, &param0, &param1)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdePlaneGeom.OdePlaneGeom", false, true);
        LVecBase4f param1_local;
        LVecBase4f const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "OdePlaneGeom.OdePlaneGeom", "LVecBase4f");
          return -1;
        }
        if (param0_this != NULL) {
          OdePlaneGeom *return_value = new OdePlaneGeom(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdePlaneGeom, true, false);
        }
      }
    }
    break;
  case 4:
    {
      // 1-OdePlaneGeom::OdePlaneGeom(dReal a, dReal b, dReal c, dReal d)
      float param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"a", "b", "c", "d", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:OdePlaneGeom", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        OdePlaneGeom *return_value = new OdePlaneGeom((dReal)param0, (dReal)param1, (dReal)param2, (dReal)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdePlaneGeom, true, false);
      }
    }
    break;
  case 5:
    {
      // 1-OdePlaneGeom::OdePlaneGeom(OdeSpace &space, dReal a, dReal b, dReal c, dReal d)
      PyObject *param0;
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"space", "a", "b", "c", "d", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offff:OdePlaneGeom", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdePlaneGeom.OdePlaneGeom", false, true);
        if (param0_this != NULL) {
          OdePlaneGeom *return_value = new OdePlaneGeom(*param0_this, (dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdePlaneGeom, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdePlaneGeom() takes 1, 2, 4 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdePlaneGeom(const OdePlaneGeom param0)\n"
      "OdePlaneGeom(const LVecBase4f params)\n"
      "OdePlaneGeom(OdeSpace space, const LVecBase4f params)\n"
      "OdePlaneGeom(float a, float b, float c, float d)\n"
      "OdePlaneGeom(OdeSpace space, float a, float b, float c, float d)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdePlaneGeom(PyObject *args, OdePlaneGeom const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdePlaneGeom, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdePlaneGeom::OdePlaneGeom(LVecBase4f const &params)
    LVecBase4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
    if (arg_this != NULL) {
      OdePlaneGeom *return_value = new OdePlaneGeom(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-OdePlaneGeom::OdePlaneGeom(OdeSpace &space, LVecBase4f const &params)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "OdePlaneGeom", 2, 2, &param0, &param1)) {
          OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdePlaneGeom.OdePlaneGeom", false, false);
          LVecBase4f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase4f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            OdePlaneGeom *return_value = new OdePlaneGeom(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-OdePlaneGeom::OdePlaneGeom(dReal a, dReal b, dReal c, dReal d)
        float param0;
        float param1;
        float param2;
        float param3;
        if (PyArg_ParseTuple(args, "ffff:OdePlaneGeom", &param0, &param1, &param2, &param3)) {
          OdePlaneGeom *return_value = new OdePlaneGeom((dReal)param0, (dReal)param1, (dReal)param2, (dReal)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 5: {
        // 1-OdePlaneGeom::OdePlaneGeom(OdeSpace &space, dReal a, dReal b, dReal c, dReal d)
        PyObject *param0;
        float param1;
        float param2;
        float param3;
        float param4;
        if (PyArg_ParseTuple(args, "Offff:OdePlaneGeom", &param0, &param1, &param2, &param3, &param4)) {
          OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdePlaneGeom.OdePlaneGeom", false, false);
          if (param0_this != NULL) {
            OdePlaneGeom *return_value = new OdePlaneGeom(*param0_this, (dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_OdePlaneGeom(PyObject *args, OdePlaneGeom *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdePlaneGeom, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdePlaneGeom::OdePlaneGeom(LVecBase4f const &params)
    LVecBase4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
    if (arg_this != NULL) {
      OdePlaneGeom *return_value = new OdePlaneGeom(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-OdePlaneGeom::OdePlaneGeom(OdeSpace &space, LVecBase4f const &params)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "OdePlaneGeom", 2, 2, &param0, &param1)) {
          OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdePlaneGeom.OdePlaneGeom", false, false);
          LVecBase4f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase4f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            OdePlaneGeom *return_value = new OdePlaneGeom(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-OdePlaneGeom::OdePlaneGeom(dReal a, dReal b, dReal c, dReal d)
        float param0;
        float param1;
        float param2;
        float param3;
        if (PyArg_ParseTuple(args, "ffff:OdePlaneGeom", &param0, &param1, &param2, &param3)) {
          OdePlaneGeom *return_value = new OdePlaneGeom((dReal)param0, (dReal)param1, (dReal)param2, (dReal)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 5: {
        // 1-OdePlaneGeom::OdePlaneGeom(OdeSpace &space, dReal a, dReal b, dReal c, dReal d)
        PyObject *param0;
        float param1;
        float param2;
        float param3;
        float param4;
        if (PyArg_ParseTuple(args, "Offff:OdePlaneGeom", &param0, &param1, &param2, &param3, &param4)) {
          OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdePlaneGeom.OdePlaneGeom", false, false);
          if (param0_this != NULL) {
            OdePlaneGeom *return_value = new OdePlaneGeom(*param0_this, (dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdePlaneGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdePlaneGeom) {
    printf("OdePlaneGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdePlaneGeom *local_this = (OdePlaneGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdePlaneGeom) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeGeom) {
    return (OdeGeom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeGeom *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdePlaneGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdePlaneGeom) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeGeom) {
    OdeGeom* other_this = (OdeGeom*)from_this;
    return (OdePlaneGeom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdePlaneGeom*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeQuadTreeSpace
 */
/**
 * Python function wrapper for:
 * static TypeHandle OdeQuadTreeSpace::get_class_type(void)
 */
static PyObject *Dtool_OdeQuadTreeSpace_get_class_type_528(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeQuadTreeSpace::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeQuadTreeSpace::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeQuadTreeSpace_get_class_type_528_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeQuadTreeSpace_get_class_type_528_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeQuadTreeSpace::OdeQuadTreeSpace(LPoint3f const &center, LVecBase3f const &extents, int const depth)
 * inline OdeQuadTreeSpace::OdeQuadTreeSpace(OdeQuadTreeSpace const &) = default
 * OdeQuadTreeSpace::OdeQuadTreeSpace(OdeSpace &space, LPoint3f const &center, LVecBase3f const &extents, int const depth)
 */
static int Dtool_Init_OdeQuadTreeSpace(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline OdeQuadTreeSpace::OdeQuadTreeSpace(OdeQuadTreeSpace const &) = default
      OdeQuadTreeSpace const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_OdeQuadTreeSpace(arg, arg_this, arg_manage)) {
        Dtool_Raise_ArgTypeError(arg, 0, "OdeQuadTreeSpace.OdeQuadTreeSpace", "OdeQuadTreeSpace");
        return -1;
      }
      OdeQuadTreeSpace *return_value = new OdeQuadTreeSpace(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeQuadTreeSpace, true, false);
    }
    break;
  case 3:
    {
      // 1-OdeQuadTreeSpace::OdeQuadTreeSpace(LPoint3f const &center, LVecBase3f const &extents, int const depth)
      PyObject *param0;
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"center", "extents", "depth", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:OdeQuadTreeSpace", (char **)keyword_list, &param0, &param1, &param2)) {
        LPoint3f param0_local;
        LPoint3f const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "OdeQuadTreeSpace.OdeQuadTreeSpace", "LPoint3f");
          return -1;
        }
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "OdeQuadTreeSpace.OdeQuadTreeSpace", "LVecBase3f");
          return -1;
        }
        OdeQuadTreeSpace *return_value = new OdeQuadTreeSpace(*param0_this, *param1_this, (int const)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeQuadTreeSpace, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-OdeQuadTreeSpace::OdeQuadTreeSpace(OdeSpace &space, LPoint3f const &center, LVecBase3f const &extents, int const depth)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      int param3;
      static const char *keyword_list[] = {"space", "center", "extents", "depth", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOi:OdeQuadTreeSpace", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeQuadTreeSpace.OdeQuadTreeSpace", false, true);
        LPoint3f param1_local;
        LPoint3f const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "OdeQuadTreeSpace.OdeQuadTreeSpace", "LPoint3f");
          return -1;
        }
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          Dtool_Raise_ArgTypeError(param2, 2, "OdeQuadTreeSpace.OdeQuadTreeSpace", "LVecBase3f");
          return -1;
        }
        if (param0_this != NULL) {
          OdeQuadTreeSpace *return_value = new OdeQuadTreeSpace(*param0_this, *param1_this, *param2_this, (int const)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeQuadTreeSpace, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeQuadTreeSpace() takes 1, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeQuadTreeSpace(const OdeQuadTreeSpace param0)\n"
      "OdeQuadTreeSpace(const LPoint3f center, const LVecBase3f extents, int depth)\n"
      "OdeQuadTreeSpace(OdeSpace space, const LPoint3f center, const LVecBase3f extents, int depth)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeQuadTreeSpace(PyObject *args, OdeQuadTreeSpace const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeQuadTreeSpace, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 3: {
        // 1-OdeQuadTreeSpace::OdeQuadTreeSpace(LPoint3f const &center, LVecBase3f const &extents, int const depth)
        PyObject *param0;
        PyObject *param1;
        int param2;
        if (PyArg_ParseTuple(args, "OOi:OdeQuadTreeSpace", &param0, &param1, &param2)) {
          LPoint3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          LVecBase3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            OdeQuadTreeSpace *return_value = new OdeQuadTreeSpace(*param0_this, *param1_this, (int const)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-OdeQuadTreeSpace::OdeQuadTreeSpace(OdeSpace &space, LPoint3f const &center, LVecBase3f const &extents, int const depth)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3;
        if (PyArg_ParseTuple(args, "OOOi:OdeQuadTreeSpace", &param0, &param1, &param2, &param3)) {
          OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeQuadTreeSpace.OdeQuadTreeSpace", false, false);
          LPoint3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
          LVecBase3f const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            OdeQuadTreeSpace *return_value = new OdeQuadTreeSpace(*param0_this, *param1_this, *param2_this, (int const)param3);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_OdeQuadTreeSpace(PyObject *args, OdeQuadTreeSpace *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeQuadTreeSpace, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 3: {
        // 1-OdeQuadTreeSpace::OdeQuadTreeSpace(LPoint3f const &center, LVecBase3f const &extents, int const depth)
        PyObject *param0;
        PyObject *param1;
        int param2;
        if (PyArg_ParseTuple(args, "OOi:OdeQuadTreeSpace", &param0, &param1, &param2)) {
          LPoint3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          LVecBase3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            OdeQuadTreeSpace *return_value = new OdeQuadTreeSpace(*param0_this, *param1_this, (int const)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-OdeQuadTreeSpace::OdeQuadTreeSpace(OdeSpace &space, LPoint3f const &center, LVecBase3f const &extents, int const depth)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3;
        if (PyArg_ParseTuple(args, "OOOi:OdeQuadTreeSpace", &param0, &param1, &param2, &param3)) {
          OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeQuadTreeSpace.OdeQuadTreeSpace", false, false);
          LPoint3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
          LVecBase3f const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            OdeQuadTreeSpace *return_value = new OdeQuadTreeSpace(*param0_this, *param1_this, *param2_this, (int const)param3);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeQuadTreeSpace(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeQuadTreeSpace) {
    printf("OdeQuadTreeSpace ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeQuadTreeSpace *local_this = (OdeQuadTreeSpace *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeQuadTreeSpace) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeSpace) {
    return (OdeSpace *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeSpace *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeQuadTreeSpace(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeQuadTreeSpace) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeSpace) {
    OdeSpace* other_this = (OdeSpace*)from_this;
    return (OdeQuadTreeSpace*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeQuadTreeSpace*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeRayGeom
 */
/**
 * Python function wrapper for:
 * inline void OdeRayGeom::set_length(dReal length)
 */
static PyObject *Dtool_OdeRayGeom_set_length_531(PyObject *self, PyObject *arg) {
  OdeRayGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeRayGeom, (void **)&local_this, "OdeRayGeom.set_length")) {
    return NULL;
  }
  // 1-inline void OdeRayGeom::set_length(dReal length)
  if (PyNumber_Check(arg)) {
    (*local_this).set_length((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_length(const OdeRayGeom self, float length)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_set_length_531_comment =
  "C++ Interface:\n"
  "set_length(const OdeRayGeom self, float length)\n";
#else
static const char *Dtool_OdeRayGeom_set_length_531_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeRayGeom::get_length(void)
 */
static PyObject *Dtool_OdeRayGeom_get_length_532(PyObject *self, PyObject *) {
  OdeRayGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeRayGeom, (void **)&local_this, "OdeRayGeom.get_length")) {
    return NULL;
  }
  // 1-inline dReal OdeRayGeom::get_length(void)
  dReal return_value = (*local_this).get_length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_get_length_532_comment =
  "C++ Interface:\n"
  "get_length(const OdeRayGeom self)\n";
#else
static const char *Dtool_OdeRayGeom_get_length_532_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeRayGeom::set(LVecBase3f const &start, LVecBase3f const &dir)
 * inline void OdeRayGeom::set(dReal px, dReal py, dReal pz, dReal dx, dReal dy, dReal dz)
 */
static PyObject *Dtool_OdeRayGeom_set_533(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeRayGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeRayGeom, (void **)&local_this, "OdeRayGeom.set")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void OdeRayGeom::set(LVecBase3f const &start, LVecBase3f const &dir)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"start", "dir", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "OdeRayGeom.set", "LVecBase3f");
        }
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeRayGeom.set", "LVecBase3f");
        }
        (*local_this).set(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void OdeRayGeom::set(dReal px, dReal py, dReal pz, dReal dx, dReal dy, dReal dz)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"px", "py", "pz", "dx", "dy", "dz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:set", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        (*local_this).set((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4, (dReal)param5, (dReal)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const OdeRayGeom self, const LVecBase3f start, const LVecBase3f dir)\n"
      "set(const OdeRayGeom self, float px, float py, float pz, float dx, float dy, float dz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_set_533_comment =
  "C++ Interface:\n"
  "set(const OdeRayGeom self, const LVecBase3f start, const LVecBase3f dir)\n"
  "set(const OdeRayGeom self, float px, float py, float pz, float dx, float dy, float dz)\n";
#else
static const char *Dtool_OdeRayGeom_set_533_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeRayGeom::get(LVecBase3f &start, LVecBase3f &dir) const
 */
static PyObject *Dtool_OdeRayGeom_get_534(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeRayGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeRayGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void OdeRayGeom::get(LVecBase3f &start, LVecBase3f &dir) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"start", "dir", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param1_local;
    LVecBase3f *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "OdeRayGeom.get", "LVecBase3f");
    }
    LVecBase3f param2_local;
    LVecBase3f *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "OdeRayGeom.get", "LVecBase3f");
    }
    (*(const OdeRayGeom*)local_this).get(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get(OdeRayGeom self, LVecBase3f start, LVecBase3f dir)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_get_534_comment =
  "C++ Interface:\n"
  "get(OdeRayGeom self, LVecBase3f start, LVecBase3f dir)\n";
#else
static const char *Dtool_OdeRayGeom_get_534_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeRayGeom::get_start(void) const
 */
static PyObject *Dtool_OdeRayGeom_get_start_535(PyObject *self, PyObject *) {
  OdeRayGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeRayGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeRayGeom::get_start(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeRayGeom*)local_this).get_start());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_get_start_535_comment =
  "C++ Interface:\n"
  "get_start(OdeRayGeom self)\n";
#else
static const char *Dtool_OdeRayGeom_get_start_535_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeRayGeom::get_direction(void) const
 */
static PyObject *Dtool_OdeRayGeom_get_direction_536(PyObject *self, PyObject *) {
  OdeRayGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeRayGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeRayGeom::get_direction(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeRayGeom*)local_this).get_direction());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_get_direction_536_comment =
  "C++ Interface:\n"
  "get_direction(OdeRayGeom self)\n";
#else
static const char *Dtool_OdeRayGeom_get_direction_536_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeRayGeom::set_params(int first_contact, int backface_cull)
 */
static PyObject *Dtool_OdeRayGeom_set_params_537(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeRayGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeRayGeom, (void **)&local_this, "OdeRayGeom.set_params")) {
    return NULL;
  }
  // 1-inline void OdeRayGeom::set_params(int first_contact, int backface_cull)
  int param1;
  int param2;
  static const char *keyword_list[] = {"first_contact", "backface_cull", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_params", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_params((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_params(const OdeRayGeom self, int first_contact, int backface_cull)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_set_params_537_comment =
  "C++ Interface:\n"
  "set_params(const OdeRayGeom self, int first_contact, int backface_cull)\n";
#else
static const char *Dtool_OdeRayGeom_set_params_537_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeRayGeom::get_first_contact(void) const
 */
static PyObject *Dtool_OdeRayGeom_get_first_contact_539(PyObject *self, PyObject *) {
  OdeRayGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeRayGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeRayGeom::get_first_contact(void) const
  int return_value = (*(const OdeRayGeom*)local_this).get_first_contact();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_get_first_contact_539_comment =
  "C++ Interface:\n"
  "get_first_contact(OdeRayGeom self)\n";
#else
static const char *Dtool_OdeRayGeom_get_first_contact_539_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeRayGeom::get_backface_cull(void) const
 */
static PyObject *Dtool_OdeRayGeom_get_backface_cull_540(PyObject *self, PyObject *) {
  OdeRayGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeRayGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeRayGeom::get_backface_cull(void) const
  int return_value = (*(const OdeRayGeom*)local_this).get_backface_cull();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_get_backface_cull_540_comment =
  "C++ Interface:\n"
  "get_backface_cull(OdeRayGeom self)\n";
#else
static const char *Dtool_OdeRayGeom_get_backface_cull_540_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeRayGeom::set_closest_hit(int closest_hit)
 */
static PyObject *Dtool_OdeRayGeom_set_closest_hit_541(PyObject *self, PyObject *arg) {
  OdeRayGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeRayGeom, (void **)&local_this, "OdeRayGeom.set_closest_hit")) {
    return NULL;
  }
  // 1-inline void OdeRayGeom::set_closest_hit(int closest_hit)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_closest_hit((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_closest_hit(const OdeRayGeom self, int closest_hit)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_set_closest_hit_541_comment =
  "C++ Interface:\n"
  "set_closest_hit(const OdeRayGeom self, int closest_hit)\n";
#else
static const char *Dtool_OdeRayGeom_set_closest_hit_541_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeRayGeom::get_closest_hit(void)
 */
static PyObject *Dtool_OdeRayGeom_get_closest_hit_542(PyObject *self, PyObject *) {
  OdeRayGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeRayGeom, (void **)&local_this, "OdeRayGeom.get_closest_hit")) {
    return NULL;
  }
  // 1-inline int OdeRayGeom::get_closest_hit(void)
  int return_value = (*local_this).get_closest_hit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_get_closest_hit_542_comment =
  "C++ Interface:\n"
  "get_closest_hit(const OdeRayGeom self)\n";
#else
static const char *Dtool_OdeRayGeom_get_closest_hit_542_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeRayGeom::get_class_type(void)
 */
static PyObject *Dtool_OdeRayGeom_get_class_type_543(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeRayGeom::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeRayGeom::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_get_class_type_543_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeRayGeom_get_class_type_543_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeRayGeom::OdeRayGeom(OdeRayGeom const &) = default
 * OdeRayGeom::OdeRayGeom(OdeSpace &space, dReal length)
 * OdeRayGeom::OdeRayGeom(dReal length)
 */
static int Dtool_Init_OdeRayGeom(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline OdeRayGeom::OdeRayGeom(OdeRayGeom const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeRayGeom", (char **)keyword_list, &param0)) {
          OdeRayGeom const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_OdeRayGeom, (void **)&param0_this);
          if (param0_this != NULL) {
            OdeRayGeom *return_value = new OdeRayGeom(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeRayGeom, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdeRayGeom::OdeRayGeom(dReal length)
        float param0;
        static const char *keyword_list[] = {"length", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f:OdeRayGeom", (char **)keyword_list, &param0)) {
          OdeRayGeom *return_value = new OdeRayGeom((dReal)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeRayGeom, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline OdeRayGeom::OdeRayGeom(OdeRayGeom const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeRayGeom", (char **)keyword_list, &param0)) {
          OdeRayGeom const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_OdeRayGeom(param0, param0_this, param0_manage)) {
            OdeRayGeom *return_value = new OdeRayGeom(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeRayGeom, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: OdeRayGeom::OdeRayGeom(dReal length)
    }
    break;
  case 2:
    {
      // 1-OdeRayGeom::OdeRayGeom(OdeSpace &space, dReal length)
      PyObject *param0;
      float param1;
      static const char *keyword_list[] = {"space", "length", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:OdeRayGeom", (char **)keyword_list, &param0, &param1)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeRayGeom.OdeRayGeom", false, true);
        if (param0_this != NULL) {
          OdeRayGeom *return_value = new OdeRayGeom(*param0_this, (dReal)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeRayGeom, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeRayGeom() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeRayGeom(const OdeRayGeom param0)\n"
      "OdeRayGeom(float length)\n"
      "OdeRayGeom(OdeSpace space, float length)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeRayGeom(PyObject *args, OdeRayGeom const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeRayGeom, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeRayGeom::OdeRayGeom(dReal length)
    if (PyNumber_Check(arg)) {
      OdeRayGeom *return_value = new OdeRayGeom((dReal)PyFloat_AsDouble(arg));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeRayGeom::OdeRayGeom(OdeSpace &space, dReal length)
      PyObject *param0;
      float param1;
      if (PyArg_ParseTuple(args, "Of:OdeRayGeom", &param0, &param1)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeRayGeom.OdeRayGeom", false, false);
        if (param0_this != NULL) {
          OdeRayGeom *return_value = new OdeRayGeom(*param0_this, (dReal)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OdeRayGeom(PyObject *args, OdeRayGeom *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeRayGeom, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeRayGeom::OdeRayGeom(dReal length)
    if (PyNumber_Check(arg)) {
      OdeRayGeom *return_value = new OdeRayGeom((dReal)PyFloat_AsDouble(arg));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeRayGeom::OdeRayGeom(OdeSpace &space, dReal length)
      PyObject *param0;
      float param1;
      if (PyArg_ParseTuple(args, "Of:OdeRayGeom", &param0, &param1)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeRayGeom.OdeRayGeom", false, false);
        if (param0_this != NULL) {
          OdeRayGeom *return_value = new OdeRayGeom(*param0_this, (dReal)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeRayGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeRayGeom) {
    printf("OdeRayGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeRayGeom *local_this = (OdeRayGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeRayGeom) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeGeom) {
    return (OdeGeom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeGeom *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeRayGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeRayGeom) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeGeom) {
    OdeGeom* other_this = (OdeGeom*)from_this;
    return (OdeRayGeom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeRayGeom*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeSimpleSpace
 */
/**
 * Python function wrapper for:
 * static TypeHandle OdeSimpleSpace::get_class_type(void)
 */
static PyObject *Dtool_OdeSimpleSpace_get_class_type_546(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeSimpleSpace::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeSimpleSpace::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeSimpleSpace_get_class_type_546_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeSimpleSpace_get_class_type_546_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeSimpleSpace::OdeSimpleSpace(void)
 * inline OdeSimpleSpace::OdeSimpleSpace(OdeSimpleSpace const &) = default
 * OdeSimpleSpace::OdeSimpleSpace(OdeSpace &space)
 */
static int Dtool_Init_OdeSimpleSpace(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-OdeSimpleSpace::OdeSimpleSpace(void)
      OdeSimpleSpace *return_value = new OdeSimpleSpace();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSimpleSpace, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline OdeSimpleSpace::OdeSimpleSpace(OdeSimpleSpace const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeSimpleSpace", (char **)keyword_list, &param0)) {
          OdeSimpleSpace const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_OdeSimpleSpace, (void **)&param0_this);
          if (param0_this != NULL) {
            OdeSimpleSpace *return_value = new OdeSimpleSpace(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSimpleSpace, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdeSimpleSpace::OdeSimpleSpace(OdeSpace &space)
        PyObject *param0;
        static const char *keyword_list[] = {"space", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeSimpleSpace", (char **)keyword_list, &param0)) {
          OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeSimpleSpace.OdeSimpleSpace", false, false);
          if (param0_this != NULL) {
            OdeSimpleSpace *return_value = new OdeSimpleSpace(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSimpleSpace, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline OdeSimpleSpace::OdeSimpleSpace(OdeSimpleSpace const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeSimpleSpace", (char **)keyword_list, &param0)) {
          OdeSimpleSpace const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_OdeSimpleSpace(param0, param0_this, param0_manage)) {
            OdeSimpleSpace *return_value = new OdeSimpleSpace(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSimpleSpace, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: OdeSimpleSpace::OdeSimpleSpace(OdeSpace &space)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeSimpleSpace() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeSimpleSpace()\n"
      "OdeSimpleSpace(const OdeSimpleSpace param0)\n"
      "OdeSimpleSpace(OdeSpace space)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeSimpleSpace(PyObject *args, OdeSimpleSpace const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeSimpleSpace, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeSimpleSpace::OdeSimpleSpace(OdeSpace &space)
    OdeSpace *arg_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeSpace, 0, "OdeSimpleSpace.OdeSimpleSpace", false, false);
    if (arg_this != NULL) {
      OdeSimpleSpace *return_value = new OdeSimpleSpace(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_OdeSimpleSpace(PyObject *args, OdeSimpleSpace *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeSimpleSpace, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeSimpleSpace::OdeSimpleSpace(OdeSpace &space)
    OdeSpace *arg_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeSpace, 0, "OdeSimpleSpace.OdeSimpleSpace", false, false);
    if (arg_this != NULL) {
      OdeSimpleSpace *return_value = new OdeSimpleSpace(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_OdeSimpleSpace(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeSimpleSpace) {
    printf("OdeSimpleSpace ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeSimpleSpace *local_this = (OdeSimpleSpace *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeSimpleSpace) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeSpace) {
    return (OdeSpace *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeSpace *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeSimpleSpace(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeSimpleSpace) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeSpace) {
    OdeSpace* other_this = (OdeSpace*)from_this;
    return (OdeSimpleSpace*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeSimpleSpace*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeSliderJoint
 */
/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_axis(LVecBase3f const &axis)
 * inline void OdeSliderJoint::set_axis(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeSliderJoint_set_axis_549(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_axis")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "axis");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'axis' (pos 1) not found");
      }
      // 1-inline void OdeSliderJoint::set_axis(LVecBase3f const &axis)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeSliderJoint.set_axis", "LVecBase3f");
      }
      (*local_this).set_axis(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeSliderJoint::set_axis(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_axis", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_axis((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_axis() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_axis(const OdeSliderJoint self, const LVecBase3f axis)\n"
      "set_axis(const OdeSliderJoint self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_axis_549_comment =
  "C++ Interface:\n"
  "set_axis(const OdeSliderJoint self, const LVecBase3f axis)\n"
  "set_axis(const OdeSliderJoint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeSliderJoint_set_axis_549_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_axis_delta(LVecBase3f const &axis, LVecBase3f const &vec)
 * inline void OdeSliderJoint::set_axis_delta(dReal x, dReal y, dReal z, dReal ax, dReal ay, dReal az)
 */
static PyObject *Dtool_OdeSliderJoint_set_axis_delta_550(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_axis_delta")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void OdeSliderJoint::set_axis_delta(LVecBase3f const &axis, LVecBase3f const &vec)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"axis", "vec", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_axis_delta", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "OdeSliderJoint.set_axis_delta", "LVecBase3f");
        }
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeSliderJoint.set_axis_delta", "LVecBase3f");
        }
        (*local_this).set_axis_delta(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void OdeSliderJoint::set_axis_delta(dReal x, dReal y, dReal z, dReal ax, dReal ay, dReal az)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"x", "y", "z", "ax", "ay", "az", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:set_axis_delta", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        (*local_this).set_axis_delta((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4, (dReal)param5, (dReal)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_axis_delta() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_axis_delta(const OdeSliderJoint self, const LVecBase3f axis, const LVecBase3f vec)\n"
      "set_axis_delta(const OdeSliderJoint self, float x, float y, float z, float ax, float ay, float az)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_axis_delta_550_comment =
  "C++ Interface:\n"
  "set_axis_delta(const OdeSliderJoint self, const LVecBase3f axis, const LVecBase3f vec)\n"
  "set_axis_delta(const OdeSliderJoint self, float x, float y, float z, float ax, float ay, float az)\n";
#else
static const char *Dtool_OdeSliderJoint_set_axis_delta_550_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::add_force(dReal force)
 */
static PyObject *Dtool_OdeSliderJoint_add_force_551(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.add_force")) {
    return NULL;
  }
  // 1-inline void OdeSliderJoint::add_force(dReal force)
  if (PyNumber_Check(arg)) {
    (*local_this).add_force((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_force(const OdeSliderJoint self, float force)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_add_force_551_comment =
  "C++ Interface:\n"
  "add_force(const OdeSliderJoint self, float force)\n";
#else
static const char *Dtool_OdeSliderJoint_add_force_551_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_position(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_position_552(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSliderJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSliderJoint::get_position(void) const
  dReal return_value = (*(const OdeSliderJoint*)local_this).get_position();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_position_552_comment =
  "C++ Interface:\n"
  "get_position(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_position_552_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_position_rate(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_position_rate_553(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSliderJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSliderJoint::get_position_rate(void) const
  dReal return_value = (*(const OdeSliderJoint*)local_this).get_position_rate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_position_rate_553_comment =
  "C++ Interface:\n"
  "get_position_rate(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_position_rate_553_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeSliderJoint::get_axis(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_axis_554(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSliderJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeSliderJoint::get_axis(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeSliderJoint*)local_this).get_axis());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_axis_554_comment =
  "C++ Interface:\n"
  "get_axis(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_axis_554_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_param_lo_stop(dReal val)
 */
static PyObject *Dtool_OdeSliderJoint_set_param_lo_stop_555(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_param_lo_stop")) {
    return NULL;
  }
  // 1-inline void OdeSliderJoint::set_param_lo_stop(dReal val)
  if (PyNumber_Check(arg)) {
    (*local_this).set_param_lo_stop((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_lo_stop(const OdeSliderJoint self, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_param_lo_stop_555_comment =
  "C++ Interface:\n"
  "set_param_lo_stop(const OdeSliderJoint self, float val)\n";
#else
static const char *Dtool_OdeSliderJoint_set_param_lo_stop_555_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_param_hi_stop(dReal val)
 */
static PyObject *Dtool_OdeSliderJoint_set_param_hi_stop_556(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_param_hi_stop")) {
    return NULL;
  }
  // 1-inline void OdeSliderJoint::set_param_hi_stop(dReal val)
  if (PyNumber_Check(arg)) {
    (*local_this).set_param_hi_stop((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_hi_stop(const OdeSliderJoint self, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_param_hi_stop_556_comment =
  "C++ Interface:\n"
  "set_param_hi_stop(const OdeSliderJoint self, float val)\n";
#else
static const char *Dtool_OdeSliderJoint_set_param_hi_stop_556_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_param_vel(dReal val)
 */
static PyObject *Dtool_OdeSliderJoint_set_param_vel_557(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_param_vel")) {
    return NULL;
  }
  // 1-inline void OdeSliderJoint::set_param_vel(dReal val)
  if (PyNumber_Check(arg)) {
    (*local_this).set_param_vel((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_vel(const OdeSliderJoint self, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_param_vel_557_comment =
  "C++ Interface:\n"
  "set_param_vel(const OdeSliderJoint self, float val)\n";
#else
static const char *Dtool_OdeSliderJoint_set_param_vel_557_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_param_f_max(dReal val)
 */
static PyObject *Dtool_OdeSliderJoint_set_param_f_max_558(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_param_f_max")) {
    return NULL;
  }
  // 1-inline void OdeSliderJoint::set_param_f_max(dReal val)
  if (PyNumber_Check(arg)) {
    (*local_this).set_param_f_max((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_f_max(const OdeSliderJoint self, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_param_f_max_558_comment =
  "C++ Interface:\n"
  "set_param_f_max(const OdeSliderJoint self, float val)\n";
#else
static const char *Dtool_OdeSliderJoint_set_param_f_max_558_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_param_fudge_factor(dReal val)
 */
static PyObject *Dtool_OdeSliderJoint_set_param_fudge_factor_559(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_param_fudge_factor")) {
    return NULL;
  }
  // 1-inline void OdeSliderJoint::set_param_fudge_factor(dReal val)
  if (PyNumber_Check(arg)) {
    (*local_this).set_param_fudge_factor((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_fudge_factor(const OdeSliderJoint self, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_param_fudge_factor_559_comment =
  "C++ Interface:\n"
  "set_param_fudge_factor(const OdeSliderJoint self, float val)\n";
#else
static const char *Dtool_OdeSliderJoint_set_param_fudge_factor_559_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_param_bounce(dReal val)
 */
static PyObject *Dtool_OdeSliderJoint_set_param_bounce_560(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_param_bounce")) {
    return NULL;
  }
  // 1-inline void OdeSliderJoint::set_param_bounce(dReal val)
  if (PyNumber_Check(arg)) {
    (*local_this).set_param_bounce((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_bounce(const OdeSliderJoint self, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_param_bounce_560_comment =
  "C++ Interface:\n"
  "set_param_bounce(const OdeSliderJoint self, float val)\n";
#else
static const char *Dtool_OdeSliderJoint_set_param_bounce_560_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_param_CFM(dReal val)
 */
static PyObject *Dtool_OdeSliderJoint_set_param_CFM_561(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_param_CFM")) {
    return NULL;
  }
  // 1-inline void OdeSliderJoint::set_param_CFM(dReal val)
  if (PyNumber_Check(arg)) {
    (*local_this).set_param_CFM((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_CFM(const OdeSliderJoint self, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_param_CFM_561_comment =
  "C++ Interface:\n"
  "set_param_CFM(const OdeSliderJoint self, float val)\n";
#else
static const char *Dtool_OdeSliderJoint_set_param_CFM_561_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_param_stop_ERP(dReal val)
 */
static PyObject *Dtool_OdeSliderJoint_set_param_stop_ERP_562(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_param_stop_ERP")) {
    return NULL;
  }
  // 1-inline void OdeSliderJoint::set_param_stop_ERP(dReal val)
  if (PyNumber_Check(arg)) {
    (*local_this).set_param_stop_ERP((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_ERP(const OdeSliderJoint self, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_param_stop_ERP_562_comment =
  "C++ Interface:\n"
  "set_param_stop_ERP(const OdeSliderJoint self, float val)\n";
#else
static const char *Dtool_OdeSliderJoint_set_param_stop_ERP_562_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_param_stop_CFM(dReal val)
 */
static PyObject *Dtool_OdeSliderJoint_set_param_stop_CFM_563(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_param_stop_CFM")) {
    return NULL;
  }
  // 1-inline void OdeSliderJoint::set_param_stop_CFM(dReal val)
  if (PyNumber_Check(arg)) {
    (*local_this).set_param_stop_CFM((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_CFM(const OdeSliderJoint self, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_param_stop_CFM_563_comment =
  "C++ Interface:\n"
  "set_param_stop_CFM(const OdeSliderJoint self, float val)\n";
#else
static const char *Dtool_OdeSliderJoint_set_param_stop_CFM_563_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_param_lo_stop(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_param_lo_stop_564(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSliderJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSliderJoint::get_param_lo_stop(void) const
  dReal return_value = (*(const OdeSliderJoint*)local_this).get_param_lo_stop();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_param_lo_stop_564_comment =
  "C++ Interface:\n"
  "get_param_lo_stop(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_param_lo_stop_564_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_param_hi_stop(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_param_hi_stop_565(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSliderJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSliderJoint::get_param_hi_stop(void) const
  dReal return_value = (*(const OdeSliderJoint*)local_this).get_param_hi_stop();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_param_hi_stop_565_comment =
  "C++ Interface:\n"
  "get_param_hi_stop(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_param_hi_stop_565_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_param_vel(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_param_vel_566(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSliderJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSliderJoint::get_param_vel(void) const
  dReal return_value = (*(const OdeSliderJoint*)local_this).get_param_vel();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_param_vel_566_comment =
  "C++ Interface:\n"
  "get_param_vel(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_param_vel_566_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_param_f_max(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_param_f_max_567(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSliderJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSliderJoint::get_param_f_max(void) const
  dReal return_value = (*(const OdeSliderJoint*)local_this).get_param_f_max();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_param_f_max_567_comment =
  "C++ Interface:\n"
  "get_param_f_max(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_param_f_max_567_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_param_fudge_factor(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_param_fudge_factor_568(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSliderJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSliderJoint::get_param_fudge_factor(void) const
  dReal return_value = (*(const OdeSliderJoint*)local_this).get_param_fudge_factor();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_param_fudge_factor_568_comment =
  "C++ Interface:\n"
  "get_param_fudge_factor(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_param_fudge_factor_568_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_param_bounce(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_param_bounce_569(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSliderJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSliderJoint::get_param_bounce(void) const
  dReal return_value = (*(const OdeSliderJoint*)local_this).get_param_bounce();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_param_bounce_569_comment =
  "C++ Interface:\n"
  "get_param_bounce(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_param_bounce_569_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_param_CFM(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_param_CFM_570(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSliderJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSliderJoint::get_param_CFM(void) const
  dReal return_value = (*(const OdeSliderJoint*)local_this).get_param_CFM();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_param_CFM_570_comment =
  "C++ Interface:\n"
  "get_param_CFM(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_param_CFM_570_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_param_stop_ERP(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_param_stop_ERP_571(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSliderJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSliderJoint::get_param_stop_ERP(void) const
  dReal return_value = (*(const OdeSliderJoint*)local_this).get_param_stop_ERP();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_param_stop_ERP_571_comment =
  "C++ Interface:\n"
  "get_param_stop_ERP(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_param_stop_ERP_571_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_param_stop_CFM(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_param_stop_CFM_572(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSliderJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSliderJoint::get_param_stop_CFM(void) const
  dReal return_value = (*(const OdeSliderJoint*)local_this).get_param_stop_CFM();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_param_stop_CFM_572_comment =
  "C++ Interface:\n"
  "get_param_stop_CFM(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_param_stop_CFM_572_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeSliderJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeSliderJoint_get_class_type_573(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeSliderJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeSliderJoint::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_class_type_573_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeSliderJoint_get_class_type_573_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeSliderJoint::OdeSliderJoint(OdeSliderJoint const &) = default
 * OdeSliderJoint::OdeSliderJoint(OdeWorld &world)
 * OdeSliderJoint::OdeSliderJoint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdeSliderJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline OdeSliderJoint::OdeSliderJoint(OdeSliderJoint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeSliderJoint", (char **)keyword_list, &param0)) {
          OdeSliderJoint const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_OdeSliderJoint, (void **)&param0_this);
          if (param0_this != NULL) {
            OdeSliderJoint *return_value = new OdeSliderJoint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSliderJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdeSliderJoint::OdeSliderJoint(OdeWorld &world)
        PyObject *param0;
        static const char *keyword_list[] = {"world", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeSliderJoint", (char **)keyword_list, &param0)) {
          OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeSliderJoint.OdeSliderJoint", false, false);
          if (param0_this != NULL) {
            OdeSliderJoint *return_value = new OdeSliderJoint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSliderJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline OdeSliderJoint::OdeSliderJoint(OdeSliderJoint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeSliderJoint", (char **)keyword_list, &param0)) {
          OdeSliderJoint const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_OdeSliderJoint(param0, param0_this, param0_manage)) {
            OdeSliderJoint *return_value = new OdeSliderJoint(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSliderJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: OdeSliderJoint::OdeSliderJoint(OdeWorld &world)
    }
    break;
  case 2:
    {
      // 1-OdeSliderJoint::OdeSliderJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeSliderJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeSliderJoint.OdeSliderJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeSliderJoint.OdeSliderJoint", false, true);
        if (param0_this != NULL && param1_this != NULL) {
          OdeSliderJoint *return_value = new OdeSliderJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSliderJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeSliderJoint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeSliderJoint(const OdeSliderJoint param0)\n"
      "OdeSliderJoint(OdeWorld world)\n"
      "OdeSliderJoint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeSliderJoint(PyObject *args, OdeSliderJoint const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeSliderJoint, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeSliderJoint::OdeSliderJoint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeSliderJoint.OdeSliderJoint", false, false);
    if (arg_this != NULL) {
      OdeSliderJoint *return_value = new OdeSliderJoint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeSliderJoint::OdeSliderJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeSliderJoint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeSliderJoint.OdeSliderJoint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeSliderJoint.OdeSliderJoint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeSliderJoint *return_value = new OdeSliderJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OdeSliderJoint(PyObject *args, OdeSliderJoint *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeSliderJoint, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeSliderJoint::OdeSliderJoint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeSliderJoint.OdeSliderJoint", false, false);
    if (arg_this != NULL) {
      OdeSliderJoint *return_value = new OdeSliderJoint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeSliderJoint::OdeSliderJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeSliderJoint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeSliderJoint.OdeSliderJoint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeSliderJoint.OdeSliderJoint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeSliderJoint *return_value = new OdeSliderJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeSliderJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeSliderJoint) {
    printf("OdeSliderJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeSliderJoint *local_this = (OdeSliderJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeSliderJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeSliderJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeSliderJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeSliderJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeSliderJoint*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeSphereGeom
 */
/**
 * Python function wrapper for:
 * inline void OdeSphereGeom::set_radius(dReal radius)
 */
static PyObject *Dtool_OdeSphereGeom_set_radius_576(PyObject *self, PyObject *arg) {
  OdeSphereGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSphereGeom, (void **)&local_this, "OdeSphereGeom.set_radius")) {
    return NULL;
  }
  // 1-inline void OdeSphereGeom::set_radius(dReal radius)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const OdeSphereGeom self, float radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSphereGeom_set_radius_576_comment =
  "C++ Interface:\n"
  "set_radius(const OdeSphereGeom self, float radius)\n";
#else
static const char *Dtool_OdeSphereGeom_set_radius_576_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSphereGeom::get_radius(void) const
 */
static PyObject *Dtool_OdeSphereGeom_get_radius_577(PyObject *self, PyObject *) {
  OdeSphereGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSphereGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeSphereGeom::get_radius(void) const
  dReal return_value = (*(const OdeSphereGeom*)local_this).get_radius();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSphereGeom_get_radius_577_comment =
  "C++ Interface:\n"
  "get_radius(OdeSphereGeom self)\n";
#else
static const char *Dtool_OdeSphereGeom_get_radius_577_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSphereGeom::get_point_depth(LPoint3f const &p) const
 * inline dReal OdeSphereGeom::get_point_depth(dReal x, dReal y, dReal z) const
 */
static PyObject *Dtool_OdeSphereGeom_get_point_depth_578(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeSphereGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSphereGeom, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "p");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'p' (pos 1) not found");
      }
      // 1-inline dReal OdeSphereGeom::get_point_depth(LPoint3f const &p) const
      LPoint3f arg_local;
      LPoint3f const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeSphereGeom.get_point_depth", "LPoint3f");
      }
      dReal return_value = (*(const OdeSphereGeom*)local_this).get_point_depth(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 3:
    {
      // 1-inline dReal OdeSphereGeom::get_point_depth(dReal x, dReal y, dReal z) const
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:get_point_depth", (char **)keyword_list, &param1, &param2, &param3)) {
        dReal return_value = (*(const OdeSphereGeom*)local_this).get_point_depth((dReal)param1, (dReal)param2, (dReal)param3);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_point_depth() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point_depth(OdeSphereGeom self, const LPoint3f p)\n"
      "get_point_depth(OdeSphereGeom self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeSphereGeom_get_point_depth_578_comment =
  "C++ Interface:\n"
  "get_point_depth(OdeSphereGeom self, const LPoint3f p)\n"
  "get_point_depth(OdeSphereGeom self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeSphereGeom_get_point_depth_578_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeSphereGeom::get_class_type(void)
 */
static PyObject *Dtool_OdeSphereGeom_get_class_type_579(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeSphereGeom::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeSphereGeom::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeSphereGeom_get_class_type_579_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeSphereGeom_get_class_type_579_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeSphereGeom::OdeSphereGeom(OdeGeom &geom)
 * OdeSphereGeom::OdeSphereGeom(OdeSpace &space, dReal radius)
 * inline OdeSphereGeom::OdeSphereGeom(OdeSphereGeom const &) = default
 * OdeSphereGeom::OdeSphereGeom(dReal radius)
 */
static int Dtool_Init_OdeSphereGeom(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline OdeSphereGeom::OdeSphereGeom(OdeSphereGeom const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeSphereGeom", (char **)keyword_list, &param0)) {
          OdeSphereGeom const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_OdeSphereGeom, (void **)&param0_this);
          if (param0_this != NULL) {
            OdeSphereGeom *return_value = new OdeSphereGeom(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSphereGeom, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdeSphereGeom::OdeSphereGeom(OdeGeom &geom)
        PyObject *param0;
        static const char *keyword_list[] = {"geom", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeSphereGeom", (char **)keyword_list, &param0)) {
          OdeGeom *param0_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeGeom, 0, "OdeSphereGeom.OdeSphereGeom", false, false);
          if (param0_this != NULL) {
            OdeSphereGeom *return_value = new OdeSphereGeom(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSphereGeom, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdeSphereGeom::OdeSphereGeom(dReal radius)
        float param0;
        static const char *keyword_list[] = {"radius", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f:OdeSphereGeom", (char **)keyword_list, &param0)) {
          OdeSphereGeom *return_value = new OdeSphereGeom((dReal)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSphereGeom, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline OdeSphereGeom::OdeSphereGeom(OdeSphereGeom const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeSphereGeom", (char **)keyword_list, &param0)) {
          OdeSphereGeom const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_OdeSphereGeom(param0, param0_this, param0_manage)) {
            OdeSphereGeom *return_value = new OdeSphereGeom(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSphereGeom, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: OdeSphereGeom::OdeSphereGeom(OdeGeom &geom)
      // No coercion possible: OdeSphereGeom::OdeSphereGeom(dReal radius)
    }
    break;
  case 2:
    {
      // 1-OdeSphereGeom::OdeSphereGeom(OdeSpace &space, dReal radius)
      PyObject *param0;
      float param1;
      static const char *keyword_list[] = {"space", "radius", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:OdeSphereGeom", (char **)keyword_list, &param0, &param1)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeSphereGeom.OdeSphereGeom", false, true);
        if (param0_this != NULL) {
          OdeSphereGeom *return_value = new OdeSphereGeom(*param0_this, (dReal)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSphereGeom, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeSphereGeom() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeSphereGeom(const OdeSphereGeom param0)\n"
      "OdeSphereGeom(OdeGeom geom)\n"
      "OdeSphereGeom(float radius)\n"
      "OdeSphereGeom(OdeSpace space, float radius)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeSphereGeom(PyObject *args, OdeSphereGeom const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeSphereGeom, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 OdeSphereGeom::OdeSphereGeom(OdeGeom &geom)
      OdeGeom *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 0, "OdeSphereGeom.OdeSphereGeom", false, false);
      if (arg_this != NULL) {
        OdeSphereGeom *return_value = new OdeSphereGeom(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

    {
      // -2 OdeSphereGeom::OdeSphereGeom(dReal radius)
      if (PyNumber_Check(arg)) {
        OdeSphereGeom *return_value = new OdeSphereGeom((dReal)PyFloat_AsDouble(arg));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeSphereGeom::OdeSphereGeom(OdeSpace &space, dReal radius)
      PyObject *param0;
      float param1;
      if (PyArg_ParseTuple(args, "Of:OdeSphereGeom", &param0, &param1)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeSphereGeom.OdeSphereGeom", false, false);
        if (param0_this != NULL) {
          OdeSphereGeom *return_value = new OdeSphereGeom(*param0_this, (dReal)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OdeSphereGeom(PyObject *args, OdeSphereGeom *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeSphereGeom, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 OdeSphereGeom::OdeSphereGeom(OdeGeom &geom)
      OdeGeom *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 0, "OdeSphereGeom.OdeSphereGeom", false, false);
      if (arg_this != NULL) {
        OdeSphereGeom *return_value = new OdeSphereGeom(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

    {
      // -2 OdeSphereGeom::OdeSphereGeom(dReal radius)
      if (PyNumber_Check(arg)) {
        OdeSphereGeom *return_value = new OdeSphereGeom((dReal)PyFloat_AsDouble(arg));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeSphereGeom::OdeSphereGeom(OdeSpace &space, dReal radius)
      PyObject *param0;
      float param1;
      if (PyArg_ParseTuple(args, "Of:OdeSphereGeom", &param0, &param1)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeSphereGeom.OdeSphereGeom", false, false);
        if (param0_this != NULL) {
          OdeSphereGeom *return_value = new OdeSphereGeom(*param0_this, (dReal)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeSphereGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeSphereGeom) {
    printf("OdeSphereGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeSphereGeom *local_this = (OdeSphereGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeSphereGeom) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeGeom) {
    return (OdeGeom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeGeom *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeSphereGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeSphereGeom) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeGeom) {
    OdeGeom* other_this = (OdeGeom*)from_this;
    return (OdeSphereGeom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeSphereGeom*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeTriMeshData
 */
/**
 * Python function wrapper for:
 * void OdeTriMeshData::destroy(void)
 */
static PyObject *Dtool_OdeTriMeshData_destroy_583(PyObject *self, PyObject *) {
  OdeTriMeshData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeTriMeshData, (void **)&local_this, "OdeTriMeshData.destroy")) {
    return NULL;
  }
  // 1-void OdeTriMeshData::destroy(void)
  (*local_this).destroy();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshData_destroy_583_comment =
  "C++ Interface:\n"
  "destroy(const OdeTriMeshData self)\n";
#else
static const char *Dtool_OdeTriMeshData_destroy_583_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void OdeTriMeshData::write(ostream &out = ::cout, unsigned int indent = 0) const
 */
static PyObject *Dtool_OdeTriMeshData_write_584(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeTriMeshData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeTriMeshData, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-virtual void OdeTriMeshData::write(ostream &out, unsigned int indent) const
      (*(const OdeTriMeshData*)local_this).write();
      return Dtool_Return_None();
    }
    break;
  case 1:
  case 2:
    {
      // 1-virtual void OdeTriMeshData::write(ostream &out, unsigned int indent = 0) const
      PyObject *param1;
      unsigned long param2 = 0;
      static const char *keyword_list[] = {"out", "indent", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write", (char **)keyword_list, &param1, &param2)) {
        ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "OdeTriMeshData.write", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param2 > UINT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %lu out of range for unsigned integer",
                              param2);
        }
#endif
        if (param1_this != NULL) {
          (*(const OdeTriMeshData*)local_this).write(*param1_this, (unsigned int)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "write() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(OdeTriMeshData self)\n"
      "write(OdeTriMeshData self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshData_write_584_comment =
  "C++ Interface:\n"
  "write(OdeTriMeshData self)\n"
  "write(OdeTriMeshData self, ostream out, int indent)\n";
#else
static const char *Dtool_OdeTriMeshData_write_584_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OdeTriMeshData::write_faces(ostream &out) const
 */
static PyObject *Dtool_OdeTriMeshData_write_faces_585(PyObject *self, PyObject *arg) {
  OdeTriMeshData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeTriMeshData, (void **)&local_this)) {
    return NULL;
  }
  // 1-void OdeTriMeshData::write_faces(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "OdeTriMeshData.write_faces", false, true);
  if (arg_this != NULL) {
    (*(const OdeTriMeshData*)local_this).write_faces(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_faces(OdeTriMeshData self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshData_write_faces_585_comment =
  "C++ Interface:\n"
  "write_faces(OdeTriMeshData self, ostream out)\n";
#else
static const char *Dtool_OdeTriMeshData_write_faces_585_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeTriMeshData::get_class_type(void)
 */
static PyObject *Dtool_OdeTriMeshData_get_class_type_586(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeTriMeshData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeTriMeshData::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshData_get_class_type_586_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeTriMeshData_get_class_type_586_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeTriMeshData::OdeTriMeshData(NodePath const &model, bool use_normals = false)
 */
static int Dtool_Init_OdeTriMeshData(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-OdeTriMeshData::OdeTriMeshData(NodePath const &model, bool use_normals = false)
  PyObject *param0;
  PyObject *param1 = Py_False;
  static const char *keyword_list[] = {"model", "use_normals", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:OdeTriMeshData", (char **)keyword_list, &param0, &param1)) {
    NodePath const *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_NodePath, 0, "OdeTriMeshData.OdeTriMeshData", true, true);
    if (param0_this != NULL) {
      OdeTriMeshData *return_value = new OdeTriMeshData(*param0_this, (PyObject_IsTrue(param1) != 0));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeTriMeshData, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeTriMeshData(const NodePath model, bool use_normals)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeTriMeshData(PyObject *args, CPT(OdeTriMeshData) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeTriMeshData, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeTriMeshData::OdeTriMeshData(NodePath const &model, bool use_normals)
    NodePath const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_NodePath, (void **)&arg_this);
    if (arg_this != NULL) {
      OdeTriMeshData *return_value = new OdeTriMeshData(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeTriMeshData::OdeTriMeshData(NodePath const &model, bool use_normals)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeTriMeshData", 2, 2, &param0, &param1)) {
        NodePath const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_NodePath, (void **)&param0_this);
        if (param0_this != NULL) {
          OdeTriMeshData *return_value = new OdeTriMeshData(*param0_this, (PyObject_IsTrue(param1) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OdeTriMeshData(PyObject *args, PT(OdeTriMeshData) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeTriMeshData, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeTriMeshData::OdeTriMeshData(NodePath const &model, bool use_normals)
    NodePath const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_NodePath, (void **)&arg_this);
    if (arg_this != NULL) {
      OdeTriMeshData *return_value = new OdeTriMeshData(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeTriMeshData::OdeTriMeshData(NodePath const &model, bool use_normals)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeTriMeshData", 2, 2, &param0, &param1)) {
        NodePath const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_NodePath, (void **)&param0_this);
        if (param0_this != NULL) {
          OdeTriMeshData *return_value = new OdeTriMeshData(*param0_this, (PyObject_IsTrue(param1) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeTriMeshData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeTriMeshData) {
    printf("OdeTriMeshData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeTriMeshData *local_this = (OdeTriMeshData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeTriMeshData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeTriMeshData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeTriMeshData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (OdeTriMeshData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeTriMeshData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (OdeTriMeshData*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeTriMeshGeom
 */
/**
 * Python function wrapper for:
 * void OdeTriMeshGeom::destroy(void)
 */
static PyObject *Dtool_OdeTriMeshGeom_destroy_589(PyObject *self, PyObject *) {
  OdeTriMeshGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeTriMeshGeom, (void **)&local_this, "OdeTriMeshGeom.destroy")) {
    return NULL;
  }
  // 1-void OdeTriMeshGeom::destroy(void)
  (*local_this).destroy();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_destroy_589_comment =
  "C++ Interface:\n"
  "destroy(const OdeTriMeshGeom self)\n";
#else
static const char *Dtool_OdeTriMeshGeom_destroy_589_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeTriMeshGeom::set_tri_mesh_data(OdeTriMeshData &data)
 */
static PyObject *Dtool_OdeTriMeshGeom_set_tri_mesh_data_590(PyObject *self, PyObject *arg) {
  OdeTriMeshGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeTriMeshGeom, (void **)&local_this, "OdeTriMeshGeom.set_tri_mesh_data")) {
    return NULL;
  }
  // 1-inline void OdeTriMeshGeom::set_tri_mesh_data(OdeTriMeshData &data)
  PT(OdeTriMeshData) arg_this;
  if (!Dtool_Coerce_OdeTriMeshData(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeTriMeshGeom.set_tri_mesh_data", "OdeTriMeshData");
  }
  (*local_this).set_tri_mesh_data(*MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tri_mesh_data(const OdeTriMeshGeom self, OdeTriMeshData data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_set_tri_mesh_data_590_comment =
  "C++ Interface:\n"
  "set_tri_mesh_data(const OdeTriMeshGeom self, OdeTriMeshData data)\n";
#else
static const char *Dtool_OdeTriMeshGeom_set_tri_mesh_data_590_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< OdeTriMeshData > OdeTriMeshGeom::get_tri_mesh_data(void) const
 */
static PyObject *Dtool_OdeTriMeshGeom_get_tri_mesh_data_591(PyObject *self, PyObject *) {
  OdeTriMeshGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeTriMeshGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PointerTo< OdeTriMeshData > OdeTriMeshGeom::get_tri_mesh_data(void) const
  PointerTo< OdeTriMeshData > return_value = (*(const OdeTriMeshGeom*)local_this).get_tri_mesh_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  OdeTriMeshData *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_OdeTriMeshData, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_get_tri_mesh_data_591_comment =
  "C++ Interface:\n"
  "get_tri_mesh_data(OdeTriMeshGeom self)\n";
#else
static const char *Dtool_OdeTriMeshGeom_get_tri_mesh_data_591_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeTriMeshGeom::set_data(OdeTriMeshData &data)
 */
static PyObject *Dtool_OdeTriMeshGeom_set_data_592(PyObject *self, PyObject *arg) {
  OdeTriMeshGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeTriMeshGeom, (void **)&local_this, "OdeTriMeshGeom.set_data")) {
    return NULL;
  }
  // 1-inline void OdeTriMeshGeom::set_data(OdeTriMeshData &data)
  PT(OdeTriMeshData) arg_this;
  if (!Dtool_Coerce_OdeTriMeshData(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeTriMeshGeom.set_data", "OdeTriMeshData");
  }
  (*local_this).set_data(*MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const OdeTriMeshGeom self, OdeTriMeshData data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_set_data_592_comment =
  "C++ Interface:\n"
  "set_data(const OdeTriMeshGeom self, OdeTriMeshData data)\n";
#else
static const char *Dtool_OdeTriMeshGeom_set_data_592_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< OdeTriMeshData > OdeTriMeshGeom::get_data(void) const
 */
static PyObject *Dtool_OdeTriMeshGeom_get_data_593(PyObject *self, PyObject *) {
  OdeTriMeshGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeTriMeshGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PointerTo< OdeTriMeshData > OdeTriMeshGeom::get_data(void) const
  PointerTo< OdeTriMeshData > return_value = (*(const OdeTriMeshGeom*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  OdeTriMeshData *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_OdeTriMeshData, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_get_data_593_comment =
  "C++ Interface:\n"
  "get_data(OdeTriMeshGeom self)\n";
#else
static const char *Dtool_OdeTriMeshGeom_get_data_593_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeTriMeshGeom::enable_TC(int geom_class, int enable)
 */
static PyObject *Dtool_OdeTriMeshGeom_enable_TC_594(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeTriMeshGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeTriMeshGeom, (void **)&local_this, "OdeTriMeshGeom.enable_TC")) {
    return NULL;
  }
  // 1-inline void OdeTriMeshGeom::enable_TC(int geom_class, int enable)
  int param1;
  int param2;
  static const char *keyword_list[] = {"geom_class", "enable", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:enable_TC", (char **)keyword_list, &param1, &param2)) {
    (*local_this).enable_TC((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "enable_TC(const OdeTriMeshGeom self, int geom_class, int enable)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_enable_TC_594_comment =
  "C++ Interface:\n"
  "enable_TC(const OdeTriMeshGeom self, int geom_class, int enable)\n";
#else
static const char *Dtool_OdeTriMeshGeom_enable_TC_594_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeTriMeshGeom::is_TC_enabled(int geom_class) const
 */
static PyObject *Dtool_OdeTriMeshGeom_is_TC_enabled_595(PyObject *self, PyObject *arg) {
  OdeTriMeshGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeTriMeshGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeTriMeshGeom::is_TC_enabled(int geom_class) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const OdeTriMeshGeom*)local_this).is_TC_enabled((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_TC_enabled(OdeTriMeshGeom self, int geom_class)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_is_TC_enabled_595_comment =
  "C++ Interface:\n"
  "is_TC_enabled(OdeTriMeshGeom self, int geom_class)\n";
#else
static const char *Dtool_OdeTriMeshGeom_is_TC_enabled_595_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeTriMeshGeom::clear_TC_cache(OdeGeom const &geom)
 */
static PyObject *Dtool_OdeTriMeshGeom_clear_TC_cache_596(PyObject *self, PyObject *arg) {
  OdeTriMeshGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeTriMeshGeom, (void **)&local_this, "OdeTriMeshGeom.clear_TC_cache")) {
    return NULL;
  }
  // 1-inline void OdeTriMeshGeom::clear_TC_cache(OdeGeom const &geom)
  OdeGeom const *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 1, "OdeTriMeshGeom.clear_TC_cache", true, true);
  if (arg_this != NULL) {
    (*local_this).clear_TC_cache(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_TC_cache(const OdeTriMeshGeom self, const OdeGeom geom)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_clear_TC_cache_596_comment =
  "C++ Interface:\n"
  "clear_TC_cache(const OdeTriMeshGeom self, const OdeGeom geom)\n";
#else
static const char *Dtool_OdeTriMeshGeom_clear_TC_cache_596_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeTriMeshGeom::get_triangle(int face_index, LPoint3f &v0, LPoint3f &v1, LPoint3f &v2) const
 */
static PyObject *Dtool_OdeTriMeshGeom_get_triangle_597(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeTriMeshGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeTriMeshGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void OdeTriMeshGeom::get_triangle(int face_index, LPoint3f &v0, LPoint3f &v1, LPoint3f &v2) const
  int param1;
  PyObject *param2;
  PyObject *param3;
  PyObject *param4;
  static const char *keyword_list[] = {"face_index", "v0", "v1", "v2", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iOOO:get_triangle", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    LPoint3f param2_local;
    LPoint3f *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "OdeTriMeshGeom.get_triangle", "LPoint3f");
    }
    LPoint3f param3_local;
    LPoint3f *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "OdeTriMeshGeom.get_triangle", "LPoint3f");
    }
    LPoint3f param4_local;
    LPoint3f *param4_this = Dtool_Coerce_LPoint3f(param4, param4_local);
    if (!(param4_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param4, 4, "OdeTriMeshGeom.get_triangle", "LPoint3f");
    }
    (*(const OdeTriMeshGeom*)local_this).get_triangle((int)param1, *param2_this, *param3_this, *param4_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_triangle(OdeTriMeshGeom self, int face_index, LPoint3f v0, LPoint3f v1, LPoint3f v2)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_get_triangle_597_comment =
  "C++ Interface:\n"
  "get_triangle(OdeTriMeshGeom self, int face_index, LPoint3f v0, LPoint3f v1, LPoint3f v2)\n";
#else
static const char *Dtool_OdeTriMeshGeom_get_triangle_597_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f OdeTriMeshGeom::get_point(int face_index, dReal u, dReal v) const
 */
static PyObject *Dtool_OdeTriMeshGeom_get_point_598(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeTriMeshGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeTriMeshGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3f OdeTriMeshGeom::get_point(int face_index, dReal u, dReal v) const
  int param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"face_index", "u", "v", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iff:get_point", (char **)keyword_list, &param1, &param2, &param3)) {
    LPoint3f *return_value = new LPoint3f((*(const OdeTriMeshGeom*)local_this).get_point((int)param1, (dReal)param2, (dReal)param3));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(OdeTriMeshGeom self, int face_index, float u, float v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_get_point_598_comment =
  "C++ Interface:\n"
  "get_point(OdeTriMeshGeom self, int face_index, float u, float v)\n";
#else
static const char *Dtool_OdeTriMeshGeom_get_point_598_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int OdeTriMeshGeom::get_num_triangles(void) const
 */
static PyObject *Dtool_OdeTriMeshGeom_get_num_triangles_599(PyObject *self, PyObject *) {
  OdeTriMeshGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeTriMeshGeom, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int OdeTriMeshGeom::get_num_triangles(void) const
  int return_value = (*(const OdeTriMeshGeom*)local_this).get_num_triangles();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_get_num_triangles_599_comment =
  "C++ Interface:\n"
  "get_num_triangles(OdeTriMeshGeom self)\n";
#else
static const char *Dtool_OdeTriMeshGeom_get_num_triangles_599_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeTriMeshGeom::get_class_type(void)
 */
static PyObject *Dtool_OdeTriMeshGeom_get_class_type_600(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeTriMeshGeom::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeTriMeshGeom::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_get_class_type_600_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeTriMeshGeom_get_class_type_600_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OdeTriMeshGeom::OdeTriMeshGeom(OdeSpace &space, OdeTriMeshData &data)
 * OdeTriMeshGeom::OdeTriMeshGeom(OdeTriMeshData &data)
 * OdeTriMeshGeom::OdeTriMeshGeom(OdeTriMeshGeom const &copy)
 */
static int Dtool_Init_OdeTriMeshGeom(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 OdeTriMeshGeom::OdeTriMeshGeom(OdeTriMeshGeom const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeTriMeshGeom", (char **)keyword_list, &param0)) {
          OdeTriMeshGeom const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_OdeTriMeshGeom, (void **)&param0_this);
          if (param0_this != NULL) {
            OdeTriMeshGeom *return_value = new OdeTriMeshGeom(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeTriMeshGeom, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdeTriMeshGeom::OdeTriMeshGeom(OdeTriMeshData &data)
        PyObject *param0;
        static const char *keyword_list[] = {"data", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeTriMeshGeom", (char **)keyword_list, &param0)) {
          OdeTriMeshData *param0_this = (OdeTriMeshData *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeTriMeshData, 0, "OdeTriMeshGeom.OdeTriMeshGeom", false, false);
          if (param0_this != NULL) {
            OdeTriMeshGeom *return_value = new OdeTriMeshGeom(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeTriMeshGeom, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdeTriMeshGeom::OdeTriMeshGeom(OdeTriMeshGeom const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeTriMeshGeom", (char **)keyword_list, &param0)) {
          OdeTriMeshGeom const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_OdeTriMeshGeom(param0, param0_this, param0_manage)) {
            OdeTriMeshGeom *return_value = new OdeTriMeshGeom(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeTriMeshGeom, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdeTriMeshGeom::OdeTriMeshGeom(OdeTriMeshData &data)
        PyObject *param0;
        static const char *keyword_list[] = {"data", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeTriMeshGeom", (char **)keyword_list, &param0)) {
          PT(OdeTriMeshData) param0_this;
          if (Dtool_Coerce_OdeTriMeshData(param0, param0_this)) {
            OdeTriMeshGeom *return_value = new OdeTriMeshGeom(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeTriMeshGeom, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-OdeTriMeshGeom::OdeTriMeshGeom(OdeSpace &space, OdeTriMeshData &data)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"space", "data", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeTriMeshGeom", (char **)keyword_list, &param0, &param1)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeTriMeshGeom.OdeTriMeshGeom", false, true);
        PT(OdeTriMeshData) param1_this;
        if (!Dtool_Coerce_OdeTriMeshData(param1, param1_this)) {
          Dtool_Raise_ArgTypeError(param1, 1, "OdeTriMeshGeom.OdeTriMeshGeom", "OdeTriMeshData");
          return -1;
        }
        if (param0_this != NULL) {
          OdeTriMeshGeom *return_value = new OdeTriMeshGeom(*param0_this, *MOVE(param1_this));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeTriMeshGeom, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeTriMeshGeom() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeTriMeshGeom(const OdeTriMeshGeom copy)\n"
      "OdeTriMeshGeom(OdeTriMeshData data)\n"
      "OdeTriMeshGeom(OdeSpace space, OdeTriMeshData data)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeTriMeshGeom(PyObject *args, OdeTriMeshGeom const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeTriMeshGeom, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeTriMeshGeom::OdeTriMeshGeom(OdeTriMeshData &data)
    OdeTriMeshData *arg_this = (OdeTriMeshData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeTriMeshData, 0, "OdeTriMeshGeom.OdeTriMeshGeom", false, false);
    if (arg_this != NULL) {
      OdeTriMeshGeom *return_value = new OdeTriMeshGeom(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeTriMeshGeom::OdeTriMeshGeom(OdeSpace &space, OdeTriMeshData &data)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeTriMeshGeom", 2, 2, &param0, &param1)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeTriMeshGeom.OdeTriMeshGeom", false, false);
        OdeTriMeshData *param1_this = (OdeTriMeshData *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeTriMeshData, 1, "OdeTriMeshGeom.OdeTriMeshGeom", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeTriMeshGeom *return_value = new OdeTriMeshGeom(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OdeTriMeshGeom(PyObject *args, OdeTriMeshGeom *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeTriMeshGeom, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeTriMeshGeom::OdeTriMeshGeom(OdeTriMeshData &data)
    OdeTriMeshData *arg_this = (OdeTriMeshData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeTriMeshData, 0, "OdeTriMeshGeom.OdeTriMeshGeom", false, false);
    if (arg_this != NULL) {
      OdeTriMeshGeom *return_value = new OdeTriMeshGeom(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeTriMeshGeom::OdeTriMeshGeom(OdeSpace &space, OdeTriMeshData &data)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeTriMeshGeom", 2, 2, &param0, &param1)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeTriMeshGeom.OdeTriMeshGeom", false, false);
        OdeTriMeshData *param1_this = (OdeTriMeshData *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeTriMeshData, 1, "OdeTriMeshGeom.OdeTriMeshGeom", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeTriMeshGeom *return_value = new OdeTriMeshGeom(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeTriMeshGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeTriMeshGeom) {
    printf("OdeTriMeshGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeTriMeshGeom *local_this = (OdeTriMeshGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeTriMeshGeom) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeGeom) {
    return (OdeGeom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeGeom *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeTriMeshGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeTriMeshGeom) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeGeom) {
    OdeGeom* other_this = (OdeGeom*)from_this;
    return (OdeTriMeshGeom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeTriMeshGeom*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeUniversalJoint
 */
/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_anchor(LVecBase3f const &anchor)
 * inline void OdeUniversalJoint::set_anchor(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeUniversalJoint_set_anchor_603(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_anchor")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "anchor");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'anchor' (pos 1) not found");
      }
      // 1-inline void OdeUniversalJoint::set_anchor(LVecBase3f const &anchor)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeUniversalJoint.set_anchor", "LVecBase3f");
      }
      (*local_this).set_anchor(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeUniversalJoint::set_anchor(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_anchor", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_anchor((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_anchor() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anchor(const OdeUniversalJoint self, const LVecBase3f anchor)\n"
      "set_anchor(const OdeUniversalJoint self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_anchor_603_comment =
  "C++ Interface:\n"
  "set_anchor(const OdeUniversalJoint self, const LVecBase3f anchor)\n"
  "set_anchor(const OdeUniversalJoint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_anchor_603_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_axis1(LVecBase3f const &axis)
 * inline void OdeUniversalJoint::set_axis1(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeUniversalJoint_set_axis1_604(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_axis1")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "axis");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'axis' (pos 1) not found");
      }
      // 1-inline void OdeUniversalJoint::set_axis1(LVecBase3f const &axis)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeUniversalJoint.set_axis1", "LVecBase3f");
      }
      (*local_this).set_axis1(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeUniversalJoint::set_axis1(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_axis1", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_axis1((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_axis1() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_axis1(const OdeUniversalJoint self, const LVecBase3f axis)\n"
      "set_axis1(const OdeUniversalJoint self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_axis1_604_comment =
  "C++ Interface:\n"
  "set_axis1(const OdeUniversalJoint self, const LVecBase3f axis)\n"
  "set_axis1(const OdeUniversalJoint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_axis1_604_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_axis2(LVecBase3f const &axis)
 * inline void OdeUniversalJoint::set_axis2(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeUniversalJoint_set_axis2_605(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_axis2")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "axis");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'axis' (pos 1) not found");
      }
      // 1-inline void OdeUniversalJoint::set_axis2(LVecBase3f const &axis)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "OdeUniversalJoint.set_axis2", "LVecBase3f");
      }
      (*local_this).set_axis2(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void OdeUniversalJoint::set_axis2(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_axis2", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_axis2((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_axis2() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_axis2(const OdeUniversalJoint self, const LVecBase3f axis)\n"
      "set_axis2(const OdeUniversalJoint self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_axis2_605_comment =
  "C++ Interface:\n"
  "set_axis2(const OdeUniversalJoint self, const LVecBase3f axis)\n"
  "set_axis2(const OdeUniversalJoint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_axis2_605_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::add_torques(dReal torque1, dReal torque2)
 */
static PyObject *Dtool_OdeUniversalJoint_add_torques_606(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.add_torques")) {
    return NULL;
  }
  // 1-inline void OdeUniversalJoint::add_torques(dReal torque1, dReal torque2)
  float param1;
  float param2;
  static const char *keyword_list[] = {"torque1", "torque2", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:add_torques", (char **)keyword_list, &param1, &param2)) {
    (*local_this).add_torques((dReal)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_torques(const OdeUniversalJoint self, float torque1, float torque2)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_add_torques_606_comment =
  "C++ Interface:\n"
  "add_torques(const OdeUniversalJoint self, float torque1, float torque2)\n";
#else
static const char *Dtool_OdeUniversalJoint_add_torques_606_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeUniversalJoint::get_anchor(void) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_anchor_607(PyObject *self, PyObject *) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeUniversalJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeUniversalJoint::get_anchor(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeUniversalJoint*)local_this).get_anchor());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_anchor_607_comment =
  "C++ Interface:\n"
  "get_anchor(OdeUniversalJoint self)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_anchor_607_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeUniversalJoint::get_anchor2(void) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_anchor2_608(PyObject *self, PyObject *) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeUniversalJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeUniversalJoint::get_anchor2(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeUniversalJoint*)local_this).get_anchor2());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_anchor2_608_comment =
  "C++ Interface:\n"
  "get_anchor2(OdeUniversalJoint self)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_anchor2_608_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeUniversalJoint::get_axis1(void) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_axis1_609(PyObject *self, PyObject *) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeUniversalJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeUniversalJoint::get_axis1(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeUniversalJoint*)local_this).get_axis1());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_axis1_609_comment =
  "C++ Interface:\n"
  "get_axis1(OdeUniversalJoint self)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_axis1_609_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeUniversalJoint::get_axis2(void) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_axis2_610(PyObject *self, PyObject *) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeUniversalJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f OdeUniversalJoint::get_axis2(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const OdeUniversalJoint*)local_this).get_axis2());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_axis2_610_comment =
  "C++ Interface:\n"
  "get_axis2(OdeUniversalJoint self)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_axis2_610_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_angle1(void) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_angle1_611(PyObject *self, PyObject *) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeUniversalJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeUniversalJoint::get_angle1(void) const
  dReal return_value = (*(const OdeUniversalJoint*)local_this).get_angle1();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_angle1_611_comment =
  "C++ Interface:\n"
  "get_angle1(OdeUniversalJoint self)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_angle1_611_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_angle2(void) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_angle2_612(PyObject *self, PyObject *) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeUniversalJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeUniversalJoint::get_angle2(void) const
  dReal return_value = (*(const OdeUniversalJoint*)local_this).get_angle2();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_angle2_612_comment =
  "C++ Interface:\n"
  "get_angle2(OdeUniversalJoint self)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_angle2_612_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_angle1_rate(void) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_angle1_rate_613(PyObject *self, PyObject *) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeUniversalJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeUniversalJoint::get_angle1_rate(void) const
  dReal return_value = (*(const OdeUniversalJoint*)local_this).get_angle1_rate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_angle1_rate_613_comment =
  "C++ Interface:\n"
  "get_angle1_rate(OdeUniversalJoint self)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_angle1_rate_613_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_angle2_rate(void) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_angle2_rate_614(PyObject *self, PyObject *) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeUniversalJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeUniversalJoint::get_angle2_rate(void) const
  dReal return_value = (*(const OdeUniversalJoint*)local_this).get_angle2_rate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_angle2_rate_614_comment =
  "C++ Interface:\n"
  "get_angle2_rate(OdeUniversalJoint self)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_angle2_rate_614_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_param_lo_stop(int axis, dReal val)
 */
static PyObject *Dtool_OdeUniversalJoint_set_param_lo_stop_615(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_param_lo_stop")) {
    return NULL;
  }
  // 1-inline void OdeUniversalJoint::set_param_lo_stop(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_lo_stop", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_lo_stop((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_lo_stop(const OdeUniversalJoint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_param_lo_stop_615_comment =
  "C++ Interface:\n"
  "set_param_lo_stop(const OdeUniversalJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_param_lo_stop_615_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_param_hi_stop(int axis, dReal val)
 */
static PyObject *Dtool_OdeUniversalJoint_set_param_hi_stop_616(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_param_hi_stop")) {
    return NULL;
  }
  // 1-inline void OdeUniversalJoint::set_param_hi_stop(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_hi_stop", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_hi_stop((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_hi_stop(const OdeUniversalJoint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_param_hi_stop_616_comment =
  "C++ Interface:\n"
  "set_param_hi_stop(const OdeUniversalJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_param_hi_stop_616_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_param_vel(int axis, dReal val)
 */
static PyObject *Dtool_OdeUniversalJoint_set_param_vel_617(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_param_vel")) {
    return NULL;
  }
  // 1-inline void OdeUniversalJoint::set_param_vel(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_vel", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_vel((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_vel(const OdeUniversalJoint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_param_vel_617_comment =
  "C++ Interface:\n"
  "set_param_vel(const OdeUniversalJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_param_vel_617_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_param_f_max(int axis, dReal val)
 */
static PyObject *Dtool_OdeUniversalJoint_set_param_f_max_618(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_param_f_max")) {
    return NULL;
  }
  // 1-inline void OdeUniversalJoint::set_param_f_max(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_f_max", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_f_max((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_f_max(const OdeUniversalJoint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_param_f_max_618_comment =
  "C++ Interface:\n"
  "set_param_f_max(const OdeUniversalJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_param_f_max_618_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_param_fudge_factor(int axis, dReal val)
 */
static PyObject *Dtool_OdeUniversalJoint_set_param_fudge_factor_619(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_param_fudge_factor")) {
    return NULL;
  }
  // 1-inline void OdeUniversalJoint::set_param_fudge_factor(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_fudge_factor", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_fudge_factor((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_fudge_factor(const OdeUniversalJoint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_param_fudge_factor_619_comment =
  "C++ Interface:\n"
  "set_param_fudge_factor(const OdeUniversalJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_param_fudge_factor_619_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_param_bounce(int axis, dReal val)
 */
static PyObject *Dtool_OdeUniversalJoint_set_param_bounce_620(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_param_bounce")) {
    return NULL;
  }
  // 1-inline void OdeUniversalJoint::set_param_bounce(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_bounce", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_bounce((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_bounce(const OdeUniversalJoint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_param_bounce_620_comment =
  "C++ Interface:\n"
  "set_param_bounce(const OdeUniversalJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_param_bounce_620_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_param_CFM(int axis, dReal val)
 */
static PyObject *Dtool_OdeUniversalJoint_set_param_CFM_621(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_param_CFM")) {
    return NULL;
  }
  // 1-inline void OdeUniversalJoint::set_param_CFM(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_CFM", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_CFM((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_CFM(const OdeUniversalJoint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_param_CFM_621_comment =
  "C++ Interface:\n"
  "set_param_CFM(const OdeUniversalJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_param_CFM_621_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_param_stop_ERP(int axis, dReal val)
 */
static PyObject *Dtool_OdeUniversalJoint_set_param_stop_ERP_622(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_param_stop_ERP")) {
    return NULL;
  }
  // 1-inline void OdeUniversalJoint::set_param_stop_ERP(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_stop_ERP", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_stop_ERP((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_ERP(const OdeUniversalJoint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_param_stop_ERP_622_comment =
  "C++ Interface:\n"
  "set_param_stop_ERP(const OdeUniversalJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_param_stop_ERP_622_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_param_stop_CFM(int axis, dReal val)
 */
static PyObject *Dtool_OdeUniversalJoint_set_param_stop_CFM_623(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_param_stop_CFM")) {
    return NULL;
  }
  // 1-inline void OdeUniversalJoint::set_param_stop_CFM(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_stop_CFM", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_param_stop_CFM((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_CFM(const OdeUniversalJoint self, int axis, float val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_param_stop_CFM_623_comment =
  "C++ Interface:\n"
  "set_param_stop_CFM(const OdeUniversalJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_param_stop_CFM_623_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_param_lo_stop(int axis) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_param_lo_stop_624(PyObject *self, PyObject *arg) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeUniversalJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeUniversalJoint::get_param_lo_stop(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeUniversalJoint*)local_this).get_param_lo_stop((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_lo_stop(OdeUniversalJoint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_param_lo_stop_624_comment =
  "C++ Interface:\n"
  "get_param_lo_stop(OdeUniversalJoint self, int axis)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_param_lo_stop_624_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_param_hi_stop(int axis) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_param_hi_stop_625(PyObject *self, PyObject *arg) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeUniversalJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeUniversalJoint::get_param_hi_stop(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeUniversalJoint*)local_this).get_param_hi_stop((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_hi_stop(OdeUniversalJoint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_param_hi_stop_625_comment =
  "C++ Interface:\n"
  "get_param_hi_stop(OdeUniversalJoint self, int axis)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_param_hi_stop_625_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_param_vel(int axis) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_param_vel_626(PyObject *self, PyObject *arg) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeUniversalJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeUniversalJoint::get_param_vel(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeUniversalJoint*)local_this).get_param_vel((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_vel(OdeUniversalJoint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_param_vel_626_comment =
  "C++ Interface:\n"
  "get_param_vel(OdeUniversalJoint self, int axis)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_param_vel_626_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_param_f_max(int axis) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_param_f_max_627(PyObject *self, PyObject *arg) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeUniversalJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeUniversalJoint::get_param_f_max(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeUniversalJoint*)local_this).get_param_f_max((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_f_max(OdeUniversalJoint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_param_f_max_627_comment =
  "C++ Interface:\n"
  "get_param_f_max(OdeUniversalJoint self, int axis)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_param_f_max_627_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_param_fudge_factor(int axis) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_param_fudge_factor_628(PyObject *self, PyObject *arg) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeUniversalJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeUniversalJoint::get_param_fudge_factor(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeUniversalJoint*)local_this).get_param_fudge_factor((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_fudge_factor(OdeUniversalJoint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_param_fudge_factor_628_comment =
  "C++ Interface:\n"
  "get_param_fudge_factor(OdeUniversalJoint self, int axis)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_param_fudge_factor_628_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_param_bounce(int axis) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_param_bounce_629(PyObject *self, PyObject *arg) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeUniversalJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeUniversalJoint::get_param_bounce(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeUniversalJoint*)local_this).get_param_bounce((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_bounce(OdeUniversalJoint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_param_bounce_629_comment =
  "C++ Interface:\n"
  "get_param_bounce(OdeUniversalJoint self, int axis)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_param_bounce_629_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_param_CFM(int axis) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_param_CFM_630(PyObject *self, PyObject *arg) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeUniversalJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeUniversalJoint::get_param_CFM(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeUniversalJoint*)local_this).get_param_CFM((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_CFM(OdeUniversalJoint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_param_CFM_630_comment =
  "C++ Interface:\n"
  "get_param_CFM(OdeUniversalJoint self, int axis)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_param_CFM_630_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_param_stop_ERP(int axis) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_param_stop_ERP_631(PyObject *self, PyObject *arg) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeUniversalJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeUniversalJoint::get_param_stop_ERP(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeUniversalJoint*)local_this).get_param_stop_ERP((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_stop_ERP(OdeUniversalJoint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_param_stop_ERP_631_comment =
  "C++ Interface:\n"
  "get_param_stop_ERP(OdeUniversalJoint self, int axis)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_param_stop_ERP_631_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_param_stop_CFM(int axis) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_param_stop_CFM_632(PyObject *self, PyObject *arg) {
  OdeUniversalJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeUniversalJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline dReal OdeUniversalJoint::get_param_stop_CFM(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = (*(const OdeUniversalJoint*)local_this).get_param_stop_CFM((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_stop_CFM(OdeUniversalJoint self, int axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_param_stop_CFM_632_comment =
  "C++ Interface:\n"
  "get_param_stop_CFM(OdeUniversalJoint self, int axis)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_param_stop_CFM_632_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeUniversalJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeUniversalJoint_get_class_type_633(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeUniversalJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OdeUniversalJoint::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_class_type_633_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeUniversalJoint_get_class_type_633_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeUniversalJoint::OdeUniversalJoint(OdeUniversalJoint const &) = default
 * OdeUniversalJoint::OdeUniversalJoint(OdeWorld &world)
 * OdeUniversalJoint::OdeUniversalJoint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdeUniversalJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline OdeUniversalJoint::OdeUniversalJoint(OdeUniversalJoint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeUniversalJoint", (char **)keyword_list, &param0)) {
          OdeUniversalJoint const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_OdeUniversalJoint, (void **)&param0_this);
          if (param0_this != NULL) {
            OdeUniversalJoint *return_value = new OdeUniversalJoint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeUniversalJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 OdeUniversalJoint::OdeUniversalJoint(OdeWorld &world)
        PyObject *param0;
        static const char *keyword_list[] = {"world", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeUniversalJoint", (char **)keyword_list, &param0)) {
          OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeUniversalJoint.OdeUniversalJoint", false, false);
          if (param0_this != NULL) {
            OdeUniversalJoint *return_value = new OdeUniversalJoint(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeUniversalJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline OdeUniversalJoint::OdeUniversalJoint(OdeUniversalJoint const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OdeUniversalJoint", (char **)keyword_list, &param0)) {
          OdeUniversalJoint const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_OdeUniversalJoint(param0, param0_this, param0_manage)) {
            OdeUniversalJoint *return_value = new OdeUniversalJoint(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeUniversalJoint, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: OdeUniversalJoint::OdeUniversalJoint(OdeWorld &world)
    }
    break;
  case 2:
    {
      // 1-OdeUniversalJoint::OdeUniversalJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeUniversalJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeUniversalJoint.OdeUniversalJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeUniversalJoint.OdeUniversalJoint", false, true);
        if (param0_this != NULL && param1_this != NULL) {
          OdeUniversalJoint *return_value = new OdeUniversalJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeUniversalJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeUniversalJoint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeUniversalJoint(const OdeUniversalJoint param0)\n"
      "OdeUniversalJoint(OdeWorld world)\n"
      "OdeUniversalJoint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeUniversalJoint(PyObject *args, OdeUniversalJoint const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeUniversalJoint, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeUniversalJoint::OdeUniversalJoint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeUniversalJoint.OdeUniversalJoint", false, false);
    if (arg_this != NULL) {
      OdeUniversalJoint *return_value = new OdeUniversalJoint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeUniversalJoint::OdeUniversalJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeUniversalJoint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeUniversalJoint.OdeUniversalJoint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeUniversalJoint.OdeUniversalJoint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeUniversalJoint *return_value = new OdeUniversalJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OdeUniversalJoint(PyObject *args, OdeUniversalJoint *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OdeUniversalJoint, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeUniversalJoint::OdeUniversalJoint(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeUniversalJoint.OdeUniversalJoint", false, false);
    if (arg_this != NULL) {
      OdeUniversalJoint *return_value = new OdeUniversalJoint(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeUniversalJoint::OdeUniversalJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeUniversalJoint", 2, 2, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeUniversalJoint.OdeUniversalJoint", false, false);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeUniversalJoint.OdeUniversalJoint", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          OdeUniversalJoint *return_value = new OdeUniversalJoint(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeUniversalJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeUniversalJoint) {
    printf("OdeUniversalJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeUniversalJoint *local_this = (OdeUniversalJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeUniversalJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeUniversalJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeUniversalJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeUniversalJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeUniversalJoint*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OdeUtil
 */
/**
 * Python function wrapper for:
 * static OdeJoint OdeUtil::get_connecting_joint(OdeBody const &body1, OdeBody const &body2)
 */
static PyObject *Dtool_OdeUtil_get_connecting_joint_635(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static OdeJoint OdeUtil::get_connecting_joint(OdeBody const &body1, OdeBody const &body2)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"body1", "body2", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_connecting_joint", (char **)keyword_list, &param0, &param1)) {
    OdeBody const *param0_this;
    bool param0_manage = false;
    if (!Dtool_ConstCoerce_OdeBody(param0, param0_this, param0_manage)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "OdeUtil.get_connecting_joint", "OdeBody");
    }
    OdeBody const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_OdeBody(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "OdeUtil.get_connecting_joint", "OdeBody");
    }
    OdeJoint *return_value = new OdeJoint(OdeUtil::get_connecting_joint(*param0_this, *param1_this));
    if (param0_manage) {
      delete param0_this;
    }
    if (param1_manage) {
      delete param1_this;
    }
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeJoint, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_connecting_joint(const OdeBody body1, const OdeBody body2)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_get_connecting_joint_635_comment =
  "C++ Interface:\n"
  "get_connecting_joint(const OdeBody body1, const OdeBody body2)\n"
  "\n"
  "/**\n"
  " * Returns the joint that connects the given bodies.\n"
  " */";
#else
static const char *Dtool_OdeUtil_get_connecting_joint_635_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static OdeJointCollection OdeUtil::get_connecting_joint_list(OdeBody const &body1, OdeBody const &body2)
 */
static PyObject *Dtool_OdeUtil_get_connecting_joint_list_636(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static OdeJointCollection OdeUtil::get_connecting_joint_list(OdeBody const &body1, OdeBody const &body2)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"body1", "body2", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_connecting_joint_list", (char **)keyword_list, &param0, &param1)) {
    OdeBody const *param0_this;
    bool param0_manage = false;
    if (!Dtool_ConstCoerce_OdeBody(param0, param0_this, param0_manage)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "OdeUtil.get_connecting_joint_list", "OdeBody");
    }
    OdeBody const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_OdeBody(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "OdeUtil.get_connecting_joint_list", "OdeBody");
    }
    OdeJointCollection *return_value = new OdeJointCollection(OdeUtil::get_connecting_joint_list(*param0_this, *param1_this));
    if (param0_manage) {
      delete param0_this;
    }
    if (param1_manage) {
      delete param1_this;
    }
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OdeJointCollection, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_connecting_joint_list(const OdeBody body1, const OdeBody body2)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_get_connecting_joint_list_636_comment =
  "C++ Interface:\n"
  "get_connecting_joint_list(const OdeBody body1, const OdeBody body2)\n"
  "\n"
  "/**\n"
  " * Returns a collection of joints connecting the specified bodies.\n"
  " */";
#else
static const char *Dtool_OdeUtil_get_connecting_joint_list_636_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static int OdeUtil::are_connected(OdeBody const &body1, OdeBody const &body2)
 */
static PyObject *Dtool_OdeUtil_are_connected_637(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static int OdeUtil::are_connected(OdeBody const &body1, OdeBody const &body2)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"body1", "body2", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:are_connected", (char **)keyword_list, &param0, &param1)) {
    OdeBody const *param0_this;
    bool param0_manage = false;
    if (!Dtool_ConstCoerce_OdeBody(param0, param0_this, param0_manage)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "OdeUtil.are_connected", "OdeBody");
    }
    OdeBody const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_OdeBody(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "OdeUtil.are_connected", "OdeBody");
    }
    int return_value = OdeUtil::are_connected(*param0_this, *param1_this);
    if (param0_manage) {
      delete param0_this;
    }
    if (param1_manage) {
      delete param1_this;
    }
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "are_connected(const OdeBody body1, const OdeBody body2)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_are_connected_637_comment =
  "C++ Interface:\n"
  "are_connected(const OdeBody body1, const OdeBody body2)\n"
  "\n"
  "/**\n"
  " * Returns 1 if the given bodies are connected by a joint, returns 0\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_OdeUtil_are_connected_637_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static int OdeUtil::are_connected_excluding(OdeBody const &body1, OdeBody const &body2, int const joint_type)
 */
static PyObject *Dtool_OdeUtil_are_connected_excluding_638(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static int OdeUtil::are_connected_excluding(OdeBody const &body1, OdeBody const &body2, int const joint_type)
  PyObject *param0;
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"body1", "body2", "joint_type", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:are_connected_excluding", (char **)keyword_list, &param0, &param1, &param2)) {
    OdeBody const *param0_this;
    bool param0_manage = false;
    if (!Dtool_ConstCoerce_OdeBody(param0, param0_this, param0_manage)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "OdeUtil.are_connected_excluding", "OdeBody");
    }
    OdeBody const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_OdeBody(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "OdeUtil.are_connected_excluding", "OdeBody");
    }
    int return_value = OdeUtil::are_connected_excluding(*param0_this, *param1_this, (int const)param2);
    if (param0_manage) {
      delete param0_this;
    }
    if (param1_manage) {
      delete param1_this;
    }
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "are_connected_excluding(const OdeBody body1, const OdeBody body2, int joint_type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_are_connected_excluding_638_comment =
  "C++ Interface:\n"
  "are_connected_excluding(const OdeBody body1, const OdeBody body2, int joint_type)\n"
  "\n"
  "/**\n"
  " * Returns 1 if the given bodies are connected by a joint that does not match\n"
  " * the given joint_type, returns 0 otherwise.  This is useful for deciding\n"
  " * whether to add contact joints between two bodies: if they are already\n"
  " * connected by non-contact joints then it may not be appropriate to add\n"
  " * contacts, however it is okay to add more contact between bodies that\n"
  " * already have contacts.\n"
  " */";
#else
static const char *Dtool_OdeUtil_are_connected_excluding_638_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< OdeCollisionEntry > OdeUtil::collide(OdeGeom const &geom1, OdeGeom const &geom2, short int const max_contacts = 150)
 */
static PyObject *Dtool_OdeUtil_collide_639(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< OdeCollisionEntry > OdeUtil::collide(OdeGeom const &geom1, OdeGeom const &geom2, short int const max_contacts = 150)
  PyObject *param0;
  PyObject *param1;
  short param2 = 150;
  static const char *keyword_list[] = {"geom1", "geom2", "max_contacts", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|h:collide", (char **)keyword_list, &param0, &param1, &param2)) {
    OdeGeom const *param0_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeGeom, 0, "OdeUtil.collide", true, true);
    OdeGeom const *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeGeom, 1, "OdeUtil.collide", true, true);
    if (param0_this != NULL && param1_this != NULL) {
      PointerTo< OdeCollisionEntry > return_value = OdeUtil::collide(*param0_this, *param1_this, (short int const)param2);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      // Transfer ownership of return_value.
      OdeCollisionEntry *return_ptr = return_value.p();
      return_value.cheat() = NULL;
      if (return_ptr == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_OdeCollisionEntry, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "collide(const OdeGeom geom1, const OdeGeom geom2, int max_contacts)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_collide_639_comment =
  "C++ Interface:\n"
  "collide(const OdeGeom geom1, const OdeGeom geom2, int max_contacts)\n"
  "\n"
  "/**\n"
  " * Given two geometry objects that potentially touch (geom1 and geom2),\n"
  " * generate contact information for them.  Returns an OdeCollisionEntry.\n"
  " */";
#else
static const char *Dtool_OdeUtil_collide_639_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static int OdeUtil::collide2(OdeGeom const &geom1, OdeGeom const &geom2, PyObject *arg, PyObject *callback)
 */
static PyObject *Dtool_OdeUtil_collide2_640(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static int OdeUtil::collide2(OdeGeom const &geom1, OdeGeom const &geom2, PyObject *arg, PyObject *callback)
  PyObject *param0;
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"geom1", "geom2", "arg", "callback", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:collide2", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    OdeGeom const *param0_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeGeom, 0, "OdeUtil.collide2", true, true);
    OdeGeom const *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeGeom, 1, "OdeUtil.collide2", true, true);
    if (param0_this != NULL && param1_this != NULL) {
      int return_value = Extension<OdeUtil>::collide2(*param0_this, *param1_this, param2, param3);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "collide2(const OdeGeom geom1, const OdeGeom geom2, object arg, object callback)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_collide2_640_comment =
  "C++ Interface:\n"
  "collide2(const OdeGeom geom1, const OdeGeom geom2, object arg, object callback)\n";
#else
static const char *Dtool_OdeUtil_collide2_640_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static OdeGeom OdeUtil::space_to_geom(OdeSpace const &space)
 */
static PyObject *Dtool_OdeUtil_space_to_geom_641(PyObject *, PyObject *arg) {
  // 1-static OdeGeom OdeUtil::space_to_geom(OdeSpace const &space)
  OdeSpace const *arg_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeSpace, 0, "OdeUtil.space_to_geom", true, true);
  if (arg_this != NULL) {
    OdeGeom *return_value = new OdeGeom(OdeUtil::space_to_geom(*arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeGeom, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "space_to_geom(const OdeSpace space)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_space_to_geom_641_comment =
  "C++ Interface:\n"
  "space_to_geom(const OdeSpace space)\n";
#else
static const char *Dtool_OdeUtil_space_to_geom_641_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static dReal OdeUtil::get_infinity(void)
 */
static PyObject *Dtool_OdeUtil_get_infinity_642(PyObject *, PyObject *) {
  // 1-static dReal OdeUtil::get_infinity(void)
  dReal return_value = OdeUtil::get_infinity();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_get_infinity_642_comment =
  "C++ Interface:\n"
  "get_infinity()\n"
  "\n"
  "// RAU we can't access OC_infinity as constants are not exposed in python";
#else
static const char *Dtool_OdeUtil_get_infinity_642_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static int OdeUtil::rand_get_seed(void)
 */
static PyObject *Dtool_OdeUtil_rand_get_seed_643(PyObject *, PyObject *) {
  // 1-static int OdeUtil::rand_get_seed(void)
  int return_value = OdeUtil::rand_get_seed();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_rand_get_seed_643_comment =
  "C++ Interface:\n"
  "rand_get_seed()\n";
#else
static const char *Dtool_OdeUtil_rand_get_seed_643_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static void OdeUtil::rand_set_seed(int s)
 */
static PyObject *Dtool_OdeUtil_rand_set_seed_644(PyObject *, PyObject *arg) {
  // 1-static void OdeUtil::rand_set_seed(int s)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    OdeUtil::rand_set_seed((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rand_set_seed(int s)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_rand_set_seed_644_comment =
  "C++ Interface:\n"
  "rand_set_seed(int s)\n";
#else
static const char *Dtool_OdeUtil_rand_set_seed_644_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OdeUtil::OdeUtil(void) = default
 * inline OdeUtil::OdeUtil(OdeUtil const &) = default
 */
static int Dtool_Init_OdeUtil(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline OdeUtil::OdeUtil(void) = default
      OdeUtil *return_value = new OdeUtil();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeUtil, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline OdeUtil::OdeUtil(OdeUtil const &) = default
      OdeUtil const *arg_this = (OdeUtil *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeUtil, 0, "OdeUtil.OdeUtil", true, true);
      if (arg_this != NULL) {
        OdeUtil *return_value = new OdeUtil(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeUtil, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeUtil() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeUtil()\n"
      "OdeUtil(const OdeUtil param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeUtil(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OdeUtil) {
    printf("OdeUtil ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OdeUtil *local_this = (OdeUtil *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OdeUtil) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OdeUtil(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OdeUtil) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for dxBody (dxBody)
 */
static PyMethodDef Dtool_Methods_dxBody[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_dxBody = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_dxBody = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.dxBody",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_dxBody,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_dxBody,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_dxBody,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_dxBody,
    PyType_GenericAlloc,
    Dtool_new_dxBody,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_dxBody,
  Dtool_UpcastInterface_dxBody,
  Dtool_DowncastInterface_dxBody,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_dxBody(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_dxBody._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_dxBody._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_dxBody) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(dxBody)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_dxBody);
  }
}

/**
 * Python method tables for dxGeom (dxGeom)
 */
static PyMethodDef Dtool_Methods_dxGeom[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_dxGeom = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_dxGeom = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.dxGeom",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_dxGeom,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_dxGeom,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_dxGeom,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_dxGeom,
    PyType_GenericAlloc,
    Dtool_new_dxGeom,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_dxGeom,
  Dtool_UpcastInterface_dxGeom,
  Dtool_DowncastInterface_dxGeom,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_dxGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_dxGeom._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_dxGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_dxGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(dxGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_dxGeom);
  }
}

/**
 * Python method tables for dxJoint (dxJoint)
 */
static PyMethodDef Dtool_Methods_dxJoint[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_dxJoint = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_dxJoint = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.dxJoint",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_dxJoint,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_dxJoint,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_dxJoint,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_dxJoint,
    PyType_GenericAlloc,
    Dtool_new_dxJoint,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_dxJoint,
  Dtool_UpcastInterface_dxJoint,
  Dtool_DowncastInterface_dxJoint,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_dxJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_dxJoint._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_dxJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_dxJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(dxJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_dxJoint);
  }
}

/**
 * Python method tables for dxJointGroup (dxJointGroup)
 */
static PyMethodDef Dtool_Methods_dxJointGroup[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_dxJointGroup = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_dxJointGroup = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.dxJointGroup",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_dxJointGroup,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_dxJointGroup,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_dxJointGroup,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_dxJointGroup,
    PyType_GenericAlloc,
    Dtool_new_dxJointGroup,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_dxJointGroup,
  Dtool_UpcastInterface_dxJointGroup,
  Dtool_DowncastInterface_dxJointGroup,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_dxJointGroup(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_dxJointGroup._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_dxJointGroup._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_dxJointGroup) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(dxJointGroup)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_dxJointGroup);
  }
}

/**
 * Python method tables for dxSpace (dxSpace)
 */
static PyMethodDef Dtool_Methods_dxSpace[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_dxSpace = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_dxSpace = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.dxSpace",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_dxSpace,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_dxSpace,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_dxSpace,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_dxSpace,
    PyType_GenericAlloc,
    Dtool_new_dxSpace,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_dxSpace,
  Dtool_UpcastInterface_dxSpace,
  Dtool_DowncastInterface_dxSpace,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_dxSpace(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_dxSpace._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_dxSpace._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_dxSpace) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(dxSpace)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_dxSpace);
  }
}

/**
 * Python method tables for dxTriMeshData (dxTriMeshData)
 */
static PyMethodDef Dtool_Methods_dxTriMeshData[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_dxTriMeshData = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_dxTriMeshData = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.dxTriMeshData",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_dxTriMeshData,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_dxTriMeshData,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_dxTriMeshData,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_dxTriMeshData,
    PyType_GenericAlloc,
    Dtool_new_dxTriMeshData,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_dxTriMeshData,
  Dtool_UpcastInterface_dxTriMeshData,
  Dtool_DowncastInterface_dxTriMeshData,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_dxTriMeshData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_dxTriMeshData._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_dxTriMeshData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_dxTriMeshData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(dxTriMeshData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_dxTriMeshData);
  }
}

/**
 * Python method tables for dxWorld (dxWorld)
 */
static PyMethodDef Dtool_Methods_dxWorld[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_dxWorld = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_dxWorld = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.dxWorld",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_dxWorld,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_dxWorld,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_dxWorld,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_dxWorld,
    PyType_GenericAlloc,
    Dtool_new_dxWorld,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_dxWorld,
  Dtool_UpcastInterface_dxWorld,
  Dtool_DowncastInterface_dxWorld,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_dxWorld(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_dxWorld._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_dxWorld._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_dxWorld) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(dxWorld)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_dxWorld);
  }
}

/**
 * Python method tables for OdeWorld (OdeWorld)
 */
static PyMethodDef Dtool_Methods_OdeWorld[] = {
  {"destroy", &Dtool_OdeWorld_destroy_11, METH_NOARGS, (const char *)Dtool_OdeWorld_destroy_11_comment},
  {"is_empty", &Dtool_OdeWorld_is_empty_12, METH_NOARGS, (const char *)Dtool_OdeWorld_is_empty_12_comment},
  {"isEmpty", &Dtool_OdeWorld_is_empty_12, METH_NOARGS, (const char *)Dtool_OdeWorld_is_empty_12_comment},
  {"set_gravity", (PyCFunction) &Dtool_OdeWorld_set_gravity_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_set_gravity_14_comment},
  {"setGravity", (PyCFunction) &Dtool_OdeWorld_set_gravity_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_set_gravity_14_comment},
  {"set_erp", &Dtool_OdeWorld_set_erp_15, METH_O, (const char *)Dtool_OdeWorld_set_erp_15_comment},
  {"setErp", &Dtool_OdeWorld_set_erp_15, METH_O, (const char *)Dtool_OdeWorld_set_erp_15_comment},
  {"set_cfm", &Dtool_OdeWorld_set_cfm_16, METH_O, (const char *)Dtool_OdeWorld_set_cfm_16_comment},
  {"setCfm", &Dtool_OdeWorld_set_cfm_16, METH_O, (const char *)Dtool_OdeWorld_set_cfm_16_comment},
  {"set_quick_step_num_iterations", &Dtool_OdeWorld_set_quick_step_num_iterations_17, METH_O, (const char *)Dtool_OdeWorld_set_quick_step_num_iterations_17_comment},
  {"setQuickStepNumIterations", &Dtool_OdeWorld_set_quick_step_num_iterations_17, METH_O, (const char *)Dtool_OdeWorld_set_quick_step_num_iterations_17_comment},
  {"set_quick_step_w", &Dtool_OdeWorld_set_quick_step_w_18, METH_O, (const char *)Dtool_OdeWorld_set_quick_step_w_18_comment},
  {"setQuickStepW", &Dtool_OdeWorld_set_quick_step_w_18, METH_O, (const char *)Dtool_OdeWorld_set_quick_step_w_18_comment},
  {"set_contact_max_correcting_vel", &Dtool_OdeWorld_set_contact_max_correcting_vel_19, METH_O, (const char *)Dtool_OdeWorld_set_contact_max_correcting_vel_19_comment},
  {"setContactMaxCorrectingVel", &Dtool_OdeWorld_set_contact_max_correcting_vel_19, METH_O, (const char *)Dtool_OdeWorld_set_contact_max_correcting_vel_19_comment},
  {"set_contact_surface_layer", &Dtool_OdeWorld_set_contact_surface_layer_20, METH_O, (const char *)Dtool_OdeWorld_set_contact_surface_layer_20_comment},
  {"setContactSurfaceLayer", &Dtool_OdeWorld_set_contact_surface_layer_20, METH_O, (const char *)Dtool_OdeWorld_set_contact_surface_layer_20_comment},
  {"set_auto_disable_linear_threshold", &Dtool_OdeWorld_set_auto_disable_linear_threshold_21, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_linear_threshold_21_comment},
  {"setAutoDisableLinearThreshold", &Dtool_OdeWorld_set_auto_disable_linear_threshold_21, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_linear_threshold_21_comment},
  {"set_auto_disable_angular_threshold", &Dtool_OdeWorld_set_auto_disable_angular_threshold_22, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_angular_threshold_22_comment},
  {"setAutoDisableAngularThreshold", &Dtool_OdeWorld_set_auto_disable_angular_threshold_22, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_angular_threshold_22_comment},
  {"set_auto_disable_steps", &Dtool_OdeWorld_set_auto_disable_steps_23, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_steps_23_comment},
  {"setAutoDisableSteps", &Dtool_OdeWorld_set_auto_disable_steps_23, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_steps_23_comment},
  {"set_auto_disable_time", &Dtool_OdeWorld_set_auto_disable_time_24, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_time_24_comment},
  {"setAutoDisableTime", &Dtool_OdeWorld_set_auto_disable_time_24, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_time_24_comment},
  {"set_auto_disable_flag", &Dtool_OdeWorld_set_auto_disable_flag_25, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_flag_25_comment},
  {"setAutoDisableFlag", &Dtool_OdeWorld_set_auto_disable_flag_25, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_flag_25_comment},
  {"get_gravity", &Dtool_OdeWorld_get_gravity_26, METH_NOARGS, (const char *)Dtool_OdeWorld_get_gravity_26_comment},
  {"getGravity", &Dtool_OdeWorld_get_gravity_26, METH_NOARGS, (const char *)Dtool_OdeWorld_get_gravity_26_comment},
  {"get_erp", &Dtool_OdeWorld_get_erp_27, METH_NOARGS, (const char *)Dtool_OdeWorld_get_erp_27_comment},
  {"getErp", &Dtool_OdeWorld_get_erp_27, METH_NOARGS, (const char *)Dtool_OdeWorld_get_erp_27_comment},
  {"get_cfm", &Dtool_OdeWorld_get_cfm_28, METH_NOARGS, (const char *)Dtool_OdeWorld_get_cfm_28_comment},
  {"getCfm", &Dtool_OdeWorld_get_cfm_28, METH_NOARGS, (const char *)Dtool_OdeWorld_get_cfm_28_comment},
  {"get_quick_step_num_iterations", &Dtool_OdeWorld_get_quick_step_num_iterations_29, METH_NOARGS, (const char *)Dtool_OdeWorld_get_quick_step_num_iterations_29_comment},
  {"getQuickStepNumIterations", &Dtool_OdeWorld_get_quick_step_num_iterations_29, METH_NOARGS, (const char *)Dtool_OdeWorld_get_quick_step_num_iterations_29_comment},
  {"get_quick_step_w", &Dtool_OdeWorld_get_quick_step_w_30, METH_NOARGS, (const char *)Dtool_OdeWorld_get_quick_step_w_30_comment},
  {"getQuickStepW", &Dtool_OdeWorld_get_quick_step_w_30, METH_NOARGS, (const char *)Dtool_OdeWorld_get_quick_step_w_30_comment},
  {"get_contact_max_correcting_vel", &Dtool_OdeWorld_get_contact_max_correcting_vel_31, METH_NOARGS, (const char *)Dtool_OdeWorld_get_contact_max_correcting_vel_31_comment},
  {"getContactMaxCorrectingVel", &Dtool_OdeWorld_get_contact_max_correcting_vel_31, METH_NOARGS, (const char *)Dtool_OdeWorld_get_contact_max_correcting_vel_31_comment},
  {"get_contact_surface_layer", &Dtool_OdeWorld_get_contact_surface_layer_32, METH_NOARGS, (const char *)Dtool_OdeWorld_get_contact_surface_layer_32_comment},
  {"getContactSurfaceLayer", &Dtool_OdeWorld_get_contact_surface_layer_32, METH_NOARGS, (const char *)Dtool_OdeWorld_get_contact_surface_layer_32_comment},
  {"get_auto_disable_linear_threshold", &Dtool_OdeWorld_get_auto_disable_linear_threshold_33, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_linear_threshold_33_comment},
  {"getAutoDisableLinearThreshold", &Dtool_OdeWorld_get_auto_disable_linear_threshold_33, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_linear_threshold_33_comment},
  {"get_auto_disable_angular_threshold", &Dtool_OdeWorld_get_auto_disable_angular_threshold_34, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_angular_threshold_34_comment},
  {"getAutoDisableAngularThreshold", &Dtool_OdeWorld_get_auto_disable_angular_threshold_34, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_angular_threshold_34_comment},
  {"get_auto_disable_steps", &Dtool_OdeWorld_get_auto_disable_steps_35, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_steps_35_comment},
  {"getAutoDisableSteps", &Dtool_OdeWorld_get_auto_disable_steps_35, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_steps_35_comment},
  {"get_auto_disable_time", &Dtool_OdeWorld_get_auto_disable_time_36, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_time_36_comment},
  {"getAutoDisableTime", &Dtool_OdeWorld_get_auto_disable_time_36, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_time_36_comment},
  {"get_auto_disable_flag", &Dtool_OdeWorld_get_auto_disable_flag_37, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_flag_37_comment},
  {"getAutoDisableFlag", &Dtool_OdeWorld_get_auto_disable_flag_37, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_flag_37_comment},
  {"impulse_to_force", (PyCFunction) &Dtool_OdeWorld_impulse_to_force_38, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_impulse_to_force_38_comment},
  {"impulseToForce", (PyCFunction) &Dtool_OdeWorld_impulse_to_force_38, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_impulse_to_force_38_comment},
  {"step", &Dtool_OdeWorld_step_39, METH_O, (const char *)Dtool_OdeWorld_step_39_comment},
  {"quick_step", &Dtool_OdeWorld_quick_step_40, METH_O, (const char *)Dtool_OdeWorld_quick_step_40_comment},
  {"quickStep", &Dtool_OdeWorld_quick_step_40, METH_O, (const char *)Dtool_OdeWorld_quick_step_40_comment},
  {"compare_to", &Dtool_OdeWorld_compare_to_41, METH_O, (const char *)Dtool_OdeWorld_compare_to_41_comment},
  {"compareTo", &Dtool_OdeWorld_compare_to_41, METH_O, (const char *)Dtool_OdeWorld_compare_to_41_comment},
  {"init_surface_table", &Dtool_OdeWorld_init_surface_table_42, METH_O, (const char *)Dtool_OdeWorld_init_surface_table_42_comment},
  {"initSurfaceTable", &Dtool_OdeWorld_init_surface_table_42, METH_O, (const char *)Dtool_OdeWorld_init_surface_table_42_comment},
  {"add_body_dampening", (PyCFunction) &Dtool_OdeWorld_add_body_dampening_43, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_add_body_dampening_43_comment},
  {"addBodyDampening", (PyCFunction) &Dtool_OdeWorld_add_body_dampening_43, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_add_body_dampening_43_comment},
  {"set_surface_entry", (PyCFunction) &Dtool_OdeWorld_set_surface_entry_44, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_set_surface_entry_44_comment},
  {"setSurfaceEntry", (PyCFunction) &Dtool_OdeWorld_set_surface_entry_44, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_set_surface_entry_44_comment},
  {"apply_dampening", (PyCFunction) &Dtool_OdeWorld_apply_dampening_45, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_apply_dampening_45_comment},
  {"applyDampening", (PyCFunction) &Dtool_OdeWorld_apply_dampening_45, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_apply_dampening_45_comment},
  {"get_class_type", &Dtool_OdeWorld_get_class_type_47, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeWorld_get_class_type_47_comment},
  {"getClassType", &Dtool_OdeWorld_get_class_type_47, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeWorld_get_class_type_47_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeWorld slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_OdeWorld_operator_typecast_bool_46_nb_bool(PyObject *self) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeWorld, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeWorld slot tp_compare -> compare_to
//////////////////
static int Dtool_OdeWorld_compare_to_41_tp_compare(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeWorld, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int OdeWorld::compare_to(OdeWorld const &other) const
  OdeWorld const *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 1, "OdeWorld.compare_to", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const OdeWorld*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(OdeWorld self, const OdeWorld other)\n");
  }
  return -1;
}

static PyNumberMethods Dtool_NumberMethods_OdeWorld = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  &Dtool_OdeWorld_operator_typecast_bool_46_nb_bool,
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeWorld = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeWorld = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeWorld = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeWorld = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeWorld",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeWorld,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_OdeWorld_compare_to_41_tp_compare,
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeWorld,
    &Dtool_SequenceMethods_OdeWorld,
    &Dtool_MappingMethods_OdeWorld,
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeWorld,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
#if PY_MAJOR_VERSION >= 3
    &DTOOL_PyObject_RichCompare,
#else
    0, // tp_richcompare
#endif
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeWorld,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeWorld,
    PyType_GenericAlloc,
    Dtool_new_OdeWorld,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeWorld,
  Dtool_UpcastInterface_OdeWorld,
  Dtool_DowncastInterface_OdeWorld,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_OdeWorld(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != NULL);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(NULL);
    Dtool_OdeWorld._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    PyObject *dict = PyDict_New();
    Dtool_OdeWorld._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeWorld) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeWorld)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeWorld);
  }
}

/**
 * Python method tables for OdeJointGroup (OdeJointGroup)
 */
static PyMethodDef Dtool_Methods_OdeJointGroup[] = {
  {"destroy", &Dtool_OdeJointGroup_destroy_50, METH_NOARGS, (const char *)Dtool_OdeJointGroup_destroy_50_comment},
  {"empty", &Dtool_OdeJointGroup_empty_52, METH_NOARGS, (const char *)Dtool_OdeJointGroup_empty_52_comment},
  {"compare_to", &Dtool_OdeJointGroup_compare_to_53, METH_O, (const char *)Dtool_OdeJointGroup_compare_to_53_comment},
  {"compareTo", &Dtool_OdeJointGroup_compare_to_53, METH_O, (const char *)Dtool_OdeJointGroup_compare_to_53_comment},
  {"get_class_type", &Dtool_OdeJointGroup_get_class_type_54, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeJointGroup_get_class_type_54_comment},
  {"getClassType", &Dtool_OdeJointGroup_get_class_type_54, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeJointGroup_get_class_type_54_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeJointGroup slot tp_compare -> compare_to
//////////////////
static int Dtool_OdeJointGroup_compare_to_53_tp_compare(PyObject *self, PyObject *arg) {
  OdeJointGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJointGroup, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int OdeJointGroup::compare_to(OdeJointGroup const &other) const
  OdeJointGroup const *arg_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointGroup, 1, "OdeJointGroup.compare_to", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const OdeJointGroup*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(OdeJointGroup self, const OdeJointGroup other)\n");
  }
  return -1;
}

static PyNumberMethods Dtool_NumberMethods_OdeJointGroup = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeJointGroup = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeJointGroup = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeJointGroup = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeJointGroup = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeJointGroup",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeJointGroup,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_OdeJointGroup_compare_to_53_tp_compare,
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeJointGroup,
    &Dtool_SequenceMethods_OdeJointGroup,
    &Dtool_MappingMethods_OdeJointGroup,
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeJointGroup,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
#if PY_MAJOR_VERSION >= 3
    &DTOOL_PyObject_RichCompare,
#else
    0, // tp_richcompare
#endif
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeJointGroup,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeJointGroup,
    PyType_GenericAlloc,
    Dtool_new_OdeJointGroup,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeJointGroup,
  Dtool_UpcastInterface_OdeJointGroup,
  Dtool_DowncastInterface_OdeJointGroup,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_OdeJointGroup(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != NULL);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(NULL);
    Dtool_OdeJointGroup._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    PyObject *dict = PyDict_New();
    Dtool_OdeJointGroup._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeJointGroup) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeJointGroup)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeJointGroup);
  }
}

/**
 * Python method tables for OdeJointFeedback (OdeJointFeedback)
 */
static PyMethodDef Dtool_Methods_OdeJointFeedback[] = {
  {"get_force1", &Dtool_OdeJointFeedback_get_force1_57, METH_NOARGS, (const char *)Dtool_OdeJointFeedback_get_force1_57_comment},
  {"getForce1", &Dtool_OdeJointFeedback_get_force1_57, METH_NOARGS, (const char *)Dtool_OdeJointFeedback_get_force1_57_comment},
  {"get_force2", &Dtool_OdeJointFeedback_get_force2_58, METH_NOARGS, (const char *)Dtool_OdeJointFeedback_get_force2_58_comment},
  {"getForce2", &Dtool_OdeJointFeedback_get_force2_58, METH_NOARGS, (const char *)Dtool_OdeJointFeedback_get_force2_58_comment},
  {"get_torque1", &Dtool_OdeJointFeedback_get_torque1_59, METH_NOARGS, (const char *)Dtool_OdeJointFeedback_get_torque1_59_comment},
  {"getTorque1", &Dtool_OdeJointFeedback_get_torque1_59, METH_NOARGS, (const char *)Dtool_OdeJointFeedback_get_torque1_59_comment},
  {"get_torque2", &Dtool_OdeJointFeedback_get_torque2_60, METH_NOARGS, (const char *)Dtool_OdeJointFeedback_get_torque2_60_comment},
  {"getTorque2", &Dtool_OdeJointFeedback_get_torque2_60, METH_NOARGS, (const char *)Dtool_OdeJointFeedback_get_torque2_60_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeJointFeedback = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeJointFeedback = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeJointFeedback = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeJointFeedback = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeJointFeedback = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeJointFeedback",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeJointFeedback,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeJointFeedback,
    &Dtool_SequenceMethods_OdeJointFeedback,
    &Dtool_MappingMethods_OdeJointFeedback,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeJointFeedback,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeJointFeedback,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeJointFeedback,
    PyType_GenericAlloc,
    Dtool_new_OdeJointFeedback,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeJointFeedback,
  Dtool_UpcastInterface_OdeJointFeedback,
  Dtool_DowncastInterface_OdeJointFeedback,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_OdeJointFeedback(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_OdeJointFeedback._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_OdeJointFeedback._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeJointFeedback) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeJointFeedback)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeJointFeedback);
  }
}

/**
 * Python method tables for OdeJoint (OdeJoint)
 */
static PyMethodDef Dtool_Methods_OdeJoint[] = {
  {"destroy", &Dtool_OdeJoint_destroy_65, METH_NOARGS, (const char *)Dtool_OdeJoint_destroy_65_comment},
  {"is_empty", &Dtool_OdeJoint_is_empty_66, METH_NOARGS, (const char *)Dtool_OdeJoint_is_empty_66_comment},
  {"isEmpty", &Dtool_OdeJoint_is_empty_66, METH_NOARGS, (const char *)Dtool_OdeJoint_is_empty_66_comment},
  {"get_joint_type", &Dtool_OdeJoint_get_joint_type_68, METH_NOARGS, (const char *)Dtool_OdeJoint_get_joint_type_68_comment},
  {"getJointType", &Dtool_OdeJoint_get_joint_type_68, METH_NOARGS, (const char *)Dtool_OdeJoint_get_joint_type_68_comment},
  {"get_body", &Dtool_OdeJoint_get_body_69, METH_O, (const char *)Dtool_OdeJoint_get_body_69_comment},
  {"getBody", &Dtool_OdeJoint_get_body_69, METH_O, (const char *)Dtool_OdeJoint_get_body_69_comment},
  {"set_feedback", (PyCFunction) &Dtool_OdeJoint_set_feedback_70, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeJoint_set_feedback_70_comment},
  {"setFeedback", (PyCFunction) &Dtool_OdeJoint_set_feedback_70, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeJoint_set_feedback_70_comment},
  {"get_feedback", &Dtool_OdeJoint_get_feedback_71, METH_NOARGS, (const char *)Dtool_OdeJoint_get_feedback_71_comment},
  {"getFeedback", &Dtool_OdeJoint_get_feedback_71, METH_NOARGS, (const char *)Dtool_OdeJoint_get_feedback_71_comment},
  {"attach", (PyCFunction) &Dtool_OdeJoint_attach_72, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeJoint_attach_72_comment},
  {"attach_bodies", (PyCFunction) &Dtool_OdeJoint_attach_bodies_73, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeJoint_attach_bodies_73_comment},
  {"attachBodies", (PyCFunction) &Dtool_OdeJoint_attach_bodies_73, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeJoint_attach_bodies_73_comment},
  {"attach_body", (PyCFunction) &Dtool_OdeJoint_attach_body_74, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeJoint_attach_body_74_comment},
  {"attachBody", (PyCFunction) &Dtool_OdeJoint_attach_body_74, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeJoint_attach_body_74_comment},
  {"detach", &Dtool_OdeJoint_detach_75, METH_NOARGS, (const char *)Dtool_OdeJoint_detach_75_comment},
  {"write", (PyCFunction) &Dtool_OdeJoint_write_76, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeJoint_write_76_comment},
  {"compare_to", &Dtool_OdeJoint_compare_to_77, METH_O, (const char *)Dtool_OdeJoint_compare_to_77_comment},
  {"compareTo", &Dtool_OdeJoint_compare_to_77, METH_O, (const char *)Dtool_OdeJoint_compare_to_77_comment},
  {"convert", &Dtool_OdeJoint_convert_80, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_80_comment},
  {"convert_to_ball", &Dtool_OdeJoint_convert_to_ball_81, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_ball_81_comment},
  {"convertToBall", &Dtool_OdeJoint_convert_to_ball_81, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_ball_81_comment},
  {"convert_to_hinge", &Dtool_OdeJoint_convert_to_hinge_82, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_hinge_82_comment},
  {"convertToHinge", &Dtool_OdeJoint_convert_to_hinge_82, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_hinge_82_comment},
  {"convert_to_slider", &Dtool_OdeJoint_convert_to_slider_83, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_slider_83_comment},
  {"convertToSlider", &Dtool_OdeJoint_convert_to_slider_83, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_slider_83_comment},
  {"convert_to_contact", &Dtool_OdeJoint_convert_to_contact_84, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_contact_84_comment},
  {"convertToContact", &Dtool_OdeJoint_convert_to_contact_84, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_contact_84_comment},
  {"convert_to_universal", &Dtool_OdeJoint_convert_to_universal_85, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_universal_85_comment},
  {"convertToUniversal", &Dtool_OdeJoint_convert_to_universal_85, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_universal_85_comment},
  {"convert_to_hinge2", &Dtool_OdeJoint_convert_to_hinge2_86, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_hinge2_86_comment},
  {"convertToHinge2", &Dtool_OdeJoint_convert_to_hinge2_86, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_hinge2_86_comment},
  {"convert_to_fixed", &Dtool_OdeJoint_convert_to_fixed_87, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_fixed_87_comment},
  {"convertToFixed", &Dtool_OdeJoint_convert_to_fixed_87, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_fixed_87_comment},
  {"convert_to_null", &Dtool_OdeJoint_convert_to_null_88, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_null_88_comment},
  {"convertToNull", &Dtool_OdeJoint_convert_to_null_88, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_null_88_comment},
  {"convert_to_a_motor", &Dtool_OdeJoint_convert_to_a_motor_89, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_a_motor_89_comment},
  {"convertToAMotor", &Dtool_OdeJoint_convert_to_a_motor_89, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_a_motor_89_comment},
  {"convert_to_l_motor", &Dtool_OdeJoint_convert_to_l_motor_90, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_l_motor_90_comment},
  {"convertToLMotor", &Dtool_OdeJoint_convert_to_l_motor_90, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_l_motor_90_comment},
  {"convert_to_plane2d", &Dtool_OdeJoint_convert_to_plane2d_91, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_plane2d_91_comment},
  {"convertToPlane2d", &Dtool_OdeJoint_convert_to_plane2d_91, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_plane2d_91_comment},
  {"get_class_type", &Dtool_OdeJoint_get_class_type_92, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeJoint_get_class_type_92_comment},
  {"getClassType", &Dtool_OdeJoint_get_class_type_92, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeJoint_get_class_type_92_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeJoint slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_OdeJoint_operator_typecast_bool_79_nb_bool(PyObject *self) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeJoint slot tp_compare -> compare_to
//////////////////
static int Dtool_OdeJoint_compare_to_77_tp_compare(PyObject *self, PyObject *arg) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int OdeJoint::compare_to(OdeJoint const &other) const
  OdeJoint const *arg_this = (OdeJoint *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJoint, 1, "OdeJoint.compare_to", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const OdeJoint*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(OdeJoint self, const OdeJoint other)\n");
  }
  return -1;
}

//////////////////
//  A __str__ function
//     OdeJoint
//////////////////
static PyObject *Dtool_Str_OdeJoint(PyObject *self) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     OdeJoint
//////////////////
static PyObject *Dtool_RichCompare_OdeJoint(PyObject *self, PyObject *arg, int op) {
  OdeJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool OdeJoint::operator ==(OdeJoint const &other) const
      OdeJoint const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_OdeJoint, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const OdeJoint*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_OdeJoint_compare_to_77_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_OdeJoint = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  &Dtool_OdeJoint_operator_typecast_bool_79_nb_bool,
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeJoint = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeJoint = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeJoint = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeJoint = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeJoint",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeJoint,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_OdeJoint_compare_to_77_tp_compare,
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeJoint,
    &Dtool_SequenceMethods_OdeJoint,
    &Dtool_MappingMethods_OdeJoint,
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Str_OdeJoint,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_OdeJoint,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeJoint,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeJoint,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeJoint,
  Dtool_UpcastInterface_OdeJoint,
  Dtool_DowncastInterface_OdeJoint,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_OdeJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != NULL);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(NULL);
    Dtool_OdeJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    PyObject *dict = _PyDict_NewPresized(25);
    Dtool_OdeJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum OdeJoint::JointType;
    PyDict_SetItemString(dict, "JT_none", Dtool_WrapValue(OdeJoint::JT_none));
    PyDict_SetItemString(dict, "JTNone", Dtool_WrapValue(OdeJoint::JT_none));
    PyDict_SetItemString(dict, "JT_ball", Dtool_WrapValue(OdeJoint::JT_ball));
    PyDict_SetItemString(dict, "JTBall", Dtool_WrapValue(OdeJoint::JT_ball));
    PyDict_SetItemString(dict, "JT_hinge", Dtool_WrapValue(OdeJoint::JT_hinge));
    PyDict_SetItemString(dict, "JTHinge", Dtool_WrapValue(OdeJoint::JT_hinge));
    PyDict_SetItemString(dict, "JT_slider", Dtool_WrapValue(OdeJoint::JT_slider));
    PyDict_SetItemString(dict, "JTSlider", Dtool_WrapValue(OdeJoint::JT_slider));
    PyDict_SetItemString(dict, "JT_contact", Dtool_WrapValue(OdeJoint::JT_contact));
    PyDict_SetItemString(dict, "JTContact", Dtool_WrapValue(OdeJoint::JT_contact));
    PyDict_SetItemString(dict, "JT_universal", Dtool_WrapValue(OdeJoint::JT_universal));
    PyDict_SetItemString(dict, "JTUniversal", Dtool_WrapValue(OdeJoint::JT_universal));
    PyDict_SetItemString(dict, "JT_hinge2", Dtool_WrapValue(OdeJoint::JT_hinge2));
    PyDict_SetItemString(dict, "JTHinge2", Dtool_WrapValue(OdeJoint::JT_hinge2));
    PyDict_SetItemString(dict, "JT_fixed", Dtool_WrapValue(OdeJoint::JT_fixed));
    PyDict_SetItemString(dict, "JTFixed", Dtool_WrapValue(OdeJoint::JT_fixed));
    PyDict_SetItemString(dict, "JT_null", Dtool_WrapValue(OdeJoint::JT_null));
    PyDict_SetItemString(dict, "JTNull", Dtool_WrapValue(OdeJoint::JT_null));
    PyDict_SetItemString(dict, "JT_a_motor", Dtool_WrapValue(OdeJoint::JT_a_motor));
    PyDict_SetItemString(dict, "JTAMotor", Dtool_WrapValue(OdeJoint::JT_a_motor));
    PyDict_SetItemString(dict, "JT_l_motor", Dtool_WrapValue(OdeJoint::JT_l_motor));
    PyDict_SetItemString(dict, "JTLMotor", Dtool_WrapValue(OdeJoint::JT_l_motor));
    PyDict_SetItemString(dict, "JT_plane2d", Dtool_WrapValue(OdeJoint::JT_plane2d));
    PyDict_SetItemString(dict, "JTPlane2d", Dtool_WrapValue(OdeJoint::JT_plane2d));
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeJoint);
  }
}

/**
 * Python method tables for OdeAMotorJoint (OdeAMotorJoint)
 */
static PyMethodDef Dtool_Methods_OdeAMotorJoint[] = {
  {"set_num_axes", &Dtool_OdeAMotorJoint_set_num_axes_96, METH_O, (const char *)Dtool_OdeAMotorJoint_set_num_axes_96_comment},
  {"setNumAxes", &Dtool_OdeAMotorJoint_set_num_axes_96, METH_O, (const char *)Dtool_OdeAMotorJoint_set_num_axes_96_comment},
  {"set_axis", (PyCFunction) &Dtool_OdeAMotorJoint_set_axis_97, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_axis_97_comment},
  {"setAxis", (PyCFunction) &Dtool_OdeAMotorJoint_set_axis_97, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_axis_97_comment},
  {"set_angle", (PyCFunction) &Dtool_OdeAMotorJoint_set_angle_98, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_angle_98_comment},
  {"setAngle", (PyCFunction) &Dtool_OdeAMotorJoint_set_angle_98, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_angle_98_comment},
  {"set_mode", &Dtool_OdeAMotorJoint_set_mode_99, METH_O, (const char *)Dtool_OdeAMotorJoint_set_mode_99_comment},
  {"setMode", &Dtool_OdeAMotorJoint_set_mode_99, METH_O, (const char *)Dtool_OdeAMotorJoint_set_mode_99_comment},
  {"add_torques", (PyCFunction) &Dtool_OdeAMotorJoint_add_torques_100, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_add_torques_100_comment},
  {"addTorques", (PyCFunction) &Dtool_OdeAMotorJoint_add_torques_100, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_add_torques_100_comment},
  {"get_num_axes", &Dtool_OdeAMotorJoint_get_num_axes_101, METH_NOARGS, (const char *)Dtool_OdeAMotorJoint_get_num_axes_101_comment},
  {"getNumAxes", &Dtool_OdeAMotorJoint_get_num_axes_101, METH_NOARGS, (const char *)Dtool_OdeAMotorJoint_get_num_axes_101_comment},
  {"get_axis", &Dtool_OdeAMotorJoint_get_axis_102, METH_O, (const char *)Dtool_OdeAMotorJoint_get_axis_102_comment},
  {"getAxis", &Dtool_OdeAMotorJoint_get_axis_102, METH_O, (const char *)Dtool_OdeAMotorJoint_get_axis_102_comment},
  {"get_axis_rel", &Dtool_OdeAMotorJoint_get_axis_rel_104, METH_O, (const char *)Dtool_OdeAMotorJoint_get_axis_rel_104_comment},
  {"getAxisRel", &Dtool_OdeAMotorJoint_get_axis_rel_104, METH_O, (const char *)Dtool_OdeAMotorJoint_get_axis_rel_104_comment},
  {"get_angle", &Dtool_OdeAMotorJoint_get_angle_105, METH_O, (const char *)Dtool_OdeAMotorJoint_get_angle_105_comment},
  {"getAngle", &Dtool_OdeAMotorJoint_get_angle_105, METH_O, (const char *)Dtool_OdeAMotorJoint_get_angle_105_comment},
  {"get_angle_rate", &Dtool_OdeAMotorJoint_get_angle_rate_106, METH_O, (const char *)Dtool_OdeAMotorJoint_get_angle_rate_106_comment},
  {"getAngleRate", &Dtool_OdeAMotorJoint_get_angle_rate_106, METH_O, (const char *)Dtool_OdeAMotorJoint_get_angle_rate_106_comment},
  {"get_mode", &Dtool_OdeAMotorJoint_get_mode_107, METH_NOARGS, (const char *)Dtool_OdeAMotorJoint_get_mode_107_comment},
  {"getMode", &Dtool_OdeAMotorJoint_get_mode_107, METH_NOARGS, (const char *)Dtool_OdeAMotorJoint_get_mode_107_comment},
  {"set_param_lo_stop", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_lo_stop_108, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_lo_stop_108_comment},
  {"setParamLoStop", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_lo_stop_108, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_lo_stop_108_comment},
  {"set_param_hi_stop", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_hi_stop_109, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_hi_stop_109_comment},
  {"setParamHiStop", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_hi_stop_109, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_hi_stop_109_comment},
  {"set_param_vel", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_vel_110, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_vel_110_comment},
  {"setParamVel", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_vel_110, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_vel_110_comment},
  {"set_param_f_max", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_f_max_111, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_f_max_111_comment},
  {"setParamFMax", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_f_max_111, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_f_max_111_comment},
  {"set_param_fudge_factor", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_fudge_factor_112, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_fudge_factor_112_comment},
  {"setParamFudgeFactor", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_fudge_factor_112, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_fudge_factor_112_comment},
  {"set_param_bounce", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_bounce_113, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_bounce_113_comment},
  {"setParamBounce", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_bounce_113, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_bounce_113_comment},
  {"set_param_CFM", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_CFM_114, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_CFM_114_comment},
  {"setParamCFM", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_CFM_114, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_CFM_114_comment},
  {"set_param_stop_ERP", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_stop_ERP_115, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_stop_ERP_115_comment},
  {"setParamStopERP", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_stop_ERP_115, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_stop_ERP_115_comment},
  {"set_param_stop_CFM", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_stop_CFM_116, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_stop_CFM_116_comment},
  {"setParamStopCFM", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_stop_CFM_116, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_stop_CFM_116_comment},
  {"get_param_lo_stop", &Dtool_OdeAMotorJoint_get_param_lo_stop_117, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_lo_stop_117_comment},
  {"getParamLoStop", &Dtool_OdeAMotorJoint_get_param_lo_stop_117, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_lo_stop_117_comment},
  {"get_param_hi_stop", &Dtool_OdeAMotorJoint_get_param_hi_stop_118, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_hi_stop_118_comment},
  {"getParamHiStop", &Dtool_OdeAMotorJoint_get_param_hi_stop_118, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_hi_stop_118_comment},
  {"get_param_vel", &Dtool_OdeAMotorJoint_get_param_vel_119, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_vel_119_comment},
  {"getParamVel", &Dtool_OdeAMotorJoint_get_param_vel_119, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_vel_119_comment},
  {"get_param_f_max", &Dtool_OdeAMotorJoint_get_param_f_max_120, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_f_max_120_comment},
  {"getParamFMax", &Dtool_OdeAMotorJoint_get_param_f_max_120, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_f_max_120_comment},
  {"get_param_fudge_factor", &Dtool_OdeAMotorJoint_get_param_fudge_factor_121, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_fudge_factor_121_comment},
  {"getParamFudgeFactor", &Dtool_OdeAMotorJoint_get_param_fudge_factor_121, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_fudge_factor_121_comment},
  {"get_param_bounce", &Dtool_OdeAMotorJoint_get_param_bounce_122, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_bounce_122_comment},
  {"getParamBounce", &Dtool_OdeAMotorJoint_get_param_bounce_122, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_bounce_122_comment},
  {"get_param_CFM", &Dtool_OdeAMotorJoint_get_param_CFM_123, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_CFM_123_comment},
  {"getParamCFM", &Dtool_OdeAMotorJoint_get_param_CFM_123, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_CFM_123_comment},
  {"get_param_stop_ERP", &Dtool_OdeAMotorJoint_get_param_stop_ERP_124, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_stop_ERP_124_comment},
  {"getParamStopERP", &Dtool_OdeAMotorJoint_get_param_stop_ERP_124, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_stop_ERP_124_comment},
  {"get_param_stop_CFM", &Dtool_OdeAMotorJoint_get_param_stop_CFM_125, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_stop_CFM_125_comment},
  {"getParamStopCFM", &Dtool_OdeAMotorJoint_get_param_stop_CFM_125, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_stop_CFM_125_comment},
  {"get_class_type", &Dtool_OdeAMotorJoint_get_class_type_126, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeAMotorJoint_get_class_type_126_comment},
  {"getClassType", &Dtool_OdeAMotorJoint_get_class_type_126, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeAMotorJoint_get_class_type_126_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_axes", (PyCFunction) &MakeSeq_OdeAMotorJoint_get_axes, METH_NOARGS, NULL},
  { "getAxes", (PyCFunction) &MakeSeq_OdeAMotorJoint_get_axes, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeAMotorJoint = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeAMotorJoint = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeAMotorJoint = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeAMotorJoint = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeAMotorJoint = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeAMotorJoint",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeAMotorJoint,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeAMotorJoint,
    &Dtool_SequenceMethods_OdeAMotorJoint,
    &Dtool_MappingMethods_OdeAMotorJoint,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeAMotorJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeAMotorJoint,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeAMotorJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeAMotorJoint,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeAMotorJoint,
  Dtool_UpcastInterface_OdeAMotorJoint,
  Dtool_DowncastInterface_OdeAMotorJoint,
  (CoerceFunction)Dtool_ConstCoerce_OdeAMotorJoint,
  (CoerceFunction)Dtool_Coerce_OdeAMotorJoint,
};

static void Dtool_PyModuleClassInit_OdeAMotorJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(NULL);
    Dtool_OdeAMotorJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    PyObject *dict = PyDict_New();
    Dtool_OdeAMotorJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeAMotorJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeAMotorJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeAMotorJoint);
  }
}

/**
 * Python method tables for OdeBallJoint (OdeBallJoint)
 */
static PyMethodDef Dtool_Methods_OdeBallJoint[] = {
  {"set_anchor", (PyCFunction) &Dtool_OdeBallJoint_set_anchor_129, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBallJoint_set_anchor_129_comment},
  {"setAnchor", (PyCFunction) &Dtool_OdeBallJoint_set_anchor_129, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBallJoint_set_anchor_129_comment},
  {"set_anchor2", (PyCFunction) &Dtool_OdeBallJoint_set_anchor2_130, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBallJoint_set_anchor2_130_comment},
  {"setAnchor2", (PyCFunction) &Dtool_OdeBallJoint_set_anchor2_130, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBallJoint_set_anchor2_130_comment},
  {"get_anchor", &Dtool_OdeBallJoint_get_anchor_131, METH_NOARGS, (const char *)Dtool_OdeBallJoint_get_anchor_131_comment},
  {"getAnchor", &Dtool_OdeBallJoint_get_anchor_131, METH_NOARGS, (const char *)Dtool_OdeBallJoint_get_anchor_131_comment},
  {"get_anchor2", &Dtool_OdeBallJoint_get_anchor2_132, METH_NOARGS, (const char *)Dtool_OdeBallJoint_get_anchor2_132_comment},
  {"getAnchor2", &Dtool_OdeBallJoint_get_anchor2_132, METH_NOARGS, (const char *)Dtool_OdeBallJoint_get_anchor2_132_comment},
  {"get_class_type", &Dtool_OdeBallJoint_get_class_type_133, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeBallJoint_get_class_type_133_comment},
  {"getClassType", &Dtool_OdeBallJoint_get_class_type_133, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeBallJoint_get_class_type_133_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeBallJoint = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeBallJoint = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeBallJoint = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeBallJoint = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeBallJoint = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeBallJoint",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeBallJoint,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeBallJoint,
    &Dtool_SequenceMethods_OdeBallJoint,
    &Dtool_MappingMethods_OdeBallJoint,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeBallJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeBallJoint,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeBallJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeBallJoint,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeBallJoint,
  Dtool_UpcastInterface_OdeBallJoint,
  Dtool_DowncastInterface_OdeBallJoint,
  (CoerceFunction)Dtool_ConstCoerce_OdeBallJoint,
  (CoerceFunction)Dtool_Coerce_OdeBallJoint,
};

static void Dtool_PyModuleClassInit_OdeBallJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(NULL);
    Dtool_OdeBallJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    PyObject *dict = PyDict_New();
    Dtool_OdeBallJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeBallJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeBallJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeBallJoint);
  }
}

/**
 * Python method tables for OdeMass (OdeMass)
 */
static PyMethodDef Dtool_Methods_OdeMass[] = {
  {"check", &Dtool_OdeMass_check_137, METH_NOARGS, (const char *)Dtool_OdeMass_check_137_comment},
  {"set_zero", &Dtool_OdeMass_set_zero_138, METH_NOARGS, (const char *)Dtool_OdeMass_set_zero_138_comment},
  {"setZero", &Dtool_OdeMass_set_zero_138, METH_NOARGS, (const char *)Dtool_OdeMass_set_zero_138_comment},
  {"set_parameters", (PyCFunction) &Dtool_OdeMass_set_parameters_139, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_parameters_139_comment},
  {"setParameters", (PyCFunction) &Dtool_OdeMass_set_parameters_139, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_parameters_139_comment},
  {"set_sphere", (PyCFunction) &Dtool_OdeMass_set_sphere_140, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_sphere_140_comment},
  {"setSphere", (PyCFunction) &Dtool_OdeMass_set_sphere_140, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_sphere_140_comment},
  {"set_sphere_total", (PyCFunction) &Dtool_OdeMass_set_sphere_total_141, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_sphere_total_141_comment},
  {"setSphereTotal", (PyCFunction) &Dtool_OdeMass_set_sphere_total_141, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_sphere_total_141_comment},
  {"set_capsule", (PyCFunction) &Dtool_OdeMass_set_capsule_142, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_capsule_142_comment},
  {"setCapsule", (PyCFunction) &Dtool_OdeMass_set_capsule_142, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_capsule_142_comment},
  {"set_capsule_total", (PyCFunction) &Dtool_OdeMass_set_capsule_total_143, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_capsule_total_143_comment},
  {"setCapsuleTotal", (PyCFunction) &Dtool_OdeMass_set_capsule_total_143, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_capsule_total_143_comment},
  {"set_cylinder", (PyCFunction) &Dtool_OdeMass_set_cylinder_144, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_cylinder_144_comment},
  {"setCylinder", (PyCFunction) &Dtool_OdeMass_set_cylinder_144, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_cylinder_144_comment},
  {"set_cylinder_total", (PyCFunction) &Dtool_OdeMass_set_cylinder_total_145, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_cylinder_total_145_comment},
  {"setCylinderTotal", (PyCFunction) &Dtool_OdeMass_set_cylinder_total_145, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_cylinder_total_145_comment},
  {"set_box", (PyCFunction) &Dtool_OdeMass_set_box_146, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_box_146_comment},
  {"setBox", (PyCFunction) &Dtool_OdeMass_set_box_146, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_box_146_comment},
  {"set_box_total", (PyCFunction) &Dtool_OdeMass_set_box_total_147, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_box_total_147_comment},
  {"setBoxTotal", (PyCFunction) &Dtool_OdeMass_set_box_total_147, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_box_total_147_comment},
  {"adjust", &Dtool_OdeMass_adjust_148, METH_O, (const char *)Dtool_OdeMass_adjust_148_comment},
  {"translate", (PyCFunction) &Dtool_OdeMass_translate_149, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_translate_149_comment},
  {"rotate", &Dtool_OdeMass_rotate_150, METH_O, (const char *)Dtool_OdeMass_rotate_150_comment},
  {"add", &Dtool_OdeMass_add_151, METH_O, (const char *)Dtool_OdeMass_add_151_comment},
  {"get_magnitude", &Dtool_OdeMass_get_magnitude_152, METH_NOARGS, (const char *)Dtool_OdeMass_get_magnitude_152_comment},
  {"getMagnitude", &Dtool_OdeMass_get_magnitude_152, METH_NOARGS, (const char *)Dtool_OdeMass_get_magnitude_152_comment},
  {"get_center", &Dtool_OdeMass_get_center_153, METH_NOARGS, (const char *)Dtool_OdeMass_get_center_153_comment},
  {"getCenter", &Dtool_OdeMass_get_center_153, METH_NOARGS, (const char *)Dtool_OdeMass_get_center_153_comment},
  {"get_inertial_tensor", &Dtool_OdeMass_get_inertial_tensor_154, METH_NOARGS, (const char *)Dtool_OdeMass_get_inertial_tensor_154_comment},
  {"getInertialTensor", &Dtool_OdeMass_get_inertial_tensor_154, METH_NOARGS, (const char *)Dtool_OdeMass_get_inertial_tensor_154_comment},
  {"write", (PyCFunction) &Dtool_OdeMass_write_155, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_write_155_comment},
  {"get_class_type", &Dtool_OdeMass_get_class_type_156, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeMass_get_class_type_156_comment},
  {"getClassType", &Dtool_OdeMass_get_class_type_156, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeMass_get_class_type_156_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     OdeMass
//////////////////
static PyObject *Dtool_Str_OdeMass(PyObject *self) {
  OdeMass *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeMass, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_OdeMass = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeMass = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeMass = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeMass = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeMass = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeMass",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeMass,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeMass,
    &Dtool_SequenceMethods_OdeMass,
    &Dtool_MappingMethods_OdeMass,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_OdeMass,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeMass,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeMass,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeMass,
    PyType_GenericAlloc,
    Dtool_new_OdeMass,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeMass,
  Dtool_UpcastInterface_OdeMass,
  Dtool_DowncastInterface_OdeMass,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_OdeMass(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_OdeMass._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_OdeMass._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeMass) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeMass)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeMass);
  }
}

/**
 * Python method tables for OdeBody (OdeBody)
 */
static PyMethodDef Dtool_Methods_OdeBody[] = {
  {"destroy", &Dtool_OdeBody_destroy_159, METH_NOARGS, (const char *)Dtool_OdeBody_destroy_159_comment},
  {"is_empty", &Dtool_OdeBody_is_empty_160, METH_NOARGS, (const char *)Dtool_OdeBody_is_empty_160_comment},
  {"isEmpty", &Dtool_OdeBody_is_empty_160, METH_NOARGS, (const char *)Dtool_OdeBody_is_empty_160_comment},
  {"set_auto_disable_linear_threshold", &Dtool_OdeBody_set_auto_disable_linear_threshold_162, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_linear_threshold_162_comment},
  {"setAutoDisableLinearThreshold", &Dtool_OdeBody_set_auto_disable_linear_threshold_162, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_linear_threshold_162_comment},
  {"set_auto_disable_angular_threshold", &Dtool_OdeBody_set_auto_disable_angular_threshold_163, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_angular_threshold_163_comment},
  {"setAutoDisableAngularThreshold", &Dtool_OdeBody_set_auto_disable_angular_threshold_163, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_angular_threshold_163_comment},
  {"set_auto_disable_steps", &Dtool_OdeBody_set_auto_disable_steps_164, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_steps_164_comment},
  {"setAutoDisableSteps", &Dtool_OdeBody_set_auto_disable_steps_164, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_steps_164_comment},
  {"set_auto_disable_time", &Dtool_OdeBody_set_auto_disable_time_165, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_time_165_comment},
  {"setAutoDisableTime", &Dtool_OdeBody_set_auto_disable_time_165, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_time_165_comment},
  {"set_auto_disable_flag", &Dtool_OdeBody_set_auto_disable_flag_166, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_flag_166_comment},
  {"setAutoDisableFlag", &Dtool_OdeBody_set_auto_disable_flag_166, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_flag_166_comment},
  {"set_auto_disable_defaults", &Dtool_OdeBody_set_auto_disable_defaults_167, METH_NOARGS, (const char *)Dtool_OdeBody_set_auto_disable_defaults_167_comment},
  {"setAutoDisableDefaults", &Dtool_OdeBody_set_auto_disable_defaults_167, METH_NOARGS, (const char *)Dtool_OdeBody_set_auto_disable_defaults_167_comment},
  {"set_data", &Dtool_OdeBody_set_data_168, METH_O, (const char *)Dtool_OdeBody_set_data_168_comment},
  {"setData", &Dtool_OdeBody_set_data_168, METH_O, (const char *)Dtool_OdeBody_set_data_168_comment},
  {"set_position", (PyCFunction) &Dtool_OdeBody_set_position_169, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_position_169_comment},
  {"setPosition", (PyCFunction) &Dtool_OdeBody_set_position_169, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_position_169_comment},
  {"set_rotation", &Dtool_OdeBody_set_rotation_170, METH_O, (const char *)Dtool_OdeBody_set_rotation_170_comment},
  {"setRotation", &Dtool_OdeBody_set_rotation_170, METH_O, (const char *)Dtool_OdeBody_set_rotation_170_comment},
  {"set_quaternion", &Dtool_OdeBody_set_quaternion_171, METH_O, (const char *)Dtool_OdeBody_set_quaternion_171_comment},
  {"setQuaternion", &Dtool_OdeBody_set_quaternion_171, METH_O, (const char *)Dtool_OdeBody_set_quaternion_171_comment},
  {"set_linear_vel", (PyCFunction) &Dtool_OdeBody_set_linear_vel_172, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_linear_vel_172_comment},
  {"setLinearVel", (PyCFunction) &Dtool_OdeBody_set_linear_vel_172, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_linear_vel_172_comment},
  {"set_angular_vel", (PyCFunction) &Dtool_OdeBody_set_angular_vel_173, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_angular_vel_173_comment},
  {"setAngularVel", (PyCFunction) &Dtool_OdeBody_set_angular_vel_173, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_angular_vel_173_comment},
  {"set_mass", &Dtool_OdeBody_set_mass_174, METH_O, (const char *)Dtool_OdeBody_set_mass_174_comment},
  {"setMass", &Dtool_OdeBody_set_mass_174, METH_O, (const char *)Dtool_OdeBody_set_mass_174_comment},
  {"get_auto_disable_linear_threshold", &Dtool_OdeBody_get_auto_disable_linear_threshold_175, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_linear_threshold_175_comment},
  {"getAutoDisableLinearThreshold", &Dtool_OdeBody_get_auto_disable_linear_threshold_175, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_linear_threshold_175_comment},
  {"get_auto_disable_angular_threshold", &Dtool_OdeBody_get_auto_disable_angular_threshold_176, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_angular_threshold_176_comment},
  {"getAutoDisableAngularThreshold", &Dtool_OdeBody_get_auto_disable_angular_threshold_176, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_angular_threshold_176_comment},
  {"get_auto_disable_steps", &Dtool_OdeBody_get_auto_disable_steps_177, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_steps_177_comment},
  {"getAutoDisableSteps", &Dtool_OdeBody_get_auto_disable_steps_177, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_steps_177_comment},
  {"get_auto_disable_time", &Dtool_OdeBody_get_auto_disable_time_178, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_time_178_comment},
  {"getAutoDisableTime", &Dtool_OdeBody_get_auto_disable_time_178, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_time_178_comment},
  {"get_auto_disable_flag", &Dtool_OdeBody_get_auto_disable_flag_179, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_flag_179_comment},
  {"getAutoDisableFlag", &Dtool_OdeBody_get_auto_disable_flag_179, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_flag_179_comment},
  {"get_data", &Dtool_OdeBody_get_data_180, METH_NOARGS, (const char *)Dtool_OdeBody_get_data_180_comment},
  {"getData", &Dtool_OdeBody_get_data_180, METH_NOARGS, (const char *)Dtool_OdeBody_get_data_180_comment},
  {"get_position", &Dtool_OdeBody_get_position_181, METH_NOARGS, (const char *)Dtool_OdeBody_get_position_181_comment},
  {"getPosition", &Dtool_OdeBody_get_position_181, METH_NOARGS, (const char *)Dtool_OdeBody_get_position_181_comment},
  {"get_rotation", &Dtool_OdeBody_get_rotation_182, METH_NOARGS, (const char *)Dtool_OdeBody_get_rotation_182_comment},
  {"getRotation", &Dtool_OdeBody_get_rotation_182, METH_NOARGS, (const char *)Dtool_OdeBody_get_rotation_182_comment},
  {"get_quaternion", &Dtool_OdeBody_get_quaternion_183, METH_NOARGS, (const char *)Dtool_OdeBody_get_quaternion_183_comment},
  {"getQuaternion", &Dtool_OdeBody_get_quaternion_183, METH_NOARGS, (const char *)Dtool_OdeBody_get_quaternion_183_comment},
  {"get_linear_vel", &Dtool_OdeBody_get_linear_vel_184, METH_NOARGS, (const char *)Dtool_OdeBody_get_linear_vel_184_comment},
  {"getLinearVel", &Dtool_OdeBody_get_linear_vel_184, METH_NOARGS, (const char *)Dtool_OdeBody_get_linear_vel_184_comment},
  {"get_angular_vel", &Dtool_OdeBody_get_angular_vel_185, METH_NOARGS, (const char *)Dtool_OdeBody_get_angular_vel_185_comment},
  {"getAngularVel", &Dtool_OdeBody_get_angular_vel_185, METH_NOARGS, (const char *)Dtool_OdeBody_get_angular_vel_185_comment},
  {"get_mass", &Dtool_OdeBody_get_mass_186, METH_NOARGS, (const char *)Dtool_OdeBody_get_mass_186_comment},
  {"getMass", &Dtool_OdeBody_get_mass_186, METH_NOARGS, (const char *)Dtool_OdeBody_get_mass_186_comment},
  {"add_force", (PyCFunction) &Dtool_OdeBody_add_force_187, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_force_187_comment},
  {"addForce", (PyCFunction) &Dtool_OdeBody_add_force_187, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_force_187_comment},
  {"add_torque", (PyCFunction) &Dtool_OdeBody_add_torque_188, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_torque_188_comment},
  {"addTorque", (PyCFunction) &Dtool_OdeBody_add_torque_188, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_torque_188_comment},
  {"add_rel_force", (PyCFunction) &Dtool_OdeBody_add_rel_force_189, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_rel_force_189_comment},
  {"addRelForce", (PyCFunction) &Dtool_OdeBody_add_rel_force_189, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_rel_force_189_comment},
  {"add_rel_torque", (PyCFunction) &Dtool_OdeBody_add_rel_torque_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_rel_torque_190_comment},
  {"addRelTorque", (PyCFunction) &Dtool_OdeBody_add_rel_torque_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_rel_torque_190_comment},
  {"add_force_at_pos", (PyCFunction) &Dtool_OdeBody_add_force_at_pos_191, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_force_at_pos_191_comment},
  {"addForceAtPos", (PyCFunction) &Dtool_OdeBody_add_force_at_pos_191, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_force_at_pos_191_comment},
  {"add_force_at_rel_pos", (PyCFunction) &Dtool_OdeBody_add_force_at_rel_pos_192, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_force_at_rel_pos_192_comment},
  {"addForceAtRelPos", (PyCFunction) &Dtool_OdeBody_add_force_at_rel_pos_192, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_force_at_rel_pos_192_comment},
  {"add_rel_force_at_pos", (PyCFunction) &Dtool_OdeBody_add_rel_force_at_pos_193, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_rel_force_at_pos_193_comment},
  {"addRelForceAtPos", (PyCFunction) &Dtool_OdeBody_add_rel_force_at_pos_193, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_rel_force_at_pos_193_comment},
  {"add_rel_force_at_rel_pos", (PyCFunction) &Dtool_OdeBody_add_rel_force_at_rel_pos_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_rel_force_at_rel_pos_194_comment},
  {"addRelForceAtRelPos", (PyCFunction) &Dtool_OdeBody_add_rel_force_at_rel_pos_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_rel_force_at_rel_pos_194_comment},
  {"set_force", (PyCFunction) &Dtool_OdeBody_set_force_195, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_force_195_comment},
  {"setForce", (PyCFunction) &Dtool_OdeBody_set_force_195, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_force_195_comment},
  {"set_torque", (PyCFunction) &Dtool_OdeBody_set_torque_196, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_torque_196_comment},
  {"setTorque", (PyCFunction) &Dtool_OdeBody_set_torque_196, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_torque_196_comment},
  {"get_rel_point_pos", (PyCFunction) &Dtool_OdeBody_get_rel_point_pos_197, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_get_rel_point_pos_197_comment},
  {"getRelPointPos", (PyCFunction) &Dtool_OdeBody_get_rel_point_pos_197, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_get_rel_point_pos_197_comment},
  {"get_rel_point_vel", (PyCFunction) &Dtool_OdeBody_get_rel_point_vel_198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_get_rel_point_vel_198_comment},
  {"getRelPointVel", (PyCFunction) &Dtool_OdeBody_get_rel_point_vel_198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_get_rel_point_vel_198_comment},
  {"get_point_vel", (PyCFunction) &Dtool_OdeBody_get_point_vel_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_get_point_vel_199_comment},
  {"getPointVel", (PyCFunction) &Dtool_OdeBody_get_point_vel_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_get_point_vel_199_comment},
  {"get_pos_rel_point", (PyCFunction) &Dtool_OdeBody_get_pos_rel_point_200, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_get_pos_rel_point_200_comment},
  {"getPosRelPoint", (PyCFunction) &Dtool_OdeBody_get_pos_rel_point_200, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_get_pos_rel_point_200_comment},
  {"vector_to_world", (PyCFunction) &Dtool_OdeBody_vector_to_world_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_vector_to_world_201_comment},
  {"vectorToWorld", (PyCFunction) &Dtool_OdeBody_vector_to_world_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_vector_to_world_201_comment},
  {"vector_from_world", (PyCFunction) &Dtool_OdeBody_vector_from_world_202, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_vector_from_world_202_comment},
  {"vectorFromWorld", (PyCFunction) &Dtool_OdeBody_vector_from_world_202, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_vector_from_world_202_comment},
  {"set_finite_rotation_mode", &Dtool_OdeBody_set_finite_rotation_mode_203, METH_O, (const char *)Dtool_OdeBody_set_finite_rotation_mode_203_comment},
  {"setFiniteRotationMode", &Dtool_OdeBody_set_finite_rotation_mode_203, METH_O, (const char *)Dtool_OdeBody_set_finite_rotation_mode_203_comment},
  {"set_finite_rotation_axis", (PyCFunction) &Dtool_OdeBody_set_finite_rotation_axis_204, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_finite_rotation_axis_204_comment},
  {"setFiniteRotationAxis", (PyCFunction) &Dtool_OdeBody_set_finite_rotation_axis_204, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_finite_rotation_axis_204_comment},
  {"get_finite_rotation_mode", &Dtool_OdeBody_get_finite_rotation_mode_205, METH_NOARGS, (const char *)Dtool_OdeBody_get_finite_rotation_mode_205_comment},
  {"getFiniteRotationMode", &Dtool_OdeBody_get_finite_rotation_mode_205, METH_NOARGS, (const char *)Dtool_OdeBody_get_finite_rotation_mode_205_comment},
  {"get_finite_rotation_axis", &Dtool_OdeBody_get_finite_rotation_axis_206, METH_NOARGS, (const char *)Dtool_OdeBody_get_finite_rotation_axis_206_comment},
  {"getFiniteRotationAxis", &Dtool_OdeBody_get_finite_rotation_axis_206, METH_NOARGS, (const char *)Dtool_OdeBody_get_finite_rotation_axis_206_comment},
  {"get_num_joints", &Dtool_OdeBody_get_num_joints_207, METH_NOARGS, (const char *)Dtool_OdeBody_get_num_joints_207_comment},
  {"getNumJoints", &Dtool_OdeBody_get_num_joints_207, METH_NOARGS, (const char *)Dtool_OdeBody_get_num_joints_207_comment},
  {"get_joint", &Dtool_OdeBody_get_joint_208, METH_O, (const char *)Dtool_OdeBody_get_joint_208_comment},
  {"getJoint", &Dtool_OdeBody_get_joint_208, METH_O, (const char *)Dtool_OdeBody_get_joint_208_comment},
  {"get_converted_joint", &Dtool_OdeBody_get_converted_joint_210, METH_O, (const char *)Dtool_OdeBody_get_converted_joint_210_comment},
  {"getConvertedJoint", &Dtool_OdeBody_get_converted_joint_210, METH_O, (const char *)Dtool_OdeBody_get_converted_joint_210_comment},
  {"enable", &Dtool_OdeBody_enable_211, METH_NOARGS, (const char *)Dtool_OdeBody_enable_211_comment},
  {"disable", &Dtool_OdeBody_disable_212, METH_NOARGS, (const char *)Dtool_OdeBody_disable_212_comment},
  {"is_enabled", &Dtool_OdeBody_is_enabled_213, METH_NOARGS, (const char *)Dtool_OdeBody_is_enabled_213_comment},
  {"isEnabled", &Dtool_OdeBody_is_enabled_213, METH_NOARGS, (const char *)Dtool_OdeBody_is_enabled_213_comment},
  {"set_gravity_mode", &Dtool_OdeBody_set_gravity_mode_214, METH_O, (const char *)Dtool_OdeBody_set_gravity_mode_214_comment},
  {"setGravityMode", &Dtool_OdeBody_set_gravity_mode_214, METH_O, (const char *)Dtool_OdeBody_set_gravity_mode_214_comment},
  {"get_gravity_mode", &Dtool_OdeBody_get_gravity_mode_215, METH_NOARGS, (const char *)Dtool_OdeBody_get_gravity_mode_215_comment},
  {"getGravityMode", &Dtool_OdeBody_get_gravity_mode_215, METH_NOARGS, (const char *)Dtool_OdeBody_get_gravity_mode_215_comment},
  {"write", (PyCFunction) &Dtool_OdeBody_write_216, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_write_216_comment},
  {"compare_to", &Dtool_OdeBody_compare_to_218, METH_O, (const char *)Dtool_OdeBody_compare_to_218_comment},
  {"compareTo", &Dtool_OdeBody_compare_to_218, METH_O, (const char *)Dtool_OdeBody_compare_to_218_comment},
  {"get_class_type", &Dtool_OdeBody_get_class_type_219, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeBody_get_class_type_219_comment},
  {"getClassType", &Dtool_OdeBody_get_class_type_219, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeBody_get_class_type_219_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_joints", (PyCFunction) &MakeSeq_OdeBody_get_joints, METH_NOARGS, NULL},
  { "getJoints", (PyCFunction) &MakeSeq_OdeBody_get_joints, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeBody slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_OdeBody_operator_typecast_bool_217_nb_bool(PyObject *self) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeBody slot tp_compare -> compare_to
//////////////////
static int Dtool_OdeBody_compare_to_218_tp_compare(PyObject *self, PyObject *arg) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int OdeBody::compare_to(OdeBody const &other) const
  OdeBody const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_OdeBody(arg, arg_this, arg_manage)) {
    Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.compare_to", "OdeBody");
    return -1;
  }
  int return_value = (*(const OdeBody*)local_this).compare_to(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(OdeBody self, const OdeBody other)\n");
  }
  return -1;
}

//////////////////
//  A __str__ function
//     OdeBody
//////////////////
static PyObject *Dtool_Str_OdeBody(PyObject *self) {
  OdeBody *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_OdeBody = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  &Dtool_OdeBody_operator_typecast_bool_217_nb_bool,
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeBody = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeBody = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeBody = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeBody = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeBody",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeBody,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_OdeBody_compare_to_218_tp_compare,
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeBody,
    &Dtool_SequenceMethods_OdeBody,
    &Dtool_MappingMethods_OdeBody,
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Str_OdeBody,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeBody,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
#if PY_MAJOR_VERSION >= 3
    &DTOOL_PyObject_RichCompare,
#else
    0, // tp_richcompare
#endif
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeBody,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeBody,
    PyType_GenericAlloc,
    Dtool_new_OdeBody,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeBody,
  Dtool_UpcastInterface_OdeBody,
  Dtool_DowncastInterface_OdeBody,
  (CoerceFunction)Dtool_ConstCoerce_OdeBody,
  (CoerceFunction)Dtool_Coerce_OdeBody,
};

static void Dtool_PyModuleClassInit_OdeBody(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != NULL);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(NULL);
    Dtool_OdeBody._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    PyObject *dict = PyDict_New();
    Dtool_OdeBody._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeBody) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeBody)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeBody);
  }
}

/**
 * Python method tables for OdeSpace (OdeSpace)
 */
static PyMethodDef Dtool_Methods_OdeSpace[] = {
  {"destroy", &Dtool_OdeSpace_destroy_221, METH_NOARGS, (const char *)Dtool_OdeSpace_destroy_221_comment},
  {"is_empty", &Dtool_OdeSpace_is_empty_222, METH_NOARGS, (const char *)Dtool_OdeSpace_is_empty_222_comment},
  {"isEmpty", &Dtool_OdeSpace_is_empty_222, METH_NOARGS, (const char *)Dtool_OdeSpace_is_empty_222_comment},
  {"set_cleanup", &Dtool_OdeSpace_set_cleanup_223, METH_O, (const char *)Dtool_OdeSpace_set_cleanup_223_comment},
  {"setCleanup", &Dtool_OdeSpace_set_cleanup_223, METH_O, (const char *)Dtool_OdeSpace_set_cleanup_223_comment},
  {"get_cleanup", &Dtool_OdeSpace_get_cleanup_224, METH_NOARGS, (const char *)Dtool_OdeSpace_get_cleanup_224_comment},
  {"getCleanup", &Dtool_OdeSpace_get_cleanup_224, METH_NOARGS, (const char *)Dtool_OdeSpace_get_cleanup_224_comment},
  {"query", &Dtool_OdeSpace_query_225, METH_O, (const char *)Dtool_OdeSpace_query_225_comment},
  {"get_num_geoms", &Dtool_OdeSpace_get_num_geoms_226, METH_NOARGS, (const char *)Dtool_OdeSpace_get_num_geoms_226_comment},
  {"getNumGeoms", &Dtool_OdeSpace_get_num_geoms_226, METH_NOARGS, (const char *)Dtool_OdeSpace_get_num_geoms_226_comment},
  {"get_AABB", (PyCFunction) &Dtool_OdeSpace_get_AABB_227, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSpace_get_AABB_227_comment},
  {"getAABB", (PyCFunction) &Dtool_OdeSpace_get_AABB_227, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSpace_get_AABB_227_comment},
  {"get_AA_bounds", &Dtool_OdeSpace_get_AA_bounds_228, METH_NOARGS, (const char *)Dtool_OdeSpace_get_AA_bounds_228_comment},
  {"getAABounds", &Dtool_OdeSpace_get_AA_bounds_228, METH_NOARGS, (const char *)Dtool_OdeSpace_get_AA_bounds_228_comment},
  {"is_space", &Dtool_OdeSpace_is_space_229, METH_NOARGS, (const char *)Dtool_OdeSpace_is_space_229_comment},
  {"isSpace", &Dtool_OdeSpace_is_space_229, METH_NOARGS, (const char *)Dtool_OdeSpace_is_space_229_comment},
  {"get_class", &Dtool_OdeSpace_get_class_230, METH_NOARGS, (const char *)Dtool_OdeSpace_get_class_230_comment},
  {"getClass", &Dtool_OdeSpace_get_class_230, METH_NOARGS, (const char *)Dtool_OdeSpace_get_class_230_comment},
  {"set_category_bits", &Dtool_OdeSpace_set_category_bits_231, METH_O, (const char *)Dtool_OdeSpace_set_category_bits_231_comment},
  {"setCategoryBits", &Dtool_OdeSpace_set_category_bits_231, METH_O, (const char *)Dtool_OdeSpace_set_category_bits_231_comment},
  {"set_collide_bits", &Dtool_OdeSpace_set_collide_bits_232, METH_O, (const char *)Dtool_OdeSpace_set_collide_bits_232_comment},
  {"setCollideBits", &Dtool_OdeSpace_set_collide_bits_232, METH_O, (const char *)Dtool_OdeSpace_set_collide_bits_232_comment},
  {"get_category_bits", &Dtool_OdeSpace_get_category_bits_233, METH_NOARGS, (const char *)Dtool_OdeSpace_get_category_bits_233_comment},
  {"getCategoryBits", &Dtool_OdeSpace_get_category_bits_233, METH_NOARGS, (const char *)Dtool_OdeSpace_get_category_bits_233_comment},
  {"get_collide_bits", &Dtool_OdeSpace_get_collide_bits_234, METH_NOARGS, (const char *)Dtool_OdeSpace_get_collide_bits_234_comment},
  {"getCollideBits", &Dtool_OdeSpace_get_collide_bits_234, METH_NOARGS, (const char *)Dtool_OdeSpace_get_collide_bits_234_comment},
  {"enable", &Dtool_OdeSpace_enable_235, METH_NOARGS, (const char *)Dtool_OdeSpace_enable_235_comment},
  {"disable", &Dtool_OdeSpace_disable_236, METH_NOARGS, (const char *)Dtool_OdeSpace_disable_236_comment},
  {"is_enabled", &Dtool_OdeSpace_is_enabled_237, METH_NOARGS, (const char *)Dtool_OdeSpace_is_enabled_237_comment},
  {"isEnabled", &Dtool_OdeSpace_is_enabled_237, METH_NOARGS, (const char *)Dtool_OdeSpace_is_enabled_237_comment},
  {"set_auto_collide_world", &Dtool_OdeSpace_set_auto_collide_world_238, METH_O, (const char *)Dtool_OdeSpace_set_auto_collide_world_238_comment},
  {"setAutoCollideWorld", &Dtool_OdeSpace_set_auto_collide_world_238, METH_O, (const char *)Dtool_OdeSpace_set_auto_collide_world_238_comment},
  {"set_auto_collide_joint_group", &Dtool_OdeSpace_set_auto_collide_joint_group_239, METH_O, (const char *)Dtool_OdeSpace_set_auto_collide_joint_group_239_comment},
  {"setAutoCollideJointGroup", &Dtool_OdeSpace_set_auto_collide_joint_group_239, METH_O, (const char *)Dtool_OdeSpace_set_auto_collide_joint_group_239_comment},
  {"add", &Dtool_OdeSpace_add_240, METH_O, (const char *)Dtool_OdeSpace_add_240_comment},
  {"remove", &Dtool_OdeSpace_remove_241, METH_O, (const char *)Dtool_OdeSpace_remove_241_comment},
  {"clean", &Dtool_OdeSpace_clean_242, METH_NOARGS, (const char *)Dtool_OdeSpace_clean_242_comment},
  {"get_geom", &Dtool_OdeSpace_get_geom_243, METH_O, (const char *)Dtool_OdeSpace_get_geom_243_comment},
  {"getGeom", &Dtool_OdeSpace_get_geom_243, METH_O, (const char *)Dtool_OdeSpace_get_geom_243_comment},
  {"get_space", &Dtool_OdeSpace_get_space_244, METH_NOARGS, (const char *)Dtool_OdeSpace_get_space_244_comment},
  {"getSpace", &Dtool_OdeSpace_get_space_244, METH_NOARGS, (const char *)Dtool_OdeSpace_get_space_244_comment},
  {"write", (PyCFunction) &Dtool_OdeSpace_write_245, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSpace_write_245_comment},
  {"convert_to_simple_space", &Dtool_OdeSpace_convert_to_simple_space_247, METH_NOARGS, (const char *)Dtool_OdeSpace_convert_to_simple_space_247_comment},
  {"convertToSimpleSpace", &Dtool_OdeSpace_convert_to_simple_space_247, METH_NOARGS, (const char *)Dtool_OdeSpace_convert_to_simple_space_247_comment},
  {"convert_to_hash_space", &Dtool_OdeSpace_convert_to_hash_space_248, METH_NOARGS, (const char *)Dtool_OdeSpace_convert_to_hash_space_248_comment},
  {"convertToHashSpace", &Dtool_OdeSpace_convert_to_hash_space_248, METH_NOARGS, (const char *)Dtool_OdeSpace_convert_to_hash_space_248_comment},
  {"convert_to_quad_tree_space", &Dtool_OdeSpace_convert_to_quad_tree_space_249, METH_NOARGS, (const char *)Dtool_OdeSpace_convert_to_quad_tree_space_249_comment},
  {"convertToQuadTreeSpace", &Dtool_OdeSpace_convert_to_quad_tree_space_249, METH_NOARGS, (const char *)Dtool_OdeSpace_convert_to_quad_tree_space_249_comment},
  {"convert", &Dtool_OdeSpace_convert_250, METH_NOARGS, (const char *)Dtool_OdeSpace_convert_250_comment},
  {"get_converted_geom", &Dtool_OdeSpace_get_converted_geom_251, METH_O, (const char *)Dtool_OdeSpace_get_converted_geom_251_comment},
  {"getConvertedGeom", &Dtool_OdeSpace_get_converted_geom_251, METH_O, (const char *)Dtool_OdeSpace_get_converted_geom_251_comment},
  {"get_converted_space", &Dtool_OdeSpace_get_converted_space_252, METH_NOARGS, (const char *)Dtool_OdeSpace_get_converted_space_252_comment},
  {"getConvertedSpace", &Dtool_OdeSpace_get_converted_space_252, METH_NOARGS, (const char *)Dtool_OdeSpace_get_converted_space_252_comment},
  {"auto_collide", &Dtool_OdeSpace_auto_collide_253, METH_NOARGS, (const char *)Dtool_OdeSpace_auto_collide_253_comment},
  {"autoCollide", &Dtool_OdeSpace_auto_collide_253, METH_NOARGS, (const char *)Dtool_OdeSpace_auto_collide_253_comment},
  {"collide", (PyCFunction) &Dtool_OdeSpace_collide_254, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSpace_collide_254_comment},
  {"set_collide_id", (PyCFunction) &Dtool_OdeSpace_set_collide_id_255, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSpace_set_collide_id_255_comment},
  {"setCollideId", (PyCFunction) &Dtool_OdeSpace_set_collide_id_255, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSpace_set_collide_id_255_comment},
  {"set_surface_type", (PyCFunction) &Dtool_OdeSpace_set_surface_type_256, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSpace_set_surface_type_256_comment},
  {"setSurfaceType", (PyCFunction) &Dtool_OdeSpace_set_surface_type_256, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSpace_set_surface_type_256_comment},
  {"get_surface_type", &Dtool_OdeSpace_get_surface_type_257, METH_O, (const char *)Dtool_OdeSpace_get_surface_type_257_comment},
  {"getSurfaceType", &Dtool_OdeSpace_get_surface_type_257, METH_O, (const char *)Dtool_OdeSpace_get_surface_type_257_comment},
  {"get_collide_id", &Dtool_OdeSpace_get_collide_id_258, METH_O, (const char *)Dtool_OdeSpace_get_collide_id_258_comment},
  {"getCollideId", &Dtool_OdeSpace_get_collide_id_258, METH_O, (const char *)Dtool_OdeSpace_get_collide_id_258_comment},
  {"set_collision_event", &Dtool_OdeSpace_set_collision_event_259, METH_O, (const char *)Dtool_OdeSpace_set_collision_event_259_comment},
  {"setCollisionEvent", &Dtool_OdeSpace_set_collision_event_259, METH_O, (const char *)Dtool_OdeSpace_set_collision_event_259_comment},
  {"get_collision_event", &Dtool_OdeSpace_get_collision_event_260, METH_NOARGS, (const char *)Dtool_OdeSpace_get_collision_event_260_comment},
  {"getCollisionEvent", &Dtool_OdeSpace_get_collision_event_260, METH_NOARGS, (const char *)Dtool_OdeSpace_get_collision_event_260_comment},
  {"get_class_type", &Dtool_OdeSpace_get_class_type_261, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSpace_get_class_type_261_comment},
  {"getClassType", &Dtool_OdeSpace_get_class_type_261, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSpace_get_class_type_261_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeSpace slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_OdeSpace_operator_typecast_bool_246_nb_bool(PyObject *self) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSpace, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
//  A __str__ function
//     OdeSpace
//////////////////
static PyObject *Dtool_Str_OdeSpace(PyObject *self) {
  OdeSpace *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSpace, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_OdeSpace = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  &Dtool_OdeSpace_operator_typecast_bool_246_nb_bool,
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeSpace = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeSpace = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeSpace = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeSpace = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeSpace",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeSpace,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeSpace,
    &Dtool_SequenceMethods_OdeSpace,
    &Dtool_MappingMethods_OdeSpace,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_OdeSpace,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeSpace,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeSpace,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeSpace,
    PyType_GenericAlloc,
    Dtool_new_OdeSpace,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeSpace,
  Dtool_UpcastInterface_OdeSpace,
  Dtool_DowncastInterface_OdeSpace,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_OdeSpace(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != NULL);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(NULL);
    Dtool_OdeSpace._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    PyObject *dict = PyDict_New();
    Dtool_OdeSpace._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeSpace) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeSpace)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeSpace);
  }
}

/**
 * Python method tables for OdeGeom (OdeGeom)
 */
static PyMethodDef Dtool_Methods_OdeGeom[] = {
  {"destroy", &Dtool_OdeGeom_destroy_265, METH_NOARGS, (const char *)Dtool_OdeGeom_destroy_265_comment},
  {"is_empty", &Dtool_OdeGeom_is_empty_266, METH_NOARGS, (const char *)Dtool_OdeGeom_is_empty_266_comment},
  {"isEmpty", &Dtool_OdeGeom_is_empty_266, METH_NOARGS, (const char *)Dtool_OdeGeom_is_empty_266_comment},
  {"set_body", &Dtool_OdeGeom_set_body_268, METH_O, (const char *)Dtool_OdeGeom_set_body_268_comment},
  {"setBody", &Dtool_OdeGeom_set_body_268, METH_O, (const char *)Dtool_OdeGeom_set_body_268_comment},
  {"has_body", &Dtool_OdeGeom_has_body_269, METH_NOARGS, (const char *)Dtool_OdeGeom_has_body_269_comment},
  {"hasBody", &Dtool_OdeGeom_has_body_269, METH_NOARGS, (const char *)Dtool_OdeGeom_has_body_269_comment},
  {"get_body", &Dtool_OdeGeom_get_body_270, METH_NOARGS, (const char *)Dtool_OdeGeom_get_body_270_comment},
  {"getBody", &Dtool_OdeGeom_get_body_270, METH_NOARGS, (const char *)Dtool_OdeGeom_get_body_270_comment},
  {"set_position", (PyCFunction) &Dtool_OdeGeom_set_position_271, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeGeom_set_position_271_comment},
  {"setPosition", (PyCFunction) &Dtool_OdeGeom_set_position_271, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeGeom_set_position_271_comment},
  {"set_rotation", &Dtool_OdeGeom_set_rotation_272, METH_O, (const char *)Dtool_OdeGeom_set_rotation_272_comment},
  {"setRotation", &Dtool_OdeGeom_set_rotation_272, METH_O, (const char *)Dtool_OdeGeom_set_rotation_272_comment},
  {"set_quaternion", &Dtool_OdeGeom_set_quaternion_273, METH_O, (const char *)Dtool_OdeGeom_set_quaternion_273_comment},
  {"setQuaternion", &Dtool_OdeGeom_set_quaternion_273, METH_O, (const char *)Dtool_OdeGeom_set_quaternion_273_comment},
  {"get_position", &Dtool_OdeGeom_get_position_274, METH_NOARGS, (const char *)Dtool_OdeGeom_get_position_274_comment},
  {"getPosition", &Dtool_OdeGeom_get_position_274, METH_NOARGS, (const char *)Dtool_OdeGeom_get_position_274_comment},
  {"get_rotation", &Dtool_OdeGeom_get_rotation_275, METH_NOARGS, (const char *)Dtool_OdeGeom_get_rotation_275_comment},
  {"getRotation", &Dtool_OdeGeom_get_rotation_275, METH_NOARGS, (const char *)Dtool_OdeGeom_get_rotation_275_comment},
  {"get_quaternion", &Dtool_OdeGeom_get_quaternion_276, METH_NOARGS, (const char *)Dtool_OdeGeom_get_quaternion_276_comment},
  {"getQuaternion", &Dtool_OdeGeom_get_quaternion_276, METH_NOARGS, (const char *)Dtool_OdeGeom_get_quaternion_276_comment},
  {"get_AABB", (PyCFunction) &Dtool_OdeGeom_get_AABB_277, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeGeom_get_AABB_277_comment},
  {"getAABB", (PyCFunction) &Dtool_OdeGeom_get_AABB_277, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeGeom_get_AABB_277_comment},
  {"get_AA_bounds", &Dtool_OdeGeom_get_AA_bounds_278, METH_NOARGS, (const char *)Dtool_OdeGeom_get_AA_bounds_278_comment},
  {"getAABounds", &Dtool_OdeGeom_get_AA_bounds_278, METH_NOARGS, (const char *)Dtool_OdeGeom_get_AA_bounds_278_comment},
  {"is_space", &Dtool_OdeGeom_is_space_279, METH_NOARGS, (const char *)Dtool_OdeGeom_is_space_279_comment},
  {"isSpace", &Dtool_OdeGeom_is_space_279, METH_NOARGS, (const char *)Dtool_OdeGeom_is_space_279_comment},
  {"get_class", &Dtool_OdeGeom_get_class_280, METH_NOARGS, (const char *)Dtool_OdeGeom_get_class_280_comment},
  {"getClass", &Dtool_OdeGeom_get_class_280, METH_NOARGS, (const char *)Dtool_OdeGeom_get_class_280_comment},
  {"set_category_bits", &Dtool_OdeGeom_set_category_bits_281, METH_O, (const char *)Dtool_OdeGeom_set_category_bits_281_comment},
  {"setCategoryBits", &Dtool_OdeGeom_set_category_bits_281, METH_O, (const char *)Dtool_OdeGeom_set_category_bits_281_comment},
  {"set_collide_bits", &Dtool_OdeGeom_set_collide_bits_282, METH_O, (const char *)Dtool_OdeGeom_set_collide_bits_282_comment},
  {"setCollideBits", &Dtool_OdeGeom_set_collide_bits_282, METH_O, (const char *)Dtool_OdeGeom_set_collide_bits_282_comment},
  {"get_category_bits", &Dtool_OdeGeom_get_category_bits_283, METH_NOARGS, (const char *)Dtool_OdeGeom_get_category_bits_283_comment},
  {"getCategoryBits", &Dtool_OdeGeom_get_category_bits_283, METH_NOARGS, (const char *)Dtool_OdeGeom_get_category_bits_283_comment},
  {"get_collide_bits", &Dtool_OdeGeom_get_collide_bits_284, METH_NOARGS, (const char *)Dtool_OdeGeom_get_collide_bits_284_comment},
  {"getCollideBits", &Dtool_OdeGeom_get_collide_bits_284, METH_NOARGS, (const char *)Dtool_OdeGeom_get_collide_bits_284_comment},
  {"enable", &Dtool_OdeGeom_enable_285, METH_NOARGS, (const char *)Dtool_OdeGeom_enable_285_comment},
  {"disable", &Dtool_OdeGeom_disable_286, METH_NOARGS, (const char *)Dtool_OdeGeom_disable_286_comment},
  {"is_enabled", &Dtool_OdeGeom_is_enabled_287, METH_NOARGS, (const char *)Dtool_OdeGeom_is_enabled_287_comment},
  {"isEnabled", &Dtool_OdeGeom_is_enabled_287, METH_NOARGS, (const char *)Dtool_OdeGeom_is_enabled_287_comment},
  {"set_offset_position", (PyCFunction) &Dtool_OdeGeom_set_offset_position_288, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeGeom_set_offset_position_288_comment},
  {"setOffsetPosition", (PyCFunction) &Dtool_OdeGeom_set_offset_position_288, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeGeom_set_offset_position_288_comment},
  {"set_offset_rotation", &Dtool_OdeGeom_set_offset_rotation_289, METH_O, (const char *)Dtool_OdeGeom_set_offset_rotation_289_comment},
  {"setOffsetRotation", &Dtool_OdeGeom_set_offset_rotation_289, METH_O, (const char *)Dtool_OdeGeom_set_offset_rotation_289_comment},
  {"set_offset_quaternion", &Dtool_OdeGeom_set_offset_quaternion_290, METH_O, (const char *)Dtool_OdeGeom_set_offset_quaternion_290_comment},
  {"setOffsetQuaternion", &Dtool_OdeGeom_set_offset_quaternion_290, METH_O, (const char *)Dtool_OdeGeom_set_offset_quaternion_290_comment},
  {"set_offset_world_position", (PyCFunction) &Dtool_OdeGeom_set_offset_world_position_291, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeGeom_set_offset_world_position_291_comment},
  {"setOffsetWorldPosition", (PyCFunction) &Dtool_OdeGeom_set_offset_world_position_291, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeGeom_set_offset_world_position_291_comment},
  {"set_offset_world_rotation", &Dtool_OdeGeom_set_offset_world_rotation_292, METH_O, (const char *)Dtool_OdeGeom_set_offset_world_rotation_292_comment},
  {"setOffsetWorldRotation", &Dtool_OdeGeom_set_offset_world_rotation_292, METH_O, (const char *)Dtool_OdeGeom_set_offset_world_rotation_292_comment},
  {"set_offset_world_quaternion", &Dtool_OdeGeom_set_offset_world_quaternion_293, METH_O, (const char *)Dtool_OdeGeom_set_offset_world_quaternion_293_comment},
  {"setOffsetWorldQuaternion", &Dtool_OdeGeom_set_offset_world_quaternion_293, METH_O, (const char *)Dtool_OdeGeom_set_offset_world_quaternion_293_comment},
  {"clear_offset", &Dtool_OdeGeom_clear_offset_294, METH_NOARGS, (const char *)Dtool_OdeGeom_clear_offset_294_comment},
  {"clearOffset", &Dtool_OdeGeom_clear_offset_294, METH_NOARGS, (const char *)Dtool_OdeGeom_clear_offset_294_comment},
  {"is_offset", &Dtool_OdeGeom_is_offset_295, METH_NOARGS, (const char *)Dtool_OdeGeom_is_offset_295_comment},
  {"isOffset", &Dtool_OdeGeom_is_offset_295, METH_NOARGS, (const char *)Dtool_OdeGeom_is_offset_295_comment},
  {"get_offset_position", &Dtool_OdeGeom_get_offset_position_296, METH_NOARGS, (const char *)Dtool_OdeGeom_get_offset_position_296_comment},
  {"getOffsetPosition", &Dtool_OdeGeom_get_offset_position_296, METH_NOARGS, (const char *)Dtool_OdeGeom_get_offset_position_296_comment},
  {"get_offset_rotation", &Dtool_OdeGeom_get_offset_rotation_297, METH_NOARGS, (const char *)Dtool_OdeGeom_get_offset_rotation_297_comment},
  {"getOffsetRotation", &Dtool_OdeGeom_get_offset_rotation_297, METH_NOARGS, (const char *)Dtool_OdeGeom_get_offset_rotation_297_comment},
  {"get_offset_quaternion", &Dtool_OdeGeom_get_offset_quaternion_298, METH_NOARGS, (const char *)Dtool_OdeGeom_get_offset_quaternion_298_comment},
  {"getOffsetQuaternion", &Dtool_OdeGeom_get_offset_quaternion_298, METH_NOARGS, (const char *)Dtool_OdeGeom_get_offset_quaternion_298_comment},
  {"get_space", &Dtool_OdeGeom_get_space_299, METH_NOARGS, (const char *)Dtool_OdeGeom_get_space_299_comment},
  {"getSpace", &Dtool_OdeGeom_get_space_299, METH_NOARGS, (const char *)Dtool_OdeGeom_get_space_299_comment},
  {"get_converted_space", &Dtool_OdeGeom_get_converted_space_300, METH_NOARGS, (const char *)Dtool_OdeGeom_get_converted_space_300_comment},
  {"getConvertedSpace", &Dtool_OdeGeom_get_converted_space_300, METH_NOARGS, (const char *)Dtool_OdeGeom_get_converted_space_300_comment},
  {"write", (PyCFunction) &Dtool_OdeGeom_write_301, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeGeom_write_301_comment},
  {"compare_to", &Dtool_OdeGeom_compare_to_303, METH_O, (const char *)Dtool_OdeGeom_compare_to_303_comment},
  {"compareTo", &Dtool_OdeGeom_compare_to_303, METH_O, (const char *)Dtool_OdeGeom_compare_to_303_comment},
  {"convert", &Dtool_OdeGeom_convert_304, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_304_comment},
  {"convert_to_box", &Dtool_OdeGeom_convert_to_box_305, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_box_305_comment},
  {"convertToBox", &Dtool_OdeGeom_convert_to_box_305, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_box_305_comment},
  {"convert_to_capped_cylinder", &Dtool_OdeGeom_convert_to_capped_cylinder_306, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_capped_cylinder_306_comment},
  {"convertToCappedCylinder", &Dtool_OdeGeom_convert_to_capped_cylinder_306, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_capped_cylinder_306_comment},
  {"convert_to_cylinder", &Dtool_OdeGeom_convert_to_cylinder_307, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_cylinder_307_comment},
  {"convertToCylinder", &Dtool_OdeGeom_convert_to_cylinder_307, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_cylinder_307_comment},
  {"convert_to_plane", &Dtool_OdeGeom_convert_to_plane_308, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_plane_308_comment},
  {"convertToPlane", &Dtool_OdeGeom_convert_to_plane_308, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_plane_308_comment},
  {"convert_to_ray", &Dtool_OdeGeom_convert_to_ray_309, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_ray_309_comment},
  {"convertToRay", &Dtool_OdeGeom_convert_to_ray_309, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_ray_309_comment},
  {"convert_to_sphere", &Dtool_OdeGeom_convert_to_sphere_310, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_sphere_310_comment},
  {"convertToSphere", &Dtool_OdeGeom_convert_to_sphere_310, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_sphere_310_comment},
  {"convert_to_tri_mesh", &Dtool_OdeGeom_convert_to_tri_mesh_311, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_tri_mesh_311_comment},
  {"convertToTriMesh", &Dtool_OdeGeom_convert_to_tri_mesh_311, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_tri_mesh_311_comment},
  {"convert_to_simple_space", &Dtool_OdeGeom_convert_to_simple_space_312, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_simple_space_312_comment},
  {"convertToSimpleSpace", &Dtool_OdeGeom_convert_to_simple_space_312, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_simple_space_312_comment},
  {"convert_to_hash_space", &Dtool_OdeGeom_convert_to_hash_space_313, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_hash_space_313_comment},
  {"convertToHashSpace", &Dtool_OdeGeom_convert_to_hash_space_313, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_hash_space_313_comment},
  {"convert_to_quad_tree_space", &Dtool_OdeGeom_convert_to_quad_tree_space_314, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_quad_tree_space_314_comment},
  {"convertToQuadTreeSpace", &Dtool_OdeGeom_convert_to_quad_tree_space_314, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_quad_tree_space_314_comment},
  {"get_class_type", &Dtool_OdeGeom_get_class_type_315, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeGeom_get_class_type_315_comment},
  {"getClassType", &Dtool_OdeGeom_get_class_type_315, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeGeom_get_class_type_315_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeGeom slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_OdeGeom_operator_typecast_bool_302_nb_bool(PyObject *self) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeGeom slot tp_compare -> compare_to
//////////////////
static int Dtool_OdeGeom_compare_to_303_tp_compare(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int OdeGeom::compare_to(OdeGeom const &other) const
  OdeGeom const *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 1, "OdeGeom.compare_to", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const OdeGeom*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(OdeGeom self, const OdeGeom other)\n");
  }
  return -1;
}

//////////////////
//  A __str__ function
//     OdeGeom
//////////////////
static PyObject *Dtool_Str_OdeGeom(PyObject *self) {
  OdeGeom *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_OdeGeom = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  &Dtool_OdeGeom_operator_typecast_bool_302_nb_bool,
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeGeom = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeGeom = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeGeom = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeGeom = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeGeom",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeGeom,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_OdeGeom_compare_to_303_tp_compare,
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeGeom,
    &Dtool_SequenceMethods_OdeGeom,
    &Dtool_MappingMethods_OdeGeom,
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Str_OdeGeom,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeGeom,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
#if PY_MAJOR_VERSION >= 3
    &DTOOL_PyObject_RichCompare,
#else
    0, // tp_richcompare
#endif
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeGeom,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeGeom,
    PyType_GenericAlloc,
    Dtool_new_OdeGeom,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeGeom,
  Dtool_UpcastInterface_OdeGeom,
  Dtool_DowncastInterface_OdeGeom,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_OdeGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != NULL);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(NULL);
    Dtool_OdeGeom._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    PyObject *dict = _PyDict_NewPresized(21);
    Dtool_OdeGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum OdeGeom::GeomClass;
    PyDict_SetItemString(dict, "GC_sphere", Dtool_WrapValue(OdeGeom::GC_sphere));
    PyDict_SetItemString(dict, "GCSphere", Dtool_WrapValue(OdeGeom::GC_sphere));
    PyDict_SetItemString(dict, "GC_box", Dtool_WrapValue(OdeGeom::GC_box));
    PyDict_SetItemString(dict, "GCBox", Dtool_WrapValue(OdeGeom::GC_box));
    PyDict_SetItemString(dict, "GC_capped_cylinder", Dtool_WrapValue(OdeGeom::GC_capped_cylinder));
    PyDict_SetItemString(dict, "GCCappedCylinder", Dtool_WrapValue(OdeGeom::GC_capped_cylinder));
    PyDict_SetItemString(dict, "GC_cylinder", Dtool_WrapValue(OdeGeom::GC_cylinder));
    PyDict_SetItemString(dict, "GCCylinder", Dtool_WrapValue(OdeGeom::GC_cylinder));
    PyDict_SetItemString(dict, "GC_plane", Dtool_WrapValue(OdeGeom::GC_plane));
    PyDict_SetItemString(dict, "GCPlane", Dtool_WrapValue(OdeGeom::GC_plane));
    PyDict_SetItemString(dict, "GC_ray", Dtool_WrapValue(OdeGeom::GC_ray));
    PyDict_SetItemString(dict, "GCRay", Dtool_WrapValue(OdeGeom::GC_ray));
    PyDict_SetItemString(dict, "GC_tri_mesh", Dtool_WrapValue(OdeGeom::GC_tri_mesh));
    PyDict_SetItemString(dict, "GCTriMesh", Dtool_WrapValue(OdeGeom::GC_tri_mesh));
    PyDict_SetItemString(dict, "GC_simple_space", Dtool_WrapValue(OdeGeom::GC_simple_space));
    PyDict_SetItemString(dict, "GCSimpleSpace", Dtool_WrapValue(OdeGeom::GC_simple_space));
    PyDict_SetItemString(dict, "GC_hash_space", Dtool_WrapValue(OdeGeom::GC_hash_space));
    PyDict_SetItemString(dict, "GCHashSpace", Dtool_WrapValue(OdeGeom::GC_hash_space));
    PyDict_SetItemString(dict, "GC_quad_tree_space", Dtool_WrapValue(OdeGeom::GC_quad_tree_space));
    PyDict_SetItemString(dict, "GCQuadTreeSpace", Dtool_WrapValue(OdeGeom::GC_quad_tree_space));
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeGeom);
  }
}

/**
 * Python method tables for OdeBoxGeom (OdeBoxGeom)
 */
static PyMethodDef Dtool_Methods_OdeBoxGeom[] = {
  {"set_lengths", (PyCFunction) &Dtool_OdeBoxGeom_set_lengths_319, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBoxGeom_set_lengths_319_comment},
  {"setLengths", (PyCFunction) &Dtool_OdeBoxGeom_set_lengths_319, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBoxGeom_set_lengths_319_comment},
  {"get_lengths", &Dtool_OdeBoxGeom_get_lengths_320, METH_NOARGS, (const char *)Dtool_OdeBoxGeom_get_lengths_320_comment},
  {"getLengths", &Dtool_OdeBoxGeom_get_lengths_320, METH_NOARGS, (const char *)Dtool_OdeBoxGeom_get_lengths_320_comment},
  {"get_point_depth", (PyCFunction) &Dtool_OdeBoxGeom_get_point_depth_321, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBoxGeom_get_point_depth_321_comment},
  {"getPointDepth", (PyCFunction) &Dtool_OdeBoxGeom_get_point_depth_321, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBoxGeom_get_point_depth_321_comment},
  {"get_class_type", &Dtool_OdeBoxGeom_get_class_type_322, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeBoxGeom_get_class_type_322_comment},
  {"getClassType", &Dtool_OdeBoxGeom_get_class_type_322, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeBoxGeom_get_class_type_322_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeBoxGeom = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeBoxGeom = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeBoxGeom = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeBoxGeom = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeBoxGeom = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeBoxGeom",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeBoxGeom,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeBoxGeom,
    &Dtool_SequenceMethods_OdeBoxGeom,
    &Dtool_MappingMethods_OdeBoxGeom,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeBoxGeom,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeBoxGeom,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeBoxGeom,
    PyType_GenericAlloc,
    Dtool_new_OdeBoxGeom,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeBoxGeom,
  Dtool_UpcastInterface_OdeBoxGeom,
  Dtool_DowncastInterface_OdeBoxGeom,
  (CoerceFunction)Dtool_ConstCoerce_OdeBoxGeom,
  (CoerceFunction)Dtool_Coerce_OdeBoxGeom,
};

static void Dtool_PyModuleClassInit_OdeBoxGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeGeom(NULL);
    Dtool_OdeBoxGeom._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeGeom);
    PyObject *dict = PyDict_New();
    Dtool_OdeBoxGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeBoxGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeBoxGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeBoxGeom);
  }
}

/**
 * Python method tables for OdeCappedCylinderGeom (OdeCappedCylinderGeom)
 */
static PyMethodDef Dtool_Methods_OdeCappedCylinderGeom[] = {
  {"set_params", (PyCFunction) &Dtool_OdeCappedCylinderGeom_set_params_325, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeCappedCylinderGeom_set_params_325_comment},
  {"setParams", (PyCFunction) &Dtool_OdeCappedCylinderGeom_set_params_325, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeCappedCylinderGeom_set_params_325_comment},
  {"get_radius", &Dtool_OdeCappedCylinderGeom_get_radius_327, METH_NOARGS, (const char *)Dtool_OdeCappedCylinderGeom_get_radius_327_comment},
  {"getRadius", &Dtool_OdeCappedCylinderGeom_get_radius_327, METH_NOARGS, (const char *)Dtool_OdeCappedCylinderGeom_get_radius_327_comment},
  {"get_length", &Dtool_OdeCappedCylinderGeom_get_length_328, METH_NOARGS, (const char *)Dtool_OdeCappedCylinderGeom_get_length_328_comment},
  {"getLength", &Dtool_OdeCappedCylinderGeom_get_length_328, METH_NOARGS, (const char *)Dtool_OdeCappedCylinderGeom_get_length_328_comment},
  {"get_point_depth", (PyCFunction) &Dtool_OdeCappedCylinderGeom_get_point_depth_329, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeCappedCylinderGeom_get_point_depth_329_comment},
  {"getPointDepth", (PyCFunction) &Dtool_OdeCappedCylinderGeom_get_point_depth_329, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeCappedCylinderGeom_get_point_depth_329_comment},
  {"get_class_type", &Dtool_OdeCappedCylinderGeom_get_class_type_330, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeCappedCylinderGeom_get_class_type_330_comment},
  {"getClassType", &Dtool_OdeCappedCylinderGeom_get_class_type_330, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeCappedCylinderGeom_get_class_type_330_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeCappedCylinderGeom = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeCappedCylinderGeom = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeCappedCylinderGeom = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeCappedCylinderGeom = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeCappedCylinderGeom = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeCappedCylinderGeom",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeCappedCylinderGeom,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeCappedCylinderGeom,
    &Dtool_SequenceMethods_OdeCappedCylinderGeom,
    &Dtool_MappingMethods_OdeCappedCylinderGeom,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeCappedCylinderGeom,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeCappedCylinderGeom,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeCappedCylinderGeom,
    PyType_GenericAlloc,
    Dtool_new_OdeCappedCylinderGeom,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeCappedCylinderGeom,
  Dtool_UpcastInterface_OdeCappedCylinderGeom,
  Dtool_DowncastInterface_OdeCappedCylinderGeom,
  (CoerceFunction)Dtool_ConstCoerce_OdeCappedCylinderGeom,
  (CoerceFunction)Dtool_Coerce_OdeCappedCylinderGeom,
};

static void Dtool_PyModuleClassInit_OdeCappedCylinderGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeGeom(NULL);
    Dtool_OdeCappedCylinderGeom._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeGeom);
    PyObject *dict = PyDict_New();
    Dtool_OdeCappedCylinderGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeCappedCylinderGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeCappedCylinderGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeCappedCylinderGeom);
  }
}

/**
 * Python method tables for OdeContactGeom (OdeContactGeom)
 */
static PyMethodDef Dtool_Methods_OdeContactGeom[] = {
  {"get_pos", &Dtool_OdeContactGeom_get_pos_333, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_pos_333_comment},
  {"getPos", &Dtool_OdeContactGeom_get_pos_333, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_pos_333_comment},
  {"get_normal", &Dtool_OdeContactGeom_get_normal_334, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_normal_334_comment},
  {"getNormal", &Dtool_OdeContactGeom_get_normal_334, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_normal_334_comment},
  {"get_depth", &Dtool_OdeContactGeom_get_depth_335, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_depth_335_comment},
  {"getDepth", &Dtool_OdeContactGeom_get_depth_335, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_depth_335_comment},
  {"get_g1", &Dtool_OdeContactGeom_get_g1_336, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_g1_336_comment},
  {"getG1", &Dtool_OdeContactGeom_get_g1_336, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_g1_336_comment},
  {"get_g2", &Dtool_OdeContactGeom_get_g2_337, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_g2_337_comment},
  {"getG2", &Dtool_OdeContactGeom_get_g2_337, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_g2_337_comment},
  {"get_side1", &Dtool_OdeContactGeom_get_side1_338, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_side1_338_comment},
  {"getSide1", &Dtool_OdeContactGeom_get_side1_338, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_side1_338_comment},
  {"get_side2", &Dtool_OdeContactGeom_get_side2_339, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_side2_339_comment},
  {"getSide2", &Dtool_OdeContactGeom_get_side2_339, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_side2_339_comment},
  {"set_pos", &Dtool_OdeContactGeom_set_pos_340, METH_O, (const char *)Dtool_OdeContactGeom_set_pos_340_comment},
  {"setPos", &Dtool_OdeContactGeom_set_pos_340, METH_O, (const char *)Dtool_OdeContactGeom_set_pos_340_comment},
  {"set_normal", &Dtool_OdeContactGeom_set_normal_341, METH_O, (const char *)Dtool_OdeContactGeom_set_normal_341_comment},
  {"setNormal", &Dtool_OdeContactGeom_set_normal_341, METH_O, (const char *)Dtool_OdeContactGeom_set_normal_341_comment},
  {"set_depth", &Dtool_OdeContactGeom_set_depth_342, METH_O, (const char *)Dtool_OdeContactGeom_set_depth_342_comment},
  {"setDepth", &Dtool_OdeContactGeom_set_depth_342, METH_O, (const char *)Dtool_OdeContactGeom_set_depth_342_comment},
  {"set_g1", &Dtool_OdeContactGeom_set_g1_343, METH_O, (const char *)Dtool_OdeContactGeom_set_g1_343_comment},
  {"setG1", &Dtool_OdeContactGeom_set_g1_343, METH_O, (const char *)Dtool_OdeContactGeom_set_g1_343_comment},
  {"set_g2", &Dtool_OdeContactGeom_set_g2_344, METH_O, (const char *)Dtool_OdeContactGeom_set_g2_344_comment},
  {"setG2", &Dtool_OdeContactGeom_set_g2_344, METH_O, (const char *)Dtool_OdeContactGeom_set_g2_344_comment},
  {"get_class_type", &Dtool_OdeContactGeom_get_class_type_345, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeContactGeom_get_class_type_345_comment},
  {"getClassType", &Dtool_OdeContactGeom_get_class_type_345, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeContactGeom_get_class_type_345_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeContactGeom = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeContactGeom = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeContactGeom = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeContactGeom = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeContactGeom = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeContactGeom",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeContactGeom,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeContactGeom,
    &Dtool_SequenceMethods_OdeContactGeom,
    &Dtool_MappingMethods_OdeContactGeom,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeContactGeom,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeContactGeom,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeContactGeom,
    PyType_GenericAlloc,
    Dtool_new_OdeContactGeom,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeContactGeom,
  Dtool_UpcastInterface_OdeContactGeom,
  Dtool_DowncastInterface_OdeContactGeom,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_OdeContactGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_OdeContactGeom._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_OdeContactGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeContactGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeContactGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeContactGeom);
  }
}

/**
 * Python method tables for OdeCollisionEntry (OdeCollisionEntry)
 */
static PyMethodDef Dtool_Methods_OdeCollisionEntry[] = {
  {"get_geom1", &Dtool_OdeCollisionEntry_get_geom1_347, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_geom1_347_comment},
  {"getGeom1", &Dtool_OdeCollisionEntry_get_geom1_347, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_geom1_347_comment},
  {"get_geom2", &Dtool_OdeCollisionEntry_get_geom2_348, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_geom2_348_comment},
  {"getGeom2", &Dtool_OdeCollisionEntry_get_geom2_348, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_geom2_348_comment},
  {"get_body1", &Dtool_OdeCollisionEntry_get_body1_349, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_body1_349_comment},
  {"getBody1", &Dtool_OdeCollisionEntry_get_body1_349, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_body1_349_comment},
  {"get_body2", &Dtool_OdeCollisionEntry_get_body2_350, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_body2_350_comment},
  {"getBody2", &Dtool_OdeCollisionEntry_get_body2_350, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_body2_350_comment},
  {"get_num_contacts", &Dtool_OdeCollisionEntry_get_num_contacts_351, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_num_contacts_351_comment},
  {"getNumContacts", &Dtool_OdeCollisionEntry_get_num_contacts_351, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_num_contacts_351_comment},
  {"get_contact_point", &Dtool_OdeCollisionEntry_get_contact_point_352, METH_O, (const char *)Dtool_OdeCollisionEntry_get_contact_point_352_comment},
  {"getContactPoint", &Dtool_OdeCollisionEntry_get_contact_point_352, METH_O, (const char *)Dtool_OdeCollisionEntry_get_contact_point_352_comment},
  {"get_contact_geom", &Dtool_OdeCollisionEntry_get_contact_geom_353, METH_O, (const char *)Dtool_OdeCollisionEntry_get_contact_geom_353_comment},
  {"getContactGeom", &Dtool_OdeCollisionEntry_get_contact_geom_353, METH_O, (const char *)Dtool_OdeCollisionEntry_get_contact_geom_353_comment},
  {"is_empty", &Dtool_OdeCollisionEntry_is_empty_358, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_is_empty_358_comment},
  {"isEmpty", &Dtool_OdeCollisionEntry_is_empty_358, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_is_empty_358_comment},
  {"get_class_type", &Dtool_OdeCollisionEntry_get_class_type_359, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeCollisionEntry_get_class_type_359_comment},
  {"getClassType", &Dtool_OdeCollisionEntry_get_class_type_359, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeCollisionEntry_get_class_type_359_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_contact_points", (PyCFunction) &MakeSeq_OdeCollisionEntry_get_contact_points, METH_NOARGS, NULL},
  { "getContactPoints", (PyCFunction) &MakeSeq_OdeCollisionEntry_get_contact_points, METH_NOARGS, NULL},
  {"get_contact_geoms", (PyCFunction) &MakeSeq_OdeCollisionEntry_get_contact_geoms, METH_NOARGS, NULL},
  { "getContactGeoms", (PyCFunction) &MakeSeq_OdeCollisionEntry_get_contact_geoms, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeCollisionEntry slot mp_subscript -> operator []
//////////////////
static PyObject *Dtool_OdeCollisionEntry_operator_354_mp_subscript(PyObject *self, PyObject *arg) {
  OdeCollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline OdeContactGeom OdeCollisionEntry::operator [](std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:__getitem__", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    OdeContactGeom *return_value = new OdeContactGeom((*(const OdeCollisionEntry*)local_this).operator []((std::size_t)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (return_value != (OdeContactGeom *)NULL) {
      return_value->ref();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      if (return_value != (OdeContactGeom *)NULL) {
        unref_delete(return_value);
      }
      return Dtool_Raise_AssertionError();
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeContactGeom, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(OdeCollisionEntry self, int n)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeCollisionEntry slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_OdeCollisionEntry_operator_typecast_bool_357_nb_bool(PyObject *self) {
  OdeCollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCollisionEntry, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

static PyNumberMethods Dtool_NumberMethods_OdeCollisionEntry = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  &Dtool_OdeCollisionEntry_operator_typecast_bool_357_nb_bool,
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeCollisionEntry = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeCollisionEntry = {
  0, // mp_length
  &Dtool_OdeCollisionEntry_operator_354_mp_subscript,
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeCollisionEntry = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeCollisionEntry = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeCollisionEntry",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeCollisionEntry,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeCollisionEntry,
    &Dtool_SequenceMethods_OdeCollisionEntry,
    &Dtool_MappingMethods_OdeCollisionEntry,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeCollisionEntry,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class used to hold information about a collision that has occurred.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeCollisionEntry,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeCollisionEntry,
    PyType_GenericAlloc,
    Dtool_new_OdeCollisionEntry,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeCollisionEntry,
  Dtool_UpcastInterface_OdeCollisionEntry,
  Dtool_DowncastInterface_OdeCollisionEntry,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_OdeCollisionEntry(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_OdeCollisionEntry._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_OdeCollisionEntry._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeCollisionEntry) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeCollisionEntry)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeCollisionEntry);
  }
}

/**
 * Python method tables for OdeSurfaceParameters (OdeSurfaceParameters)
 */
static PyMethodDef Dtool_Methods_OdeSurfaceParameters[] = {
  {"set_mode", &Dtool_OdeSurfaceParameters_set_mode_364, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_mode_364_comment},
  {"setMode", &Dtool_OdeSurfaceParameters_set_mode_364, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_mode_364_comment},
  {"set_mu", &Dtool_OdeSurfaceParameters_set_mu_365, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_mu_365_comment},
  {"setMu", &Dtool_OdeSurfaceParameters_set_mu_365, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_mu_365_comment},
  {"set_mu2", &Dtool_OdeSurfaceParameters_set_mu2_366, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_mu2_366_comment},
  {"setMu2", &Dtool_OdeSurfaceParameters_set_mu2_366, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_mu2_366_comment},
  {"set_bounce", &Dtool_OdeSurfaceParameters_set_bounce_367, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_bounce_367_comment},
  {"setBounce", &Dtool_OdeSurfaceParameters_set_bounce_367, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_bounce_367_comment},
  {"set_bounce_vel", &Dtool_OdeSurfaceParameters_set_bounce_vel_368, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_bounce_vel_368_comment},
  {"setBounceVel", &Dtool_OdeSurfaceParameters_set_bounce_vel_368, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_bounce_vel_368_comment},
  {"set_soft_erp", &Dtool_OdeSurfaceParameters_set_soft_erp_369, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_soft_erp_369_comment},
  {"setSoftErp", &Dtool_OdeSurfaceParameters_set_soft_erp_369, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_soft_erp_369_comment},
  {"set_soft_cfm", &Dtool_OdeSurfaceParameters_set_soft_cfm_370, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_soft_cfm_370_comment},
  {"setSoftCfm", &Dtool_OdeSurfaceParameters_set_soft_cfm_370, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_soft_cfm_370_comment},
  {"set_motion1", &Dtool_OdeSurfaceParameters_set_motion1_371, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_motion1_371_comment},
  {"setMotion1", &Dtool_OdeSurfaceParameters_set_motion1_371, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_motion1_371_comment},
  {"set_motion2", &Dtool_OdeSurfaceParameters_set_motion2_372, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_motion2_372_comment},
  {"setMotion2", &Dtool_OdeSurfaceParameters_set_motion2_372, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_motion2_372_comment},
  {"set_slip1", &Dtool_OdeSurfaceParameters_set_slip1_373, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_slip1_373_comment},
  {"setSlip1", &Dtool_OdeSurfaceParameters_set_slip1_373, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_slip1_373_comment},
  {"set_slip2", &Dtool_OdeSurfaceParameters_set_slip2_374, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_slip2_374_comment},
  {"setSlip2", &Dtool_OdeSurfaceParameters_set_slip2_374, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_slip2_374_comment},
  {"get_mode", &Dtool_OdeSurfaceParameters_get_mode_375, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_mode_375_comment},
  {"getMode", &Dtool_OdeSurfaceParameters_get_mode_375, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_mode_375_comment},
  {"get_mu", &Dtool_OdeSurfaceParameters_get_mu_376, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_mu_376_comment},
  {"getMu", &Dtool_OdeSurfaceParameters_get_mu_376, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_mu_376_comment},
  {"get_mu2", &Dtool_OdeSurfaceParameters_get_mu2_377, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_mu2_377_comment},
  {"getMu2", &Dtool_OdeSurfaceParameters_get_mu2_377, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_mu2_377_comment},
  {"get_bounce", &Dtool_OdeSurfaceParameters_get_bounce_378, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_bounce_378_comment},
  {"getBounce", &Dtool_OdeSurfaceParameters_get_bounce_378, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_bounce_378_comment},
  {"get_bounce_vel", &Dtool_OdeSurfaceParameters_get_bounce_vel_379, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_bounce_vel_379_comment},
  {"getBounceVel", &Dtool_OdeSurfaceParameters_get_bounce_vel_379, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_bounce_vel_379_comment},
  {"get_soft_erp", &Dtool_OdeSurfaceParameters_get_soft_erp_380, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_soft_erp_380_comment},
  {"getSoftErp", &Dtool_OdeSurfaceParameters_get_soft_erp_380, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_soft_erp_380_comment},
  {"get_soft_cfm", &Dtool_OdeSurfaceParameters_get_soft_cfm_381, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_soft_cfm_381_comment},
  {"getSoftCfm", &Dtool_OdeSurfaceParameters_get_soft_cfm_381, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_soft_cfm_381_comment},
  {"get_motion1", &Dtool_OdeSurfaceParameters_get_motion1_382, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_motion1_382_comment},
  {"getMotion1", &Dtool_OdeSurfaceParameters_get_motion1_382, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_motion1_382_comment},
  {"get_motion2", &Dtool_OdeSurfaceParameters_get_motion2_383, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_motion2_383_comment},
  {"getMotion2", &Dtool_OdeSurfaceParameters_get_motion2_383, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_motion2_383_comment},
  {"get_slip1", &Dtool_OdeSurfaceParameters_get_slip1_384, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_slip1_384_comment},
  {"getSlip1", &Dtool_OdeSurfaceParameters_get_slip1_384, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_slip1_384_comment},
  {"get_slip2", &Dtool_OdeSurfaceParameters_get_slip2_385, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_slip2_385_comment},
  {"getSlip2", &Dtool_OdeSurfaceParameters_get_slip2_385, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_slip2_385_comment},
  {"get_class_type", &Dtool_OdeSurfaceParameters_get_class_type_386, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSurfaceParameters_get_class_type_386_comment},
  {"getClassType", &Dtool_OdeSurfaceParameters_get_class_type_386, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSurfaceParameters_get_class_type_386_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeSurfaceParameters = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeSurfaceParameters = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeSurfaceParameters = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeSurfaceParameters = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeSurfaceParameters = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeSurfaceParameters",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeSurfaceParameters,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeSurfaceParameters,
    &Dtool_SequenceMethods_OdeSurfaceParameters,
    &Dtool_MappingMethods_OdeSurfaceParameters,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeSurfaceParameters,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeSurfaceParameters,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeSurfaceParameters,
    PyType_GenericAlloc,
    Dtool_new_OdeSurfaceParameters,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeSurfaceParameters,
  Dtool_UpcastInterface_OdeSurfaceParameters,
  Dtool_DowncastInterface_OdeSurfaceParameters,
  (CoerceFunction)Dtool_ConstCoerce_OdeSurfaceParameters,
  (CoerceFunction)Dtool_Coerce_OdeSurfaceParameters,
};

static void Dtool_PyModuleClassInit_OdeSurfaceParameters(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != NULL);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(NULL);
    Dtool_OdeSurfaceParameters._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    PyObject *dict = _PyDict_NewPresized(27);
    Dtool_OdeSurfaceParameters._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum OdeSurfaceParameters::ModeFlags;
    PyDict_SetItemString(dict, "MF_contact_mu2", Dtool_WrapValue(OdeSurfaceParameters::MF_contact_mu2));
    PyDict_SetItemString(dict, "MFContactMu2", Dtool_WrapValue(OdeSurfaceParameters::MF_contact_mu2));
    PyDict_SetItemString(dict, "MF_contactFDir1", Dtool_WrapValue(OdeSurfaceParameters::MF_contactFDir1));
    PyDict_SetItemString(dict, "MFContactFDir1", Dtool_WrapValue(OdeSurfaceParameters::MF_contactFDir1));
    PyDict_SetItemString(dict, "MF_contactBounce", Dtool_WrapValue(OdeSurfaceParameters::MF_contactBounce));
    PyDict_SetItemString(dict, "MFContactBounce", Dtool_WrapValue(OdeSurfaceParameters::MF_contactBounce));
    PyDict_SetItemString(dict, "MF_contactSoftERP", Dtool_WrapValue(OdeSurfaceParameters::MF_contactSoftERP));
    PyDict_SetItemString(dict, "MFContactSoftERP", Dtool_WrapValue(OdeSurfaceParameters::MF_contactSoftERP));
    PyDict_SetItemString(dict, "MF_contactSoftCFM", Dtool_WrapValue(OdeSurfaceParameters::MF_contactSoftCFM));
    PyDict_SetItemString(dict, "MFContactSoftCFM", Dtool_WrapValue(OdeSurfaceParameters::MF_contactSoftCFM));
    PyDict_SetItemString(dict, "MF_contactMotion1", Dtool_WrapValue(OdeSurfaceParameters::MF_contactMotion1));
    PyDict_SetItemString(dict, "MFContactMotion1", Dtool_WrapValue(OdeSurfaceParameters::MF_contactMotion1));
    PyDict_SetItemString(dict, "MF_contactMotion2", Dtool_WrapValue(OdeSurfaceParameters::MF_contactMotion2));
    PyDict_SetItemString(dict, "MFContactMotion2", Dtool_WrapValue(OdeSurfaceParameters::MF_contactMotion2));
    PyDict_SetItemString(dict, "MF_contactSlip1", Dtool_WrapValue(OdeSurfaceParameters::MF_contactSlip1));
    PyDict_SetItemString(dict, "MFContactSlip1", Dtool_WrapValue(OdeSurfaceParameters::MF_contactSlip1));
    PyDict_SetItemString(dict, "MF_contactSlip2", Dtool_WrapValue(OdeSurfaceParameters::MF_contactSlip2));
    PyDict_SetItemString(dict, "MFContactSlip2", Dtool_WrapValue(OdeSurfaceParameters::MF_contactSlip2));
    PyDict_SetItemString(dict, "MF_contactApprox0", Dtool_WrapValue(OdeSurfaceParameters::MF_contactApprox0));
    PyDict_SetItemString(dict, "MFContactApprox0", Dtool_WrapValue(OdeSurfaceParameters::MF_contactApprox0));
    PyDict_SetItemString(dict, "MF_contactApprox1_1", Dtool_WrapValue(OdeSurfaceParameters::MF_contactApprox1_1));
    PyDict_SetItemString(dict, "MFContactApprox11", Dtool_WrapValue(OdeSurfaceParameters::MF_contactApprox1_1));
    PyDict_SetItemString(dict, "MF_contactApprox1_2", Dtool_WrapValue(OdeSurfaceParameters::MF_contactApprox1_2));
    PyDict_SetItemString(dict, "MFContactApprox12", Dtool_WrapValue(OdeSurfaceParameters::MF_contactApprox1_2));
    PyDict_SetItemString(dict, "MF_contactApprox1", Dtool_WrapValue(OdeSurfaceParameters::MF_contactApprox1));
    PyDict_SetItemString(dict, "MFContactApprox1", Dtool_WrapValue(OdeSurfaceParameters::MF_contactApprox1));
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeSurfaceParameters) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeSurfaceParameters)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeSurfaceParameters);
  }
}

/**
 * Python method tables for OdeContact (OdeContact)
 */
static PyMethodDef Dtool_Methods_OdeContact[] = {
  {"get_surface", &Dtool_OdeContact_get_surface_389, METH_NOARGS, (const char *)Dtool_OdeContact_get_surface_389_comment},
  {"getSurface", &Dtool_OdeContact_get_surface_389, METH_NOARGS, (const char *)Dtool_OdeContact_get_surface_389_comment},
  {"get_geom", &Dtool_OdeContact_get_geom_390, METH_NOARGS, (const char *)Dtool_OdeContact_get_geom_390_comment},
  {"getGeom", &Dtool_OdeContact_get_geom_390, METH_NOARGS, (const char *)Dtool_OdeContact_get_geom_390_comment},
  {"get_fdir1", &Dtool_OdeContact_get_fdir1_391, METH_NOARGS, (const char *)Dtool_OdeContact_get_fdir1_391_comment},
  {"getFdir1", &Dtool_OdeContact_get_fdir1_391, METH_NOARGS, (const char *)Dtool_OdeContact_get_fdir1_391_comment},
  {"set_surface", &Dtool_OdeContact_set_surface_392, METH_O, (const char *)Dtool_OdeContact_set_surface_392_comment},
  {"setSurface", &Dtool_OdeContact_set_surface_392, METH_O, (const char *)Dtool_OdeContact_set_surface_392_comment},
  {"set_geom", &Dtool_OdeContact_set_geom_393, METH_O, (const char *)Dtool_OdeContact_set_geom_393_comment},
  {"setGeom", &Dtool_OdeContact_set_geom_393, METH_O, (const char *)Dtool_OdeContact_set_geom_393_comment},
  {"set_fdir1", &Dtool_OdeContact_set_fdir1_394, METH_O, (const char *)Dtool_OdeContact_set_fdir1_394_comment},
  {"setFdir1", &Dtool_OdeContact_set_fdir1_394, METH_O, (const char *)Dtool_OdeContact_set_fdir1_394_comment},
  {"get_class_type", &Dtool_OdeContact_get_class_type_395, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeContact_get_class_type_395_comment},
  {"getClassType", &Dtool_OdeContact_get_class_type_395, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeContact_get_class_type_395_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeContact = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeContact = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeContact = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeContact = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeContact = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeContact",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeContact,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeContact,
    &Dtool_SequenceMethods_OdeContact,
    &Dtool_MappingMethods_OdeContact,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeContact,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeContact,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeContact,
    PyType_GenericAlloc,
    Dtool_new_OdeContact,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeContact,
  Dtool_UpcastInterface_OdeContact,
  Dtool_DowncastInterface_OdeContact,
  (CoerceFunction)Dtool_ConstCoerce_OdeContact,
  (CoerceFunction)Dtool_Coerce_OdeContact,
};

static void Dtool_PyModuleClassInit_OdeContact(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_OdeContact._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_OdeContact._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeContact) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeContact)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeContact);
  }
}

/**
 * Python method tables for OdeContactJoint (OdeContactJoint)
 */
static PyMethodDef Dtool_Methods_OdeContactJoint[] = {
  {"get_class_type", &Dtool_OdeContactJoint_get_class_type_398, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeContactJoint_get_class_type_398_comment},
  {"getClassType", &Dtool_OdeContactJoint_get_class_type_398, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeContactJoint_get_class_type_398_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeContactJoint = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeContactJoint = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeContactJoint = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeContactJoint = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeContactJoint = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeContactJoint",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeContactJoint,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeContactJoint,
    &Dtool_SequenceMethods_OdeContactJoint,
    &Dtool_MappingMethods_OdeContactJoint,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeContactJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeContactJoint,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeContactJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeContactJoint,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeContactJoint,
  Dtool_UpcastInterface_OdeContactJoint,
  Dtool_DowncastInterface_OdeContactJoint,
  (CoerceFunction)Dtool_ConstCoerce_OdeContactJoint,
  (CoerceFunction)Dtool_Coerce_OdeContactJoint,
};

static void Dtool_PyModuleClassInit_OdeContactJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(NULL);
    Dtool_OdeContactJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    PyObject *dict = PyDict_New();
    Dtool_OdeContactJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeContactJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeContactJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeContactJoint);
  }
}

/**
 * Python method tables for OdeCylinderGeom (OdeCylinderGeom)
 */
static PyMethodDef Dtool_Methods_OdeCylinderGeom[] = {
  {"set_params", (PyCFunction) &Dtool_OdeCylinderGeom_set_params_401, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeCylinderGeom_set_params_401_comment},
  {"setParams", (PyCFunction) &Dtool_OdeCylinderGeom_set_params_401, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeCylinderGeom_set_params_401_comment},
  {"get_radius", &Dtool_OdeCylinderGeom_get_radius_403, METH_NOARGS, (const char *)Dtool_OdeCylinderGeom_get_radius_403_comment},
  {"getRadius", &Dtool_OdeCylinderGeom_get_radius_403, METH_NOARGS, (const char *)Dtool_OdeCylinderGeom_get_radius_403_comment},
  {"get_length", &Dtool_OdeCylinderGeom_get_length_404, METH_NOARGS, (const char *)Dtool_OdeCylinderGeom_get_length_404_comment},
  {"getLength", &Dtool_OdeCylinderGeom_get_length_404, METH_NOARGS, (const char *)Dtool_OdeCylinderGeom_get_length_404_comment},
  {"get_class_type", &Dtool_OdeCylinderGeom_get_class_type_405, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeCylinderGeom_get_class_type_405_comment},
  {"getClassType", &Dtool_OdeCylinderGeom_get_class_type_405, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeCylinderGeom_get_class_type_405_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeCylinderGeom = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeCylinderGeom = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeCylinderGeom = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeCylinderGeom = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeCylinderGeom = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeCylinderGeom",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeCylinderGeom,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeCylinderGeom,
    &Dtool_SequenceMethods_OdeCylinderGeom,
    &Dtool_MappingMethods_OdeCylinderGeom,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeCylinderGeom,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeCylinderGeom,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeCylinderGeom,
    PyType_GenericAlloc,
    Dtool_new_OdeCylinderGeom,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeCylinderGeom,
  Dtool_UpcastInterface_OdeCylinderGeom,
  Dtool_DowncastInterface_OdeCylinderGeom,
  (CoerceFunction)Dtool_ConstCoerce_OdeCylinderGeom,
  (CoerceFunction)Dtool_Coerce_OdeCylinderGeom,
};

static void Dtool_PyModuleClassInit_OdeCylinderGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeGeom(NULL);
    Dtool_OdeCylinderGeom._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeGeom);
    PyObject *dict = PyDict_New();
    Dtool_OdeCylinderGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeCylinderGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeCylinderGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeCylinderGeom);
  }
}

/**
 * Python method tables for OdeFixedJoint (OdeFixedJoint)
 */
static PyMethodDef Dtool_Methods_OdeFixedJoint[] = {
  {"set", &Dtool_OdeFixedJoint_set_408, METH_NOARGS, (const char *)Dtool_OdeFixedJoint_set_408_comment},
  {"get_class_type", &Dtool_OdeFixedJoint_get_class_type_409, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeFixedJoint_get_class_type_409_comment},
  {"getClassType", &Dtool_OdeFixedJoint_get_class_type_409, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeFixedJoint_get_class_type_409_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeFixedJoint = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeFixedJoint = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeFixedJoint = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeFixedJoint = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeFixedJoint = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeFixedJoint",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeFixedJoint,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeFixedJoint,
    &Dtool_SequenceMethods_OdeFixedJoint,
    &Dtool_MappingMethods_OdeFixedJoint,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeFixedJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeFixedJoint,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeFixedJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeFixedJoint,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeFixedJoint,
  Dtool_UpcastInterface_OdeFixedJoint,
  Dtool_DowncastInterface_OdeFixedJoint,
  (CoerceFunction)Dtool_ConstCoerce_OdeFixedJoint,
  (CoerceFunction)Dtool_Coerce_OdeFixedJoint,
};

static void Dtool_PyModuleClassInit_OdeFixedJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(NULL);
    Dtool_OdeFixedJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    PyObject *dict = PyDict_New();
    Dtool_OdeFixedJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeFixedJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeFixedJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeFixedJoint);
  }
}

/**
 * Python method tables for OdeHashSpace (OdeHashSpace)
 */
static PyMethodDef Dtool_Methods_OdeHashSpace[] = {
  {"set_levels", (PyCFunction) &Dtool_OdeHashSpace_set_levels_412, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHashSpace_set_levels_412_comment},
  {"setLevels", (PyCFunction) &Dtool_OdeHashSpace_set_levels_412, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHashSpace_set_levels_412_comment},
  {"get_min_level", &Dtool_OdeHashSpace_get_min_level_413, METH_NOARGS, (const char *)Dtool_OdeHashSpace_get_min_level_413_comment},
  {"getMinLevel", &Dtool_OdeHashSpace_get_min_level_413, METH_NOARGS, (const char *)Dtool_OdeHashSpace_get_min_level_413_comment},
  {"get_max_level", &Dtool_OdeHashSpace_get_max_level_414, METH_NOARGS, (const char *)Dtool_OdeHashSpace_get_max_level_414_comment},
  {"getMaxLevel", &Dtool_OdeHashSpace_get_max_level_414, METH_NOARGS, (const char *)Dtool_OdeHashSpace_get_max_level_414_comment},
  {"get_class_type", &Dtool_OdeHashSpace_get_class_type_415, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeHashSpace_get_class_type_415_comment},
  {"getClassType", &Dtool_OdeHashSpace_get_class_type_415, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeHashSpace_get_class_type_415_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeHashSpace = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeHashSpace = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeHashSpace = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeHashSpace = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeHashSpace = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeHashSpace",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeHashSpace,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeHashSpace,
    &Dtool_SequenceMethods_OdeHashSpace,
    &Dtool_MappingMethods_OdeHashSpace,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeHashSpace,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeHashSpace,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeHashSpace,
    PyType_GenericAlloc,
    Dtool_new_OdeHashSpace,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeHashSpace,
  Dtool_UpcastInterface_OdeHashSpace,
  Dtool_DowncastInterface_OdeHashSpace,
  (CoerceFunction)Dtool_ConstCoerce_OdeHashSpace,
  (CoerceFunction)Dtool_Coerce_OdeHashSpace,
};

static void Dtool_PyModuleClassInit_OdeHashSpace(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeSpace(NULL);
    Dtool_OdeHashSpace._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeSpace);
    PyObject *dict = PyDict_New();
    Dtool_OdeHashSpace._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeHashSpace) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeHashSpace)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeHashSpace);
  }
}

/**
 * Python method tables for OdeHinge2Joint (OdeHinge2Joint)
 */
static PyMethodDef Dtool_Methods_OdeHinge2Joint[] = {
  {"set_anchor", (PyCFunction) &Dtool_OdeHinge2Joint_set_anchor_418, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_anchor_418_comment},
  {"setAnchor", (PyCFunction) &Dtool_OdeHinge2Joint_set_anchor_418, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_anchor_418_comment},
  {"set_axis1", (PyCFunction) &Dtool_OdeHinge2Joint_set_axis1_419, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_axis1_419_comment},
  {"setAxis1", (PyCFunction) &Dtool_OdeHinge2Joint_set_axis1_419, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_axis1_419_comment},
  {"set_axis2", (PyCFunction) &Dtool_OdeHinge2Joint_set_axis2_420, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_axis2_420_comment},
  {"setAxis2", (PyCFunction) &Dtool_OdeHinge2Joint_set_axis2_420, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_axis2_420_comment},
  {"add_torques", (PyCFunction) &Dtool_OdeHinge2Joint_add_torques_421, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_add_torques_421_comment},
  {"addTorques", (PyCFunction) &Dtool_OdeHinge2Joint_add_torques_421, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_add_torques_421_comment},
  {"get_anchor", &Dtool_OdeHinge2Joint_get_anchor_422, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_anchor_422_comment},
  {"getAnchor", &Dtool_OdeHinge2Joint_get_anchor_422, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_anchor_422_comment},
  {"get_anchor2", &Dtool_OdeHinge2Joint_get_anchor2_423, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_anchor2_423_comment},
  {"getAnchor2", &Dtool_OdeHinge2Joint_get_anchor2_423, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_anchor2_423_comment},
  {"get_axis1", &Dtool_OdeHinge2Joint_get_axis1_424, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_axis1_424_comment},
  {"getAxis1", &Dtool_OdeHinge2Joint_get_axis1_424, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_axis1_424_comment},
  {"get_axis2", &Dtool_OdeHinge2Joint_get_axis2_425, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_axis2_425_comment},
  {"getAxis2", &Dtool_OdeHinge2Joint_get_axis2_425, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_axis2_425_comment},
  {"get_angle1", &Dtool_OdeHinge2Joint_get_angle1_426, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_angle1_426_comment},
  {"getAngle1", &Dtool_OdeHinge2Joint_get_angle1_426, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_angle1_426_comment},
  {"get_angle1_rate", &Dtool_OdeHinge2Joint_get_angle1_rate_427, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_angle1_rate_427_comment},
  {"getAngle1Rate", &Dtool_OdeHinge2Joint_get_angle1_rate_427, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_angle1_rate_427_comment},
  {"get_angle2_rate", &Dtool_OdeHinge2Joint_get_angle2_rate_428, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_angle2_rate_428_comment},
  {"getAngle2Rate", &Dtool_OdeHinge2Joint_get_angle2_rate_428, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_angle2_rate_428_comment},
  {"set_param_lo_stop", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_lo_stop_429, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_lo_stop_429_comment},
  {"setParamLoStop", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_lo_stop_429, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_lo_stop_429_comment},
  {"set_param_hi_stop", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_hi_stop_430, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_hi_stop_430_comment},
  {"setParamHiStop", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_hi_stop_430, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_hi_stop_430_comment},
  {"set_param_vel", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_vel_431, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_vel_431_comment},
  {"setParamVel", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_vel_431, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_vel_431_comment},
  {"set_param_f_max", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_f_max_432, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_f_max_432_comment},
  {"setParamFMax", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_f_max_432, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_f_max_432_comment},
  {"set_param_fudge_factor", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_fudge_factor_433, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_fudge_factor_433_comment},
  {"setParamFudgeFactor", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_fudge_factor_433, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_fudge_factor_433_comment},
  {"set_param_bounce", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_bounce_434, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_bounce_434_comment},
  {"setParamBounce", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_bounce_434, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_bounce_434_comment},
  {"set_param_CFM", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_CFM_435, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_CFM_435_comment},
  {"setParamCFM", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_CFM_435, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_CFM_435_comment},
  {"set_param_stop_ERP", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_stop_ERP_436, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_stop_ERP_436_comment},
  {"setParamStopERP", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_stop_ERP_436, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_stop_ERP_436_comment},
  {"set_param_stop_CFM", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_stop_CFM_437, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_stop_CFM_437_comment},
  {"setParamStopCFM", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_stop_CFM_437, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_stop_CFM_437_comment},
  {"set_param_suspension_ERP", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_suspension_ERP_438, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_suspension_ERP_438_comment},
  {"setParamSuspensionERP", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_suspension_ERP_438, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_suspension_ERP_438_comment},
  {"set_param_suspension_CFM", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_suspension_CFM_439, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_suspension_CFM_439_comment},
  {"setParamSuspensionCFM", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_suspension_CFM_439, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_suspension_CFM_439_comment},
  {"get_param_lo_stop", &Dtool_OdeHinge2Joint_get_param_lo_stop_440, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_lo_stop_440_comment},
  {"getParamLoStop", &Dtool_OdeHinge2Joint_get_param_lo_stop_440, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_lo_stop_440_comment},
  {"get_param_hi_stop", &Dtool_OdeHinge2Joint_get_param_hi_stop_441, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_hi_stop_441_comment},
  {"getParamHiStop", &Dtool_OdeHinge2Joint_get_param_hi_stop_441, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_hi_stop_441_comment},
  {"get_param_vel", &Dtool_OdeHinge2Joint_get_param_vel_442, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_vel_442_comment},
  {"getParamVel", &Dtool_OdeHinge2Joint_get_param_vel_442, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_vel_442_comment},
  {"get_param_f_max", &Dtool_OdeHinge2Joint_get_param_f_max_443, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_f_max_443_comment},
  {"getParamFMax", &Dtool_OdeHinge2Joint_get_param_f_max_443, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_f_max_443_comment},
  {"get_param_fudge_factor", &Dtool_OdeHinge2Joint_get_param_fudge_factor_444, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_fudge_factor_444_comment},
  {"getParamFudgeFactor", &Dtool_OdeHinge2Joint_get_param_fudge_factor_444, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_fudge_factor_444_comment},
  {"get_param_bounce", &Dtool_OdeHinge2Joint_get_param_bounce_445, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_bounce_445_comment},
  {"getParamBounce", &Dtool_OdeHinge2Joint_get_param_bounce_445, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_bounce_445_comment},
  {"get_param_CFM", &Dtool_OdeHinge2Joint_get_param_CFM_446, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_CFM_446_comment},
  {"getParamCFM", &Dtool_OdeHinge2Joint_get_param_CFM_446, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_CFM_446_comment},
  {"get_param_stop_ERP", &Dtool_OdeHinge2Joint_get_param_stop_ERP_447, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_stop_ERP_447_comment},
  {"getParamStopERP", &Dtool_OdeHinge2Joint_get_param_stop_ERP_447, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_stop_ERP_447_comment},
  {"get_param_stop_CFM", &Dtool_OdeHinge2Joint_get_param_stop_CFM_448, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_stop_CFM_448_comment},
  {"getParamStopCFM", &Dtool_OdeHinge2Joint_get_param_stop_CFM_448, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_stop_CFM_448_comment},
  {"get_param_suspension_ERP", &Dtool_OdeHinge2Joint_get_param_suspension_ERP_449, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_suspension_ERP_449_comment},
  {"getParamSuspensionERP", &Dtool_OdeHinge2Joint_get_param_suspension_ERP_449, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_suspension_ERP_449_comment},
  {"get_param_suspension_CFM", &Dtool_OdeHinge2Joint_get_param_suspension_CFM_450, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_suspension_CFM_450_comment},
  {"getParamSuspensionCFM", &Dtool_OdeHinge2Joint_get_param_suspension_CFM_450, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_suspension_CFM_450_comment},
  {"get_class_type", &Dtool_OdeHinge2Joint_get_class_type_451, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeHinge2Joint_get_class_type_451_comment},
  {"getClassType", &Dtool_OdeHinge2Joint_get_class_type_451, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeHinge2Joint_get_class_type_451_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeHinge2Joint = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeHinge2Joint = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeHinge2Joint = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeHinge2Joint = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeHinge2Joint = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeHinge2Joint",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeHinge2Joint,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeHinge2Joint,
    &Dtool_SequenceMethods_OdeHinge2Joint,
    &Dtool_MappingMethods_OdeHinge2Joint,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeHinge2Joint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeHinge2Joint,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeHinge2Joint,
    PyType_GenericAlloc,
    Dtool_new_OdeHinge2Joint,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeHinge2Joint,
  Dtool_UpcastInterface_OdeHinge2Joint,
  Dtool_DowncastInterface_OdeHinge2Joint,
  (CoerceFunction)Dtool_ConstCoerce_OdeHinge2Joint,
  (CoerceFunction)Dtool_Coerce_OdeHinge2Joint,
};

static void Dtool_PyModuleClassInit_OdeHinge2Joint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(NULL);
    Dtool_OdeHinge2Joint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    PyObject *dict = PyDict_New();
    Dtool_OdeHinge2Joint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeHinge2Joint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeHinge2Joint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeHinge2Joint);
  }
}

/**
 * Python method tables for OdeHingeJoint (OdeHingeJoint)
 */
static PyMethodDef Dtool_Methods_OdeHingeJoint[] = {
  {"set_anchor", (PyCFunction) &Dtool_OdeHingeJoint_set_anchor_454, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHingeJoint_set_anchor_454_comment},
  {"setAnchor", (PyCFunction) &Dtool_OdeHingeJoint_set_anchor_454, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHingeJoint_set_anchor_454_comment},
  {"set_anchor_delta", (PyCFunction) &Dtool_OdeHingeJoint_set_anchor_delta_455, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHingeJoint_set_anchor_delta_455_comment},
  {"setAnchorDelta", (PyCFunction) &Dtool_OdeHingeJoint_set_anchor_delta_455, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHingeJoint_set_anchor_delta_455_comment},
  {"set_axis", (PyCFunction) &Dtool_OdeHingeJoint_set_axis_456, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHingeJoint_set_axis_456_comment},
  {"setAxis", (PyCFunction) &Dtool_OdeHingeJoint_set_axis_456, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHingeJoint_set_axis_456_comment},
  {"add_torque", &Dtool_OdeHingeJoint_add_torque_457, METH_O, (const char *)Dtool_OdeHingeJoint_add_torque_457_comment},
  {"addTorque", &Dtool_OdeHingeJoint_add_torque_457, METH_O, (const char *)Dtool_OdeHingeJoint_add_torque_457_comment},
  {"get_anchor", &Dtool_OdeHingeJoint_get_anchor_458, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_anchor_458_comment},
  {"getAnchor", &Dtool_OdeHingeJoint_get_anchor_458, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_anchor_458_comment},
  {"get_anchor2", &Dtool_OdeHingeJoint_get_anchor2_459, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_anchor2_459_comment},
  {"getAnchor2", &Dtool_OdeHingeJoint_get_anchor2_459, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_anchor2_459_comment},
  {"get_axis", &Dtool_OdeHingeJoint_get_axis_460, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_axis_460_comment},
  {"getAxis", &Dtool_OdeHingeJoint_get_axis_460, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_axis_460_comment},
  {"get_angle", &Dtool_OdeHingeJoint_get_angle_461, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_angle_461_comment},
  {"getAngle", &Dtool_OdeHingeJoint_get_angle_461, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_angle_461_comment},
  {"get_angle_rate", &Dtool_OdeHingeJoint_get_angle_rate_462, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_angle_rate_462_comment},
  {"getAngleRate", &Dtool_OdeHingeJoint_get_angle_rate_462, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_angle_rate_462_comment},
  {"set_param_lo_stop", &Dtool_OdeHingeJoint_set_param_lo_stop_463, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_lo_stop_463_comment},
  {"setParamLoStop", &Dtool_OdeHingeJoint_set_param_lo_stop_463, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_lo_stop_463_comment},
  {"set_param_hi_stop", &Dtool_OdeHingeJoint_set_param_hi_stop_464, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_hi_stop_464_comment},
  {"setParamHiStop", &Dtool_OdeHingeJoint_set_param_hi_stop_464, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_hi_stop_464_comment},
  {"set_param_vel", &Dtool_OdeHingeJoint_set_param_vel_465, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_vel_465_comment},
  {"setParamVel", &Dtool_OdeHingeJoint_set_param_vel_465, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_vel_465_comment},
  {"set_param_f_max", &Dtool_OdeHingeJoint_set_param_f_max_466, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_f_max_466_comment},
  {"setParamFMax", &Dtool_OdeHingeJoint_set_param_f_max_466, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_f_max_466_comment},
  {"set_param_fudge_factor", &Dtool_OdeHingeJoint_set_param_fudge_factor_467, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_fudge_factor_467_comment},
  {"setParamFudgeFactor", &Dtool_OdeHingeJoint_set_param_fudge_factor_467, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_fudge_factor_467_comment},
  {"set_param_bounce", &Dtool_OdeHingeJoint_set_param_bounce_468, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_bounce_468_comment},
  {"setParamBounce", &Dtool_OdeHingeJoint_set_param_bounce_468, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_bounce_468_comment},
  {"set_param_CFM", &Dtool_OdeHingeJoint_set_param_CFM_469, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_CFM_469_comment},
  {"setParamCFM", &Dtool_OdeHingeJoint_set_param_CFM_469, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_CFM_469_comment},
  {"set_param_stop_ERP", &Dtool_OdeHingeJoint_set_param_stop_ERP_470, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_stop_ERP_470_comment},
  {"setParamStopERP", &Dtool_OdeHingeJoint_set_param_stop_ERP_470, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_stop_ERP_470_comment},
  {"set_param_stop_CFM", &Dtool_OdeHingeJoint_set_param_stop_CFM_471, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_stop_CFM_471_comment},
  {"setParamStopCFM", &Dtool_OdeHingeJoint_set_param_stop_CFM_471, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_stop_CFM_471_comment},
  {"get_param_lo_stop", &Dtool_OdeHingeJoint_get_param_lo_stop_472, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_lo_stop_472_comment},
  {"getParamLoStop", &Dtool_OdeHingeJoint_get_param_lo_stop_472, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_lo_stop_472_comment},
  {"get_param_hi_stop", &Dtool_OdeHingeJoint_get_param_hi_stop_473, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_hi_stop_473_comment},
  {"getParamHiStop", &Dtool_OdeHingeJoint_get_param_hi_stop_473, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_hi_stop_473_comment},
  {"get_param_vel", &Dtool_OdeHingeJoint_get_param_vel_474, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_vel_474_comment},
  {"getParamVel", &Dtool_OdeHingeJoint_get_param_vel_474, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_vel_474_comment},
  {"get_param_f_max", &Dtool_OdeHingeJoint_get_param_f_max_475, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_f_max_475_comment},
  {"getParamFMax", &Dtool_OdeHingeJoint_get_param_f_max_475, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_f_max_475_comment},
  {"get_param_fudge_factor", &Dtool_OdeHingeJoint_get_param_fudge_factor_476, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_fudge_factor_476_comment},
  {"getParamFudgeFactor", &Dtool_OdeHingeJoint_get_param_fudge_factor_476, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_fudge_factor_476_comment},
  {"get_param_bounce", &Dtool_OdeHingeJoint_get_param_bounce_477, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_bounce_477_comment},
  {"getParamBounce", &Dtool_OdeHingeJoint_get_param_bounce_477, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_bounce_477_comment},
  {"get_param_CFM", &Dtool_OdeHingeJoint_get_param_CFM_478, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_CFM_478_comment},
  {"getParamCFM", &Dtool_OdeHingeJoint_get_param_CFM_478, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_CFM_478_comment},
  {"get_param_stop_ERP", &Dtool_OdeHingeJoint_get_param_stop_ERP_479, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_stop_ERP_479_comment},
  {"getParamStopERP", &Dtool_OdeHingeJoint_get_param_stop_ERP_479, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_stop_ERP_479_comment},
  {"get_param_stop_CFM", &Dtool_OdeHingeJoint_get_param_stop_CFM_480, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_stop_CFM_480_comment},
  {"getParamStopCFM", &Dtool_OdeHingeJoint_get_param_stop_CFM_480, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_stop_CFM_480_comment},
  {"get_class_type", &Dtool_OdeHingeJoint_get_class_type_481, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeHingeJoint_get_class_type_481_comment},
  {"getClassType", &Dtool_OdeHingeJoint_get_class_type_481, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeHingeJoint_get_class_type_481_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeHingeJoint = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeHingeJoint = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeHingeJoint = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeHingeJoint = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeHingeJoint = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeHingeJoint",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeHingeJoint,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeHingeJoint,
    &Dtool_SequenceMethods_OdeHingeJoint,
    &Dtool_MappingMethods_OdeHingeJoint,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeHingeJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeHingeJoint,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeHingeJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeHingeJoint,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeHingeJoint,
  Dtool_UpcastInterface_OdeHingeJoint,
  Dtool_DowncastInterface_OdeHingeJoint,
  (CoerceFunction)Dtool_ConstCoerce_OdeHingeJoint,
  (CoerceFunction)Dtool_Coerce_OdeHingeJoint,
};

static void Dtool_PyModuleClassInit_OdeHingeJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(NULL);
    Dtool_OdeHingeJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    PyObject *dict = PyDict_New();
    Dtool_OdeHingeJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeHingeJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeHingeJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeHingeJoint);
  }
}

/**
 * Python method tables for OdeJointCollection (OdeJointCollection)
 */
static PyMethodDef Dtool_Methods_OdeJointCollection[] = {
  {"assign", &Dtool_OdeJointCollection_operator_484, METH_O, (const char *)Dtool_OdeJointCollection_operator_484_comment},
  {"add_joint", &Dtool_OdeJointCollection_add_joint_486, METH_O, (const char *)Dtool_OdeJointCollection_add_joint_486_comment},
  {"addJoint", &Dtool_OdeJointCollection_add_joint_486, METH_O, (const char *)Dtool_OdeJointCollection_add_joint_486_comment},
  {"remove_joint", &Dtool_OdeJointCollection_remove_joint_487, METH_O, (const char *)Dtool_OdeJointCollection_remove_joint_487_comment},
  {"removeJoint", &Dtool_OdeJointCollection_remove_joint_487, METH_O, (const char *)Dtool_OdeJointCollection_remove_joint_487_comment},
  {"add_joints_from", &Dtool_OdeJointCollection_add_joints_from_488, METH_O, (const char *)Dtool_OdeJointCollection_add_joints_from_488_comment},
  {"addJointsFrom", &Dtool_OdeJointCollection_add_joints_from_488, METH_O, (const char *)Dtool_OdeJointCollection_add_joints_from_488_comment},
  {"remove_joints_from", &Dtool_OdeJointCollection_remove_joints_from_489, METH_O, (const char *)Dtool_OdeJointCollection_remove_joints_from_489_comment},
  {"removeJointsFrom", &Dtool_OdeJointCollection_remove_joints_from_489, METH_O, (const char *)Dtool_OdeJointCollection_remove_joints_from_489_comment},
  {"remove_duplicate_joints", &Dtool_OdeJointCollection_remove_duplicate_joints_490, METH_NOARGS, (const char *)Dtool_OdeJointCollection_remove_duplicate_joints_490_comment},
  {"removeDuplicateJoints", &Dtool_OdeJointCollection_remove_duplicate_joints_490, METH_NOARGS, (const char *)Dtool_OdeJointCollection_remove_duplicate_joints_490_comment},
  {"has_joint", &Dtool_OdeJointCollection_has_joint_491, METH_O, (const char *)Dtool_OdeJointCollection_has_joint_491_comment},
  {"hasJoint", &Dtool_OdeJointCollection_has_joint_491, METH_O, (const char *)Dtool_OdeJointCollection_has_joint_491_comment},
  {"clear", &Dtool_OdeJointCollection_clear_492, METH_NOARGS, (const char *)Dtool_OdeJointCollection_clear_492_comment},
  {"is_empty", &Dtool_OdeJointCollection_is_empty_493, METH_NOARGS, (const char *)Dtool_OdeJointCollection_is_empty_493_comment},
  {"isEmpty", &Dtool_OdeJointCollection_is_empty_493, METH_NOARGS, (const char *)Dtool_OdeJointCollection_is_empty_493_comment},
  {"get_num_joints", &Dtool_OdeJointCollection_get_num_joints_494, METH_NOARGS, (const char *)Dtool_OdeJointCollection_get_num_joints_494_comment},
  {"getNumJoints", &Dtool_OdeJointCollection_get_num_joints_494, METH_NOARGS, (const char *)Dtool_OdeJointCollection_get_num_joints_494_comment},
  {"get_joint", &Dtool_OdeJointCollection_get_joint_495, METH_O, (const char *)Dtool_OdeJointCollection_get_joint_495_comment},
  {"getJoint", &Dtool_OdeJointCollection_get_joint_495, METH_O, (const char *)Dtool_OdeJointCollection_get_joint_495_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_joints", (PyCFunction) &MakeSeq_OdeJointCollection_get_joints, METH_NOARGS, NULL},
  { "getJoints", (PyCFunction) &MakeSeq_OdeJointCollection_get_joints, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeJointCollection slot nb_add -> operator +
//////////////////
static PyObject *Dtool_OdeJointCollection_operator_500_nb_add(PyObject *self, PyObject *arg) {
  OdeJointCollection *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_OdeJointCollection, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline OdeJointCollection OdeJointCollection::operator +(OdeJointCollection const &other) const
  OdeJointCollection const *arg_this = (OdeJointCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointCollection, 1, "OdeJointCollection.__add__", true, true);
  if (arg_this != NULL) {
    OdeJointCollection *return_value = new OdeJointCollection((*(const OdeJointCollection*)local_this).operator +(*arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OdeJointCollection, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeJointCollection slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_OdeJointCollection_operator_499_nb_inplace_add(PyObject *self, PyObject *arg) {
  OdeJointCollection *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_OdeJointCollection, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void OdeJointCollection::operator +=(OdeJointCollection const &other)
    OdeJointCollection const *arg_this = (OdeJointCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointCollection, 1, "OdeJointCollection.__iadd__", true, true);
    if (arg_this != NULL) {
      (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call OdeJointCollection.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeJointCollection slot sq_item -> operator []
//////////////////
static PyObject *Dtool_OdeJointCollection_operator_497_sq_item(PyObject *self, Py_ssize_t index) {
  OdeJointCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJointCollection, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "OdeJointCollection index out of range");
    return NULL;
  }
  // 1-OdeJoint OdeJointCollection::operator [](int index) const
  OdeJoint *return_value = new OdeJoint((*(const OdeJointCollection*)local_this).operator [](index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(OdeJointCollection self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeJointCollection slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_OdeJointCollection_size_498_sq_length(PyObject *self) {
  OdeJointCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJointCollection, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_OdeJointCollection = {
  &Dtool_OdeJointCollection_operator_500_nb_add,
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_OdeJointCollection_operator_499_nb_inplace_add,
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeJointCollection = {
  &Dtool_OdeJointCollection_size_498_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_OdeJointCollection_operator_497_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_OdeJointCollection = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeJointCollection",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeJointCollection,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeJointCollection,
    &Dtool_SequenceMethods_OdeJointCollection,
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeJointCollection,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeJointCollection,
    PyType_GenericAlloc,
    Dtool_new_OdeJointCollection,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeJointCollection,
  Dtool_UpcastInterface_OdeJointCollection,
  Dtool_DowncastInterface_OdeJointCollection,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_OdeJointCollection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_OdeJointCollection._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_OdeJointCollection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeJointCollection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeJointCollection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeJointCollection);
  }
}

/**
 * Python method tables for OdeLMotorJoint (OdeLMotorJoint)
 */
static PyMethodDef Dtool_Methods_OdeLMotorJoint[] = {
  {"set_num_axes", &Dtool_OdeLMotorJoint_set_num_axes_503, METH_O, (const char *)Dtool_OdeLMotorJoint_set_num_axes_503_comment},
  {"setNumAxes", &Dtool_OdeLMotorJoint_set_num_axes_503, METH_O, (const char *)Dtool_OdeLMotorJoint_set_num_axes_503_comment},
  {"set_axis", (PyCFunction) &Dtool_OdeLMotorJoint_set_axis_504, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeLMotorJoint_set_axis_504_comment},
  {"setAxis", (PyCFunction) &Dtool_OdeLMotorJoint_set_axis_504, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeLMotorJoint_set_axis_504_comment},
  {"set_param", (PyCFunction) &Dtool_OdeLMotorJoint_set_param_505, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeLMotorJoint_set_param_505_comment},
  {"setParam", (PyCFunction) &Dtool_OdeLMotorJoint_set_param_505, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeLMotorJoint_set_param_505_comment},
  {"get_num_axes", &Dtool_OdeLMotorJoint_get_num_axes_506, METH_NOARGS, (const char *)Dtool_OdeLMotorJoint_get_num_axes_506_comment},
  {"getNumAxes", &Dtool_OdeLMotorJoint_get_num_axes_506, METH_NOARGS, (const char *)Dtool_OdeLMotorJoint_get_num_axes_506_comment},
  {"get_axis", &Dtool_OdeLMotorJoint_get_axis_507, METH_O, (const char *)Dtool_OdeLMotorJoint_get_axis_507_comment},
  {"getAxis", &Dtool_OdeLMotorJoint_get_axis_507, METH_O, (const char *)Dtool_OdeLMotorJoint_get_axis_507_comment},
  {"get_param", &Dtool_OdeLMotorJoint_get_param_509, METH_O, (const char *)Dtool_OdeLMotorJoint_get_param_509_comment},
  {"getParam", &Dtool_OdeLMotorJoint_get_param_509, METH_O, (const char *)Dtool_OdeLMotorJoint_get_param_509_comment},
  {"get_class_type", &Dtool_OdeLMotorJoint_get_class_type_510, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeLMotorJoint_get_class_type_510_comment},
  {"getClassType", &Dtool_OdeLMotorJoint_get_class_type_510, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeLMotorJoint_get_class_type_510_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_axes", (PyCFunction) &MakeSeq_OdeLMotorJoint_get_axes, METH_NOARGS, NULL},
  { "getAxes", (PyCFunction) &MakeSeq_OdeLMotorJoint_get_axes, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeLMotorJoint = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeLMotorJoint = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeLMotorJoint = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeLMotorJoint = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeLMotorJoint = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeLMotorJoint",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeLMotorJoint,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeLMotorJoint,
    &Dtool_SequenceMethods_OdeLMotorJoint,
    &Dtool_MappingMethods_OdeLMotorJoint,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeLMotorJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeLMotorJoint,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeLMotorJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeLMotorJoint,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeLMotorJoint,
  Dtool_UpcastInterface_OdeLMotorJoint,
  Dtool_DowncastInterface_OdeLMotorJoint,
  (CoerceFunction)Dtool_ConstCoerce_OdeLMotorJoint,
  (CoerceFunction)Dtool_Coerce_OdeLMotorJoint,
};

static void Dtool_PyModuleClassInit_OdeLMotorJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(NULL);
    Dtool_OdeLMotorJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    PyObject *dict = PyDict_New();
    Dtool_OdeLMotorJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeLMotorJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeLMotorJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeLMotorJoint);
  }
}

/**
 * Python method tables for OdeNullJoint (OdeNullJoint)
 */
static PyMethodDef Dtool_Methods_OdeNullJoint[] = {
  {"get_class_type", &Dtool_OdeNullJoint_get_class_type_513, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeNullJoint_get_class_type_513_comment},
  {"getClassType", &Dtool_OdeNullJoint_get_class_type_513, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeNullJoint_get_class_type_513_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeNullJoint = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeNullJoint = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeNullJoint = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeNullJoint = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeNullJoint = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeNullJoint",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeNullJoint,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeNullJoint,
    &Dtool_SequenceMethods_OdeNullJoint,
    &Dtool_MappingMethods_OdeNullJoint,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeNullJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeNullJoint,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeNullJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeNullJoint,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeNullJoint,
  Dtool_UpcastInterface_OdeNullJoint,
  Dtool_DowncastInterface_OdeNullJoint,
  (CoerceFunction)Dtool_ConstCoerce_OdeNullJoint,
  (CoerceFunction)Dtool_Coerce_OdeNullJoint,
};

static void Dtool_PyModuleClassInit_OdeNullJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(NULL);
    Dtool_OdeNullJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    PyObject *dict = PyDict_New();
    Dtool_OdeNullJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeNullJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeNullJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeNullJoint);
  }
}

/**
 * Python method tables for OdePlane2dJoint (OdePlane2dJoint)
 */
static PyMethodDef Dtool_Methods_OdePlane2dJoint[] = {
  {"set_x_param", (PyCFunction) &Dtool_OdePlane2dJoint_set_x_param_516, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlane2dJoint_set_x_param_516_comment},
  {"setXParam", (PyCFunction) &Dtool_OdePlane2dJoint_set_x_param_516, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlane2dJoint_set_x_param_516_comment},
  {"set_y_param", (PyCFunction) &Dtool_OdePlane2dJoint_set_y_param_517, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlane2dJoint_set_y_param_517_comment},
  {"setYParam", (PyCFunction) &Dtool_OdePlane2dJoint_set_y_param_517, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlane2dJoint_set_y_param_517_comment},
  {"set_angle_param", (PyCFunction) &Dtool_OdePlane2dJoint_set_angle_param_518, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlane2dJoint_set_angle_param_518_comment},
  {"setAngleParam", (PyCFunction) &Dtool_OdePlane2dJoint_set_angle_param_518, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlane2dJoint_set_angle_param_518_comment},
  {"get_class_type", &Dtool_OdePlane2dJoint_get_class_type_519, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdePlane2dJoint_get_class_type_519_comment},
  {"getClassType", &Dtool_OdePlane2dJoint_get_class_type_519, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdePlane2dJoint_get_class_type_519_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdePlane2dJoint = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdePlane2dJoint = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdePlane2dJoint = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdePlane2dJoint = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdePlane2dJoint = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdePlane2dJoint",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdePlane2dJoint,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdePlane2dJoint,
    &Dtool_SequenceMethods_OdePlane2dJoint,
    &Dtool_MappingMethods_OdePlane2dJoint,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdePlane2dJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdePlane2dJoint,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdePlane2dJoint,
    PyType_GenericAlloc,
    Dtool_new_OdePlane2dJoint,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdePlane2dJoint,
  Dtool_UpcastInterface_OdePlane2dJoint,
  Dtool_DowncastInterface_OdePlane2dJoint,
  (CoerceFunction)Dtool_ConstCoerce_OdePlane2dJoint,
  (CoerceFunction)Dtool_Coerce_OdePlane2dJoint,
};

static void Dtool_PyModuleClassInit_OdePlane2dJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(NULL);
    Dtool_OdePlane2dJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    PyObject *dict = PyDict_New();
    Dtool_OdePlane2dJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdePlane2dJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdePlane2dJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdePlane2dJoint);
  }
}

/**
 * Python method tables for OdePlaneGeom (OdePlaneGeom)
 */
static PyMethodDef Dtool_Methods_OdePlaneGeom[] = {
  {"set_params", (PyCFunction) &Dtool_OdePlaneGeom_set_params_522, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlaneGeom_set_params_522_comment},
  {"setParams", (PyCFunction) &Dtool_OdePlaneGeom_set_params_522, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlaneGeom_set_params_522_comment},
  {"get_params", &Dtool_OdePlaneGeom_get_params_523, METH_NOARGS, (const char *)Dtool_OdePlaneGeom_get_params_523_comment},
  {"getParams", &Dtool_OdePlaneGeom_get_params_523, METH_NOARGS, (const char *)Dtool_OdePlaneGeom_get_params_523_comment},
  {"get_point_depth", (PyCFunction) &Dtool_OdePlaneGeom_get_point_depth_524, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlaneGeom_get_point_depth_524_comment},
  {"getPointDepth", (PyCFunction) &Dtool_OdePlaneGeom_get_point_depth_524, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlaneGeom_get_point_depth_524_comment},
  {"get_class_type", &Dtool_OdePlaneGeom_get_class_type_525, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdePlaneGeom_get_class_type_525_comment},
  {"getClassType", &Dtool_OdePlaneGeom_get_class_type_525, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdePlaneGeom_get_class_type_525_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdePlaneGeom = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdePlaneGeom = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdePlaneGeom = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdePlaneGeom = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdePlaneGeom = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdePlaneGeom",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdePlaneGeom,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdePlaneGeom,
    &Dtool_SequenceMethods_OdePlaneGeom,
    &Dtool_MappingMethods_OdePlaneGeom,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdePlaneGeom,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdePlaneGeom,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdePlaneGeom,
    PyType_GenericAlloc,
    Dtool_new_OdePlaneGeom,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdePlaneGeom,
  Dtool_UpcastInterface_OdePlaneGeom,
  Dtool_DowncastInterface_OdePlaneGeom,
  (CoerceFunction)Dtool_ConstCoerce_OdePlaneGeom,
  (CoerceFunction)Dtool_Coerce_OdePlaneGeom,
};

static void Dtool_PyModuleClassInit_OdePlaneGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeGeom(NULL);
    Dtool_OdePlaneGeom._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeGeom);
    PyObject *dict = PyDict_New();
    Dtool_OdePlaneGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdePlaneGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdePlaneGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdePlaneGeom);
  }
}

/**
 * Python method tables for OdeQuadTreeSpace (OdeQuadTreeSpace)
 */
static PyMethodDef Dtool_Methods_OdeQuadTreeSpace[] = {
  {"get_class_type", &Dtool_OdeQuadTreeSpace_get_class_type_528, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeQuadTreeSpace_get_class_type_528_comment},
  {"getClassType", &Dtool_OdeQuadTreeSpace_get_class_type_528, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeQuadTreeSpace_get_class_type_528_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeQuadTreeSpace = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeQuadTreeSpace = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeQuadTreeSpace = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeQuadTreeSpace = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeQuadTreeSpace = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeQuadTreeSpace",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeQuadTreeSpace,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeQuadTreeSpace,
    &Dtool_SequenceMethods_OdeQuadTreeSpace,
    &Dtool_MappingMethods_OdeQuadTreeSpace,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeQuadTreeSpace,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeQuadTreeSpace,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeQuadTreeSpace,
    PyType_GenericAlloc,
    Dtool_new_OdeQuadTreeSpace,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeQuadTreeSpace,
  Dtool_UpcastInterface_OdeQuadTreeSpace,
  Dtool_DowncastInterface_OdeQuadTreeSpace,
  (CoerceFunction)Dtool_ConstCoerce_OdeQuadTreeSpace,
  (CoerceFunction)Dtool_Coerce_OdeQuadTreeSpace,
};

static void Dtool_PyModuleClassInit_OdeQuadTreeSpace(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeSpace(NULL);
    Dtool_OdeQuadTreeSpace._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeSpace);
    PyObject *dict = PyDict_New();
    Dtool_OdeQuadTreeSpace._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeQuadTreeSpace) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeQuadTreeSpace)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeQuadTreeSpace);
  }
}

/**
 * Python method tables for OdeRayGeom (OdeRayGeom)
 */
static PyMethodDef Dtool_Methods_OdeRayGeom[] = {
  {"set_length", &Dtool_OdeRayGeom_set_length_531, METH_O, (const char *)Dtool_OdeRayGeom_set_length_531_comment},
  {"setLength", &Dtool_OdeRayGeom_set_length_531, METH_O, (const char *)Dtool_OdeRayGeom_set_length_531_comment},
  {"get_length", &Dtool_OdeRayGeom_get_length_532, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_length_532_comment},
  {"getLength", &Dtool_OdeRayGeom_get_length_532, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_length_532_comment},
  {"set", (PyCFunction) &Dtool_OdeRayGeom_set_533, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeRayGeom_set_533_comment},
  {"get", (PyCFunction) &Dtool_OdeRayGeom_get_534, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeRayGeom_get_534_comment},
  {"get_start", &Dtool_OdeRayGeom_get_start_535, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_start_535_comment},
  {"getStart", &Dtool_OdeRayGeom_get_start_535, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_start_535_comment},
  {"get_direction", &Dtool_OdeRayGeom_get_direction_536, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_direction_536_comment},
  {"getDirection", &Dtool_OdeRayGeom_get_direction_536, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_direction_536_comment},
  {"set_params", (PyCFunction) &Dtool_OdeRayGeom_set_params_537, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeRayGeom_set_params_537_comment},
  {"setParams", (PyCFunction) &Dtool_OdeRayGeom_set_params_537, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeRayGeom_set_params_537_comment},
  {"get_first_contact", &Dtool_OdeRayGeom_get_first_contact_539, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_first_contact_539_comment},
  {"getFirstContact", &Dtool_OdeRayGeom_get_first_contact_539, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_first_contact_539_comment},
  {"get_backface_cull", &Dtool_OdeRayGeom_get_backface_cull_540, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_backface_cull_540_comment},
  {"getBackfaceCull", &Dtool_OdeRayGeom_get_backface_cull_540, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_backface_cull_540_comment},
  {"set_closest_hit", &Dtool_OdeRayGeom_set_closest_hit_541, METH_O, (const char *)Dtool_OdeRayGeom_set_closest_hit_541_comment},
  {"setClosestHit", &Dtool_OdeRayGeom_set_closest_hit_541, METH_O, (const char *)Dtool_OdeRayGeom_set_closest_hit_541_comment},
  {"get_closest_hit", &Dtool_OdeRayGeom_get_closest_hit_542, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_closest_hit_542_comment},
  {"getClosestHit", &Dtool_OdeRayGeom_get_closest_hit_542, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_closest_hit_542_comment},
  {"get_class_type", &Dtool_OdeRayGeom_get_class_type_543, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeRayGeom_get_class_type_543_comment},
  {"getClassType", &Dtool_OdeRayGeom_get_class_type_543, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeRayGeom_get_class_type_543_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeRayGeom = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeRayGeom = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeRayGeom = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeRayGeom = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeRayGeom = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeRayGeom",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeRayGeom,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeRayGeom,
    &Dtool_SequenceMethods_OdeRayGeom,
    &Dtool_MappingMethods_OdeRayGeom,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeRayGeom,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeRayGeom,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeRayGeom,
    PyType_GenericAlloc,
    Dtool_new_OdeRayGeom,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeRayGeom,
  Dtool_UpcastInterface_OdeRayGeom,
  Dtool_DowncastInterface_OdeRayGeom,
  (CoerceFunction)Dtool_ConstCoerce_OdeRayGeom,
  (CoerceFunction)Dtool_Coerce_OdeRayGeom,
};

static void Dtool_PyModuleClassInit_OdeRayGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeGeom(NULL);
    Dtool_OdeRayGeom._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeGeom);
    PyObject *dict = PyDict_New();
    Dtool_OdeRayGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeRayGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeRayGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeRayGeom);
  }
}

/**
 * Python method tables for OdeSimpleSpace (OdeSimpleSpace)
 */
static PyMethodDef Dtool_Methods_OdeSimpleSpace[] = {
  {"get_class_type", &Dtool_OdeSimpleSpace_get_class_type_546, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSimpleSpace_get_class_type_546_comment},
  {"getClassType", &Dtool_OdeSimpleSpace_get_class_type_546, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSimpleSpace_get_class_type_546_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeSimpleSpace = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeSimpleSpace = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeSimpleSpace = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeSimpleSpace = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeSimpleSpace = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeSimpleSpace",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeSimpleSpace,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeSimpleSpace,
    &Dtool_SequenceMethods_OdeSimpleSpace,
    &Dtool_MappingMethods_OdeSimpleSpace,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeSimpleSpace,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeSimpleSpace,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeSimpleSpace,
    PyType_GenericAlloc,
    Dtool_new_OdeSimpleSpace,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeSimpleSpace,
  Dtool_UpcastInterface_OdeSimpleSpace,
  Dtool_DowncastInterface_OdeSimpleSpace,
  (CoerceFunction)Dtool_ConstCoerce_OdeSimpleSpace,
  (CoerceFunction)Dtool_Coerce_OdeSimpleSpace,
};

static void Dtool_PyModuleClassInit_OdeSimpleSpace(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeSpace(NULL);
    Dtool_OdeSimpleSpace._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeSpace);
    PyObject *dict = PyDict_New();
    Dtool_OdeSimpleSpace._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeSimpleSpace) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeSimpleSpace)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeSimpleSpace);
  }
}

/**
 * Python method tables for OdeSliderJoint (OdeSliderJoint)
 */
static PyMethodDef Dtool_Methods_OdeSliderJoint[] = {
  {"set_axis", (PyCFunction) &Dtool_OdeSliderJoint_set_axis_549, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSliderJoint_set_axis_549_comment},
  {"setAxis", (PyCFunction) &Dtool_OdeSliderJoint_set_axis_549, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSliderJoint_set_axis_549_comment},
  {"set_axis_delta", (PyCFunction) &Dtool_OdeSliderJoint_set_axis_delta_550, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSliderJoint_set_axis_delta_550_comment},
  {"setAxisDelta", (PyCFunction) &Dtool_OdeSliderJoint_set_axis_delta_550, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSliderJoint_set_axis_delta_550_comment},
  {"add_force", &Dtool_OdeSliderJoint_add_force_551, METH_O, (const char *)Dtool_OdeSliderJoint_add_force_551_comment},
  {"addForce", &Dtool_OdeSliderJoint_add_force_551, METH_O, (const char *)Dtool_OdeSliderJoint_add_force_551_comment},
  {"get_position", &Dtool_OdeSliderJoint_get_position_552, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_position_552_comment},
  {"getPosition", &Dtool_OdeSliderJoint_get_position_552, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_position_552_comment},
  {"get_position_rate", &Dtool_OdeSliderJoint_get_position_rate_553, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_position_rate_553_comment},
  {"getPositionRate", &Dtool_OdeSliderJoint_get_position_rate_553, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_position_rate_553_comment},
  {"get_axis", &Dtool_OdeSliderJoint_get_axis_554, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_axis_554_comment},
  {"getAxis", &Dtool_OdeSliderJoint_get_axis_554, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_axis_554_comment},
  {"set_param_lo_stop", &Dtool_OdeSliderJoint_set_param_lo_stop_555, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_lo_stop_555_comment},
  {"setParamLoStop", &Dtool_OdeSliderJoint_set_param_lo_stop_555, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_lo_stop_555_comment},
  {"set_param_hi_stop", &Dtool_OdeSliderJoint_set_param_hi_stop_556, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_hi_stop_556_comment},
  {"setParamHiStop", &Dtool_OdeSliderJoint_set_param_hi_stop_556, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_hi_stop_556_comment},
  {"set_param_vel", &Dtool_OdeSliderJoint_set_param_vel_557, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_vel_557_comment},
  {"setParamVel", &Dtool_OdeSliderJoint_set_param_vel_557, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_vel_557_comment},
  {"set_param_f_max", &Dtool_OdeSliderJoint_set_param_f_max_558, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_f_max_558_comment},
  {"setParamFMax", &Dtool_OdeSliderJoint_set_param_f_max_558, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_f_max_558_comment},
  {"set_param_fudge_factor", &Dtool_OdeSliderJoint_set_param_fudge_factor_559, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_fudge_factor_559_comment},
  {"setParamFudgeFactor", &Dtool_OdeSliderJoint_set_param_fudge_factor_559, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_fudge_factor_559_comment},
  {"set_param_bounce", &Dtool_OdeSliderJoint_set_param_bounce_560, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_bounce_560_comment},
  {"setParamBounce", &Dtool_OdeSliderJoint_set_param_bounce_560, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_bounce_560_comment},
  {"set_param_CFM", &Dtool_OdeSliderJoint_set_param_CFM_561, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_CFM_561_comment},
  {"setParamCFM", &Dtool_OdeSliderJoint_set_param_CFM_561, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_CFM_561_comment},
  {"set_param_stop_ERP", &Dtool_OdeSliderJoint_set_param_stop_ERP_562, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_stop_ERP_562_comment},
  {"setParamStopERP", &Dtool_OdeSliderJoint_set_param_stop_ERP_562, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_stop_ERP_562_comment},
  {"set_param_stop_CFM", &Dtool_OdeSliderJoint_set_param_stop_CFM_563, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_stop_CFM_563_comment},
  {"setParamStopCFM", &Dtool_OdeSliderJoint_set_param_stop_CFM_563, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_stop_CFM_563_comment},
  {"get_param_lo_stop", &Dtool_OdeSliderJoint_get_param_lo_stop_564, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_lo_stop_564_comment},
  {"getParamLoStop", &Dtool_OdeSliderJoint_get_param_lo_stop_564, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_lo_stop_564_comment},
  {"get_param_hi_stop", &Dtool_OdeSliderJoint_get_param_hi_stop_565, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_hi_stop_565_comment},
  {"getParamHiStop", &Dtool_OdeSliderJoint_get_param_hi_stop_565, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_hi_stop_565_comment},
  {"get_param_vel", &Dtool_OdeSliderJoint_get_param_vel_566, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_vel_566_comment},
  {"getParamVel", &Dtool_OdeSliderJoint_get_param_vel_566, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_vel_566_comment},
  {"get_param_f_max", &Dtool_OdeSliderJoint_get_param_f_max_567, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_f_max_567_comment},
  {"getParamFMax", &Dtool_OdeSliderJoint_get_param_f_max_567, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_f_max_567_comment},
  {"get_param_fudge_factor", &Dtool_OdeSliderJoint_get_param_fudge_factor_568, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_fudge_factor_568_comment},
  {"getParamFudgeFactor", &Dtool_OdeSliderJoint_get_param_fudge_factor_568, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_fudge_factor_568_comment},
  {"get_param_bounce", &Dtool_OdeSliderJoint_get_param_bounce_569, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_bounce_569_comment},
  {"getParamBounce", &Dtool_OdeSliderJoint_get_param_bounce_569, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_bounce_569_comment},
  {"get_param_CFM", &Dtool_OdeSliderJoint_get_param_CFM_570, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_CFM_570_comment},
  {"getParamCFM", &Dtool_OdeSliderJoint_get_param_CFM_570, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_CFM_570_comment},
  {"get_param_stop_ERP", &Dtool_OdeSliderJoint_get_param_stop_ERP_571, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_stop_ERP_571_comment},
  {"getParamStopERP", &Dtool_OdeSliderJoint_get_param_stop_ERP_571, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_stop_ERP_571_comment},
  {"get_param_stop_CFM", &Dtool_OdeSliderJoint_get_param_stop_CFM_572, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_stop_CFM_572_comment},
  {"getParamStopCFM", &Dtool_OdeSliderJoint_get_param_stop_CFM_572, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_stop_CFM_572_comment},
  {"get_class_type", &Dtool_OdeSliderJoint_get_class_type_573, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSliderJoint_get_class_type_573_comment},
  {"getClassType", &Dtool_OdeSliderJoint_get_class_type_573, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSliderJoint_get_class_type_573_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeSliderJoint = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeSliderJoint = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeSliderJoint = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeSliderJoint = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeSliderJoint = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeSliderJoint",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeSliderJoint,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeSliderJoint,
    &Dtool_SequenceMethods_OdeSliderJoint,
    &Dtool_MappingMethods_OdeSliderJoint,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeSliderJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeSliderJoint,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeSliderJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeSliderJoint,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeSliderJoint,
  Dtool_UpcastInterface_OdeSliderJoint,
  Dtool_DowncastInterface_OdeSliderJoint,
  (CoerceFunction)Dtool_ConstCoerce_OdeSliderJoint,
  (CoerceFunction)Dtool_Coerce_OdeSliderJoint,
};

static void Dtool_PyModuleClassInit_OdeSliderJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(NULL);
    Dtool_OdeSliderJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    PyObject *dict = PyDict_New();
    Dtool_OdeSliderJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeSliderJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeSliderJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeSliderJoint);
  }
}

/**
 * Python method tables for OdeSphereGeom (OdeSphereGeom)
 */
static PyMethodDef Dtool_Methods_OdeSphereGeom[] = {
  {"set_radius", &Dtool_OdeSphereGeom_set_radius_576, METH_O, (const char *)Dtool_OdeSphereGeom_set_radius_576_comment},
  {"setRadius", &Dtool_OdeSphereGeom_set_radius_576, METH_O, (const char *)Dtool_OdeSphereGeom_set_radius_576_comment},
  {"get_radius", &Dtool_OdeSphereGeom_get_radius_577, METH_NOARGS, (const char *)Dtool_OdeSphereGeom_get_radius_577_comment},
  {"getRadius", &Dtool_OdeSphereGeom_get_radius_577, METH_NOARGS, (const char *)Dtool_OdeSphereGeom_get_radius_577_comment},
  {"get_point_depth", (PyCFunction) &Dtool_OdeSphereGeom_get_point_depth_578, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSphereGeom_get_point_depth_578_comment},
  {"getPointDepth", (PyCFunction) &Dtool_OdeSphereGeom_get_point_depth_578, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSphereGeom_get_point_depth_578_comment},
  {"get_class_type", &Dtool_OdeSphereGeom_get_class_type_579, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSphereGeom_get_class_type_579_comment},
  {"getClassType", &Dtool_OdeSphereGeom_get_class_type_579, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSphereGeom_get_class_type_579_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeSphereGeom = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeSphereGeom = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeSphereGeom = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeSphereGeom = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeSphereGeom = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeSphereGeom",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeSphereGeom,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeSphereGeom,
    &Dtool_SequenceMethods_OdeSphereGeom,
    &Dtool_MappingMethods_OdeSphereGeom,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeSphereGeom,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeSphereGeom,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeSphereGeom,
    PyType_GenericAlloc,
    Dtool_new_OdeSphereGeom,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeSphereGeom,
  Dtool_UpcastInterface_OdeSphereGeom,
  Dtool_DowncastInterface_OdeSphereGeom,
  (CoerceFunction)Dtool_ConstCoerce_OdeSphereGeom,
  (CoerceFunction)Dtool_Coerce_OdeSphereGeom,
};

static void Dtool_PyModuleClassInit_OdeSphereGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeGeom(NULL);
    Dtool_OdeSphereGeom._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeGeom);
    PyObject *dict = PyDict_New();
    Dtool_OdeSphereGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeSphereGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeSphereGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeSphereGeom);
  }
}

/**
 * Python method tables for OdeTriMeshData (OdeTriMeshData)
 */
static PyMethodDef Dtool_Methods_OdeTriMeshData[] = {
  {"destroy", &Dtool_OdeTriMeshData_destroy_583, METH_NOARGS, (const char *)Dtool_OdeTriMeshData_destroy_583_comment},
  {"write", (PyCFunction) &Dtool_OdeTriMeshData_write_584, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeTriMeshData_write_584_comment},
  {"write_faces", &Dtool_OdeTriMeshData_write_faces_585, METH_O, (const char *)Dtool_OdeTriMeshData_write_faces_585_comment},
  {"writeFaces", &Dtool_OdeTriMeshData_write_faces_585, METH_O, (const char *)Dtool_OdeTriMeshData_write_faces_585_comment},
  {"get_class_type", &Dtool_OdeTriMeshData_get_class_type_586, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeTriMeshData_get_class_type_586_comment},
  {"getClassType", &Dtool_OdeTriMeshData_get_class_type_586, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeTriMeshData_get_class_type_586_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     OdeTriMeshData
//////////////////
static PyObject *Dtool_Str_OdeTriMeshData(PyObject *self) {
  OdeTriMeshData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeTriMeshData, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_OdeTriMeshData = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeTriMeshData = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeTriMeshData = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeTriMeshData = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeTriMeshData = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeTriMeshData",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeTriMeshData,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeTriMeshData,
    &Dtool_SequenceMethods_OdeTriMeshData,
    &Dtool_MappingMethods_OdeTriMeshData,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_OdeTriMeshData,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeTriMeshData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeTriMeshData,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeTriMeshData,
    PyType_GenericAlloc,
    Dtool_new_OdeTriMeshData,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeTriMeshData,
  Dtool_UpcastInterface_OdeTriMeshData,
  Dtool_DowncastInterface_OdeTriMeshData,
  (CoerceFunction)Dtool_ConstCoerce_OdeTriMeshData,
  (CoerceFunction)Dtool_Coerce_OdeTriMeshData,
};

static void Dtool_PyModuleClassInit_OdeTriMeshData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_OdeTriMeshData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_OdeTriMeshData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum OdeTriMeshData::DataType;
    PyDict_SetItemString(dict, "DT_face_normals", Dtool_WrapValue(OdeTriMeshData::DT_face_normals));
    PyDict_SetItemString(dict, "DTFaceNormals", Dtool_WrapValue(OdeTriMeshData::DT_face_normals));
    PyDict_SetItemString(dict, "DT_last_transformation", Dtool_WrapValue(OdeTriMeshData::DT_last_transformation));
    PyDict_SetItemString(dict, "DTLastTransformation", Dtool_WrapValue(OdeTriMeshData::DT_last_transformation));
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeTriMeshData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeTriMeshData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeTriMeshData);
  }
}

/**
 * Python method tables for OdeTriMeshGeom (OdeTriMeshGeom)
 */
static PyMethodDef Dtool_Methods_OdeTriMeshGeom[] = {
  {"destroy", &Dtool_OdeTriMeshGeom_destroy_589, METH_NOARGS, (const char *)Dtool_OdeTriMeshGeom_destroy_589_comment},
  {"set_tri_mesh_data", &Dtool_OdeTriMeshGeom_set_tri_mesh_data_590, METH_O, (const char *)Dtool_OdeTriMeshGeom_set_tri_mesh_data_590_comment},
  {"setTriMeshData", &Dtool_OdeTriMeshGeom_set_tri_mesh_data_590, METH_O, (const char *)Dtool_OdeTriMeshGeom_set_tri_mesh_data_590_comment},
  {"get_tri_mesh_data", &Dtool_OdeTriMeshGeom_get_tri_mesh_data_591, METH_NOARGS, (const char *)Dtool_OdeTriMeshGeom_get_tri_mesh_data_591_comment},
  {"getTriMeshData", &Dtool_OdeTriMeshGeom_get_tri_mesh_data_591, METH_NOARGS, (const char *)Dtool_OdeTriMeshGeom_get_tri_mesh_data_591_comment},
  {"set_data", &Dtool_OdeTriMeshGeom_set_data_592, METH_O, (const char *)Dtool_OdeTriMeshGeom_set_data_592_comment},
  {"setData", &Dtool_OdeTriMeshGeom_set_data_592, METH_O, (const char *)Dtool_OdeTriMeshGeom_set_data_592_comment},
  {"get_data", &Dtool_OdeTriMeshGeom_get_data_593, METH_NOARGS, (const char *)Dtool_OdeTriMeshGeom_get_data_593_comment},
  {"getData", &Dtool_OdeTriMeshGeom_get_data_593, METH_NOARGS, (const char *)Dtool_OdeTriMeshGeom_get_data_593_comment},
  {"enable_TC", (PyCFunction) &Dtool_OdeTriMeshGeom_enable_TC_594, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeTriMeshGeom_enable_TC_594_comment},
  {"enableTC", (PyCFunction) &Dtool_OdeTriMeshGeom_enable_TC_594, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeTriMeshGeom_enable_TC_594_comment},
  {"is_TC_enabled", &Dtool_OdeTriMeshGeom_is_TC_enabled_595, METH_O, (const char *)Dtool_OdeTriMeshGeom_is_TC_enabled_595_comment},
  {"isTCEnabled", &Dtool_OdeTriMeshGeom_is_TC_enabled_595, METH_O, (const char *)Dtool_OdeTriMeshGeom_is_TC_enabled_595_comment},
  {"clear_TC_cache", &Dtool_OdeTriMeshGeom_clear_TC_cache_596, METH_O, (const char *)Dtool_OdeTriMeshGeom_clear_TC_cache_596_comment},
  {"clearTCCache", &Dtool_OdeTriMeshGeom_clear_TC_cache_596, METH_O, (const char *)Dtool_OdeTriMeshGeom_clear_TC_cache_596_comment},
  {"get_triangle", (PyCFunction) &Dtool_OdeTriMeshGeom_get_triangle_597, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeTriMeshGeom_get_triangle_597_comment},
  {"getTriangle", (PyCFunction) &Dtool_OdeTriMeshGeom_get_triangle_597, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeTriMeshGeom_get_triangle_597_comment},
  {"get_point", (PyCFunction) &Dtool_OdeTriMeshGeom_get_point_598, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeTriMeshGeom_get_point_598_comment},
  {"getPoint", (PyCFunction) &Dtool_OdeTriMeshGeom_get_point_598, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeTriMeshGeom_get_point_598_comment},
  {"get_num_triangles", &Dtool_OdeTriMeshGeom_get_num_triangles_599, METH_NOARGS, (const char *)Dtool_OdeTriMeshGeom_get_num_triangles_599_comment},
  {"getNumTriangles", &Dtool_OdeTriMeshGeom_get_num_triangles_599, METH_NOARGS, (const char *)Dtool_OdeTriMeshGeom_get_num_triangles_599_comment},
  {"get_class_type", &Dtool_OdeTriMeshGeom_get_class_type_600, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeTriMeshGeom_get_class_type_600_comment},
  {"getClassType", &Dtool_OdeTriMeshGeom_get_class_type_600, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeTriMeshGeom_get_class_type_600_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeTriMeshGeom = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeTriMeshGeom = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeTriMeshGeom = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeTriMeshGeom = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeTriMeshGeom = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeTriMeshGeom",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeTriMeshGeom,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeTriMeshGeom,
    &Dtool_SequenceMethods_OdeTriMeshGeom,
    &Dtool_MappingMethods_OdeTriMeshGeom,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeTriMeshGeom,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeTriMeshGeom,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeTriMeshGeom,
    PyType_GenericAlloc,
    Dtool_new_OdeTriMeshGeom,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeTriMeshGeom,
  Dtool_UpcastInterface_OdeTriMeshGeom,
  Dtool_DowncastInterface_OdeTriMeshGeom,
  (CoerceFunction)Dtool_ConstCoerce_OdeTriMeshGeom,
  (CoerceFunction)Dtool_Coerce_OdeTriMeshGeom,
};

static void Dtool_PyModuleClassInit_OdeTriMeshGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeGeom(NULL);
    Dtool_OdeTriMeshGeom._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeGeom);
    PyObject *dict = PyDict_New();
    Dtool_OdeTriMeshGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeTriMeshGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeTriMeshGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeTriMeshGeom);
  }
}

/**
 * Python method tables for OdeUniversalJoint (OdeUniversalJoint)
 */
static PyMethodDef Dtool_Methods_OdeUniversalJoint[] = {
  {"set_anchor", (PyCFunction) &Dtool_OdeUniversalJoint_set_anchor_603, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_anchor_603_comment},
  {"setAnchor", (PyCFunction) &Dtool_OdeUniversalJoint_set_anchor_603, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_anchor_603_comment},
  {"set_axis1", (PyCFunction) &Dtool_OdeUniversalJoint_set_axis1_604, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_axis1_604_comment},
  {"setAxis1", (PyCFunction) &Dtool_OdeUniversalJoint_set_axis1_604, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_axis1_604_comment},
  {"set_axis2", (PyCFunction) &Dtool_OdeUniversalJoint_set_axis2_605, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_axis2_605_comment},
  {"setAxis2", (PyCFunction) &Dtool_OdeUniversalJoint_set_axis2_605, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_axis2_605_comment},
  {"add_torques", (PyCFunction) &Dtool_OdeUniversalJoint_add_torques_606, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_add_torques_606_comment},
  {"addTorques", (PyCFunction) &Dtool_OdeUniversalJoint_add_torques_606, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_add_torques_606_comment},
  {"get_anchor", &Dtool_OdeUniversalJoint_get_anchor_607, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_anchor_607_comment},
  {"getAnchor", &Dtool_OdeUniversalJoint_get_anchor_607, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_anchor_607_comment},
  {"get_anchor2", &Dtool_OdeUniversalJoint_get_anchor2_608, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_anchor2_608_comment},
  {"getAnchor2", &Dtool_OdeUniversalJoint_get_anchor2_608, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_anchor2_608_comment},
  {"get_axis1", &Dtool_OdeUniversalJoint_get_axis1_609, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_axis1_609_comment},
  {"getAxis1", &Dtool_OdeUniversalJoint_get_axis1_609, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_axis1_609_comment},
  {"get_axis2", &Dtool_OdeUniversalJoint_get_axis2_610, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_axis2_610_comment},
  {"getAxis2", &Dtool_OdeUniversalJoint_get_axis2_610, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_axis2_610_comment},
  {"get_angle1", &Dtool_OdeUniversalJoint_get_angle1_611, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_angle1_611_comment},
  {"getAngle1", &Dtool_OdeUniversalJoint_get_angle1_611, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_angle1_611_comment},
  {"get_angle2", &Dtool_OdeUniversalJoint_get_angle2_612, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_angle2_612_comment},
  {"getAngle2", &Dtool_OdeUniversalJoint_get_angle2_612, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_angle2_612_comment},
  {"get_angle1_rate", &Dtool_OdeUniversalJoint_get_angle1_rate_613, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_angle1_rate_613_comment},
  {"getAngle1Rate", &Dtool_OdeUniversalJoint_get_angle1_rate_613, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_angle1_rate_613_comment},
  {"get_angle2_rate", &Dtool_OdeUniversalJoint_get_angle2_rate_614, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_angle2_rate_614_comment},
  {"getAngle2Rate", &Dtool_OdeUniversalJoint_get_angle2_rate_614, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_angle2_rate_614_comment},
  {"set_param_lo_stop", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_lo_stop_615, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_lo_stop_615_comment},
  {"setParamLoStop", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_lo_stop_615, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_lo_stop_615_comment},
  {"set_param_hi_stop", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_hi_stop_616, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_hi_stop_616_comment},
  {"setParamHiStop", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_hi_stop_616, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_hi_stop_616_comment},
  {"set_param_vel", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_vel_617, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_vel_617_comment},
  {"setParamVel", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_vel_617, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_vel_617_comment},
  {"set_param_f_max", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_f_max_618, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_f_max_618_comment},
  {"setParamFMax", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_f_max_618, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_f_max_618_comment},
  {"set_param_fudge_factor", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_fudge_factor_619, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_fudge_factor_619_comment},
  {"setParamFudgeFactor", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_fudge_factor_619, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_fudge_factor_619_comment},
  {"set_param_bounce", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_bounce_620, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_bounce_620_comment},
  {"setParamBounce", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_bounce_620, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_bounce_620_comment},
  {"set_param_CFM", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_CFM_621, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_CFM_621_comment},
  {"setParamCFM", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_CFM_621, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_CFM_621_comment},
  {"set_param_stop_ERP", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_stop_ERP_622, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_stop_ERP_622_comment},
  {"setParamStopERP", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_stop_ERP_622, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_stop_ERP_622_comment},
  {"set_param_stop_CFM", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_stop_CFM_623, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_stop_CFM_623_comment},
  {"setParamStopCFM", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_stop_CFM_623, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_stop_CFM_623_comment},
  {"get_param_lo_stop", &Dtool_OdeUniversalJoint_get_param_lo_stop_624, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_lo_stop_624_comment},
  {"getParamLoStop", &Dtool_OdeUniversalJoint_get_param_lo_stop_624, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_lo_stop_624_comment},
  {"get_param_hi_stop", &Dtool_OdeUniversalJoint_get_param_hi_stop_625, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_hi_stop_625_comment},
  {"getParamHiStop", &Dtool_OdeUniversalJoint_get_param_hi_stop_625, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_hi_stop_625_comment},
  {"get_param_vel", &Dtool_OdeUniversalJoint_get_param_vel_626, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_vel_626_comment},
  {"getParamVel", &Dtool_OdeUniversalJoint_get_param_vel_626, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_vel_626_comment},
  {"get_param_f_max", &Dtool_OdeUniversalJoint_get_param_f_max_627, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_f_max_627_comment},
  {"getParamFMax", &Dtool_OdeUniversalJoint_get_param_f_max_627, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_f_max_627_comment},
  {"get_param_fudge_factor", &Dtool_OdeUniversalJoint_get_param_fudge_factor_628, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_fudge_factor_628_comment},
  {"getParamFudgeFactor", &Dtool_OdeUniversalJoint_get_param_fudge_factor_628, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_fudge_factor_628_comment},
  {"get_param_bounce", &Dtool_OdeUniversalJoint_get_param_bounce_629, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_bounce_629_comment},
  {"getParamBounce", &Dtool_OdeUniversalJoint_get_param_bounce_629, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_bounce_629_comment},
  {"get_param_CFM", &Dtool_OdeUniversalJoint_get_param_CFM_630, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_CFM_630_comment},
  {"getParamCFM", &Dtool_OdeUniversalJoint_get_param_CFM_630, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_CFM_630_comment},
  {"get_param_stop_ERP", &Dtool_OdeUniversalJoint_get_param_stop_ERP_631, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_stop_ERP_631_comment},
  {"getParamStopERP", &Dtool_OdeUniversalJoint_get_param_stop_ERP_631, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_stop_ERP_631_comment},
  {"get_param_stop_CFM", &Dtool_OdeUniversalJoint_get_param_stop_CFM_632, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_stop_CFM_632_comment},
  {"getParamStopCFM", &Dtool_OdeUniversalJoint_get_param_stop_CFM_632, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_stop_CFM_632_comment},
  {"get_class_type", &Dtool_OdeUniversalJoint_get_class_type_633, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeUniversalJoint_get_class_type_633_comment},
  {"getClassType", &Dtool_OdeUniversalJoint_get_class_type_633, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeUniversalJoint_get_class_type_633_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeUniversalJoint = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeUniversalJoint = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OdeUniversalJoint = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OdeUniversalJoint = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OdeUniversalJoint = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeUniversalJoint",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeUniversalJoint,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeUniversalJoint,
    &Dtool_SequenceMethods_OdeUniversalJoint,
    &Dtool_MappingMethods_OdeUniversalJoint,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OdeUniversalJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeUniversalJoint,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeUniversalJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeUniversalJoint,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeUniversalJoint,
  Dtool_UpcastInterface_OdeUniversalJoint,
  Dtool_DowncastInterface_OdeUniversalJoint,
  (CoerceFunction)Dtool_ConstCoerce_OdeUniversalJoint,
  (CoerceFunction)Dtool_Coerce_OdeUniversalJoint,
};

static void Dtool_PyModuleClassInit_OdeUniversalJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(NULL);
    Dtool_OdeUniversalJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    PyObject *dict = PyDict_New();
    Dtool_OdeUniversalJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeUniversalJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeUniversalJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeUniversalJoint);
  }
}

/**
 * Python method tables for OdeUtil (OdeUtil)
 */
static PyMethodDef Dtool_Methods_OdeUtil[] = {
  {"get_connecting_joint", (PyCFunction) &Dtool_OdeUtil_get_connecting_joint_635, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_get_connecting_joint_635_comment},
  {"getConnectingJoint", (PyCFunction) &Dtool_OdeUtil_get_connecting_joint_635, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_get_connecting_joint_635_comment},
  {"get_connecting_joint_list", (PyCFunction) &Dtool_OdeUtil_get_connecting_joint_list_636, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_get_connecting_joint_list_636_comment},
  {"getConnectingJointList", (PyCFunction) &Dtool_OdeUtil_get_connecting_joint_list_636, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_get_connecting_joint_list_636_comment},
  {"are_connected", (PyCFunction) &Dtool_OdeUtil_are_connected_637, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_are_connected_637_comment},
  {"areConnected", (PyCFunction) &Dtool_OdeUtil_are_connected_637, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_are_connected_637_comment},
  {"are_connected_excluding", (PyCFunction) &Dtool_OdeUtil_are_connected_excluding_638, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_are_connected_excluding_638_comment},
  {"areConnectedExcluding", (PyCFunction) &Dtool_OdeUtil_are_connected_excluding_638, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_are_connected_excluding_638_comment},
  {"collide", (PyCFunction) &Dtool_OdeUtil_collide_639, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_collide_639_comment},
  {"collide2", (PyCFunction) &Dtool_OdeUtil_collide2_640, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_collide2_640_comment},
  {"space_to_geom", &Dtool_OdeUtil_space_to_geom_641, METH_O | METH_STATIC, (const char *)Dtool_OdeUtil_space_to_geom_641_comment},
  {"spaceToGeom", &Dtool_OdeUtil_space_to_geom_641, METH_O | METH_STATIC, (const char *)Dtool_OdeUtil_space_to_geom_641_comment},
  {"get_infinity", &Dtool_OdeUtil_get_infinity_642, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeUtil_get_infinity_642_comment},
  {"getInfinity", &Dtool_OdeUtil_get_infinity_642, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeUtil_get_infinity_642_comment},
  {"rand_get_seed", &Dtool_OdeUtil_rand_get_seed_643, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeUtil_rand_get_seed_643_comment},
  {"randGetSeed", &Dtool_OdeUtil_rand_get_seed_643, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeUtil_rand_get_seed_643_comment},
  {"rand_set_seed", &Dtool_OdeUtil_rand_set_seed_644, METH_O | METH_STATIC, (const char *)Dtool_OdeUtil_rand_set_seed_644_comment},
  {"randSetSeed", &Dtool_OdeUtil_rand_set_seed_644, METH_O | METH_STATIC, (const char *)Dtool_OdeUtil_rand_set_seed_644_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OdeUtil = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_OdeUtil = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.ode.OdeUtil",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeUtil,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OdeUtil,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OdeUtil,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OdeUtil,
    PyType_GenericAlloc,
    Dtool_new_OdeUtil,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeUtil,
  Dtool_UpcastInterface_OdeUtil,
  Dtool_DowncastInterface_OdeUtil,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_OdeUtil(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_OdeUtil._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_OdeUtil._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeUtil) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeUtil)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeUtil);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libpandaode_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("dxBody", Dtool_dxBody);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("dxGeom", Dtool_dxGeom);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("dxJoint", Dtool_dxJoint);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("dxJointGroup", Dtool_dxJointGroup);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("dxSpace", Dtool_dxSpace);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("dxTriMeshData", Dtool_dxTriMeshData);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("dxWorld", Dtool_dxWorld);
#endif
  Dtool_OdeWorld._type = OdeWorld::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeWorld);
  Dtool_OdeJointGroup._type = OdeJointGroup::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeJointGroup);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("OdeJointFeedback", Dtool_OdeJointFeedback);
#endif
  Dtool_OdeJoint._type = OdeJoint::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeJoint);
  Dtool_OdeAMotorJoint._type = OdeAMotorJoint::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeAMotorJoint);
  Dtool_OdeBallJoint._type = OdeBallJoint::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeBallJoint);
  Dtool_OdeMass._type = OdeMass::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeMass);
  Dtool_OdeBody._type = OdeBody::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeBody);
  Dtool_OdeSpace._type = OdeSpace::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeSpace);
  Dtool_OdeGeom._type = OdeGeom::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeGeom);
  Dtool_OdeBoxGeom._type = OdeBoxGeom::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeBoxGeom);
  Dtool_OdeCappedCylinderGeom._type = OdeCappedCylinderGeom::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeCappedCylinderGeom);
  Dtool_OdeContactGeom._type = OdeContactGeom::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeContactGeom);
  Dtool_OdeCollisionEntry._type = OdeCollisionEntry::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeCollisionEntry);
  Dtool_OdeSurfaceParameters._type = OdeSurfaceParameters::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeSurfaceParameters);
  Dtool_OdeContact._type = OdeContact::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeContact);
  Dtool_OdeContactJoint._type = OdeContactJoint::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeContactJoint);
  Dtool_OdeCylinderGeom._type = OdeCylinderGeom::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeCylinderGeom);
  Dtool_OdeFixedJoint._type = OdeFixedJoint::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeFixedJoint);
  Dtool_OdeHashSpace._type = OdeHashSpace::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeHashSpace);
  Dtool_OdeHinge2Joint._type = OdeHinge2Joint::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeHinge2Joint);
  Dtool_OdeHingeJoint._type = OdeHingeJoint::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeHingeJoint);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("OdeJointCollection", Dtool_OdeJointCollection);
#endif
  Dtool_OdeLMotorJoint._type = OdeLMotorJoint::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeLMotorJoint);
  Dtool_OdeNullJoint._type = OdeNullJoint::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeNullJoint);
  Dtool_OdePlane2dJoint._type = OdePlane2dJoint::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdePlane2dJoint);
  Dtool_OdePlaneGeom._type = OdePlaneGeom::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdePlaneGeom);
  Dtool_OdeQuadTreeSpace._type = OdeQuadTreeSpace::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeQuadTreeSpace);
  Dtool_OdeRayGeom._type = OdeRayGeom::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeRayGeom);
  Dtool_OdeSimpleSpace._type = OdeSimpleSpace::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeSimpleSpace);
  Dtool_OdeSliderJoint._type = OdeSliderJoint::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeSliderJoint);
  Dtool_OdeSphereGeom._type = OdeSphereGeom::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeSphereGeom);
  Dtool_OdeTriMeshData._type = OdeTriMeshData::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeTriMeshData);
  Dtool_OdeTriMeshGeom._type = OdeTriMeshGeom::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeTriMeshGeom);
  Dtool_OdeUniversalJoint._type = OdeUniversalJoint::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OdeUniversalJoint);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("OdeUtil", Dtool_OdeUtil);
#endif
}

void Dtool_libpandaode_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_LVector3f = LookupRuntimeTypedClass(LVector3f::get_class_type());
  Dtool_Ptr_LVecBase3f = LookupRuntimeTypedClass(LVecBase3f::get_class_type());
  Dtool_Ptr_LPoint3f = LookupRuntimeTypedClass(LPoint3f::get_class_type());
  Dtool_Ptr_LVecBase4f = LookupRuntimeTypedClass(LVecBase4f::get_class_type());
  Dtool_Ptr_LMatrix3f = LookupRuntimeTypedClass(LMatrix3f::get_class_type());
  Dtool_Ptr_LQuaternionf = LookupRuntimeTypedClass(LQuaternionf::get_class_type());
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_BitMask_uint32_t_32 = LookupRuntimeTypedClass(BitMask< uint32_t, 32 >::get_class_type());
  Dtool_Ptr_NodePath = LookupRuntimeTypedClass(NodePath::get_class_type());
#endif
}

void Dtool_libpandaode_BuildInstants(PyObject *module) {
  (void) module;
  // dxBody
  Dtool_PyModuleClassInit_dxBody(module);
  PyModule_AddObject(module, "dxBody", (PyObject *)&Dtool_dxBody);
  Py_INCREF(Dtool_Ptr_dxBody);
  PyModule_AddObject(module, "DxBody", (PyObject *)&Dtool_dxBody);
  // dxGeom
  Dtool_PyModuleClassInit_dxGeom(module);
  PyModule_AddObject(module, "dxGeom", (PyObject *)&Dtool_dxGeom);
  Py_INCREF(Dtool_Ptr_dxGeom);
  PyModule_AddObject(module, "DxGeom", (PyObject *)&Dtool_dxGeom);
  // dxJoint
  Dtool_PyModuleClassInit_dxJoint(module);
  PyModule_AddObject(module, "dxJoint", (PyObject *)&Dtool_dxJoint);
  Py_INCREF(Dtool_Ptr_dxJoint);
  PyModule_AddObject(module, "DxJoint", (PyObject *)&Dtool_dxJoint);
  // dxJointGroup
  Dtool_PyModuleClassInit_dxJointGroup(module);
  PyModule_AddObject(module, "dxJointGroup", (PyObject *)&Dtool_dxJointGroup);
  Py_INCREF(Dtool_Ptr_dxJointGroup);
  PyModule_AddObject(module, "DxJointGroup", (PyObject *)&Dtool_dxJointGroup);
  // dxSpace
  Dtool_PyModuleClassInit_dxSpace(module);
  PyModule_AddObject(module, "dxSpace", (PyObject *)&Dtool_dxSpace);
  Py_INCREF(Dtool_Ptr_dxSpace);
  PyModule_AddObject(module, "DxSpace", (PyObject *)&Dtool_dxSpace);
  // dxTriMeshData
  Dtool_PyModuleClassInit_dxTriMeshData(module);
  PyModule_AddObject(module, "dxTriMeshData", (PyObject *)&Dtool_dxTriMeshData);
  Py_INCREF(Dtool_Ptr_dxTriMeshData);
  PyModule_AddObject(module, "DxTriMeshData", (PyObject *)&Dtool_dxTriMeshData);
  // dxWorld
  Dtool_PyModuleClassInit_dxWorld(module);
  PyModule_AddObject(module, "dxWorld", (PyObject *)&Dtool_dxWorld);
  Py_INCREF(Dtool_Ptr_dxWorld);
  PyModule_AddObject(module, "DxWorld", (PyObject *)&Dtool_dxWorld);
  // OdeWorld
  Dtool_PyModuleClassInit_OdeWorld(module);
  PyModule_AddObject(module, "OdeWorld", (PyObject *)&Dtool_OdeWorld);
  // OdeJointGroup
  Dtool_PyModuleClassInit_OdeJointGroup(module);
  PyModule_AddObject(module, "OdeJointGroup", (PyObject *)&Dtool_OdeJointGroup);
  // OdeJointFeedback
  Dtool_PyModuleClassInit_OdeJointFeedback(module);
  PyModule_AddObject(module, "OdeJointFeedback", (PyObject *)&Dtool_OdeJointFeedback);
  // OdeJoint
  Dtool_PyModuleClassInit_OdeJoint(module);
  PyModule_AddObject(module, "OdeJoint", (PyObject *)&Dtool_OdeJoint);
  // OdeAMotorJoint
  Dtool_PyModuleClassInit_OdeAMotorJoint(module);
  PyModule_AddObject(module, "OdeAMotorJoint", (PyObject *)&Dtool_OdeAMotorJoint);
  // OdeBallJoint
  Dtool_PyModuleClassInit_OdeBallJoint(module);
  PyModule_AddObject(module, "OdeBallJoint", (PyObject *)&Dtool_OdeBallJoint);
  // OdeMass
  Dtool_PyModuleClassInit_OdeMass(module);
  PyModule_AddObject(module, "OdeMass", (PyObject *)&Dtool_OdeMass);
  // OdeBody
  Dtool_PyModuleClassInit_OdeBody(module);
  PyModule_AddObject(module, "OdeBody", (PyObject *)&Dtool_OdeBody);
  // OdeSpace
  Dtool_PyModuleClassInit_OdeSpace(module);
  PyModule_AddObject(module, "OdeSpace", (PyObject *)&Dtool_OdeSpace);
  // OdeGeom
  Dtool_PyModuleClassInit_OdeGeom(module);
  PyModule_AddObject(module, "OdeGeom", (PyObject *)&Dtool_OdeGeom);
  // OdeBoxGeom
  Dtool_PyModuleClassInit_OdeBoxGeom(module);
  PyModule_AddObject(module, "OdeBoxGeom", (PyObject *)&Dtool_OdeBoxGeom);
  // OdeCappedCylinderGeom
  Dtool_PyModuleClassInit_OdeCappedCylinderGeom(module);
  PyModule_AddObject(module, "OdeCappedCylinderGeom", (PyObject *)&Dtool_OdeCappedCylinderGeom);
  // OdeContactGeom
  Dtool_PyModuleClassInit_OdeContactGeom(module);
  PyModule_AddObject(module, "OdeContactGeom", (PyObject *)&Dtool_OdeContactGeom);
  // OdeCollisionEntry
  Dtool_PyModuleClassInit_OdeCollisionEntry(module);
  PyModule_AddObject(module, "OdeCollisionEntry", (PyObject *)&Dtool_OdeCollisionEntry);
  // OdeSurfaceParameters
  Dtool_PyModuleClassInit_OdeSurfaceParameters(module);
  PyModule_AddObject(module, "OdeSurfaceParameters", (PyObject *)&Dtool_OdeSurfaceParameters);
  // OdeContact
  Dtool_PyModuleClassInit_OdeContact(module);
  PyModule_AddObject(module, "OdeContact", (PyObject *)&Dtool_OdeContact);
  // OdeContactJoint
  Dtool_PyModuleClassInit_OdeContactJoint(module);
  PyModule_AddObject(module, "OdeContactJoint", (PyObject *)&Dtool_OdeContactJoint);
  // OdeCylinderGeom
  Dtool_PyModuleClassInit_OdeCylinderGeom(module);
  PyModule_AddObject(module, "OdeCylinderGeom", (PyObject *)&Dtool_OdeCylinderGeom);
  // OdeFixedJoint
  Dtool_PyModuleClassInit_OdeFixedJoint(module);
  PyModule_AddObject(module, "OdeFixedJoint", (PyObject *)&Dtool_OdeFixedJoint);
  // OdeHashSpace
  Dtool_PyModuleClassInit_OdeHashSpace(module);
  PyModule_AddObject(module, "OdeHashSpace", (PyObject *)&Dtool_OdeHashSpace);
  // OdeHinge2Joint
  Dtool_PyModuleClassInit_OdeHinge2Joint(module);
  PyModule_AddObject(module, "OdeHinge2Joint", (PyObject *)&Dtool_OdeHinge2Joint);
  // OdeHingeJoint
  Dtool_PyModuleClassInit_OdeHingeJoint(module);
  PyModule_AddObject(module, "OdeHingeJoint", (PyObject *)&Dtool_OdeHingeJoint);
  // OdeJointCollection
  Dtool_PyModuleClassInit_OdeJointCollection(module);
  PyModule_AddObject(module, "OdeJointCollection", (PyObject *)&Dtool_OdeJointCollection);
  // OdeLMotorJoint
  Dtool_PyModuleClassInit_OdeLMotorJoint(module);
  PyModule_AddObject(module, "OdeLMotorJoint", (PyObject *)&Dtool_OdeLMotorJoint);
  // OdeNullJoint
  Dtool_PyModuleClassInit_OdeNullJoint(module);
  PyModule_AddObject(module, "OdeNullJoint", (PyObject *)&Dtool_OdeNullJoint);
  // OdePlane2dJoint
  Dtool_PyModuleClassInit_OdePlane2dJoint(module);
  PyModule_AddObject(module, "OdePlane2dJoint", (PyObject *)&Dtool_OdePlane2dJoint);
  // OdePlaneGeom
  Dtool_PyModuleClassInit_OdePlaneGeom(module);
  PyModule_AddObject(module, "OdePlaneGeom", (PyObject *)&Dtool_OdePlaneGeom);
  // OdeQuadTreeSpace
  Dtool_PyModuleClassInit_OdeQuadTreeSpace(module);
  PyModule_AddObject(module, "OdeQuadTreeSpace", (PyObject *)&Dtool_OdeQuadTreeSpace);
  // OdeRayGeom
  Dtool_PyModuleClassInit_OdeRayGeom(module);
  PyModule_AddObject(module, "OdeRayGeom", (PyObject *)&Dtool_OdeRayGeom);
  // OdeSimpleSpace
  Dtool_PyModuleClassInit_OdeSimpleSpace(module);
  PyModule_AddObject(module, "OdeSimpleSpace", (PyObject *)&Dtool_OdeSimpleSpace);
  // OdeSliderJoint
  Dtool_PyModuleClassInit_OdeSliderJoint(module);
  PyModule_AddObject(module, "OdeSliderJoint", (PyObject *)&Dtool_OdeSliderJoint);
  // OdeSphereGeom
  Dtool_PyModuleClassInit_OdeSphereGeom(module);
  PyModule_AddObject(module, "OdeSphereGeom", (PyObject *)&Dtool_OdeSphereGeom);
  // OdeTriMeshData
  Dtool_PyModuleClassInit_OdeTriMeshData(module);
  PyModule_AddObject(module, "OdeTriMeshData", (PyObject *)&Dtool_OdeTriMeshData);
  // OdeTriMeshGeom
  Dtool_PyModuleClassInit_OdeTriMeshGeom(module);
  PyModule_AddObject(module, "OdeTriMeshGeom", (PyObject *)&Dtool_OdeTriMeshGeom);
  // OdeUniversalJoint
  Dtool_PyModuleClassInit_OdeUniversalJoint(module);
  PyModule_AddObject(module, "OdeUniversalJoint", (PyObject *)&Dtool_OdeUniversalJoint);
  // OdeUtil
  Dtool_PyModuleClassInit_OdeUtil(module);
  PyModule_AddObject(module, "OdeUtil", (PyObject *)&Dtool_OdeUtil);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libpandaode_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478214176,  /* file_identifier */
  "libpandaode",  /* library_name */
  "sTqO",  /* library_hash_name */
  "panda3d.ode",  /* module_name */
  "libpandaode.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  1518  /* next_index */
};

Configure(_in_configure_libpandaode);
ConfigureFn(_in_configure_libpandaode) {
  interrogate_request_module(&_in_module_def);
}

